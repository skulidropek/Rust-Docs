public class AboutYou : BaseMonoBehaviour {
    public Text username;
    public RawImage avatar;
    public Text subtitle;
}
public class AccessbilityMaterialPropertyBlock : AccessibilityComponent {
    public Renderer TargetRenderer;
    public string TagName;
    public AccessibilityColourCollection ForData;
}
public class AccessibilityCollection`1 : BaseScriptableObject {
    public string convarName;
    public T[] AllOptions;
}
[CreateAssetMenuAttribute]
public class AccessibilityColourCollection : AccessibilityCollection`1<ColourPair> {
}
public abstract class AccessibilityComponent : ListComponent`1<AccessibilityComponent> {
}
public class AccessibilityDecalMaterial : AccessibilityComponent {
    public DeferredDecal DecalRenderer;
    public AccessibilityMaterialCollection TargetData;
}
[CreateAssetMenuAttribute]
public class AccessibilityMaterialCollection : AccessibilityCollection`1<MaterialOption> {
}
public class AccessibilityMaterialSprite : AccessibilityComponent {
    public Image TargetImage;
    public AccessibilityMaterialCollection TargetData;
}
public class AccessibilityMaterialSwap : AccessibilityComponent {
    public AccessibilityMaterialCollection ForData;
    public Renderer ForRenderer;
}
public class AccessibilitySpriteColour : AccessibilityComponent {
    public AccessibilityColourCollection TargetData;
    public Image SpriteA;
    public Image SpriteB;
}
public class Achievements : SingletonComponent`1<Achievements> {
    public SoundDefinition listComplete;
    public SoundDefinition itemComplete;
    public SoundDefinition popup;
    public Canvas Canvas;
    public Text titleText;
}
public class AchievementTodo : BaseMonoBehaviour {
    public Text text;
    public RectTransform checkIcon;
    public RectTransform checkBox;
    public Color AliveColor;
    public Color DeadColor;
    public Color HighlightColor;
}
public enum ActionPriority : Enum {
    public int value__;
    public static ActionPriority Highest;
    public static ActionPriority High;
    public static ActionPriority Medium;
    public static ActionPriority Low;
    public static ActionPriority Lowest;
}
[ExecuteInEditMode]
public class AdaptMeshToTerrain : MonoBehaviour {
    public LayerMask LayerMask;
    public float RayHeight;
    public float RayMaxDistance;
    public float MinDisplacement;
    public float MaxDisplacement;
    [RangeAttribute("8", "64")]
public int PlaneResolution;
}
public class AddNewEventUIButton : MonoBehaviour {
}
public class AddNewStateUIButton : MonoBehaviour {
}
public class AddSellOrderManager : MonoBehaviour {
    public VirtualItemIcon sellItemIcon;
    public VirtualItemIcon currencyItemIcon;
    public GameObject itemSearchParent;
    public ItemSearchEntry itemSearchEntryPrefab;
    public InputField sellItemInput;
    public InputField sellItemAmount;
    public InputField currencyItemInput;
    public InputField currencyItemAmount;
    public VendingPanelAdmin adminPanel;
}
public class AddToAlphaMap : ProceduralObject {
    public Bounds bounds;
    public virtual void Process();
}
public class AddToHeightMap : ProceduralObject {
    public bool DestroyGameObject;
    public void Apply();
    public virtual void Process();
}
public class AddToWaterMap : ProceduralObject {
    public bool automaticallyAddTerrainTopology;
    public virtual void Process();
}
public class AdminExistingSellOrder : MonoBehaviour {
    public VirtualItemIcon MerchandiseIcon;
    public VirtualItemIcon CurrencyIcon;
    private VendingPanelAdmin adminPanel;
    private int index;
}
public class AdminUI : MonoBehaviour {
    public bool AllowInDemo;
    public GameObject TargetGameObject;
}
public class AdvancedChristmasLights : IOEntity {
    public GameObjectRef bulbPrefab;
    public LineRenderer lineRenderer;
    public List`1<pointEntry> points;
    public List`1<BaseBulb> bulbs;
    public float bulbSpacing;
    public float wireThickness;
    public Transform wireEmission;
    public AnimationType animationStyle;
    public RendererLOD _lod;
    [TooltipAttribute("This many units used will result in +1 power usage")]
public float lengthToPowerRatio;
    private bool finalized;
    private int lengthUsed;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void ClearPoints();
    public void FinishEditing();
    public bool IsFinalized();
    public void AddPoint(Vector3 newPoint, Vector3 newNormal, float slackLevel);
    public virtual int ConsumptionAmount();
    protected virtual int GetPickupCount();
    public void AddLengthUsed(int addLength);
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public bool CanPlayerManipulate(BasePlayer player);
    [IsVisible("3")]
[RPC_Server]
public void SetAnimationStyle(RPCMessage msg);
}
public class AdventCalendar : BaseCombatEntity {
    public int startMonth;
    public int startDay;
    public DayReward[] days;
    public GameObject[] crosses;
    public static List`1<AdventCalendar> all;
    public static Dictionary`2<ulong, List`1<int>> playerRewardHistory;
    public static Phrase CheckLater;
    public static Phrase EventOver;
    public GameObjectRef giftEffect;
    public GameObjectRef boxCloseEffect;
    [ServerVar]
public static int overrideAdventCalendarDay;
    [ServerVar]
public static int overrideAdventCalendarMonth;
    private static AdventCalendar();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public void AwardGift(BasePlayer player);
    public bool WasAwardedTodaysGift(BasePlayer player);
    [CallsPerSecond("1")]
[RPC_Server]
[IsVisible("3")]
public void RPC_RequestGift(RPCMessage msg);
}
public class AggressionTimerAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; private set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class AggressionTimerEventUI : BaseEventUI {
}
public class AIArena : MonoBehaviour {
}
public class AIArenaNameTag : MonoBehaviour {
    public BasePlayer Entity;
    public bool ShowHealth;
    public bool ShowName;
    private string trimmedName;
}
public class AIBrainSenses : object {
    [ServerVar]
public static float UpdateInterval;
    [ServerVar]
public static float HumanKnownPlayersLOSUpdateInterval;
    [ServerVar]
public static float KnownPlayersLOSUpdateInterval;
    public float knownPlayersLOSUpdateInterval;
    public float MemoryDuration;
    public float LastThreatTimestamp;
    public float TimeInAgressiveState;
    [CompilerGeneratedAttribute]
private SimpleAIMemory <Memory>k__BackingField;
    public static BaseEntity[] queryResults;
    public static BasePlayer[] playerQueryResults;
    public float nextUpdateTime;
    public float nextKnownPlayersLOSUpdateTime;
    public BaseEntity owner;
    public BasePlayer playerOwner;
    public IAISenses ownerSenses;
    public float maxRange;
    public float targetLostRange;
    public float visionCone;
    public bool checkVision;
    public bool checkLOS;
    public bool ignoreNonVisionSneakers;
    public float listenRange;
    public bool hostileTargetsOnly;
    public bool senseFriendlies;
    public bool refreshKnownLOS;
    [CompilerGeneratedAttribute]
private bool <ignoreSafeZonePlayers>k__BackingField;
    public bool ignoreTutorialPlayers;
    public EntityType senseTypes;
    public IAIAttack ownerAttack;
    public BaseAIBrain brain;
    private Func`2<BaseEntity, bool> aiCaresAbout;
    public float TimeSinceThreat { get; }
    public SimpleAIMemory Memory { get; public set; }
    public float TargetLostRange { get; }
    public bool ignoreSafeZonePlayers { get; public set; }
    public List`1<BaseEntity> Players { get; }
    private static AIBrainSenses();
    public float get_TimeSinceThreat();
    [CompilerGeneratedAttribute]
public SimpleAIMemory get_Memory();
    [CompilerGeneratedAttribute]
public void set_Memory(SimpleAIMemory value);
    public float get_TargetLostRange();
    [CompilerGeneratedAttribute]
public bool get_ignoreSafeZonePlayers();
    [CompilerGeneratedAttribute]
public void set_ignoreSafeZonePlayers(bool value);
    public void Init(BaseEntity owner, BaseAIBrain brain, float memoryDuration, float range, float targetLostRange, float visionCone, bool checkVision, bool checkLOS, bool ignoreNonVisionSneakers, float listenRange, bool hostileTargetsOnly, bool senseFriendlies, bool ignoreSafeZonePlayers, EntityType senseTypes, bool refreshKnownLOS);
    public void DelaySenseUpdate(float delay);
    public void Update();
    private void UpdateSenses();
    public void UpdateKnownPlayersLOS();
    private void SensePlayers();
    private void SenseBrains();
    private bool AiCaresAbout(BaseEntity entity);
    private bool IsValidSenseType(BaseEntity ent);
    private bool IsTargetInVision(BaseEntity target);
    public BaseEntity GetNearestPlayer(float rangeFraction);
    public List`1<BaseEntity> get_Players();
    public BaseEntity GetNearestThreat(float rangeFraction);
    public BaseEntity GetNearestTarget(float rangeFraction);
    private BaseEntity GetNearest(List`1<BaseEntity> entities, float rangeFraction);
}
public class AICoverPoint : AIPoint {
    public float coverDot;
    public void OnDrawGizmos();
}
public class AICoverPointTool : MonoBehaviour {
    [ContextMenu("Place Cover Points")]
public void PlaceCoverPoints();
    private TestResult TestPoint(Vector3 pos);
    private void PlacePoint(TestResult result);
    private void PlacePoint(Vector3 pos, Vector3 dir);
    public bool HitsCover(Ray ray, int layerMask, float maxDistance);
}
public class AIDesign : object {
    [CompilerGeneratedAttribute]
private AIDesignScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public List`1<AIState> AvailableStates;
    public int DefaultStateContainerID;
    private Dictionary`2<int, AIStateContainer> stateContainers;
    public AIDesignScope Scope { get; private set; }
    public string Description { get; private set; }
    [CompilerGeneratedAttribute]
public AIDesignScope get_Scope();
    [CompilerGeneratedAttribute]
private void set_Scope(AIDesignScope value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    public void SetAvailableStates(List`1<AIState> states);
    public void Load(AIDesign design, BaseEntity owner);
    private void InitStateContainers(AIDesign design, BaseEntity owner);
    public AIStateContainer GetDefaultStateContainer();
    public AIStateContainer GetStateContainerByID(int id);
    public AIStateContainer GetFirstStateContainerOfType(AIState stateType);
    public AIDesign ToProto(int currentStateID);
}
public static class AIDesigns : object {
    public static string DesignFolderPath;
    private static Dictionary`2<string, AIDesign> designs;
    private static AIDesigns();
    public static AIDesign GetByNameOrInstance(string designName, AIDesign entityDesign);
    public static void RefreshCache(string designName, AIDesign design);
    private static AIDesign GetByName(string designName);
}
public enum AIDesignScope : Enum {
    public int value__;
    public static AIDesignScope Default;
    public static AIDesignScope EntityServerWide;
    public static AIDesignScope EntityInstance;
}
[CreateAssetMenuAttribute]
public class AIDesignSO : BaseScriptableObject {
    public string Filename;
}
public class AIEvents : object {
    public AIMemory Memory;
    [CompilerGeneratedAttribute]
private int <CurrentInputMemorySlot>k__BackingField;
    public List`1<BaseAIEvent> events;
    private IAIEventListener eventListener;
    public AIBrainSenses senses;
    private int currentEventIndex;
    private bool inBlock;
    public int CurrentInputMemorySlot { get; private set; }
    [CompilerGeneratedAttribute]
public int get_CurrentInputMemorySlot();
    [CompilerGeneratedAttribute]
private void set_CurrentInputMemorySlot(int value);
    public void Init(IAIEventListener listener, AIStateContainer stateContainer, BaseEntity owner, AIBrainSenses senses);
    public void RemoveAll();
    public void AddStateEvents(List`1<BaseAIEvent> events, BaseEntity owner);
    public void Add(BaseAIEvent aiEvent);
    public void Tick(float deltaTime, StateStatus stateStatus);
    private int FindNextEventBlock();
}
public enum AIEventType : Enum {
    public int value__;
    public static AIEventType Timer;
    public static AIEventType PlayerDetected;
    public static AIEventType StateError;
    public static AIEventType Attacked;
    public static AIEventType StateFinished;
    public static AIEventType InAttackRange;
    public static AIEventType HealthBelow;
    public static AIEventType InRange;
    public static AIEventType PerformedAttack;
    public static AIEventType TirednessAbove;
    public static AIEventType HungerAbove;
    public static AIEventType ThreatDetected;
    public static AIEventType TargetDetected;
    public static AIEventType AmmoBelow;
    public static AIEventType BestTargetDetected;
    public static AIEventType IsVisible;
    public static AIEventType AttackTick;
    public static AIEventType IsMounted;
    public static AIEventType And;
    public static AIEventType Chance;
    public static AIEventType TargetLost;
    public static AIEventType TimeSinceThreat;
    public static AIEventType OnPositionMemorySet;
    public static AIEventType AggressionTimer;
    public static AIEventType Reloading;
    public static AIEventType InRangeOfHome;
    public static AIEventType IsBlinded;
}
public class AIHelicopterAnimation : MonoBehaviour {
    public PatrolHelicopterAI _ai;
    public float swayAmount;
    public float impactSwayAmount;
    public float lastStrafeScalar;
    public float lastForwardBackScalar;
    public float degreeMax;
    public Vector3 lastPosition;
    public float oldMoveSpeed;
    public float smoothRateOfChange;
    public float flareAmount;
    public float swaySmoothingFactor;
    private float smoothedTime;
    private void Awake();
    public void UpdateAnimation();
    public void UpdateLastPosition();
    private void UpdateForwardBackTilting();
    private void UpdateStrafeTilting();
    private void ModifyHelicopterAngles();
    private Vector3 GetCurrentMoveDirection();
}
public class AIInformationCell : object {
    public Bounds BoundingBox;
    public List`1<AIInformationCell> NeighbourCells;
    public AIInformationCellContents`1<AIMovePoint> MovePoints;
    public AIInformationCellContents`1<AICoverPoint> CoverPoints;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Z>k__BackingField;
    public int X { get; }
    public int Z { get; }
    public AIInformationCell(Bounds bounds, GameObject root, int x, int z);
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public int get_Z();
    public void DebugDraw(Color color, bool points, float scale);
}
public class AIInformationCellContents`1 : object {
    public HashSet`1<T> Items;
    public int Count { get; }
    public bool Empty { get; }
    public int get_Count();
    public bool get_Empty();
    public void Init(Bounds cellBounds, GameObject root);
    public void Clear();
    public void Add(T item);
    public void Remove(T item);
}
public class AIInformationGrid : MonoBehaviour {
    public int CellSize;
    public Bounds BoundingBox;
    public AIInformationCell[] Cells;
    private Vector3 origin;
    private int xCellCount;
    private int zCellCount;
    private static int maxPointResults;
    private AIMovePoint[] movePointResults;
    private AICoverPoint[] coverPointResults;
    private static int maxCellResults;
    private AIInformationCell[] resultCells;
    [ContextMenu("Init")]
public void Init();
    private int GetIndex(int x, int z);
    public AIInformationCell CellAt(int x, int z);
    public AIMovePoint[] GetMovePointsInRange(Vector3 position, float maxRange, Int32& pointCount);
    public AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, Int32& pointCount);
    public AIInformationCell[] GetCellsInRange(Vector3 position, float maxRange, Int32& cellCount);
    public AIInformationCell GetCell(Vector3 position);
    public void OnDrawGizmos();
    public void DebugDraw();
}
public class AIInformationGridTester : MonoBehaviour {
    public AIInformationGrid Grid;
    public float Range;
}
public class AIInformationZone : BaseMonoBehaviour {
    public bool RenderBounds;
    public bool ShouldSleepAI;
    public bool Virtual;
    public bool UseCalculatedCoverDistances;
    public static List`1<AIInformationZone> zones;
    public List`1<AICoverPoint> coverPoints;
    public List`1<AIMovePoint> movePoints;
    private AICoverPoint[] coverPointArray;
    private AIMovePoint[] movePointArray;
    public List`1<NavMeshLink> navMeshLinks;
    public List`1<AIMovePointPath> paths;
    public Bounds bounds;
    public bool SetMovePointTerrainYOnEnable;
    private AIInformationGrid grid;
    [ServerVar]
public static bool UseSimpleLOSCheck;
    [CompilerGeneratedAttribute]
private bool <Sleeping>k__BackingField;
    private List`1<IAISleepable> sleepables;
    private OBB areaBox;
    private bool isDirty;
    private int processIndex;
    private int halfPaths;
    private int pathSuccesses;
    private int pathFails;
    private bool initd;
    private static bool lastFrameAnyDirty;
    private static float rebuildStartTime;
    public static float buildTimeTest;
    private static float lastNavmeshBuildTime;
    public bool Sleeping { get; private set; }
    public int SleepingCount { get; }
    private static AIInformationZone();
    public static AIInformationZone Merge(List`1<AIInformationZone> zones, GameObject newRoot);
    public static Bounds EncapsulateBounds(List`1<AIInformationZone> zones);
    [CompilerGeneratedAttribute]
public bool get_Sleeping();
    [CompilerGeneratedAttribute]
private void set_Sleeping(bool value);
    public int get_SleepingCount();
    public void Start();
    private void OnEnable();
    private void OnDisable();
    public void Init();
    private void SetMovePointsY(int layerMask, float yStartOffset, float yDistance, float localYDefault);
    public void RegisterSleepableEntity(IAISleepable sleepable);
    public void UnregisterSleepableEntity(IAISleepable sleepable);
    public void SleepAI();
    public void WakeAI();
    private void AddCoverPoint(AICoverPoint point);
    private void RemoveCoverPoint(AICoverPoint point, bool markDirty);
    private void AddMovePoint(AIMovePoint point);
    private void RemoveMovePoint(AIMovePoint point, bool markDirty);
    public void MarkDirty(bool completeRefresh);
    private bool PassesBudget(float startTime, float budgetSeconds);
    public bool ProcessDistancesAttempt();
    private bool ProcessDistances();
    public static void BudgetedTick();
    public void NavmeshBuildingComplete();
    public Vector3 ClosestPointTo(Vector3 target);
    public void AddInitialPoints();
    private void RefreshPointArrays();
    public void AddDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints, Func`2<Vector3, bool> validatePoint);
    public void RemoveDynamicAIPoints(AIMovePoint[] movePoints, AICoverPoint[] coverPoints);
    public AIMovePointPath GetNearestPath(Vector3 position);
    public static AIInformationZone GetForPoint(Vector3 point, bool fallBackToNearest);
    public bool PointInside(Vector3 point);
    public AIMovePoint GetBestMovePointNear(BaseEntity targetEntity, BaseEntity fromEntity, float minRange, float maxRange, bool checkLOS, BaseEntity forObject, bool returnClosest, bool returnRandom);
    public AIPoint[] GetMovePointsInRange(Vector3 currentPos, float maxRange, Int32& pointCount);
    private AIMovePoint GetClosestRaw(Vector3 pos, bool onlyIncludeWithCover);
    public AICoverPoint GetBestCoverPoint(Vector3 currentPosition, Vector3 hideFromPosition, float minRange, float maxRange, BaseEntity forObject, bool allowObjectToReuse);
    private AICoverPoint[] GetCoverPointsInRange(Vector3 position, float maxRange, Int32& pointCount);
    public NavMeshLink GetClosestNavMeshLink(Vector3 pos);
}
public class AimConeUtil : object {
    public static Vector3 GetModifiedAimConeDirection(float aimCone, Vector3 inputVec, bool anywhereInside);
    public static Quaternion GetAimConeQuat(float aimCone);
}
public class AIMemory : object {
    public AIMemoryBank`1<BaseEntity> Entity;
    public AIMemoryBank`1<Vector3> Position;
    public AIMemoryBank`1<AIPoint> AIPoint;
    public void Clear();
}
public class AIMemoryBank`1 : object {
    private MemoryBankType type;
    private T[] slots;
    private Single[] slotSetTimestamps;
    private int slotCount;
    public AIMemoryBank`1(MemoryBankType type, int slots);
    public void Init(MemoryBankType type, int slots);
    public void Set(T item, int index);
    public T Get(int index);
    public float GetTimeSinceSet(int index);
    public void Remove(int index);
    public void Clear();
}
public class AIMovePoint : AIPoint {
    public ListDictionary`2<AIMovePoint, float> distances;
    public ListDictionary`2<AICoverPoint, float> distancesToCover;
    public float radius;
    public float WaitTime;
    public List`1<Transform> LookAtPoints;
    public void OnDrawGizmos();
    public void DrawLookAtPoints();
    public void Clear();
    public void AddLookAtPoint(Transform transform);
    public bool HasLookAtPoints();
    public Transform GetRandomLookAtPoint();
}
public class AIMovePointPath : MonoBehaviour {
    public Color DebugPathColor;
    public Mode LoopMode;
    public List`1<AIMovePoint> Points;
    public void Clear();
    public void AddPoint(AIMovePoint point);
    public AIMovePoint FindNearestPoint(Vector3 position);
    public int FindNearestPointIndex(Vector3 position);
    public AIMovePoint GetPointAtIndex(int index);
    public int GetNextPointIndex(int currentPointIndex, PathDirection& pathDirection);
    private void OnDrawGizmos();
    private void OnDrawGizmosSelected();
    [ContextMenu("Add Child Points")]
public void AddChildPoints();
}
public class AIPoint : BaseMonoBehaviour {
    private BaseEntity currentUser;
    public bool InUse();
    public bool IsUsedBy(BaseEntity user);
    public bool CanBeUsedBy(BaseEntity user);
    public void SetUsedBy(BaseEntity user, float duration);
    public void SetUsedBy(BaseEntity user);
    public void ClearUsed();
    public void ClearIfUsedBy(BaseEntity user);
}
public enum AIState : Enum {
    public int value__;
    public static AIState None;
    public static AIState Idle;
    public static AIState Roam;
    public static AIState Chase;
    public static AIState Cover;
    public static AIState Combat;
    public static AIState Mounted;
    public static AIState Exfil;
    public static AIState Patrol;
    public static AIState Orbit;
    public static AIState Egress;
    public static AIState Land;
    public static AIState DropCrate;
    public static AIState MoveTowards;
    public static AIState Flee;
    public static AIState Attack;
    public static AIState Sleep;
    public static AIState Reload;
    public static AIState TakeCover;
    public static AIState Dismounted;
    public static AIState FollowPath;
    public static AIState NavigateHome;
    public static AIState CombatStationary;
    public static AIState Cooldown;
    public static AIState MoveToPoint;
    public static AIState MoveToVector3;
    public static AIState Blinded;
    public static AIState KillSelf;
    public static AIState MountAPC;
}
public class AIStateContainer : object {
    [CompilerGeneratedAttribute]
private int <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private AIState <State>k__BackingField;
    public List`1<BaseAIEvent> Events;
    [CompilerGeneratedAttribute]
private int <InputMemorySlot>k__BackingField;
    public int ID { get; private set; }
    public AIState State { get; private set; }
    public int InputMemorySlot { get; private set; }
    [CompilerGeneratedAttribute]
public int get_ID();
    [CompilerGeneratedAttribute]
private void set_ID(int value);
    [CompilerGeneratedAttribute]
public AIState get_State();
    [CompilerGeneratedAttribute]
private void set_State(AIState value);
    [CompilerGeneratedAttribute]
public int get_InputMemorySlot();
    [CompilerGeneratedAttribute]
private void set_InputMemorySlot(int value);
    public void Init(AIStateContainer container, BaseEntity owner);
    public AIStateContainer ToProto();
}
public class AIThinkManager : BaseMonoBehaviour {
    public static ListHashSet`1<IThinker> _processQueue;
    public static ListHashSet`1<IThinker> _removalQueue;
    public static ListHashSet`1<IThinker> _animalProcessQueue;
    public static ListHashSet`1<IThinker> _animalremovalQueue;
    public static ListHashSet`1<IThinker> _petProcessQueue;
    public static ListHashSet`1<IThinker> _petRemovalQueue;
    [HelpAttribute("How many miliseconds to budget for processing AI entities per server frame")]
[ServerVar]
public static float framebudgetms;
    [HelpAttribute("How many miliseconds to budget for processing animal AI entities per server frame")]
[ServerVar]
public static float animalframebudgetms;
    [ServerVar]
[HelpAttribute("How many miliseconds to budget for processing pet AI entities per server frame")]
public static float petframebudgetms;
    private static int lastIndex;
    private static int lastAnimalIndex;
    private static int lastPetIndex;
    private static AIThinkManager();
    public static void ProcessQueue(QueueType queueType);
    private static void DoRemoval(ListHashSet`1<IThinker> removal, ListHashSet`1<IThinker> process);
    private static void DoProcessing(ListHashSet`1<IThinker> process, float budgetSeconds, Int32& last);
    public static void Add(IThinker toAdd);
    public static void Remove(IThinker toRemove);
    public static void AddAnimal(IThinker toAdd);
    public static void RemoveAnimal(IThinker toRemove);
    public static void AddPet(IThinker toAdd);
    public static void RemovePet(IThinker toRemove);
}
public enum AIThinkMode : Enum {
    public int value__;
    public static AIThinkMode FixedUpdate;
    public static AIThinkMode Interval;
}
public class AITraversalArea : TriggerBase {
    public Transform entryPoint1;
    public Transform entryPoint2;
    public AITraversalWaitPoint[] waitPoints;
    public Bounds movementArea;
    public Transform activeEntryPoint;
    public float nextFreeTime;
    public void OnValidate();
    public virtual GameObject InterestedInObject(GameObject obj);
    public bool CanTraverse(BaseEntity ent);
    public Transform GetClosestEntry(Vector3 position);
    public Transform GetFarthestEntry(Vector3 position);
    public void SetBusyFor(float dur);
    public bool CanUse(Vector3 dirFrom);
    public virtual void OnEntityEnter(BaseEntity ent);
    public AITraversalWaitPoint GetEntryPointNear(Vector3 pos);
    public bool EntityFilter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
    public void OnDrawGizmos();
}
public class AITraversalWaitPoint : MonoBehaviour {
    public float nextFreeTime;
    public bool Occupied();
    public void Occupy(float dur);
}
public class AlignedLineDrawer : MonoBehaviour {
    public MeshFilter Filter;
    public MeshRenderer Renderer;
    public float LineWidth;
    public float SurfaceOffset;
    public float SprayThickness;
    public float uvTilingFactor;
    public bool DrawEndCaps;
    public bool DrawSideMesh;
    public bool DrawBackMesh;
    public SprayCanSpray_Freehand Spray;
}
public class AlignedLineDrawerDecal : AlignedLineDrawer {
    public DeferredDecal decalComponent;
}
[ExecuteInEditMode]
public class AlphaSinPulse : MonoBehaviour {
    public CanvasGroup target;
    public float speed;
    public float amplitude;
    public bool preview;
}
public class AlternateAttack : StateMachineBehaviour {
    public bool random;
    public bool dontIncrement;
    public String[] targetTransitions;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
[CreateAssetMenuAttribute]
public class AmbienceDefinition : ScriptableObject {
    [HeaderAttribute("Sound")]
public List`1<SoundDefinition> sounds;
    [HorizontalAttribute("2", "-1")]
public ValueRange stingFrequency;
    [InspectorFlagsAttribute]
[HeaderAttribute("Environment")]
public Enum biomes;
    [InspectorFlagsAttribute]
public Enum topologies;
    public EnvironmentType environmentType;
    public bool useEnvironmentType;
    public AnimationCurve time;
    [HorizontalAttribute("2", "-1")]
public ValueRange rain;
    [HorizontalAttribute("2", "-1")]
public ValueRange wind;
    [HorizontalAttribute("2", "-1")]
public ValueRange snow;
    [HorizontalAttribute("2", "-1")]
public ValueRange waves;
}
[CreateAssetMenuAttribute]
public class AmbienceDefinitionList : ScriptableObject {
    public List`1<AmbienceDefinition> defs;
}
public class AmbienceEmitter : MonoBehaviour {
    public AmbienceDefinitionList baseAmbience;
    public AmbienceDefinitionList stings;
    public bool isStatic;
    public bool followCamera;
    public bool isBaseEmitter;
    public bool active;
    public float cameraDistanceSq;
    public BoundingSphere boundingSphere;
    public float crossfadeTime;
    [CompilerGeneratedAttribute]
private Enum <currentTopology>k__BackingField;
    [CompilerGeneratedAttribute]
private Enum <currentBiome>k__BackingField;
    public Dictionary`2<AmbienceDefinition, float> nextStingTime;
    public float deactivateTime;
    public bool playUnderwater;
    public bool playAbovewater;
    public Enum currentTopology { get; private set; }
    public Enum currentBiome { get; private set; }
    [CompilerGeneratedAttribute]
public Enum get_currentTopology();
    [CompilerGeneratedAttribute]
private void set_currentTopology(Enum value);
    [CompilerGeneratedAttribute]
public Enum get_currentBiome();
    [CompilerGeneratedAttribute]
private void set_currentBiome(Enum value);
    public sealed virtual int CompareTo(AmbienceEmitter other);
}
public class AmbienceLocalStings : MonoBehaviour {
    public float maxDistance;
    public float stingRadius;
    public float stingFrequency;
    public float stingFrequencyVariance;
    public SoundDefinition[] stingSounds;
}
public class AmbienceManager : SingletonComponent`1<AmbienceManager> {
    public List`1<EmitterTypeLimit> localEmitterLimits;
    public EmitterTypeLimit catchallEmitterLimit;
    public int maxActiveLocalEmitters;
    public int activeLocalEmitters;
    public List`1<AmbienceEmitter> cameraEmitters;
    public List`1<AmbienceEmitter> emittersInRange;
    public List`1<AmbienceEmitter> activeEmitters;
    public float localEmitterRange;
    public List`1<AmbienceZone> currentAmbienceZones;
    public bool isUnderwater;
    [CompilerGeneratedAttribute]
private float <ambienceZoneGain>k__BackingField;
    public float ambienceZoneGain { get; private set; }
    [CompilerGeneratedAttribute]
public float get_ambienceZoneGain();
    [CompilerGeneratedAttribute]
private void set_ambienceZoneGain(float value);
}
public class AmbienceSpawnEmitters : MonoBehaviour {
    public int baseEmitterCount;
    public int baseEmitterDistance;
    public GameObjectRef emitterPrefab;
}
public class AmbienceWaveSounds : SingletonComponent`1<AmbienceWaveSounds> {
    public int emitterCount;
    public float emitterDistance;
    public List`1<WaveLayer> waveLayers;
}
public class AmbienceWaveSoundZone : TriggerBase {
    public float priority;
    public float gain;
    public virtual void PreClientComponentCull(IPrefabProcessor p);
}
public class AmbienceZone : TriggerBase {
    public AmbienceDefinitionList baseAmbience;
    public AmbienceDefinitionList stings;
    public float priority;
    public bool overrideCrossfadeTime;
    public float crossfadeTime;
    public float ambienceGain;
    public virtual void PreClientComponentCull(IPrefabProcessor p);
}
public class AmbientLightLOD : FacepunchBehaviour {
    public bool isDynamic;
    public float enabledRadius;
    public bool toggleFade;
    public float toggleFadeDuration;
    protected void OnValidate();
}
public class AmmoBelowAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; private set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class AmmoBelowEventUI : BaseEventUI {
}
public class AmmoInformationPanel : ItemInformationPanel {
    public ItemStatValue damageDisplay;
    public ItemStatValue velocityDisplay;
    public ItemStatValue spreadDisplay;
    public ItemTextValue pelletsDisplay;
    public ItemStatValue falloffRangeDisplay;
    public ItemTextValue thicknessDisplay;
}
public class AmplifyOcclusion.VersionInfo : object {
    public static byte Major;
    public static byte Minor;
    public static byte Release;
    private static string StageSuffix;
    [SerializeField]
private int m_major;
    [SerializeField]
private int m_minor;
    [SerializeField]
private int m_release;
    public int Number { get; }
    private VersionInfo(byte major, byte minor, byte release);
    private static VersionInfo();
    public static string StaticToString();
    public virtual string ToString();
    public int get_Number();
    public static VersionInfo Current();
    public static bool Matches(VersionInfo version);
}
[AddComponentMenu("")]
public class AmplifyOcclusionBase : MonoBehaviour {
    [HeaderAttribute("Ambient Occlusion")]
public ApplicationMethod ApplyMethod;
    [TooltipAttribute("Number of samples per pass.")]
public SampleCountLevel SampleCount;
    public PerPixelNormalSource PerPixelNormals;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Final applied intensity of the occlusion effect.")]
public float Intensity;
    public Color Tint;
    [TooltipAttribute("Radius spread of the occlusion.")]
[RangeAttribute("0", "32")]
public float Radius;
    [TooltipAttribute("Max sampling range in pixels.")]
[RangeAttribute("32", "1024")]
public int PixelRadiusLimit;
    [RangeAttribute("0", "2")]
[TooltipAttribute("Occlusion contribution amount on relation to radius.")]
public float RadiusIntensity;
    [RangeAttribute("0", "16")]
[TooltipAttribute("Power exponent attenuation of the occlusion.")]
public float PowerExponent;
    [RangeAttribute("0", "0,99")]
[TooltipAttribute("Controls the initial occlusion contribution offset.")]
public float Bias;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Controls the thickness occlusion contribution.")]
public float Thickness;
    [TooltipAttribute("Compute the Occlusion and Blur at half of the resolution.")]
public bool Downsample;
    [HeaderAttribute("Distance Fade")]
[TooltipAttribute("Control parameters at faraway.")]
public bool FadeEnabled;
    [TooltipAttribute("Distance in Unity unities that start to fade.")]
public float FadeStart;
    [TooltipAttribute("Length distance to performe the transition.")]
public float FadeLength;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Final Intensity parameter.")]
public float FadeToIntensity;
    public Color FadeToTint;
    [RangeAttribute("0", "32")]
[TooltipAttribute("Final Radius parameter.")]
public float FadeToRadius;
    [RangeAttribute("0", "16")]
[TooltipAttribute("Final PowerExponent parameter.")]
public float FadeToPowerExponent;
    [TooltipAttribute("Final Thickness parameter.")]
[RangeAttribute("0", "1")]
public float FadeToThickness;
    [HeaderAttribute("Bilateral Blur")]
public bool BlurEnabled;
    [TooltipAttribute("Radius in screen pixels.")]
[RangeAttribute("1", "4")]
public int BlurRadius;
    [RangeAttribute("1", "4")]
[TooltipAttribute("Number of times that the Blur will repeat.")]
public int BlurPasses;
    [RangeAttribute("0", "20")]
[TooltipAttribute("0 - Blured, 1 - Sharpened.")]
public float BlurSharpness;
    [TooltipAttribute("Accumulates the effect over the time.")]
[HeaderAttribute("Temporal Filter")]
public bool FilterEnabled;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Controls the accumulation decayment. 0 - Faster update, more flicker. 1 - Slow update (ghosting on moving objects), less flicker.")]
public float FilterBlending;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Controls the discard sensibility based on the motion of the scene and objects. 0 - Discard less, reuse more (more ghost effect). 1 - Discard more, reuse less (less ghost effect).")]
public float FilterResponse;
    [TooltipAttribute("Enables directional variations.")]
public bool TemporalDirections;
    [TooltipAttribute("Enables offset variations.")]
public bool TemporalOffsets;
    [TooltipAttribute("Reduces ghosting effect near the objects's edges while moving.")]
public bool TemporalDilation;
    [TooltipAttribute("Uses the object movement information for calc new areas of occlusion.")]
public bool UseMotionVectors;
}
[RequireComponent("UnityEngine.Camera")]
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Amplify Occlusion")]
public class AmplifyOcclusionEffect : AmplifyOcclusionBase {
}
public class AndAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class AndEventUI : BaseEventUI {
}
public class ANDSwitch : IOEntity {
    private int input1Amount;
    private int input2Amount;
    public virtual int ConsumptionAmount();
    public virtual bool WantsPower(int inputIndex);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int slot);
}
public class AnimalAnimation : MonoBehaviour {
    public BaseEntity Entity;
    public BaseNpc Target;
    public Animator Animator;
    public MaterialEffect FootstepEffects;
    public Transform[] Feet;
    public SoundDefinition saddleMovementSoundDef;
    public SoundDefinition saddleMovementSoundDefWood;
    public SoundDefinition saddleMovementSoundDefRoadsign;
    public AnimationCurve saddleMovementGainCurve;
    [TooltipAttribute("Ensure there is a float param called idleOffset if this is enabled")]
public bool hasIdleOffset;
    [ReadOnlyAttribute]
public string BaseFolder;
    public static Flags Flag_WoodArmor;
    public static Flags Flag_RoadsignArmor;
}
public class AnimalBrain : BaseAIBrain {
    public static int Count;
    public static NavigationSpeed ControlTestAnimalSpeed;
    private static AnimalBrain();
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
    public BaseAnimalNPC GetEntity();
}
public class AnimalFootIK : MonoBehaviour {
    public Transform[] Feet;
    public Animator animator;
    public float maxWeightDistance;
    public float minWeightDistance;
    public float actualFootOffset;
    public bool GroundSample(Vector3 origin, RaycastHit& hit);
    public void Start();
    public AvatarIKGoal GoalFromIndex(int index);
    private void OnAnimatorIK(int layerIndex);
}
public class AnimalMultiSkin : object {
    public Material[] multiSkin;
}
public class AnimalRagdoll : Ragdoll {
    public SkinnedMeshRenderer[] bodyRenderers;
    public SkinnedMeshRenderer[] hairRenderers;
}
public class AnimalSkin : MonoBehaviour {
    public SkinnedMeshRenderer[] animalMesh;
    public AnimalMultiSkin[] animalSkins;
    private Model model;
    public bool dontRandomizeOnStart;
    private void Start();
    public void ChangeSkin(int iSkin);
}
public class AnimatedBuildingBlock : StabilityEntity {
    private bool animatorNeedsInitializing;
    private bool animatorIsOpen;
    [HideInInspector]
public bool isAnimating;
    private static int Open;
    private static AnimatedBuildingBlock();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    protected virtual void ApplySubAnimationParameters(bool init, Animator toAnimator);
    protected void UpdateAnimationParameters(bool init);
    protected virtual void OnAnimatorFinished();
    private void PutAnimatorToSleep();
    protected virtual void OnAnimatorDisabled();
}
public class AnimatedScreenShake : BaseScreenShake {
    public AnimationClip TargetClip;
    [ReadOnlyAttribute]
public AnimationCurve rotX;
    [ReadOnlyAttribute]
public AnimationCurve rotY;
    [ReadOnlyAttribute]
public AnimationCurve rotZ;
    [ReadOnlyAttribute]
public AnimationCurve posX;
    [ReadOnlyAttribute]
public AnimationCurve posY;
    [ReadOnlyAttribute]
public AnimationCurve posZ;
    private static float VALID_RANGE;
    private bool canPlay;
    public virtual void Setup();
    public virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
public class AnimationEventForward : MonoBehaviour {
    public GameObject targetObject;
    public void Event(string type);
}
public class AnimationEvents : BaseMonoBehaviour {
    public Transform rootObject;
    public HeldEntity targetEntity;
    [TooltipAttribute("Path to the effect folder for these animations. Relative to this object.")]
public string effectFolder;
    public bool enforceClipWeights;
    public string localFolder;
    [TooltipAttribute("If true the localFolder field won't update with manifest updates, use for custom paths")]
public bool customLocalFolder;
    public bool IsBusy;
    protected void OnEnable();
}
public class AnimationFlagHandler : MonoBehaviour {
    public Animator animator;
    public void SetBoolTrue(string name);
    public void SetBoolFalse(string name);
}
public class AnimatorLOD : LODComponent {
    public float Distance;
}
public static class AntiHack : object {
    private static int movement_mask;
    private static int vehicle_mask;
    private static int grounded_mask;
    private static int player_mask;
    private static Collider[] buffer;
    private static Dictionary`2<ulong, int> kicks;
    private static Dictionary`2<ulong, int> bans;
    private static float LOG_GROUP_SECONDS;
    private static Queue`1<GroupedLog> groupedLogs;
    public static RaycastHit isInsideRayHit;
    private static AntiHack();
    public static bool TestNoClipping(Vector3 oldPos, Vector3 newPos, float radius, float backtracking, bool vehicleLayer, BaseEntity ignoreEntity);
    private static bool ShouldUseCastNoClipChecks(BaseEntity entity);
    public static void Cycle();
    public static void ResetTimer(BasePlayer ply);
    public static bool ShouldIgnore(BasePlayer ply);
    public static bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime);
    public static void ValidateEyeHistory(BasePlayer ply);
    public static bool IsInsideTerrain(BasePlayer ply);
    public static bool TestInsideTerrain(Vector3 pos);
    public static bool IsInsideMesh(Vector3 pos);
    public static bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime);
    public static bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime);
    public static bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime);
    public static bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded);
    public static bool TestServerSideFallDamage(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float deltaTime);
    public static void ResetServerFall(BasePlayer ply);
    public static bool TestIsBuildingInsideSomething(Target target, Vector3 deployPos);
    public static void NoteAdminHack(BasePlayer ply);
    public static void FadeViolations(BasePlayer ply, float deltaTime);
    public static void EnforceViolations(BasePlayer ply);
    public static void Log(BasePlayer ply, AntiHackType type, string message, bool logToAnalytics);
    public static void LogToConsoleBatched(BasePlayer ply, AntiHackType type, string message, float maxDistance);
    private static void LogToConsole(BasePlayer ply, AntiHackType type, string message);
    private static void LogToConsole(string plyName, AntiHackType type, string message, Vector3 pos);
    private static void LogToEAC(BasePlayer ply, AntiHackType type, string message);
    public static void AddViolation(BasePlayer ply, AntiHackType type, float amount);
    public static void Kick(BasePlayer ply, string reason);
    public static void Ban(BasePlayer ply, string reason);
    private static void AddRecord(BasePlayer ply, Dictionary`2<ulong, int> records);
    public static int GetKickRecord(BasePlayer ply);
    public static int GetBanRecord(BasePlayer ply);
    private static int GetRecord(BasePlayer ply, Dictionary`2<ulong, int> records);
}
public enum AntiHackType : Enum {
    public int value__;
    public static AntiHackType None;
    public static AntiHackType NoClip;
    public static AntiHackType SpeedHack;
    public static AntiHackType FlyHack;
    public static AntiHackType ProjectileHack;
    public static AntiHackType MeleeHack;
    public static AntiHackType EyeHack;
    public static AntiHackType AttackHack;
    public static AntiHackType ReloadHack;
    public static AntiHackType CooldownHack;
    public static AntiHackType InsideTerrain;
    public static AntiHackType InsideGeometry;
    public static AntiHackType EffectHack;
}
public abstract class AppIOEntity : IOEntity {
    private float _cacheTime;
    private BuildingPrivlidge _cache;
    public AppEntityType Type { get; }
    public bool Value { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public abstract virtual AppEntityType get_Type();
    public virtual bool get_Value();
    public virtual void set_Value(bool value);
    protected void BroadcastValueChange();
    internal virtual void FillEntityPayload(AppEntityPayload payload);
    public virtual BuildingPrivlidge GetBuildingPrivilege();
    public EntityTarget GetTarget();
    [AsyncStateMachineAttribute("AppIOEntity/<PairWithApp>d__12")]
[RPC_Server]
[CallsPerSecond("5")]
[IsVisible("3")]
public void PairWithApp(RPCMessage msg);
    protected virtual void OnPairedWithPlayer(BasePlayer player);
}
public class ApplyTerrainAnchors : MonoBehaviour {
    protected void Awake();
}
public class ApplyTerrainModifiers : MonoBehaviour {
    protected void Awake();
}
public class ApplyTweakUIChanges : MonoBehaviour {
    public Button ApplyButton;
    public TweakUIBase[] Options;
    private void OnEnable();
    public void Apply();
    public void SetDirty();
    public void SetClean();
}
public class ArcadeClientAuthTest : ArcadeEntityController {
    public float speed;
    public float maxSpeed;
    public BaseArcadeGame myGame;
    public ArcadeEntity myEntity;
}
public class ArcadeEntity : BaseMonoBehaviour {
    public UInt32 id;
    public UInt32 spriteID;
    public UInt32 soundID;
    public bool visible;
    public Vector3 heading;
    public bool isEnabled;
    public bool dirty;
    public float alpha;
    public BoxCollider boxCollider;
    public bool host;
    public bool localAuthorativeOverride;
    public ArcadeEntity arcadeEntityParent;
    public UInt32 prefabID;
    [HeaderAttribute("Health")]
public bool takesDamage;
    public float health;
    public float maxHealth;
    public bool mapLoadedEntiy;
}
public class ArcadeEntityController : BaseMonoBehaviour {
    public BaseArcadeGame parentGame;
    public ArcadeEntity arcadeEntity;
    public ArcadeEntity sourceEntity;
    public Vector3 heading { get; public set; }
    public Vector3 positionLocal { get; public set; }
    public Vector3 positionWorld { get; public set; }
    public Vector3 get_heading();
    public void set_heading(Vector3 value);
    public Vector3 get_positionLocal();
    public void set_positionLocal(Vector3 value);
    public Vector3 get_positionWorld();
    public void set_positionWorld(Vector3 value);
}
public class ArcadeNetworkTrigger : TriggerBase {
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class ArcadeTennisPaddle : ArcadeEntity {
}
public class ArmorInformationPanel : ItemInformationPanel {
    public ItemTextValue projectileDisplay;
    public ItemTextValue meleeDisplay;
    public ItemTextValue coldDisplay;
    public ItemTextValue explosionDisplay;
    public ItemTextValue radiationDisplay;
    public ItemTextValue biteDisplay;
    public ItemTextValue spacer;
    public Text areaProtectionText;
    public Phrase LegText;
    public Phrase ChestText;
    public Phrase HeadText;
    public Phrase ChestLegsText;
    public Phrase WholeBodyText;
    public ItemTextValue eggVision;
}
[CreateAssetMenuAttribute]
public class ArmorProperties : ScriptableObject {
    [InspectorFlagsAttribute]
public HitArea area;
    public bool Contains(HitArea hitArea);
}
[ExtensionAttribute]
public static class ArrayEx : object {
    public static T[] New(int length);
    [ExtensionAttribute]
public static T GetRandom(T[] array);
    [ExtensionAttribute]
public static T GetRandom(T[] array, UInt32 seed);
    [ExtensionAttribute]
public static T GetRandom(T[] array, UInt32& seed);
    [ExtensionAttribute]
public static void Shuffle(T[] array, UInt32 seed);
    [ExtensionAttribute]
public static void Shuffle(T[] array, UInt32& seed);
    [ExtensionAttribute]
public static void BubbleSort(T[] array);
}
public class ArticulatedOccludee : BaseMonoBehaviour {
    private static float UpdateBoundsFadeStart;
    private static float UpdateBoundsFadeLength;
    private static float UpdateBoundsMaxFrequency;
    private static float UpdateBoundsMinFrequency;
    private LODGroup lodGroup;
    public List`1<Collider> colliders;
    private OccludeeSphere localOccludee;
    private List`1<Renderer> renderers;
    private bool isVisible;
    private Action TriggerUpdateVisibilityBoundsDelegate;
    public bool IsVisible { get; }
    public bool get_IsVisible();
    protected virtual void OnDisable();
    private void ClearVisibility();
    public void ProcessVisibility(LODGroup lod);
    private void RegisterForCulling(Sphere sphere, bool visible);
    private void UnregisterFromCulling();
    public void UpdateCullingBounds();
    protected virtual bool CheckVisibility();
    private void ApplyVisibility(bool vis);
    protected virtual void OnVisibilityChanged(bool visible);
    private void UpdateVisibility(float delay);
    private void VisUpdateUsingCulling(float dist, bool visibility);
    public virtual void TriggerUpdateVisibilityBounds();
}
public class AspectRatioGuide : MonoBehaviour {
    public AspectRatioFitter aspectRatioFitter;
    public RustText label;
    public float aspect;
    public float ratio;
    private void Populate();
    public void Awake();
    public void Update();
}
[ExtensionAttribute]
public static class AssetNameCache : object {
    private static Dictionary`2<Object, string> mixed;
    private static Dictionary`2<Object, string> lower;
    private static Dictionary`2<Object, string> upper;
    private static AssetNameCache();
    private static string LookupName(Object obj);
    private static string LookupNameLower(Object obj);
    private static string LookupNameUpper(Object obj);
    [ExtensionAttribute]
public static string GetName(PhysicMaterial mat);
    [ExtensionAttribute]
public static string GetNameLower(PhysicMaterial mat);
    [ExtensionAttribute]
public static string GetNameUpper(PhysicMaterial mat);
    [ExtensionAttribute]
public static string GetName(Material mat);
    [ExtensionAttribute]
public static string GetNameLower(Material mat);
    [ExtensionAttribute]
public static string GetNameUpper(Material mat);
}
public static class AssetStorage : object {
    public static void Save(T& asset, string path);
    public static void Save(Texture2D& asset);
    public static void Save(Texture2D& asset, string path, bool linear, bool compress);
    public static void Load(T& asset, string path);
    public static void Delete(T& asset);
}
public class AsyncTerrainNavMeshBake : CustomYieldInstruction {
    private List`1<int> indices;
    private List`1<Vector3> vertices;
    private List`1<Vector3> normals;
    private List`1<int> triangles;
    private Vector3 pivot;
    private int width;
    private int height;
    private bool normal;
    private bool alpha;
    private Action worker;
    public bool keepWaiting { get; }
    public bool isDone { get; }
    public Mesh mesh { get; }
    public AsyncTerrainNavMeshBake(Vector3 pivot, int width, int height, bool normal, bool alpha);
    public virtual bool get_keepWaiting();
    public bool get_isDone();
    public NavMeshBuildSource CreateNavMeshBuildSource();
    public NavMeshBuildSource CreateNavMeshBuildSource(int area);
    public Mesh get_mesh();
    private void DoWork();
    private void Invoke();
    private void Callback(IAsyncResult result);
}
[ExecuteInEditMode]
public class AtmosphereVolume : MonoBehaviour {
    public float MaxVisibleDistance;
    public float BoundsAttenuationDecay;
    public FogSettings FogSettings;
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Camera")]
public class AtmosphereVolumeRenderer : MonoBehaviour {
    public FogMode Mode;
    public bool DistanceFog;
    public bool HeightFog;
    public AtmosphereVolume Volume;
    private static bool isSupported { get; }
    private static bool get_isSupported();
}
public class AttackedAIEvent : BaseAIEvent {
    protected float lastExecuteTime;
    private BaseCombatEntity combatEntity;
    public virtual void Reset();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class AttackedEventUI : BaseEventUI {
}
public class AttackEntity : HeldEntity {
    [HeaderAttribute("Attack Entity")]
public float deployDelay;
    public float repeatDelay;
    public float animationDelay;
    [HeaderAttribute("NPCUsage")]
public float effectiveRange;
    public float npcDamageScale;
    public float attackLengthMin;
    public float attackLengthMax;
    public float attackSpacing;
    public float aiAimSwayOffset;
    public float aiAimCone;
    public bool aiOnlyInRange;
    public float CloseRangeAddition;
    public float MediumRangeAddition;
    public float LongRangeAddition;
    public bool CanUseAtMediumRange;
    public bool CanUseAtLongRange;
    public SoundDefinition[] reloadSounds;
    public SoundDefinition thirdPersonMeleeSound;
    [HeaderAttribute("Recoil Compensation")]
public float recoilCompDelayOverride;
    public bool wantsRecoilComp;
    public bool showCrosshairOnTutorial;
    public bool noHeadshots;
    public EncryptedValue`1<float> nextAttackTime;
    protected bool UsingInfiniteAmmoCheat { get; }
    public float NextAttackTime { get; }
    public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction);
    public virtual float AmmoFraction();
    public virtual bool CanReload();
    public virtual bool ServerIsReloading();
    public virtual void ServerReload();
    public virtual bool ServerTryReload(IAmmoContainer ammoSource);
    public virtual void TopUpAmmo();
    public virtual Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier);
    protected bool get_UsingInfiniteAmmoCheat();
    public float get_NextAttackTime();
    public virtual void GetAttackStats(HitInfo info);
    public void StartAttackCooldownRaw(float cooldown);
    public void StartAttackCooldown(float cooldown);
    public void ResetAttackCooldown();
    public bool HasAttackCooldown();
    protected float GetAttackCooldown();
    protected float GetAttackIdle();
    protected float CalculateCooldownTime(float nextTime, float cooldown, bool catchup);
    protected bool VerifyClientRPC(BasePlayer player);
    protected virtual bool VerifyClientAttack(BasePlayer player);
    protected bool ValidateEyePos(BasePlayer player, Vector3 eyePos, bool checkLineOfSight);
    public virtual void OnHeldChanged();
}
public class AttackHeliCamOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
public class AttackHelicopter : PlayerHelicopter {
    [HeaderAttribute("Attack Helicopter")]
public Transform gunnerEyePos;
    [SerializeField]
private Transform turbofanBone;
    [SerializeField]
private GameObjectRef turretStoragePrefab;
    [SerializeField]
private GameObjectRef rocketStoragePrefab;
    [SerializeField]
private GameObjectRef gunCamUIPrefab;
    [SerializeField]
private GameObjectRef gunCamUIDialogPrefab;
    [SerializeField]
private GameObject gunCamUIParent;
    [SerializeField]
private ParticleSystemContainer fxLightDamage;
    [SerializeField]
private ParticleSystemContainer fxMediumDamage;
    [SerializeField]
private ParticleSystemContainer fxHeavyDamage;
    [SerializeField]
private SoundDefinition damagedLightLoop;
    [SerializeField]
private SoundDefinition damagedHeavyLoop;
    [SerializeField]
private GameObject damageSoundTarget;
    [SerializeField]
private MeshRenderer monitorStaticRenderer;
    [SerializeField]
private Material monitorStatic;
    [SerializeField]
private Material monitorStaticSafeZone;
    [SerializeField]
[HeaderAttribute("Heli Pilot Flares")]
public GameObjectRef flareFireFX;
    [SerializeField]
public GameObjectRef pilotFlare;
    [SerializeField]
public Transform leftFlareLaunchPos;
    [SerializeField]
public Transform rightFlareLaunchPos;
    [SerializeField]
public float flareLaunchVel;
    [HeaderAttribute("Heli Pilot Lights")]
[SerializeField]
private Renderer rocketLightOff;
    [SerializeField]
private Renderer rocketLightRed;
    [SerializeField]
private Renderer rocketLightGreen;
    [SerializeField]
private Renderer flareLightOff;
    [SerializeField]
private Renderer flareLightRed;
    [SerializeField]
private Renderer flareLightGreen;
    [HeaderAttribute("Heli Turret")]
public Vector2 turretPitchClamp;
    public Vector2 turretYawClamp;
    public static Flags IN_GUNNER_VIEW_FLAG;
    public static Flags IN_SAFE_ZONE_FLAG;
    protected static int headingGaugeIndex;
    protected static int altGaugeIndex;
    protected int altShakeIndex;
    public EntityRef`1<AttackHelicopterTurret> turretInstance;
    public EntityRef`1<AttackHelicopterRockets> rocketsInstance;
    public GunnerInputState gunnerInputState;
    public TimeSince timeSinceLastGunnerInput;
    public TimeSince timeSinceFailedWeaponFireRPC;
    public TimeSince timeSinceFailedFlareRPC;
    public bool HasSafeZoneFlag { get; }
    public bool GunnerIsInGunnerView { get; }
    private static AttackHelicopter();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_HasSafeZoneFlag();
    public bool get_GunnerIsInGunnerView();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual void Load(LoadInfo info);
    public AttackHelicopterTurret GetTurret();
    public AttackHelicopterRockets GetRockets();
    public virtual void PilotInput(InputState inputState, BasePlayer player);
    public virtual void PassengerInput(InputState inputState, BasePlayer player);
    public void WeaponFireFailed(int ammo, BasePlayer player);
    public void FlareFireFailed(BasePlayer player);
    public virtual void VehicleFixedUpdate();
    public virtual bool EnterTrigger(TriggerBase trigger);
    public virtual void LeaveTrigger(TriggerBase trigger);
    public virtual void PrePlayerDismount(BasePlayer player, BaseMountable seat);
    internal virtual void DoServerDestroy();
    public virtual void Save(SaveInfo info);
    public void MarkAllMountedPlayersAsHostile();
    public virtual bool AdminFixUp(int tier);
    public void LaunchFlare();
    [RPC_Server]
[IsVisible("3")]
public void RPC_OpenTurret(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_OpenStorage(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_OpenGunnerView(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_CloseGunnerView(RPCMessage msg);
}
public class AttackHelicopterRockets : StorageContainer {
    [SerializeField]
private Transform[] rocketMuzzlePositions;
    [SerializeField]
private GameObjectRef rocketFireTubeFX;
    [SerializeField]
public float timeBetweenRockets;
    [SerializeField]
private float timeBetweenFlares;
    [SerializeField]
public float reloadTime;
    [SerializeField]
public int rocketsPerReload;
    [SerializeField]
private ItemDefinition incendiaryRocketDef;
    [SerializeField]
private ItemDefinition hvRocketDef;
    [SerializeField]
private ItemDefinition flareItemDef;
    public AttackHelicopter owner;
    private static AmmoTypes ammoType;
    public TimeSince timeSinceRocketFired;
    private TimeSince timeSinceFlareFired;
    private static float ROCKET_LAUNCH_OFFSET;
    private int rocketsSinceReload;
    private bool leftSide;
    public bool CanFireRocket { get; }
    public bool IsReloading { get; }
    public bool CanFireFlare { get; }
    private bool HasOwner { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_CanFireRocket();
    public bool get_IsReloading();
    public bool get_CanFireFlare();
    private bool get_HasOwner();
    public virtual void InitShared();
    public int GetRocketAmount();
    public bool HasFlareAmmo();
    public int GetAmmoBeforeReload();
    public bool TryGetAmmoDef(ItemDefinition& ammoDef);
    public Vector3 MuzzleMidPoint();
    public float GetMinRocketSpeed();
    public Vector3 GetProjectedHitPos();
    private void ResetFiringTimes();
    public virtual void Save(SaveInfo info);
    public virtual BasePlayer ToPlayer();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public bool InputTick(GunnerInputState input, BasePlayer gunner);
    public bool TryFireRocket(BasePlayer shooter);
    public bool TryFireFlare();
    [CompilerGeneratedAttribute]
private bool <ItemFilter>g__IsValidRocket|36_0(<>c__DisplayClass36_0& );
    [CompilerGeneratedAttribute]
private bool <ItemFilter>g__IsValidFlare|36_1(<>c__DisplayClass36_0& );
}
public class AttackHelicopterTurret : StorageContainer {
    [SerializeField]
public Transform turretSocket;
    [SerializeField]
public Transform turretHorizontal;
    [SerializeField]
public Transform turretVertical;
    public AttackHelicopter owner;
    [CompilerGeneratedAttribute]
private GunStatus <GunState>k__BackingField;
    public EntityRef`1<HeldEntity> attachedHeldEntity;
    public bool forceAcceptAmmo;
    public static float WEAPON_Z_OFFSET_SCALE;
    public float muzzleYOffset;
    public float lastSentX;
    public float lastSentY;
    public bool HasOwner { get; }
    public GunStatus GunState { get; public set; }
    public float GunXAngle { get; }
    public float GunYAngle { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_HasOwner();
    [CompilerGeneratedAttribute]
public GunStatus get_GunState();
    [CompilerGeneratedAttribute]
public void set_GunState(GunStatus value);
    public float get_GunXAngle();
    public float get_GunYAngle();
    public virtual void Load(LoadInfo info);
    public void SetGunRotation(float xRot, float yRot);
    public HeldEntity GetAttachedHeldEntity();
    public void GetAmmoAmounts(Int32& clip, Int32& available);
    public Vector3 GetProjectedHitPos();
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual BasePlayer ToPlayer();
    public bool CanAcceptItem(Item item, int targetSlot);
    public bool IsValidWeapon(Item item);
    public bool InputTick(GunnerInputState input);
    public Vector3 ClampEyeAngle(Transform heliTransform, Vector3 eyeDir, Vector2 pitchRange, Vector2 yawRange);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public void UpdateAttachedWeapon();
    public bool TryReload();
    public bool TryFireWeapon();
    public void RefreshGunState();
}
public class AttackHeliDriverSeat : BaseVehicleSeat {
    [SerializeField]
private Sprite rocketCrosshair;
    [SerializeField]
private Sprite incendRocketCrosshair;
    [SerializeField]
private Sprite hvRocketCrosshair;
    [SerializeField]
private Sprite reloadingCrosshair;
    [SerializeField]
private GameObjectRef rocketHVItem;
    [SerializeField]
private GameObjectRef rocketIncenItem;
    private AttackHelicopter _owner;
    private AttackHelicopter Owner { get; }
    private AttackHelicopter get_Owner();
}
public class AttackHeliGunnerSeat : BaseVehicleSeat {
    private AttackHelicopter _owner;
    private AttackHelicopter Owner { get; }
    private AttackHelicopter get_Owner();
    public virtual bool CanHoldItems();
    public virtual Transform GetEyeOverride();
    public virtual Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot);
    public virtual Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot);
    public virtual Vector2 GetPitchClamp();
    public virtual Vector2 GetYawClamp();
}
[RequireComponent("UnityEngine.Rigidbody")]
public class AttackHeliPilotFlare : MonoBehaviour {
    protected void Start();
    protected void OnDestroy();
    public void Init(Vector3 initialVelocity);
    public sealed virtual Vector3 CenterPoint();
    public sealed virtual bool IsVisible(Vector3 from, float maxDistance);
    public sealed virtual bool InSafeZone();
    public sealed virtual bool IsValidHomingTarget();
    public sealed virtual void OnEntityMessage(BaseEntity from, string msg);
}
public class AttackHeliUIDialog : UIDialog {
    [HeaderAttribute("Attack Helicopter")]
[SerializeField]
private Material compassStripMat;
    [SerializeField]
private Canvas mainCanvas;
    [SerializeField]
private CanvasGroup gunCrosshair;
    [SerializeField]
private CanvasGroup gunNoAmmoCrosshair;
    [SerializeField]
private CanvasGroup gunCrosshairGhost;
    [SerializeField]
private RectTransform gunCrosshairGhostRect;
    [SerializeField]
private Canvas rocketCrosshairDefaultCanvas;
    [SerializeField]
private RectTransform rocketCrosshairDefaultRect;
    [SerializeField]
private Canvas rocketCrosshairHVCanvas;
    [SerializeField]
private RectTransform rocketCrosshairHVRect;
    [SerializeField]
private Canvas rocketCrosshairIncenCanvas;
    [SerializeField]
private RectTransform rocketCrosshairIncenRect;
    [SerializeField]
private GameObjectRef rocketHVItem;
    [SerializeField]
private GameObjectRef rocketIncenItem;
    [SerializeField]
private CanvasGroup crosshairHitMarkerGroup;
    [SerializeField]
private RectTransform zoomIndicator;
    [SerializeField]
private RectTransform positionBox;
    [SerializeField]
private RustText ammoTextGunMag;
    [SerializeField]
private RustText ammoTextGunRest;
    [SerializeField]
private RustText ammoTextRocketMag;
    [SerializeField]
private RustText ammoTextRocketRest;
    [SerializeField]
private RustText rangeText;
    [SerializeField]
private float zoomIndicatorMinY;
    [SerializeField]
private float zoomIndicatorMaxY;
    [SerializeField]
private float positionBoxXMult;
    [SerializeField]
private float positionBoxYMult;
    [SerializeField]
private Animator damageWarning;
}
public class AttackTickAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class AttackTickEventUI : BaseEventUI {
}
public class AttractionPoint : PrefabAttribute {
    public string groupName;
    protected virtual Type GetIndexedType();
}
public class AudioAlarm : IOEntity {
}
public class AudioInterceptComponent : MonoBehaviour {
}
public class AudioSettings : MonoBehaviour {
    public static float duckingFactor;
    public AudioMixer mixer;
    private static AudioSettings();
    private void Update();
    private float LinearToDecibel(float linear);
}
public class AudioVisualisationEntity : IOEntity {
    private EntityRef`1<BaseEntity> connectedTo;
    [CompilerGeneratedAttribute]
private LightColour <currentColour>k__BackingField;
    [CompilerGeneratedAttribute]
private VolumeSensitivity <currentVolumeSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private Speed <currentSpeed>k__BackingField;
    public GameObjectRef SettingsDialog;
    [CompilerGeneratedAttribute]
private int <currentGradient>k__BackingField;
    public LightColour currentColour { get; private set; }
    public VolumeSensitivity currentVolumeSensitivity { get; private set; }
    public Speed currentSpeed { get; private set; }
    public int currentGradient { get; private set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public LightColour get_currentColour();
    [CompilerGeneratedAttribute]
private void set_currentColour(LightColour value);
    [CompilerGeneratedAttribute]
public VolumeSensitivity get_currentVolumeSensitivity();
    [CompilerGeneratedAttribute]
private void set_currentVolumeSensitivity(VolumeSensitivity value);
    [CompilerGeneratedAttribute]
public Speed get_currentSpeed();
    [CompilerGeneratedAttribute]
private void set_currentSpeed(Speed value);
    [CompilerGeneratedAttribute]
public int get_currentGradient();
    [CompilerGeneratedAttribute]
private void set_currentGradient(int value);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    private IOEntity GetAudioSource(IOEntity entity, Int32& depth);
    public virtual void Save(SaveInfo info);
    [RPC_Server]
[CallsPerSecond("5")]
[IsVisible("3")]
public void ServerUpdateSettings(RPCMessage msg);
    public virtual void Load(LoadInfo info);
}
public class AudioVisualisationEntityLight : AudioVisualisationEntity {
    public Light TargetLight;
    public Light SecondaryLight;
    public MeshRenderer[] TargetRenderer;
    public LightColourSet RedColour;
    public LightColourSet GreenColour;
    public LightColourSet BlueColour;
    public LightColourSet YellowColour;
    public LightColourSet PinkColour;
    public float lightMinIntensity;
    public float lightMaxIntensity;
}
public class AuroraEffect : WeatherEffect {
}
public static class Auth_CentralizedBans : object {
    private static BanPayload payloadData;
    private static Auth_CentralizedBans();
    [IteratorStateMachineAttribute("Auth_CentralizedBans/<Run>d__0")]
public static IEnumerator Run(Connection connection);
    private static bool CheckIfPlayerBanned(ulong steamId, Connection connection, UnityWebRequest request);
    [CompilerGeneratedAttribute]
internal static void <CheckIfPlayerBanned>g__Reject|2_0(string reason, <>c__DisplayClass2_0& );
}
public static class Auth_EAC : object {
    [IteratorStateMachineAttribute("Auth_EAC/<Run>d__0")]
public static IEnumerator Run(Connection connection);
}
public static class Auth_Nexus : object {
    [IteratorStateMachineAttribute("Auth_Nexus/<Run>d__0")]
public static IEnumerator Run(Connection connection);
}
public static class Auth_Steam : object {
    internal static List`1<Connection> waitingList;
    private static Auth_Steam();
    [IteratorStateMachineAttribute("Auth_Steam/<Run>d__1")]
public static IEnumerator Run(Connection connection);
    public static bool ValidateConnecting(ulong steamid, ulong ownerSteamID, AuthResponse response);
}
public class AutoTurret : ContainerIOEntity {
    public GameObjectRef gun_fire_effect;
    public GameObjectRef bulletEffect;
    public float bulletSpeed;
    public AmbienceEmitter ambienceEmitter;
    public bool playAmbientSounds;
    public GameObject assignDialog;
    public LaserBeam laserBeam;
    public BaseCombatEntity target;
    public Transform eyePos;
    public Transform muzzlePos;
    public Vector3 aimDir;
    public Transform gun_yaw;
    public Transform gun_pitch;
    public float sightRange;
    public SoundDefinition turnLoopDef;
    public SoundDefinition movementChangeDef;
    public SoundDefinition ambientLoopDef;
    public SoundDefinition focusCameraDef;
    public float focusSoundFreqMin;
    public float focusSoundFreqMax;
    public GameObjectRef peacekeeperToggleSound;
    public GameObjectRef onlineSound;
    public GameObjectRef offlineSound;
    public GameObjectRef targetAcquiredEffect;
    public GameObjectRef targetLostEffect;
    public GameObjectRef reloadEffect;
    public float aimCone;
    public static Flags Flag_Equipped;
    public static Flags Flag_MaxAuths;
    public HashSet`1<PlayerNameID> authorizedPlayers;
    [ServerVar]
public static float auto_turret_budget_ms;
    public static UpdateAutoTurretScanQueue updateAutoTurretScanQueue;
    [HeaderAttribute("RC")]
public float rcTurnSensitivity;
    public Transform RCEyes;
    public GameObjectRef IDPanelPrefab;
    public RemoteControllableControls rcControls;
    public string rcIdentifier;
    [CompilerGeneratedAttribute]
private int <ViewerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField;
    public TargetTrigger targetTrigger;
    public TriggerBase interferenceTrigger;
    public float maxInterference;
    public float attachedWeaponZOffsetScale;
    public Transform socketTransform;
    public bool authDirty;
    public bool hasPotentialUnauthedTarget;
    public float nextShotTime;
    public float lastShotTime;
    public float nextVisCheck;
    public float lastTargetSeenTime;
    public bool targetVisible;
    public bool booting;
    public float nextIdleAimTime;
    public Vector3 targetAimDir;
    public static float bulletDamage;
    public RealTimeSinceEx timeSinceLastServerTick;
    public HashSet`1<AutoTurret> nearbyTurrets;
    public static HashSet`1<AutoTurret> interferenceUpdateList;
    public float nextForcedAimTime;
    public Vector3 lastSentAimDir;
    public static Single[] visibilityOffsets;
    public int peekIndex;
    public int numConsecutiveMisses;
    public int totalAmmo;
    public float nextAmmoCheckTime;
    public bool totalAmmoDirty;
    public float currentAmmoGravity;
    public float currentAmmoVelocity;
    public HeldEntity AttachedWeapon;
    public int consumptionAmount;
    public bool CanPing { get; }
    public bool RequiresMouse { get; }
    public float MaxRange { get; }
    public RemoteControllableControls RequiredControls { get; }
    public int ViewerCount { get; public set; }
    public Nullable`1<CameraViewerId> ControllingViewerId { get; public set; }
    public bool IsBeingControlled { get; }
    public bool PreventDuplicatesInQueue { get; }
    private static AutoTurret();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual bool get_CanPing();
    public bool IsOnline();
    public bool IsOffline();
    public virtual void ResetState();
    public virtual Transform GetCenterMuzzle();
    public float AngleToTarget(BaseCombatEntity potentialtarget, bool use2D);
    public virtual bool InFiringArc(BaseCombatEntity potentialtarget);
    public virtual bool CanPickup(BasePlayer player);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    public virtual void PostSave(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public Vector3 AimOffset(BaseCombatEntity aimat);
    public float GetAimSpeed();
    public void UpdateAiming(float dt);
    public bool IsAuthed(ulong id);
    public bool IsAuthed(BasePlayer player);
    public bool AnyAuthed();
    public virtual bool CanChangeSettings(BasePlayer player);
    public bool PeacekeeperMode();
    public sealed virtual Transform GetEyes();
    public sealed virtual float GetFovScale();
    public sealed virtual BaseEntity GetEnt();
    public virtual bool CanControl(ulong playerID);
    public virtual bool get_RequiresMouse();
    public sealed virtual float get_MaxRange();
    public sealed virtual RemoteControllableControls get_RequiredControls();
    [CompilerGeneratedAttribute]
public int get_ViewerCount();
    [CompilerGeneratedAttribute]
public void set_ViewerCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<CameraViewerId> get_ControllingViewerId();
    [CompilerGeneratedAttribute]
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value);
    public bool get_IsBeingControlled();
    public sealed virtual bool InitializeControl(CameraViewerId viewerID);
    public sealed virtual void StopControl(CameraViewerId viewerID);
    public sealed virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public bool UpdateManualAim(InputState inputState);
    public virtual void InitShared();
    public virtual void DestroyShared();
    public sealed virtual void RCSetup();
    public sealed virtual void RCShutdown();
    [RPC_Server]
[MaxDistance("3")]
public void Server_SetID(RPCMessage msg);
    public sealed virtual void UpdateIdentifier(string newID, bool clientSend);
    public sealed virtual string GetIdentifier();
    public virtual bool CanChangeID(BasePlayer player);
    public virtual int ConsumptionAmount();
    public void SetOnline();
    public void SetIsOnline(bool online);
    public static void ProcessInterferenceQueue();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public void InitiateShutdown();
    public void InitiateStartup();
    public void SetPeacekeepermode(bool isOn);
    public bool IsValidWeapon(Item item);
    public bool CanAcceptItem(Item item, int targetSlot);
    public bool AtMaxAuthCapacity();
    public void UpdateMaxAuthCapacity();
    [IsVisible("3")]
[RPC_Server]
private void FlipAim(RPCMessage rpc);
    [RPC_Server]
[IsVisible("3")]
private void AddSelfAuthorize(RPCMessage rpc);
    public void AddSelfAuthorize(BasePlayer player);
    [RPC_Server]
[IsVisible("3")]
private void RemoveSelfAuthorize(RPCMessage rpc);
    [RPC_Server]
[IsVisible("3")]
private void ClearList(RPCMessage rpc);
    [RPC_Server]
[IsVisible("3")]
public void AssignToFriend(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
private void SERVER_Peacekeeper(RPCMessage rpc);
    [IsVisible("3")]
[RPC_Server]
private void SERVER_AttackAll(RPCMessage rpc);
    public virtual float TargetScanRate();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void OnEntityEnterTrigger(BaseNetworkable entity);
    public void SendAimDir();
    public void SendAimDirImmediate();
    public void SetTarget(BaseCombatEntity targ);
    public virtual bool CheckPeekers();
    public bool ObjectVisible(BaseCombatEntity obj);
    public virtual void FireAttachedGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target);
    public virtual void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target);
    public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal);
    public void IdleTick(float dt);
    public virtual bool HasClipAmmo();
    public virtual bool HasReserveAmmo();
    public int GetTotalAmmo();
    public AmmoTypes GetValidAmmoTypes();
    public ItemDefinition GetDesiredAmmo();
    public void Reload();
    public virtual void PostServerLoad();
    public void UpdateTotalAmmo();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public bool EnsureReloaded(bool onlyReloadIfEmpty);
    public BaseProjectile GetAttachedWeapon();
    public virtual bool HasFallbackWeapon();
    public bool HasGenericFireable();
    public void UpdateAttachedWeapon();
    public static HeldEntity TryAddWeaponToTurret(Item weaponItem, Transform parent, BaseEntity entityParent, float zOffsetScale);
    public virtual void OnKilled(HitInfo info);
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual float GetMaxAngleForEngagement();
    public void TargetTick();
    public bool HasTarget();
    public void OfflineTick();
    public virtual bool IsEntityHostile(BaseCombatEntity ent);
    public bool ShouldTarget(BaseCombatEntity targ);
    public void ScheduleForTargetScan();
    public bool HasInterference();
    public void TryRegisterForInterferenceUpdate();
    public void UpdateInterference();
    public virtual bool get_PreventDuplicatesInQueue();
    public void UpdateInterferenceOnOthers();
    public void UpdateNearbyTurrets(bool created);
    public void TargetScan();
    public virtual bool Ignore(BasePlayer player);
    public void ServerTick();
    public virtual void OnAttacked(HitInfo info);
    public void UpdateFacingToTarget(float dt);
    public float GetAngle(Vector3 launchPosition, Vector3 targetPosition, float launchVelocity, float gravityScale);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
}
public class AvatarSwitcher : StateMachineBehaviour {
    public Avatar ToApply;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class AverageVelocity : object {
    private Vector3 pos;
    private float time;
    private float lastEntry;
    private float averageSpeed;
    private Vector3 averageVelocity;
    public float Speed { get; }
    public Vector3 Average { get; }
    public void Record(Vector3 newPos);
    public float get_Speed();
    public Vector3 get_Average();
}
public class BackpackInventoryPanel : MonoBehaviour {
    private ItemIcon icon;
    public GameObject[] ShowWhenSelected;
    public GameObject[] HideWhenSelected;
    public Vector3 BackpackTargetRotation;
    public Vector3 BackpackTargetUIShift;
    public AnimationCurve BackpackModelRotateCurve;
    public AnimationCurve BackpackUIShiftCurve;
    public AnimationCurve BackpackTransparencyCurve;
    public AnimationCurve FadeOutWhenOpenCurve;
    public float OpenScale;
    public float CloseScale;
    public float BackpackAlphaActiveThreshold;
    public RectTransform PreviewModelRectTransform;
    public CanvasGroup BackpackInventoryCanvas;
    public CanvasGroup[] FadeOutWhenOpen;
}
public static class Ballistics : object {
    public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, Single& requiredGravity);
    public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, float minRange, Single& requiredGravity);
    public static bool TryGetPhysicsProjectileHitPos(Vector3 origin, Vector3 direction, float speed, float gravity, Vector3& result, float flightTimePerUpwardCheck, float flightTimePerDownwardCheck, float maxRays, BaseNetworkable owner);
    public static Vector3 GetBulletHitPoint(Vector3 origin, Vector3 direction);
    public static Vector3 GetBulletHitPoint(Ray aimRay);
    private static bool NextRayHitSomething(TheoreticalProjectile& projectile, float dt, BaseNetworkable owner);
    private static float ProjectileDistToGravity(float x, float y, float , float v);
}
public class BanditGuard : HumanNPC {
}
public class Barricade : DecayEntity {
    public float reflectDamage;
    public GameObjectRef reflectEffect;
    public bool canNpcSmash;
    public NavMeshModifierVolume NavMeshVolumeAnimals;
    public NavMeshModifierVolume NavMeshVolumeHumanoids;
    public NPCBarricadeTriggerBox NpcTriggerBox;
    private static int nonWalkableArea;
    private static int animalAgentTypeId;
    private static int humanoidAgentTypeId;
    private static Barricade();
    public virtual void ServerInit();
    public virtual void OnAttacked(HitInfo info);
}
public class BaseAIBrain : EntityComponent`1<BaseEntity> {
    public bool SendClientCurrentState;
    public bool UseQueuedMovementUpdates;
    public bool AllowedToSleep;
    public AIDesignSO DefaultDesignSO;
    public List`1<AIDesignSO> Designs;
    public AIDesign InstanceSpecificDesign;
    public float SenseRange;
    public float AttackRangeMultiplier;
    public float TargetLostRange;
    public float VisionCone;
    public bool CheckVisionCone;
    public bool CheckLOS;
    public bool IgnoreNonVisionSneakers;
    public float IgnoreSneakersMaxDistance;
    public float IgnoreNonVisionMaxDistance;
    public float ListenRange;
    public EntityType SenseTypes;
    public bool HostileTargetsOnly;
    public bool IgnoreSafeZonePlayers;
    public int MaxGroupSize;
    public float MemoryDuration;
    public bool RefreshKnownLOS;
    public bool CanBeBlinded;
    public float BlindDurationMultiplier;
    public float MovementTickStartDelay;
    [CompilerGeneratedAttribute]
private BasicAIState <CurrentState>k__BackingField;
    public AIState ClientCurrentState;
    public Vector3 mainInterestPoint;
    [CompilerGeneratedAttribute]
private AIThinkMode <ThinkMode>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Age>k__BackingField;
    [CompilerGeneratedAttribute]
private AIBrainSenses <Senses>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePathFinder <PathFinder>k__BackingField;
    public bool UseAIDesign;
    [CompilerGeneratedAttribute]
private AIEvents <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private AIDesign <AIDesign>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePlayer <DesigningPlayer>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePlayer <OwningPlayer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGroupLeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGrouped>k__BackingField;
    [CompilerGeneratedAttribute]
private IAIGroupable <GroupLeader>k__BackingField;
    public bool Pet;
    public List`1<IAIGroupable> groupMembers;
    [HeaderAttribute("Healing")]
public bool CanUseHealingItems;
    public float HealChance;
    public float HealBelowHealthFraction;
    protected int loadedDesignIndex;
    [CompilerGeneratedAttribute]
private BaseNavigator <Navigator>k__BackingField;
    public int currentStateContainerID;
    private float lastMovementTickTime;
    public bool sleeping;
    private bool disabled;
    public Dictionary`2<AIState, BasicAIState> states;
    protected float thinkRate;
    protected float lastThinkTime;
    protected float unblindTime;
    public BasicAIState CurrentState { get; public set; }
    public AIThinkMode ThinkMode { get; public set; }
    public float Age { get; public set; }
    public AIBrainSenses Senses { get; public set; }
    public BasePathFinder PathFinder { get; public set; }
    public AIEvents Events { get; public set; }
    public AIDesign AIDesign { get; public set; }
    public BasePlayer DesigningPlayer { get; public set; }
    public BasePlayer OwningPlayer { get; public set; }
    public bool IsGroupLeader { get; public set; }
    public bool IsGrouped { get; public set; }
    public IAIGroupable GroupLeader { get; public set; }
    public BaseNavigator Navigator { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public BasicAIState get_CurrentState();
    [CompilerGeneratedAttribute]
public void set_CurrentState(BasicAIState value);
    [CompilerGeneratedAttribute]
public AIThinkMode get_ThinkMode();
    [CompilerGeneratedAttribute]
public void set_ThinkMode(AIThinkMode value);
    [CompilerGeneratedAttribute]
public float get_Age();
    [CompilerGeneratedAttribute]
public void set_Age(float value);
    public void ForceSetAge(float age);
    [CompilerGeneratedAttribute]
public AIBrainSenses get_Senses();
    [CompilerGeneratedAttribute]
public void set_Senses(AIBrainSenses value);
    [CompilerGeneratedAttribute]
public BasePathFinder get_PathFinder();
    [CompilerGeneratedAttribute]
public void set_PathFinder(BasePathFinder value);
    [CompilerGeneratedAttribute]
public AIEvents get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(AIEvents value);
    [CompilerGeneratedAttribute]
public AIDesign get_AIDesign();
    [CompilerGeneratedAttribute]
public void set_AIDesign(AIDesign value);
    [CompilerGeneratedAttribute]
public BasePlayer get_DesigningPlayer();
    [CompilerGeneratedAttribute]
public void set_DesigningPlayer(BasePlayer value);
    [CompilerGeneratedAttribute]
public BasePlayer get_OwningPlayer();
    [CompilerGeneratedAttribute]
public void set_OwningPlayer(BasePlayer value);
    [CompilerGeneratedAttribute]
public bool get_IsGroupLeader();
    [CompilerGeneratedAttribute]
public void set_IsGroupLeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGrouped();
    [CompilerGeneratedAttribute]
public void set_IsGrouped(bool value);
    [CompilerGeneratedAttribute]
public IAIGroupable get_GroupLeader();
    [CompilerGeneratedAttribute]
public void set_GroupLeader(IAIGroupable value);
    public int LoadedDesignIndex();
    [CompilerGeneratedAttribute]
public BaseNavigator get_Navigator();
    [CompilerGeneratedAttribute]
public void set_Navigator(BaseNavigator value);
    public void SetEnabled(bool flag);
    private sealed virtual override bool IAIDesign.CanPlayerDesignAI(BasePlayer player);
    private bool PlayerCanDesignAI(BasePlayer player);
    [RPC_Server]
private void RequestAIDesign(RPCMessage msg);
    [RPC_Server]
private void SubmitAIDesign(RPCMessage msg);
    public sealed virtual override void IAIDesign.StopDesigning();
    public sealed virtual override void IAIDesign.LoadAIDesign(AIDesign design, BasePlayer player);
    public bool LoadDefaultAIDesign();
    public bool LoadAIDesignAtIndex(int index);
    public virtual void OnAIDesignLoadedAtIndex(int index);
    protected bool LoadAIDesign(AIDesign design, BasePlayer player, int index);
    public void SaveDesign();
    [RPC_Server]
private void StopAIDesign(RPCMessage msg);
    private void ClearDesigningPlayer();
    public void SetOwningPlayer(BasePlayer owner);
    public virtual bool ShouldServerThink();
    public virtual void DoThink();
    public List`1<AIState> GetStateList();
    public bool Blinded();
    public void SetBlinded(float duration);
    public void Start();
    public virtual void AddStates();
    public virtual void InitializeAI();
    public BaseEntity GetBrainBaseEntity();
    public virtual void OnDestroy();
    private void StartMovementTick();
    private void StopMovementTick();
    public void TickMovement();
    public void DoMovementTick();
    public void AddState(BasicAIState newState);
    public bool HasState(AIState state);
    public bool SwitchToState(AIState newState, int stateContainerID);
    private bool SwitchToState(BasicAIState newState, int stateContainerID);
    protected virtual void OnStateChanged();
    private void AddEvents(int stateContainerID);
    public virtual void Think(float delta);
    private void UpdateAgressionTimer(float delta);
    private sealed virtual override bool IAISleepable.AllowedToSleep();
    private sealed virtual override void IAISleepable.SleepAI();
    private sealed virtual override void IAISleepable.WakeAI();
    private void UpdateGroup();
    public sealed virtual bool AddMember(IAIGroupable member);
    public sealed virtual void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity);
    public sealed virtual void SetGroupRoamRootPosition(Vector3 rootPos);
    public sealed virtual bool InGroup();
    public sealed virtual void LeaveGroup();
    public sealed virtual void RemoveMember(IAIGroupable member);
    public sealed virtual void SetUngrouped();
    public virtual void LoadComponent(LoadInfo info);
    public virtual void SaveComponent(SaveInfo info);
    private void SendStateChangeEvent(int previousStateID, int newStateID, int sourceEventID);
    public sealed virtual void EventTriggeredStateChange(int newStateContainerID, int sourceEventID);
    public sealed virtual bool IsPet();
    public sealed virtual void SetPetOwner(BasePlayer player);
    public sealed virtual bool IsOwnedBy(BasePlayer player);
    public sealed virtual bool IssuePetCommand(PetCommandType cmd, int param, Nullable`1<Ray> ray);
}
public class BaseAIEvent : object {
    [CompilerGeneratedAttribute]
private AIEventType <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TriggerStateContainerID>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteRate <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inverted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutputEntityMemorySlot>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InputEntityMemorySlot>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseEntity <Owner>k__BackingField;
    private float executeTimer;
    protected float deltaTime;
    public AIEventType EventType { get; private set; }
    public int TriggerStateContainerID { get; private set; }
    public ExecuteRate Rate { get; protected set; }
    public float ExecutionRate { get; }
    public bool ShouldExecute { get; protected set; }
    public bool Result { get; protected set; }
    public bool Inverted { get; private set; }
    public int OutputEntityMemorySlot { get; protected set; }
    public bool ShouldSetOutputEntityMemory { get; }
    public int InputEntityMemorySlot { get; protected set; }
    public int ID { get; protected set; }
    public BaseEntity Owner { get; private set; }
    public bool HasValidTriggerState { get; }
    public BaseAIEvent(AIEventType type);
    [CompilerGeneratedAttribute]
public AIEventType get_EventType();
    [CompilerGeneratedAttribute]
private void set_EventType(AIEventType value);
    [CompilerGeneratedAttribute]
public int get_TriggerStateContainerID();
    [CompilerGeneratedAttribute]
private void set_TriggerStateContainerID(int value);
    [CompilerGeneratedAttribute]
public ExecuteRate get_Rate();
    [CompilerGeneratedAttribute]
protected void set_Rate(ExecuteRate value);
    public float get_ExecutionRate();
    [CompilerGeneratedAttribute]
public bool get_ShouldExecute();
    [CompilerGeneratedAttribute]
protected void set_ShouldExecute(bool value);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
protected void set_Result(bool value);
    [CompilerGeneratedAttribute]
public bool get_Inverted();
    [CompilerGeneratedAttribute]
private void set_Inverted(bool value);
    [CompilerGeneratedAttribute]
public int get_OutputEntityMemorySlot();
    [CompilerGeneratedAttribute]
protected void set_OutputEntityMemorySlot(int value);
    public bool get_ShouldSetOutputEntityMemory();
    [CompilerGeneratedAttribute]
public int get_InputEntityMemorySlot();
    [CompilerGeneratedAttribute]
protected void set_InputEntityMemorySlot(int value);
    [CompilerGeneratedAttribute]
public int get_ID();
    [CompilerGeneratedAttribute]
protected void set_ID(int value);
    [CompilerGeneratedAttribute]
public BaseEntity get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(BaseEntity value);
    public bool get_HasValidTriggerState();
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual void Init(int triggerStateContainer, int id, BaseEntity owner, int inputMemorySlot, int outputMemorySlot, bool inverted);
    public virtual AIEventData ToProto();
    public virtual void Reset();
    public void Tick(float deltaTime, IAIEventListener listener);
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
    public virtual void PostExecute();
    public void TriggerStateChange(IAIEventListener listener, int sourceEventID);
    public static BaseAIEvent CreateEvent(AIEventType eventType);
}
public class BaseAimable : BaseVehicleMountPoint {
    public Transform aimBase;
}
public class BaseAnimalNPC : BaseNpc {
    public string deathStatName;
    public AnimalBrain brain;
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void TryThink();
    public virtual void OnKilled(HitInfo hitInfo);
    public virtual void OnAttacked(HitInfo info);
    public virtual void PostServerLoad();
    public sealed virtual bool CanAttack(BaseEntity entity);
    public sealed virtual bool NeedsToReload();
    public sealed virtual float EngagementRange();
    public sealed virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public sealed virtual bool CanSeeTarget(BaseEntity entity);
    public sealed virtual bool Reload();
    public sealed virtual bool StartAttacking(BaseEntity target);
    public sealed virtual void StopAttacking();
    public sealed virtual float CooldownDuration();
    public sealed virtual bool IsOnCooldown();
    public sealed virtual bool IsTirednessAbove(float value);
    public sealed virtual void StartSleeping();
    public sealed virtual void StopSleeping();
    public sealed virtual bool IsHungerAbove(float value);
    public sealed virtual bool IsThreat(BaseEntity entity);
    public sealed virtual bool IsTarget(BaseEntity entity);
    public sealed virtual bool IsFriendly(BaseEntity entity);
    public sealed virtual float GetAmmoFraction();
    public sealed virtual BaseEntity GetBestTarget();
    public sealed virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
}
public class BaseArcadeGame : BaseMonoBehaviour {
    public static List`1<BaseArcadeGame> globalActiveGames;
    public Camera cameraToRender;
    public RenderTexture renderTexture;
    public Texture2D distantTexture;
    public Transform center;
    public int frameRate;
    public Dictionary`2<UInt32, ArcadeEntity> activeArcadeEntities;
    public Sprite[] spriteManifest;
    public ArcadeEntity[] entityManifest;
    public bool clientside;
    public bool clientsideInput;
    public static int spriteIndexInvisible;
    public GameObject arcadeEntityPrefab;
    public BaseArcadeMachine ownerMachine;
    public static int gameOffsetIndex;
    private bool isAuthorative;
    public Canvas canvas;
    private static BaseArcadeGame();
    public BasePlayer GetHostPlayer();
}
public class BaseArcadeMachine : BaseVehicle {
    public BaseArcadeGame arcadeGamePrefab;
    public BaseArcadeGame activeGame;
    public ArcadeNetworkTrigger networkTrigger;
    public float broadcastRadius;
    public Transform gameScreen;
    public RawImage RTImage;
    public Transform leftJoystick;
    public Transform rightJoystick;
    public SoundPlayer musicPlayer;
    public static Flags Flag_P1;
    public static Flags Flag_P2;
    public List`1<ScoreEntry> scores;
    private static int inputFrameRate;
    private static int snapshotFrameRate;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void AddScore(BasePlayer player, int score);
    [RPC_Server]
[IsVisible("3")]
public void RequestAddScore(RPCMessage msg);
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    protected virtual bool CanPushNow(BasePlayer pusher);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void NearbyClientMessage(string msg);
    [IsVisible("3")]
[RPC_Server]
public void DestroyMessageFromHost(RPCMessage msg);
    [CallsPerSecond("7")]
[RPC_Server]
[IsVisible("3")]
public void BroadcastEntityMessage(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("30")]
[IsVisible("3")]
public void GetSnapshotFromClient(RPCMessage msg);
}
public class BaseBoat : BaseVehicle {
    [HeaderAttribute("Boat")]
public float engineThrust;
    public float steeringScale;
    public Transform thrustPoint;
    public Transform centerOfMass;
    public Buoyancy buoyancy;
    public bool preventDecayIndoors;
    [HeaderAttribute("Correction Forces")]
public bool applyCorrectionForces;
    public Transform[] planeFitPoints;
    public Vector3 inAirPID;
    public float inAirDesiredPitch;
    public Vector3 wavePID;
    public MinMax correctionRange;
    public float correctionSpringForce;
    public float correctionSpringDamping;
    private Vector3[] worldAnchors;
    private PidQuaternionController pidController;
    [ServerVar]
public static bool generate_paths;
    [ServerVar]
public static bool do_shore_drift;
    public static int secondsUntilShoreDrift;
    public static int secondsBetweenShoreDrift;
    [ServerVar]
[HelpAttribute("Shore drift speed in metres per second")]
public static float drift_speed;
    public float gasPedal;
    public float steering;
    private TimeSince shoreDriftTimer;
    private string lastDriftCheckStatus;
    protected bool AllowKinematicDrift { get; }
    private static BaseBoat();
    [HelpAttribute("Seconds until boat starts drifting to shore if there's nobody around")]
[ServerVar]
public static int seconds_until_shore_drift(Arg arg);
    [ServerVar]
[HelpAttribute("Seconds between shore drift teleport ticks")]
public static int seconds_between_shore_drift(Arg arg);
    public bool InDryDock();
    public virtual float MaxVelocity();
    protected virtual bool get_AllowKinematicDrift();
    public virtual void ServerInit();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void DriverInput(InputState inputState, BasePlayer player);
    public sealed virtual void OnPoolDestroyed();
    public sealed virtual void WakeUp();
    protected virtual void OnServerWake();
    public virtual bool EngineOn();
    public virtual void VehicleFixedUpdate();
    protected void ApplyCorrectionForces();
    public static void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors);
    private void CheckDriftToShore();
    private void GoToSleep();
    public virtual bool AnyPlayersOnBoat();
    public string GetDriftStatus();
    public static void UpdateShoreDriftInvokeOnAll();
    private void UpdateShoreDriftInvoke();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    public static List`1<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth);
}
public class BaseBulb : MonoBehaviour {
    public Renderer bulbRenderer;
}
public abstract class BaseCardGameEntity : BaseVehicle {
    [HeaderAttribute("Card Game")]
[SerializeField]
private GameObjectRef uiPrefab;
    public ItemDefinition scrapItemDef;
    [SerializeField]
private GameObjectRef potPrefab;
    public PlayerStorageInfo[] playerStoragePoints;
    [SerializeField]
private GameObjectRef playerStoragePrefab;
    private CardGameController _gameCont;
    public CardGameOption gameOption;
    public EntityRef PotInstance;
    private bool storageLinked;
    public int ScrapItemID { get; }
    public CardGameController GameController { get; }
    protected float MaxStorageInteractionDist { get; }
    public bool CanSwapSeats { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int get_ScrapItemID();
    public CardGameController get_GameController();
    protected abstract virtual float get_MaxStorageInteractionDist();
    public virtual void Load(LoadInfo info);
    private CardGameController GetGameController();
    public virtual void DestroyShared();
    public virtual bool get_CanSwapSeats();
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    public virtual void PrePlayerDismount(BasePlayer player, BaseMountable seat);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public StorageContainer GetPot();
    public BasePlayer IDToPlayer(ulong id);
    public virtual void PlayerStorageChanged();
    public CardGamePlayerStorage GetPlayerStorage(int storageIndex);
    public CardGamePlayerStorage GetPlayerStorage(ulong playerID);
    public int GetMountPointIndex(ulong playerID);
    public virtual void SpawnSubEntities();
    [IsVisible("3")]
[RPC_Server]
private void RPC_PlayerInput(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
private void RPC_LeaveTable(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
private void RPC_OpenLoot(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_Editor_SpawnTestPlayer(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_Editor_MakeRandomMove(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
private void RPC_Play(RPCMessage msg);
}
public class BaseChair : BaseMountable {
    public virtual float GetComfort();
}
public class BaseCollision : MonoBehaviour {
    public BaseEntity Owner;
    public Model model;
}
public class BaseCombatEntity : BaseEntity {
    [HeaderAttribute("BaseCombatEntity")]
public SkeletonProperties skeletonProperties;
    public ProtectionProperties baseProtection;
    public float startHealth;
    public Pickup pickup;
    public Repair repair;
    public bool ShowHealthInfo;
    [ReadOnlyAttribute]
public LifeState lifestate;
    public bool sendsHitNotification;
    public bool sendsMeleeHitNotification;
    public bool markAttackerHostile;
    public float _health;
    public float _maxHealth;
    public Faction faction;
    public float lastAttackedTime;
    [CompilerGeneratedAttribute]
private Vector3 <LastAttackedDir>k__BackingField;
    public float lastDealtDamageTime;
    public int lastNotifyFrame;
    private static float MAX_HEALTH_REPAIR;
    public static Phrase RecentlyDamagedError;
    public static Phrase NotDamagedError;
    public DamageType lastDamage;
    public BaseEntity lastAttacker;
    public BaseEntity lastDealtDamageTo;
    public bool ResetLifeStateOnSpawn;
    public DirectionProperties[] propDirection;
    public float unHostileTime;
    [CompilerGeneratedAttribute]
private ActionVolume <LastNoiseVolume>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <LastNoisePosition>k__BackingField;
    public float lastNoiseTime;
    public Vector3 LastAttackedDir { get; public set; }
    public float SecondsSinceAttacked { get; }
    public float SecondsSinceDealtDamage { get; }
    public float healthFraction { get; }
    public float health { get; public set; }
    public float TimeSinceLastNoise { get; }
    public ActionVolume LastNoiseVolume { get; private set; }
    public Vector3 LastNoisePosition { get; private set; }
    private static BaseCombatEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool IsDead();
    public virtual bool IsAlive();
    public Faction GetFaction();
    public virtual bool IsFriendly(BaseCombatEntity other);
    [CompilerGeneratedAttribute]
public Vector3 get_LastAttackedDir();
    [CompilerGeneratedAttribute]
public void set_LastAttackedDir(Vector3 value);
    public float get_SecondsSinceAttacked();
    public float get_SecondsSinceDealtDamage();
    public float get_healthFraction();
    public virtual void ResetState();
    public virtual void DestroyShared();
    public virtual float GetThreatLevel();
    public virtual float PenetrationResistance(HitInfo info);
    public virtual void ScaleDamage(HitInfo info);
    public HitArea SkeletonLookup(UInt32 boneID);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public void SetJustAttacked();
    public virtual void Load(LoadInfo info);
    public float get_health();
    public void set_health(float value);
    public virtual float Health();
    public virtual float MaxHealth();
    public virtual float StartHealth();
    public virtual float StartMaxHealth();
    public void SetMaxHealth(float newMax);
    public void DoHitNotify(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
    protected virtual int GetPickupCount();
    public virtual bool CanPickup(BasePlayer player);
    public virtual void OnPickedUp(Item createdItem, BasePlayer player);
    public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_PickupStart(RPCMessage rpc);
    public virtual List`1<ItemAmount> BuildCost();
    public virtual float RepairCostFraction();
    public List`1<ItemAmount> RepairCost(float healthMissingFraction);
    public virtual void OnRepair();
    public virtual void OnRepairFinished();
    public virtual void OnRepairFailed(BasePlayer player, Phrase reason, String[] args);
    public virtual void OnRepairFailedResources(BasePlayer player, List`1<ItemAmount> requirements);
    public virtual void DoRepair(BasePlayer player);
    public virtual void InitializeHealth(float newhealth, float newmax);
    public virtual void ServerInit();
    public virtual void OnHealthChanged(float oldvalue, float newvalue);
    public void Hurt(float amount);
    public void Hurt(float amount, DamageType type, BaseEntity attacker, bool useProtection);
    public virtual void Hurt(HitInfo info);
    public virtual bool IsHostile();
    public virtual void MarkHostileFor(float duration);
    private void DebugHurt(HitInfo info);
    public void SetHealth(float hp);
    public virtual void Heal(float amount);
    public virtual void OnKilled(HitInfo info);
    public virtual void Die(HitInfo info);
    public void DieInstantly();
    public void UpdateSurroundings();
    public float get_TimeSinceLastNoise();
    [CompilerGeneratedAttribute]
public ActionVolume get_LastNoiseVolume();
    [CompilerGeneratedAttribute]
private void set_LastNoiseVolume(ActionVolume value);
    [CompilerGeneratedAttribute]
public Vector3 get_LastNoisePosition();
    [CompilerGeneratedAttribute]
private void set_LastNoisePosition(Vector3 value);
    public void MakeNoise(Vector3 position, ActionVolume loudness);
    public bool CanLastNoiseBeHeard(Vector3 listenPosition, float listenRange);
}
public class BaseCommandBuffer : MonoBehaviour {
    private Dictionary`2<Camera, Dictionary`2<int, CommandBuffer>> cameras;
    protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent);
    protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent);
    protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent);
    protected void Cleanup();
}
public class BaseCorpse : BaseCombatEntity {
    public GameObjectRef prefabRagdoll;
    public BaseEntity parentEnt;
    public ResourceDispenser resourceDispenser;
    public static float CORPSE_SLEEP_THRESHOLD;
    protected Rigidbody rigidBody;
    public bool blockDamageIfNotGather;
    public SpawnGroup spawnGroup;
    private static float RAGDOLL_PUSH_DIST;
    private static float RAGDOLL_PUSH_FORCE;
    public bool CorpseIsRagdoll { get; }
    public TraitFlag Traits { get; }
    public virtual bool get_CorpseIsRagdoll();
    public virtual void ResetState();
    public virtual void ServerInit();
    public virtual void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState);
    public virtual bool CanRemove();
    public void RemoveCorpse();
    public void ResetRemovalTime(float dur);
    public virtual float GetRemovalTime();
    public void ResetRemovalTime();
    public virtual void Save(SaveInfo info);
    public void TakeChildren(BaseEntity takeChildrenFrom);
    public virtual void ApplyInheritedVelocity(Vector3 velocity);
    private Rigidbody SetupRigidBody();
    public virtual void Load(LoadInfo info);
    private void Load(Corpse corpse);
    public virtual void OnAttacked(HitInfo info);
    protected virtual void PushRagdoll(HitInfo info);
    protected void PushRigidbodies(List`1<Rigidbody> rbs, Vector3 hitPos, Vector3 hitNormal);
    public virtual string Categorize();
    public virtual TraitFlag get_Traits();
    public virtual void Eat(BaseNpc baseNpc, float timeSpent);
    public virtual bool ShouldInheritNetworkGroup();
}
public class BaseDetector : IOEntity {
    public PlayerDetectionTrigger myTrigger;
    public static Flags Flag_HasContents;
    public virtual int ConsumptionAmount();
    public virtual bool ShouldTrigger();
    public virtual void OnObjects();
    public sealed virtual void OnObjectAdded(GameObject obj, Collider col);
    public virtual void OnEmpty();
    public virtual void OnDetectorTriggered();
    public virtual void OnDetectorReleased();
    public virtual int GetPassthroughAmount(int outputSlot);
}
public class BaseDiggableEntity : BaseCombatEntity {
    public bool RequiresShovel;
    public Vector3 DropOffset;
    public Vector3 DropVelocity;
    public int RequiredDigCount;
    public bool DestroyOnDug;
    [HeaderAttribute("Loot")]
public List`1<DiggableEntityLoot> LootLists;
    public int digsRemaining;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void Hurt(HitInfo info);
    public virtual void Dig(BasePlayer player);
    public virtual void OnFirstDig(BasePlayer player);
    public virtual void OnSingleDig(BasePlayer player);
    public virtual void OnFullyDug(BasePlayer player);
    public BaseEntity SpawnItem();
    private Nullable`1<ItemEntry> GetItem(Vector3 digWorldPos);
}
public class BaseEntity : BaseNetworkable {
    [HeaderAttribute("BaseEntity")]
public Bounds bounds;
    public GameObjectRef impactEffect;
    public bool enableSaving;
    public bool syncPosition;
    public Model model;
    public Flags flags;
    public UInt32 parentBone;
    public ulong skinID;
    private EntityComponentBase[] _components;
    [HideInInspector]
public bool HasBrain;
    private float nextHeightCheckTime;
    private bool cachedUnderground;
    public string _name;
    [CompilerGeneratedAttribute]
private ulong <OwnerID>k__BackingField;
    private static Queue`1<BaseEntity> globalBroadcastQueue;
    private static UInt32 globalBroadcastProtocol;
    private UInt32 broadcastProtocol;
    public List`1<EntityLink> links;
    private bool linkedToNeighbours;
    private TimeUntil _transferProtectionRemaining;
    private Action _disableTransferProtectionAction;
    public static string RpcClientDeprecationNotice;
    public Spawnable _spawnable;
    public static HashSet`1<BaseEntity> saveList;
    public BaseEntity creatorEntity;
    private bool couldSaveOriginally;
    public int ticksSinceStopped;
    public bool isCallingUpdateNetworkGroup;
    private EntityRef[] entitySlots;
    public List`1<TriggerBase> triggers;
    protected bool isVisible;
    protected bool isAnimatorVisible;
    protected bool isShadowVisible;
    protected OccludeeSphere localOccludee;
    [CompilerGeneratedAttribute]
private float <Weight>k__BackingField;
    public float RealisticMass { get; }
    public EntityComponentBase[] Components { get; }
    public bool IsNpc { get; }
    public ulong OwnerID { get; public set; }
    protected float TransferProtectionRemaining { get; }
    protected Action DisableTransferProtectionAction { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public float PositionTickRate { get; }
    public bool PositionTickFixedTime { get; }
    public Vector3 ServerPosition { get; public set; }
    public Quaternion ServerRotation { get; public set; }
    public float radiationLevel { get; }
    public float currentTemperature { get; }
    public float currentEnvironmentalWetness { get; }
    public TraitFlag Traits { get; }
    public float Weight { get; protected set; }
    private static BaseEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float get_RealisticMass();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    protected void ReceiveCollisionMessages(bool b);
    public EntityComponentBase[] get_Components();
    public virtual BasePlayer ToPlayer();
    public virtual bool get_IsNpc();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public virtual void ResetState();
    public virtual float InheritedVelocityScale();
    public virtual bool InheritedVelocityDirection();
    public virtual Vector3 GetInheritedProjectileVelocity(Vector3 direction);
    public virtual Vector3 GetInheritedThrowVelocity(Vector3 direction);
    public virtual Vector3 GetInheritedDropVelocity();
    public Vector3 GetParentVelocity();
    public sealed virtual Vector3 GetWorldVelocity();
    public Vector3 GetLocalVelocity();
    public Quaternion GetAngularVelocity();
    public virtual OBB WorldSpaceBounds();
    public Vector3 PivotPoint();
    public sealed virtual Vector3 CenterPoint();
    public Vector3 ClosestPoint(Vector3 position);
    public virtual Vector3 TriggerPoint();
    public sealed virtual float Distance(Vector3 position);
    public float SqrDistance(Vector3 position);
    public float Distance(BaseEntity other);
    public float SqrDistance(BaseEntity other);
    public float Distance2D(Vector3 position);
    public float SqrDistance2D(Vector3 position);
    public float Distance2D(BaseEntity other);
    public float SqrDistance2D(BaseEntity other);
    public bool IsVisible(Ray ray, int layerMask, float maxDistance);
    public bool IsVisibleSpecificLayers(Vector3 position, Vector3 target, int layerMask, float maxDistance);
    public bool IsVisible(Vector3 position, Vector3 target, float maxDistance);
    public sealed virtual bool IsVisible(Vector3 position, float maxDistance);
    public bool IsVisibleAndCanSee(Vector3 position);
    public bool IsVisibleAndCanSeeLegacy(Vector3 position, float maxDistance);
    public bool CanSee(Vector3 fromPos, Vector3 targetPos);
    public bool IsOlderThan(BaseEntity other);
    public virtual bool IsOutside();
    public bool IsOutside(Vector3 position);
    public bool IsUnderground(bool cached);
    public virtual float WaterFactor();
    public virtual float AirFactor();
    public bool WaterTestFromVolumes(Vector3 pos, WaterInfo& info);
    public bool IsInWaterVolume(Vector3 pos, Boolean& natural);
    public bool WaterTestFromVolumes(Bounds bounds, WaterInfo& info);
    public bool WaterTestFromVolumes(Vector3 start, Vector3 end, float radius, WaterInfo& info);
    public virtual bool BlocksWaterFor(BasePlayer player);
    public virtual float Health();
    public virtual float MaxHealth();
    public virtual float MaxVelocity();
    public virtual float BoundsPadding();
    public virtual float PenetrationResistance(HitInfo info);
    public virtual GameObjectRef GetImpactEffect(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
    public virtual Item GetItem();
    public virtual Item GetItem(ItemId itemId);
    public virtual void GiveItem(Item item, GiveItemReason reason);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual BaseEntity GetEntity();
    public virtual string ToString();
    public virtual string Categorize();
    public void Log(string str);
    public void SetModel(Model mdl);
    public Model GetModel();
    public virtual Transform[] GetBones();
    public virtual Transform FindBone(string strName);
    public virtual UInt32 FindBoneID(Transform boneTransform);
    public virtual Transform FindClosestBone(Vector3 worldPos);
    [CompilerGeneratedAttribute]
public ulong get_OwnerID();
    [CompilerGeneratedAttribute]
public void set_OwnerID(ulong value);
    public virtual bool ShouldBlockProjectiles();
    public virtual bool ShouldInheritNetworkGroup();
    public virtual bool SupportsChildDeployables();
    public virtual bool ForceDeployableSetParent();
    public bool IsOnMovingObject();
    public void BroadcastEntityMessage(string msg, float radius, int layerMask);
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public virtual void DebugServer(int rep, float time);
    public virtual string DebugText();
    public void OnDebugStart();
    protected void DebugText(Vector3 pos, string str, Color color, float time);
    public sealed virtual bool HasFlag(Flags f);
    public bool HasAny(Flags f);
    public bool ParentHasFlag(Flags f);
    public sealed virtual void SetFlag(Flags f, bool b, bool recursive, bool networkupdate);
    public bool IsOn();
    public bool IsOpen();
    public bool IsOnFire();
    public bool IsLocked();
    public virtual bool IsDebugging();
    public bool IsDisabled();
    public bool IsBroken();
    public bool IsBusy();
    public bool IsTransferProtected();
    public bool IsTransferring();
    public virtual string GetLogColor();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public void SendNetworkUpdate_Flags();
    public virtual bool IsOccupied(Socket_Base socket);
    public bool IsOccupied(string socketName);
    public EntityLink FindLink(Socket_Base socket);
    public EntityLink FindLink(string socketName);
    public EntityLink FindLink(String[] socketNames);
    public T FindLinkedEntity();
    public void EntityLinkMessage(Action`1<T> action);
    public void EntityLinkBroadcast(Action`1<T> action, Func`2<S, bool> canTraverseSocket);
    public void EntityLinkBroadcast(Action`1<T> action);
    public void EntityLinkBroadcast();
    public bool ReceivedEntityLinkBroadcast();
    public List`1<EntityLink> GetEntityLinks(bool linkToNeighbours);
    private void LinkToEntity(BaseEntity other);
    private void LinkToNeighbours();
    private void InitEntityLinks();
    private void FreeEntityLinks();
    public void RefreshEntityLinks();
    [RPC_Server]
public void SV_RequestFile(RPCMessage msg);
    protected float get_TransferProtectionRemaining();
    protected Action get_DisableTransferProtectionAction();
    public virtual void EnableTransferProtection();
    public virtual void DisableTransferProtection();
    public void SetParent(BaseEntity entity, bool worldPositionStays, bool sendImmediate);
    public void SetParent(BaseEntity entity, string strBone, bool worldPositionStays, bool sendImmediate);
    public bool HasChild(BaseEntity c);
    public void SetParent(BaseEntity entity, UInt32 boneID, bool worldPositionStays, bool sendImmediate);
    public void DestroyOnClient(Connection connection);
    public void SendChildrenNetworkUpdate();
    public void SendChildrenNetworkUpdateImmediate();
    public virtual void SwitchParent(BaseEntity ent);
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    public virtual EntityPrivilege GetEntityBuildingPrivilege();
    public virtual BuildingPrivlidge GetBuildingPrivilege();
    public BuildingPrivlidge GetNearestBuildingPrivledge();
    public BuildingPrivlidge GetBuildingPrivilege(OBB obb);
    public void SV_RPCMessage(UInt32 nameID, Message message);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1, T2 arg2);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName, T1 arg1);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPC(Connection sourceConnection, string funcName);
    public void ClientRPC(RpcTarget target);
    public void ClientRPC(RpcTarget target, T1 arg1);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public void ClientRPC(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    private void GetRpcTargetNetworkGroup(RpcTarget& target);
    private void FreeRPCTarget(RpcTarget target);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1);
    [ObsoleteAttribute("Use ClientRPC( RpcTarget ) overloads")]
public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName);
    protected NetWrite ClientRPCStart(string funcName);
    private void ClientRPCWrite(NetWrite write, T arg);
    protected void ClientRPCSend(NetWrite write, SendInfo sendInfo);
    public void ClientRPCPlayerList(Connection sourceConnection, BasePlayer player, string funcName, List`1<T1> list);
    public virtual void Save(SaveInfo info);
    public virtual bool ShouldNetworkOwnerInfo();
    public virtual bool get_ShouldTransferAssociatedFiles();
    public virtual void Load(LoadInfo info);
    public virtual void SetCreatorEntity(BaseEntity newCreatorEntity);
    public virtual Vector3 GetLocalVelocityServer();
    public virtual Quaternion GetAngularVelocityServer();
    public void EnableGlobalBroadcast(bool wants);
    public void EnableSaving(bool wants);
    public void RestoreCanSave();
    public virtual void ServerInit();
    public virtual void OnPlaced(BasePlayer player);
    public virtual float get_PositionTickRate();
    public virtual bool get_PositionTickFixedTime();
    protected virtual bool ShouldUpdateNetworkGroup();
    protected virtual bool ShouldUpdateNetworkPosition();
    public void NetworkPositionTick();
    public void TransformChanged();
    public virtual void OnPositionalNetworkUpdate();
    public virtual void Spawn();
    public sealed virtual void OnParentSpawning();
    public void SpawnAsMapEntity();
    public virtual void PostMapEntitySpawn();
    internal virtual void DoServerDestroy();
    internal virtual void OnParentRemoved();
    public virtual void OnInvalidPosition();
    public BaseCorpse DropCorpse(string strCorpsePrefab, PlayerFlags playerFlagsOnDeath, ModelState modelState);
    public BaseCorpse DropCorpse(string strCorpsePrefab, Vector3 posOnDeath, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState);
    public virtual void UpdateNetworkGroup();
    public virtual void Eat(BaseNpc baseNpc, float timeSpent);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual bool ShouldNetworkTo(BasePlayer player);
    public virtual void AttackerInfo(DeathInfo info);
    public virtual void Push(Vector3 velocity);
    public virtual void ApplyInheritedVelocity(Vector3 velocity);
    public virtual void SetVelocity(Vector3 velocity);
    public virtual void SetAngularVelocity(Vector3 velocity);
    public virtual Vector3 GetDropPosition();
    public virtual Vector3 GetDropVelocity();
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual Vector3 get_ServerPosition();
    public virtual void set_ServerPosition(Vector3 value);
    public virtual Quaternion get_ServerRotation();
    public virtual void set_ServerRotation(Quaternion value);
    public virtual string Admin_Who();
    public virtual bool BuoyancyWake();
    public virtual bool BuoyancySleep(bool inWater);
    public float get_radiationLevel();
    public virtual float RadiationProtection();
    public virtual float RadiationExposureFraction();
    public float get_currentTemperature();
    public float get_currentEnvironmentalWetness();
    [FromOwner]
[RPC_Server]
private void BroadcastSignalFromClient(RPCMessage msg);
    protected virtual void OnReceivedSignalServer(Signal signal, string arg);
    public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection);
    public void SignalBroadcast(Signal signal, Connection sourceConnection);
    public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection, string fallbackEffect);
    protected virtual void OnSkinChanged(ulong oldSkinID, ulong newSkinID);
    protected virtual void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public bool HasAnySlot();
    public BaseEntity GetSlot(Slot slot);
    public string GetSlotAnchorName(Slot slot);
    public void SetSlot(Slot slot, BaseEntity ent);
    public EntityRef[] GetSlots();
    public void SetSlots(EntityRef[] newSlots);
    public virtual bool HasSlot(Slot slot);
    public virtual TraitFlag get_Traits();
    public bool HasTrait(TraitFlag f);
    public bool HasAnyTrait(TraitFlag f);
    public virtual bool EnterTrigger(TriggerBase trigger);
    public virtual void LeaveTrigger(TriggerBase trigger);
    public void RemoveFromTriggers();
    public T FindTrigger();
    public bool FindTrigger(T& result);
    private void ForceUpdateTriggersAction();
    public void ForceUpdateTriggers(bool enter, bool exit, bool invoke);
    public virtual bool InSafeZone();
    public TriggerParent FindSuitableParent();
    [CompilerGeneratedAttribute]
public float get_Weight();
    [CompilerGeneratedAttribute]
protected void set_Weight(float value);
}
public class BaseEntityChild : MonoBehaviour {
    public static void Setup(GameObject obj, BaseEntity parent);
    public void OnDestroy();
}
[ExtensionAttribute]
public static class BaseEntityEx : object {
    [ExtensionAttribute]
public static bool IsValidEntityReference(T obj);
    [ExtensionAttribute]
public static bool HasEntityInParents(BaseEntity ent, BaseEntity toFind);
}
public class BaseEntityRef : ResourceRef`1<BaseEntity> {
    public virtual BaseEntity Get();
}
public class BaseEventUI : MonoBehaviour {
    public RustText TextEventType;
    public RustText TextOutput;
    public RustButton ToggleInvert;
    public Dropdown DropdownInputMemorySlot;
    public Dropdown DropdownOutputMemorySlot;
    public RustInput InputFloatValue;
    public RustInput InputFloatValue2;
    [HideInInspector]
public AIEventType EventType;
    [HideInInspector]
public BaseStateUI Output;
}
public class BaseFirework : BaseCombatEntity {
    public float fuseLength;
    public float activityLength;
    public static Flags Flag_Spent;
    public float corpseDuration;
    public bool limitActiveCount;
    [ServerVar]
public static int maxActiveFireworks;
    public static HashSet`1<BaseFirework> _activeFireworks;
    private static BaseFirework();
    public bool IsLit();
    public bool IsExhausted();
    public static int NumActiveFireworks();
    public virtual void TryLightFuse();
    public virtual void Begin();
    public virtual void OnExhausted();
    public void Cleanup();
    internal virtual void DoServerDestroy();
    public virtual void OnAttacked(HitInfo info);
    public sealed virtual void Ignite(Vector3 fromPos);
    public void StaggeredTryLightFuse();
    public sealed virtual bool CanIgnite();
    public virtual bool CanPickup(BasePlayer player);
}
public class BaseFishingRod : HeldEntity {
    public GameObjectRef FishingBobberRef;
    public float FishCatchDistance;
    public LineRenderer ReelLineRenderer;
    public Transform LineRendererWorldStartPos;
    [CompilerGeneratedAttribute]
private CatchState <CurrentState>k__BackingField;
    private FishState currentFishState;
    private EntityRef`1<FishingBobber> currentBobber;
    public float ConditionLossOnSuccess;
    public float ConditionLossOnFail;
    public float GlobalStrainSpeedMultiplier;
    public float MaxCastDistance;
    public static Flags Straining;
    public ItemModFishable ForceFish;
    public static Flags PullingLeftFlag;
    public static Flags PullingRightFlag;
    public static Flags ReelingInFlag;
    public GameObjectRef BobberPreview;
    public SoundDefinition onLineSoundDef;
    public SoundDefinition strainSoundDef;
    public AnimationCurve strainGainCurve;
    public SoundDefinition tensionBreakSoundDef;
    public static UpdateFishingRod updateFishingRodQueue;
    private TimeUntil nextFishStateChange;
    private TimeSince fishCatchDuration;
    private float strainTimer;
    private static float strainMax;
    private TimeSince lastStrainUpdate;
    private TimeUntil catchTime;
    private TimeSince lastSightCheck;
    private Vector3 playerStartPosition;
    private WaterBody surfaceBody;
    private ItemDefinition lureUsed;
    private ItemDefinition currentFishTarget;
    private ItemModFishable fishableModifier;
    private ItemModFishable lastFish;
    private bool inQueue;
    [ServerVar]
public static bool ForceSuccess;
    [ServerVar]
public static bool ForceFail;
    [ServerVar]
public static bool ImmediateHook;
    public CatchState CurrentState { get; private set; }
    private static BaseFishingRod();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public CatchState get_CurrentState();
    [CompilerGeneratedAttribute]
private void set_CurrentState(CatchState value);
    public virtual void Load(LoadInfo info);
    public virtual bool BlocksGestures();
    private bool AllowPullInDirection(Vector3 worldDirection, Vector3 bobberPosition);
    private bool EvaluateFishingPosition(Vector3& pos, BasePlayer ply, FailReason& reason, WaterBody& waterBody);
    private Item GetCurrentLure();
    private bool HasReelInInput(InputState state);
    [IsActiveItem]
[RPC_Server]
private void Server_RequestCast(RPCMessage msg);
    private void FailedCast(FailReason reason);
    private void CatchProcess();
    private void CatchProcessBudgeted();
    private void ResetLine();
    [IsActiveItem]
[RPC_Server]
private void Server_Cancel(RPCMessage msg);
    private void Server_Cancel(FailReason reason);
    public virtual void OnHeldChanged();
    public virtual void Save(SaveInfo info);
    private void UpdateFlags(bool inputLeft, bool inputRight, bool back);
}
public class BaseFishNPC : BaseNpc {
    protected FishBrain brain;
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void TryThink();
    public sealed virtual bool CanAttack(BaseEntity entity);
    public sealed virtual bool NeedsToReload();
    public sealed virtual float EngagementRange();
    public sealed virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public sealed virtual bool CanSeeTarget(BaseEntity entity);
    public sealed virtual bool Reload();
    public sealed virtual bool StartAttacking(BaseEntity target);
    public sealed virtual void StopAttacking();
    public sealed virtual float CooldownDuration();
    public sealed virtual bool IsOnCooldown();
    public sealed virtual bool IsThreat(BaseEntity entity);
    public sealed virtual bool IsTarget(BaseEntity entity);
    public sealed virtual bool IsFriendly(BaseEntity entity);
    public sealed virtual float GetAmmoFraction();
    public sealed virtual BaseEntity GetBestTarget();
    public sealed virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
}
public abstract class BaseFootstepEffect : MonoBehaviour {
    public LayerMask validImpactLayers;
}
public class BaseFuelLightSource : BaseOven {
}
public class BaseGameMode : BaseEntity {
    private GameMode gameModeScores;
    public String[] scoreColumns;
    [HeaderAttribute("Vanilla")]
public bool globalChat;
    public bool localChat;
    public bool teamSystem;
    public bool safeZone;
    public bool ingameMap;
    public bool compass;
    public bool contactSystem;
    public bool crawling;
    public bool rustPlus;
    public bool wipeBpsOnProtocol;
    public int maximumSleepingBags;
    public bool returnValidCombatlog;
    public bool missionSystem;
    public bool mlrs;
    public static Flags Flag_Warmup;
    public static Flags Flag_GameOver;
    public static Flags Flag_WaitingForPlayers;
    [HeaderAttribute("Changelog")]
public Phrase[] addedFeatures;
    public Phrase[] removedFeatures;
    public Phrase[] changedFeatures;
    public List`1<string> convars;
    [CompilerGeneratedAttribute]
private static Action`1<BaseGameMode> GameModeChanged;
    public string shortname;
    public float matchDuration;
    public float warmupDuration;
    public float timeBetweenMatches;
    public int minPlayersToStart;
    public bool useCustomSpawns;
    public string victoryScoreName;
    public string teamScoreName;
    public int numScoreForVictory;
    public string gamemodeTitle;
    public SoundDefinition[] warmupMusics;
    public SoundDefinition[] lossMusics;
    public SoundDefinition[] winMusics;
    private float warmupStartTime;
    private float matchStartTime;
    private float matchEndTime;
    public List`1<string> gameModeTags;
    public CameraMode deathCameraMode;
    public bool permanent;
    public bool limitTeamAuths;
    public bool allowSleeping;
    public bool allowWounding;
    public bool allowBleeding;
    public bool allowTemperature;
    public bool quickRespawn;
    public bool quickDeploy;
    public float respawnDelayOverride;
    public float startHealthOverride;
    public float autoHealDelay;
    public float autoHealDuration;
    public float corpseRemovalTimeOverride;
    public bool hasKillFeed;
    public bool allowPings;
    public static BaseGameMode svActiveGameMode;
    public static List`1<BaseGameMode> svGameModeManifest;
    private GameObject[] allspawns;
    private GameModeSpawnGroup[] gameModeSpawnGroups;
    public PlayerInventoryProperties[] loadouts;
    [TooltipAttribute("Use steamID to always pick the same loadout per player")]
public bool useStaticLoadoutPerPlayer;
    public bool topUpMagazines;
    public bool sendKillNotifications;
    public GameModeTeam[] teams;
    private static bool isResetting;
    private static BaseGameMode();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public GameMode GetGameScores();
    public int ScoreColumnIndex(string scoreName);
    public void InitScores();
    public void CopyGameModeScores(GameMode from, GameMode to);
    public PlayerScore GetPlayerScoreForPlayer(BasePlayer player);
    public int GetScoreIndexByName(string name);
    public virtual bool IsDraw();
    public virtual string GetWinnerName();
    public virtual int GetPlayerTeamPosition(BasePlayer player);
    public virtual int GetPlayerRank(BasePlayer player);
    public int GetWinningTeamIndex();
    public virtual bool DidPlayerWin(BasePlayer player);
    public bool IsTeamGame();
    public bool KeepScores();
    public void ModifyTeamScore(int teamIndex, int modifyAmount);
    public void SetTeamScore(int teamIndex, int score);
    public virtual void ResetPlayerScores(BasePlayer player);
    public void ModifyPlayerGameScore(BasePlayer player, string scoreName, int modifyAmount);
    public void ModifyPlayerGameScore(BasePlayer player, int scoreIndex, int modifyAmount);
    public int GetPlayerGameScore(BasePlayer player, int scoreIndex);
    public void SetPlayerTeam(BasePlayer player, int newTeam);
    public void SetPlayerGameScore(BasePlayer player, int scoreIndex, int scoreValue);
    public int GetMaxBeds(BasePlayer player);
    protected virtual void SetupTags();
    public virtual ResearchCostResult GetScrapCostForResearch(ItemDefinition item, ResearchType researchType);
    public virtual Nullable`1<float> EvaluateSleepingBagReset(SleepingBag bag, Vector3 position, SleepingBagResetReason reason);
    private void DeleteEntities();
    protected void OnCreated_Vanilla();
    [CompilerGeneratedAttribute]
public static void add_GameModeChanged(Action`1<BaseGameMode> value);
    [CompilerGeneratedAttribute]
public static void remove_GameModeChanged(Action`1<BaseGameMode> value);
    public bool HasAnyGameModeTag(String[] tags);
    public bool HasGameModeTag(string tag);
    public bool AllowsSleeping();
    public bool HasLoadouts();
    public int GetNumTeams();
    public int GetTeamScore(int teamIndex);
    public static void CreateGameMode(string overrideMode);
    public static void SetActiveGameMode(BaseGameMode newActive, bool serverside);
    public static BaseGameMode GetActiveGameMode(bool serverside);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    public virtual float CorpseRemovalTime(BaseCorpse corpse);
    public virtual bool InWarmup();
    public virtual bool IsWaitingForPlayers();
    public virtual bool IsMatchOver();
    public virtual bool IsMatchActive();
    public virtual void InitShared();
    public virtual void DestroyShared();
    protected virtual void OnCreated();
    protected virtual void OnMatchBegin();
    public virtual void ResetMatch();
    public virtual void ResetTeamScores();
    public virtual void ShutdownGame();
    private void Update();
    protected virtual void OnThink(float delta);
    public virtual void OnMatchEnd();
    public virtual void OnNewPlayer(BasePlayer player);
    public void PostPlayerRespawn(BasePlayer player);
    public virtual void OnPlayerConnected(BasePlayer player);
    public virtual void UnassignAllPlayers();
    public void AutoAssignTeam(BasePlayer player);
    public virtual void OnPlayerDisconnected(BasePlayer player);
    public virtual void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info);
    public virtual void OnPlayerRevived(BasePlayer instigator, BasePlayer victim);
    public virtual void OnPlayerHurt(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo);
    public virtual void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo);
    public virtual bool CanPlayerRespawn(BasePlayer player);
    public virtual void OnPlayerRespawn(BasePlayer player);
    public virtual void CheckGameConditions(bool force);
    public virtual void LoadoutPlayer(BasePlayer player);
    public virtual void InstallSpawnpoints();
    public virtual SpawnPoint GetPlayerSpawn(BasePlayer forPlayer);
    public virtual int GetMaxRelationshipTeamSize();
    public virtual SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers);
    public virtual bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item);
}
public abstract class BaseHelicopter : BaseVehicle {
    [SerializeField]
[HeaderAttribute("Helicopter")]
public float engineThrustMax;
    [SerializeField]
public Vector3 torqueScale;
    [SerializeField]
protected Transform com;
    [SerializeField]
public GameObject[] killTriggers;
    [SerializeField]
protected GroundEffect[] groundEffects;
    [SerializeField]
public GameObjectRef serverGibs;
    [SerializeField]
public GameObjectRef explosionEffect;
    [SerializeField]
public GameObjectRef fireBall;
    [SerializeField]
public GameObjectRef crashEffect;
    [TooltipAttribute("Lower values mean more lift is produced at high angles.")]
[SerializeField]
[RangeAttribute("0,1", "0,95")]
public float liftDotMax;
    [SerializeField]
[RangeAttribute("0,1", "0,95")]
public float altForceDotMin;
    [RangeAttribute("0,1", "0,95")]
[SerializeField]
public float liftFraction;
    [SerializeField]
public float thrustLerpSpeed;
    public static Flags Flag_InternalLights;
    public float currentThrottle;
    public float avgThrust;
    public float avgTerrainHeight;
    [CompilerGeneratedAttribute]
private bool <autoHover>k__BackingField;
    public HelicopterInputState currentInputState;
    public float lastPlayerInputTime;
    public float hoverForceScale;
    public Vector3 damageTorque;
    public float nextDamageTime;
    public float nextEffectTime;
    public float pendingImpactDamage;
    public bool autoHover { get; public set; }
    public bool ForceMovementHandling { get; }
    [CompilerGeneratedAttribute]
public bool get_autoHover();
    [CompilerGeneratedAttribute]
public void set_autoHover(bool value);
    public virtual float GetServiceCeiling();
    public virtual float GetMinimumAltitudeTerrain();
    public virtual float MaxVelocity();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public bool ToggleAutoHover(BasePlayer player);
    public virtual void PilotInput(InputState inputState, BasePlayer player);
    public virtual void PassengerInput(InputState inputState, BasePlayer player);
    public virtual void SetDefaultInputState();
    public virtual bool IsEnginePowered();
    public virtual void VehicleFixedUpdate();
    public virtual void LightToggle(BasePlayer player);
    public virtual bool IsEngineOn();
    public virtual bool get_ForceMovementHandling();
    protected virtual void TryStartEngine(BasePlayer player);
    protected abstract virtual void ApplyHandbrake();
    public void ClearDamageTorque();
    public void SetDamageTorque(Vector3 newTorque);
    public void AddDamageTorque(Vector3 torqueToAdd);
    public virtual void MovementUpdate();
    public void DelayedImpactDamage();
    public virtual bool CollisionDamageEnabled();
    public void ProcessCollision(Collision collision);
    public void OnCollisionEnter(Collision collision);
    public virtual void OnKilled(HitInfo info);
    public virtual bool IsValidHomingTarget();
    [CompilerGeneratedAttribute]
internal static float <PilotInput>g__MouseToBinary|32_0(float amount);
}
public class BaseHuntEvent : BaseEntity {
    public GameObjectRef[] HuntablePrefab;
    protected List`1<string> HuntableResourcePathCached;
    public AudioSource huntStartSound;
    public virtual void ServerInit();
}
public class BaseLadder : BaseCombatEntity {
    public virtual bool ShouldBlockProjectiles();
}
public class BaseLauncher : BaseProjectile {
    public float initialSpeedMultiplier;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool ForceSendMagazine(SaveInfo saveInfo);
    public virtual void ServerUse();
    public virtual void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness);
    [RPC_Server]
[IsActiveItem]
private void SV_Launch(RPCMessage msg);
    public virtual void ProjectileLaunched_Server(ServerProjectile justLaunched);
}
public class BaseLiquidVessel : AttackEntity {
    [HeaderAttribute("Liquid Vessel")]
public GameObjectRef thrownWaterObject;
    public GameObjectRef ThrowEffect3P;
    public SoundDefinition throwSound3P;
    public GameObjectRef fillFromContainer;
    public GameObjectRef fillFromWorld;
    public SoundDefinition fillFromContainerStartSoundDef;
    public SoundDefinition fillFromContainerSoundDef;
    public SoundDefinition fillFromWorldStartSoundDef;
    public SoundDefinition fillFromWorldSoundDef;
    public bool hasLid;
    public float throwScale;
    public bool canDrinkFrom;
    public bool updateVMWater;
    public float minThrowFrac;
    public bool useThrowAnim;
    public float fillMlPerSec;
    public static Phrase DifferentLiquidType;
    private float lastFillTime;
    private TimeSince timeSinceLastToast;
    private float nextFreeTime;
    private static BaseLiquidVessel();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void OnHeldChanged();
    public void SetFilling(bool isFilling);
    public virtual void OnSetFilling(bool flag);
    public void StartFilling();
    public void StopFilling();
    public void FillCheck();
    public void LoseWater(int amount);
    public void AddLiquid(ItemDefinition liquidType, int amount);
    public Item GetContents();
    public int AmountHeld();
    public float HeldFraction();
    public int MaxHoldable();
    public bool CanDrink();
    private bool IsWeaponBusy();
    private void SetBusyFor(float dur);
    private void ClearBusy();
    [RPC_Server]
[IsActiveItem]
private void DoDrink(RPCMessage msg);
    [RPC_Server]
private void ThrowContents(RPCMessage msg);
    public void DoThrow(Vector3 pos, Vector3 velocity);
    [RPC_Server]
private void SendFilling(RPCMessage msg);
    public bool CanFillFromWorld();
    public bool CanThrow();
    public LiquidContainer GetFacingLiquidContainer();
}
public class BaseLock : BaseEntity {
    [ItemSelector("11")]
public ItemDefinition itemType;
    public bool CanRemove;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool GetPlayerLockPermission(BasePlayer player);
    public virtual bool OnTryToOpen(BasePlayer player);
    public virtual bool OnTryToClose(BasePlayer player);
    public virtual bool HasLockPermission(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_TakeLock(RPCMessage rpc);
    public virtual float BoundsPadding();
}
public class BaseMagnet : MonoBehaviour {
    public BaseEntity entityOwner;
    public Flags magnetFlag;
    public TriggerMagnet magnetTrigger;
    public FixedJoint fixedJoint;
    public Rigidbody kinematicAttachmentBody;
    public float magnetForce;
    public Transform attachDepthPoint;
    public GameObjectRef attachEffect;
    public bool isMagnetOn;
    public GameObject colliderSource;
    private BasePlayer associatedPlayer;
    public bool HasConnectedObject();
    public OBB GetConnectedOBB(float scale);
    public void SetCollisionsEnabled(GameObject other, bool wants);
    public virtual void SetMagnetEnabled(bool wantsOn, BasePlayer forPlayer);
    public virtual void OnMagnetEnabled();
    public virtual void OnMagnetDisabled();
    public bool IsMagnetOn();
    public void MagnetThink(float delta);
}
public class BaseMelee : AttackEntity {
    [HeaderAttribute("Melee")]
public DamageProperties damageProperties;
    public List`1<DamageTypeEntry> damageTypes;
    public List`1<DamageTypeEntry> deployableDamageOverrides;
    public float maxDistance;
    public float attackRadius;
    public bool isAutomatic;
    public bool blockSprintOnAttack;
    public bool canUntieCrates;
    public bool longResourceForgiveness;
    [HeaderAttribute("Effects")]
public GameObjectRef strikeFX;
    public bool useStandardHitEffects;
    [HeaderAttribute("NPCUsage")]
public float aiStrikeDelay;
    public GameObjectRef swingEffect;
    public List`1<MaterialFX> materialStrikeFX;
    [RangeAttribute("0", "1")]
[HeaderAttribute("Other")]
public float heartStress;
    public GatherProperties gathering;
    [HeaderAttribute("Throwing")]
public bool canThrowAsProjectile;
    public bool canAiHearIt;
    public bool onlyThrowAsProjectile;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void GetAttackStats(HitInfo info);
    public virtual void DoAttackShared(HitInfo info);
    public GatherPropertyEntry GetGatherInfoFromIndex(GatherType index);
    public virtual bool CanHit(HitTest info);
    public float TotalDamage();
    public bool IsItemBroken();
    public void LoseCondition(float amount);
    public virtual float GetConditionLoss();
    public void UpdateItemCondition(HitInfo info);
    [RPC_Server]
[IsActiveItem]
public void PlayerAttack(RPCMessage msg);
    public virtual bool CanBeUsedInWater();
    public virtual string GetStrikeEffectPath(string materialName);
    public virtual void ServerUse();
    public virtual void ServerUse_OnHit(HitInfo info);
    public void ServerUse_Strike();
    public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction);
    [RPC_Server]
[FromOwner]
[IsActiveItem]
private void CLProject(RPCMessage msg);
}
public abstract class BaseMeshPaintable : MonoBehaviour {
}
public static class BaseMetabolism : object {
    public static float targetHeartRate;
}
public abstract class BaseMetabolism`1 : EntityComponent`1<T> {
    protected T owner;
    public MetabolismAttribute calories;
    public MetabolismAttribute hydration;
    public MetabolismAttribute heartrate;
    protected float timeSinceLastMetabolism;
    public virtual void Reset();
    protected virtual void OnDisable();
    public virtual void ServerInit(T owner);
    public virtual void ServerUpdate(BaseCombatEntity ownerEntity, float delta);
    protected virtual void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta);
    protected virtual void RunMetabolism(BaseCombatEntity ownerEntity, float delta);
    public virtual void ApplyChange(Type type, float amount, float time);
    public bool ShouldDie();
    public virtual MetabolismAttribute FindAttribute(Type type);
}
public class BaseMetalDetector : HeldEntity {
    public DetectState State;
    public float LongRangeDetectionRange;
    public float SweetSpotDetectionRange;
    public SoundDefinition BeepSoundEffect;
    [ServerVar]
public static float NearestDistanceTick;
    [ServerVar]
public static float DetectLongRangeTick;
    [ServerVar]
public static float DetectMinMovementDistance;
    private List`1<IMetalDetectable> inRangeSources;
    public IMetalDetectable nearestSource;
    private float nearestSourceDistanceSqr;
    private Vector3 lastDetectPlayerPos;
    private static BaseMetalDetector();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void OnHeldChanged();
    private void StartDetecting();
    private void StopDetecting();
    private void SendNearestDistance();
    private float GetDistanceToCenterOrNearestSubSource(IMetalDetectable source);
    private void ProcessDetectedSources();
    private void DetectLongRange();
    private void DetectSources(BasePlayer player);
    private void ClearSources();
    [CallsPerSecond("2")]
[RPC_Server]
[FromOwner]
private void RPC_RequestFlag(RPCMessage rpc);
    [CallsPerSecond("6")]
[FromOwner]
[RPC_Server]
public void SV_SetSweetspotScanning(RPCMessage msg);
    public Vector3 GetDetectionPoint();
    public float GetSweetSpotDistancePercent(float distance, float sourceSpawnRadius);
}
[CreateAssetMenuAttribute]
public class BaseMission : BaseScriptableObject {
    [ServerVar]
public static bool missionsenabled;
    public string shortname;
    public Phrase missionName;
    public Phrase missionDesc;
    public bool canBeAbandoned;
    public bool completeSilently;
    public bool blockMissionStat;
    public TutorialMissionHelpSet showHelpInfo;
    public MissionObjectiveEntry[] objectives;
    public static List`1<Vector3> blockedPoints;
    public static string MISSION_COMPLETE_STAT;
    public GameObjectRef acceptEffect;
    public GameObjectRef failedEffect;
    public GameObjectRef victoryEffect;
    public TutorialItemAllowance AllowedTutorialItems;
    public BaseMission followupMission;
    public int repeatDelaySecondsSuccess;
    public int repeatDelaySecondsFailed;
    public float timeLimitSeconds;
    public Sprite icon;
    public Sprite providerIcon;
    public bool hideStagesNotStarted;
    public MissionDependancy[] acceptDependancies;
    public MissionEntityEntry[] missionEntities;
    public PositionGenerator[] positionGenerators;
    public ItemAmount[] baseRewards;
    public UInt32 id { get; }
    public bool isRepeatable { get; }
    private static BaseMission();
    public UInt32 get_id();
    public static void PlayerDisconnected(BasePlayer player);
    public static void PlayerKilled(BasePlayer player);
    public bool get_isRepeatable();
    public virtual Sprite GetIcon(MissionInstance instance);
    public static void AddBlocker(Vector3 point);
    public static void RemoveBlockers(MissionInstance instance);
    public static void DoMissionEffect(string effectString, BasePlayer assignee);
    public virtual void MissionStart(MissionInstance instance, BasePlayer assignee);
    public void CheckObjectives(MissionInstance instance, BasePlayer assignee);
    public virtual void Think(MissionInstance instance, BasePlayer assignee, float delta);
    public virtual void MissionComplete(MissionInstance instance, BasePlayer assignee);
    public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee);
    public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason);
    public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee);
    public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor);
    public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor);
    public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission);
    public bool IsEligableForMission(BasePlayer player, IMissionProvider provider);
    [CompilerGeneratedAttribute]
internal static void <MissionComplete>g__GiveReward|47_0(BasePlayer player, ItemAmount reward);
}
public static class BaseModifiers : object {
}
public abstract class BaseModifiers`1 : EntityComponent`1<T> {
    public List`1<Modifier> All;
    protected Dictionary`2<ModifierType, float> totalValues;
    protected Dictionary`2<ModifierType, float> modifierVariables;
    protected T owner;
    protected bool dirty;
    protected float timeSinceLastTick;
    protected float lastTickTime;
    public int ActiveModifierCoount { get; }
    public int get_ActiveModifierCoount();
    public void Add(List`1<ModifierDefintion> modDefs);
    protected void Add(ModifierDefintion def);
    protected void Add(Modifier modifier);
    private bool CanAdd(Modifier modifier);
    private int GetMaxModifiersForSourceType(ModifierSource source);
    private int GetTypeSourceCount(ModifierType type, ModifierSource source);
    private Modifier GetShortestLifeModifier(ModifierType type, ModifierSource source);
    private void Remove(Modifier modifier);
    public void RemoveAll();
    public float GetValue(ModifierType type, float defaultValue);
    public float GetVariableValue(ModifierType type, float defaultValue);
    public void SetVariableValue(ModifierType type, float value);
    public void RemoveVariable(ModifierType type);
    protected virtual void OnDisable();
    protected void SetDirty(bool flag);
    public virtual void ServerInit(T owner);
    public void ResetTicking();
    public virtual void ServerUpdate(BaseCombatEntity ownerEntity);
    protected virtual void TickModifiers(BaseCombatEntity ownerEntity, float delta);
}
public abstract class BaseModularVehicle : GroundVehicle {
    [SerializeField]
[HeaderAttribute("Modular Vehicle")]
public List`1<ModularVehicleSocket> moduleSockets;
    [SerializeField]
public Transform centreOfMassTransform;
    [SerializeField]
public Transform waterSample;
    [SerializeField]
public LODGroup lodGroup;
    public GameObjectRef keyEnterDialog;
    [CompilerGeneratedAttribute]
private List`1<BaseVehicleModule> <AttachedModuleEntities>k__BackingField;
    private float _mass;
    [CompilerGeneratedAttribute]
private float <TotalMass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInited>k__BackingField;
    public static Flags FLAG_KINEMATIC;
    public Dictionary`2<BaseVehicleModule, Action> moduleAddActions;
    public bool inEditableLocation;
    public bool prevEditable;
    public bool immuneToDecay;
    [CompilerGeneratedAttribute]
private ModularVehicleInventory <Inventory>k__BackingField;
    public Vector3 realLocalCOM;
    public Item AssociatedItemInstance;
    private bool disablePhysics;
    public Vector3 CentreOfMass { get; }
    public int NumAttachedModules { get; }
    public bool HasAnyModules { get; }
    public List`1<BaseVehicleModule> AttachedModuleEntities { get; }
    public int TotalSockets { get; }
    public int NumFreeSockets { get; }
    private float Mass { get; }
    public float TotalMass { get; public set; }
    public bool IsKinematic { get; }
    public bool IsLockable { get; }
    public bool HasInited { get; private set; }
    public ItemDefinition AssociatedItemDef { get; }
    public bool IsEditableNow { get; }
    public ModularVehicleInventory Inventory { get; public set; }
    public Vector3 get_CentreOfMass();
    public int get_NumAttachedModules();
    public bool get_HasAnyModules();
    [CompilerGeneratedAttribute]
public List`1<BaseVehicleModule> get_AttachedModuleEntities();
    public int get_TotalSockets();
    public int get_NumFreeSockets();
    private float get_Mass();
    [CompilerGeneratedAttribute]
public float get_TotalMass();
    [CompilerGeneratedAttribute]
public void set_TotalMass(float value);
    public bool get_IsKinematic();
    public virtual bool get_IsLockable();
    [CompilerGeneratedAttribute]
public bool get_HasInited();
    [CompilerGeneratedAttribute]
private void set_HasInited(bool value);
    public ItemDefinition get_AssociatedItemDef();
    public bool get_IsEditableNow();
    public virtual void InitShared();
    public virtual bool PlayerCanUseThis(BasePlayer player, LockType lockType);
    public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, Int32& index);
    public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos);
    public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos);
    public bool TryGetModuleAt(int socketIndex, BaseVehicleModule& result);
    public ModularVehicleSocket GetSocket(int index);
    public virtual void Load(LoadInfo info);
    public virtual bool CanPushNow(BasePlayer pusher);
    public virtual void OnChildAdded(BaseEntity childEntity);
    public virtual void OnChildRemoved(BaseEntity childEntity);
    public virtual void ModuleEntityAdded(BaseVehicleModule addedModule);
    public virtual void ModuleEntityRemoved(BaseVehicleModule removedModule);
    public void RefreshModulesExcept(BaseVehicleModule ignoredModule);
    [CompilerGeneratedAttribute]
public ModularVehicleInventory get_Inventory();
    [CompilerGeneratedAttribute]
public void set_Inventory(ModularVehicleInventory value);
    public virtual void ServerInit();
    public virtual void PreServerLoad();
    public virtual void PostServerLoad();
    public virtual void DoServerDestroy();
    public virtual float MaxVelocity();
    public abstract virtual bool IsComplete();
    public bool CouldBeEdited();
    public void DisablePhysics();
    public void EnablePhysics();
    public virtual void VehicleFixedUpdate();
    public virtual bool MountEligable(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public sealed virtual bool CanMoveFrom(BasePlayer player, Item item);
    protected abstract virtual Vector3 GetCOMMultiplier();
    public virtual void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info);
    public abstract virtual void ModuleReachedZeroHealth();
    public bool TryAddModule(Item moduleItem, int socketIndex);
    public bool TryAddModule(Item moduleItem);
    public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, String& failureReason);
    public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex);
    public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem);
    public Item GetVehicleItem(ItemId itemUID);
    public BaseVehicleModule GetModuleForItem(Item item);
    public void SetMass(float mass);
    public void SetCOM(Vector3 com);
}
public abstract class BaseMonoBehaviour : FacepunchBehaviour {
    public virtual bool IsDebugging();
    public virtual string GetLogColor();
    public void LogEntry(EntryType log, int level, string fmtString);
    public void LogEntry(EntryType log, int level, string fmtString, T1 arg1);
    public void LogEntry(EntryType log, int level, string fmtString, T1 arg1, T2 arg2);
    public void LogEntry(EntryType log, int level, string fmtString, T1 arg1, T2 arg2, T3 arg3);
    protected virtual string GetLogIdentity();
    private void LogImpl(EntryType entryType, int level, string message);
}
public class BaseMountable : BaseCombatEntity {
    public static Phrase dismountPhrase;
    [HeaderAttribute("View")]
public Transform eyePositionOverride;
    public Transform eyeCenterOverride;
    public Vector2 pitchClamp;
    public Vector2 yawClamp;
    public bool canWieldItems;
    public bool relativeViewAngles;
    [HeaderAttribute("Mounting")]
public bool AllowForceMountWhenRestrained;
    public Transform mountAnchor;
    public float mountLOSVertOffset;
    public MountPoses mountPose;
    public float maxMountDistance;
    public Transform[] dismountPositions;
    public bool checkPlayerLosOnMount;
    public bool disableMeshCullingForPlayers;
    public bool allowHeadLook;
    public bool ignoreVehicleParent;
    public bool legacyDismount;
    public ItemModWearable wearWhileMounted;
    public bool modifiesPlayerCollider;
    public CapsuleColliderInfo customPlayerCollider;
    public float clippingCheckRadius;
    public bool clippingAndVisChecks;
    public ClippingCheckLocation clippingChecksLocation;
    public SoundDefinition mountSoundDef;
    public SoundDefinition swapSoundDef;
    public SoundDefinition dismountSoundDef;
    public DismountConvarType dismountHoldType;
    public MountStatType mountTimeStatType;
    public MountGestureType allowedGestures;
    public bool canDrinkWhileMounted;
    public bool allowSleeperMounting;
    [HelpAttribute("Set this to true if the mountable is enclosed so it doesn't move inside cars and such")]
public bool animateClothInLocalSpace;
    [HeaderAttribute("Camera")]
public CameraMode MountedCameraMode;
    [HeaderAttribute("Rigidbody (Optional)")]
public Rigidbody rigidBody;
    [FormerlySerializedAsAttribute("needsVehicleTick")]
public bool isMobile;
    public float SideLeanAmount;
    public static float playerHeight;
    public static float playerRadius;
    public BasePlayer _mounted;
    public static ListHashSet`1<BaseMountable> AllMountables;
    public static float MOUNTABLE_TICK_RATE;
    protected float PositionTickRate { get; }
    public bool IsSummerDlcVehicle { get; }
    protected bool BypassClothingMountBlocks { get; }
    public bool BlocksDoors { get; }
    private static BaseMountable();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool CanHoldItems();
    public virtual CameraMode GetMountedCameraMode();
    public virtual bool DirectlyMountable();
    public virtual Transform GetEyeOverride();
    public virtual bool ModifiesThirdPersonCamera();
    public virtual Vector2 GetPitchClamp();
    public virtual Vector2 GetYawClamp();
    public virtual bool AnyMounted();
    public bool IsMounted();
    public virtual Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot);
    public virtual Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    public virtual float MaxVelocity();
    public virtual bool PlayerIsMounted(BasePlayer player);
    public virtual BaseVehicle VehicleParent();
    public virtual bool HasValidDismountPosition(BasePlayer player);
    public virtual bool ValidDismountPosition(BasePlayer player, Vector3 disPos);
    public BasePlayer GetMounted();
    public virtual void MounteeTookDamage(BasePlayer mountee, HitInfo info);
    public virtual void LightToggle(BasePlayer player);
    public virtual void OnWeaponFired(BaseProjectile weapon);
    public virtual bool CanSwapToThis(BasePlayer player);
    protected virtual float get_PositionTickRate();
    public virtual bool CanPickup(BasePlayer player);
    public virtual void OnKilled(HitInfo info);
    [RPC_Server]
[IsVisible("3")]
public void RPC_WantsMount(RPCMessage msg);
    public void WantsMount(BasePlayer player);
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public virtual bool AttemptDismount(BasePlayer player);
    [RPC_Server]
public void RPC_WantsDismount(RPCMessage msg);
    public void MountPlayer(BasePlayer player);
    public virtual void OnPlayerMounted();
    public virtual void OnPlayerDismounted(BasePlayer player);
    public virtual void UpdateMountFlags();
    public virtual void DismountAllPlayers();
    public void DismountPlayer(BasePlayer player, bool lite);
    public virtual bool GetDismountPosition(BasePlayer player, Vector3& res);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public static void FixedUpdateCycle();
    public static void PlayerSyncCycle();
    public virtual void VehicleFixedUpdate();
    public virtual void PostVehicleFixedUpdate();
    public virtual void MountedPlayerSync();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual float GetComfort();
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public bool TryFireProjectile(StorageContainer ammoStorage, AmmoTypes ammoType, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, ServerProjectile& projectile);
    public virtual void DisableTransferProtection();
    protected virtual int GetClipCheckMask();
    public virtual bool IsSeatClipping(BaseMountable mountable);
    public virtual Vector3 GetMountRagdollVelocity(BasePlayer player);
    protected virtual bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction);
    public virtual bool get_IsSummerDlcVehicle();
    public virtual bool IsInstrument();
    public Vector3 GetDismountCheckStart(BasePlayer player);
    public Vector3 GetMountedPosition();
    public virtual float GetSpeed();
    public bool CanPlayerSeeMountPoint(Ray ray, BasePlayer player, float maxDistance);
    public bool NearMountPoint(BasePlayer player);
    protected bool ClothingBlocksMounting(BasePlayer player);
    protected virtual bool get_BypassClothingMountBlocks();
    public static Vector3 ConvertVector(Vector3 vec);
    public virtual bool get_BlocksDoors();
}
public class BaseMovement : MonoBehaviour {
    public bool adminCheat;
    public float adminSpeed;
}
public class BaseNavigator : BaseMonoBehaviour {
    [ServerVar]
public static float maxStepUpDistance;
    [ServerVar]
public static int baseNavMovementFrameInterval;
    [ServerVar]
public static float stuckTriggerDuration;
    [ServerVar]
public static float navTypeHeightOffset;
    [ServerVar]
public static float navTypeDistance;
    [HeaderAttribute("General")]
public bool CanNavigateMounted;
    public bool CanUseNavMesh;
    public bool CanUseAStar;
    public bool CanUseBaseNav;
    public bool CanUseCustomNav;
    public float StoppingDistance;
    public string DefaultArea;
    public bool CanPathFindToChaseTargetIfNoMovePoint;
    public int PathFindChaseLOSAttemptCount;
    public float PathFindChaseLOSDistanceMultiplier;
    [HeaderAttribute("Stuck Detection")]
public bool TriggerStuckEvent;
    public float StuckDistance;
    [HeaderAttribute("Speed")]
public float Speed;
    public float Acceleration;
    public float TurnSpeed;
    public NavigationSpeed MoveTowardsSpeed;
    public bool FaceMoveTowardsTarget;
    [HeaderAttribute("Speed Fractions")]
public float SlowestSpeedFraction;
    public float SlowSpeedFraction;
    public float NormalSpeedFraction;
    public float FastSpeedFraction;
    public float LowHealthSpeedReductionTriggerFraction;
    public float LowHealthMaxSpeedFraction;
    public float SwimmingSpeedMultiplier;
    [HeaderAttribute("AIPoint Usage")]
public float BestMovementPointMaxDistance;
    public float BestCoverPointMaxDistance;
    public float BestRoamPointMaxDistance;
    public float MaxRoamDistanceFromHome;
    [HeaderAttribute("Misc")]
public float FaceTargetChaseDistance;
    public bool CanUseRandomMovePointIfNonFound;
    public float MaxWaterDepth;
    public bool SpeedBasedAvoidancePriority;
    private NavMeshPath path;
    private NavMeshQueryFilter navMeshQueryFilter;
    [CompilerGeneratedAttribute]
private AIMovePointPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePath <AStarGraph>k__BackingField;
    private int defaultAreaMask;
    [InspectorFlagsAttribute]
public Enum biomePreference;
    public bool UseBiomePreference;
    [InspectorFlagsAttribute]
public Enum topologyPreference;
    [InspectorFlagsAttribute]
public Enum topologyPrevent;
    [InspectorFlagsAttribute]
public Enum biomeRequirement;
    [CompilerGeneratedAttribute]
private NavMeshAgent <Agent>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseCombatEntity <BaseEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private NavigationType <CurrentNavigationType>k__BackingField;
    [CompilerGeneratedAttribute]
private NavigationType <LastUsedNavigationType>k__BackingField;
    public float stuckTimer;
    public Vector3 stuckCheckPosition;
    [CompilerGeneratedAttribute]
private bool <StuckOffNavmesh>k__BackingField;
    protected bool traversingNavMeshLink;
    protected string currentNavMeshLinkName;
    protected Vector3 currentNavMeshLinkEndPos;
    protected Stack`1<IAIPathNode> currentAStarPath;
    protected IAIPathNode targetNode;
    protected float currentSpeedFraction;
    private float lastSetDestinationTime;
    protected OverrideFacingDirectionMode overrideFacingDirectionMode;
    protected BaseEntity facingDirectionEntity;
    protected bool overrideFacingDirection;
    protected Vector3 facingDirectionOverride;
    protected bool paused;
    private int frameCount;
    private float accumDelta;
    public AIMovePointPath Path { get; public set; }
    public BasePath AStarGraph { get; public set; }
    public NavMeshAgent Agent { get; private set; }
    public BaseCombatEntity BaseEntity { get; private set; }
    public Vector3 Destination { get; public set; }
    public bool IsOnNavMeshLink { get; }
    public bool Moving { get; }
    public NavigationType CurrentNavigationType { get; private set; }
    public NavigationType LastUsedNavigationType { get; private set; }
    [HideInInspector]
public bool StuckOffNavmesh { get; private set; }
    public bool HasPath { get; }
    public bool IsOverridingFacingDirection { get; }
    public Vector3 FacingDirectionOverride { get; }
    private static BaseNavigator();
    [CompilerGeneratedAttribute]
public AIMovePointPath get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(AIMovePointPath value);
    [CompilerGeneratedAttribute]
public BasePath get_AStarGraph();
    [CompilerGeneratedAttribute]
public void set_AStarGraph(BasePath value);
    public int TopologyPreference();
    public int TopologyPrevent();
    public int BiomeRequirement();
    [CompilerGeneratedAttribute]
public NavMeshAgent get_Agent();
    [CompilerGeneratedAttribute]
private void set_Agent(NavMeshAgent value);
    [CompilerGeneratedAttribute]
public BaseCombatEntity get_BaseEntity();
    [CompilerGeneratedAttribute]
private void set_BaseEntity(BaseCombatEntity value);
    [CompilerGeneratedAttribute]
public Vector3 get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(Vector3 value);
    public virtual bool get_IsOnNavMeshLink();
    public bool get_Moving();
    [CompilerGeneratedAttribute]
public NavigationType get_CurrentNavigationType();
    [CompilerGeneratedAttribute]
private void set_CurrentNavigationType(NavigationType value);
    [CompilerGeneratedAttribute]
public NavigationType get_LastUsedNavigationType();
    [CompilerGeneratedAttribute]
private void set_LastUsedNavigationType(NavigationType value);
    [CompilerGeneratedAttribute]
public bool get_StuckOffNavmesh();
    [CompilerGeneratedAttribute]
private void set_StuckOffNavmesh(bool value);
    public virtual bool get_HasPath();
    public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent);
    public void SetNavMeshEnabled(bool flag);
    protected virtual bool CanEnableNavMeshNavigation();
    protected virtual bool CanUpdateMovement();
    public void ForceToGround();
    private void DelayedForceToGround();
    public bool PlaceOnNavMesh(float yOffset);
    public virtual void OnPlacedOnNavmesh();
    public virtual void OnFailedToPlaceOnNavmesh();
    public bool Warp(Vector3 position);
    public bool GetNearestNavmeshPosition(Vector3 target, Vector3& position, float maxRange);
    public bool SetBaseDestination(Vector3 pos, float speedFraction);
    public bool SetDestination(BasePath path, IAIPathNode newTargetNode, float speedFraction);
    public bool SetDestination(Vector3 pos, NavigationSpeed speed, float updateInterval, float navmeshSampleDistance);
    public virtual bool SetCustomDestination(Vector3 pos, float speedFraction, float updateInterval);
    public bool SetDestination(Vector3 pos, float speedFraction, float updateInterval, float navmeshSampleDistance);
    private NavigationType DetermineNavigationType(Vector3 location, Vector3& navMeshPos);
    public void SetCurrentSpeed(NavigationSpeed speed);
    public bool UpdateIntervalElapsed(float updateInterval);
    public float GetSpeedFraction(NavigationSpeed speed);
    public void SetCurrentNavigationType(NavigationType navType);
    public void Pause();
    public void Resume();
    public void Stop();
    private void StopNavMesh();
    private void StopAStar();
    protected virtual void StopCustom();
    public void Think(float delta);
    public void UpdateNavigation(float delta);
    private void UpdateMovement(float delta);
    public virtual void OnStuck();
    public virtual bool IsSwimming();
    private Vector3 GetNextPathPosition();
    private bool ValidateNextPosition(Vector3& moveToPosition);
    private void UpdateSpeed(float delta, bool swimming);
    protected virtual float GetTargetSpeed();
    protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta);
    public virtual void ApplyFacingDirectionOverride();
    public void SetFacingDirectionEntity(BaseEntity entity);
    public void SetFacingDirectionOverride(Vector3 direction);
    public void ClearFacingDirectionOverride();
    public bool get_IsOverridingFacingDirection();
    public Vector3 get_FacingDirectionOverride();
    protected bool ReachedPosition(Vector3 position);
    private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition);
    private bool HandleNavMeshLinkTraversalStart(float delta);
    private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition);
    private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition);
    private void CompleteNavMeshLink();
    public bool IsPositionATopologyPreference(Vector3 position);
    public bool IsPositionPreventTopology(Vector3 position);
    public bool IsPositionABiomePreference(Vector3 position);
    public bool IsPositionABiomeRequirement(Vector3 position);
    public bool IsAcceptableWaterDepth(Vector3 pos);
    public void SetBrakingEnabled(bool flag);
    public static int GetNavMeshAgentID(string name);
}
public abstract class BaseNetworkable : BaseMonoBehaviour {
    [HeaderAttribute("BaseNetworkable")]
[ReadOnlyAttribute]
public UInt32 prefabID;
    [TooltipAttribute("If enabled the entity will send to everyone on the server - regardless of position")]
public bool globalBroadcast;
    [TooltipAttribute("Global broadcast a cut down version of the entity to show buildings across the map")]
public bool globalBuildingBlock;
    public Networkable net;
    [CompilerGeneratedAttribute]
private bool <IsDestroyed>k__BackingField;
    private string _prefabName;
    private string _prefabNameWithoutExtension;
    public static EntityRealm serverEntities;
    private static bool isServersideEntity;
    public static List`1<Connection> connectionsInSphereList;
    public List`1<Component> postNetworkUpdateComponents;
    public bool _limitedNetworking;
    public EntityRef parentEntity;
    public List`1<BaseEntity> children;
    public bool canTriggerParent;
    public int creationFrame;
    public bool isSpawned;
    public MemoryStream _NetworkCache;
    public static Queue`1<MemoryStream> EntityMemoryStreamPool;
    private MemoryStream _SaveCache;
    public bool IsDestroyed { get; private set; }
    public string PrefabName { get; }
    public string ShortPrefabName { get; }
    public bool isServer { get; }
    public bool isClient { get; }
    public bool limitNetworking { get; public set; }
    public GameManager gameManager { get; }
    public Library prefabAttribute { get; }
    public static Group GlobalNetworkGroup { get; }
    public static Group LimboNetworkGroup { get; }
    private static BaseNetworkable();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDestroyed();
    [CompilerGeneratedAttribute]
private void set_IsDestroyed(bool value);
    public string get_PrefabName();
    public sealed virtual string get_ShortPrefabName();
    public virtual Vector3 GetNetworkPosition();
    public virtual Quaternion GetNetworkRotation();
    public string InvokeString();
    public BaseEntity LookupPrefab();
    public sealed virtual bool EqualNetID(BaseNetworkable other);
    public bool EqualNetID(NetworkableId otherID);
    public virtual void ResetState();
    public virtual void InitShared();
    public virtual void PreInitShared();
    public virtual void PostInitShared();
    public virtual void DestroyShared();
    public virtual void OnNetworkGroupEnter(Group group);
    public virtual void OnNetworkGroupLeave(Group group);
    public sealed virtual void OnNetworkGroupChange();
    public sealed virtual void OnNetworkSubscribersEnter(List`1<Connection> connections);
    public sealed virtual void OnNetworkSubscribersLeave(List`1<Connection> connections);
    private void EntityDestroy();
    private void DoEntityDestroy();
    private void SpawnShared();
    public virtual void Save(SaveInfo info);
    public virtual void PostSave(SaveInfo info);
    public void InitLoad(NetworkableId entityID);
    public virtual void PreServerLoad();
    public virtual void Load(LoadInfo info);
    public virtual void PostServerLoad();
    public bool get_isServer();
    public sealed virtual bool get_isClient();
    public T ToServer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public static List`1<Connection> GetConnectionsWithin(Vector3 position, float distance);
    public static void GetCloseConnections(Vector3 position, float distance, List`1<Connection> foundConnections);
    public static void GetCloseConnections(Vector3 position, float distance, List`1<BasePlayer> players);
    public static bool HasCloseConnections(Vector3 position, float distance);
    public static bool HasConnections(Vector3 position);
    public void BroadcastOnPostNetworkUpdate(BaseEntity entity);
    public virtual void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public bool get_limitNetworking();
    public void set_limitNetworking(bool value);
    private void OnNetworkLimitStart();
    private void OnNetworkLimitEnd();
    public BaseEntity GetParentEntity();
    public bool HasParent();
    public void AddChild(BaseEntity child);
    protected virtual void OnChildAdded(BaseEntity child);
    public void RemoveChild(BaseEntity child);
    protected virtual void OnChildRemoved(BaseEntity child);
    public GameManager get_gameManager();
    public Library get_prefabAttribute();
    public static Group get_GlobalNetworkGroup();
    public static Group get_LimboNetworkGroup();
    public virtual float GetNetworkTime();
    public virtual void Spawn();
    private void SendGlobalNetworkUpdate();
    public bool IsFullySpawned();
    public virtual void ServerInit();
    public virtual void ServerInitPostNetworkGroupAssign();
    public List`1<Connection> GetSubscribers();
    public void KillMessage();
    public virtual void AdminKill();
    public sealed virtual void Kill(DestroyMode mode);
    public void KillAsMapEntity();
    public void TerminateOnClient(DestroyMode mode);
    private void TerminateOnServer();
    internal virtual void DoServerDestroy();
    public virtual bool ShouldNetworkTo(BasePlayer player);
    public void SendNetworkGroupChange();
    public void SendAsSnapshot(Connection connection, bool justCreated);
    public void SendNetworkUpdate(NetworkQueue queue);
    public void SendNetworkUpdateImmediate(bool justCreated);
    public void SendNetworkUpdate_Position();
    public void ToStream(Stream stream, SaveInfo saveInfo);
    public virtual bool CanUseNetworkCache(Connection connection);
    public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo);
    public void InvalidateNetworkCache();
    public MemoryStream GetSaveCache();
    public virtual void UpdateNetworkGroup();
    [CompilerGeneratedAttribute]
private bool <OnNetworkLimitStart>b__65_0(Connection x);
}
[ExtensionAttribute]
public static class BaseNetworkableEx : object {
    [ExtensionAttribute]
public static bool IsValid(BaseNetworkable ent);
    [ExtensionAttribute]
public static bool IsRealNull(BaseNetworkable ent);
}
public class BaseNpc : BaseCombatEntity {
    public int agentTypeIndex;
    public bool NewAI;
    public bool LegacyNavigation;
    public bool canSwim;
    [CompilerGeneratedAttribute]
private bool <IsStuck>k__BackingField;
    private Vector3 stepDirection;
    [CompilerGeneratedAttribute]
private bool <AgencyUpdateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOnOffmeshLinkAndReachedNewCoord>k__BackingField;
    private float maxFleeTime;
    private float fleeHealthThresholdPercentage;
    private float blockEnemyTargetingTimeout;
    private float blockFoodTargetingTimeout;
    private float aggroTimeout;
    private float lastAggroChanceResult;
    private float lastAggroChanceCalcTime;
    private static float aggroChanceRecalcTimeout;
    private float eatTimeout;
    private float wakeUpBlockMoveTimeout;
    private BaseEntity blockTargetingThisEnemy;
    public float waterDepth;
    public bool swimming;
    public bool wasSwimming;
    private static AnimationCurve speedFractionResponse;
    private bool _traversingNavMeshLink;
    private OffMeshLinkData _currentNavMeshLink;
    private string _currentNavMeshLinkName;
    private float _currentNavMeshLinkTraversalTime;
    private float _currentNavMeshLinkTraversalTimeDelta;
    private Quaternion _currentNavMeshLinkOrientation;
    private Vector3 _currentNavMeshLinkEndPos;
    public float nextAttackTime;
    [InspectorFlagsAttribute]
[SerializeField]
public Enum topologyPreference;
    public Transform ChaseTransform;
    [HeaderAttribute("BaseNpc")]
public GameObjectRef CorpsePrefab;
    public AiStatistics Stats;
    public Vector3 AttackOffset;
    public float AttackDamage;
    public DamageType AttackDamageType;
    public float MinimumTargetHealthFraction;
    [TooltipAttribute("Stamina to use per attack")]
public float AttackCost;
    [TooltipAttribute("How often can we attack")]
public float AttackRate;
    [TooltipAttribute("Maximum Distance for an attack")]
public float AttackRange;
    public NavMeshAgent NavAgent;
    public LayerMask movementMask;
    public float stuckDuration;
    public float lastStuckTime;
    public float idleDuration;
    private bool _isDormant;
    private float lastSetDestinationTime;
    [CompilerGeneratedAttribute]
private BaseEntity <AttackTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SeenInfo <AttackTargetMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseEntity <FoodTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <SpawnPosition>k__BackingField;
    public StateTimer BusyTimer;
    public float Sleep;
    public VitalLevel Stamina;
    public VitalLevel Energy;
    public VitalLevel Hydration;
    [CompilerGeneratedAttribute]
private Behaviour <CurrentBehaviour>k__BackingField;
    [InspectorFlagsAttribute]
public AiFlags aiFlags;
    public Byte[] CurrentFacts;
    [HeaderAttribute("NPC Senses")]
public int ForgetUnseenEntityTime;
    public float SensesTickRate;
    public BaseEntity[] SensesResults;
    private float lastTickTime;
    public float playerTargetDecisionStartTime;
    private float animalTargetDecisionStartTime;
    private bool isAlreadyCheckingPathPending;
    private int numPathPendingAttempts;
    private float accumPathPendingDelay;
    public static float TickRate;
    private Vector3 lastStuckPos;
    private float nextFlinchTime;
    [CompilerGeneratedAttribute]
private float <TargetSpeed>k__BackingField;
    public int AgentTypeIndex { get; public set; }
    public bool IsStuck { get; public set; }
    public bool AgencyUpdateRequired { get; public set; }
    public bool IsOnOffmeshLinkAndReachedNewCoord { get; public set; }
    public float GetAttackRate { get; }
    public bool IsNpc { get; }
    public bool IsDormant { get; public set; }
    public float SecondsSinceLastSetDestination { get; }
    public float LastSetDestinationTime { get; }
    public Vector3 Destination { get; public set; }
    public bool IsStopped { get; public set; }
    public bool AutoBraking { get; public set; }
    public bool HasPath { get; }
    public BaseEntity AttackTarget { get; public set; }
    public SeenInfo AttackTargetMemory { get; public set; }
    public BaseEntity FoodTarget { get; public set; }
    public BaseCombatEntity CombatTarget { get; }
    public Vector3 SpawnPosition { get; public set; }
    public float AttackTargetVisibleFor { get; }
    public float TimeAtDestination { get; }
    public BaseCombatEntity Entity { get; }
    public NavMeshAgent GetNavAgent { get; }
    public AiStatistics GetStats { get; }
    public float GetAttackRange { get; }
    public Vector3 GetAttackOffset { get; }
    public float GetStamina { get; }
    public float GetEnergy { get; }
    public float GetAttackCost { get; }
    public float GetSleep { get; }
    public Vector3 CurrentAimAngles { get; }
    public float GetStuckDuration { get; }
    public float GetLastStuckTime { get; }
    public Vector3 AttackPosition { get; }
    public Vector3 CrouchedAttackPosition { get; }
    public float currentBehaviorDuration { get; }
    public Behaviour CurrentBehaviour { get; public set; }
    public bool IsSitting { get; public set; }
    public bool IsChasing { get; public set; }
    public bool IsSleeping { get; public set; }
    public float TargetSpeed { get; public set; }
    private static BaseNpc();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int get_AgentTypeIndex();
    public void set_AgentTypeIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_IsStuck();
    [CompilerGeneratedAttribute]
public void set_IsStuck(bool value);
    [CompilerGeneratedAttribute]
public bool get_AgencyUpdateRequired();
    [CompilerGeneratedAttribute]
public void set_AgencyUpdateRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOnOffmeshLinkAndReachedNewCoord();
    [CompilerGeneratedAttribute]
public void set_IsOnOffmeshLinkAndReachedNewCoord(bool value);
    public virtual string DebugText();
    public void TickAi();
    private void TickSpeed();
    protected virtual void TickMetabolism();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual float FearLevel(BaseEntity ent);
    public virtual float HateLevel(BaseEntity ent);
    protected virtual void TickSleep();
    public void TickNavigationWater();
    public void TickNavigation();
    private void TickChase();
    private void HandleNavMeshLinkTraversal(float delta, Vector3& moveToPosition);
    private bool HandleNavMeshLinkTraversalStart(float delta);
    private void HandleNavMeshLinkTraversalTick(float delta, Vector3& moveToPosition);
    private bool IsNavMeshLinkTraversalComplete(float delta, Vector3& moveToPosition);
    private void CompleteNavMeshLink();
    private void TickFollowPath(Vector3& moveToPosition);
    private bool ValidateNextPosition(Vector3& moveToPosition);
    private void UpdatePositionAndRotation(Vector3 moveToPosition);
    private void TickIdle();
    public void TickStuck();
    public void OnBecomeStuck();
    public void OnBecomeUnStuck();
    public void UpdateAiRotation();
    public float get_GetAttackRate();
    public bool AttackReady();
    public virtual void StartAttack();
    public void Attack(BaseCombatEntity target);
    public virtual void Eat();
    public virtual void AddCalories(float amount);
    public virtual void Startled();
    private bool IsAfraid();
    protected bool IsAfraidOf(FamilyEnum family);
    private bool CheckHealthThresholdToFlee();
    private void TickBehaviourState();
    private void WantsToFlee();
    private void TickFlee();
    public bool BlockEnemyTargeting(float timeout);
    private void TickBlockEnemyTargeting();
    public bool BlockFoodTargeting(float timeout);
    private void TickBlockFoodTargeting();
    public bool TryAggro(EnemyRangeEnum range);
    public bool StartAggro(float timeout);
    private void TickAggro();
    public bool StartEating(float timeout);
    private void TickEating();
    public bool WakeUpBlockMove(float timeout);
    private void TickWakeUpBlockMove();
    private void OnFactChanged(Facts fact, byte oldValue, byte newValue);
    public int TopologyPreference();
    public void UpdateDestination(Vector3 position);
    public void UpdateDestination(Transform tx);
    public void StopMoving();
    public virtual void ApplyInheritedVelocity(Vector3 velocity);
    public static Vector3 GetNewNavPosWithVelocity(BaseEntity ent, Vector3 velocity);
    public virtual bool get_IsNpc();
    public bool get_IsDormant();
    public void set_IsDormant(bool value);
    public float get_SecondsSinceLastSetDestination();
    public float get_LastSetDestinationTime();
    public Vector3 get_Destination();
    public void set_Destination(Vector3 value);
    public bool get_IsStopped();
    public void set_IsStopped(bool value);
    public bool get_AutoBraking();
    public void set_AutoBraking(bool value);
    public bool get_HasPath();
    public bool IsNavRunning();
    public void Pause();
    public void Resume();
    [IteratorStateMachineAttribute("BaseNpc/<TryForceToNavmesh>d__141")]
private IEnumerator TryForceToNavmesh();
    [CompilerGeneratedAttribute]
public BaseEntity get_AttackTarget();
    [CompilerGeneratedAttribute]
public void set_AttackTarget(BaseEntity value);
    [CompilerGeneratedAttribute]
public SeenInfo get_AttackTargetMemory();
    [CompilerGeneratedAttribute]
public void set_AttackTargetMemory(SeenInfo value);
    [CompilerGeneratedAttribute]
public BaseEntity get_FoodTarget();
    [CompilerGeneratedAttribute]
public void set_FoodTarget(BaseEntity value);
    public BaseCombatEntity get_CombatTarget();
    [CompilerGeneratedAttribute]
public Vector3 get_SpawnPosition();
    [CompilerGeneratedAttribute]
public void set_SpawnPosition(Vector3 value);
    public float get_AttackTargetVisibleFor();
    public float get_TimeAtDestination();
    public BaseCombatEntity get_Entity();
    public NavMeshAgent get_GetNavAgent();
    public float GetWantsToAttack(BaseEntity target);
    public AiStatistics get_GetStats();
    public float get_GetAttackRange();
    public Vector3 get_GetAttackOffset();
    public float get_GetStamina();
    public float get_GetEnergy();
    public float get_GetAttackCost();
    public float get_GetSleep();
    public Vector3 get_CurrentAimAngles();
    public float get_GetStuckDuration();
    public float get_GetLastStuckTime();
    public bool BusyTimerActive();
    public void SetBusyFor(float dur);
    public Vector3 get_AttackPosition();
    public Vector3 get_CrouchedAttackPosition();
    internal float WantsToAttack(BaseEntity target);
    public float get_currentBehaviorDuration();
    [CompilerGeneratedAttribute]
public Behaviour get_CurrentBehaviour();
    [CompilerGeneratedAttribute]
public void set_CurrentBehaviour(Behaviour value);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual float MaxVelocity();
    public bool HasAiFlag(AiFlags f);
    public void SetAiFlag(AiFlags f, bool set);
    public bool get_IsSitting();
    public void set_IsSitting(bool value);
    public bool get_IsChasing();
    public void set_IsChasing(bool value);
    public bool get_IsSleeping();
    public void set_IsSleeping(bool value);
    public void InitFacts();
    public byte GetFact(Facts fact);
    public void SetFact(Facts fact, byte value, bool triggerCallback, bool onlyTriggerCallbackOnDiffValue);
    public EnemyRangeEnum ToEnemyRangeEnum(float range);
    public float GetActiveAggressionRangeSqr();
    public FoodRangeEnum ToFoodRangeEnum(float range);
    public AfraidRangeEnum ToAfraidRangeEnum(float range);
    public HealthEnum ToHealthEnum(float healthNormalized);
    public byte ToIsTired(float energyNormalized);
    public SpeedEnum ToSpeedEnum(float speed);
    public float ToSpeed(SpeedEnum speed);
    public byte GetPathStatus();
    public NavMeshPathStatus ToPathStatus(byte value);
    private void TickSenses();
    private void TickHearing();
    private void TickSmell();
    private float DecisionMomentumPlayerTarget();
    private float DecisionMomentumAnimalTarget();
    private void TickFoodAwareness();
    private void SelectFood();
    private void SelectClosestFood();
    private void UpdateSelfFacts();
    private byte IsMoving();
    private static bool AiCaresAbout(BaseEntity ent);
    private static bool WithinVisionCone(BaseNpc npc, BaseEntity other);
    public void SetTargetPathStatus(float pendingDelay);
    private void DelayedTargetPathStatus();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void Hurt(HitInfo info);
    public virtual void OnKilled(HitInfo hitInfo);
    [CompilerGeneratedAttribute]
public float get_TargetSpeed();
    [CompilerGeneratedAttribute]
public void set_TargetSpeed(float value);
}
public class BaseOven : StorageContainer {
    private static Dictionary`2<float, HashSet`1<ItemDefinition>> _materialOutputCache;
    public TemperatureType temperature;
    public Option switchOnMenu;
    public Option switchOffMenu;
    public ItemAmount[] startupContents;
    public bool allowByproductCreation;
    public ItemDefinition fuelType;
    public bool canModFire;
    public bool disabledBySplash;
    public int smeltSpeed;
    public int fuelSlots;
    public int inputSlots;
    public int outputSlots;
    public IndustrialSlotMode IndustrialMode;
    public static Flags Flag_CookingPaused;
    public int _activeCookingSlot;
    public int _inputSlotIndex;
    public int _outputSlotIndex;
    public static float UpdateRate;
    public bool CanRunWithNoFuel { get; }
    public ItemContainer Container { get; }
    public BaseEntity IndustrialEntity { get; }
    public float cookingTemperature { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void PreInitShared();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void OnInventoryFirstCreated(ItemContainer container);
    public virtual void OnItemAddedOrRemoved(Item item, bool bAdded);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public Nullable`1<MinMax> GetAllowedSlots(Item item);
    public MinMax GetOutputSlotRange();
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public virtual void OvenFull();
    public int GetFuelRate();
    public int GetCharcoalRate();
    public virtual bool get_CanRunWithNoFuel();
    public void Cook();
    protected virtual void OnCooked();
    public void ConsumeFuel(Item fuel, ItemModBurnable burnable);
    [RPC_Server]
[MaxDistance("3")]
protected virtual void SVSwitch(RPCMessage msg);
    public float GetTemperature(int slot);
    public void UpdateAttachmentTemperature();
    public virtual void StartCooking();
    public virtual void StopCooking();
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public Item FindBurnable();
    public void IncreaseCookTime(float amount);
    public sealed virtual ItemContainer get_Container();
    public sealed virtual Vector2i InputSlotRange(int slotIndex);
    public sealed virtual Vector2i OutputSlotRange(int slotIndex);
    public sealed virtual void OnStorageItemTransferBegin();
    public sealed virtual void OnStorageItemTransferEnd();
    public sealed virtual BaseEntity get_IndustrialEntity();
    public float GetSmeltingSpeed();
    public float get_cookingTemperature();
    public bool IsBurnableItem(Item item);
    public bool IsBurnableByproduct(Item item);
    public bool IsMaterialInput(Item item);
    public bool IsMaterialOutput(Item item);
    public bool IsOutputItem(Item item);
    private void BuildMaterialOutputCache();
    public virtual bool HasSlot(Slot slot);
    public virtual bool SupportsChildDeployables();
    public virtual bool CanPickup(BasePlayer player);
    protected virtual bool CanPickupOven();
}
public class BasePath : MonoBehaviour {
    public List`1<BasePathNode> nodes;
    public List`1<PathInterestNode> interestZones;
    public List`1<PathSpeedZone> speedZones;
    private Nullable`1<float> cachedLength;
    public IEnumerable`1<IAIPathInterestNode> InterestNodes { get; }
    public IEnumerable`1<IAIPathSpeedZone> SpeedZones { get; }
    public sealed virtual IEnumerable`1<IAIPathInterestNode> get_InterestNodes();
    public sealed virtual IEnumerable`1<IAIPathSpeedZone> get_SpeedZones();
    private void AddChildren();
    private void ClearChildren();
    public static void AutoGenerateLinks(BasePath path, float maxRange);
    public sealed virtual void GetNodesNear(Vector3 point, List`1& nearNodes, float dist);
    public sealed virtual IAIPathNode GetClosestToPoint(Vector3 point);
    public sealed virtual IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist);
    public sealed virtual void AddInterestNode(IAIPathInterestNode interestZone);
    public sealed virtual void AddSpeedZone(IAIPathSpeedZone speedZone);
    public float GetPathLength();
    public float GetPathProgress(Vector3 position);
    public void GetPointInPath(float normalisedTime, Vector3& pos, Vector3& rotation);
}
public class BasePathFinder : object {
    private static Vector3[] preferedTopologySamples;
    private static Vector3[] topologySamples;
    private Vector3 chosenPosition;
    private static float halfPI;
    private static BasePathFinder();
    public virtual Vector3 GetRandomPatrolPoint();
    public virtual AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange);
    public void DebugDraw();
    public virtual Vector3 GetRandomPositionAround(Vector3 position, float minDistFrom, float maxDistFrom);
    public virtual Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange);
    public virtual Vector3 GetBestRoamPositionFromAnchor(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange);
    public virtual bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, Vector3& result);
    private bool TestFleeDirection(BaseNavigator navigator, Vector3 dirFromThreat, float offsetDegrees, float minRange, float maxRange, Vector3& result);
    public static Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees);
}
public class BasePathNode : MonoBehaviour {
    public BasePath Path;
    public List`1<BasePathNode> linked;
    public float maxVelocityOnApproach;
    public bool straightaway;
    public Vector3 Position { get; }
    public bool Straightaway { get; }
    public IEnumerable`1<IAIPathNode> Linked { get; }
    public sealed virtual Vector3 get_Position();
    public sealed virtual bool get_Straightaway();
    public sealed virtual IEnumerable`1<IAIPathNode> get_Linked();
    public sealed virtual bool IsValid();
    public sealed virtual void AddLink(IAIPathNode link);
    public void OnDrawGizmosSelected();
}
public class BasePet : NPCPlayer {
    public static Dictionary`2<ulong, BasePet> ActivePetByOwnerID;
    [ServerVar]
public static bool queuedMovementsAllowed;
    [ServerVar]
public static bool onlyQueueBaseNavMovements;
    [HelpAttribute("How many miliseconds to budget for processing pet movements per frame")]
[ServerVar]
public static float movementupdatebudgetms;
    public float BaseAttackRate;
    public float BaseAttackDamge;
    public DamageType AttackDamageType;
    [CompilerGeneratedAttribute]
private PetBrain <Brain>k__BackingField;
    public GameObjectRef mapMarkerPrefab;
    private BaseEntity _mapMarkerInstance;
    [HideInInspector]
public bool inQueue;
    public static Queue`1<BasePet> _movementProcessQueue;
    public PetBrain Brain { get; protected set; }
    private static BasePet();
    [CompilerGeneratedAttribute]
public PetBrain get_Brain();
    [CompilerGeneratedAttribute]
protected void set_Brain(PetBrain value);
    public virtual float StartHealth();
    public virtual float StartMaxHealth();
    public virtual float MaxHealth();
    public static void ProcessMovementQueue();
    public void DoBudgetedMoveUpdate();
    public virtual bool IsLoadBalanced();
    public virtual void ServerInit();
    public void CreateMapMarker();
    internal virtual void DoServerDestroy();
    public virtual void TryThink();
    public virtual void ServerThink(float delta);
    public void ApplyPetStatModifiers();
    private void OnPhysicsNeighbourChanged();
}
public class BasePlayer : BaseCombatEntity {
    public bool isInAir;
    public bool isOnPlayer;
    public float violationLevel;
    public float lastViolationTime;
    public float lastAdminCheatTime;
    public AntiHackType lastViolationType;
    public float vehiclePauseTime;
    public float speedhackPauseTime;
    public float speedhackDistance;
    public float flyhackPauseTime;
    public float flyhackDistanceVertical;
    public float flyhackDistanceHorizontal;
    public Vector3 lastGroundedPosition;
    public float fallingVelocity;
    public float fallingDistance;
    public float timeInAir;
    public float waterDelay;
    public Vector3 initialVelocity;
    public TimeAverageValueLookup`1<UInt32> rpcHistory;
    public static Phrase ClanInviteSuccess;
    public static Phrase ClanInviteFailure;
    public static Phrase ClanInviteFull;
    public long clanId;
    public IClan serverClan;
    public ViewModel GestureViewModel;
    public static float drinkRange;
    public static float drinkMovementSpeed;
    private NetworkQueueList[] networkQueue;
    private NetworkQueueList SnapshotQueue;
    public static string GestureCancelString;
    public GestureCollection gestureList;
    public TimeUntil gestureFinishedTime;
    public TimeSince blockHeldInputTimer;
    public GestureConfig currentGesture;
    private HashSet`1<NetworkableId> recentWaveTargets;
    public static string WAVED_PLAYERS_STAT;
    public ulong currentTeam;
    public static Phrase MaxTeamSizeToast;
    private bool sentInstrumentTeamAchievement;
    private bool sentSummerTeamAchievement;
    private static int TEAMMATE_INSTRUMENT_COUNT_ACHIEVEMENT;
    private static int TEAMMATE_SUMMER_FLOATING_COUNT_ACHIEVEMENT;
    private static string TEAMMATE_INSTRUMENT_ACHIEVEMENT;
    private static string TEAMMATE_SUMMER_ACHIEVEMENT;
    public static Phrase MarkerLimitPhrase;
    public static int MaxMapNoteLabelLength;
    public List`1<MissionInstance> missions;
    private float thinkEvery;
    private float timeSinceMissionThink;
    private BaseMission followupMission;
    private IMissionProvider followupMissionProvider;
    private int _activeMission;
    public ModelState modelState;
    [CompilerGeneratedAttribute]
private ModelState <modelStateTick>k__BackingField;
    private bool wantsSendModelState;
    public float nextModelStateUpdate;
    public EntityRef mounted;
    public float nextSeatSwapTime;
    public BaseEntity PetEntity;
    public IPet Pet;
    private float lastPetCommandIssuedTime;
    private static Phrase HostileTitle;
    private static Phrase HostileDesc;
    private static PingStyle HostileMarker;
    private static Phrase GoToTitle;
    private static Phrase GoToDesc;
    private static PingStyle GoToMarker;
    private static Phrase DollarTitle;
    private static Phrase DollarDesc;
    private static PingStyle DollarMarker;
    private static Phrase LootTitle;
    private static Phrase LootDesc;
    private static PingStyle LootMarker;
    private static Phrase NodeTitle;
    private static Phrase NodeDesc;
    private static PingStyle NodeMarker;
    private static Phrase GunTitle;
    private static Phrase GunDesc;
    private static PingStyle GunMarker;
    private static PingStyle BuildMarker;
    private TimeSince lastTick;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<ItemDefinition, PingType>> tutorialDesiredResource;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<NetworkableId, PingType>> pingedEntities;
    private TimeSince lastResourcePingUpdate;
    private bool _playerStateDirty;
    private string _wipeId;
    private BaseEntity cachedPrivilegeFromOther;
    private float cachedPrivilegeFromOtherTime;
    public Dictionary`2<int, FiredProjectile> firedProjectiles;
    private static float radiationDamageTime;
    private static float radiationDamageThreshold;
    private static float radiationRatioAdjustment;
    private static float containerCheckRadTime;
    private static float containerRadRatioAdjustment;
    private Action inflictInventoryRadsAction;
    private float inventoryRads;
    private bool hasOpenedLoot;
    private List`1<ItemContainer> radiationCheckContainers;
    private float containerRads;
    private Action inflictRadsAction;
    private Action checkRadsAction;
    public PlayerStatistics stats;
    public ItemId svActiveItemID;
    public float NextChatTime;
    public float nextSuicideTime;
    public float nextRespawnTime;
    public string respawnId;
    private RealTimeUntil timeUntilLoadingExpires;
    [CompilerGeneratedAttribute]
private int <DebugMapMarkerIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlayHeavyLandingAnimation>k__BackingField;
    public Dictionary`2<BaseNetworkable, float> lastPlayerVisibility;
    [CompilerGeneratedAttribute]
private Vector3 <estimatedVelocity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <estimatedSpeed>k__BackingField;
    [CompilerGeneratedAttribute]
private float <estimatedSpeed2D>k__BackingField;
    [CompilerGeneratedAttribute]
private int <secondsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
public float <desyncTimeRaw>k__BackingField;
    [CompilerGeneratedAttribute]
public float <desyncTimeClamped>k__BackingField;
    public Vector3 viewAngles;
    public float lastSubscriptionTick;
    public float lastPlayerTick;
    public float sleepStartTime;
    public float fallTickRate;
    public float lastFallTime;
    public float fallVelocity;
    private DeathBlow cachedNonSuicideHit;
    public static ListHashSet`1<BasePlayer> activePlayerList;
    public static ListHashSet`1<BasePlayer> sleepingPlayerList;
    public static ListHashSet`1<BasePlayer> bots;
    public float cachedCraftLevel;
    public float nextCheckTime;
    private Workbench _cachedWorkbench;
    public PersistantPlayer cachedPersistantPlayer;
    private static OceanPaths cachedOceanPaths;
    private static int WILDERNESS;
    private static int MONUMENT;
    private static int BASE;
    private static int FLYING;
    private static int BOATING;
    private static int SWIMMING;
    private static int DRIVING;
    [HelpAttribute("How many milliseconds to budget for processing life story updates per frame")]
[ServerVar]
public static float lifeStoryFramebudgetms;
    public PlayerLifeStory lifeStory;
    public PlayerLifeStory previousLifeStory;
    public static float TimeCategoryUpdateFrequency;
    public float nextTimeCategoryUpdate;
    [CompilerGeneratedAttribute]
private int <currentTimeCategory>k__BackingField;
    private bool hasSentPresenceState;
    private bool LifeStoryInWilderness;
    private bool LifeStoryInMonument;
    private bool LifeStoryInBase;
    private bool LifeStoryFlying;
    private bool LifeStoryBoating;
    private bool LifeStorySwimming;
    private bool LifeStoryDriving;
    private bool waitingForLifeStoryUpdate;
    public static LifeStoryWorkQueue lifeStoryQueue;
    [CanBeNullAttribute]
private DeathInfo cachedOverrideDeathInfo;
    private bool IsSpectatingTeamInfo;
    private TimeSince lastSpectateTeamInfoUpdate;
    public int SpectateOffset;
    public string spectateFilter;
    [CompilerGeneratedAttribute]
private bool <IsBeingSpectated>k__BackingField;
    private List`1<NearbyStash> nearbyStashes;
    public float lastUpdateTime;
    public float cachedThreatLevel;
    public float weaponDrawnDuration;
    [CompilerGeneratedAttribute]
private InputState <serverInput>k__BackingField;
    public float lastTickTime;
    public float lastStallTime;
    public float lastInputTime;
    private float tutorialKickTime;
    public Nullable`1<ItemId> restraintItemId;
    public PlayerTick lastReceivedTick;
    private float tickDeltaTime;
    private bool tickNeedsFinalizing;
    [CompilerGeneratedAttribute]
private Vector3 <tickViewAngles>k__BackingField;
    private TimeAverageValue ticksPerSecond;
    private TickInterpolator tickInterpolator;
    public Deque`1<Vector3> eyeHistory;
    public TickHistory tickHistory;
    [CompilerGeneratedAttribute]
private TutorialItemAllowance <CurrentTutorialAllowance>k__BackingField;
    private float startTutorialCooldown;
    public float nextUnderwearValidationTime;
    public UInt32 lastValidUnderwearSkin;
    public float woundedDuration;
    public float lastWoundedStartTime;
    public float healingWhileCrawling;
    public bool woundedByFallDamage;
    private static float INCAPACITATED_HEALTH_MIN;
    private static float INCAPACITATED_HEALTH_MAX;
    public static int MaxBotIdRange;
    [HeaderAttribute("BasePlayer")]
public GameObjectRef fallDamageEffect;
    public GameObjectRef drownEffect;
    [InspectorFlagsAttribute]
public PlayerFlags playerFlags;
    private HiddenValue`1<PlayerEyes> eyesValue;
    private HiddenValue`1<PlayerInventory> inventoryValue;
    public PlayerBlueprints blueprints;
    public PlayerMetabolism metabolism;
    public PlayerModifiers modifiers;
    private HiddenValue`1<CapsuleCollider> colliderValue;
    public PlayerBelt Belt;
    public Rigidbody playerRigidbody;
    public EncryptedValue`1<ulong> userID;
    public string UserIDString;
    public int gamemodeteam;
    public int reputation;
    protected string _displayName;
    public string _lastSetName;
    public static float crouchSpeed;
    public static float walkSpeed;
    public static float runSpeed;
    public static float crawlSpeed;
    public CapsuleColliderInfo playerColliderStanding;
    public CapsuleColliderInfo playerColliderDucked;
    public CapsuleColliderInfo playerColliderCrawling;
    public CapsuleColliderInfo playerColliderLyingDown;
    public ProtectionProperties cachedProtection;
    public float nextColliderRefreshTime;
    public float weaponMoveSpeedScale;
    public bool clothingBlocksAiming;
    public float clothingMoveSpeedReduction;
    public float clothingWaterSpeedBonus;
    public float clothingAccuracyBonus;
    public bool equippingBlocked;
    public float eggVision;
    public PhoneController activeTelephone;
    public BaseEntity designingAIEntity;
    public IPlayer IPlayer;
    public Phrase LootPanelTitle { get; }
    public bool IsReceivingSnapshot { get; }
    public bool IsAdmin { get; }
    public bool IsDeveloper { get; }
    public bool IsInCreativeMode { get; }
    public bool UnlockAllSkins { get; }
    public bool IsAiming { get; }
    public bool IsFlying { get; }
    public bool IsConnected { get; }
    public bool IsInTutorial { get; }
    public bool IsRestrained { get; }
    public bool IsRestrainedOrSurrendering { get; }
    public bool InGesture { get; }
    private bool CurrentGestureBlocksMovement { get; }
    public bool CurrentGestureIsDance { get; }
    public bool CurrentGestureIsFullBody { get; }
    public bool CurrentGestureIsUpperBody { get; }
    public bool CurrentGestureIsSurrendering { get; }
    private bool InGestureCancelCooldown { get; }
    public PlayerTeam Team { get; }
    public MapNote ServerCurrentDeathNote { get; public set; }
    public bool HasPendingFollowupMission { get; }
    public ModelState modelStateTick { get; private set; }
    public bool isMounted { get; }
    public bool isMountingHidingWeapon { get; }
    private int TotalPingCount { get; }
    public PlayerState State { get; }
    public string WipeId { get; }
    public FamilyEnum Family { get; }
    protected float PositionTickRate { get; }
    public int DebugMapMarkerIndex { get; public set; }
    public bool PlayHeavyLandingAnimation { get; public set; }
    public Grid Chunk { get; }
    public SubGrid SubGrid { get; }
    public SubGrid EstimatedSubGrid { get; }
    public Vector3 estimatedVelocity { get; private set; }
    public Vector3 estimatedVelocityClamped { get; }
    public float estimatedSpeed { get; private set; }
    public float estimatedSpeed2D { get; private set; }
    public int secondsConnected { get; private set; }
    public float desyncTimeRaw { get; private set; }
    public float desyncTimeClamped { get; private set; }
    public float secondsSleeping { get; }
    public static IEnumerable`1<BasePlayer> allPlayerList { get; }
    public float currentCraftLevel { get; }
    public float currentComfort { get; }
    public PersistantPlayer PersistantPlayerInfo { get; public set; }
    public bool hasPreviousLife { get; }
    public int currentTimeCategory { get; private set; }
    public bool IsBeingSpectated { get; private set; }
    public InputState serverInput { get; private set; }
    public float timeSinceLastTick { get; }
    public float timeSinceLastStall { get; }
    public float IdleTime { get; }
    public bool isStalled { get; }
    public bool wasStalled { get; }
    public Vector3 tickViewAngles { get; private set; }
    public int tickHistoryCapacity { get; }
    public Matrix4x4 tickHistoryMatrix { get; }
    public TutorialItemAllowance CurrentTutorialAllowance { get; private set; }
    public float TimeSinceWoundedStarted { get; }
    public Connection Connection { get; }
    public bool IsBot { get; }
    public PlayerEyes eyes { get; public set; }
    public PlayerInventory inventory { get; }
    public CapsuleCollider playerCollider { get; }
    public string displayName { get; public set; }
    public TraitFlag Traits { get; }
    public bool HasActiveTelephone { get; }
    public bool IsDesigningAI { get; }
    private static BasePlayer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool TriggeredAntiHack(float seconds, float score);
    public bool UsedAdminCheat(float seconds);
    public void PauseVehicleNoClipDetection(float seconds);
    public void PauseFlyHackDetection(float seconds);
    public void PauseSpeedHackDetection(float seconds);
    public int GetAntiHackKicks();
    public void ResetAntiHack();
    public bool CanModifyClan();
    public void LoadClanInfo();
    public void UpdateClanLastSeen();
    public void AddClanScore(ClanScoreEventType type, int multiplier, BasePlayer otherPlayer, IClan otherClan, string arg1, string arg2);
    private void HandleClanPlayerKilled(BasePlayer killedByPlayer);
    public virtual bool CanBeLooted(BasePlayer player);
    public sealed virtual Phrase get_LootPanelTitle();
    [RPC_Server]
[IsVisible("3")]
public void RPC_LootPlayer(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_Assist(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_KeepAlive(RPCMessage msg);
    [RPC_Server]
private void SV_Drink(RPCMessage msg);
    [RPC_Server]
public void RPC_StartClimb(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("1")]
private void RequestServerEmoji();
    [RPC_Server]
[CallsPerSecond("3")]
private void ServerRequestEmojiData(RPCMessage msg);
    public int GetQueuedUpdateCount(NetworkQueue queue);
    public void SendSnapshots(ListHashSet`1<Networkable> ents);
    public void QueueUpdate(NetworkQueue queue, BaseNetworkable ent);
    public void SendEntityUpdate();
    public void ClearEntityQueue(Group group);
    private void SendEntityUpdates(NetworkQueueList queue);
    public void SendEntitySnapshot(BaseNetworkable ent);
    public bool HasPlayerFlag(PlayerFlags f);
    public bool get_IsReceivingSnapshot();
    public bool get_IsAdmin();
    public bool get_IsDeveloper();
    public bool get_IsInCreativeMode();
    public bool get_UnlockAllSkins();
    public bool get_IsAiming();
    public bool get_IsFlying();
    public bool get_IsConnected();
    public void SetPlayerFlag(PlayerFlags f, bool b);
    public void LightToggle(bool mask);
    public bool get_IsInTutorial();
    public bool get_IsRestrained();
    public bool get_IsRestrainedOrSurrendering();
    public bool get_InGesture();
    private bool get_CurrentGestureBlocksMovement();
    public bool get_CurrentGestureIsDance();
    public bool get_CurrentGestureIsFullBody();
    public bool get_CurrentGestureIsUpperBody();
    public bool get_CurrentGestureIsSurrendering();
    private bool get_InGestureCancelCooldown();
    [CallsPerSecond("1")]
[RPC_Server]
[FromOwner]
public void Server_StartGesture(RPCMessage msg);
    public void Server_StartGesture(UInt32 gestureId);
    public void Server_StartGesture(GestureConfig toPlay, GestureStartSource startSource);
    private void TimeoutGestureServer();
    [FromOwner]
[RPC_Server]
[CallsPerSecond("10")]
public void Server_CancelGesture();
    private void MonitorLoopingGesture();
    private void NotifyGesturesNewItemEquipped();
    public int CountWaveTargets(Vector3 position, float distance, float minimumDot, Vector3 forward, HashSet`1<NetworkableId> workingList, int maxCount);
    private bool IsGestureBlocked();
    public PlayerTeam get_Team();
    public void DelayedTeamUpdate();
    public void TeamUpdate();
    public void TeamUpdate(bool fullTeamUpdate);
    public void UpdateTeam(ulong newTeam);
    public void ClearTeam();
    public void ClearPendingInvite();
    public HeldEntity GetHeldEntity();
    public bool IsHoldingEntity();
    public bool IsHostileItem(Item item);
    public bool IsItemHoldRestricted(Item item);
    public MapNote get_ServerCurrentDeathNote();
    public void set_ServerCurrentDeathNote(MapNote value);
    public void ClearDeathMarker(bool sendToClient);
    public void Server_LogDeathMarker(Vector3 position);
    [FromOwner]
[RPC_Server]
[CallsPerSecond("8")]
public void Server_AddMarker(RPCMessage msg);
    private int FindUnusedPointOfInterestColour();
    [RPC_Server]
[FromOwner]
[CallsPerSecond("1")]
public void Server_UpdateMarker(RPCMessage msg);
    private void ValidateMapNote(MapNote n);
    [CallsPerSecond("10")]
[FromOwner]
[RPC_Server]
public void Server_RemovePointOfInterest(RPCMessage msg);
    [FromOwner]
[RPC_Server]
[CallsPerSecond("1")]
public void Server_RequestMarkers(RPCMessage msg);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("1")]
public void Server_ClearMapMarkers(RPCMessage msg);
    public void SendMarkersToClient();
    public bool HasAttemptedMission(UInt32 missionID);
    public bool CanAcceptMission(BaseMission mission);
    public bool CanAcceptMission(UInt32 missionID);
    public bool IsMissionActive(UInt32 missionID);
    public bool HasCompletedMission(UInt32 missionID);
    public bool HasFailedMission(UInt32 missionID);
    private void WipeMissions();
    public void AbandonActiveMission();
    public void ThinkMissions(float delta);
    public void MissionDirty(bool shouldSendNetworkUpdate);
    public void ProcessMissionEvent(MissionEventType type, UInt32 identifier, float amount);
    public void ProcessMissionEvent(MissionEventType type, UInt32 identifier, float amount, Vector3 worldPos);
    public void ProcessMissionEvent(MissionEventType type, int identifier, float amount);
    public void ProcessMissionEvent(MissionEventType type, NetworkableId identifier, float amount);
    public void ProcessMissionEvent(MissionEventType type, MissionEventPayload payload, float amount);
    private void AssignFollowUpMission();
    public void RegisterFollowupMission(BaseMission targetMission, IMissionProvider provider);
    public bool get_HasPendingFollowupMission();
    private Missions SaveMissions();
    public void SetActiveMission(int index);
    public int GetActiveMission();
    public bool HasActiveMission();
    public MissionInstance GetActiveMissionInstance();
    private void LoadMissions(Missions loadedMissions);
    [CompilerGeneratedAttribute]
public ModelState get_modelStateTick();
    [CompilerGeneratedAttribute]
private void set_modelStateTick(ModelState value);
    private void UpdateModelState();
    public void SendModelState(bool force);
    public bool get_isMounted();
    public bool get_isMountingHidingWeapon();
    public BaseMountable GetMounted();
    public BaseVehicle GetMountedVehicle();
    public void MarkSwapSeat();
    public bool SwapSeatCooldown();
    public bool CanMountMountablesNow();
    public void SetMounted(BaseMountable mount);
    public void EnsureDismounted();
    public virtual void DismountObject();
    public void HandleMountedOnLoad();
    public bool AllowSleeperMounting(BaseMountable mountable);
    public PlayerSecondaryData SaveSecondaryData();
    public void LoadSecondaryData(PlayerSecondaryData data);
    public virtual void DisableTransferProtection();
    public void KickAfterServerTransfer();
    [RPC_Server]
[CallsPerSecond("5")]
[FromOwner]
private void RequestParachuteDeploy(RPCMessage msg);
    public void RequestParachuteDeploy();
    public bool CheckParachuteClearance();
    public bool HasValidParachuteEquipped();
    public void ClearClientPetLink();
    public void SendClientPetLink();
    public void SendClientPetStateIndex();
    [RPC_Server]
private void IssuePetCommand(RPCMessage msg);
    [RPC_Server]
private void IssuePetCommandRaycast(RPCMessage msg);
    private void ParsePetCommand(RPCMessage msg, bool raycast);
    public bool CanPing(bool disregardHeldEntity);
    public static PingStyle GetPingStyle(PingType t);
    private void ApplyPingStyle(MapNote note, PingType type);
    [CallsPerSecond("3")]
[FromOwner]
[RPC_Server]
private void Server_AddPing(RPCMessage msg);
    public void AddPingAtLocation(PingType type, Vector3 location, float time, NetworkableId associatedId);
    public void RemovePingAtLocation(PingType type, Vector3 location, float tolerance, NetworkableId associatedId);
    [FromOwner]
[CallsPerSecond("3")]
[RPC_Server]
private void Server_RemovePing(RPCMessage msg);
    public void SendPingsToClient();
    private int get_TotalPingCount();
    public void TickPings();
    public void RegisterPingedEntity(BaseEntity entity, PingType type);
    public void DeregisterPingedEntitiesOfType(PingType type);
    public void DeregisterPingedEntity(NetworkableId id, PingType type);
    public void EnableResourcePings(ItemDefinition forItem, PingType pingType);
    private void UpdateResourcePings();
    private MapNote CreatePingForEntity(BaseEntity baseEntity, PingType type);
    private bool HasPingForEntity(BaseEntity ent);
    private bool HasPingForEntity(NetworkableId id);
    public void DisableResourcePings(ItemDefinition forItem, PingType type);
    private void ClearAllPings();
    public PlayerState get_State();
    public string get_WipeId();
    public void DirtyPlayerState();
    public void SavePlayerState();
    public void ResetPlayerState();
    public bool IsSleeping();
    public bool IsSpectating();
    public bool IsRelaxed();
    public bool IsServerFalling();
    public bool IsLoadingAfterTransfer();
    public bool CanBuild();
    public bool CanBuild(Vector3 position, Quaternion rotation, Bounds bounds);
    public bool CanBuild(OBB obb);
    public bool IsBuildingBlocked();
    public bool IsBuildingBlocked(Vector3 position, Quaternion rotation, Bounds bounds);
    public bool IsBuildingBlocked(OBB obb);
    public bool IsBuildingAuthed();
    public bool IsBuildingAuthed(Vector3 position, Quaternion rotation, Bounds bounds);
    public bool IsBuildingAuthed(OBB obb);
    public bool CanPlaceBuildingPrivilege();
    public bool CanPlaceBuildingPrivilege(Vector3 position, Quaternion rotation, Bounds bounds);
    public bool CanPlaceBuildingPrivilege(OBB obb);
    public bool IsNearEnemyBase();
    public bool IsNearEnemyBase(Vector3 position, Quaternion rotation, Bounds bounds);
    public bool IsNearEnemyBase(OBB obb);
    public bool IsBuildingBlockedByVehicle();
    public bool IsBuildingBlockedByEntity();
    public bool HasPrivilegeFromOther();
    private bool IsBuildingBlockedByVehicle(OBB obb);
    private bool IsBuildingBlockedByEntity(OBB obb);
    [RPC_Server]
[FromOwner]
public void OnProjectileAttack(RPCMessage msg);
    [RPC_Server]
[FromOwner]
public void OnProjectileRicochet(RPCMessage msg);
    [FromOwner]
[RPC_Server]
public void OnProjectileUpdate(RPCMessage msg);
    private void SimulateProjectile(Vector3& position, Vector3& velocity, Single& partialTime, float travelTime, Vector3 gravity, float drag, Vector3& prevPosition, Vector3& prevVelocity);
    protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem);
    public void CleanupExpiredProjectiles();
    public bool HasFiredProjectile(int id);
    public void NoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Guid projectileGroupId, Vector3 positionOffset, Item pickupItem);
    public void ServerNoteFiredProjectile(int projectileid, Vector3 startPos, Vector3 startVel, AttackEntity attackEnt, ItemDefinition firedItemDef, Item pickupItem);
    public void ApplyRadiation(float radsAmount, bool protection);
    public void PlayerInventoryRadioactivityChange(float radAmount, bool hasRads);
    private void InflcitRadsFromInventory();
    public void RadioactiveLootCheck(List`1<ItemContainer> containerRefs);
    private void HasOpenedLoot();
    public void HasClosedLoot();
    private void InflictRadsFromContainer();
    private void CheckRadsInContainer();
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual FamilyEnum get_Family();
    protected virtual float get_PositionTickRate();
    [CompilerGeneratedAttribute]
public int get_DebugMapMarkerIndex();
    [CompilerGeneratedAttribute]
public void set_DebugMapMarkerIndex(int value);
    [CompilerGeneratedAttribute]
public bool get_PlayHeavyLandingAnimation();
    [CompilerGeneratedAttribute]
public void set_PlayHeavyLandingAnimation(bool value);
    public Grid get_Chunk();
    public SubGrid get_SubGrid();
    public SubGrid get_EstimatedSubGrid();
    internal virtual void OnParentRemoved();
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    private void TransformState(Matrix4x4 matrix);
    public bool CanSuicide();
    public void MarkSuicide();
    public bool CanRespawn();
    public void MarkRespawn(float nextSpawnDelay);
    public Item GetActiveItem();
    public void MovePosition(Vector3 newPos);
    [CompilerGeneratedAttribute]
public Vector3 get_estimatedVelocity();
    [CompilerGeneratedAttribute]
private void set_estimatedVelocity(Vector3 value);
    public Vector3 get_estimatedVelocityClamped();
    [CompilerGeneratedAttribute]
public float get_estimatedSpeed();
    [CompilerGeneratedAttribute]
private void set_estimatedSpeed(float value);
    [CompilerGeneratedAttribute]
public float get_estimatedSpeed2D();
    [CompilerGeneratedAttribute]
private void set_estimatedSpeed2D(float value);
    [CompilerGeneratedAttribute]
public int get_secondsConnected();
    [CompilerGeneratedAttribute]
private void set_secondsConnected(int value);
    [CompilerGeneratedAttribute]
public float get_desyncTimeRaw();
    [CompilerGeneratedAttribute]
private void set_desyncTimeRaw(float value);
    [CompilerGeneratedAttribute]
public float get_desyncTimeClamped();
    [CompilerGeneratedAttribute]
private void set_desyncTimeClamped(float value);
    public void OverrideViewAngles(Vector3 newAng);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void ServerUpdate(float deltaTime);
    private void ServerUpdateBots(float deltaTime);
    public void ConnectedPlayerUpdate(float deltaTime);
    private void EnterGame();
    private void HandleTutorialOnGameEnter();
    [FromOwner]
[RPC_Server]
private void ClientKeepConnectionAlive(RPCMessage msg);
    [FromOwner]
[RPC_Server]
private void ClientLoadingComplete(RPCMessage msg);
    public void PlayerInit(Connection c);
    public void StatSave();
    public void SendDeathInformation();
    public void SendRespawnOptions();
    public static void GetRespawnOptionsForPlayer(List`1<SpawnOptions> spawnOptions, ulong userID);
    [CallsPerSecond("1")]
[RPC_Server]
[FromOwner]
private void RequestRespawnInformation(RPCMessage msg);
    public float get_secondsSleeping();
    public void ScheduledDeath();
    public virtual void StartSleeping();
    private void TurnOffAllLights();
    private void OnPhysicsNeighbourChanged();
    private void DelayedServerFall();
    public void SetServerFall(bool wantsOn);
    public void ServerFall();
    public void DelayedRigidbodyDisable();
    public virtual void EndSleeping();
    public virtual void EndLooting();
    public virtual void OnDisconnected();
    private void InventoryUpdate();
    public void ApplyFallDamageFromVelocity(float velocity);
    [FromOwner]
[RPC_Server]
private void OnPlayerLanded(RPCMessage msg);
    public void SendGlobalSnapshot();
    public void SendFullSnapshot();
    public virtual void OnNetworkGroupLeave(Group group);
    private void LeaveVisibility(Group group);
    public virtual void OnNetworkGroupEnter(Group group);
    private void EnterVisibility(Group group);
    public void CheckDeathCondition(HitInfo info);
    public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath, bool forceServerSide);
    public virtual void OnKilled(HitInfo info);
    public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity);
    public void Respawn();
    public bool IsImmortalTo(HitInfo info);
    public float TimeAlive();
    public virtual void Hurt(HitInfo info);
    public virtual void Heal(float amount);
    [IteratorStateMachineAttribute("BasePlayer/<get_allPlayerList>d__469")]
public static IEnumerable`1<BasePlayer> get_allPlayerList();
    public static BasePlayer FindBot(ulong userId);
    public static BasePlayer FindBotClosestMatch(string name);
    public static BasePlayer FindByID(ulong userID);
    public static bool TryFindByID(ulong userID, BasePlayer& basePlayer);
    public static BasePlayer FindSleeping(ulong userID);
    public static BasePlayer FindAwakeOrSleepingByID(ulong userID);
    public void Command(string strCommand, Object[] arguments);
    public virtual void OnInvalidPosition();
    public static BasePlayer Find(string strNameOrIDOrIP, IEnumerable`1<BasePlayer> list);
    public static BasePlayer Find(string strNameOrIDOrIP);
    public static BasePlayer FindSleeping(string strNameOrIDOrIP);
    public static BasePlayer FindAwakeOrSleeping(string strNameOrIDOrIP);
    public void SendConsoleCommand(string command, Object[] obj);
    public void UpdateRadiation(float fAmount);
    public virtual float RadiationExposureFraction();
    public virtual float RadiationProtection();
    public virtual void OnHealthChanged(float oldvalue, float newvalue);
    public void SV_ClothingChanged();
    public bool IsNoob();
    public bool HasHostileItem();
    public virtual void GiveItem(Item item, GiveItemReason reason);
    public virtual void AttackerInfo(DeathInfo info);
    public void InvalidateWorkbenchCache();
    public Workbench GetCachedCraftLevelWorkbench();
    public float get_currentCraftLevel();
    public float get_currentComfort();
    public virtual bool ShouldDropActiveItem();
    public virtual void Die(HitInfo info);
    public void Kick(string reason, bool reserveSlot);
    public virtual Vector3 GetDropPosition();
    public virtual Vector3 GetDropVelocity();
    public virtual void ApplyInheritedVelocity(Vector3 velocity);
    public virtual void SetInfo(string key, string val);
    public virtual int GetInfoInt(string key, int defaultVal);
    public virtual bool GetInfoBool(string key, bool defaultVal);
    public virtual string GetInfoString(string key, string defaultVal);
    [CallsPerSecond("1")]
[RPC_Server]
public void PerformanceReport(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("1")]
public void PerformanceReport_Frametime(RPCMessage msg);
    public virtual bool ShouldNetworkTo(BasePlayer player);
    private bool OcclusionLineOfSight(BasePlayer player);
    private static void OcclusionPlayerFound(BasePlayer player1, BasePlayer player2, bool cache);
    private static void OcclusionPlayerLost(BasePlayer player1, BasePlayer player2, bool cache);
    private bool OcclusionGetRecentlySeen(BasePlayer player);
    private bool OcclusionShouldSeeAllPlayers();
    internal void GiveAchievement(string name, bool allowTutorial);
    [RPC_Server]
[CallsPerSecond("1")]
public void OnPlayerReported(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("1")]
public void OnFeedbackReport(RPCMessage msg);
    public void StartDemoRecording();
    public void StopDemoRecording();
    public void MonitorDemoRecording();
    public void InvalidateCachedPeristantPlayer();
    public PersistantPlayer get_PersistantPlayerInfo();
    public void set_PersistantPlayerInfo(PersistantPlayer value);
    public bool IsPlayerVisibleToUs(BasePlayer otherPlayer, Vector3 fromOffset, int layerMask);
    protected virtual void OnKilledByPlayer(BasePlayer p);
    public sealed virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public sealed virtual ItemContainerId GetIdealContainer(BasePlayer looter, Item item, ItemMoveModifier modifier);
    private BaseVehicle GetVehicleParent();
    private void RemoveLoadingPlayerFlag();
    public bool InNoRespawnZone();
    private void SendCargoPatrolPath();
    [RPC_Server]
[CallsPerSecond("5")]
[MaxDistance("3")]
[IsVisible("3")]
private void RPC_ReqDoPush(RPCMessage rpc);
    [RPC_Server]
[CallsPerSecond("5")]
[IsVisible("3")]
[MaxDistance("3")]
private void RPC_ReqRemoveCuffs(RPCMessage rpc);
    [IsVisible("3")]
[MaxDistance("3")]
[RPC_Server]
[CallsPerSecond("5")]
private void RPC_ReqRemoveHood(RPCMessage rpc);
    private void RemoveAndReturnPrisonerHood(BasePlayer returnToPlayer);
    [RPC_Server]
[CallsPerSecond("5")]
[MaxDistance("3")]
[IsVisible("3")]
private void RPC_ReqEquipHood(RPCMessage rpc);
    private void EquipPrisonerHood(BasePlayer placingPlayer);
    [MaxDistance("3")]
[CallsPerSecond("5")]
[RPC_Server]
[IsVisible("3")]
private void RPC_ReqForceMountNearest(RPCMessage rpc);
    private void ForceRestrainedMountNearest(BasePlayer forcingPlayer);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("5")]
[MaxDistance("3")]
private void RPC_ReqForceSwapSeat(RPCMessage rpc);
    public sealed virtual bool CanMoveFrom(BasePlayer player, Item item);
    public bool get_hasPreviousLife();
    [CompilerGeneratedAttribute]
public int get_currentTimeCategory();
    [CompilerGeneratedAttribute]
private void set_currentTimeCategory(int value);
    internal void LifeStoryStart();
    public void LifeStoryEnd();
    internal void LifeStoryUpdate(float deltaTime, float moveSpeed);
    public void UpdateTimeCategory();
    public void LifeStoryShotFired(BaseEntity withWeapon);
    public void LifeStoryShotHit(BaseEntity withWeapon);
    public void LifeStoryKill(BaseCombatEntity killed);
    public void LifeStoryGenericStat(string key, int value);
    public void LifeStoryHurt(float amount);
    public void LifeStoryHeal(float amount);
    public void SetOverrideDeathBlow(DeathInfo info);
    internal void LifeStoryLogDeath(DeathBlow& deathBlow, DamageType lastDamage);
    [CompilerGeneratedAttribute]
public bool get_IsBeingSpectated();
    [CompilerGeneratedAttribute]
private void set_IsBeingSpectated(bool value);
    public void SetSpectateTeamInfo(bool state);
    private void Tick_Spectator();
    public void UpdateSpectateTarget(string strName);
    public void UpdateSpectateTarget(ulong id);
    private void SpectatePlayer(BaseEntity target);
    public void StartSpectating();
    public void StopSpectating();
    public void Teleport(BasePlayer player);
    public void Teleport(string strName, bool playersOnly);
    public void Teleport(Vector3 position);
    public void CopyRotation(BasePlayer player);
    protected virtual void OnChildAdded(BaseEntity child);
    protected virtual void OnChildRemoved(BaseEntity child);
    [RPC_Server]
[CallsPerSecond("10")]
[FromOwner]
private void UpdateSpectatePositionFromDebugCamera(RPCMessage msg);
    [RPC_Server]
private void NotifyDebugCameraEnded(RPCMessage msg);
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public void AddNeabyStash(StashContainer newStash);
    public void RemoveNearbyStash(StashContainer stash);
    private void CheckStashRevealInvoke();
    public virtual float GetThreatLevel();
    public void EnsureUpdated();
    public virtual bool IsHostile();
    public virtual float GetHostileDuration();
    public virtual void MarkHostileFor(float duration);
    public void MarkWeaponDrawnDuration(float newDuration);
    public void AddWeaponDrawnDuration(float duration);
    [CompilerGeneratedAttribute]
public InputState get_serverInput();
    [CompilerGeneratedAttribute]
private void set_serverInput(InputState value);
    public float get_timeSinceLastTick();
    public float get_timeSinceLastStall();
    public float get_IdleTime();
    public bool get_isStalled();
    public bool get_wasStalled();
    public void OnReceivedTick(Stream stream);
    public void OnReceivedVoice(Byte[] data);
    public void ResetInputIdleTime();
    private void EACStateUpdate();
    private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled);
    public void UpdateActiveItem(ItemId itemID);
    internal void UpdateModelStateFromTick(PlayerTick tick);
    internal void UpdatePositionFromTick(PlayerTick tick, bool wasPlayerStalled);
    internal void UpdateRotationFromTick(PlayerTick tick);
    public void UpdateEstimatedVelocity(Vector3 lastPos, Vector3 currentPos, float deltaTime);
    [CompilerGeneratedAttribute]
public Vector3 get_tickViewAngles();
    [CompilerGeneratedAttribute]
private void set_tickViewAngles(Vector3 value);
    public int get_tickHistoryCapacity();
    public Matrix4x4 get_tickHistoryMatrix();
    public void FinalizeTick(float deltaTime);
    [CompilerGeneratedAttribute]
public TutorialItemAllowance get_CurrentTutorialAllowance();
    [CompilerGeneratedAttribute]
private void set_CurrentTutorialAllowance(TutorialItemAllowance value);
    public bool IsCraftingTutorialBlocked(ItemDefinition def, Boolean& forceUnlock);
    public bool CanModifyCraftAmountDuringTutorial();
    public TutorialIsland GetCurrentTutorialIsland();
    public void ClearTutorial();
    public void ClearTutorial_PostDeath();
    public void OnStartedTutorial();
    public void SetTutorialAllowance(TutorialItemAllowance newAllowance);
    [RPC_Server]
private void StartTutorial(RPCMessage msg);
    public void StartTutorial(bool triggerAnalytics);
    [CallsPerSecond("1")]
[RPC_Server]
private void PlayerRequestedTutorialStart(RPCMessage msg);
    public UInt32 GetUnderwearSkin();
    [RPC_Server]
public void ServerRPC_UnderwearChange(RPCMessage msg);
    public bool IsWounded();
    public bool IsCrawling();
    public bool IsIncapacitated();
    public float get_TimeSinceWoundedStarted();
    public bool WoundInsteadOfDying(HitInfo info);
    public void ResetWoundingVars();
    public virtual bool EligibleForWounding(HitInfo info);
    public void BecomeWounded(HitInfo info);
    public void StopWounded(BasePlayer source);
    public void ProlongWounding(float delay);
    public void SendWoundedInformation(float timeLeft);
    public float GetRecoveryChance();
    public void WoundingTick();
    public void GoToCrawling(HitInfo info);
    public void GoToIncapacitated(HitInfo info);
    public void WoundedStartSharedCode(HitInfo info);
    public void StartWoundedTick(int minTime, int maxTime);
    public void ApplyWoundedStartTime();
    public void RecoverFromWounded();
    public bool WoundingCausingImmortality(HitInfo info);
    public virtual BasePlayer ToPlayer();
    public Connection get_Connection();
    public bool get_IsBot();
    public PlayerEyes get_eyes();
    public void set_eyes(PlayerEyes value);
    public PlayerInventory get_inventory();
    public CapsuleCollider get_playerCollider();
    public virtual string get_displayName();
    public virtual void set_displayName(string value);
    public static string SanitizePlayerNameString(string playerName, ulong userId);
    public bool IsGod();
    public virtual Quaternion GetNetworkRotation();
    public bool CanInteract();
    public bool CanInteract(bool usableWhileCrawling);
    public virtual float StartHealth();
    public virtual float StartMaxHealth();
    public virtual float MaxHealth();
    public virtual float MaxVelocity();
    public virtual OBB WorldSpaceBounds();
    public Vector3 GetMountVelocity();
    public virtual Vector3 GetInheritedProjectileVelocity(Vector3 direction);
    public virtual Vector3 GetInheritedThrowVelocity(Vector3 direction);
    public virtual Vector3 GetInheritedDropVelocity();
    public virtual void PreInitShared();
    public virtual void DestroyShared();
    public virtual bool InSafeZone();
    public bool IsInNoRespawnZone();
    public bool IsOnATugboat();
    public static void ServerCycle(float deltaTime);
    private bool ManuallyCheckSafezone();
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public Bounds GetBounds(bool ducked);
    public Bounds GetBounds();
    public Vector3 GetCenter(bool ducked);
    public Vector3 GetCenter();
    public Vector3 GetOffset(bool ducked);
    public Vector3 GetOffset();
    public Vector3 GetSize(bool ducked);
    public Vector3 GetSize();
    public float GetHeight(bool ducked);
    public float GetHeight();
    public float GetRadius();
    public float GetJumpHeight();
    public virtual Vector3 TriggerPoint();
    public Vector3 NoClipOffset();
    public float NoClipRadius(float margin);
    public float MaxDeployDistance(Item item);
    public float GetMinSpeed();
    public float GetMaxSpeed();
    public float GetSpeed(float running, float ducking, float crawling);
    public virtual void OnAttacked(HitInfo info);
    public void EnablePlayerCollider();
    public void DisablePlayerCollider();
    public void RefreshColliderSize(bool forced);
    private void SetPlayerRigidbodyState(bool isEnabled);
    public void AddPlayerRigidbody();
    public void RemovePlayerRigidbody();
    public bool IsEnsnared();
    public bool IsAttacking();
    public bool CanAttack();
    public bool OnLadder();
    public bool IsSwimming();
    public bool IsHeadUnderwater();
    public virtual bool IsOnGround();
    public bool IsRunning();
    public bool IsDucked();
    public void ShowToast(Styles style, Phrase phrase, bool overlay, String[] arguments);
    public void ChatMessage(string msg);
    public void ConsoleMessage(string msg);
    public virtual float PenetrationResistance(HitInfo info);
    public virtual void ScaleDamage(HitInfo info);
    public void ResetWeaponMoveSpeedScale();
    private void UpdateMoveSpeedFromClothing();
    public virtual void UpdateProtectionFromClothing();
    public virtual string Categorize();
    public virtual string ToString();
    public string GetDebugStatus();
    public virtual Item GetItem(ItemId itemId);
    public virtual TraitFlag get_Traits();
    public virtual float WaterFactor();
    public virtual float AirFactor();
    public float GetOxygenTime(AirSupplyType& airSupplyType);
    public virtual bool ShouldInheritNetworkGroup();
    public static bool AnyPlayersVisibleToEntity(Vector3 pos, float radius, BaseEntity source, Vector3 entityEyePos, bool ignorePlayersWithPriv);
    public bool IsStandingOnEntity(BaseEntity standingOn, int layerMask);
    public void SetActiveTelephone(PhoneController t);
    public bool get_HasActiveTelephone();
    public bool get_IsDesigningAI();
    public void ClearDesigningAIEntity();
    [CompilerGeneratedAttribute]
private bool <CountWaveTargets>g__CheckPlayer|118_0(BasePlayer player, <>c__DisplayClass118_0& );
    [CompilerGeneratedAttribute]
private bool <FindUnusedPointOfInterestColour>g__HasColour|149_0(int index);
    [CompilerGeneratedAttribute]
private ArraySegment`1<byte> <SaveSecondaryData>g__GetPoolableMugshotData|212_0(PlayerRelationshipInfo relationshipInfo);
    [AsyncStateMachineAttribute("BasePlayer/<<SendRespawnOptions>g__CollectExternalAndSend|425_0>d")]
[CompilerGeneratedAttribute]
private void <SendRespawnOptions>g__CollectExternalAndSend|425_0();
    [CompilerGeneratedAttribute]
private void <SendRespawnOptions>g__SendToPlayer|425_1(List`1<SpawnOptions> spawnOptions, bool loading);
    [CompilerGeneratedAttribute]
internal static float <CreateCorpse>g__GetFloatBasedOnUserID|455_0(ulong steamid, ulong seed);
    [CompilerGeneratedAttribute]
internal static void <OcclusionPlayerFound>g__UpdateVisibility|515_0(BasePlayer src, BasePlayer dst);
    [CompilerGeneratedAttribute]
internal static void <OcclusionPlayerLost>g__UpdateVisibility|516_0(BasePlayer src, BasePlayer dst);
    [CompilerGeneratedAttribute]
private int <ForceRestrainedMountNearest>b__546_0(BaseMountable a, BaseMountable b);
    [CompilerGeneratedAttribute]
private bool <UpdateSpectateTarget>b__602_1(BaseNetworkable x);
    [CompilerGeneratedAttribute]
private bool <UpdateSpectateTarget>b__602_3(BasePlayer x);
    [CompilerGeneratedAttribute]
private bool <UpdateSpectateTarget>b__602_4(BasePlayer x);
}
public class BasePortal : BaseCombatEntity {
    public bool isUsablePortal;
    private Vector3 destination_pos;
    private Quaternion destination_rot;
    public BasePortal targetPortal;
    public NetworkableId targetID;
    public Transform localEntryExitPos;
    public Transform relativeAnchor;
    public bool isMirrored;
    public GameObjectRef appearEffect;
    public GameObjectRef disappearEffect;
    public GameObjectRef transitionSoundEffect;
    public string useTagString;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void ServerInit();
    public void LinkPortal();
    public virtual void PostServerLoad();
    public void SetDestination(Vector3 destPos, Quaternion destRot);
    public Vector3 GetLocalEntryExitPosition();
    public Quaternion GetLocalEntryExitRotation();
    public BasePortal GetPortal();
    public virtual void UsePortal(BasePlayer player);
    [IsVisible("3")]
[RPC_Server]
[CallsPerSecond("1")]
public void RPC_UsePortal(RPCMessage msg);
    public bool IsActive();
}
public class BasePrefab : BaseMonoBehaviour {
    [HideInInspector]
public UInt32 prefabID;
    [HideInInspector]
public bool isClient;
    public bool isServer { get; }
    public bool get_isServer();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class BaseProjectile : AttackEntity {
    [HeaderAttribute("NPC Info")]
public float NoiseRadius;
    [HeaderAttribute("Projectile")]
public float damageScale;
    public float distanceScale;
    public float projectileVelocityScale;
    public bool automatic;
    public bool usableByTurret;
    [TooltipAttribute("Final damage is scaled by this amount before being applied to a target when this weapon is mounted to a turret")]
public float turretDamageScale;
    [HeaderAttribute("Effects")]
public GameObjectRef attackFX;
    public GameObjectRef silencedAttack;
    public GameObjectRef muzzleBrakeAttack;
    public SoundDefinition fireModeSound;
    public Transform MuzzlePoint;
    [HeaderAttribute("Reloading")]
public float reloadTime;
    public bool canUnloadAmmo;
    public Magazine primaryMagazine;
    public bool fractionalReload;
    public float reloadStartDuration;
    public float reloadFractionDuration;
    public float reloadEndDuration;
    public float alternateDryFireRate;
    [HeaderAttribute("Recoil")]
public float aimSway;
    public float aimSwaySpeed;
    public RecoilProperties recoil;
    [HeaderAttribute("Aim Cone")]
public AnimationCurve aimconeCurve;
    public float aimCone;
    public float hipAimCone;
    public float aimconePenaltyPerShot;
    public float aimConePenaltyMax;
    public float aimconePenaltyRecoverTime;
    public float aimconePenaltyRecoverDelay;
    public float stancePenaltyScale;
    [HeaderAttribute("Iconsights")]
public bool hasADS;
    public bool noAimingWhileCycling;
    public bool manualCycle;
    protected bool needsCycle;
    protected bool isCycling;
    public bool aiming;
    [HeaderAttribute("ViewModel")]
public bool useEmptyAmmoState;
    [HeaderAttribute("Burst Information")]
public bool isBurstWeapon;
    public bool canChangeFireModes;
    public bool defaultOn;
    public float internalBurstRecoilScale;
    public float internalBurstFireRateScale;
    public float internalBurstAimConeScale;
    public float resetDuration;
    public int numShotsFired;
    public static float maxDistance;
    private EncryptedValue`1<float> nextReloadTime;
    private EncryptedValue`1<float> startReloadTime;
    private float lastReloadTime;
    private bool modsChangedInitialized;
    private float stancePenalty;
    private float aimconePenalty;
    private UInt32 cachedModHash;
    private float sightAimConeScale;
    private float sightAimConeOffset;
    private float hipAimConeScale;
    private float hipAimConeOffset;
    protected bool reloadStarted;
    protected bool reloadFinished;
    private int fractionalInsertCounter;
    private static Effect reusableInstance;
    public RecoilProperties recoilProperties { get; }
    public bool isSemiAuto { get; }
    public Transform MuzzleTransform { get; }
    public bool IsUsableByTurret { get; }
    protected bool CanRefundAmmo { get; }
    protected ItemDefinition PrimaryMagazineAmmo { get; }
    private static BaseProjectile();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    protected bool TryReload(IAmmoContainer ammoSource, int desiredAmount, bool canRefundAmmo);
    public void SwitchAmmoTypesIfNeeded(IAmmoContainer ammoSource);
    public static void StripAmmoToType(List`1& ammos, ItemDefinition onlyAllowed);
    public void SetAmmoCount(int newCount);
    public void ModifyAmmoCount(int amount);
    public RecoilProperties get_recoilProperties();
    public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction);
    public virtual float GetDamageScale(bool getMax);
    public virtual float GetDistanceScale(bool getMax);
    public virtual float GetProjectileVelocityScale(bool getMax);
    public virtual float GetOverrideProjectileThickness(Projectile projectile);
    protected void StartReloadCooldown(float cooldown);
    protected void ResetReloadCooldown();
    protected bool HasReloadCooldown();
    protected float GetReloadCooldown();
    protected float GetReloadIdle();
    private void OnDrawGizmos();
    public virtual RecoilProperties GetRecoil();
    public bool get_isSemiAuto();
    public virtual Transform get_MuzzleTransform();
    public virtual float AmmoFraction();
    public virtual bool get_IsUsableByTurret();
    public virtual void DidAttackServerside();
    public virtual bool ServerIsReloading();
    public virtual bool CanReload();
    public virtual void TopUpAmmo();
    public virtual void ServerReload();
    public virtual bool ServerTryReload(IAmmoContainer ammoSource);
    public virtual Vector3 ModifyAIAim(Vector3 eulerInput, float swayModifier);
    public float GetAIAimcone();
    public virtual void ServerUse();
    public virtual void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness);
    private void AssignInitiator(HitInfo info);
    public virtual void ServerInit();
    public void DelayedModSetup();
    public virtual void DestroyShared();
    public void ModsChanged(Item item, bool added);
    public void ForceModsChanged();
    public void DelayedModsChanged();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    public void UnloadAmmo(Item item, BasePlayer player);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter);
    public virtual void SetLightsOn(bool isOn);
    public void UpdateAttachmentsState();
    private bool ShouldLightsBeOn();
    protected virtual void OnChildRemoved(BaseEntity child);
    public bool CanAiAttack();
    public virtual float GetAimCone();
    public float ScaleRepeatDelay(float delay);
    public Modifier GetProjectileModifier();
    public bool UsingBurstMode();
    public bool UsingInternalBurstMode();
    public bool IsBurstEligable();
    public float TimeBetweenBursts();
    public virtual bool CanAttack();
    public float GetReloadDuration();
    public int GetAvailableAmmo();
    public bool IsBurstDisabled();
    [RPC_Server]
[IsActiveItem]
[CallsPerSecond("2")]
private void ToggleFireMode(RPCMessage msg);
    public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount);
    [RPC_Server]
[IsActiveItem]
private void SwitchAmmoTo(RPCMessage msg);
    public virtual void OnHeldChanged();
    [RPC_Server]
[IsActiveItem]
private void StartReload(RPCMessage msg);
    protected virtual void OnReloadStarted();
    protected virtual bool get_CanRefundAmmo();
    [RPC_Server]
[IsActiveItem]
private void ServerFractionalReloadInsert(RPCMessage msg);
    [IsActiveItem]
[RPC_Server]
private void Reload(RPCMessage msg);
    [IsActiveItem]
[FromOwner]
[RPC_Server]
private void CLProject(RPCMessage msg);
    protected virtual ItemDefinition get_PrimaryMagazineAmmo();
    public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects, List`1<Connection> targets);
    public void UpdateItemCondition();
    public bool IsSilenced();
    public string GetAttackEffectAdditive();
    protected string GetAttackEffect();
    public virtual bool CanUseNetworkCache(Connection sendingTo);
    public virtual void Save(SaveInfo info);
    public virtual bool ForceSendMagazine(SaveInfo saveInfo);
    public virtual void Load(LoadInfo info);
}
public class BaseResourceExtractor : BaseCombatEntity {
    public bool canExtractLiquid;
    public bool canExtractSolid;
    public virtual void ServerInit();
}
public class BaseRidableAnimal : BaseVehicle {
    public ItemDefinition onlyAllowedItem;
    public ContentsType allowedContents;
    public int maxStackSize;
    public int numStorageSlots;
    public int equipmentSlots;
    public string lootPanelName;
    public string storagePanelName;
    public bool needsBuildingPrivilegeToUse;
    public bool isLootable;
    public ItemContainer storageInventory;
    public ItemContainer equipmentInventory;
    public static Flags Flag_ForSale;
    public Phrase SingleHorseTitle;
    public Phrase SingleHorseDescription;
    public Phrase DoubleHorseTitle;
    public Phrase DoubleHorseDescription;
    private Vector3 lastMoveDirection;
    public GameObjectRef saddlePrefab;
    public EntityRef saddleRef;
    public Transform movementLOSOrigin;
    public SoundPlayer sprintSounds;
    public SoundPlayer largeWhinny;
    public static Flags Flag_Lead;
    public static Flags Flag_HasRider;
    [HeaderAttribute("Purchase")]
public List`1<PurchaseOption> PurchaseOptions;
    public ItemDefinition purchaseToken;
    public GameObjectRef eatEffect;
    public GameObjectRef CorpsePrefab;
    [HeaderAttribute("Obstacles")]
public Transform animalFront;
    public Transform animalNeck;
    public Transform animalRear;
    public Transform animalHead;
    public float obstacleDetectionRadius;
    public float obstacleHeadDetectionRadius;
    public float maxWaterDepth;
    public float roadSpeedBonus;
    public float maxWallClimbSlope;
    public float maxStepHeight;
    public float maxStepDownHeight;
    [HeaderAttribute("Movement")]
public RunState currentRunState;
    public float walkSpeed;
    public float trotSpeed;
    public float runSpeed;
    public float turnSpeed;
    public float maxSpeed;
    public Transform[] groundSampleOffsets;
    [HeaderAttribute("Dung")]
public ItemDefinition Dung;
    public float CaloriesToDigestPerHour;
    public float DungProducedPerCalorie;
    private float pendingDungCalories;
    private float dungProduction;
    protected float prevStamina;
    protected float prevMaxStamina;
    protected int prevRunState;
    protected float prevMaxSpeed;
    [HeaderAttribute("Stamina")]
public float staminaSeconds;
    public float currentMaxStaminaSeconds;
    public float maxStaminaSeconds;
    public float staminaCoreLossRatio;
    public float staminaCoreSpeedBonus;
    public float staminaReplenishRatioMoving;
    public float staminaReplenishRatioStanding;
    public float calorieToStaminaRatio;
    public float hydrationToStaminaRatio;
    public float maxStaminaCoreFromWater;
    public bool debugMovement;
    private static float normalOffsetDist;
    private Vector3[] normalOffsets;
    [ServerVar]
public static float decayminutes;
    public float currentSpeed;
    public float desiredRotation;
    public float animalPitchClamp;
    public float animalRollClamp;
    public static Queue`1<BaseRidableAnimal> _processQueue;
    [HelpAttribute("How many miliseconds to budget for processing ridable animals per frame")]
[ServerVar]
public static float framebudgetms;
    [ServerVar]
[HelpAttribute("Scale all ridable animal dung production rates by this value. 0 will disable dung production.")]
public static float dungTimeScale;
    private BaseEntity leadTarget;
    public float nextDecayTime;
    private float lastMovementUpdateTime;
    private bool inQueue;
    protected float nextEatTime;
    public float lastEatTime;
    public float lastInputTime;
    private float forwardHeldSeconds;
    private float backwardHeldSeconds;
    private float sprintHeldSeconds;
    private float noHeldSeconds;
    private float lastSprintPressedTime;
    private float lastForwardPressedTime;
    private float lastBackwardPressedTime;
    private float timeInMoveState;
    protected bool onIdealTerrain;
    private float nextIdealTerrainCheckTime;
    private float nextStandTime;
    private InputState aiInputState;
    public Vector3 currentVelocity;
    private Vector3 averagedUp;
    private float nextGroundNormalUpdateTime;
    private Vector3 targetUp;
    private float nextObstacleCheckTime;
    private float cachedObstacleDistance;
    private static int maxObstacleCheckSpeed;
    private float timeAlive;
    private TimeUntil dropUntilTime;
    public bool IsNpc { get; }
    private static BaseRidableAnimal();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsForSale();
    public void ContainerServerInit();
    private void CreateInventories(bool giveUID);
    private void ReleaseInventories();
    private void CreateEquipmentInventory(bool giveUID);
    private void CreateStorageInventory(bool giveUID);
    private ItemContainer CreateInventory(bool giveUID, int slots);
    public void SaveContainer(SaveInfo info);
    public virtual void OnInventoryDirty();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public bool ItemFilter(Item item, int targetSlot);
    public virtual bool CanAnimalAcceptItem(Item item, int targetSlot);
    [RPC_Server]
[IsVisible("3")]
private void RPC_OpenLoot(RPCMessage rpc);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual bool CanOpenStorage(BasePlayer player);
    public void LoadContainer(LoadInfo info);
    public float GetBreathingDelay();
    public bool IsLeading();
    public static float UnitsToKPH(float unitsPerSecond);
    public virtual bool get_IsNpc();
    public static void ProcessQueue();
    public void SetLeading(BaseEntity newLeadTarget);
    public virtual float GetNetworkTime();
    public virtual void Save(SaveInfo info);
    private void OnPhysicsNeighbourChanged();
    public void DelayedDropToGround();
    public virtual void Load(LoadInfo info);
    public virtual bool HasValidSaddle();
    public virtual bool HasSeatAvailable();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public virtual void LeadingChanged();
    [RPC_Server]
[IsVisible("3")]
public void RPC_Claim(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_Lead(RPCMessage msg);
    public virtual void OnClaimedWithToken(Item tokenItem);
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public void SetDecayActive(bool isActive);
    public float TimeUntilNextDecay();
    public void AddDecayDelay(float amount);
    public virtual void Hurt(HitInfo info);
    public void AnimalDecay();
    public void UseStamina(float amount);
    public bool CanInitiateSprint();
    public bool CanSprint();
    public void ReplenishStamina(float amount);
    public virtual float ReplenishRatio();
    public void ReplenishStaminaCore(float calories, float hydration);
    public void UpdateStamina(float delta);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void DismountHeavyPlayers();
    public BaseMountable GetSaddle();
    public void BudgetedUpdate();
    public void ApplyDungCalories(float calories);
    private void UpdateDung(float delta);
    private void DoDung();
    public virtual void VehicleFixedUpdate();
    public float StaminaCoreFraction();
    public void DoEatEvent();
    public void ReplenishFromFood(ItemModConsumable consumable);
    public virtual void EatNearbyFood();
    public void SwitchMoveState(RunState newState);
    public void UpdateOnIdealTerrain();
    public float MoveStateToVelocity(RunState stateToCheck);
    public float GetDesiredVelocity();
    public RunState StateFromSpeed(float speedToUse);
    public void ModifyRunState(int dir);
    public bool CanStand();
    public virtual bool IsStandCollisionClear();
    public void DoDebugMovement();
    public virtual void RiderInput(InputState inputState, BasePlayer player);
    public virtual float MaxVelocity();
    private float NormalizeAngle(float angle);
    public void UpdateGroundNormal(bool force);
    public void MarkObstacleDistanceDirty();
    public float GetObstacleDistance();
    public float ObstacleDistanceCheck(float speed);
    public virtual void MarkDistanceTravelled(float amount);
    public void UpdateMovement(float delta);
    public bool DropToGround(Vector3 targetPos, bool force);
    public virtual void DoNetworkUpdate();
    public virtual void PreServerLoad();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void OnKilled(HitInfo hitInfo);
    public virtual void SetupCorpse(BaseCorpse corpse);
    public virtual Vector3 GetLocalVelocityServer();
    public void UpdateDropToGroundForDuration(float duration);
    public virtual void InitShared();
    public bool PlayerHasToken(BasePlayer player, int tokenItemID);
    public Item GetPurchaseToken(BasePlayer player, int tokenItemID);
    public virtual float GetWalkSpeed();
    public virtual float GetTrotSpeed();
    public virtual float GetRunSpeed();
    public bool IsPlayerTooHeavy(BasePlayer player);
}
public class BaseSaddle : BaseMountable {
    public BaseRidableAnimal animal;
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void SetAnimal(BaseRidableAnimal newAnimal);
}
public abstract class BaseScreenShake : MonoBehaviour {
    public static List`1<BaseScreenShake> list;
    internal static float punchFadeScale;
    internal static float bobScale;
    internal static float animPunchMagnitude;
    internal static AnimationCurve InverseCurve;
    public float length;
    internal float timeTaken;
    private int currentFrame;
    private static BaseScreenShake();
    public static void Apply(Camera cam, BaseViewModel vm);
    protected void OnEnable();
    protected void OnDisable();
    public void Run(CachedTransform`1& cam, CachedTransform`1& vm);
    public abstract virtual void Setup();
    public abstract virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
public class BaseScriptableObject : ScriptableObject {
    [HideInInspector]
public UInt32 FilenameStringId;
    public string LookupFileName();
    public static bool op_Equality(BaseScriptableObject a, BaseScriptableObject b);
    public static bool op_Inequality(BaseScriptableObject a, BaseScriptableObject b);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public abstract class BaseSpawnPoint : MonoBehaviour {
    public SpawnPointType spawnPointType;
    [SerializeField]
[RangeAttribute("1", "25")]
[TooltipAttribute("Min distance between the spawn area and any human players")]
protected float playerCheckMargin;
    public static Dictionary`2<SpawnPointType, List`1<BaseSpawnPoint>> spawnPoints;
    private static BaseSpawnPoint();
    public abstract virtual void GetLocation(Vector3& pos, Quaternion& rot);
    public abstract virtual void ObjectSpawned(SpawnPointInstance instance);
    public abstract virtual void ObjectRetired(SpawnPointInstance instance);
    protected void OnEnable();
    protected void OnDisable();
    public virtual bool IsAvailableTo(GameObject prefab);
    public virtual bool HasPlayersIntersecting();
    protected void DropToGround(Vector3& pos, Quaternion& rot);
}
public class BaseStateUI : MonoBehaviour {
    public Dropdown DropdownInputMemorySlot;
    public Transform PrefabAddNewEvent;
    public Transform PrefabTimerEvent;
    public Transform PrefabPlayerDetectedEvent;
    public Transform PrefabStateErrorEvent;
    public Transform PrefabStateFinishedEvent;
    public Transform PrefabAttackedEvent;
    public Transform PrefabInAttackRangeEvent;
    public Transform PrefabHealthBelowEvent;
    public Transform PrefabInRangeEvent;
    public Transform PrefabPerformedAttackEvent;
    public Transform PrefabTirednessAboveEvent;
    public Transform PrefabHungerAboveEvent;
    public Transform PrefabThreatDetectevEvent;
    public Transform PrefabTargetDetectevEvent;
    public Transform PrefabAmmoBelowEvent;
    public Transform PrefabBestTargetDetectedEvent;
    public Transform PrefabIsVisibleEvent;
    public Transform PrefabAttackTickEvent;
    public Transform PrefabIsMountedEvent;
    public Transform PrefabAndEvent;
    public Transform PrefabChanceEvent;
    public Transform PrefabTargetLostEvent;
    public Transform PrefabTimeSinceThreatEvent;
    public Transform PrefabOnPositionMemorySetEvent;
    public Transform PrefabAggressionTimerEvent;
    public Transform PrefabReloadingEvent;
    public Transform PrefabInRangeOfHomeEvent;
    public Transform PrefabIsBlindedEvent;
    public RustText TextStateName;
    public Transform EventContainer;
    public ScrollRect Scroll;
}
public class BaseSubmarine : BaseVehicle {
    [HeaderAttribute("Submarine Main")]
[SerializeField]
private Transform centreOfMassTransform;
    [SerializeField]
public Buoyancy buoyancy;
    [SerializeField]
public float maxRudderAngle;
    [SerializeField]
private Transform rudderVisualTransform;
    [SerializeField]
private Transform rudderDetailedColliderTransform;
    [SerializeField]
private Transform propellerTransform;
    [SerializeField]
public float timeUntilAutoSurface;
    [SerializeField]
private Renderer[] interiorRenderers;
    [SerializeField]
private SonarObject sonarObject;
    [SerializeField]
private GameObjectRef fuelStoragePrefab;
    [HeaderAttribute("Submarine Engine & Fuel")]
[SerializeField]
public float engineKW;
    [SerializeField]
public float turnPower;
    [SerializeField]
public float engineStartupTime;
    [SerializeField]
private GameObjectRef itemStoragePrefab;
    [SerializeField]
public float depthChangeTargetSpeed;
    [SerializeField]
public float idleFuelPerSec;
    [SerializeField]
public float maxFuelPerSec;
    [FormerlySerializedAsAttribute("internalAccessFuelTank")]
[SerializeField]
private bool internalAccessStorage;
    [HeaderAttribute("Submarine Weaponry")]
[SerializeField]
public GameObjectRef torpedoStoragePrefab;
    [SerializeField]
public Transform torpedoFiringPoint;
    [FormerlySerializedAsAttribute("maxFireRate")]
[SerializeField]
public float reloadTime;
    [HeaderAttribute("Submarine Audio & FX")]
[SerializeField]
protected SubmarineAudio submarineAudio;
    [SerializeField]
private ParticleSystem fxTorpedoFire;
    [SerializeField]
private GameObject internalFXContainer;
    [SerializeField]
private GameObject internalOnFXContainer;
    [SerializeField]
private ParticleSystem fxIntAmbientBubbleLoop;
    [SerializeField]
private ParticleSystem fxIntInitialDiveBubbles;
    [SerializeField]
private ParticleSystem fxIntWaterDropSpray;
    [SerializeField]
private ParticleSystem fxIntWindowFilm;
    [SerializeField]
private ParticleSystemContainer fxIntMediumDamage;
    [SerializeField]
private ParticleSystemContainer fxIntHeavyDamage;
    [SerializeField]
private GameObject externalFXContainer;
    [SerializeField]
private GameObject externalOnFXContainer;
    [SerializeField]
private ParticleSystem fxExtAmbientBubbleLoop;
    [SerializeField]
private ParticleSystem fxExtInitialDiveBubbles;
    [SerializeField]
private ParticleSystem fxExtAboveWaterEngineThrustForward;
    [SerializeField]
private ParticleSystem fxExtAboveWaterEngineThrustReverse;
    [SerializeField]
private ParticleSystem fxExtUnderWaterEngineThrustForward;
    [SerializeField]
private ParticleSystem[] fxExtUnderWaterEngineThrustForwardSubs;
    [SerializeField]
private ParticleSystem fxExtUnderWaterEngineThrustReverse;
    [SerializeField]
private ParticleSystem[] fxExtUnderWaterEngineThrustReverseSubs;
    [SerializeField]
private ParticleSystem fxExtBowWave;
    [SerializeField]
private ParticleSystem fxExtWakeEffect;
    [SerializeField]
public GameObjectRef aboveWatercollisionEffect;
    [SerializeField]
public GameObjectRef underWatercollisionEffect;
    [SerializeField]
private VolumetricLightBeam spotlightVolumetrics;
    [SerializeField]
private float mountedAlphaInside;
    [SerializeField]
private float mountedAlphaOutside;
    [ServerVar]
public static float outsidedecayminutes;
    [ServerVar]
public static float deepwaterdecayminutes;
    [ServerVar]
public static float oxygenminutes;
    [CompilerGeneratedAttribute]
private Vector3 <Velocity>k__BackingField;
    public static Flags Flag_Ammo;
    private float _throttle;
    private float _rudder;
    private float _upDown;
    private float _oxygen;
    public VehicleEngineController`1<BaseSubmarine> engineController;
    public float cachedFuelAmount;
    protected Vector3 steerAngle;
    public float waterSurfaceY;
    public float curSubDepthY;
    public EntityRef`1<StorageContainer> torpedoStorageInstance;
    private EntityRef`1<StorageContainer> itemStorageInstance;
    public int waterLayerMask;
    public float targetClimbSpeed;
    public float maxDamageThisTick;
    private float nextCollisionDamageTime;
    private bool prevPrimaryFireInput;
    private bool primaryFireInput;
    private static float DECAY_TICK_TIME;
    public TimeSince timeSinceLastUsed;
    public TimeSince timeSinceTorpedoFired;
    private TimeSince timeSinceFailRPCSent;
    private float normalDrag;
    private float highDrag;
    private bool wasOnSurface;
    public AirSupplyType AirType { get; }
    public EngineState<BaseSubmarine> EngineState { get; }
    public Vector3 Velocity { get; private set; }
    public bool LightsAreOn { get; }
    public bool HasAmmo { get; }
    public float ThrottleInput { get; protected set; }
    public float RudderInput { get; protected set; }
    public float UpDownInput { get; protected set; }
    public float Oxygen { get; protected set; }
    protected float PhysicalRudderAngle { get; }
    protected bool IsInWater { get; }
    protected bool IsSurfaced { get; }
    private static BaseSubmarine();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual AirSupplyType get_AirType();
    public EngineState<BaseSubmarine> get_EngineState();
    [CompilerGeneratedAttribute]
public Vector3 get_Velocity();
    [CompilerGeneratedAttribute]
private void set_Velocity(Vector3 value);
    public bool get_LightsAreOn();
    public bool get_HasAmmo();
    public float get_ThrottleInput();
    protected void set_ThrottleInput(float value);
    public float get_RudderInput();
    protected void set_RudderInput(float value);
    public float get_UpDownInput();
    protected void set_UpDownInput(float value);
    public float get_Oxygen();
    protected void set_Oxygen(float value);
    protected float get_PhysicalRudderAngle();
    protected bool get_IsInWater();
    protected bool get_IsSurfaced();
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    public virtual float AirFactor();
    public virtual bool BlocksWaterFor(BasePlayer player);
    public float GetFuelAmount();
    public virtual float GetSpeed();
    public virtual bool CanBeLooted(BasePlayer player);
    public sealed virtual float GetAirTimeRemaining();
    protected virtual bool CanPushNow(BasePlayer pusher);
    private void UpdatePhysicalRudder(float turnInput, float deltaTime);
    private bool CanMount(BasePlayer player);
    private void UpdateWaterInfo();
    private float GetWaterSurfaceY();
    public virtual void ServerInit();
    protected virtual void OnChildAdded(BaseEntity child);
    private void ServerFlagsChanged(Flags old, Flags next);
    internal virtual void DoServerDestroy();
    protected void OnCollisionEnter(Collision collision);
    public virtual float MaxVelocity();
    public virtual IFuelSystem GetFuelSystem();
    public virtual int StartingFuelUnits();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public sealed virtual void OnPoolDestroyed();
    public sealed virtual void WakeUp();
    protected virtual void OnServerWake();
    public virtual void OnKilled(HitInfo info);
    public virtual void VehicleFixedUpdate();
    public virtual void LightToggle(BasePlayer player);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void Save(SaveInfo info);
    public sealed virtual bool MeetsEngineRequirements();
    public sealed virtual void OnEngineStartFailed();
    public StorageContainer GetTorpedoContainer();
    public StorageContainer GetItemContainer();
    private void ProcessCollision(Collision collision);
    public void UpdateClients();
    public void SubmarineDecay();
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void RPC_OpenTorpedoStorage(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_OpenItemStorage(RPCMessage msg);
    public void OnSurfacedInMoonpool();
    private sealed virtual override void IEngineControllerUser.Invoke(Action action, float time);
    private sealed virtual override void IEngineControllerUser.CancelInvoke(Action action);
}
public class BaseTrap : DecayEntity {
    public virtual void ObjectEntered(GameObject obj);
    public virtual void Arm();
    public virtual void OnEmpty();
}
public class BaseTrapTrigger : TriggerBase {
    public BaseTrap _trap;
    public virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnObjectAdded(GameObject obj, Collider col);
    public virtual void OnEmpty();
}
public class BaseVehicle : BaseMountable {
    [HeaderAttribute("Base Vehicle")]
[TooltipAttribute("Allow players to mount other mountables/ladders from this vehicle")]
public bool mountChaining;
    public bool checkVehicleClipping;
    public LayerMask excludeCollisionLayers;
    public DismountStyle dismountStyle;
    public bool shouldShowHudHealth;
    public bool ignoreDamageFromOutside;
    [HeaderAttribute("Base Vehicle - Mount Points")]
public List`1<MountPointInfo> mountPoints;
    public RagdollMode mountedPlayerRagdolls;
    public ClippingCheckMode clippingChecks;
    [HeaderAttribute("Base Vehicle - Damage")]
public DamageRenderer damageRenderer;
    [FormerlySerializedAsAttribute("explosionDamageMultiplier")]
public float explosionForceMultiplier;
    public float explosionForceMax;
    public static Flags Flag_OnlyOwnerEntry;
    public static Flags Flag_Headlights;
    public static Flags Flag_Stationary;
    public static Flags Flag_SeatsFull;
    protected static Flags Flag_AnyMounted;
    private List`1<BaseVehicle> childVehicles;
    private static float MIN_TIME_BETWEEN_PUSHES;
    public TimeSince timeSinceLastPush;
    private bool prevSleeping;
    private float nextCollisionFXTime;
    private CollisionDetectionMode savedCollisionDetectionMode;
    private BaseVehicle pendingLoad;
    public Queue`1<BasePlayer> recentDrivers;
    public Action clearRecentDriverAction;
    public float safeAreaRadius;
    public Vector3 safeAreaOrigin;
    public float spawnTime;
    public bool IsMovingOrOn { get; }
    public float RealisticMass { get; }
    public Enumerable allMountPoints { get; }
    public bool IsClient { get; }
    public bool AlwaysAllowBradleyTargeting { get; }
    protected bool RecentlyPushed { get; }
    protected bool PositionTickFixedTime { get; }
    protected bool CanSwapSeats { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsStationary();
    public bool IsMoving();
    public bool get_IsMovingOrOn();
    public virtual float get_RealisticMass();
    public bool IsAuthed(BasePlayer player);
    public virtual bool AnyMounted();
    public virtual bool PlayerIsMounted(BasePlayer player);
    public virtual bool CanPushNow(BasePlayer pusher);
    public bool HasMountPoints();
    public virtual bool CanBeLooted(BasePlayer player);
    public bool IsFlipped();
    public virtual bool IsVehicleRoot();
    public virtual bool DirectlyMountable();
    public virtual BaseVehicle VehicleParent();
    protected virtual void OnChildAdded(BaseEntity child);
    protected virtual void OnChildRemoved(BaseEntity child);
    public Enumerable get_allMountPoints();
    public MountPointInfo GetMountPoint(int index);
    public virtual float GetSpeed();
    public sealed virtual bool get_IsClient();
    public virtual bool get_AlwaysAllowBradleyTargeting();
    protected bool get_RecentlyPushed();
    public virtual void OnAttacked(HitInfo info);
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual float GetNetworkTime();
    protected virtual bool get_PositionTickFixedTime();
    public virtual void VehicleFixedUpdate();
    protected virtual int GetClipCheckMask();
    protected virtual bool DetermineIfStationary();
    public virtual Vector3 GetLocalVelocityServer();
    public virtual Quaternion GetAngularVelocityServer();
    public virtual int StartingFuelUnits();
    public virtual bool IsSeatVisible(BaseMountable mountable, Vector3 eyePos, int mask);
    protected virtual bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction);
    public virtual void CheckSeatsForClipping();
    public virtual void SeatClippedWorld(BaseMountable mountable);
    public virtual void MounteeTookDamage(BasePlayer mountee, HitInfo info);
    public virtual void DismountAllPlayers();
    public virtual void ServerInit();
    public virtual void SpawnSubEntities();
    public virtual bool AdminFixUp(int tier);
    private void OnPhysicsNeighbourChanged();
    private void CheckAndSpawnMountPoints();
    public virtual void Spawn();
    public virtual void Hurt(HitInfo info);
    public void DoExplosionForce(HitInfo info);
    public int NumMounted();
    public virtual int MaxMounted();
    public bool HasDriver();
    public bool IsDriver(BasePlayer player);
    public bool HasPassenger();
    public bool IsPassenger(BasePlayer player);
    public BasePlayer GetDriver();
    public BasePlayer GetPassenger();
    public void GetDrivers(List`1<BasePlayer> drivers);
    public void GetMountedPlayers(List`1<BasePlayer> players);
    public sealed virtual BasePlayer GetPlayerDamageInitiator();
    public int GetPlayerSeat(BasePlayer player);
    public MountPointInfo GetPlayerSeatInfo(BasePlayer player);
    public bool IsVehicleMountPoint(BaseMountable bm);
    protected virtual bool get_CanSwapSeats();
    public virtual bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool forcingRestrainedPlayer);
    public void SwapSeats(BasePlayer player, int targetSeat, bool forcingRestrainedPlayer);
    public virtual int NumSwappableSeats();
    public bool HasDriverMountPoints();
    public bool OnlyOwnerAccessible();
    public sealed virtual bool IsDespawnEligable();
    public sealed virtual void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);
    public void ClearOwnerEntry();
    private void DisableTransferProtectionIfEmpty();
    public virtual IFuelSystem GetFuelSystem();
    public bool IsSafe();
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public BaseMountable GetIdealMountPoint(Vector3 eyePos, Vector3 pos, BasePlayer playerFor);
    public virtual bool MountEligable(BasePlayer player);
    public int GetIndexFromSeat(BaseMountable seat);
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public virtual void PrePlayerDismount(BasePlayer player, BaseMountable seat);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public void TryShowCollisionFX(Collision collision, GameObjectRef effectGO);
    public void TryShowCollisionFX(Vector3 contactPoint, GameObjectRef effectGO);
    public void SetToKinematic();
    public void SetToNonKinematic();
    public virtual void UpdateMountFlags();
    public void ClearRecentDriver();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public BaseMountable GetIdealMountPointFor(BasePlayer player);
    public virtual bool GetDismountPosition(BasePlayer player, Vector3& res);
    public BaseMountable SpawnMountPoint(MountPointInfo mountToSpawn, Model model);
    [RPC_Server]
[MaxDistance("5")]
public void RPC_WantsPush(RPCMessage msg);
    public virtual void DoPushAction(BasePlayer player);
    protected virtual void OnServerWake();
    protected virtual void OnServerSleep();
    public virtual bool ShouldDisableTransferProtectionOnLoad(BasePlayer player);
    public virtual void DisableTransferProtection();
    public virtual bool AllowPlayerInstigatedDismount(BasePlayer player);
}
public class BaseVehicleModule : BaseVehicle {
    [SerializeField]
[HeaderAttribute("Vehicle Module")]
private Transform centreOfMassTransform;
    [SerializeField]
private float mass;
    public VisualGroup visualGroup;
    [SerializeField]
[HideInInspector]
private VehicleLight[] lights;
    [CompilerGeneratedAttribute]
private BaseModularVehicle <Vehicle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstSocketIndex>k__BackingField;
    public LODLevel[] lodRenderers;
    [SerializeField]
[HideInInspector]
private List`1<ConditionalObject> conditionals;
    [HeaderAttribute("Trigger Parent")]
[SerializeField]
private TriggerParent[] triggerParents;
    [SerializeField]
[HeaderAttribute("Sliding Components")]
private VehicleModuleSlidingComponent[] slidingComponents;
    [SerializeField]
private VehicleModuleButtonComponent[] buttonComponents;
    private TimeSince TimeSinceAddedToVehicle;
    private float prevRefreshHealth;
    private bool prevRefreshVehicleIsDead;
    private bool prevRefreshVehicleIsLockable;
    public Item AssociatedItemInstance;
    [CompilerGeneratedAttribute]
private bool <PropagateDamage>k__BackingField;
    private TimeSince timeSinceItemLockRefresh;
    private static float TIME_BETWEEN_LOCK_REFRESH;
    public BaseModularVehicle Vehicle { get; private set; }
    public int FirstSocketIndex { get; private set; }
    public Vector3 CentreOfMass { get; }
    public float Mass { get; }
    public NetworkableId ID { get; }
    public bool IsOnAVehicle { get; }
    public ItemDefinition AssociatedItemDef { get; }
    public bool HasSeating { get; }
    public bool HasAnEngine { get; }
    public bool PropagateDamage { get; private set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public BaseModularVehicle get_Vehicle();
    [CompilerGeneratedAttribute]
private void set_Vehicle(BaseModularVehicle value);
    [CompilerGeneratedAttribute]
public int get_FirstSocketIndex();
    [CompilerGeneratedAttribute]
private void set_FirstSocketIndex(int value);
    public Vector3 get_CentreOfMass();
    public float get_Mass();
    public NetworkableId get_ID();
    public bool get_IsOnAVehicle();
    public ItemDefinition get_AssociatedItemDef();
    public virtual bool get_HasSeating();
    public virtual bool get_HasAnEngine();
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void RefreshParameters();
    public virtual BaseVehicle VehicleParent();
    public virtual void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex);
    public virtual void ModuleRemoved();
    public void OtherVehicleModulesChanged();
    public virtual bool CanBeLooted(BasePlayer player);
    public bool KeycodeEntryBlocked(BasePlayer player);
    public virtual void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState);
    public virtual float MaxHealth();
    public virtual float StartHealth();
    public int GetNumSocketsTaken();
    public List`1<ConditionalObject> GetConditionals();
    public virtual float GetMaxDriveForce();
    public void RefreshConditionals(bool canGib);
    protected virtual void PostConditionalRefresh();
    private void RefreshConditional(ConditionalObject conditional, bool canGib);
    private bool TryGetAdjacentModuleInFront(BaseVehicleModule& result);
    private bool TryGetAdjacentModuleBehind(BaseVehicleModule& result);
    private bool InSameVisualGroupAs(BaseVehicleModule moduleEntity, AdjacentMatchType matchType);
    private bool CanBeUsedNowBy(BasePlayer player);
    public bool PlayerIsLookingAtUsable(string lookingAtColldierName, string usableColliderName);
    public virtual void Load(LoadInfo info);
    public virtual bool IsVehicleRoot();
    [CompilerGeneratedAttribute]
public bool get_PropagateDamage();
    [CompilerGeneratedAttribute]
private void set_PropagateDamage(bool value);
    public virtual void VehicleFixedUpdate();
    public virtual void Hurt(HitInfo info);
    public virtual void OnHealthChanged(float oldValue, float newValue);
    public bool CanBeMovedNow();
    protected virtual bool CanBeMovedNowOnVehicle();
    public virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public void AcceptPropagatedDamage(float amount, DamageType type, BaseEntity attacker, bool useProtection);
    public virtual void Die(HitInfo info);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Use(RPCMessage msg);
    public virtual void AdminKill();
    public virtual bool AdminFixUp(int tier);
    public virtual void OnPlayerDismountedVehicle(BasePlayer player);
    public virtual void Save(SaveInfo info);
}
public class BaseVehicleMountPoint : BaseMountable {
    public virtual bool DirectlyMountable();
    public virtual BaseVehicle VehicleParent();
    public virtual bool BlocksWaterFor(BasePlayer player);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    public virtual float AirFactor();
}
public class BaseVehicleSeat : BaseVehicleMountPoint {
    [HeaderAttribute("Vehicle Seat")]
public float mountedAnimationSpeed;
    public bool sendClientInputToVehicleParent;
    public bool forcePlayerModelUpdate;
    public bool giveCrosshair;
    public bool canTeamInteract;
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public virtual void MounteeTookDamage(BasePlayer mountee, HitInfo info);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void LightToggle(BasePlayer player);
    public virtual void SwitchParent(BaseEntity ent);
    public virtual Vector3 GetMountRagdollVelocity(BasePlayer player);
}
public class BaseViewModel : FacepunchBehaviour {
    [HeaderAttribute("BaseViewModel")]
public LazyAimProperties lazyaimRegular;
    public LazyAimProperties lazyaimIronsights;
    public Transform pivot;
    public bool useViewModelCamera;
    public bool wantsHeldItemFlags;
    public GameObject[] hideSightMeshes;
    public bool isGestureViewModel;
    public Transform MuzzlePoint;
    [HeaderAttribute("Skin")]
public SubsurfaceProfile subsurfaceProfile;
    [HideInInspector]
public List`1<SkinnedMeshRenderer> baseSkinPieces;
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class BasicCar : BaseVehicle {
    public VehicleWheel[] wheels;
    public float brakePedal;
    public float gasPedal;
    public float steering;
    public Transform centerOfMass;
    public Transform steeringWheel;
    public float motorForceConstant;
    public float brakeForceConstant;
    public float GasLerpTime;
    public float SteeringLerpTime;
    public Transform driverEye;
    public GameObjectRef chairRef;
    public Transform chairAnchorTest;
    public SoundPlayer idleLoopPlayer;
    public Transform engineOffset;
    public SoundDefinition engineSoundDef;
    private static bool chairtest;
    public float throttle;
    public float brake;
    public bool lightsOn;
    public virtual float MaxVelocity();
    public virtual Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot);
    public virtual void ServerInit();
    public void SpawnChairTest();
    public virtual void VehicleFixedUpdate();
    public void DoSteering();
    public void ConvertInputToThrottle();
    public void ApplyForceAtWheels();
    public void NoDriverInput();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void DriverInput(InputState inputState, BasePlayer player);
    public virtual void LightToggle(BasePlayer player);
}
public class BasicZoneController : ZoneController {
    public BasicZoneController(NexusZoneClient zoneClient);
    public virtual string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone);
    private void GetStarterZones(List`1<NexusZoneDetails> zones);
}
public static class BatchingToggleEx : object {
}
public class Bear : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Bear();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public class BearTrap : BaseTrap {
    protected Animator animator;
    private GameObject hurtTarget;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool Armed();
    public virtual void InitShared();
    public virtual bool CanPickup(BasePlayer player);
    public virtual void ServerInit();
    public virtual void Arm();
    public void Fire();
    public virtual void ObjectEntered(GameObject obj);
    public void DelayedFire();
    public void RadialResetCorpses(float duration);
    public virtual void OnAttacked(HitInfo info);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_Arm(RPCMessage rpc);
    public virtual void Load(LoadInfo info);
}
public class BearTrapTrigger : BaseTrapTrigger {
}
public class BeltBarIcon : MonoBehaviour {
    public RustText TextBind;
    public string bind;
}
public class BenchmarkInfo : SingletonComponent`1<BenchmarkInfo> {
    public static string BenchmarkTitle;
    public static string BenchmarkSubtitle;
    public TextMeshProUGUI PerformanceText;
    public TextMeshProUGUI SystemInfoText;
    private StringBuilder sb;
    private RealTimeSince timeSinceUpdated;
    private void Start();
    private void Update();
}
public class BenchmarkScene : MonoBehaviour {
    public string BenchmarkTitle;
    public string BenchmarkIdent;
    public int MaxNumberOfFrames;
    public int MaxNumberOfSeconds;
}
public class BestTargetDetectedAIEvent : BaseAIEvent {
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class BestTargetDetectedEventUI : BaseEventUI {
}
public static class Bezier : object {
    public static void ApplyLineSlack(Vector3[]& positions, Single[] slackLevels, int tesselationLevel, Transform referenceTransform);
    public static void ApplyLineSlack(Vector3[] positions, Single[] slackLevels, Vector3[]& result, int tesselationLevel, Transform referenceTransform);
    public static void ApplyLineSlack(Vector3[] positions, Single[] slackLevels, List`1& result, int tesselationLevel, Transform referenceTransform);
}
public class BicycleAudio : BikeVehicleAudio {
    [HeaderAttribute("Bicycle")]
[SerializeField]
private SoundDefinition pedalActiveSoundDef;
    [SerializeField]
private SoundDefinition pedalCoastSoundDef;
    [SerializeField]
private SoundDefinition pedalStartDef;
    [SerializeField]
private SoundDefinition pedalStopDef;
    [SerializeField]
private SoundDefinition bellSoundDef;
    [SerializeField]
private AnimationCurve pedalGainCurve;
    [SerializeField]
private AnimationCurve pedalPitchCurve;
    [SerializeField]
private SlicedGranularAudioClip pedalClicks;
    [SerializeField]
private AnimationCurve pedalClickFrequencyCurve;
}
public class BigWheelBettingTerminal : StorageContainer {
    public BigWheelGame bigWheel;
    public Vector3 seatedPlayerOffset;
    public float offsetCheckRadius;
    public SoundDefinition winSound;
    public SoundDefinition loseSound;
    public BasePlayer lastPlayer;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsPlayerValid(BasePlayer player);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public bool TrySetBigWheel(BigWheelGame newWheel);
}
public class BigWheelGame : SpinnerWheel {
    public float baseSpeed;
    public float offset;
    public AnimationCurve decelerationCurve;
    public AnimationCurve speedCurve;
    public HitNumber[] hitNumbers;
    private float targetAngle;
    private float minimumSpinTime;
    private bool isSpinning;
    private bool decelerating;
    private float elapsedTime;
    private Random random;
    [ServerVar]
public static float spinFrequencySeconds;
    public int spinNumber;
    protected int targetNumber;
    public int lastPaidSpinNumber;
    public List`1<BigWheelBettingTerminal> terminals;
    private static BigWheelGame();
    public virtual bool AllowPlayerSpins();
    public virtual bool CanUpdateSign(BasePlayer player);
    public virtual void ServerInit();
    public void DoSpin();
    public void SetTerminalsLocked(bool isLocked);
    public void RemoveTerminal(BigWheelBettingTerminal terminal);
    public void InitBettingTerminals();
    public float GetMaxSpinSpeed(float time);
    public virtual void Update_Server();
    private float NormalizeAngle(float angle);
    public float SpinSpacing();
    public void QueueSpin();
    public void Payout();
    public HitNumber GetCurrentHitType();
}
public class Bike : GroundVehicle {
    public static Phrase sprintPhrase;
    public static Phrase boostPhrase;
    [HeaderAttribute("Bike")]
[SerializeField]
private Transform centreOfMassTransform;
    [SerializeField]
private VisualCarWheel wheelFront;
    [SerializeField]
private VisualCarWheel wheelRear;
    [SerializeField]
private VisualCarWheel wheelExtra;
    [SerializeField]
public bool snowmobileDrivingStyle;
    [SerializeField]
public CarSettings carSettings;
    [SerializeField]
public int engineKW;
    [SerializeField]
public float idleFuelPerSec;
    [SerializeField]
public float maxFuelPerSec;
    [SerializeField]
[RangeAttribute("0", "1")]
private float pitchStabP;
    [SerializeField]
[RangeAttribute("0", "1")]
private float pitchStabD;
    [SerializeField]
[RangeAttribute("0", "1")]
private float twoWheelRollStabP;
    [SerializeField]
[RangeAttribute("0", "1")]
private float twoWheelRollStabD;
    [SerializeField]
[RangeAttribute("1", "500")]
private float manyWheelStabP;
    [SerializeField]
[RangeAttribute("1", "100")]
private float manyWheelStabD;
    [SerializeField]
[RangeAttribute("0", "1")]
public float airControlTorquePower;
    public float sprintTime;
    [SerializeField]
public float sprintRegenTime;
    [SerializeField]
public float sprintBoostPercent;
    [SerializeField]
private ProtectionProperties riderProtection;
    [SerializeField]
private float hurtTriggerMinSpeed;
    [SerializeField]
private TriggerHurtNotChild hurtTriggerFront;
    [SerializeField]
private TriggerHurtNotChild hurtTriggerRear;
    [SerializeField]
private float maxLeanSpeed;
    [SerializeField]
private float leftMaxLean;
    [SerializeField]
private float rightMaxLean;
    [SerializeField]
private float midairRotationForce;
    [SerializeField]
private Vector3 customInertiaTensor;
    public PoweredBy poweredBy;
    [RangeAttribute("0", "1")]
[SerializeField]
public float percentFood;
    [SerializeField]
public float playerDamageThreshold;
    [SerializeField]
public float playerDeathThreshold;
    [SerializeField]
private bool hasBell;
    [HeaderAttribute("Bike Visuals")]
public float minGroundFXSpeed;
    [SerializeField]
private BikeChassisVisuals chassisVisuals;
    [SerializeField]
private VehicleLight[] lights;
    [SerializeField]
private ParticleSystemContainer exhaustFX;
    [SerializeField]
private Transform steeringLeftIK;
    [SerializeField]
private Transform steeringRightIK;
    [SerializeField]
private Transform steeringRightIKAcclerating;
    [SerializeField]
private Transform leftFootIK;
    [SerializeField]
private Transform rightFootIK;
    [SerializeField]
private Transform passengerLeftHandIK;
    [SerializeField]
private Transform passengerRightHandIK;
    [SerializeField]
private Transform passengerLeftFootIK;
    [SerializeField]
private Transform passengerRightFootIK;
    [SerializeField]
private ParticleSystemContainer fxMediumDamage;
    [SerializeField]
private GameObject fxMediumDamageInstLight;
    [SerializeField]
private ParticleSystemContainer fxHeavyDamage;
    [SerializeField]
private GameObject fxHeavyDamageInstLight;
    [SerializeField]
[HeaderAttribute("Sidecar")]
private Rigidbody sidecarRigidBody;
    [SerializeField]
private Transform sidecarPhysicsHinge;
    [ServerVar]
public static float outsideDecayMinutes;
    [ServerVar]
public static float pedalRoadsidePopulation;
    [SerializeField]
private Transform realSidecarCapsule;
    [ServerVar]
public static float pedalMonumentPopulation;
    [SerializeField]
private Transform duplicateSidecarCapsule;
    [ServerVar]
public static float motorbikeMonumentPopulation;
    [ServerVar]
public static bool doPlayerDamage;
    private bool hasExtraWheel;
    public bool hasSidecar;
    private bool hasDamageFX;
    private float _throttle;
    private float _brake;
    public static Flags Flag_SprintInput;
    public static Flags Flag_DuckInput;
    public static Flags Flag_IsSprinting;
    [CompilerGeneratedAttribute]
private float <SprintPercentRemaining>k__BackingField;
    private float _mass;
    private float cachedFuelFraction;
    private static float FORCE_MULTIPLIER;
    private float _steer;
    public CarPhysics`1<Bike> carPhysics;
    private VehicleTerrainHandler serverTerrainHandler;
    private CarWheel[] wheels;
    public TimeSince timeSinceLastUsed;
    private static float DECAY_TICK_TIME;
    private float prevPitchStabError;
    private float prevRollStabError;
    private float prevRollStabRoll;
    public float lastCrashDamage;
    private TimeSince timeSinceBellDing;
    private bool wasWantingSlopeSprint;
    private bool inBurnoutMode;
    private bool shouldBypassClippingChecks;
    public float ThrottleInput { get; protected set; }
    public float BrakeInput { get; protected set; }
    public bool IsBraking { get; }
    public bool SprintInput { get; private set; }
    public bool DuckInput { get; private set; }
    public bool CanSprint { get; }
    public bool IsSprinting { get; private set; }
    public float SprintPercentRemaining { get; protected set; }
    public float SteerAngle { get; }
    public float DriveWheelVelocity { get; }
    public float DriveWheelSlip { get; }
    public float SidecarAngle { get; }
    public float MaxSteerAngle { get; }
    private float Mass { get; }
    public float SteerInput { get; protected set; }
    public Surface OnSurface { get; }
    private static Bike();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public float get_ThrottleInput();
    protected void set_ThrottleInput(float value);
    public float get_BrakeInput();
    protected void set_BrakeInput(float value);
    public bool get_IsBraking();
    public bool get_SprintInput();
    private void set_SprintInput(bool value);
    public bool get_DuckInput();
    private void set_DuckInput(bool value);
    public bool get_CanSprint();
    public bool get_IsSprinting();
    private void set_IsSprinting(bool value);
    [CompilerGeneratedAttribute]
public float get_SprintPercentRemaining();
    [CompilerGeneratedAttribute]
protected void set_SprintPercentRemaining(float value);
    public sealed virtual float get_SteerAngle();
    public virtual float get_DriveWheelVelocity();
    public float get_DriveWheelSlip();
    public float get_SidecarAngle();
    public sealed virtual float get_MaxSteerAngle();
    private float get_Mass();
    public virtual void PreInitShared();
    public virtual void Load(LoadInfo info);
    public sealed virtual float GetMaxDriveForce();
    public virtual float GetMaxForwardSpeed();
    public virtual float GetThrottleInput();
    public virtual float GetBrakeInput();
    public float GetPerformanceFraction();
    public float GetFuelFraction();
    public virtual bool CanBeLooted(BasePlayer player);
    protected virtual IFuelSystem CreateFuelSystem();
    public float get_SteerInput();
    protected void set_SteerInput(float value);
    public sealed virtual Surface get_OnSurface();
    public sealed virtual float GetSteerInput();
    public virtual void ServerInit();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public virtual void VehicleFixedUpdate();
    protected virtual void AwakeBikePhysicsTick(float speed);
    private void PDPitchStab();
    private void PDDirectionStab();
    private void PDRollStab(float speed);
    private float AngleDifference(float a, float b);
    private void StabiliseSnowmobileStyle();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public sealed virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public sealed virtual bool GetSteerSpeedMod(float speed);
    public virtual float GetSteerMaxMult(float speed);
    public virtual float MaxVelocity();
    public sealed virtual CarWheel[] GetWheels();
    public sealed virtual float GetWheelsMidPos();
    public virtual void Save(SaveInfo info);
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    public virtual void SeatClippedWorld(BaseMountable mountable);
    public virtual void DoCollisionDamage(BaseEntity hitEntity, float damage);
    public virtual Vector3 GetMountRagdollVelocity(BasePlayer player);
    public virtual int StartingFuelUnits();
    public virtual bool MeetsEngineRequirements();
    public void BikeDecay();
    public virtual float GetModifiedDrag();
    private void UpdateClients();
    public virtual void SendClientRPC(byte throttleAndBrake);
    public virtual void OnEngineStartFailed();
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    private bool WantsSprint(float speed);
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
}
public class BikeChassisVisuals : VehicleChassisVisuals`1<Bike> {
    [SerializeField]
private SuspensionSettings suspension;
    [SerializeField]
private PedalBikeSettings pedals;
    [SerializeField]
private KickstandSettiongs kickstand;
    [SerializeField]
private BikeVehicleAudio audioScript;
    [SerializeField]
private ChainRenderer[] chainRenderers;
    [SerializeField]
private float chainSpeedMultiplier;
    [SerializeField]
private Animator animator;
    [SerializeField]
private float minGroundFXSpeed;
}
public class BikeDriverSeat : BikeSeat {
    [SerializeField]
private Vector3 sprintPosOffset;
}
public class BikeSeat : MouseSteerableSeat {
    [SerializeField]
private Transform eyePosRef;
}
public class BikeVehicleAudio : GroundVehicleAudio {
    [HeaderAttribute("Engine")]
[SerializeField]
private EngineAudioSet engineAudioSet;
    [HeaderAttribute("Suspension")]
[SerializeField]
private SoundDefinition suspensionDef;
    [SerializeField]
private float suspensionMinExtensionDelta;
    [SerializeField]
private float suspensionMinTimeBetweenSounds;
    [SerializeField]
[HeaderAttribute("Tires")]
private SoundDefinition tireDirtSoundDef;
    [SerializeField]
private SoundDefinition tireGrassSoundDef;
    [SerializeField]
private SoundDefinition tireSnowSoundDef;
    [SerializeField]
private SoundDefinition tireWaterSoundDef;
    [SerializeField]
private AnimationCurve tireGainCurve;
    [HeaderAttribute("Skid")]
[SerializeField]
private SoundDefinition skidSoundLoop;
    [SerializeField]
private SoundDefinition skidSoundDirtLoop;
    [SerializeField]
private SoundDefinition skidSoundSnowLoop;
    [SerializeField]
private float skidMinSlip;
    [SerializeField]
private float skidMaxSlip;
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Renderer")]
public class BindRendererBounds : MonoBehaviour {
}
[ExecuteInEditMode]
public class BindSubsurfaceProfile : MonoBehaviour {
    public SubsurfaceProfile subsurfaceProfile;
}
public class Binocular : AttackEntity {
    public Single[] fovs;
    public GameObjectRef fovChangeEffect;
    public float smoothSpeed;
    public GameObjectRef rangePrefab;
}
public class BiomeVisuals : MonoBehaviour {
    public GameObject Arid;
    public GameObject Temperate;
    public GameObject Tundra;
    public GameObject Arctic;
    public bool OverrideBiome;
    public Enum ToOverride;
    [HorizontalAttribute("2", "-1")]
public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;
    protected void Start();
    private void SetChoice(GameObject selection);
    private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy);
}
public class BirthdayBalloonHandler : MonoBehaviour {
    public float checkOffset;
    public float checkRadius;
}
public class BlackjackMachine : BaseCardGameEntity {
    [HeaderAttribute("Blackjack Machine")]
[SerializeField]
private GameObjectRef mainScreenPrefab;
    [SerializeField]
private GameObjectRef smallScreenPrefab;
    [SerializeField]
private Transform mainScreenParent;
    [SerializeField]
private Transform[] smallScreenParents;
    private static int _maxbet;
    private BlackjackController controller;
    private BlackjackMainScreenUI mainScreenUI;
    private BlackjackSmallScreenUI[] smallScreenUIs;
    [ServerVar]
public static int maxbet { get; public set; }
    protected float MaxStorageInteractionDist { get; }
    private static BlackjackMachine();
    public static int get_maxbet();
    public static void set_maxbet(int value);
    protected virtual float get_MaxStorageInteractionDist();
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual void PlayerStorageChanged();
}
public class BlackjackMainScreenUI : FacepunchBehaviour {
    [SerializeField]
private Canvas inGameDisplay;
    [SerializeField]
private Canvas notInGameDisplay;
    [SerializeField]
private Sprite faceNeutral;
    [SerializeField]
private Sprite faceShocked;
    [SerializeField]
private Sprite faceSad;
    [SerializeField]
private Sprite faceCool;
    [SerializeField]
private Sprite faceHappy;
    [SerializeField]
private Sprite faceLove;
    [SerializeField]
private Image faceInGame;
    [SerializeField]
private Image faceNotInGame;
    [SerializeField]
private Sprite[] faceNeutralVariants;
    [SerializeField]
private Sprite[] faceHalloweenVariants;
    [SerializeField]
private RustText cardCountText;
    [SerializeField]
private RustText payoutText;
    [SerializeField]
private RustText insuranceText;
    [SerializeField]
private Canvas placeBetsCanvas;
    [SerializeField]
private HorizontalLayoutGroup cardsLayout;
    [SerializeField]
private BlackjackScreenCardUI[] cards;
    [SerializeField]
private Phrase phraseBust;
}
public class BlackjackScreenCardUI : FacepunchBehaviour {
    [SerializeField]
private Canvas baseCanvas;
    [SerializeField]
private Canvas cardFront;
    [SerializeField]
private Canvas cardBack;
    [SerializeField]
private Image image;
    [SerializeField]
private RustText text;
    [SerializeField]
private Sprite heartSprite;
    [SerializeField]
private Sprite diamondSprite;
    [SerializeField]
private Sprite spadeSprite;
    [SerializeField]
private Sprite clubSprite;
}
public class BlackjackScreenInputUI : MonoBehaviour {
    [SerializeField]
private Canvas availableOption;
    [SerializeField]
private Canvas unavailableOption;
    [SerializeField]
private RustText availableOptionText;
}
public class BlackjackSmallScreenUI : FacepunchBehaviour {
    [SerializeField]
private Canvas notInGameDisplay;
    [SerializeField]
private Canvas inGameDisplay;
    [SerializeField]
private RustText cardCountText;
    [SerializeField]
private RustText betText;
    [SerializeField]
private RustText splitBetText;
    [SerializeField]
private RustText insuranceText;
    [SerializeField]
private RustText bankText;
    [SerializeField]
private RustText splitText;
    [SerializeField]
private Canvas infoTextCanvas;
    [SerializeField]
private RustText inGameText;
    [SerializeField]
private RustText notInGameText;
    [SerializeField]
private HorizontalLayoutGroup cardsLayout;
    [SerializeField]
private BlackjackScreenCardUI[] cards;
    [SerializeField]
private BlackjackScreenInputUI[] inputs;
    [SerializeField]
private Phrase phraseBust;
    [SerializeField]
private Phrase phraseBet;
    [SerializeField]
private Phrase phrasePlaceYourBet;
    [SerializeField]
private Phrase phraseStandoff;
    [SerializeField]
private Phrase phraseYouWin;
    [SerializeField]
private Phrase phraseYouLose;
    [SerializeField]
private Phrase phraseWaitingForOtherPlayers;
    [SerializeField]
private Phrase phraseAddFunds;
    [SerializeField]
private Phrase phraseWaitingForPlayer;
    [SerializeField]
private Phrase phraseSplitStored;
    [SerializeField]
private Phrase phraseSplitActive;
    [SerializeField]
private Phrase phraseHand;
}
public class BlackjackUI : MonoBehaviour {
    [SerializeField]
private Image[] playerCardImages;
    [SerializeField]
private Image[] dealerCardImages;
    [SerializeField]
private Image[] splitCardImages;
    [SerializeField]
private Image[] playerCardBackings;
    [SerializeField]
private Image[] dealerCardBackings;
    [SerializeField]
private Image[] splitCardBackings;
    [SerializeField]
private CardGamePlayerWidget[] playerWidgets;
    [SerializeField]
private GameObject dealerValueObj;
    [SerializeField]
private RustText dealerValueText;
    [SerializeField]
private GameObject yourValueObj;
    [SerializeField]
private RustText yourValueText;
    [SerializeField]
private Phrase phrasePlaceYourBet;
    [SerializeField]
private Phrase phraseHit;
    [SerializeField]
private Phrase phraseStand;
    [SerializeField]
private Phrase phraseSplit;
    [SerializeField]
private Phrase phraseDouble;
    [SerializeField]
private Phrase phraseInsurance;
    [SerializeField]
private Phrase phraseBust;
    [SerializeField]
private Phrase phraseBlackjack;
    [SerializeField]
private Phrase phraseStandoff;
    [SerializeField]
private Phrase phraseYouWin;
    [SerializeField]
private Phrase phraseYouLose;
    [SerializeField]
private Phrase phraseWaitingForOtherPlayers;
    [SerializeField]
private Phrase phraseHand;
    [SerializeField]
private Phrase phraseInsurancePaidOut;
    [SerializeField]
private Sprite insuranceIcon;
    [SerializeField]
private Sprite noIcon;
    [SerializeField]
private Color bustTextColour;
}
[CreateAssetMenuAttribute]
public class BlendedEngineLoopDefinition : ScriptableObject {
    public EngineLoopDefinition[] engineLoops;
    public float minRPM;
    public float maxRPM;
    public float RPMChangeRateUp;
    public float RPMChangeRateDown;
}
public class BlendedLoopEngineSound : MonoBehaviour {
    public BlendedEngineLoopDefinition loopDefinition;
    public bool engineOn;
    [RangeAttribute("0", "1")]
public float RPMControl;
    public float smoothedRPMControl;
    private EngineLoop[] engineLoops;
    public bool debugPlayImmediately;
    public float maxDistance { get; }
    public EngineLoop[] GetEngineLoops();
    public float GetLoopGain(int idx);
    public float GetLoopPitch(int idx);
    public float get_maxDistance();
}
public class BlendedSoundLoops : MonoBehaviour {
    [RangeAttribute("0", "1")]
public float blend;
    public float blendSmoothing;
    public float loopFadeOutTime;
    public float loopFadeInTime;
    public float gainModSmoothing;
    public float pitchModSmoothing;
    public bool shouldPlay;
    public float gain;
    public List`1<Loop> loops;
    public float maxDistance;
}
public class BlendedSoundLoopSpeedControl : MonoBehaviour {
    public BlendedSoundLoops loops;
    public float speed;
    public float speedMax;
}
public enum BlendModeType : Enum {
    public int value__;
    public static BlendModeType Screen;
    public static BlendModeType Add;
}
public class BlendModeTypeParameter : ParameterOverride`1<BlendModeType> {
}
public class BlendShapeController : MonoBehaviour {
    public SkinnedMeshRenderer TargetRenderer;
    public BlendState[] States;
    public float LerpSpeed;
    public BlendMode CurrentMode;
}
public class BlendTexture : ProcessedTexture {
    public BlendTexture(int width, int height, bool linear);
    public void Blend(Texture source, Texture target, float alpha);
    public void CopyTo(BlendTexture target);
}
public class BlueprintButton : MonoBehaviour {
    public Image image;
    public Image imageFavourite;
    public Button button;
    public CanvasGroup group;
    public GameObject newNotification;
    public GameObject lockedOverlay;
    public Tooltip Tip;
    public Image FavouriteIcon;
    public PingWidget TutorialHighlight;
}
public class BlueprintCategoryButton : MonoBehaviour {
    public TextMeshProUGUI amountLabel;
    public ItemCategory Category;
    public bool AlwaysShow;
    public bool ShowItemCount;
    public GameObject BackgroundHighlight;
    public SoundDefinition clickSound;
    public SoundDefinition hoverSound;
    public PingWidget tutorialHighlight;
}
public class BlueprintCraftGridRow : MonoBehaviour {
    public CanvasGroup canvasGroup;
    public RustText amountText;
    public RustText itemNameText;
    public RustText totalText;
    public RustText haveText;
    public Color colorOK;
    public Color colorBad;
}
public class BlueprintHeader : MonoBehaviour {
    public Text categoryName;
    public Text unlockCount;
    public void Setup(ItemCategory name, int unlocked, int total);
}
public class BlueprintInformationPanel : ItemInformationPanel {
    public GameObject LearnedRoot;
    public GameObject NotLearnedRoot;
    public GameObject NotLearnableRoot;
}
public class BlunderbussViewmodel : MonoBehaviour {
    public Animator TargetAnimator;
    public float ShotsLeftSpeed;
    public int HammerLayer;
}
public class BlurManager : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
[PostProcessAttribute("BlurOptimizedRenderer", "2", "Custom/BlurOptimized", "True")]
public class BlurOptimized : PostProcessEffectSettings {
    [RangeAttribute("0", "2")]
public FixedIntParameter downsample;
    [RangeAttribute("1", "4")]
public FixedIntParameter blurIterations;
    [RangeAttribute("0", "10")]
public FloatParameter blurSize;
    public FloatParameter fadeToBlurDistance;
    public BlurTypeParameter blurType;
}
public class BlurOptimizedRenderer : PostProcessEffectRenderer`1<BlurOptimized> {
    private int dataProperty;
    private Shader blurShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class BlurTexture : ProcessedTexture {
    public BlurTexture(int width, int height, bool linear);
    public void Blur(float radius);
    public void Blur(Texture source, float radius);
}
public enum BlurType : Enum {
    public int value__;
    public static BlurType StandardGauss;
    public static BlurType SgxGauss;
}
public class BlurTypeParameter : ParameterOverride`1<BlurType> {
}
public class Boar : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Boar();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public class BobberPreview : MonoBehaviour {
    public Material ValidMaterial;
    public Material InvalidMaterial;
    public MeshRenderer TargetRenderer;
}
public class BoneDictionary : object {
    public Transform transform;
    public Transform[] transforms;
    public String[] names;
    private Dictionary`2<string, Transform> nameDict;
    private Dictionary`2<UInt32, Transform> hashDict;
    private Dictionary`2<Transform, UInt32> transformDict;
    public int Count { get; }
    public BoneDictionary(Transform rootBone);
    public BoneDictionary(Transform rootBone, Transform[] boneTransforms, String[] boneNames);
    public int get_Count();
    private void BuildBoneDictionary();
    public Transform FindBone(string name, bool defaultToRoot);
    public Transform FindBone(UInt32 hash, bool defaultToRoot);
    public UInt32 FindBoneID(Transform transform);
}
public class BonePropertyAttribute : PropertyAttribute {
}
public class BoneRetarget : MonoBehaviour {
    public bool preserveInFirstPerson;
    public bool restoreBeforePooling;
}
public class BoomBox : EntityComponent`1<BaseEntity> {
    public AudioSource SoundSource;
    public float ConditionLossRate;
    public ItemDefinition[] ValidCassettes;
    public SoundDefinition PlaySfx;
    public SoundDefinition StopSfx;
    public static Flags HasCassette;
    [ServerVar]
public static int BacktrackLength;
    public Action`1<float> HurtCallback;
    public static Dictionary`2<string, string> ValidStations;
    public static Dictionary`2<string, string> ServerValidStations;
    [ReplicatedVar]
public static string ServerUrlList;
    public static string lastParsedServerList;
    public ShoutcastStreamer ShoutcastStreamer;
    public GameObjectRef RadioIpDialog;
    [CompilerGeneratedAttribute]
private string <CurrentRadioIp>k__BackingField;
    public ulong AssignedRadioBy;
    public BaseEntity BaseEntity { get; }
    private bool isClient { get; }
    public string CurrentRadioIp { get; public set; }
    private static BoomBox();
    [ServerVar]
public static void ClearRadioByUser(Arg arg);
    public BaseEntity get_BaseEntity();
    public void ServerTogglePlay(RPCMessage msg);
    public void DeductCondition();
    public void ServerTogglePlay(bool play);
    public void OnCassetteInserted(Cassette c);
    public void OnCassetteRemoved(Cassette c);
    public bool IsPowered();
    public bool IsOn();
    public bool HasFlag(Flags f);
    public void SetFlag(Flags f, bool state);
    private bool get_isClient();
    public static void LoadStations();
    public static Dictionary`2<string, string> GetStationData();
    public static bool IsStationValid(string url);
    public static void ParseServerUrlList();
    [CompilerGeneratedAttribute]
public string get_CurrentRadioIp();
    [CompilerGeneratedAttribute]
public void set_CurrentRadioIp(string value);
    public void Server_UpdateRadioIP(RPCMessage msg);
    public void Save(SaveInfo info);
    public bool ClearRadioByUserId(ulong id);
    public void Load(LoadInfo info);
}
public class Bootstrap : SingletonComponent`1<Bootstrap> {
    internal static bool bootstrapInitRun;
    public static bool isErrored;
    public string messageString;
    public CanvasGroup BootstrapUiCanvas;
    public GameObject errorPanel;
    public TextMeshProUGUI errorText;
    public TextMeshProUGUI statusText;
    private static string lastWrittenValue;
    public static bool needsSetup { get; }
    public static bool isPresent { get; }
    public static bool get_needsSetup();
    public static bool get_isPresent();
    public static void RunDefaults();
    public static void Init_Tier0();
    public static void Init_Systems();
    public static void Init_Config();
    public static void NetworkInitRaknet();
    public static void NetworkInitSteamworks(bool enableSteamDatagramRelay);
    [IteratorStateMachineAttribute("Bootstrap/<Start>d__17")]
private IEnumerator Start();
    [IteratorStateMachineAttribute("Bootstrap/<DedicatedServerStartup>d__18")]
private IEnumerator DedicatedServerStartup();
    private static void EnsureRootFolderCreated();
    [IteratorStateMachineAttribute("Bootstrap/<StartNexusServer>d__20")]
public static IEnumerator StartNexusServer();
    [IteratorStateMachineAttribute("Bootstrap/<StartServer>d__21")]
public static IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves);
    private void StartupShared();
    public void ThrowError(string error);
    public void ExitGame();
    [IteratorStateMachineAttribute("Bootstrap/<LoadingUpdate>d__25")]
public static IEnumerator LoadingUpdate(string str);
    public static void WriteToLog(string str);
    private static void EarlyInitialize();
    [ConditionalAttribute("DEVELOPMENT_BUILD")]
private static void EncryptionSmokeTest();
    [CompilerGeneratedAttribute]
internal static void <EncryptionSmokeTest>g__TestEncryption|29_0(T value);
}
public class BossFormController : ArcadeEntityController {
    public float animationSpeed;
    public Sprite[] animationFrames;
    public Vector2 roamDistance;
    public Transform colliderParent;
    public BossDamagePoint[] damagePoints;
    public ArcadeEntityController flashController;
    public float health;
}
public class BoundsCheck : PrefabAttribute {
    public BlockType IsType;
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class BoundsCheckEx : object {
    [ExtensionAttribute]
public static bool ApplyBoundsChecks(BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer);
}
[ExtensionAttribute]
public static class BoundsEx : object {
    private static Vector3[] pts;
    private static BoundsEx();
    [ExtensionAttribute]
public static Bounds XZ3D(Bounds bounds);
    [ExtensionAttribute]
public static Bounds Transform(Bounds bounds, Matrix4x4 matrix);
    [ExtensionAttribute]
public static Rect ToScreenRect(Bounds b, Camera cam);
    [ExtensionAttribute]
public static Rect ToCanvasRect(Bounds b, RectTransform target, Camera cam);
    [ExtensionAttribute]
public static float InnerDistToEdge2D(Bounds b, Vector3 point);
    [ExtensionAttribute]
public static float MaxExtent(Bounds b);
}
public class BowWeapon : BaseProjectile {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsActiveItem]
[RPC_Server]
private void BowReload(RPCMessage msg);
    public virtual bool ForceSendMagazine(SaveInfo saveInfo);
}
public class BoxStorage : StorageContainer {
    public virtual Vector3 GetDropPosition();
    public virtual bool SupportsChildDeployables();
    public virtual bool CanPickup(BasePlayer player);
}
public class BradleyAPC : BaseCombatEntity {
    [HeaderAttribute("Sound")]
public BlendedLoopEngineSound engineSound;
    public SoundDefinition treadLoopDef;
    public AnimationCurve treadGainCurve;
    public AnimationCurve treadPitchCurve;
    public AnimationCurve treadFreqCurve;
    private Sound treadLoop;
    private Modulator treadGain;
    private Modulator treadPitch;
    public SoundDefinition chasisLurchSoundDef;
    public float chasisLurchAngleDelta;
    public float chasisLurchSpeedDelta;
    public float lastAngle;
    public float lastSpeed;
    public SoundDefinition turretTurnLoopDef;
    public float turretLoopGainSpeed;
    public float turretLoopPitchSpeed;
    public float turretLoopMinAngleDelta;
    public float turretLoopMaxAngleDelta;
    public float turretLoopPitchMin;
    public float turretLoopPitchMax;
    public float turretLoopGainThreshold;
    private Sound turretTurnLoop;
    private Modulator turretTurnLoopGain;
    private Modulator turretTurnLoopPitch;
    public float enginePitch;
    public float rpmMultiplier;
    private TreadAnimator treadAnimator;
    [HeaderAttribute("Wheels")]
public WheelCollider[] leftWheels;
    public WheelCollider[] rightWheels;
    [HeaderAttribute("Movement Config")]
public float moveForceMax;
    public float brakeForce;
    public float turnForce;
    public float sideStiffnessMax;
    public float sideStiffnessMin;
    public Transform centerOfMass;
    public float stoppingDist;
    [HeaderAttribute("Control")]
public float throttle;
    public float turning;
    public float rightThrottle;
    public float leftThrottle;
    public bool brake;
    [HeaderAttribute("Other")]
public Rigidbody myRigidBody;
    public Collider myCollider;
    public Vector3 destination;
    public Vector3 finalDestination;
    public Transform followTest;
    public TriggerHurtEx impactDamager;
    [HeaderAttribute("Weapons")]
public Transform mainTurretEyePos;
    public Transform mainTurret;
    public Transform CannonPitch;
    public Transform CannonMuzzle;
    public Transform coaxPitch;
    public Transform coaxMuzzle;
    public Transform topTurretEyePos;
    public Transform topTurretYaw;
    public Transform topTurretPitch;
    public Transform topTurretMuzzle;
    public GameObjectRef SmokeGrenadePrefab;
    public Vector3 turretAimVector;
    public Vector3 desiredAimVector;
    public Vector3 topTurretAimVector;
    public Vector3 desiredTopTurretAimVector;
    [HeaderAttribute("Effects")]
public GameObjectRef explosionEffect;
    public GameObjectRef servergibs;
    public GameObjectRef fireBall;
    public GameObjectRef crateToDrop;
    public GameObjectRef debrisFieldMarker;
    [HeaderAttribute("Loot")]
public int maxCratesToSpawn;
    [HeaderAttribute("Spline")]
public float splineMovementSpeed;
    public Vector3 splineOffset;
    [HeaderAttribute("Other")]
public int patrolPathIndex;
    public IAIPath patrolPath;
    public bool DoAI;
    public GameObjectRef mainCannonMuzzleFlash;
    public GameObjectRef mainCannonProjectile;
    public float recoilScale;
    public NavMeshPath navMeshPath;
    public int navMeshPathIndex;
    private SimpleSplineTranslator splineTranslator;
    private LayerMask obstacleHitMask;
    private TimeSince timeSinceSeemingStuck;
    private TimeSince timeSinceStuckReverseStart;
    private static string prefabPath;
    public float nextFireTime;
    public int numBursted;
    public float nextPatrolTime;
    public float nextEngagementPathTime;
    public float currentSpeedZoneLimit;
    [HeaderAttribute("Pathing")]
public List`1<Vector3> currentPath;
    public int currentPathIndex;
    public bool pathLooping;
    private bool followingSpine;
    private int splineId;
    private WorldSpline spline;
    private int entryDirection;
    private TimeSince lastJoinedSpline;
    [HeaderAttribute("Scientists")]
public GameObject AIRoot;
    public GameObjectRef MonumentScientistPrefab;
    public GameObjectRef RoadScientistPrefab;
    public int ScientistSpawnCount;
    public float ScientistSpawnRadius;
    public List`1<GameObject> ScientistSpawnPoints;
    public List`1<ScientistSpawnGroup> ScientistSpawns;
    public bool SetScientistChaseBasedOnWeapon;
    [ServerVar]
public static float DeployHealthRangeMin;
    [ServerVar]
public static float DeployHealthRangeMax;
    [ServerVar]
public static float DeployAttackDistanceMax;
    [ServerVar]
public static float DeployInterval;
    [ServerVar]
public static float DeployOnDamageCheckInterval;
    [ServerVar]
public static float ScientistRedeploymentMinInterval;
    [ServerVar]
public static float MountAfterNotAttackedDuration;
    [ServerVar]
public static float MountAfterNotTargetsDuration;
    [ServerVar]
public static float MountAfterNotFiredDuration;
    [ServerVar]
public static bool UseSmokeGrenades;
    [ServerVar]
public static bool KillScientistsOnBradleyDeath;
    [HideInInspector]
public bool RoadSpawned;
    private List`1<ScientistNPC> activeScientists;
    private List`1<GameObjectRef> mountedScientistPrefabs;
    private List`1<Vector3> scientistSpawnPositions;
    private int numberOfScientistsToSpawn;
    private TimeSince timeSinceScientistDeploy;
    private TimeSince timeSinceDeployCheck;
    private TimeSince timeSinceValidTarget;
    private TimeSince deployedTimeSinceBradleyAttackedTarget;
    private static int walkableAreaMask;
    private bool mountingScientists;
    private bool inDeployedState;
    private bool deployingScientists;
    private Dictionary`2<UInt32, GameObjectRef> scientistPrefabLookUp;
    [HeaderAttribute("Targeting")]
public float viewDistance;
    public float searchRange;
    public float searchFrequency;
    public float memoryDuration;
    public static float sightUpdateRate;
    public List`1<TargetInfo> targetList;
    public BaseCombatEntity mainGunTarget;
    [HeaderAttribute("Coax")]
public float coaxFireRate;
    public int coaxBurstLength;
    public float coaxAimCone;
    public float bulletDamage;
    [HeaderAttribute("TopTurret")]
public float topTurretFireRate;
    public float nextCoaxTime;
    public int numCoaxBursted;
    public float nextTopTurretTime;
    public GameObjectRef gun_fire_effect;
    public GameObjectRef bulletEffect;
    public float lastLateUpdate;
    protected float PositionTickRate { get; }
    private static BradleyAPC();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public void BuildingCheck();
    public virtual void Save(SaveInfo info);
    public static BradleyAPC SpawnRoadDrivingBradley(Vector3 spawnPos, Quaternion spawnRot);
    [ServerVar]
public static string svspawnroadbradley(Vector3 pos, Vector3 dir);
    public void SetDestination(Vector3 dest);
    public virtual void ServerInit();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public void Initialize();
    public BasePlayer FollowPlayer();
    public static Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom);
    protected virtual float get_PositionTickRate();
    public bool IsAtDestination();
    public bool IsAtFinalDestination();
    public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos);
    public void FireGunTest();
    public void InstallPatrolPath(IAIPath path);
    public void UpdateMovement_Patrol();
    private void EnterSpline();
    private void LeaveSpline();
    public void DoSplineMove();
    public void UpdateMovement_Hunt();
    public void DoSimpleAI();
    private void SetTarget();
    public void FixedUpdate();
    private void AvoidObstacles(Single& throttleScaleFromTurn);
    public void DoPhysicsMove();
    public void ApplyBrakes(float amount);
    public float GetMotorTorque(bool rightSide);
    public void ScaleSidewaysFriction(float scale);
    public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount);
    public void ApplyBrakeTorque(float amount, bool rightSide);
    public void CreateExplosionMarker(float durationMinutes);
    public virtual void OnKilled(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
    public virtual void Hurt(HitInfo info);
    public virtual void OnHealthChanged(float oldvalue, float newvalue);
    public void DoHealing();
    public sealed virtual BasePlayer GetPlayerDamageInitiator();
    public sealed virtual float GetDamageMultiplier(BaseEntity ent);
    public sealed virtual void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
    public sealed virtual void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction);
    public sealed virtual void OnBasePathTrigger(int pathId, BasePath path);
    private bool IsOnSpline();
    public bool HasPath();
    public void ClearPath();
    public bool IndexValid(int index);
    public Vector3 GetFinalDestination();
    public Vector3 GetCurrentPathDestination();
    public bool PathComplete();
    public bool AtCurrentPathNode();
    public int GetLoopedIndex(int index);
    public Vector3 PathDirection(int index);
    public Vector3 IdealPathPosition();
    public void AdvancePathMovement(bool force);
    public bool GetPathToClosestTurnableNode(IAIPathNode start, Vector3 forward, List`1& nodes);
    public bool GetEngagementPath(List`1& nodes);
    private void CacheSpawnPrefabIDS();
    private void TrySpawnScientists(BasePlayer triggeringPlayer);
    private List`1<ScientistSpawnGroup> GetTriggereringSpawnGroups();
    private void AddMountedScientistsToSpawn(List`1<GameObjectRef> scientists);
    private void ClearMountedScientists();
    private void AddSpawnGroupSpawns(List`1<ScientistSpawnGroup> spawnGroups, List`1<GameObjectRef> scientists);
    private void SetSpawnGroupsAsSpawned(List`1<ScientistSpawnGroup> spawnGroups);
    private void UpdateDeployed();
    private bool UnableToFireAtPlayers();
    private void UpdateMountScientists();
    public int ActiveScientistCount();
    public int AliveScientistCount();
    private bool CanDeployScientists(BaseEntity attacker, List`1<GameObjectRef> scientistPrefabs, List`1<Vector3> spawnPositions);
    [IteratorStateMachineAttribute("BradleyAPC/<DeployScientists>d__202")]
private IEnumerator DeployScientists(BasePlayer triggerPlayer, List`1<GameObjectRef> scientistPrefabs, List`1<Vector3> spawnPositions);
    private void SetDeployingScientists(bool flag);
    private void SetMountingScientists(bool flag);
    private ScientistNPC SpawnScientist(GameObjectRef scientistPrefab, Vector3 spawnPos, bool roadSpawned);
    private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing);
    private void DropSmokeGrenade(Vector3 position, float duration);
    private void KillSpawnedScientists();
    [IteratorStateMachineAttribute("BradleyAPC/<RecallSpawnedScientists>d__209")]
private IEnumerator RecallSpawnedScientists();
    public void OnScientistMounted(ScientistNPC scientist);
    public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom);
    public void UpdateTargetList();
    public int SortTargets(TargetInfo t1, TargetInfo t2);
    public Vector3 GetAimPoint(BaseEntity ent);
    public bool VisibilityTest(BaseEntity ent);
    public void UpdateTargetVisibilities();
    public void DoWeaponAiming();
    public void DoWeapons();
    public void FireGun(Vector3 targetPos, float aimCone, bool isCoax);
    public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal);
    public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch, float maxPitch, float maxYaw, Transform parentOverride);
    public void LateUpdate();
}
public class BradleyMoveTest : MonoBehaviour {
    public WheelCollider[] leftWheels;
    public WheelCollider[] rightWheels;
    public float moveForceMax;
    public float brakeForce;
    public float throttle;
    public float turnForce;
    public float sideStiffnessMax;
    public float sideStiffnessMin;
    public Transform centerOfMass;
    public float turning;
    public bool brake;
    public Rigidbody myRigidBody;
    public Vector3 destination;
    public float stoppingDist;
    public GameObject followTest;
    public void Awake();
    public void Initialize();
    public void SetDestination(Vector3 dest);
    public void FixedUpdate();
    public void ApplyBrakes(float amount);
    public float GetMotorTorque(bool rightSide);
    public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount);
    public void ApplyBrakeTorque(float amount, bool rightSide);
    public void AdjustFriction();
}
public class BradleySpawner : MonoBehaviour {
    public BasePath path;
    public GameObjectRef bradleyPrefab;
    public BradleyAPC spawned;
    public bool initialSpawn;
    public float minRespawnTimeMinutes;
    public float maxRespawnTimeMinutes;
    public static BradleySpawner singleton;
    private bool pendingRespawn;
    public void Start();
    public void DelayedStart();
    public void CheckIfRespawnNeeded();
    public void ScheduleRespawn();
    public void DoRespawn();
    public void SpawnBradley();
}
public class BranchConfig : IOConfig`1<ElectricalBranch> {
}
public class Branding : BaseMonoBehaviour {
    public TextMeshProUGUI versionText;
    public CanvasGroup canvasGroup;
    private string oldChangeId;
}
public class BucketVMFluidSim : MonoBehaviour {
    public Animator waterbucketAnim;
    public ParticleSystem waterPour;
    public ParticleSystem waterTurbulence;
    public ParticleSystem waterFill;
    public float waterLevel;
    public float targetWaterLevel;
    public AudioSource waterSpill;
}
public class BuildingBlock : StabilityEntity {
    public Construction blockDefinition;
    private static Vector3[] outsideLookupOffsets;
    private bool forceSkinRefresh;
    private ulong lastSkinID;
    [CompilerGeneratedAttribute]
private int <modelState>k__BackingField;
    public int lastModelState;
    [CompilerGeneratedAttribute]
private UInt32 <customColour>k__BackingField;
    private UInt32 lastCustomColour;
    public UInt32 playerCustomColourToApply;
    public Enum grade;
    public Enum lastGrade;
    public ConstructionSkin currentSkin;
    private DeferredAction skinChange;
    private MeshRenderer placeholderRenderer;
    private MeshCollider placeholderCollider;
    public static UpdateSkinWorkQueue updateSkinQueueServer;
    public static Phrase RotateTitle;
    public static Phrase RotateDesc;
    private bool globalNetworkCooldown;
    public bool CullBushes;
    public bool CheckForPipesOnModelChange;
    public OBBComponent AlternativePipeBounds;
    [CompilerGeneratedAttribute]
private ulong <wallpaperID>k__BackingField;
    public float wallpaperHealth;
    [CompilerGeneratedAttribute]
private ulong <wallpaperID2>k__BackingField;
    public float wallpaperHealth2;
    public ProtectionProperties wallpaperProtection;
    public bool CanBeDemolished { get; }
    public int modelState { get; public set; }
    public UInt32 customColour { get; private set; }
    public ConstructionGrade currentGrade { get; }
    public ulong wallpaperID { get; private set; }
    public ulong wallpaperID2 { get; private set; }
    private static BuildingBlock();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool get_CanBeDemolished();
    public virtual void ResetState();
    public virtual void InitShared();
    public virtual void PostInitShared();
    public virtual void DestroyShared();
    public virtual string Categorize();
    public virtual float BoundsPadding();
    public virtual bool IsOutside();
    public virtual bool SupportsChildDeployables();
    [CompilerGeneratedAttribute]
public int get_modelState();
    [CompilerGeneratedAttribute]
public void set_modelState(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_customColour();
    [CompilerGeneratedAttribute]
private void set_customColour(UInt32 value);
    public void SetConditionalModel(int state);
    public bool GetConditionalModel(int index);
    public ConstructionGrade get_currentGrade();
    public bool CanChangeToGrade(Enum iGrade, ulong iSkin, BasePlayer player);
    public bool HasUpgradePrivilege(Enum iGrade, ulong iSkin, BasePlayer player);
    public bool IsUpgradeBlocked();
    public bool CanAffordUpgrade(Enum iGrade, ulong iSkin, BasePlayer player);
    public void SetGrade(Enum iGrade);
    public void UpdateGrade();
    protected virtual void OnSkinChanged(ulong oldSkinID, ulong newSkinID);
    protected virtual void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void SetHealthToMax();
    [MaxDistance("3")]
[RPC_Server]
public void DoUpgradeToGrade(RPCMessage msg);
    private UInt32 GetShippingContainerBlockColourForPlayer(BasePlayer player);
    public void ChangeGradeAndSkin(Enum targetGrade, ulong skin, bool playEffect, bool updateSkin);
    public void ChangeGrade(Enum targetGrade, bool playEffect, bool updateSkin);
    public void PayForUpgrade(ConstructionGrade g, BasePlayer player);
    public void SetCustomColour(UInt32 newColour);
    public bool NeedsSkinChange();
    public void UpdateSkin(bool force);
    private void DestroySkin();
    public void RefreshNeighbours(bool linkToNeighbours);
    private void UpdatePlaceholder(bool state);
    private void ChangeSkin();
    public void ChangeSkin(GameObjectRef prefab);
    public virtual bool ShouldBlockProjectiles();
    [ContextMenu("Check for pipes")]
public void CheckForPipes();
    private void OnHammered();
    public virtual float MaxHealth();
    public virtual List`1<ItemAmount> BuildCost();
    public virtual void OnHealthChanged(float oldvalue, float newvalue);
    public virtual float RepairCostFraction();
    public bool CanRotate(BasePlayer player);
    public bool IsRotatable();
    public bool IsRotationBlocked();
    public bool HasRotationPrivilege(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
public void DoRotation(RPCMessage msg);
    private void ResetGlobalNetworkCooldown();
    public void StopBeingRotatable();
    public void StartBeingRotatable();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void AttachToBuilding(DecayEntity other);
    public virtual void ServerInit();
    public virtual void Hurt(HitInfo info);
    [CompilerGeneratedAttribute]
public ulong get_wallpaperID();
    [CompilerGeneratedAttribute]
private void set_wallpaperID(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_wallpaperID2();
    [CompilerGeneratedAttribute]
private void set_wallpaperID2(ulong value);
    public bool HasWallpaper();
    public bool HasWallpaper(int side);
    public virtual bool IsOccupied(Socket_Base socket);
    public void SetWallpaper(ulong id, int side);
    public void RemoveWallpaper(int side);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_PickupWallpaperStart(RPCMessage msg);
    private void DamageWallpaper(float totalDamage, int side);
    public virtual void StabilityCheck();
    public virtual void OnDecay(Decay decay, float decayDeltaTime);
    public void CheckWallpaper();
    public bool CanSeeWallpaperSocket(BasePlayer player, int side);
    public virtual bool CanPickup(BasePlayer player);
}
public class BuildingBlockDecay : Decay {
    private bool isFoundation;
    public virtual float GetDecayDelay(BaseEntity entity);
    public virtual float GetDecayDuration(BaseEntity entity);
    public virtual bool ShouldDecay(BaseEntity entity);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class BuildingBlockedGuide : MonoBehaviour {
    public Mesh BoxMesh;
    public Mesh SphereMesh;
    public Mesh CapsuleMesh;
    public MeshRenderer Renderer;
    public MeshFilter Filter;
    public Collider LargestVolume;
}
[CreateAssetMenuAttribute]
public class BuildingGrade : ScriptableObject {
    public Enum type;
    public ulong skin;
    public bool enabledInStandalone;
    [TooltipAttribute("Will bypass the inventory check if this is enabled, allowing anyone to craft this item, enabledInStandalone will still need to be true")]
public bool alwaysUnlock;
    public float baseHealth;
    public List`1<ItemAmount> baseCost;
    public PhysicMaterial physicMaterial;
    public ProtectionProperties damageProtecton;
    public bool supportsColourChange;
    public Option upgradeMenu;
}
public class BuildingGradeDecay : Decay {
    public Enum decayGrade;
    public virtual float GetDecayDelay(BaseEntity entity);
    public virtual float GetDecayDuration(BaseEntity entity);
    public virtual bool ShouldDecay(BaseEntity entity);
}
public abstract class BuildingManager : object {
    public static ServerBuildingManager server;
    public ListHashSet`1<DecayEntity> decayEntities;
    public ListDictionary`2<UInt32, Building> buildingDictionary;
    private static BuildingManager();
    public Building GetBuilding(UInt32 buildingID);
    public void Add(DecayEntity ent);
    public void Remove(DecayEntity ent);
    public void Clear();
    protected abstract virtual Building CreateBuilding(UInt32 id);
    protected abstract virtual void DisposeBuilding(Building& building);
}
public class BuildingPrivilegeRetro : BuildingPrivlidge {
    public BuildingPrivilegeRetroScreen screens;
    public GameObjectRef[] boxPrefabs;
    public GameObjectRef[] doubleBoxPrefabs;
    public int boxesAmount;
    public Transform boxesParent;
    public Vector3 boxSpacing;
    public ToolSetting[] toolSettings;
    public ToolModel[] toolCustomModels;
    public Material hammerOriginalMaterial;
    public virtual void Save(SaveInfo info);
    private float GetResourceProportion(int id);
    public virtual void Load(LoadInfo info);
}
public class BuildingPrivilegeRetroScreen : FacepunchBehaviour {
    [SerializeField]
private CanvasGroup screenCanvas;
    [SpaceAttribute]
[HeaderAttribute("PROTECTED TIME")]
public RustText protectedTimeText;
    public int decayWarningThreshold;
    public GameObject decayWarningGroup;
    public GameObject decayingGroup;
    [HeaderAttribute("UPKEEP")]
[SpaceAttribute]
public VirtualItemIcon[] costIcons;
    public RustText[] paginationTexts;
    [SpaceAttribute]
[HeaderAttribute("BLOCKS")]
public GameObject[] blocksType;
    public RustText blockCountText;
    public RustText doorCountText;
    [SpaceAttribute]
public Renderer screenRenderer;
    [ColorUsageAttribute("True", "True")]
public Color fromScreenEmissionColor;
    [ColorUsageAttribute("True", "True")]
public Color screenEmissionColor;
    public AnimationCurve tweenCurve;
    public float animDuration;
    public Animation screensAnim;
    public Screen[] screens;
}
public class BuildingPrivlidge : StorageContainer {
    public GameObject assignDialog;
    public HashSet`1<PlayerNameID> authorizedPlayers;
    public static Flags Flag_MaxAuths;
    public List`1<ItemDefinition> allowedConstructionItems;
    public float cachedProtectedMinutes;
    public float nextProtectedCalcTime;
    public static UpkeepBracket[] upkeepBrackets;
    public List`1<ItemAmount> upkeepBuffer;
    private static BuildingPrivlidge();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public bool IsAuthed(BasePlayer player);
    public bool IsAuthed(ulong userId);
    public bool AnyAuthed();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void Save(SaveInfo info);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Load(LoadInfo info);
    public void BuildingDirty();
    public bool AtMaxAuthCapacity();
    public void UpdateMaxAuthCapacity();
    protected virtual void OnInventoryDirty();
    public virtual void OnItemAddedOrRemoved(Item item, bool bAdded);
    public void AddDelayedUpdate();
    public void DelayedUpdate();
    public bool CanAdministrate(BasePlayer player);
    [RPC_Server]
[IsVisible("3")]
private void AddAuthorize(RPCMessage rpc);
    public void AddPlayer(BasePlayer granter, ulong targetPlayerId);
    [RPC_Server]
[IsVisible("3")]
public void RemoveSelfAuthorize(RPCMessage rpc);
    [RPC_Server]
[IsVisible("3")]
public void ClearList(RPCMessage rpc);
    [RPC_Server]
[IsVisible("3")]
public void RPC_Rotate(RPCMessage msg);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    private void UnlinkDoorControllers();
    public virtual bool HasSlot(Slot slot);
    public virtual bool SupportsChildDeployables();
    public float CalculateUpkeepPeriodMinutes();
    public float CalculateUpkeepCostFraction();
    public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts);
    public float GetProtectedMinutes(bool force);
    public virtual void OnKilled(HitInfo info);
    [AsyncStateMachineAttribute("BuildingPrivlidge/<HandleKilledByClanMember>d__39")]
private void HandleKilledByClanMember(BasePlayer player);
    public virtual void DecayTick();
    public bool EnsurePrimary();
    public void MarkProtectedMinutesDirty(float delay);
    public float CalculateBuildingTaxRate();
    public void ApplyUpkeepPayment();
    public void QueueUpkeepPayment(List`1<ItemAmount> itemAmounts);
    public bool CanAffordUpkeepPayment(List`1<ItemAmount> itemAmounts);
    public float PurchaseUpkeepTime(DecayEntity entity, float deltaTime);
    public void PurchaseUpkeepTime(float deltaTime);
    public static string FormatUpkeepMinutes(float minutes);
}
public class BuildingProximity : PrefabAttribute {
    private static float check_radius;
    private static float check_forgiveness;
    private static float foundation_width;
    private static float foundation_extents;
    public static bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation);
    public static ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2);
    public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation);
    protected virtual Type GetIndexedType();
}
public class Bulb : BaseBulb {
    public MaterialSwap swap;
}
public class BunkerEntrance : BaseEntity {
    public GameObjectRef portalPrefab;
    public GameObjectRef doorPrefab;
    public Transform portalSpawnPoint;
    public Transform doorSpawnPoint;
    public Door doorInstance;
    public BasePortal portalInstance;
    public virtual void ServerInit();
    public sealed virtual void MissionStarted(BasePlayer assignee, MissionInstance instance);
    public sealed virtual void MissionEnded(BasePlayer assignee, MissionInstance instance);
}
public class BunnyEntry : MonoBehaviour {
    public Text nameText;
    public Text amountText;
    public RawImage starImage;
    public RawImage selfImage;
}
public class Buoyancy : ListComponent`1<Buoyancy> {
    public BuoyancyPoint[] points;
    public GameObjectRef[] waterImpacts;
    public Rigidbody rigidBody;
    public float buoyancyScale;
    public bool scaleForceWithMass;
    public bool doEffects;
    public float flowMovementScale;
    public float requiredSubmergedFraction;
    public bool useUnderwaterDrag;
    [RangeAttribute("0", "3")]
public float underwaterDrag;
    [RangeAttribute("0", "1")]
[TooltipAttribute("How much this object will pay attention to the wave system, 0 = flat water, 1 = full waves (default 1)")]
[FormerlySerializedAsAttribute("flatWaterLerp")]
public float wavesEffect;
    [CompilerGeneratedAttribute]
private float <timeOutOfWater>k__BackingField;
    public Action`1<bool> SubmergedChanged;
    public BaseEntity forEntity;
    public float submergedFraction;
    [SerializeField]
[ReadOnlyAttribute]
private BuoyancyPointData[] pointData;
    private bool initedPointArrays;
    private Vector2[] pointPositionArray;
    private Vector2[] pointPositionUVArray;
    private Single[] pointShoreDistanceArray;
    private Single[] pointTerrainHeightArray;
    private Single[] pointWaterHeightArray;
    private float defaultDrag;
    private float defaultAngularDrag;
    private float timeInWater;
    public Nullable`1<float> ArtificialHeight;
    private BaseVehicle forVehicle;
    private bool hasLocalPlayers;
    private bool hadLocalPlayers;
    public float timeOutOfWater { get; private set; }
    public bool InWater { get; }
    [CompilerGeneratedAttribute]
public float get_timeOutOfWater();
    [CompilerGeneratedAttribute]
private void set_timeOutOfWater(float value);
    public bool get_InWater();
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void SavePointData(bool forced);
    public static string DefaultWaterImpact();
    private void Awake();
    public void Sleep();
    public void Wake();
    public void CheckSleepState();
    public bool ShouldWake();
    public bool ShouldWake(bool hasLocalPlayers);
    private bool HasLocalPlayers();
    protected void DoCycle(bool forced);
    public static void Cycle();
    public Vector3 GetFlowDirection(Vector2 posUV);
    public void BuoyancyFixedUpdate();
    private void InitPointArrays();
}
public class BuoyancyPoint : MonoBehaviour {
    public float buoyancyForce;
    public float size;
    public float waveScale;
    public float waveFrequency;
    public bool doSplashEffects;
    public float randomOffset;
    public bool wasSubmergedLastFrame;
    public float nexSplashTime;
    private static Color gizmoColour;
    private static BuoyancyPoint();
    public void Start();
    public void OnDrawGizmos();
}
public class BurstClothCollider : MonoBehaviour {
    public float Height;
    public float Radius;
    public void GetParams(Vector3& pointA, Vector3& pointB, Vector3& up, Single& halfHeight);
}
public class BurstClothHitBoxCollision : BurstCloth {
    [HeaderAttribute("Rust Wearable BurstCloth")]
public bool UseLocalGravity;
    public float GravityStrength;
    public float DefaultLength;
    public float MountedLengthMultiplier;
    public float DuckedLengthMultiplier;
    public float CorpseLengthMultiplier;
    public Transform UpAxis;
    [HeaderAttribute("Collision")]
public Transform ColliderRoot;
    [TooltipAttribute("Keywords in bone names which should be ignored for collision")]
public String[] IgnoreKeywords;
    private static void BreakCapsuleIntoSpheres(Transform transform, Vector3 pointA, Vector3 pointB, Vector3 up, float halfHeight, float radius, List`1<SphereParams> sphereColliders);
    protected virtual void GatherColliders(List`1<SphereParams> sphereColliders);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class BushEntity : BaseEntity {
    public GameObjectRef prefab;
    public bool globalBillboard;
    public virtual void InitShared();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public enum BUTTON : Enum {
    public int value__;
    public static BUTTON FORWARD;
    public static BUTTON BACKWARD;
    public static BUTTON LEFT;
    public static BUTTON RIGHT;
    public static BUTTON JUMP;
    public static BUTTON DUCK;
    public static BUTTON SPRINT;
    public static BUTTON USE;
    public static BUTTON FIRE_PRIMARY;
    public static BUTTON FIRE_SECONDARY;
    public static BUTTON RELOAD;
    public static BUTTON FIRE_THIRD;
}
public class ButtonIcon : RustButton {
    public Image Image;
}
public class Buttons : object {
}
[DefaultMemberAttribute("Item")]
public class ByteMap : object {
    [SerializeField]
private int size;
    [SerializeField]
private int bytes;
    [SerializeField]
private Byte[] values;
    public int Size { get; }
    public UInt32 Item { get; public set; }
    public ByteMap(int size, int bytes);
    public ByteMap(int size, Byte[] values, int bytes);
    public int get_Size();
    public UInt32 get_Item(int x, int y);
    public void set_Item(int x, int y, UInt32 value);
}
public class ByteQuadtree : object {
    [SerializeField]
private int size;
    [SerializeField]
private int levels;
    [SerializeField]
private ByteMap[] values;
    public int Size { get; }
    public Element Root { get; }
    public void UpdateValues(Byte[] baseValues);
    public int get_Size();
    public Element get_Root();
    private ByteMap CreateLevel(int level);
}
public class CableTunnel : IOEntity {
    private static int numChannels;
    private Int32[] inputAmounts;
    public virtual bool WantsPower(int inputIndex);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void UpdateOutputs();
}
public class CachedTransform`1 : ValueType {
    public T component;
    public Vector3 position;
    public Quaternion rotation;
    public Vector3 localScale;
    public Matrix4x4 localToWorldMatrix { get; }
    public Matrix4x4 worldToLocalMatrix { get; }
    public Vector3 forward { get; }
    public Vector3 up { get; }
    public Vector3 right { get; }
    public CachedTransform`1(T instance);
    public void Apply();
    public void RotateAround(Vector3 center, Vector3 axis, float angle);
    public Matrix4x4 get_localToWorldMatrix();
    public Matrix4x4 get_worldToLocalMatrix();
    public Vector3 get_forward();
    public Vector3 get_up();
    public Vector3 get_right();
    public static bool op_Implicit(CachedTransform`1<T> instance);
}
[ExecuteInEditMode]
public class CameraEx : MonoBehaviour {
    public bool overrideAmbientLight;
    public AmbientMode ambientMode;
    public Color ambientGroundColor;
    public Color ambientEquatorColor;
    public Color ambientLight;
    public float ambientIntensity;
    public ReflectionProbe reflectionProbe;
    internal Color old_ambientLight;
    internal Color old_ambientGroundColor;
    internal Color old_ambientEquatorColor;
    internal float old_ambientIntensity;
    internal AmbientMode old_ambientMode;
    public float aspect;
}
public enum CameraFocusMode : Enum {
    public int value__;
    public static CameraFocusMode Off;
    public static CameraFocusMode Auto;
    public static CameraFocusMode Manual;
}
public class CameraMan : SingletonComponent`1<CameraMan> {
    public static string DefaultSaveName;
    public static string SavePositionExtension;
    public static string SavePositionDirectory;
    public bool OnlyControlWhenCursorHidden;
    public bool NeedBothMouseButtonsToZoom;
    public float LookSensitivity;
    public float MoveSpeed;
    public static float GuideAspect;
    public static float GuideRatio;
    public Canvas canvas;
    public Graphic[] guides;
    private static CameraMan();
}
public class CameraSettings : MonoBehaviour {
    private Camera cam;
    private void OnEnable();
    private void Update();
}
public class CameraTool : HeldEntity {
    public GameObjectRef screenshotEffect;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[FromOwner]
private void SVNoteScreenshot(RPCMessage msg);
}
[DisallowMultipleComponent]
public class CameraUpdateHook : MonoBehaviour {
    public static Action PreCull;
    public static Action PreRender;
    public static Action PostRender;
    public static Action RustCamera_PreRender;
    public static float LastFrameFOV;
    private static CameraUpdateHook();
    private void Awake();
}
public static class CameraUtil : object {
    public static void NormalizePlane(Plane& plane);
    public static void ExtractPlanes(Camera camera, Plane[]& planes);
    public static void ExtractPlanes(Matrix4x4 viewProjMatrix, Plane[]& planes);
}
public class CameraViewerId : ValueType {
    public ulong SteamId;
    public long ConnectionId;
    public CameraViewerId(ulong steamId, long connectionId);
    public sealed virtual bool Equals(CameraViewerId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CameraViewerId left, CameraViewerId right);
    public static bool op_Inequality(CameraViewerId left, CameraViewerId right);
}
public class CamperSeatConfig : MonoBehaviour {
    public Transform[] SeatPositions;
    public Transform StovePosition;
    public Transform StoragePosition;
}
public class Candle : BaseCombatEntity {
    public float lifeTimeSeconds;
    public float burnRate;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsVisible("3")]
[RPC_Server]
public void SetWantsOn(RPCMessage msg);
    public virtual void PostServerLoad();
    public void UpdateInvokes();
    public void Burn();
    public virtual void OnAttacked(HitInfo info);
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public sealed virtual void Ignite(Vector3 fromPos);
    public sealed virtual bool CanIgnite();
}
public class CanvasLOD : LODComponent {
    public float Distance;
}
public class CanvasOrderHack : MonoBehaviour {
    private void OnEnable();
}
public class CapturePointTrigger : TriggerBase {
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class CardGamePlayerStorage : StorageContainer {
    private EntityRef cardTableRef;
    public BaseCardGameEntity GetCardGameEntity();
    public virtual void Load(LoadInfo info);
    protected virtual void OnInventoryDirty();
    public virtual void Save(SaveInfo info);
    public void SetCardTable(BaseCardGameEntity cardGameEntity);
}
public class CardGamePlayerWidget : MonoBehaviour {
    [SerializeField]
private GameObjectRef cardImageSmallPrefab;
    [SerializeField]
private RawImage avatar;
    [SerializeField]
private RustText playerName;
    [SerializeField]
private RustText scrapTotal;
    [SerializeField]
private RustText betText;
    [SerializeField]
private Image background;
    [SerializeField]
private Color inactiveBackground;
    [SerializeField]
private Color activeBackground;
    [SerializeField]
private Color foldedBackground;
    [SerializeField]
private Color winnerBackground;
    [SerializeField]
private Animation actionShowAnimation;
    [SerializeField]
private RustText actionText;
    [SerializeField]
private Sprite canSeeIcon;
    [SerializeField]
private Sprite cannotSeeIcon;
    [SerializeField]
private Sprite blankSprite;
    [SerializeField]
private Image cornerIcon;
    [SerializeField]
private Transform cardDisplayParent;
    [SerializeField]
private GridLayoutGroup cardDisplayGridLayout;
    [SerializeField]
private GameObject circle;
    [SerializeField]
private RustText circleText;
}
public class CardGameSounds : PrefabAttribute {
    public SoundDefinition ChipsSfx;
    public SoundDefinition DrawSfx;
    public SoundDefinition PlaySfx;
    public SoundDefinition ShuffleSfx;
    public SoundDefinition WinSfx;
    public SoundDefinition LoseSfx;
    public SoundDefinition YourTurnSfx;
    public SoundDefinition CheckSfx;
    public SoundDefinition HitSfx;
    public SoundDefinition StandSfx;
    public SoundDefinition BetSfx;
    public SoundDefinition IncreaseBetSfx;
    public SoundDefinition DecreaseBetSfx;
    public SoundDefinition AllInSfx;
    public SoundDefinition UIInteractSfx;
    [HeaderAttribute("Dealer Reactions")]
public SoundDefinition DealerCoolSfx;
    public SoundDefinition DealerHappySfx;
    public SoundDefinition DealerLoveSfx;
    public SoundDefinition DealerSadSfx;
    public SoundDefinition DealerShockedSfx;
    protected virtual Type GetIndexedType();
    public void PlaySound(SoundType sound, GameObject forGameObject);
}
public class CardGameUI : UIDialog {
    [HeaderAttribute("Card Game")]
[SerializeField]
private InfoTextUI primaryInfo;
    [SerializeField]
private InfoTextUI secondaryInfo;
    [SerializeField]
private InfoTextUI playerLeaveInfo;
    [SerializeField]
private GameObject playingUI;
    [SerializeField]
private PlayingCardImage[] cardImages;
    [SerializeField]
private CardInputWidget[] inputWidgets;
    [SerializeField]
private RustSlider dismountProgressSlider;
    [SerializeField]
private Phrase phraseLoading;
    [SerializeField]
private Phrase phraseWaitingForNextRound;
    [SerializeField]
private Phrase phraseNotEnoughPlayers;
    [SerializeField]
private Phrase phrasePlayerLeftGame;
    [SerializeField]
private Phrase phraseNotEnoughBuyIn;
    [SerializeField]
private Phrase phraseTooMuchBuyIn;
    public Phrase phraseYourTurn;
    public Phrase phraseYouWinTheRound;
    public Phrase phraseRoundWinner;
    public Phrase phraseRoundWinners;
    public Phrase phraseScrapWon;
    public Phrase phraseScrapReturned;
    public Phrase phraseChangeBetAmount;
    public Phrase phraseBet;
    public Phrase phraseBetAdd;
    public Phrase phraseAllIn;
    public GameObject amountChangeRoot;
    public RustText amountChangeText;
    public Color colourNeutralUI;
    public Color colourGoodUI;
    public Color colourBadUI;
    [SerializeField]
private CanvasGroup timerCanvas;
    [SerializeField]
private RustSlider timerSlider;
    [SerializeField]
private UIChat chat;
    [SerializeField]
private HudElement Hunger;
    [SerializeField]
private HudElement Thirst;
    [SerializeField]
private HudElement Health;
    [SerializeField]
private HudElement PendingHealth;
    public Sprite cardNone;
    public Sprite cardBackLarge;
    public Sprite cardBackSmall;
    private static Sprite cardBackLargeStatic;
    private static Sprite cardBackSmallStatic;
    [SerializeField]
private TexasHoldEmUI texasHoldEmUI;
    [SerializeField]
private BlackjackUI blackjackUI;
}
public class CardInputWidget : MonoBehaviour {
    public RustText InputText;
    public RustText ActionText;
    public RustText ExtraText;
}
public class CardReader : IOEntity {
    public float accessDuration;
    public int accessLevel;
    public GameObjectRef accessGrantedEffect;
    public GameObjectRef accessDeniedEffect;
    public GameObjectRef swipeEffect;
    public Transform audioPosition;
    public Flags AccessLevel1;
    public Flags AccessLevel2;
    public Flags AccessLevel3;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public void CancelAccess();
    public void FailCard();
    public virtual void ServerInit();
    public void GrantCard();
    [RPC_Server]
[IsVisible("3")]
public void ServerCardSwiped(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class CardTable : BaseCardGameEntity {
    [SerializeField]
[HeaderAttribute("Card Table")]
private ViewModel viewModel;
    [SerializeField]
private PlayingCardImage[] tableCards;
    [SerializeField]
private Renderer[] tableCardBackings;
    [SerializeField]
private Canvas cardUICanvas;
    [SerializeField]
private Image[] tableCardImages;
    [SerializeField]
private Sprite blankCard;
    [SerializeField]
private ChipStack[] chipStacks;
    [SerializeField]
private ChipStack[] fillerStacks;
    protected float MaxStorageInteractionDist { get; }
    public virtual void Load(LoadInfo info);
    protected virtual float get_MaxStorageInteractionDist();
}
public class CardTableSeat : BaseChair {
    public Transform CardsMesh;
}
public class CargoMoveTest : FacepunchBehaviour {
    public int targetNodeIndex;
    private float currentThrottle;
    private float turnScale;
    private void Awake();
    public void FindInitialNode();
    private void Update();
    public void UpdateMovement();
    public int GetClosestNodeToUs();
    public void OnDrawGizmosSelected();
}
public class CargoNotifier : MonoBehaviour {
    [SerializeField]
private BasePath cargoPath;
    private void Start();
}
public class CargoPlane : BaseEntity {
    public GameObjectRef prefabDrop;
    public SpawnFilter filter;
    public Vector3 startPos;
    public Vector3 endPos;
    public float secondsToTake;
    public float secondsTaken;
    public bool dropped;
    public Vector3 dropPosition;
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    private void Initialize();
    public void InitDropPosition(Vector3 newDropPosition);
    public Vector3 RandomDropPosition();
    public void UpdateDropPosition(Vector3 newDropPosition);
    private void Update();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class CargoShip : BaseEntity {
    public int targetNodeIndex;
    public GameObject wakeParent;
    public GameObjectRef scientistTurretPrefab;
    public Transform[] scientistSpawnPoints;
    public List`1<Transform> crateSpawns;
    public GameObjectRef lockedCratePrefab;
    public GameObjectRef militaryCratePrefab;
    public GameObjectRef eliteCratePrefab;
    public GameObjectRef junkCratePrefab;
    public Transform waterLine;
    public Transform rudder;
    public Transform propeller;
    public GameObjectRef escapeBoatPrefab;
    public Transform escapeBoatPoint;
    public GameObjectRef microphonePrefab;
    public Transform microphonePoint;
    public GameObjectRef speakerPrefab;
    public Transform[] speakerPoints;
    public GameObject radiation;
    public GameObjectRef mapMarkerEntityPrefab;
    public GameObject hornOrigin;
    public SoundDefinition hornDef;
    public CargoShipSounds cargoShipSounds;
    public GameObject[] layouts;
    public GameObjectRef playerTest;
    public Transform bowPoint;
    private UInt32 layoutChoice;
    public static Flags IsDocked;
    public static Flags HasDocked;
    public static Flags DockedHarborIndex0;
    public static Flags DockedHarborIndex1;
    public static Flags Egressing;
    [ServerVar]
public static bool docking_debug;
    [ServerVar]
public static bool should_dock;
    [ServerVar]
public static float dock_time;
    [ServerVar]
public static bool event_enabled;
    [ServerVar]
public static float event_duration_minutes;
    [ServerVar]
public static float egress_duration_minutes;
    [ServerVar]
public static int loot_rounds;
    [ServerVar]
public static float loot_round_spacing_minutes;
    [ServerVar]
public static bool refresh_loot_on_dock;
    public static List`1<HarborInfo> harbors;
    public int currentHarborApproachNode;
    public int harborIndex;
    public bool isDoingHarborApproach;
    private int dockCount;
    private bool shouldLookAhead;
    private float lifetime;
    private CargoShipContainerDestination[] containerDestinations;
    private HashSet`1<ulong> boardedPlayerIds;
    public static bool hasCalculatedApproaches;
    public BaseEntity mapMarkerInstance;
    public Vector3 currentVelocity;
    public float currentThrottle;
    public float currentTurnSpeed;
    public float turnScale;
    public int lootRoundsPassed;
    public int hornCount;
    public float currentRadiation;
    public bool egressing;
    public BasePath harborApproachPath;
    public HarborProximityManager proxManager;
    private float lastSpeed;
    public bool IsShipDocked { get; }
    public static int TotalAvailableHarborDockingPaths { get; }
    private bool HasFinishedDocking { get; }
    private float EventTimeRemaining { get; }
    private static CargoShip();
    public bool get_IsShipDocked();
    public static int get_TotalAvailableHarborDockingPaths();
    public static List`1<Vector3> GetCargoApproachPath(int index);
    public virtual float GetNetworkTime();
    [ServerVar]
public static void debug_info(Arg arg);
    [ServerVar]
public static void debug_cargo_status(Arg arg);
    public virtual void Load(LoadInfo info);
    public void RefreshActiveLayout();
    public static void RegisterHarbor(BasePath path, Transform tf);
    public void TriggeredEventSpawn();
    public void TriggeredEventSpawnDockingTest(int index);
    private static void CalculateHarborApproachNodes();
    public void OnArrivedAtHarbor();
    private void ClearAllHarborEntitiesOnShip();
    public void CreateMapMarker();
    public void DisableCollisionTest();
    public void SpawnCrate(string resourcePath);
    public void RespawnLoot();
    public void SpawnSubEntities();
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public void PlayHorn();
    public virtual void Spawn();
    public virtual void ServerInit();
    public void UpdateRadiation();
    public void StartEgress();
    public void DelayedDestroy();
    public void FindInitialNode();
    private int GetHackableCrateCount();
    public void BuildingCheck();
    public void FixedUpdate();
    public void UpdateMovement();
    [ContextMenu("Break")]
public void Break();
    private void UpdateShip(float desiredThrottle, Vector3 desiredWaypoint, Vector3 approachRotationNode);
    private void UpdateHarborApproachProgress();
    private void InitializeHarborApproach(bool forceInit);
    private float CalculateDesiredThrottle(Vector3 desiredMoveNode);
    private void CalculateDesiredNodes(Vector3& desiredMoveNode, Vector3& approachRotationNode);
    private bool get_HasFinishedDocking();
    private void HandleNodeArrival(Vector3 waypointPosition);
    public void StartHarborApproach(CargoNotifier cn);
    private float GetTimeRemainingFromCrates();
    private void EndHarborApproach();
    private float get_EventTimeRemaining();
    private void AdvanceHarborApproach();
    private bool IsOceanPatrolPathAvailable();
    private bool IsValidTargetNode();
    private void PreHarborLeaveHorn();
    private void LeaveHarbor();
    public int GetClosestNodeToUs();
    public virtual Vector3 GetLocalVelocityServer();
    public virtual Quaternion GetAngularVelocityServer();
    public virtual float InheritedVelocityScale();
    public virtual bool BlocksWaterFor(BasePlayer player);
    public virtual float MaxVelocity();
    public virtual bool SupportsChildDeployables();
    public virtual bool ForceDeployableSetParent();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class CargoShipContainer : BaseEntity {
    public GameObject[] DressingVariants;
    public static Flags Descending;
    public static Flags Targeted;
    private int dressingVariant;
    public virtual float MaxVelocity();
    public virtual void PreInitShared();
    public virtual void ServerInit();
    public virtual void PostMapEntitySpawn();
    public virtual void Save(SaveInfo info);
    private void AssignVariant();
    public void ToggleHurtCollider(bool state);
    public void SetTargeted(bool state);
    public virtual void Load(LoadInfo info);
    private void UpdateDressingVariant();
}
public class CargoShipContainerDestination : MonoBehaviour {
}
public class CargoShipContainerSounds : FacepunchBehaviour {
    public SoundDefinition liftDef;
    public SoundDefinition dropDef;
}
public class CargoShipDevTrigger : MonoBehaviour {
    public float TimeTrigger;
}
public class CargoShipInteriorSoundTrigger : MonoBehaviour {
    public CargoShipSounds cargoShipSounds;
}
public class CargoShipSounds : MonoBehaviour {
    public CargoShip cargoShip;
    public SoundDefinition waveSoundDef;
    public AnimationCurve waveSoundYGainCurve;
    public AnimationCurve waveSoundEdgeDistanceGainCurve;
    private Sound waveSoundL;
    private Sound waveSoundR;
    private Modulator waveSoundLGainMod;
    private Modulator waveSoundRGainMod;
    public SoundDefinition sternWakeSoundDef;
    private Sound sternWakeSound;
    private Modulator sternWakeSoundGainMod;
    public SoundDefinition idleWaveSoundDef;
    public SoundDefinition engineHumSoundDef;
    private Sound engineHumSound;
    private Modulator enginePitchMod;
    public GameObject engineHumTarget;
    public float enginePitchChangeSpeed;
    public SoundDefinition hugeRumbleSoundDef;
    public AnimationCurve hugeRumbleYDiffCurve;
    public AnimationCurve hugeRumbleRelativeSpeedCurve;
    private Sound hugeRumbleSound;
    private Modulator hugeRumbleGainMod;
    private Vector3 lastCameraPos;
    private Vector3 lastRumblePos;
    private Vector3 lastRumbleLocalPos;
    public Collider soundFollowCollider;
    public Collider soundFollowColliderL;
    public Collider soundFollowColliderR;
    public Collider sternSoundFollowCollider;
    public SoundDefinition metalGroanSoundDef;
    public float metalGroanMinInterval;
    public float metalGroanMaxInterval;
}
public class CarPhysics`1 : object {
    [CompilerGeneratedAttribute]
private float <DriveWheelVelocity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <DriveWheelSlip>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SteerAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TankThrottleLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TankThrottleRight>k__BackingField;
    private ServerWheelData[] wheelData;
    private TCar car;
    private Transform transform;
    private Rigidbody rBody;
    private CarSettings vehicleSettings;
    private float speedAngle;
    private bool wasSleeping;
    private bool hasDriver;
    private bool hadDriver;
    private float steerLerpSpeed;
    private float lastMovingTime;
    private WheelFrictionCurve zeroFriction;
    private Vector3 prevLocalCOM;
    private float midWheelPos;
    private static bool WHEEL_HIT_CORRECTION;
    private static float SLEEP_SPEED;
    private static float SLEEP_DELAY;
    private static float AIR_DRAG;
    private static float DEFAULT_GROUND_GRIP;
    private static float ROAD_GROUND_GRIP;
    private static float ICE_GROUND_GRIP;
    private bool slowSpeedExitFlag;
    private static float SLOW_SPEED_EXIT_SPEED;
    public TimeSince timeSinceWaterCheck;
    public float DriveWheelVelocity { get; private set; }
    public float DriveWheelSlip { get; private set; }
    public float SteerAngle { get; private set; }
    public float TankThrottleLeft { get; private set; }
    public float TankThrottleRight { get; private set; }
    private bool InSlowSpeedExitMode { get; }
    public CarPhysics`1(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings);
    [CompilerGeneratedAttribute]
public float get_DriveWheelVelocity();
    [CompilerGeneratedAttribute]
private void set_DriveWheelVelocity(float value);
    [CompilerGeneratedAttribute]
public float get_DriveWheelSlip();
    [CompilerGeneratedAttribute]
private void set_DriveWheelSlip(float value);
    [CompilerGeneratedAttribute]
public float get_SteerAngle();
    [CompilerGeneratedAttribute]
private void set_SteerAngle(float value);
    [CompilerGeneratedAttribute]
public float get_TankThrottleLeft();
    [CompilerGeneratedAttribute]
private void set_TankThrottleLeft(float value);
    [CompilerGeneratedAttribute]
public float get_TankThrottleRight();
    [CompilerGeneratedAttribute]
private void set_TankThrottleRight(float value);
    private bool get_InSlowSpeedExitMode();
    public void FixedUpdate(float dt, float speed);
    public bool IsGrounded();
    private void COMChanged();
    private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed);
    private float GetWheelForceDistance(WheelCollider col);
    private void UpdateSuspension(ServerWheelData<TCar> wd);
    private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel);
    private void UpdateLocalFrame(ServerWheelData<TCar> wd, float dt);
    private void ComputeTyreForces(ServerWheelData<TCar> wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier);
    private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed);
    private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier);
    private void ComputeOverallForces();
    private static float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip);
    private void ApplyTyreForces(ServerWheelData<TCar> wd);
    private Vector3 GetSidewaysForceAppPoint(ServerWheelData<TCar> wd, Vector3 contactPoint);
    private float GetTankSteerInvert(float throttleInput, float speed);
    [CompilerGeneratedAttribute]
private ServerWheelData<TCar> <.ctor>g__AddWheel|48_0(CarWheel wheel, <>c__DisplayClass48_0& );
}
public class CarSettings : object {
    [HeaderAttribute("Vehicle Setup")]
[RangeAttribute("0", "1")]
public float rollingResistance;
    [RangeAttribute("0", "1")]
public float antiRoll;
    public bool canSleep;
    [HeaderAttribute("Wheels")]
public bool tankSteering;
    [RangeAttribute("0", "50")]
public float maxSteerAngle;
    public bool steeringAssist;
    [RangeAttribute("0", "1")]
public float steeringAssistRatio;
    public bool steeringLimit;
    [RangeAttribute("0", "50")]
public float minSteerLimitAngle;
    [RangeAttribute("10", "50")]
public float minSteerLimitSpeed;
    [RangeAttribute("0", "1")]
public float rearWheelSteer;
    public float steerMinLerpSpeed;
    public float steerMaxLerpSpeed;
    public float steerReturnLerpSpeed;
    public bool retainLerpSpeed;
    [HeaderAttribute("Motor")]
public float maxDriveSlip;
    public float driveForceToMaxSlip;
    public float reversePercentSpeed;
    [HeaderAttribute("Brakes")]
public float brakeForceMultiplier;
    [HeaderAttribute("Front/Rear Vehicle Balance")]
[RangeAttribute("0", "1")]
public float handlingBias;
}
public class CarvablePumpkin : BaseOven {
    private List`1<ulong> editHistory;
    private static float TextureRequestTimeout;
    public GameObjectRef changeTextDialog;
    public MeshPaintableSource[] paintableSources;
    public UInt32[] textureIDs;
    public Type FileType { get; }
    public NetworkableId NetworkID { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public UInt32[] GetContentCRCs { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public BaseNetworkable UgcEntity { get; }
    public Vector2i TextureSize { get; }
    public int TextureCount { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Type get_FileType();
    public sealed virtual UInt32[] GetTextureCRCs();
    public sealed virtual NetworkableId get_NetworkID();
    public virtual bool CanUpdateSign(BasePlayer player);
    public bool CanUnlockSign(BasePlayer player);
    public bool CanLockSign(BasePlayer player);
    public virtual void Load(LoadInfo info);
    public sealed virtual UGCType get_ContentType();
    [RPC_Server]
[MaxDistance("3")]
public void LockSign(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void UnLockSign(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual bool ShouldNetworkOwnerInfo();
    public sealed virtual void SetTextureCRCs(UInt32[] crcs);
    public sealed virtual List`1<ulong> get_EditingHistory();
    private void LogEdit(BasePlayer byPlayer);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public virtual bool get_ShouldTransferAssociatedFiles();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public virtual string Categorize();
    public sealed virtual Vector2i get_TextureSize();
    public sealed virtual int get_TextureCount();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    [MaxDistance("5")]
[CallsPerSecond("5")]
[RPC_Server]
public void UpdateSign(RPCMessage msg);
    public void EnsureInitialized();
    [ConditionalAttribute("SIGN_DEBUG")]
private static void SignDebugLog(string str);
}
public class CarWheel : object {
    public WheelCollider wheelCollider;
    [RangeAttribute("0,0001", "3")]
public float tyreFriction;
    public bool steerWheel;
    public bool brakeWheel;
    public bool powerWheel;
}
public class Cassette : BaseEntity {
    public float MaxCassetteLength;
    [ReplicatedVar]
public static float MaxCassetteFileSizeMB;
    [CompilerGeneratedAttribute]
private UInt32 <AudioId>k__BackingField;
    public ulong CreatorSteamId;
    public PreloadType PreloadType;
    public PreloadedCassetteContent PreloadContent;
    public SoundDefinition InsertCassetteSfx;
    public int ViewmodelIndex;
    public Sprite HudSprite;
    public int MaximumVoicemailSlots;
    public int preloadedAudioId;
    public ICassettePlayer currentCassettePlayer;
    public UInt32 AudioId { get; private set; }
    public SoundDefinition PreloadedAudio { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    private static Cassette();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [ServerVar]
public static void ClearCassettes(Arg arg);
    [ServerVar]
public static void ClearCassettesByUser(Arg arg);
    [CompilerGeneratedAttribute]
public UInt32 get_AudioId();
    [CompilerGeneratedAttribute]
private void set_AudioId(UInt32 value);
    public SoundDefinition get_PreloadedAudio();
    public virtual void Load(LoadInfo info);
    public void AssignPreloadContent();
    public virtual bool get_ShouldTransferAssociatedFiles();
    public virtual void Save(SaveInfo info);
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    public void DelayedCassetteInserted();
    public void SetAudioId(UInt32 id, ulong userId);
    [RPC_Server]
[CallsPerSecond("1")]
public void Server_MakeNewFile(RPCMessage msg);
    public bool ClearSavedAudio();
    internal virtual void DoServerDestroy();
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public sealed virtual UGCType get_ContentType();
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public static bool IsOggValid(Byte[] data, Cassette c);
    public static bool IsOggValid(Byte[] data, float maxLength);
    public static float ByteToMegabyte(int byteSize);
    public static double GetOggLength(Byte[] t);
}
public class CassettePanel : NotePanel {
    public GameObject[] CassetteSprites;
}
[PostProcessAttribute("CathodeRenderer", "2", "Custom/Cathode - Analogue Video", "True")]
public class Cathode : PostProcessEffectSettings {
    [RangeAttribute("0", "1")]
public FloatParameter intensity;
    [RangeAttribute("1", "16")]
public IntParameter downscale;
    [RangeAttribute("1", "16")]
public IntParameter downscaleTemporal;
    [RangeAttribute("0", "3")]
public FloatParameter horizontalBlur;
    [RangeAttribute("0", "3")]
public FloatParameter verticalBlur;
    [RangeAttribute("0", "5")]
public FloatParameter chromaSubsampling;
    [RangeAttribute("0", "5")]
public FloatParameter sharpen;
    [RangeAttribute("0", "5")]
public FloatParameter sharpenRadius;
    [RangeAttribute("0", "0,5")]
public FloatParameter colorNoise;
    [RangeAttribute("0", "5")]
public FloatParameter restlessFoot;
    [RangeAttribute("0", "0,1")]
public FloatParameter footAmplitude;
    [RangeAttribute("0", "3")]
public FloatParameter chromaIntensity;
    [RangeAttribute("0", "1")]
public FloatParameter chromaInstability;
    [RangeAttribute("0", "0,1")]
public FloatParameter chromaOffset;
    [RangeAttribute("-2", "2")]
public FloatParameter responseCurve;
    [RangeAttribute("-1", "1")]
public FloatParameter saturation;
    [RangeAttribute("0", "1")]
public FloatParameter cometTrailing;
    [RangeAttribute("0", "1")]
public FloatParameter burnIn;
    [RangeAttribute("0", "1")]
public FloatParameter tapeDust;
    [RangeAttribute("0", "2")]
public FloatParameter wobble;
    [RangeAttribute("0", "1")]
public Vector2Parameter blackWhiteLevels;
    [RangeAttribute("0", "1")]
public Vector2Parameter dynamicRange;
    [RangeAttribute("-1", "1")]
public FloatParameter whiteBallance;
}
public class CathodeRenderer : PostProcessEffectRenderer`1<Cathode> {
    private Texture2D noiseTex;
    private RenderTexture temporalRT;
    private Shader grayShader;
    private Shader primaryShader;
    private Shader tvShader;
    private Shader postTVShader;
    private Shader trailShader;
    private int _CathodeRT1;
    private int _CathodeRT2;
    private int _Intensity;
    private int _SizeX;
    private int _SizeY;
    private int _ChromaSubsampling;
    private int _Sharpen;
    private int _SharpenRadius;
    private int _ColorNoise;
    private int _RestlessFoot;
    private int _FootAmplitude;
    private int _ChromaOffset;
    private int _ChromaIntensity;
    private int _ChromaInstability;
    private int _BurnIn;
    private int _TapeDust;
    private int _TrailTex;
    private int _NoiseTex;
    private int _Gamma;
    private int _ResponseCurve;
    private int _Saturation;
    private int _Wobble;
    private int _Black;
    private int _White;
    private int _DynamicRangeMin;
    private int _DynamicRangeMax;
    private int _ScreenWhiteBal;
    private int _Trailing;
    public virtual void Init();
    public virtual void Release();
    public virtual void Render(PostProcessRenderContext context);
}
public class CCTV_RC : PoweredRemoteControlEntity {
    public Transform pivotOrigin;
    public Transform yaw;
    public Transform pitch;
    public Vector2 pitchClamp;
    public Vector2 yawClamp;
    public float turnSpeed;
    public float serverLerpSpeed;
    public float clientLerpSpeed;
    public float zoomLerpSpeed;
    public Single[] fovScales;
    public float pitchAmount;
    public float yawAmount;
    public int fovScaleIndex;
    public float fovScaleLerped;
    public bool hasPTZ;
    public AnimationCurve dofCurve;
    public float dofApertureMax;
    public static Flags Flag_HasViewer;
    public SoundDefinition movementLoopSoundDef;
    public AnimationCurve movementLoopGainCurve;
    public float movementLoopSmoothing;
    public float movementLoopReference;
    private Sound movementLoop;
    private Modulator movementLoopGainModulator;
    public SoundDefinition zoomInSoundDef;
    public SoundDefinition zoomOutSoundDef;
    public RealTimeSinceEx timeSinceLastServerTick;
    public bool RequiresMouse { get; }
    protected bool EntityCanPing { get; }
    public bool CanAcceptInput { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    public virtual bool get_RequiresMouse();
    protected virtual bool get_EntityCanPing();
    public virtual bool get_CanAcceptInput();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public virtual void Save(SaveInfo info);
    [RPC_Server]
public void Server_SetDir(RPCMessage msg);
    public virtual bool InitializeControl(CameraViewerId viewerID);
    public virtual void StopControl(CameraViewerId viewerID);
    public void UpdateViewers();
    public void ServerTick();
    public bool UpdateManualAim(InputState inputState);
    public void UpdateRotation(float delta);
    public virtual void Load(LoadInfo info);
    public virtual float GetFovScale();
}
public class CCTVOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
public class CeilingLight : IOEntity {
    public float pushScale;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    public virtual void Hurt(HitInfo info);
    public void RefreshGrowables();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public void LightsOn();
    public void LightsOff();
    public virtual void OnKilled(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
}
public class CH47AIBrain : BaseAIBrain {
    public virtual void AddStates();
    public virtual void InitializeAI();
    public void FixedUpdate();
}
public class ch47Animator : MonoBehaviour {
    public Animator animator;
    public bool bottomDoorOpen;
    public bool landingGearDown;
    public bool leftDoorOpen;
    public bool rightDoorOpen;
    public bool rearDoorOpen;
    public bool rearDoorExtensionOpen;
    public Transform rearRotorBlade;
    public Transform frontRotorBlade;
    public float rotorBladeSpeed;
    public float wheelTurnSpeed;
    public float wheelTurnAngle;
    public SkinnedMeshRenderer[] blurredRotorBlades;
    public SkinnedMeshRenderer[] RotorBlades;
    private bool blurredRotorBladesEnabled;
    public float blurSpeedThreshold;
    private void Start();
    public void SetDropDoorOpen(bool isOpen);
    private void Update();
    private void LateUpdate();
    private void EnableBlurredRotorBlades(bool enabled);
}
public class CH47DropZone : MonoBehaviour {
    public float lastDropTime;
    public static List`1<CH47DropZone> dropZones;
    private static CH47DropZone();
    public void Awake();
    public static CH47DropZone GetClosest(Vector3 pos);
    public void OnDestroy();
    public float TimeSinceLastDrop();
    public void Used();
    public void OnDrawGizmos();
}
public class CH47FlightTest : MonoBehaviour {
    public Rigidbody rigidBody;
    public float engineThrustMax;
    public Vector3 torqueScale;
    public Transform com;
    public Transform[] GroundPoints;
    public Transform[] GroundEffects;
    public float currentThrottle;
    public float avgThrust;
    public float liftDotMax;
    public Transform AIMoveTarget;
    private static float altitudeTolerance;
    private static CH47FlightTest();
    public void Awake();
    public HelicopterInputState_t GetHelicopterInputState();
    public HelicopterInputState_t GetAIInputState();
    public float GetIdealAltitude();
    public void FixedUpdate();
    public void OnDrawGizmos();
}
public class CH47Helicopter : BaseHelicopter {
    public GameObjectRef mapMarkerEntityPrefab;
    [HeaderAttribute("Sounds")]
public SoundDefinition flightEngineSoundDef;
    public SoundDefinition flightThwopsSoundDef;
    public float rotorGainModSmoothing;
    public float engineGainMin;
    public float engineGainMax;
    public float thwopGainMin;
    public float thwopGainMax;
    public BaseEntity mapMarkerInstance;
    public virtual void ServerInit();
    public void CreateMapMarker();
    public virtual bool IsValidHomingTarget();
    protected virtual void ApplyHandbrake();
    protected virtual bool CanPushNow(BasePlayer pusher);
}
public class CH47HelicopterAIController : CH47Helicopter {
    public GameObjectRef scientistPrefab;
    public GameObjectRef dismountablePrefab;
    public GameObjectRef weakDismountablePrefab;
    public float maxTiltAngle;
    public float AiAltitudeForce;
    public GameObjectRef lockedCratePrefab;
    public static Flags Flag_Damaged;
    public static Flags Flag_NearDeath;
    public static Flags Flag_DropDoorOpen;
    public GameObject triggerHurt;
    public Vector3 landingTarget;
    public int numCrates;
    private bool shouldLand;
    public bool aimDirOverride;
    public Vector3 _aimDirection;
    public Vector3 _moveTarget;
    public int lastAltitudeCheckFrame;
    public float altOverride;
    public float currentDesiredAltitude;
    private bool altitudeProtection;
    public float hoverHeight;
    public void DropCrate();
    public bool OutOfCrates();
    public bool CanDropCrate();
    public bool IsDropDoorOpen();
    public void SetDropDoorOpen(bool open);
    public bool ShouldLand();
    public void SetLandingTarget(Vector3 target);
    public void ClearLandingTarget();
    public void TriggeredEventSpawn();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public virtual void ServerInit();
    public void SpawnPassenger(Vector3 spawnPos, string prefabPath);
    public void SpawnPassenger(Vector3 spawnPos);
    public void SpawnScientist(Vector3 spawnPos);
    private void OnSpawnedHuman(HumanNPC human);
    private void CheckSpawnScientists();
    public void SpawnScientists();
    public void EnableFacingOverride(bool enabled);
    public void SetMoveTarget(Vector3 position);
    public Vector3 GetMoveTarget();
    public void SetAimDirection(Vector3 dir);
    public Vector3 GetAimDirectionOverride();
    public Vector3 GetPosition();
    public virtual void MounteeTookDamage(BasePlayer mountee, HitInfo info);
    public void CancelAnger();
    public void InitiateAnger();
    public void UnHostile();
    public virtual void OnKilled(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
    public void DelayedKill();
    public virtual void DismountAllPlayers();
    public void SetAltitudeProtection(bool on);
    public void CalculateDesiredAltitude();
    public void SetMinHoverHeight(float newHeight);
    public float CalculateOverrideAltitude();
    public virtual void SetDefaultInputState();
    public void MaintainAIAltutide();
    public virtual void VehicleFixedUpdate();
    public virtual void DestroyShared();
}
public class CH47LandingZone : MonoBehaviour {
    public float lastDropTime;
    public static List`1<CH47LandingZone> landingZones;
    public float dropoffScale;
    public static bool HasAnyLandingZones { get; }
    private static CH47LandingZone();
    public static bool get_HasAnyLandingZones();
    public void Awake();
    public static CH47LandingZone GetClosest(Vector3 pos);
    public void OnDestroy();
    public float TimeSinceLastDrop();
    public void Used();
    public void OnDrawGizmos();
}
public class CH47PathFinder : BasePathFinder {
    public List`1<Vector3> visitedPatrolPoints;
    public virtual Vector3 GetRandomPatrolPoint();
    private MonumentInfo GetRandomValidMonumentInfo();
}
public class CH47ReinforcementListener : BaseEntity {
    public string listenString;
    public GameObjectRef heliPrefab;
    public float startDist;
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public void Call();
    public static bool TryCall(string resourcePath, Vector3 ourPos, float startDist);
}
public class Chainsaw : BaseMelee {
    public float attackFadeInTime;
    public float attackFadeInDelay;
    public float attackFadeOutTime;
    public float idleFadeInTimeFromOff;
    public float idleFadeInTimeFromAttack;
    public float idleFadeInDelay;
    public float idleFadeOutTime;
    public Renderer chainRenderer;
    private MaterialPropertyBlock block;
    private Vector2 saveST;
    public static Phrase UnloadAmmoTitle;
    public static Phrase UnloadAmmoDesc;
    [HeaderAttribute("Chainsaw")]
public float fuelPerSec;
    public int maxAmmo;
    public int ammo;
    public ItemDefinition fuelType;
    public float reloadDuration;
    [HeaderAttribute("Sounds")]
public SoundPlayer idleLoop;
    public SoundPlayer attackLoopAir;
    public SoundPlayer revUp;
    public SoundPlayer revDown;
    public SoundPlayer offSound;
    private int failedAttempts;
    public float engineStartChance;
    private TimeSince lastReloadSignalFromClient;
    private float ammoRemainder;
    private static Chainsaw();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool EngineOn();
    public bool IsAttacking();
    protected virtual void OnReceivedSignalServer(Signal signal, string arg);
    public void ServerNPCStart();
    public virtual void ServerUse();
    public virtual void ServerUse_OnHit(HitInfo info);
    private void DelayedStopAttack();
    protected virtual bool VerifyClientAttack(BasePlayer player);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void SetHeld(bool bHeld);
    public void ReduceAmmo(float firingTime);
    [IsActiveItem]
[RPC_Server]
public void DoReload(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public void SetEngineStatus(bool status);
    public void SetAttackStatus(bool status);
    public void EngineTick();
    public void AttackTick();
    [RPC_Server]
[IsActiveItem]
public void Server_StartEngine(RPCMessage msg);
    [IsActiveItem]
[RPC_Server]
public void Server_StopEngine(RPCMessage msg);
    [RPC_Server]
[IsActiveItem]
public void Server_SetAttacking(RPCMessage msg);
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    public void DisableHitEffects();
    public void EnableHitEffect(UInt32 hitMaterial);
    public virtual void DoAttackShared(HitInfo info);
    public virtual void Load(LoadInfo info);
    public bool HasAmmo();
    public Item GetAmmo();
}
public class ChanceAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Chance>k__BackingField;
    public float Chance { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Chance();
    [CompilerGeneratedAttribute]
public void set_Chance(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class ChanceEventUI : BaseEventUI {
}
public class ChangelogButton : MonoBehaviour {
    public RustButton Button;
    public CanvasGroup CanvasGroup;
    private void Update();
}
public class ChangelogPanel : MonoBehaviour {
    public GameObject AddedHeader;
    public GameObject RemovedHeader;
    public GameObject ChangedHeader;
    public RustText AddedContent;
    public RustText RemovedContent;
    public RustText ChangedContent;
}
public class ChangeSignText : UIDialog {
    public Action`2<int, Texture2D> onUpdateTexture;
    public Action onClose;
    public GameObject objectContainer;
    public Transform panTransform;
    public Transform rotateTransform;
    public GameObject currentFrameSection;
    public GameObject[] frameOptions;
    public Canvas canvas;
    public RectTransform rightPanelRect;
    public Camera cameraPreview;
    public Camera camera3D;
    public Light previewLight;
    public Vector3 homeRotation;
    public RectTransform toolsContainer;
    public RectTransform brushesContainer;
    public RustSlider brushSizeSlider;
    public RustSlider brushSpacingSlider;
    public RustSlider brushOpacitySlider;
    [HeaderAttribute("Layout")]
public FlexElement rootElement;
    public FlexElement bodyElement;
    public FlexElement controlsElement;
    public FlexElement floatElement;
}
public class ChatEntry : MonoBehaviour {
    public TextMeshProUGUI text;
    public RawImage avatar;
    public CanvasGroup canvasGroup;
    public float lifeStarted;
    public ulong steamid;
    public Phrase LocalPhrase;
    public Phrase CardsPhrase;
    public Phrase TeamPhrase;
    public TmProEmojiRedirector EmojiRedirector;
    public Phrase ClanPhrase;
}
public class Chicken : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Chicken();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public class ChildrenFromScene : MonoBehaviour {
    public string SceneName;
    public bool StartChildrenDisabled;
    [IteratorStateMachineAttribute("ChildrenFromScene/<Start>d__2")]
private IEnumerator Start();
}
public class ChildrenScreenshot : MonoBehaviour {
    public Vector3 offsetAngle;
    public int width;
    public int height;
    public float fieldOfView;
    [TooltipAttribute("0 = full recursive name, 1 = object name")]
public string folder;
    [ContextMenu("Create Screenshots")]
public void CreateScreenshots();
    public void PositionCamera(Camera cam, GameObject obj);
}
public class ChineseLantern : BaseFuelLightSource {
    public Transform pivotRotator;
    public float swaySpeed;
    public float swayDistance;
    public float lerpSpeed;
}
public class ChippyArcadeGame : BaseArcadeGame {
    public ChippyMainCharacter mainChar;
    public SpriteArcadeEntity mainCharAim;
    public ChippyBoss currentBoss;
    public ChippyBoss[] bossPrefabs;
    public SpriteArcadeEntity mainMenuLogo;
    public Transform respawnPoint;
    public Vector2 mouseAim;
    public TextArcadeEntity levelIndicator;
    public TextArcadeEntity gameOverIndicator;
    public TextArcadeEntity playGameButton;
    public TextArcadeEntity highScoresButton;
    public bool OnMainMenu;
    public bool GameActive;
    public int level;
    public TextArcadeEntity[] scoreDisplays;
    public MenuButtonArcadeEntity[] mainMenuButtons;
    public int selectedButtonIndex;
    public bool OnHighScores;
}
public class ChippyBoss : SpriteArcadeEntity {
    public Vector2 roamDistance;
    public float animationSpeed;
    public Sprite[] animationFrames;
    public ArcadeEntity bulletTest;
    public SpriteRenderer flashRenderer;
    public BossDamagePoint[] damagePoints;
}
public class ChippyBulletEntity : SpriteArcadeEntity {
    public float speed;
    public float maxSpeed;
    public float radius;
    public float damage;
    public ArcadeEntity bulletImpact;
}
public class ChippyMainCharacter : SpriteArcadeEntity {
    public float speed;
    public float maxSpeed;
    public ChippyBulletEntity bulletPrefab;
    public float fireRate;
    public Vector3 aimDir;
}
public class ChippyMoveTest : MonoBehaviour {
    public Vector3 heading;
    public float speed;
    public float maxSpeed;
    private void FixedUpdate();
}
public class ChristmasTree : StorageContainer {
    public GameObject[] decorations;
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
}
public class CinematicDialog : UIDialog {
    public CanvasGroup FullFadeGroup;
}
public class CinematicEntity : BaseEntity {
    private static Flags HideMesh;
    private static Flags HideMesh2;
    private static Flags HideMesh3;
    private static Flags HideMesh4;
    public List`1<DisableGroup> DisableObjects;
    private static List`1<CinematicEntity> serverList;
    private static CinematicEntity();
    public virtual void ServerInit();
    [ServerVar]
public static void HideObjects(Arg args);
    public virtual void DestroyShared();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    private void ToggleObjects(bool state);
    public static void HideObjectShared(Arg args, List`1<CinematicEntity> entList);
}
public class CinematicScenePlaybackEntity : BaseEntity {
    public Animator RootAnimator;
    public GameObjectRef CinematicUI;
    public float Duration;
    public GameObject DebugRoot;
    public bool ShowDebugRoot;
    public Transform LookPosition;
    public bool UseCinemachineBrain;
    public bool HidePlayerLegs;
    public float FadeToBlackTime;
    private EntityRef`1<BasePlayer> currentPlayer;
    public void SignalKillPlayer();
    public void SignalFadeToBlack();
    public void AssignPlayer(BasePlayer bp);
    public virtual void ServerInit();
    private void Timeout();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ClanAsyncResult`1 : object {
    private List`1<Action`1<T>> _callbacks;
    private Stopwatch _sinceStarted;
    private bool _isComplete;
    private T _result;
    public bool IsStarted { get; }
    public float Elapsed { get; }
    public bool IsComplete { get; }
    public bool get_IsStarted();
    public float get_Elapsed();
    public bool get_IsComplete();
    public void Start();
    public bool TrySetResult(T result);
    public void OnComplete(Action`1<T> callback);
    private void Reset();
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
}
public class ClanChangeTracker : object {
    private ClanManager _clanManager;
    private List`1<ClanChangedEvent> _clanChangedEvents;
    private List`1<ClanDisbandedEvent> _clanDisbandedEvents;
    private List`1<InvitationCreatedEvent> _invitationCreatedEvents;
    private List`1<MembershipChangedEvent> _membershipChangedEvents;
    private List`1<ChatMessageEvent> _chatMessageEvents;
    public ClanChangeTracker(ClanManager clanManager);
    public void HandleEvents();
    private void HandleClanChanged(ClanChangedEvent& data);
    private void HandleClanDisbanded(ClanDisbandedEvent& data);
    private void HandleInvitationCreated(InvitationCreatedEvent& data);
    private void HandleMembershipChanged(MembershipChangedEvent& data);
    private void HandleChatMessageEvent(ChatMessageEvent& data);
    public sealed virtual void ClanChanged(long clanId, ClanDataSource dataSources);
    public sealed virtual void ClanDisbanded(long clanId);
    public sealed virtual void InvitationCreated(ulong steamId, long clanId);
    public sealed virtual void MembershipChanged(ulong steamId, Nullable`1<long> clanId);
    public sealed virtual void ClanChatMessage(long clanId, ClanChatEntry entry);
}
[ExtensionAttribute]
public static class ClanInfoExtensions : object {
    [ExtensionAttribute]
public static ClanInfo ToProto(IClan clan);
    [ExtensionAttribute]
private static Role ToProto(ClanRole role);
    [ExtensionAttribute]
public static ClanRole FromProto(Role proto);
    [ExtensionAttribute]
private static Member ToProto(ClanMember member);
    [ExtensionAttribute]
private static Invite ToProto(ClanInvite invite);
}
[ExtensionAttribute]
public static class ClanInvitationExtensions : object {
    [ExtensionAttribute]
public static ClanInvitations ToProto(List`1<ClanInvitation> invitations);
    [ExtensionAttribute]
public static Invitation ToProto(ClanInvitation invitation);
}
[ExtensionAttribute]
public static class ClanLeaderboardExtensions : object {
    [ExtensionAttribute]
public static ClanLeaderboard ToProto(List`1<ClanLeaderboardEntry> leaderboard);
    [ExtensionAttribute]
public static Entry ToProto(ClanLeaderboardEntry entry);
}
[ExtensionAttribute]
public static class ClanLogExtensions : object {
    [ExtensionAttribute]
public static ClanLog ToProto(ClanLogs clanLogs);
    [ExtensionAttribute]
public static ClanScoreEvents ToProto(ClanScoreEvents clanScoreEvents);
}
public class ClanManager : BaseEntity {
    private RealTimeSince _sinceLastLeaderboardUpdate;
    private List`1<ClanLeaderboardEntry> _leaderboardCache;
    public static TokenisedPhrase InvitationToast;
    public static int LogoSize;
    [CompilerGeneratedAttribute]
private static ClanManager <ServerInstance>k__BackingField;
    private string _backendType;
    private ClanChangeTracker _changeTracker;
    [CompilerGeneratedAttribute]
private IClanBackend <Backend>k__BackingField;
    private static int MaxMetadataRequestsPerSecond;
    private static float MaxMetadataRequestInterval;
    private static float MetadataExpiry;
    private Dictionary`2<long, List`1<Connection>> _clanMemberConnections;
    public static ClanManager ServerInstance { get; private set; }
    public IClanBackend Backend { get; private set; }
    private static ClanManager();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CallsPerSecond("3")]
[RPC_Server]
[AsyncStateMachineAttribute("ClanManager/<Server_CreateClan>d__1")]
public void Server_CreateClan(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_GetClan>d__2")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_GetClan(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_GetLogs>d__3")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_GetLogs(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_GetScoreEvents>d__4")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_GetScoreEvents(RPCMessage msg);
    [CallsPerSecond("3")]
[RPC_Server]
[AsyncStateMachineAttribute("ClanManager/<Server_GetInvitations>d__5")]
public void Server_GetInvitations(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_GetLeaderboard>d__8")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_GetLeaderboard(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_SetLogo>d__9")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_SetLogo(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_SetColor>d__10")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_SetColor(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_SetMotd>d__11")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_SetMotd(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("3")]
[AsyncStateMachineAttribute("ClanManager/<Server_Invite>d__12")]
public void Server_Invite(RPCMessage msg);
    [CallsPerSecond("3")]
[AsyncStateMachineAttribute("ClanManager/<Server_CancelInvite>d__13")]
[RPC_Server]
public void Server_CancelInvite(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_AcceptInvitation>d__14")]
[CallsPerSecond("3")]
[RPC_Server]
public void Server_AcceptInvitation(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_CancelInvitation>d__15")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_CancelInvitation(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_Kick>d__16")]
[CallsPerSecond("3")]
[RPC_Server]
public void Server_Kick(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_SetPlayerRole>d__17")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_SetPlayerRole(RPCMessage msg);
    [RPC_Server]
[AsyncStateMachineAttribute("ClanManager/<Server_SetPlayerNotes>d__18")]
[CallsPerSecond("3")]
public void Server_SetPlayerNotes(RPCMessage msg);
    [CallsPerSecond("3")]
[AsyncStateMachineAttribute("ClanManager/<Server_CreateRole>d__19")]
[RPC_Server]
public void Server_CreateRole(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_UpdateRole>d__20")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_UpdateRole(RPCMessage msg);
    [RPC_Server]
[AsyncStateMachineAttribute("ClanManager/<Server_DeleteRole>d__21")]
[CallsPerSecond("3")]
public void Server_DeleteRole(RPCMessage msg);
    [AsyncStateMachineAttribute("ClanManager/<Server_SwapRoles>d__22")]
[RPC_Server]
[CallsPerSecond("3")]
public void Server_SwapRoles(RPCMessage msg);
    private bool CheckClanResult(int requestId, BasePlayer player, ClanValueResult`1<IClan> result, IClan& clan);
    private static ClanActionResult BuildActionResult(int requestId, ClanResult result, IClan clan, bool hasClanInfo);
    [CompilerGeneratedAttribute]
public static ClanManager get_ServerInstance();
    [CompilerGeneratedAttribute]
private static void set_ServerInstance(ClanManager value);
    [CompilerGeneratedAttribute]
public IClanBackend get_Backend();
    [CompilerGeneratedAttribute]
private void set_Backend(IClanBackend value);
    [AsyncStateMachineAttribute("ClanManager/<Initialize>d__37")]
public Task Initialize();
    public void Shutdown();
    public virtual void Spawn();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    private static string ChooseBackendType();
    private static IClanBackend CreateBackendInstance(string type);
    public virtual void InitShared();
    public void OnDestroy();
    [CallsPerSecond("3")]
[RPC_Server]
[AsyncStateMachineAttribute("ClanManager/<Server_GetClanMetadata>d__49")]
public void Server_GetClanMetadata(RPCMessage msg);
    public void AddScore(IClan clan, ClanScoreEvent entry);
    public void SendClanChanged(IClan clan);
    public void SendClanInvitation(ulong steamId, long clanId);
    public bool TryGetClanMemberConnections(long clanId, List`1& connections);
    public void ClanMemberConnectionsChanged(long clanId);
    [AsyncStateMachineAttribute("ClanManager/<LoadClanInfoForSleepers>d__56")]
public void LoadClanInfoForSleepers();
    [CompilerGeneratedAttribute]
private void <Initialize>b__37_0();
    [CompilerGeneratedAttribute]
private void <Spawn>b__39_0();
}
public class ClanMetadata : ValueType {
    public long ClanId;
    public string Name;
    public int Members;
    public Color32 Color;
}
public static class ClanPushNotifications : object {
    [AsyncStateMachineAttribute("ClanPushNotifications/<SendClanAnnouncement>d__0")]
public static void SendClanAnnouncement(IClan clan, long previousTimestamp, ulong ignorePlayer);
}
public class ClanTable : BaseCombatEntity {
}
public class Client : SingletonComponent`1<Client> {
    public static Phrase loading_loading;
    public static Phrase loading_connecting;
    public static Phrase loading_connectionaccepted;
    public static Phrase loading_connecting_negotiate;
    public static Phrase loading_level;
    public static Phrase loading_skinnablewarmup;
    public static Phrase loading_preloadcomplete;
    public static Phrase loading_openingscene;
    public static Phrase loading_clientready;
    public static Phrase loading_prefabwarmup;
    private static Client();
}
[JsonModelAttribute]
public class ClientFrametimeReport : object {
    public int request_id;
    public int start_frame;
    public List`1<int> frame_times;
}
[JsonModelAttribute]
public class ClientFrametimeRequest : object {
    public int request_id;
    public int start_frame;
    public int max_frames;
}
public class ClientIOLine : BaseMonoBehaviour {
    public LineRenderer _line;
    public NotifyLOD lod;
    public Material directionalMaterial;
    public Material defaultMaterial;
    public IOType lineType;
    public WireColour colour;
    public static List`1<ClientIOLine> allLines;
    public IOEntity ownerIOEnt;
    private static ClientIOLine();
}
public class ClientIOLine_Pipe : ClientIOLine {
    public NotifyLOD NotifyLod;
    public PipeMesh PipeRenderer;
}
public class ClientIOLineParent : FacepunchBehaviour {
    public AnimatedBuildingBlock parentEntity;
    public string boneName;
    public bool ignoreForPlugConnections;
}
[JsonModelAttribute]
public class ClientPerformanceReport : ValueType {
    public int request_id;
    public string user_id;
    public float fps_average;
    public int fps;
    public int frame_id;
    public float frame_time;
    public float frame_time_average;
    public long memory_system;
    public long memory_collections;
    public long memory_managed_heap;
    public float realtime_since_startup;
    public bool streamer_mode;
    public int ping;
    public int tasks_invokes;
    public int tasks_load_balancer;
    public int workshop_skins_queued;
}
public class Climate : SingletonComponent`1<Climate> {
    private static float fadeAngle;
    private static float defaultTemp;
    private static int weatherDurationHours;
    private static int weatherFadeHours;
    [RangeAttribute("0", "1")]
public float BlendingSpeed;
    [RangeAttribute("1", "9")]
public float FogMultiplier;
    public float FogDarknessDistance;
    public bool DebugLUTBlending;
    public WeatherParameters Weather;
    public WeatherPreset[] WeatherPresets;
    public ClimateParameters Arid;
    public ClimateParameters Temperate;
    public ClimateParameters Tundra;
    public ClimateParameters Arctic;
    [CompilerGeneratedAttribute]
private float <WeatherStateBlend>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WeatherSeedPrevious>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WeatherSeedTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WeatherSeedNext>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherStatePrevious>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherStateTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherStateNext>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherState>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherClampsMin>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherClampsMax>k__BackingField;
    [CompilerGeneratedAttribute]
private WeatherPreset <WeatherOverrides>k__BackingField;
    [CompilerGeneratedAttribute]
private LegacyWeatherState <Overrides>k__BackingField;
    public Dictionary`2<WeatherPresetType, WeatherPreset[]> presetLookup;
    private ClimateParameters[] climateLookup;
    public float WeatherStateBlend { get; public set; }
    public UInt32 WeatherSeedPrevious { get; public set; }
    public UInt32 WeatherSeedTarget { get; public set; }
    public UInt32 WeatherSeedNext { get; public set; }
    public WeatherPreset WeatherStatePrevious { get; public set; }
    public WeatherPreset WeatherStateTarget { get; public set; }
    public WeatherPreset WeatherStateNext { get; public set; }
    public WeatherPreset WeatherState { get; public set; }
    public WeatherPreset WeatherClampsMin { get; private set; }
    public WeatherPreset WeatherClampsMax { get; private set; }
    public WeatherPreset WeatherOverrides { get; public set; }
    public LegacyWeatherState Overrides { get; public set; }
    [CompilerGeneratedAttribute]
public float get_WeatherStateBlend();
    [CompilerGeneratedAttribute]
public void set_WeatherStateBlend(float value);
    [CompilerGeneratedAttribute]
public UInt32 get_WeatherSeedPrevious();
    [CompilerGeneratedAttribute]
public void set_WeatherSeedPrevious(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_WeatherSeedTarget();
    [CompilerGeneratedAttribute]
public void set_WeatherSeedTarget(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_WeatherSeedNext();
    [CompilerGeneratedAttribute]
public void set_WeatherSeedNext(UInt32 value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherStatePrevious();
    [CompilerGeneratedAttribute]
public void set_WeatherStatePrevious(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherStateTarget();
    [CompilerGeneratedAttribute]
public void set_WeatherStateTarget(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherStateNext();
    [CompilerGeneratedAttribute]
public void set_WeatherStateNext(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherState();
    [CompilerGeneratedAttribute]
public void set_WeatherState(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherClampsMin();
    [CompilerGeneratedAttribute]
private void set_WeatherClampsMin(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherClampsMax();
    [CompilerGeneratedAttribute]
private void set_WeatherClampsMax(WeatherPreset value);
    [CompilerGeneratedAttribute]
public WeatherPreset get_WeatherOverrides();
    [CompilerGeneratedAttribute]
public void set_WeatherOverrides(WeatherPreset value);
    [CompilerGeneratedAttribute]
public LegacyWeatherState get_Overrides();
    [CompilerGeneratedAttribute]
public void set_Overrides(LegacyWeatherState value);
    protected virtual void Awake();
    protected virtual void OnDestroy();
    public void Update();
    private static bool Initialized();
    public static float GetClouds(Vector3 position);
    public static float GetFog(Vector3 position);
    public static float GetWind(Vector3 position);
    public static float GetThunder(Vector3 position);
    public static float GetRainbow(Vector3 position);
    public static float GetAurora(Vector3 position);
    public static float GetRain(Vector3 position);
    public static float GetSnow(Vector3 position);
    public static float GetTemperature(Vector3 position);
    private UInt32 GetSeedFromLong(long val);
    private WeatherPreset GetWeatherPreset(UInt32 seed);
    private WeatherPreset GetWeatherPreset(UInt32 seed, WeatherPresetType type);
    public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type);
    private float FindBlendParameters(Vector3 pos, ClimateParameters& src, ClimateParameters& dst);
}
public class ClimateBlendTexture : ProcessedTexture {
    public ClimateBlendTexture(int width, int height, bool linear);
    public bool CheckLostData();
    public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time);
    public static void Swap(ClimateBlendTexture& a, ClimateBlendTexture& b);
}
public class ClimateOverlay : MonoBehaviour {
    [RangeAttribute("0", "1")]
public float blendingSpeed;
    public PostProcessVolume[] biomeVolumes;
}
public class ClothingBenchmarkScene : BenchmarkScene {
    public GameObjectRef PlayerModelPrefab;
    public bool ChangeClothingEveryFrame;
}
[CreateAssetMenuAttribute]
public class ClothingMovementProperties : ScriptableObject {
    public float speedReduction;
    [TooltipAttribute("If this piece of clothing is worn movement speed will be reduced by atleast this much")]
public float minSpeedReduction;
    public float waterSpeedBonus;
}
public class ClothLOD : FacepunchBehaviour {
    [ServerVar]
public static float clothLODDist;
    public Cloth cloth;
    private static ClothLOD();
}
public class ClothWindModify : FacepunchBehaviour {
    public Cloth cloth;
    private Vector3 initialClothForce;
    public Vector3 worldWindScale;
    public Vector3 turbulenceScale;
}
public class CoalingTower : IOEntity {
    [SerializeField]
[HeaderAttribute("Coaling Tower")]
private BoxCollider unloadingBounds;
    [SerializeField]
private GameObjectRef oreStoragePrefab;
    [SerializeField]
private GameObjectRef fuelStoragePrefab;
    [SerializeField]
private MeshRenderer[] signalLightsExterior;
    [SerializeField]
private MeshRenderer[] signalLightsInterior;
    [ColorUsageAttribute("False", "True")]
public Color greenLightOnColour;
    [ColorUsageAttribute("False", "True")]
public Color yellowLightOnColour;
    [SerializeField]
private Animator vacuumAnimator;
    [SerializeField]
private float vacuumStartDelay;
    [SerializeField]
[FormerlySerializedAsAttribute("unloadingFXContainer")]
private ParticleSystemContainer unloadingFXContainerOre;
    [SerializeField]
private ParticleSystem[] unloadingFXMain;
    [SerializeField]
private ParticleSystem[] unloadingFXDust;
    [SerializeField]
private ParticleSystemContainer unloadingFXContainerFuel;
    [HeaderAttribute("Coaling Tower Text")]
[SerializeField]
private TokenisedPhrase noTraincar;
    [SerializeField]
private TokenisedPhrase noNextTraincar;
    [SerializeField]
private TokenisedPhrase noPrevTraincar;
    [SerializeField]
private TokenisedPhrase trainIsMoving;
    [SerializeField]
private TokenisedPhrase outputIsFull;
    [SerializeField]
private TokenisedPhrase trainHasThrottle;
    [HeaderAttribute("Coaling Tower Audio")]
[SerializeField]
private GameObject buttonSoundPos;
    [SerializeField]
private SoundDefinition buttonPressSound;
    [SerializeField]
private SoundDefinition buttonReleaseSound;
    [SerializeField]
private SoundDefinition failedActionSound;
    [SerializeField]
private SoundDefinition failedShuntAlarmSound;
    [SerializeField]
private SoundDefinition armMovementLower;
    [SerializeField]
private SoundDefinition armMovementRaise;
    [SerializeField]
private SoundDefinition suctionAirStart;
    [SerializeField]
private SoundDefinition suctionAirStop;
    [SerializeField]
private SoundDefinition suctionAirLoop;
    [SerializeField]
private SoundDefinition suctionOreStart;
    [SerializeField]
private SoundDefinition suctionOreLoop;
    [SerializeField]
private SoundDefinition suctionOreStop;
    [SerializeField]
private SoundDefinition suctionOreInteriorLoop;
    [SerializeField]
private SoundDefinition oreBinLoop;
    [SerializeField]
private SoundDefinition suctionFluidStart;
    [SerializeField]
private SoundDefinition suctionFluidLoop;
    [SerializeField]
private SoundDefinition suctionFluidStop;
    [SerializeField]
private SoundDefinition suctionFluidInteriorLoop;
    [SerializeField]
private SoundDefinition fluidTankLoop;
    [SerializeField]
private GameObject interiorPipeSoundLocation;
    [SerializeField]
private GameObject armMovementSoundLocation;
    [SerializeField]
private GameObject armSuctionSoundLocation;
    [SerializeField]
private GameObject oreBinSoundLocation;
    [SerializeField]
private GameObject fluidTankSoundLocation;
    private NetworkedProperty`1<int> LootTypeIndex;
    private EntityRef`1<TrainCar> activeTrainCarRef;
    private EntityRef`1<TrainCarUnloadable> activeUnloadableRef;
    private static Flags LinedUpFlag;
    private static Flags HasUnloadableFlag;
    private static Flags UnloadingInProgressFlag;
    private static Flags MoveToNextInProgressFlag;
    private static Flags MoveToPrevInProgressFlag;
    private EntityRef`1<OreHopper> oreStorageInstance;
    private EntityRef`1<PercentFullStorageContainer> fuelStorageInstance;
    public static float TIME_TO_EMPTY;
    [CompilerGeneratedAttribute]
private Vector3 <UnloadingPos>k__BackingField;
    private static List`1<CoalingTower> unloadersInWorld;
    private Sound armMovementLoopSound;
    private Sound suctionAirLoopSound;
    private Sound suctionMaterialLoopSound;
    private Sound interiorPipeLoopSound;
    private Sound unloadDestinationSound;
    private TrainCarUnloadable tcUnloadingNow;
    private bool HasTrainCar { get; }
    private bool HasUnloadable { get; }
    private bool HasUnloadableLinedUp { get; }
    public Vector3 UnloadingPos { get; private set; }
    private static CoalingTower();
    private bool get_HasTrainCar();
    private bool get_HasUnloadable();
    private bool get_HasUnloadableLinedUp();
    [CompilerGeneratedAttribute]
public Vector3 get_UnloadingPos();
    [CompilerGeneratedAttribute]
private void set_UnloadingPos(Vector3 value);
    public virtual void InitShared();
    public virtual void DestroyShared();
    public virtual void Load(LoadInfo info);
    public static bool IsUnderAnUnloader(TrainCar trainCar, Boolean& isLinedUp, Vector3& unloaderPos);
    public bool TrainCarIsUnder(TrainCar trainCar, Boolean& isLinedUp);
    private OreHopper GetOreStorage();
    private PercentFullStorageContainer GetFuelStorage();
    private TrainCar GetActiveTrainCar();
    private TrainCarUnloadable GetActiveUnloadable();
    private bool OutputBinIsFull();
    private bool WagonIsEmpty();
    private bool CanUnloadNow(ActionAttemptStatus& attemptStatus);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    protected virtual void OnChildAdded(BaseEntity child);
    public void OnEmpty();
    public sealed virtual void OnEntityEnter(BaseEntity ent);
    public sealed virtual void OnEntityLeave(BaseEntity ent);
    private void SetActiveTrainCar(TrainCar trainCar);
    private void ClearActiveTrainCar();
    private void CheckWagonLinedUp();
    private void CheckWagonLinedUp(bool networkUpdate);
    private bool TryUnloadActiveWagon(ActionAttemptStatus& attemptStatus);
    private void WagonBeginUnloadAnim();
    private void EmptyTenPercent();
    private void EndEmptyProcess(ActionAttemptStatus status);
    private bool TryShuntTrain(bool next, ActionAttemptStatus& attemptStatus);
    private void ShuntEnded(ActionAttemptStatus status);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Unload(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Next(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Prev(RPCMessage msg);
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class CodeLock : BaseLock {
    public GameObjectRef keyEnterDialog;
    public GameObjectRef effectUnlocked;
    public GameObjectRef effectLocked;
    public GameObjectRef effectDenied;
    public GameObjectRef effectCodeChanged;
    public GameObjectRef effectShock;
    public bool hasCode;
    public static Flags Flag_CodeEntryBlocked;
    public static Phrase blockwarning;
    [ServerVar]
public static float maxFailedAttempts;
    [ServerVar]
public static float lockoutCooldown;
    public bool hasGuestCode;
    public string code;
    public string guestCode;
    public List`1<ulong> whitelistPlayers;
    public List`1<ulong> guestPlayers;
    public int wrongCodes;
    public float lastWrongTime;
    private static CodeLock();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsCodeEntryBlocked();
    public virtual void Load(LoadInfo info);
    internal void DoEffect(string effect);
    public virtual bool OnTryToOpen(BasePlayer player);
    public virtual bool OnTryToClose(BasePlayer player);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_ChangeCode(RPCMessage rpc);
    [MaxDistance("3")]
[RPC_Server]
private void TryUnlock(RPCMessage rpc);
    [RPC_Server]
[MaxDistance("3")]
private void TryLock(RPCMessage rpc);
    public void ClearCodeEntryBlocked();
    [MaxDistance("3")]
[RPC_Server]
private void UnlockWithCode(RPCMessage rpc);
    public virtual void PostServerLoad();
}
public class ColdBreath : BaseMonoBehaviour {
    public GameObjectRef effect;
    private BasePlayer player;
    private Transform jawBone;
}
public class ColdOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public float smoothTime;
    public bool preventInstantiation;
}
public class CollateTrainTracks : ProceduralComponent {
    private static float MAX_NODE_DIST;
    private static float MAX_NODE_DIST_SQR;
    private static float MAX_NODE_ANGLE;
    public bool RunOnCache { get; }
    public virtual bool get_RunOnCache();
    public virtual void Process(UInt32 seed);
    [CompilerGeneratedAttribute]
internal static bool <Process>g__CompareNodes|5_1(Vector3 theirPos, Vector3 theirTangent, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& , <>c__DisplayClass5_2& );
    [CompilerGeneratedAttribute]
internal static bool <Process>g__CompareNodes|5_2(bool ourStart, bool theirStart, <>c__DisplayClass5_3& , <>c__DisplayClass5_4& , <>c__DisplayClass5_5& , <>c__DisplayClass5_6& );
    [CompilerGeneratedAttribute]
internal static bool <Process>g__NodesConnect|5_0(Vector3 ourPos, Vector3 theirPos, Vector3 ourTangent, Vector3 theirTangent);
}
public class CollectableEasterEgg : BaseEntity {
    public Transform artwork;
    public float bounceRange;
    public float bounceSpeed;
    public GameObjectRef pickupEffect;
    public ItemDefinition itemToGive;
    public RotateObject rotateObject;
    public Renderer vfx;
    public ulong ownerUserID;
    private float lastPickupStartTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    [RPC_Server]
[IsVisible("3")]
public void RPC_StartPickUp(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_PickUp(RPCMessage msg);
}
public class CollectibleEntity : BaseEntity {
    public static Phrase EatTitle;
    public Phrase itemName;
    public ItemAmount[] itemList;
    public GameObjectRef pickupEffect;
    public float xpScale;
    private static CollectibleEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsFood(bool checkConsumeMod);
    public void DoPickup(BasePlayer reciever, bool eat);
    [RPC_Server]
[MaxDistance("3")]
public void Pickup(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void PickupEat(RPCMessage msg);
    public bool HasItem(ItemDefinition def);
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
[ExtensionAttribute]
public static class CollectionEx : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> collection);
}
[ObsoleteAttribute]
public class ColliderBatch : MonoBehaviour {
}
public class ColliderInfo : MonoBehaviour {
    public static Flags FlagsNone;
    public static Flags FlagsEverything;
    public static Flags FlagsDefault;
    [InspectorFlagsAttribute]
public Flags flags;
    public bool HasFlag(Flags f);
    public void SetFlag(Flags f, bool b);
    public bool Filter(HitTest info);
}
public class ColliderInfo_Pipe : ColliderInfo {
    public int OutputSlotIndex;
    public IOEntity ParentEntity;
}
public class CombatLog : object {
    private static string selfname;
    private static string noname;
    private BasePlayer player;
    private Queue`1<Event> storage;
    [CompilerGeneratedAttribute]
private float <LastActive>k__BackingField;
    private static Dictionary`2<ulong, Queue`1<Event>> players;
    public float LastActive { get; private set; }
    public CombatLog(BasePlayer player);
    private static CombatLog();
    [CompilerGeneratedAttribute]
public float get_LastActive();
    [CompilerGeneratedAttribute]
private void set_LastActive(float value);
    public void Init();
    public void Save();
    public void LogInvalid(BasePlayer player, AttackEntity weapon, string description);
    public void LogInvalid(HitInfo info, string description);
    public void LogAttack(HitInfo info, string description, float oldHealth);
    public void Log(BaseEntity attacker, AttackEntity weapon, BaseCombatEntity hitEntity, string description, Projectile projectilePrefab, int projectileId, float healthOld, HitInfo hitInfo);
    private void Log(Event val);
    public string Get(int count, NetworkableId filterByAttacker, bool json, bool isAdmin, ulong requestingUser);
    public static Queue`1<Event> Get(ulong id);
}
public class CommandBufferDesc : object {
    [CompilerGeneratedAttribute]
private CameraEvent <CameraEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrderId>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<CommandBuffer> <FillDelegate>k__BackingField;
    public CameraEvent CameraEvent { get; private set; }
    public int OrderId { get; private set; }
    public Action`1<CommandBuffer> FillDelegate { get; private set; }
    public CommandBufferDesc(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill);
    [CompilerGeneratedAttribute]
public CameraEvent get_CameraEvent();
    [CompilerGeneratedAttribute]
private void set_CameraEvent(CameraEvent value);
    [CompilerGeneratedAttribute]
public int get_OrderId();
    [CompilerGeneratedAttribute]
private void set_OrderId(int value);
    [CompilerGeneratedAttribute]
public Action`1<CommandBuffer> get_FillDelegate();
    [CompilerGeneratedAttribute]
private void set_FillDelegate(Action`1<CommandBuffer> value);
}
[ExtensionAttribute]
public static class CommandBufferEx : object {
    [ExtensionAttribute]
public static void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass);
    [ExtensionAttribute]
public static void BlitArray(CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass);
    [ExtensionAttribute]
public static void BlitArrayMip(CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass);
    [ExtensionAttribute]
public static void BlitMip(CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass);
}
[RequireComponent("UnityEngine.Camera")]
[ExecuteInEditMode]
public class CommandBufferManager : MonoBehaviour {
}
public class CommentComponent : MonoBehaviour {
    [TextAreaAttribute]
public string comment;
}
public class CommunityEntity : PointEntity {
    public static CommunityEntity ServerInstance;
    public static CommunityEntity ClientInstance;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void InitShared();
    public virtual void DestroyShared();
}
[ExtensionAttribute]
public static class CompanionServer.AppPlayerExtensions : object {
    [ExtensionAttribute]
public static AppTeamInfo GetAppTeamInfo(BasePlayer player, ulong steamId);
    [ExtensionAttribute]
public static AppTeamInfo GetAppTeamInfo(PlayerTeam team, ulong requesterSteamId);
    private static List`1<Note> GetMapNotes(ulong playerId, bool personalNotes);
    private static void AddMapNote(List`1<Note> result, MapNote note, MapNoteType type);
}
public class CompanionServer.BanList`1 : object {
    private Dictionary`2<TKey, double> _bans;
    public void Ban(TKey key, double timeInSeconds);
    public bool IsBanned(TKey key);
    public void Cleanup();
}
public class CompanionServer.CameraRendererManager : SingletonComponent`1<CameraRendererManager> {
    private Stack`1<CameraRenderTask> _taskPool;
    private int _tasksTaken;
    private int _tasksReturned;
    private int _tasksCreated;
    private Stopwatch _stopwatch;
    private List`1<CameraRenderer> _renderers;
    private int _renderIndex;
    private int _completeIndex;
    protected virtual void OnDestroy();
    public void StartRendering(IRemoteControllable rc);
    public void Tick();
    public CameraRenderTask BorrowTask();
    public void ReturnTask(CameraRenderTask& task);
    [ServerVar]
public static void pool_stats(Arg arg);
    private void DispatchRenderers();
    private void CompleteRenderers();
    private void CleanupRenderers();
}
[ExtensionAttribute]
internal static class CompanionServer.Cameras.CameraBurstUtil : object {
    [ExtensionAttribute]
public static int GetColliderId(RaycastHit hit);
    public static Collider GetCollider(int colliderInstanceId);
}
public class CompanionServer.Cameras.CameraRenderer : object {
    [ServerVar]
public static bool enabled;
    [ServerVar]
public static float completionFrameBudgetMs;
    [ServerVar]
public static int maxRendersPerFrame;
    [ServerVar]
public static int maxRaysPerFrame;
    [ServerVar]
public static int width;
    [ServerVar]
public static int height;
    [ServerVar]
public static float verticalFov;
    [ServerVar]
public static float nearPlane;
    [ServerVar]
public static float farPlane;
    [ServerVar]
public static int layerMask;
    [ServerVar]
public static float renderInterval;
    [ServerVar]
public static int samplesPerRender;
    [ServerVar]
public static int entityMaxAge;
    [ServerVar]
public static int entityMaxDistance;
    [ServerVar]
public static int playerMaxDistance;
    [ServerVar]
public static int playerNameMaxDistance;
    private static Dictionary`2<NetworkableId, NetworkableId> _entityIdMap;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<int, ValueTuple`2<byte, int>> _knownColliders;
    private Dictionary`2<int, BaseEntity> _colliderToEntity;
    private double _lastRenderTimestamp;
    private float _fieldOfView;
    private int _sampleOffset;
    private int _nextSampleOffset;
    private int _sampleCount;
    private CameraRenderTask _task;
    private Nullable`1<ulong> _cachedViewerSteamId;
    private BasePlayer _cachedViewer;
    public CameraRendererState state;
    public IRemoteControllable rc;
    public BaseEntity entity;
    private static CameraRenderer();
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public void Reset();
    public void Init(IRemoteControllable remoteControllable);
    public bool CanRender();
    public void Render(int maxSampleCount);
    public void CompleteRender();
    private void UpdateCollidersMap(List`1<int> foundColliderIds);
    private static NetworkableId RandomizeEntityId(NetworkableId realId);
    private static byte GetMaterialIndex(PhysicMaterial material, BaseEntity entity);
}
public enum CompanionServer.Cameras.CameraRendererState : Enum {
    public int value__;
    public static CameraRendererState Invalid;
    public static CameraRendererState WaitingToRender;
    public static CameraRendererState Rendering;
}
public class CompanionServer.Cameras.CameraRenderTask : CustomYieldInstruction {
    public static int MaxSamplesPerRender;
    public static int MaxColliders;
    private static Dictionary`2<ValueTuple`2<int, int>, NativeArray`1<int2>> _samplePositions;
    private NativeArray`1<RaycastCommand> _raycastCommands;
    private NativeArray`1<RaycastHit> _raycastHits;
    private NativeArray`1<int> _colliderIds;
    private NativeArray`1<byte> _colliderMaterials;
    private NativeArray`1<int> _colliderHits;
    private NativeArray`1<int> _raycastOutput;
    private NativeArray`1<int> _foundCollidersLength;
    private NativeArray`1<int> _foundColliders;
    private NativeArray`1<int> _outputDataLength;
    private NativeArray`1<byte> _outputData;
    private Nullable`1<JobHandle> _pendingJob;
    private int _sampleCount;
    private int _colliderLength;
    public bool keepWaiting { get; }
    private static CameraRenderTask();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void Reset();
    public virtual bool get_keepWaiting();
    public int Start(int width, int height, float verticalFov, float nearPlane, float farPlane, int layerMask, Transform cameraTransform, int sampleCount, int sampleOffset, Dictionary`2<int, ValueTuple`2<byte, int>> knownColliders);
    public int ExtractRayData(Byte[] buffer, List`1<int> hitColliderIds, List`1<int> foundColliderIds);
    private static NativeArray`1<int2> GetSamplePositions(int width, int height);
    public static void FreeCachedSamplePositions();
}
public class CompanionServer.Cameras.RaycastBufferSetupJob : ValueType {
    public NativeArray`1<int> colliderIds;
    public NativeArray`1<byte> colliderMaterials;
    [WriteOnlyAttribute]
public NativeArray`1<int> colliderHits;
    public sealed virtual void Execute();
    private static void SortByAscending(NativeArray`1& colliderIds, NativeArray`1& colliderMaterials, int leftIndex, int rightIndex);
}
public class CompanionServer.Cameras.RaycastColliderProcessingJob : ValueType {
    public NativeArray`1<int> foundCollidersLength;
    public NativeArray`1<int> foundColliders;
    public sealed virtual void Execute();
    private static void SortByDescending(NativeArray`1& colliders, NativeArray`1& counts, int leftIndex, int rightIndex);
    private static void SortAscending(NativeArray`1& array, int leftIndex, int rightIndex);
}
public class CompanionServer.Cameras.RaycastOutputCompressJob : ValueType {
    [ReadOnlyAttribute]
public NativeArray`1<int> rayOutputs;
    [WriteOnlyAttribute]
public NativeArray`1<int> dataLength;
    [WriteOnlyAttribute]
public NativeArray`1<byte> data;
    public sealed virtual void Execute();
    private static ushort RayDistance(int ray);
    private static byte RayAlignment(int ray);
    private static byte RayMaterial(int ray);
}
public class CompanionServer.Cameras.RaycastRayProcessingJob : ValueType {
    public float3 cameraForward;
    public float farPlane;
    [ReadOnlyAttribute]
public NativeArray`1<RaycastHit> raycastHits;
    [ReadOnlyAttribute]
public NativeArray`1<int> colliderIds;
    [ReadOnlyAttribute]
public NativeArray`1<byte> colliderMaterials;
    [WriteOnlyAttribute]
[NativeDisableParallelForRestrictionAttribute]
public NativeArray`1<int> colliderHits;
    [WriteOnlyAttribute]
[NativeMatchesParallelForLengthAttribute]
public NativeArray`1<int> outputs;
    [NativeDisableParallelForRestrictionAttribute]
public NativeArray`1<int> foundCollidersIndex;
    [NativeDisableParallelForRestrictionAttribute]
public NativeArray`1<int> foundColliders;
    public sealed virtual void Execute(int index);
    private static int BinarySearch(NativeArray`1<int> haystack, int needle);
    private static int Compare(int x, int y);
}
public class CompanionServer.Cameras.RaycastRaySetupJob : ValueType {
    public float2 res;
    public float2 halfRes;
    public float aspectRatio;
    public float worldHeight;
    public float3 cameraPos;
    public quaternion cameraRot;
    public float nearPlane;
    public float farPlane;
    public int layerMask;
    public int sampleOffset;
    [ReadOnlyAttribute]
public NativeArray`1<int2> samplePositions;
    [WriteOnlyAttribute]
[NativeMatchesParallelForLengthAttribute]
public NativeArray`1<RaycastCommand> raycastCommands;
    public sealed virtual void Execute(int index);
}
public class CompanionServer.Cameras.RaycastSamplePositionsJob : ValueType {
    public int2 res;
    public Random random;
    public NativeArray`1<int2> positions;
    public sealed virtual void Execute();
}
[IsReadOnlyAttribute]
public class CompanionServer.CameraTarget : ValueType {
    [CompilerGeneratedAttribute]
private NetworkableId <EntityId>k__BackingField;
    public NetworkableId EntityId { get; }
    public CameraTarget(NetworkableId entityId);
    [CompilerGeneratedAttribute]
public NetworkableId get_EntityId();
    public sealed virtual bool Equals(CameraTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CameraTarget left, CameraTarget right);
    public static bool op_Inequality(CameraTarget left, CameraTarget right);
}
public class CompanionServer.ChatLog : object {
    private static int MaxBacklog;
    private Dictionary`2<ulong, ChatState> States;
    public void Record(ulong teamId, ulong steamId, string name, string message, string color, UInt32 time);
    public void Remove(ulong teamId);
    public IReadOnlyList`1<Entry> GetHistory(ulong teamId);
}
public class CompanionServer.ClanTarget : ValueType {
    [CompilerGeneratedAttribute]
private long <ClanId>k__BackingField;
    public long ClanId { get; }
    public ClanTarget(long clanId);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public long get_ClanId();
    public sealed virtual bool Equals(ClanTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ClanTarget left, ClanTarget right);
    public static bool op_Inequality(ClanTarget left, ClanTarget right);
}
public class CompanionServer.Connection : object {
    private static MemoryStream MessageStream;
    private Listener _listener;
    private IWebSocketConnection _connection;
    private Nullable`1<PlayerTarget> _subscribedPlayer;
    private HashSet`1<EntityTarget> _subscribedEntities;
    private HashSet`1<ClanTarget> _subscribedClans;
    private IRemoteControllable _currentCamera;
    private ulong _cameraViewerSteamId;
    private bool _isControllingCamera;
    [CompilerGeneratedAttribute]
private long <ConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private InputState <InputState>k__BackingField;
    public long ConnectionId { get; private set; }
    public IPAddress Address { get; }
    public IRemoteControllable CurrentCamera { get; }
    public bool IsControllingCamera { get; }
    public ulong ControllingSteamId { get; }
    public InputState InputState { get; public set; }
    public Connection(long connectionId, Listener listener, IWebSocketConnection connection);
    private static Connection();
    [CompilerGeneratedAttribute]
public sealed virtual long get_ConnectionId();
    [CompilerGeneratedAttribute]
private void set_ConnectionId(long value);
    public IPAddress get_Address();
    public void OnClose();
    public void OnMessage(Span`1<byte> data);
    public void Close();
    public sealed virtual void Send(AppResponse response);
    public sealed virtual void Subscribe(PlayerTarget target);
    public sealed virtual void Subscribe(EntityTarget target);
    public sealed virtual IRemoteControllable get_CurrentCamera();
    public sealed virtual bool get_IsControllingCamera();
    public sealed virtual ulong get_ControllingSteamId();
    [CompilerGeneratedAttribute]
public sealed virtual InputState get_InputState();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InputState(InputState value);
    public sealed virtual bool BeginViewing(IRemoteControllable camera);
    public sealed virtual void EndViewing();
    public sealed virtual void Subscribe(ClanTarget target);
    public sealed virtual void Unsubscribe(ClanTarget target);
    public void SendRaw(MemoryBuffer data);
    private static bool TryGetCameraTarget(IRemoteControllable camera, CameraTarget& target);
}
public class CompanionServer.ConnectionLimiter : object {
    private object _sync;
    private Dictionary`2<IPAddress, int> _addressCounts;
    private int _overallCount;
    public bool TryAdd(IPAddress address);
    public void Remove(IPAddress address);
    public void Clear();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class CompanionServer.EntityTarget : ValueType {
    [CompilerGeneratedAttribute]
private NetworkableId <EntityId>k__BackingField;
    public NetworkableId EntityId { get; }
    public EntityTarget(NetworkableId entityId);
    [CompilerGeneratedAttribute]
public NetworkableId get_EntityId();
    public sealed virtual bool Equals(EntityTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EntityTarget left, EntityTarget right);
    public static bool op_Inequality(EntityTarget left, EntityTarget right);
}
public abstract class CompanionServer.Handlers.BaseClanHandler`1 : BasePlayerHandler`1<T> {
    [CompilerGeneratedAttribute]
private IClanBackend <ClanBackend>k__BackingField;
    protected IClanBackend ClanBackend { get; private set; }
    [CompilerGeneratedAttribute]
protected IClanBackend get_ClanBackend();
    [CompilerGeneratedAttribute]
private void set_ClanBackend(IClanBackend value);
    [AsyncStateMachineAttribute("CompanionServer.Handlers.BaseClanHandler`1/<GetClan>d__4")]
protected ValueTask`1<IClan> GetClan();
    public virtual void EnterPool();
    public virtual ValidationResult Validate();
    protected void SendError(ClanResult result);
    private static string GetErrorString(ClanResult result);
}
public abstract class CompanionServer.Handlers.BaseEntityHandler`1 : BasePlayerHandler`1<T> {
    [CompilerGeneratedAttribute]
private AppIOEntity <Entity>k__BackingField;
    protected AppIOEntity Entity { get; private set; }
    [CompilerGeneratedAttribute]
protected AppIOEntity get_Entity();
    [CompilerGeneratedAttribute]
private void set_Entity(AppIOEntity value);
    public virtual void EnterPool();
    public virtual ValidationResult Validate();
}
public abstract class CompanionServer.Handlers.BaseHandler`1 : object {
    [CompilerGeneratedAttribute]
private TokenBucketList`1<ulong> <PlayerBuckets>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnection <Client>k__BackingField;
    [CompilerGeneratedAttribute]
private AppRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Proto>k__BackingField;
    protected TokenBucketList`1<ulong> PlayerBuckets { get; private set; }
    protected double TokenCost { get; }
    public IConnection Client { get; private set; }
    public AppRequest Request { get; private set; }
    public T Proto { get; private set; }
    [CompilerGeneratedAttribute]
protected TokenBucketList`1<ulong> get_PlayerBuckets();
    [CompilerGeneratedAttribute]
private void set_PlayerBuckets(TokenBucketList`1<ulong> value);
    protected virtual double get_TokenCost();
    [CompilerGeneratedAttribute]
public IConnection get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(IConnection value);
    [CompilerGeneratedAttribute]
public sealed virtual AppRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(AppRequest value);
    [CompilerGeneratedAttribute]
public T get_Proto();
    [CompilerGeneratedAttribute]
private void set_Proto(T value);
    public void Initialize(TokenBucketList`1<ulong> playerBuckets, IConnection client, AppRequest request, T proto);
    public virtual void EnterPool();
    public sealed virtual void LeavePool();
    public virtual ValidationResult Validate();
    public abstract virtual void Execute();
    protected void SendSuccess();
    public sealed virtual void SendError(string code);
    public void SendFlag(bool value);
    protected void Send(AppResponse response);
}
public abstract class CompanionServer.Handlers.BasePlayerHandler`1 : BaseHandler`1<T> {
    [CompilerGeneratedAttribute]
private ulong <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private BasePlayer <Player>k__BackingField;
    protected ulong UserId { get; private set; }
    protected BasePlayer Player { get; private set; }
    [CompilerGeneratedAttribute]
protected ulong get_UserId();
    [CompilerGeneratedAttribute]
private void set_UserId(ulong value);
    [CompilerGeneratedAttribute]
protected BasePlayer get_Player();
    [CompilerGeneratedAttribute]
private void set_Player(BasePlayer value);
    public virtual void EnterPool();
    public virtual ValidationResult Validate();
}
public class CompanionServer.Handlers.CameraInput : BaseHandler`1<AppCameraInput> {
    protected double TokenCost { get; }
    protected virtual double get_TokenCost();
    public virtual void Execute();
    private static Vector3 Sanitize(Vector3 value);
    private static float Sanitize(float value);
}
public class CompanionServer.Handlers.CameraSubscribe : BasePlayerHandler`1<AppCameraSubscribe> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.CameraUnsubscribe : BaseHandler`1<AppEmpty> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.CheckSubscription : BaseEntityHandler`1<AppEmpty> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.ClanChat : BaseClanHandler`1<AppEmpty> {
    [AsyncStateMachineAttribute("CompanionServer.Handlers.ClanChat/<Execute>d__0")]
public virtual void Execute();
}
public class CompanionServer.Handlers.ClanInfo : BaseClanHandler`1<AppEmpty> {
    [AsyncStateMachineAttribute("CompanionServer.Handlers.ClanInfo/<Execute>d__0")]
public virtual void Execute();
}
public class CompanionServer.Handlers.EntityInfo : BaseEntityHandler`1<AppEmpty> {
    public virtual void Execute();
}
public interface CompanionServer.Handlers.IHandler {
    public AppRequest Request { get; }
    public abstract virtual AppRequest get_Request();
    public abstract virtual ValidationResult Validate();
    public abstract virtual void Execute();
    public abstract virtual void SendError(string code);
}
public class CompanionServer.Handlers.Info : BasePlayerHandler`1<AppEmpty> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.Map : BasePlayerHandler`1<AppEmpty> {
    private static int _width;
    private static int _height;
    private static Byte[] _imageData;
    private static string _background;
    protected double TokenCost { get; }
    protected virtual double get_TokenCost();
    public virtual void Execute();
    public static void PopulateCache();
    private static void RenderToCache();
}
public class CompanionServer.Handlers.MapMarkers : BasePlayerHandler`1<AppEmpty> {
    public virtual void Execute();
    private static AppMarker GetPlayerMarker(BasePlayer player);
}
public class CompanionServer.Handlers.NexusAuth : BaseHandler`1<AppGetNexusAuth> {
    public virtual ValidationResult Validate();
    [AsyncStateMachineAttribute("CompanionServer.Handlers.NexusAuth/<Execute>d__1")]
public virtual void Execute();
}
public class CompanionServer.Handlers.PromoteToLeader : BasePlayerHandler`1<AppPromoteToLeader> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.SendClanChat : BaseClanHandler`1<AppSendMessage> {
    protected double TokenCost { get; }
    protected virtual double get_TokenCost();
    [AsyncStateMachineAttribute("CompanionServer.Handlers.SendClanChat/<Execute>d__2")]
public virtual void Execute();
}
public class CompanionServer.Handlers.SendTeamChat : BasePlayerHandler`1<AppSendMessage> {
    protected double TokenCost { get; }
    protected virtual double get_TokenCost();
    [AsyncStateMachineAttribute("CompanionServer.Handlers.SendTeamChat/<Execute>d__2")]
public virtual void Execute();
}
public class CompanionServer.Handlers.SetClanMotd : BaseClanHandler`1<AppSendMessage> {
    [AsyncStateMachineAttribute("CompanionServer.Handlers.SetClanMotd/<Execute>d__0")]
public virtual void Execute();
}
public class CompanionServer.Handlers.SetEntityValue : BaseEntityHandler`1<AppSetEntityValue> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.SetSubscription : BaseEntityHandler`1<AppFlag> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.TeamChat : BasePlayerHandler`1<AppEmpty> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.TeamInfo : BasePlayerHandler`1<AppEmpty> {
    public virtual void Execute();
}
public class CompanionServer.Handlers.Time : BasePlayerHandler`1<AppEmpty> {
    public virtual void Execute();
}
public enum CompanionServer.Handlers.ValidationResult : Enum {
    public int value__;
    public static ValidationResult Success;
    public static ValidationResult NotFound;
    public static ValidationResult RateLimit;
    public static ValidationResult Banned;
    public static ValidationResult Rejected;
}
public interface CompanionServer.IBroadcastSender`1 {
    public abstract virtual void BroadcastTo(List`1<Connection> targets, TMessage message);
}
public interface CompanionServer.IConnection {
    public long ConnectionId { get; }
    public IRemoteControllable CurrentCamera { get; }
    public bool IsControllingCamera { get; }
    public ulong ControllingSteamId { get; }
    public InputState InputState { get; public set; }
    public abstract virtual long get_ConnectionId();
    public abstract virtual void Send(AppResponse response);
    public abstract virtual void Subscribe(PlayerTarget target);
    public abstract virtual void Subscribe(EntityTarget target);
    public abstract virtual void Subscribe(ClanTarget target);
    public abstract virtual void Unsubscribe(ClanTarget target);
    public abstract virtual IRemoteControllable get_CurrentCamera();
    public abstract virtual bool get_IsControllingCamera();
    public abstract virtual ulong get_ControllingSteamId();
    public abstract virtual InputState get_InputState();
    public abstract virtual void set_InputState(InputState value);
    public abstract virtual bool BeginViewing(IRemoteControllable camera);
    public abstract virtual void EndViewing();
}
public interface CompanionServer.ITokenBucketSettings {
    public double MaxTokens { get; }
    public double TokensPerSec { get; }
    public abstract virtual double get_MaxTokens();
    public abstract virtual double get_TokensPerSec();
}
public class CompanionServer.Listener : object {
    private static ByteArrayStream Stream;
    private TokenBucketList`1<IPAddress> _ipTokenBuckets;
    private BanList`1<IPAddress> _ipBans;
    private TokenBucketList`1<ulong> _playerTokenBuckets;
    private TokenBucketList`1<ulong> _pairingTokenBuckets;
    private Queue`1<Message> _messageQueue;
    private WebSocketServer _server;
    private Stopwatch _stopwatch;
    private RealTimeSince _lastCleanup;
    private long _nextConnectionId;
    public IPAddress Address;
    public int Port;
    public ConnectionLimiter Limiter;
    public SubscriberList`2<PlayerTarget, AppBroadcast> PlayerSubscribers;
    public SubscriberList`2<EntityTarget, AppBroadcast> EntitySubscribers;
    public SubscriberList`2<ClanTarget, AppBroadcast> ClanSubscribers;
    public SubscriberList`2<CameraTarget, AppBroadcast> CameraSubscribers;
    public Listener(IPAddress ipAddress, int port);
    private static Listener();
    public sealed virtual void Dispose();
    internal void Enqueue(Connection connection, MemoryBuffer data);
    public bool Update();
    private void Dispatch(Message message);
    private bool Handle(TProto protocol, Connection connection, AppRequest request);
    public sealed virtual void BroadcastTo(List`1<Connection> targets, AppBroadcast broadcast);
    private static MemoryBuffer GetBroadcastBuffer(AppBroadcast broadcast);
    public bool CanSendPairingNotification(ulong playerId);
}
public enum CompanionServer.NotificationChannel : Enum {
    public int value__;
    public static NotificationChannel Pairing;
    public static NotificationChannel PlayerLoggedIn;
    public static NotificationChannel PlayerDied;
    public static NotificationChannel SmartAlarm;
    public static NotificationChannel ClanAnnouncement;
}
public class CompanionServer.NotificationList : object {
    private static string ApiEndpoint;
    private static HttpClient Http;
    private HashSet`1<ulong> _subscriptions;
    private double _lastSend;
    private static NotificationList();
    public bool AddSubscription(ulong steamId);
    public bool RemoveSubscription(ulong steamId);
    public bool HasSubscription(ulong steamId);
    public List`1<ulong> ToList();
    public void LoadFrom(List`1<ulong> steamIds);
    public void IntersectWith(HashSet`1<PlayerNameID> players);
    public Task`1<NotificationSendResult> SendNotification(NotificationChannel channel, string title, string body, string type);
    [AsyncStateMachineAttribute("CompanionServer.NotificationList/<SendNotificationTo>d__11")]
public static Task`1<NotificationSendResult> SendNotificationTo(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data);
    [AsyncStateMachineAttribute("CompanionServer.NotificationList/<SendNotificationTo>d__12")]
public static Task`1<NotificationSendResult> SendNotificationTo(ulong steamId, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data);
    [AsyncStateMachineAttribute("CompanionServer.NotificationList/<SendNotificationImpl>d__13")]
private static Task`1<NotificationSendResult> SendNotificationImpl(ICollection`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data);
    [AsyncStateMachineAttribute("CompanionServer.NotificationList/<SendNotificationBatchImpl>d__14")]
private static Task`1<NotificationSendResult> SendNotificationBatchImpl(IEnumerable`1<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data);
}
public enum CompanionServer.NotificationSendResult : Enum {
    public int value__;
    public static NotificationSendResult Failed;
    public static NotificationSendResult Sent;
    public static NotificationSendResult Empty;
    public static NotificationSendResult Disabled;
    public static NotificationSendResult RateLimited;
    public static NotificationSendResult ServerError;
    public static NotificationSendResult NoTargetsFound;
    public static NotificationSendResult TooManySubscribers;
}
[IsReadOnlyAttribute]
public class CompanionServer.PlayerTarget : ValueType {
    [CompilerGeneratedAttribute]
private ulong <SteamId>k__BackingField;
    public ulong SteamId { get; }
    public PlayerTarget(ulong steamId);
    [CompilerGeneratedAttribute]
public ulong get_SteamId();
    public sealed virtual bool Equals(PlayerTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PlayerTarget left, PlayerTarget right);
    public static bool op_Inequality(PlayerTarget left, PlayerTarget right);
}
public class CompanionServer.PushRequest : object {
    public string ServerToken;
    public List`1<ulong> SteamIds;
    public NotificationChannel Channel;
    public string Title;
    public string Body;
    public Dictionary`2<string, string> Data;
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
}
public static class CompanionServer.Server : object {
    private static string ApiEndpoint;
    private static HttpClient Http;
    public static ChatLog TeamChat;
    internal static string Token;
    [CompilerGeneratedAttribute]
private static Listener <Listener>k__BackingField;
    public static Listener Listener { get; private set; }
    public static bool IsEnabled { get; }
    private static Server();
    [CompilerGeneratedAttribute]
public static Listener get_Listener();
    [CompilerGeneratedAttribute]
private static void set_Listener(Listener value);
    public static bool get_IsEnabled();
    public static void Initialize(bool minimal);
    public static void Shutdown();
    public static bool Update();
    public static void Broadcast(PlayerTarget target, AppBroadcast broadcast);
    public static void Broadcast(EntityTarget target, AppBroadcast broadcast);
    public static void Broadcast(ClanTarget target, AppBroadcast broadcast);
    public static void Broadcast(CameraTarget target, AppBroadcast broadcast);
    public static bool HasAnySubscribers(CameraTarget target);
    public static bool CanSendPairingNotification(ulong playerId);
    [AsyncStateMachineAttribute("CompanionServer.Server/<PostInitializeServer>d__19")]
private static void PostInitializeServer();
    [AsyncStateMachineAttribute("CompanionServer.Server/<SetupServerRegistration>d__20")]
private static Task SetupServerRegistration();
    private static bool TryLoadServerRegistration(String& serverId, String& serverToken);
    private static void SetServerRegistration(string responseJson);
    [AsyncStateMachineAttribute("CompanionServer.Server/<CheckConnectivity>d__23")]
private static Task CheckConnectivity();
    [AsyncStateMachineAttribute("CompanionServer.Server/<AutoRetry>d__24")]
private static Task`1<HttpResponseMessage> AutoRetry(Func`1<Task`1<HttpResponseMessage>> action);
    private static void SetServerId(string serverId);
    private static string GetServerIdPath();
}
public class CompanionServer.SubscriberList`2 : object {
    private object _syncRoot;
    private Dictionary`2<TKey, Dictionary`2<Connection, double>> _subscriptions;
    private IBroadcastSender`1<TMessage> _sender;
    private Nullable`1<double> _timeoutSeconds;
    private Stopwatch _lastCleanup;
    public SubscriberList`2(IBroadcastSender`1<TMessage> sender, Nullable`1<double> timeoutSeconds);
    public void Add(TKey key, Connection value);
    public void Remove(TKey key, Connection value);
    public void Clear(TKey key);
    public void Send(TKey key, TMessage message);
    public bool HasAnySubscribers(TKey key);
    public bool HasSubscriber(TKey key, Connection target);
    private void CleanupExpired();
}
public class CompanionServer.TokenBucket : object {
    private double _lastUpdate;
    private double _tokens;
    public ITokenBucketSettings Settings;
    public bool IsFull { get; }
    public bool IsNaughty { get; }
    public bool get_IsFull();
    public bool get_IsNaughty();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    public void Reset();
    public bool TryTake(double requestedTokens);
    private void Update();
}
public class CompanionServer.TokenBucketList`1 : object {
    private Dictionary`2<TKey, TokenBucket> _buckets;
    [CompilerGeneratedAttribute]
private double <MaxTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TokensPerSec>k__BackingField;
    public double MaxTokens { get; }
    public double TokensPerSec { get; }
    public TokenBucketList`1(double maxTokens, double tokensPerSec);
    [CompilerGeneratedAttribute]
public sealed virtual double get_MaxTokens();
    [CompilerGeneratedAttribute]
public sealed virtual double get_TokensPerSec();
    public TokenBucket Get(TKey key);
    public void Cleanup();
}
[ExtensionAttribute]
public static class CompanionServer.Util : object {
    public static int OceanMargin;
    public static Phrase NotificationEmpty;
    public static Phrase NotificationDisabled;
    public static Phrase NotificationRateLimit;
    public static Phrase NotificationServerError;
    public static Phrase NotificationNoTargets;
    public static Phrase NotificationTooManySubscribers;
    public static Phrase NotificationUnknown;
    private static Util();
    public static Vector2 WorldToMap(Vector3 worldPos);
    public static void SendSignedInNotification(BasePlayer player);
    public static void SendDeathNotification(BasePlayer player, BaseEntity killer);
    public static Task`1<NotificationSendResult> SendPairNotification(string type, BasePlayer player, string title, string message, Dictionary`2<string, string> data);
    public static Dictionary`2<string, string> GetServerPairingData();
    public static Dictionary`2<string, string> GetPlayerPairingData(BasePlayer player);
    [ExtensionAttribute]
public static void BroadcastAppTeamRemoval(BasePlayer player);
    [ExtensionAttribute]
public static void BroadcastAppTeamUpdate(PlayerTeam team);
    [ExtensionAttribute]
public static void BroadcastTeamChat(PlayerTeam team, ulong steamId, string name, string message, string color);
    [AsyncStateMachineAttribute("CompanionServer.Util/<SendNotification>d__10")]
[ExtensionAttribute]
public static void SendNotification(PlayerTeam team, NotificationChannel channel, string title, string body, Dictionary`2<string, string> data, ulong ignorePlayer);
    [ExtensionAttribute]
public static string ToErrorCode(ValidationResult result);
    [ExtensionAttribute]
public static Phrase ToErrorMessage(NotificationSendResult result);
}
public class CompanionSetupScreen : SingletonComponent`1<CompanionSetupScreen> {
    public static string PairedKey;
    public GameObject instructionsBody;
    public GameObject detailsPanel;
    public GameObject loadingMessage;
    public GameObject errorMessage;
    public GameObject notSupportedMessage;
    public GameObject disabledMessage;
    public GameObject enabledMessage;
    public GameObject refreshButton;
    public GameObject enableButton;
    public GameObject disableButton;
    public GameObject pairButton;
    public RustText serverName;
    public RustButton helpButton;
}
public class CompassMapMarker : MonoBehaviour {
    public Image MarkerImage;
    public Image MarkerImageOuter;
    public GameObject LeaderRoot;
    public RustText MarkerLabel;
}
public class CompassMissionMarker : MonoBehaviour {
    public Image Icon;
}
public class CompleteTrain : object {
    [CompilerGeneratedAttribute]
private TrainCar <PrimaryTrainCar>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TotalForces>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TotalMass>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinedUpToUnload>k__BackingField;
    private Vector3 unloaderPos;
    public float trackSpeed;
    private float prevTrackSpeed;
    public List`1<TrainCar> trainCars;
    public TriggerTrainCollisions frontCollisionTrigger;
    public TriggerTrainCollisions rearCollisionTrigger;
    public bool ranUpdateTick;
    public bool disposed;
    public static float IMPACT_ENERGY_FRACTION;
    public static float MIN_COLLISION_FORCE;
    public float lastMovingTime;
    public static float SLEEP_SPEED;
    public static float SLEEP_DELAY;
    public TimeSince timeSinceLastChange;
    private bool isShunting;
    private TimeSince timeSinceShuntStart;
    private static float MAX_SHUNT_TIME;
    private static float SHUNT_SPEED;
    private static float SHUNT_SPEED_CHANGE_RATE;
    private Action`1<ActionAttemptStatus> shuntEndCallback;
    private float shuntDistance;
    private Vector3 shuntDirection;
    private Vector2 shuntStartPos2D;
    private Vector2 shuntTargetPos2D;
    private TrainCar shuntTarget;
    public StaticCollisionState staticCollidingAtFront;
    private HashSet`1<GameObject> monitoredStaticContentF;
    public StaticCollisionState staticCollidingAtRear;
    private HashSet`1<GameObject> monitoredStaticContentR;
    public Dictionary`2<Rigidbody, float> prevTrackSpeeds;
    public TrainCar PrimaryTrainCar { get; public set; }
    public bool TrainIsReversing { get; }
    public float TotalForces { get; public set; }
    public float TotalMass { get; public set; }
    public int NumTrainCars { get; }
    public int LinedUpToUnload { get; private set; }
    public bool IsLinedUpToUnload { get; }
    public CompleteTrain(TrainCar trainCar);
    public CompleteTrain(List`1<TrainCar> allTrainCars);
    [CompilerGeneratedAttribute]
public TrainCar get_PrimaryTrainCar();
    [CompilerGeneratedAttribute]
public void set_PrimaryTrainCar(TrainCar value);
    public bool get_TrainIsReversing();
    [CompilerGeneratedAttribute]
public float get_TotalForces();
    [CompilerGeneratedAttribute]
public void set_TotalForces(float value);
    [CompilerGeneratedAttribute]
public float get_TotalMass();
    [CompilerGeneratedAttribute]
public void set_TotalMass(float value);
    public int get_NumTrainCars();
    [CompilerGeneratedAttribute]
public int get_LinedUpToUnload();
    [CompilerGeneratedAttribute]
private void set_LinedUpToUnload(int value);
    public bool get_IsLinedUpToUnload();
    private void Init(List`1<TrainCar> allTrainCars);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Cleanup();
    public void RemoveTrainCar(TrainCar trainCar);
    public float GetTrackSpeedFor(TrainCar trainCar);
    public float GetPrevTrackSpeedFor(TrainCar trainCar);
    public void UpdateTick(float dt);
    public bool IncludesAnEngine();
    protected bool HasAnyCollisions();
    private bool HasAnyEnginesOn();
    private bool IsAllAsleep();
    private void SleepAll();
    public bool TryShuntCarTo(Vector3 shuntDirection, float shuntDistance, TrainCar shuntTarget, Action`1<ActionAttemptStatus> shuntEndCallback, ActionAttemptStatus& status);
    private void EndShunting(ActionAttemptStatus status);
    public bool ContainsOnly(TrainCar trainCar);
    public int IndexOf(TrainCar trainCar);
    public bool TryGetAdjacentTrainCar(TrainCar trainCar, bool next, Vector3 forwardDir, TrainCar& result);
    private void ParamsTick();
    private void MovementTick(float dt);
    private void MoveOtherTrainCar(TrainCar trainCar, TrainCar prevTrainCar);
    public void ResetUpdateTick();
    public bool Matches(List`1<TrainCar> listToCompare);
    public void ReduceSpeedBy(float velChange);
    public bool AnyPlayersOnTrain();
    private int CheckLinedUpToUnload(Vector3& unloaderPos);
    public bool GetIsCoupledBackwards(TrainCar trainCar);
    private bool GetIsCoupledBackwards(int trainCarIndex);
    private bool HasThrottleInput();
    private TrackSelection GetTrackSelection();
    public void FreeStaticCollision();
    private float ApplyCollisionsToTrackSpeed(float trackSpeed, float totalMass, float deltaTime);
    private float ApplyCollisions(float trackSpeed, TrainCar ourTrainCar, Vector3 forwardVector, bool atOurFront, TriggerTrainCollisions trigger, float ourTotalMass, StaticCollisionState& wasStaticColliding, StaticCollisionState otherEndStaticColliding, float deltaTime);
    private float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, StaticCollisionState& wasStaticColliding, TriggerTrainCollisions trigger);
    private float HandleTrainCollision(bool front, Vector3 forwardVector, float trackSpeed, Transform ourTransform, TrainCar theirTrain, float deltaTime, StaticCollisionState& wasStaticColliding);
    private float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Vector3 forwardVector, float ourTotalMass, Rigidbody theirRB, Vector3 theirVelocity, float theirTotalMass, float deltaTime, bool calcSecondaryForces);
    private float GetTotalPushingMass(Vector3 pushDirection, Vector3 ourForward, List`1& prevTrains);
    private float GetTotalPushingForces(Vector3 pushDirection, Vector3 ourForward, List`1& prevTrains, Single& nextTrainTrackSpeed);
}
public abstract class ComponentInfo : MonoBehaviour {
    public abstract virtual void Setup();
    public abstract virtual void Reset();
}
public abstract class ComponentInfo`1 : ComponentInfo {
    public T component;
    public void Initialize(T source);
}
public class Composter : StorageContainer {
    [HeaderAttribute("Composter")]
public ItemDefinition FertilizerDef;
    [TooltipAttribute("If enabled, entire item stacks will be composted each tick, instead of a single item of a stack.")]
public bool CompostEntireStack;
    public float fertilizerProductionProgress;
    protected float UpdateInterval { get; }
    protected float get_UpdateInterval();
    public virtual void ServerInit();
    public bool InventoryItemFilter(Item item, int targetSlot);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public bool ItemIsFertilizer(Item item);
    public void UpdateComposting();
    public void CompostItem(Item item);
    public void ProduceFertilizer(int amount);
}
public class CompoundBowWeapon : BowWeapon {
    public float stringHoldDurationMax;
    public float stringBonusDamage;
    public float stringBonusDistance;
    public float stringBonusVelocity;
    public float movementPenaltyRampUpTime;
    public float conditionLossPerSecondHeld;
    public float conditionLossHeldDelay;
    public SoundDefinition chargeUpSoundDef;
    public SoundDefinition stringHeldSoundDef;
    public SoundDefinition drawFinishSoundDef;
    private Sound chargeUpSound;
    private Sound stringHeldSound;
    protected float movementPenalty;
    internal float stringHoldTimeStart;
    protected float conditionLossCheckTickRate;
    protected float serverMovementCheckTickRate;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void UpdateMovementPenalty(float delta);
    public void UpdateConditionLoss();
    public void ServerMovementCheck();
    public virtual void OnHeldChanged();
    [RPC_Server]
public void RPC_StringHoldStatus(RPCMessage msg);
    public virtual void DidAttackServerside();
    public float GetLastPlayerMovementTime();
    public float GetStringBonusScale();
    public virtual float GetDamageScale(bool getMax);
    public virtual float GetDistanceScale(bool getMax);
    public virtual float GetProjectileVelocityScale(bool getMax);
}
public class ComputerMenu : UIDialog {
    public RectTransform bookmarkContainer;
    public GameObject bookmarkPrefab;
    public List`1<RCBookmarkEntry> activeEntries;
}
public class ComputerStation : BaseMountable {
    public static Flags Flag_HasFullControl;
    [HeaderAttribute("Computer")]
public GameObjectRef menuPrefab;
    public ComputerMenu computerMenu;
    public EntityRef currentlyControllingEnt;
    public List`1<string> controlBookmarks;
    public Transform leftHandIKPosition;
    public Transform rightHandIKPosition;
    public SoundDefinition turnOnSoundDef;
    public SoundDefinition turnOffSoundDef;
    public SoundDefinition onLoopSoundDef;
    public bool isStatic;
    public float autoGatherRadius;
    public ulong currentPlayerID;
    public float nextAddTime;
    public static Char[] BookmarkSplit;
    private static ComputerStation();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool AllowPings();
    public static bool IsValidIdentifier(string str);
    public virtual void DestroyShared();
    public virtual void ServerInit();
    public void GatherStaticCameras();
    public virtual void PostServerLoad();
    public void StopControl(BasePlayer ply);
    public bool IsPlayerAdmin(BasePlayer player);
    [RPC_Server]
public void DeleteBookmark(RPCMessage msg);
    [RPC_Server]
public void Server_DisconnectControl(RPCMessage msg);
    [RPC_Server]
public void BeginControllingBookmark(RPCMessage msg);
    public void CheckCCTVAchievement();
    public bool CanAddBookmark(BasePlayer player);
    public void ForceAddBookmark(string identifier);
    [RPC_Server]
public void AddBookmark(RPCMessage msg);
    public void ControlCheck();
    public string GenerateControlBookmarkString();
    public void SendControlBookmarks(BasePlayer player);
    public virtual void OnPlayerMounted();
    public virtual void OnPlayerDismounted(BasePlayer player);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ConditionalGibbable : MonoBehaviour {
    [ReadOnlyAttribute]
public int id;
}
public class ConditionalModel : PrefabAttribute {
    public GameObjectRef prefab;
    public bool onClient;
    public bool onServer;
    public bool IsImportant;
    public ModelConditionTest[] conditions;
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public bool RunTests(BaseEntity parent);
    public bool RunTestsExceptFoundationSide(BaseEntity parent);
    public GameObject InstantiateSkin(BaseEntity parent);
    protected virtual Type GetIndexedType();
}
public class ConfettiCannon : DecayEntity {
    public float InitialBlastDelay;
    public float BlastCooldown;
    public GameObjectRef ConfettiPrefab;
    public Transform ConfettiPrefabSpawnPoint;
    public static Flags Ignited;
    public float DamagePerBlast;
    private Action blastAction;
    private Action clearBusy;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsVisible("3")]
[RPC_Server]
private void Blast(RPCMessage msg);
    private void TriggerBlast();
    private void ClearBusy();
    public virtual void PostServerLoad();
    public sealed virtual void Ignite(Vector3 fromPos);
    public sealed virtual bool CanIgnite();
    public virtual void OnAttacked(HitInfo info);
}
public class ConnectedSpeaker : IOEntity {
    public AudioSource SoundSource;
    private EntityRef`1<IOEntity> connectedTo;
    public VoiceProcessor VoiceProcessor;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual void Load(LoadInfo info);
    private IAudioConnectionSource GetConnectionSource(IOEntity entity, int depth);
    public virtual void Save(SaveInfo info);
}
public class ConnectionAuth : MonoBehaviour {
    public static List`1<Connection> m_AuthConnection;
    private static RealTimeSince _sinceClientRequirementRefresh;
    private static Nullable`1<ValueTuple`2<int, int>> _clientRequirementCache;
    private static string _clientVersionMismatchMessage;
    private static ConnectionAuth();
    public bool IsAuthed(ulong iSteamID);
    public static void Reject(Connection connection, string strReason, string strReasonPrivate);
    public static void OnDisconnect(Connection connection);
    public void Approve(Connection connection);
    public void OnNewConnection(Connection connection);
    [IteratorStateMachineAttribute("ConnectionAuth/<AuthorisationRoutine>d__6")]
public IEnumerator AuthorisationRoutine(Connection connection);
    private static Nullable`1<ValueTuple`2<int, int>> GetMinClientRequirement();
    private static string GetClientVersionMismatchMessage();
}
public class ConnectionQueue : object {
    public List`1<Connection> queue;
    public List`1<Connection> joining;
    private List`1<ReservedServerSlot> reservedSlots;
    private float nextCleanupReservedSlots;
    public float nextMessageTime;
    public int ReservedCount { get; }
    public int Queued { get; }
    public int Joining { get; }
    public int get_ReservedCount();
    public int get_Queued();
    public int get_Joining();
    public void SkipQueue(ulong userid);
    internal void Join(Connection connection);
    public void Cycle(int availableSlots);
    public void SendMessages();
    public void SendMessage(Connection c, int position);
    public void RemoveConnection(Connection connection);
    public void TryAddReservedSlot(Connection connection);
    private void JoinGame(Connection connection);
    public void JoinedGame(Connection connection);
    private void AddReservation(ulong userId);
    private void CleanupExpiredReservedSlots();
    private ReservedServerSlot FindQueueSpot(ulong userId);
    private void RemoveReservedSlot(ulong userId);
    private bool CanJumpQueue(Connection connection);
    public bool IsQueued(ulong userid);
    public bool IsJoining(ulong userid);
}
public class ConnectionScreen : SingletonComponent`1<ConnectionScreen> {
    public RustText statusText;
    public GameObject disconnectButton;
    public GameObject retryButton;
    public ServerBrowserInfo browserInfo;
}
public class ConsoleGen : object {
    public static Command[] All;
    private static ConsoleGen();
}
public static class ConsoleNetwork : object {
    private static Stopwatch timer;
    private static ConsoleNetwork();
    internal static void Init();
    internal static void OnClientCommand(Message packet);
    internal static void SendClientReply(Connection cn, string strCommand);
    public static void SendClientCommand(Connection cn, string strCommand, Object[] args);
    public static void SendClientCommandImmediate(Connection cn, string strCommand, Object[] args);
    public static void SendClientCommand(List`1<Connection> cn, string strCommand, Object[] args);
    public static void BroadcastToAllClients(string strCommand, Object[] args);
}
public class ConsoleUI : SingletonComponent`1<ConsoleUI> {
    public RustText text;
    public InputField outputField;
    public InputField inputField;
    public GameObject AutocompleteDropDown;
    public GameObject ItemTemplate;
    public Color errorColor;
    public Color warningColor;
    public Color inputColor;
}
public class Construction : PrefabAttribute {
    public Option info;
    public bool canBypassBuildingPermission;
    public bool showBuildingBlockedPreview;
    [InspectorNameAttribute("Can bypass road checks")]
public bool canPlaceOnRoads;
    [FormerlySerializedAsAttribute("canRotate")]
public bool canRotateBeforePlacement;
    [FormerlySerializedAsAttribute("canRotate")]
public bool canRotateAfterPlacement;
    public bool checkVolumeOnRotate;
    public bool checkVolumeOnUpgrade;
    public bool canPlaceAtMaxDistance;
    public bool placeOnWater;
    public bool overridePlacementLayer;
    public LayerMask overridedPlacementLayer;
    public Vector3 rotationAmount;
    public Vector3 applyStartingRotation;
    public Transform deployOffset;
    public bool enforceLineOfSightCheckAgainstParentEntity;
    public bool canSnap;
    public float holdToPlaceDuration;
    public bool canFloodFillSockets;
    [RangeAttribute("0", "10")]
public float healthMultiplier;
    [RangeAttribute("0", "10")]
public float costMultiplier;
    [RangeAttribute("1", "50")]
public float maxplaceDistance;
    public Mesh guideMesh;
    public Socket_Base[] allSockets;
    public BuildingProximity[] allProximities;
    public ConstructionGrade defaultGrade;
    public SocketHandle socketHandle;
    public Bounds bounds;
    public bool isBuildingPrivilege;
    public bool isSleepingBag;
    public ConstructionGrade[] grades;
    public Deployable deployable;
    public ConstructionPlaceholder placeholder;
    public static Phrase lastPlacementError;
    public static bool lastPlacementErrorIsDetailed;
    public static string lastPlacementErrorDebug;
    public static BuildingBlock lastBuildingBlockError;
    private static Construction();
    public BaseEntity CreateConstruction(Target target, bool bNeedsValidPlacement);
    public bool HasMaleSockets(Target target);
    public void FindMaleSockets(Target target, List`1<Socket_Base> sockets);
    public ConstructionGrade GetGrade(Enum iGrade, ulong iSkin);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected virtual Type GetIndexedType();
    public bool UpdatePlacement(Transform transform, Construction common, Target& target);
    private bool TestPlacingThroughRock(Placement& placement, Target target);
    private static bool TestPlacingThroughWall(Placement& placement, Transform transform, Construction common, Target target);
    private bool TestPlacingCloseToRoad(Placement& placement, Target target, Construction construction);
    public virtual bool ShowAsNeutral(Target target);
}
public class Construction_SleepingBag : Construction {
}
public static class ConstructionErrors : object {
    public static Phrase NoPermission;
    public static Phrase StackPrivilege;
    public static Phrase CantBuildWhileMoving;
    public static Phrase ThroughRock;
    public static Phrase InsideObjects;
    public static Phrase TooCloseToRoad;
    public static Phrase TooFarAway;
    public static Phrase BlockedBy;
    public static Phrase BlockedByPlayer;
    public static Phrase TooCloseTo;
    public static Phrase ToCloseToMonument;
    public static Phrase BlockedByTree;
    public static Phrase SkinNotOwned;
    public static Phrase CannotBuildInThisArea;
    public static Phrase NotEnoughSpace;
    public static Phrase NotStableEnough;
    public static Phrase MustPlaceOnConstruction;
    public static Phrase CantPlaceOnConstruction;
    public static Phrase CantPlaceOnMonument;
    public static Phrase NotInTerrain;
    public static Phrase MustPlaceOnRoad;
    public static Phrase CantPlaceOnRoad;
    public static Phrase InvalidAreaVehicleLarge;
    public static Phrase InvalidAngle;
    public static Phrase InvalidEntity;
    public static Phrase InvalidEntityType;
    public static Phrase WantsWater;
    public static Phrase WantsWaterBody;
    public static Phrase InWater;
    public static Phrase TooDeep;
    public static Phrase TooShallow;
    public static Phrase CouldntFindConstruction;
    public static Phrase CouldntFindEntity;
    public static Phrase CouldntFindSocket;
    public static Phrase Antihack;
    public static Phrase CantDeployOnDoor;
    public static Phrase DeployableMismatch;
    public static Phrase LineOfSightBlocked;
    public static Phrase ParentTooFar;
    public static Phrase SocketOccupied;
    public static Phrase SocketNotFemale;
    public static Phrase WantsInside;
    public static Phrase WantsOutside;
    public static Phrase PlayerName;
    public static Phrase HorseName;
    public static Phrase ModularCarName;
    public static Phrase TreeName;
    public static Phrase DebrisName;
    public static Phrase OreName;
    public static Phrase CannotAttachToUnauthorized;
    public static Phrase CannotConnectTwoBuildings;
    public static Phrase CantUpgradeRecentlyDamaged;
    public static Phrase CantRotateAnymore;
    public static Phrase CantDemolishAnymore;
    private static ConstructionErrors();
    public static string GetTranslatedNameFromEntity(BaseEntity entity, BasePlayer fromPlayer);
    public static string GetBlockedByErrorFromCollider(Collider col, BasePlayer fromPlayer);
    public static void Log(BasePlayer player, string message);
}
public class ConstructionGrade : PrefabAttribute {
    public Construction construction;
    public BuildingGrade gradeBase;
    public GameObjectRef skinObject;
    private Dictionary`2<Enum, List`1<ItemAmount>> _costs;
    public float maxHealth { get; }
    public float get_maxHealth();
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public List`1<ItemAmount> CostToBuild(Enum fromGrade);
    protected virtual Type GetIndexedType();
}
[ExecuteInEditMode]
public class ConstructionPlaceholder : PrefabAttribute {
    public Mesh mesh;
    public Material material;
    public bool renderer;
    public bool collider;
    public MeshRenderer MeshRenderer;
    public MeshFilter MeshFilter;
    public MeshCollider MeshCollider;
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected virtual Type GetIndexedType();
}
public class ConstructionSkin : BasePrefab {
    public List`1<GameObject> conditionals;
    public int DetermineConditionalModelState(BuildingBlock parent);
    private void CreateConditionalModels(BuildingBlock parent);
    private void DestroyConditionalModels(BuildingBlock parent);
    public virtual void Refresh(BuildingBlock parent);
    public void Destroy(BuildingBlock parent);
    public virtual UInt32 GetStartingDetailColour(UInt32 playerColourIndex);
}
[CreateAssetMenuAttribute]
public class ConstructionSkin_ColourLookup : ScriptableObject {
    public Texture2D Sample;
    public Color[] AllColours;
}
public class ConstructionSkin_CustomDetail : ConstructionSkin {
    public ConstructionSkin_ColourLookup ColourLookup;
    public virtual UInt32 GetStartingDetailColour(UInt32 playerColourIndex);
}
public class ConstructionSocket : Socket_Base {
    public Type socketType;
    public int rotationDegrees;
    public int rotationOffset;
    public bool restrictPlacementRotation;
    public bool restrictPlacementAngle;
    public float faceAngle;
    public float angleAllowed;
    public bool wantsInside;
    [RangeAttribute("0", "1")]
public float support;
    private static Vector3[] outsideLookupDirs;
    private static ConstructionSocket();
    private void OnDrawGizmos();
    private void OnDrawGizmosSelected();
    public virtual bool TestTarget(Target target);
    public virtual bool IsCompatible(Socket_Base socket);
    public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation);
    public bool TestRestrictedAngles(Vector3 suggestedPos, Quaternion suggestedAng, Target target);
    public virtual Placement DoPlacement(Target target);
    protected virtual bool CanConnectToEntity(Target target);
    private bool ShouldInheritFemaleSocketRotation(Type type);
    public bool IsOutside(Vector3 pos, Transform tr);
}
public class ConstructionSocket_Elevator : ConstructionSocket {
    public int MaxFloor;
    protected virtual bool CanConnectToEntity(Target target);
    public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation);
}
public class ConsumableInformationPanel : ItemInformationPanel {
    public ItemTextValue[] values;
    public UIGenesDisplay Genes;
    public Text TextUnknownGenetics;
    public Text LabelGenetics;
    public GameObject GeneticsGameObject;
    public ItemTextValue durationValue;
    public ItemTextValue baitValue;
    public ItemTextValue baitStackSize;
}
public class ContactsEntry : MonoBehaviour {
    public RustText nameText;
    public RustText reputationText;
    public RawImage smallMugshot;
    public PlayerRelationshipInfo info;
}
public class ContactsPanel : SingletonComponent`1<ContactsPanel> {
    public RectTransform alliesBucket;
    public RectTransform seenBucket;
    public RectTransform enemiesBucket;
    public RectTransform contentsBucket;
    public ContactsEntry contactEntryPrefab;
    public RawImage mugshotTest;
    public RawImage fullBodyTest;
    public RustButton[] filterButtons;
    public RelationshipType selectedRelationshipType;
    public RustButton lastSeenToggle;
    public Phrase sortingByLastSeenPhrase;
    public Phrase sortingByFirstSeen;
    public RustText sortText;
}
public class ContainerIOEntity : IOEntity {
    public ItemDefinition onlyAllowedItem;
    public ContentsType allowedContents;
    public int maxStackSize;
    public int numSlots;
    public string lootPanelName;
    public Phrase panelTitle;
    public bool needsBuildingPrivilegeToUse;
    public bool isLootable;
    public bool dropsLoot;
    public bool dropFloats;
    public bool onlyOneUser;
    public SoundDefinition openSound;
    public SoundDefinition closeSound;
    private ItemContainer _inventory;
    [CompilerGeneratedAttribute]
private ulong <LastLootedBy>k__BackingField;
    public Phrase LootPanelTitle { get; }
    public ItemContainer inventory { get; }
    public Transform Transform { get; }
    public bool DropsLoot { get; }
    public bool DropFloats { get; }
    public float DestroyLootPercent { get; }
    public ulong LastLootedBy { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Phrase get_LootPanelTitle();
    public sealed virtual ItemContainer get_inventory();
    public sealed virtual Transform get_Transform();
    public sealed virtual bool get_DropsLoot();
    public sealed virtual bool get_DropFloats();
    public sealed virtual float get_DestroyLootPercent();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_LastLootedBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastLootedBy(ulong value);
    public virtual bool CanPickup(BasePlayer player);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void PreServerLoad();
    public virtual void PostServerLoad();
    public void CreateInventory(bool giveUID);
    public virtual void Save(SaveInfo info);
    public virtual void OnInventoryFirstCreated(ItemContainer container);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    protected virtual void OnInventoryDirty();
    public virtual void OnKilled(HitInfo info);
    public sealed virtual void DropItems(BaseEntity initiator);
    [RPC_Server]
[IsVisible("3")]
private void RPC_OpenLoot(RPCMessage rpc);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public sealed virtual bool ShouldDropItemsIndividually();
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier);
    public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container);
    public bool OccupiedCheck(BasePlayer player);
    public virtual void Load(LoadInfo info);
}
public class ContainerSourceLocalPlayer : ItemContainerSource {
    public Type type;
    public bool hideInvalidIcons;
    private ItemIcon[] allIcons;
    public virtual ItemContainer GetItemContainer();
}
public class ContainerSourceLoot : ItemContainerSource {
    public int container;
    public virtual ItemContainer GetItemContainer();
}
public class ContainerSourceSelectedItem : ItemContainerSource {
    public virtual ItemContainer GetItemContainer();
}
public static class ContextMenuUI : object {
}
[Factory("global")]
public class ConVar.Admin : ConsoleSystem {
    [ReplicatedVar]
public static bool allowAdminUI;
    private static Admin();
    [ServerVar]
public static void status(Arg arg);
    [ServerVar]
public static void stats(Arg arg);
    [ServerVar]
public static void upgrade_radius(Arg arg);
    [ServerVar]
public static void skin_radius(Arg arg);
    [ServerVar]
public static void add_wallpaper_radius(Arg arg);
    [ServerVar]
public static void change_wallpaper_radius(Arg arg);
    [ServerVar]
public static void clear_wallpaper_radius(Arg arg);
    public static BuildingGrade FindBuildingSkin(string name, String& error);
    private static void SkinRadiusInternal(Arg arg, bool changeAnyGrade);
    private static void wallpaper_radius_internal(Arg arg, bool addIfMissing);
    [ServerVar]
public static void killplayer(Arg arg);
    [ServerVar]
public static void killallplayers(Arg arg);
    [ServerVar]
public static void injureplayer(Arg arg);
    [ServerVar]
public static void recoverplayer(Arg arg);
    [ServerVar]
public static void kick(Arg arg);
    [ServerVar]
public static void skick(Arg arg);
    [ServerVar]
public static void kickall(Arg arg);
    [ServerVar]
public static void ban(Arg arg);
    [ServerVar]
public static void moderatorid(Arg arg);
    [ServerVar]
public static void ownerid(Arg arg);
    [ServerVar]
public static void removemoderator(Arg arg);
    [ServerVar]
public static void removeowner(Arg arg);
    [ServerVar]
public static void banid(Arg arg);
    private static bool TryGetBanExpiry(Arg arg, int n, Int64& expiry, String& durationSuffix);
    [ServerVar]
public static void unban(Arg arg);
    [ServerVar]
public static void skipqueue(Arg arg);
    [ServerVar]
public static void skipqueueid(Arg arg);
    [ServerVar]
public static void removeskipqueue(Arg arg);
    [ServerVar]
public static void players(Arg arg);
    [ServerVar]
public static void say(Arg arg);
    [ServerVar]
public static void users(Arg arg);
    [ServerVar]
public static void sleepingusers(Arg arg);
    [ServerVar]
public static void sleepingusersinrange(Arg arg);
    [ServerVar]
public static void usersinrange(Arg arg);
    [ServerVar]
public static void usersinrangeofplayer(Arg arg);
    [ServerVar]
public static void banlist(Arg arg);
    [ServerVar]
public static void banlistex(Arg arg);
    [ServerVar]
public static void listid(Arg arg);
    [ServerVar]
public static void mute(Arg arg);
    [ServerVar]
public static void unmute(Arg arg);
    [ServerVar]
public static void mutelist(Arg arg);
    [ServerVar]
public static void clientperf(Arg arg);
    [ServerVar]
public static void clientperf_frametime(Arg arg);
    [ServerVar]
public static void carstats(Arg arg);
    [ServerVar]
public static string teaminfo(Arg arg);
    [ServerVar]
public static void authradius(Arg arg);
    [ServerVar]
public static void deauthradius(Arg arg);
    private static void SetAuthInRadius(BasePlayer player, float radius, bool auth);
    private static bool SetUserAuthorized(BaseEntity entity, ulong userId, bool state);
    [ServerVar]
public static void entid(Arg arg);
    private static string AuthList(BaseEntity ent);
    private static string CodeLockAuthList(CodeLock codeLock);
    private static string CodeLockAuthList(BaseVehicleModule vehicleModule);
    public static string GetPlayerName(ulong steamId);
    public static string ChangeGrade(BaseEntity entity, int increaseBy, int decreaseBy, Enum targetGrade, ulong skin, float radius);
    private static bool RunInRadius(float radius, BaseEntity initial, Action`1<T> callback, Func`2<T, bool> filter);
    [ServerVar]
public static PlayerInfo[] playerlist();
    [ServerVar]
public static User[] Bans();
    [ServerVar]
public static ServerInfoOutput ServerInfo();
    [ServerVar]
public static BuildInfo BuildInfo();
    [ServerVar]
public static void AdminUI_FullRefresh(Arg arg);
    [ServerVar]
public static void AdminUI_RequestPlayerList(Arg arg);
    [ServerVar]
public static void AdminUI_RequestServerInfo(Arg arg);
    [ServerVar]
public static void AdminUI_RequestServerConvars(Arg arg);
    [ServerVar]
public static void AdminUI_RequestUGCList(Arg arg);
    [ServerVar]
public static void AdminUI_RequestUGCContent(Arg arg);
    [ServerVar]
public static void AdminUI_DeleteUGCContent(Arg arg);
    [ServerVar]
public static void AdminUI_RequestFireworkPattern(Arg arg);
    [ServerVar]
public static void clearugcentity(Arg arg);
    [ServerVar]
public static void clearugcentitiesinrange(Arg arg);
    [ServerVar]
public static void getugcinfo(Arg arg);
    [ServerVar]
public static void authcount(Arg arg);
    [ServerVar]
public static void entcount(Arg arg);
    private static void FindEntityAssociationsForPlayer(BasePlayer ply, bool useOwnerId, bool useAuth, string filter, List`1<EntityAssociation> results);
}
[Factory("ai")]
public class ConVar.AI : ConsoleSystem {
    [ReplicatedVar]
public static bool allowdesigning;
    [ServerVar]
public static bool think;
    [ServerVar]
public static bool navthink;
    [ServerVar]
public static bool ignoreplayers;
    [ServerVar]
public static bool groups;
    [ServerVar]
public static bool spliceupdates;
    [ServerVar]
public static bool setdestinationsamplenavmesh;
    [ServerVar]
public static bool usecalculatepath;
    [ServerVar]
public static bool usesetdestinationfallback;
    [ServerVar]
public static bool npcswimming;
    [ServerVar]
public static bool accuratevisiondistance;
    [ServerVar]
public static bool move;
    [ServerVar]
public static bool usegrid;
    [ServerVar]
public static bool sleepwake;
    [ServerVar]
public static float sensetime;
    [ServerVar]
public static float frametime;
    [ServerVar]
public static int ocean_patrol_path_iterations;
    [ServerVar]
public static bool npc_enable;
    [ServerVar]
public static int npc_max_population_military_tunnels;
    [ServerVar]
public static int npc_spawn_per_tick_max_military_tunnels;
    [ServerVar]
public static int npc_spawn_per_tick_min_military_tunnels;
    [ServerVar]
public static float npc_respawn_delay_max_military_tunnels;
    [ServerVar]
public static float npc_respawn_delay_min_military_tunnels;
    [ServerVar]
public static float npc_valid_aim_cone;
    [ServerVar]
public static float npc_valid_mounted_aim_cone;
    [ServerVar]
public static float npc_cover_compromised_cooldown;
    [ServerVar]
public static bool npc_cover_use_path_distance;
    [ServerVar]
public static float npc_cover_path_vs_straight_dist_max_diff;
    [ServerVar]
public static float npc_door_trigger_size;
    [ServerVar]
public static float npc_patrol_point_cooldown;
    [ServerVar]
public static float npc_speed_walk;
    [ServerVar]
public static float npc_speed_run;
    [ServerVar]
public static float npc_speed_sprint;
    [ServerVar]
public static float npc_speed_crouch_walk;
    [ServerVar]
public static float npc_speed_crouch_run;
    [ServerVar]
public static float npc_alertness_drain_rate;
    [ServerVar]
public static float npc_alertness_zero_detection_mod;
    [ServerVar]
public static float npc_junkpilespawn_chance;
    [ServerVar]
public static float npc_junkpile_a_spawn_chance;
    [ServerVar]
public static float npc_junkpile_g_spawn_chance;
    [ServerVar]
public static float npc_junkpile_dist_aggro_gate;
    [ServerVar]
public static int npc_max_junkpile_count;
    [ServerVar]
public static bool npc_families_no_hurt;
    [ServerVar]
public static bool npc_ignore_chairs;
    [ServerVar]
public static float npc_sensory_system_tick_rate_multiplier;
    [ServerVar]
public static float npc_cover_info_tick_rate_multiplier;
    [ServerVar]
public static float npc_reasoning_system_tick_rate_multiplier;
    [ServerVar]
public static bool animal_ignore_food;
    [ServerVar]
public static float npc_gun_noise_silencer_modifier;
    [ServerVar]
public static bool nav_carve_use_building_optimization;
    [ServerVar]
public static int nav_carve_min_building_blocks_to_apply_optimization;
    [ServerVar]
public static float nav_carve_min_base_size;
    [ServerVar]
public static float nav_carve_size_multiplier;
    [ServerVar]
public static float nav_carve_height;
    [ServerVar]
public static bool npc_only_hurt_active_target_in_safezone;
    [ServerVar]
public static bool npc_use_new_aim_system;
    [ServerVar]
public static bool npc_use_thrown_weapons;
    [ServerVar]
public static float npc_max_roam_multiplier;
    [ServerVar]
public static float npc_alertness_to_aim_modifier;
    [ServerVar]
public static float npc_deliberate_miss_to_hit_alignment_time;
    [ServerVar]
public static float npc_deliberate_miss_offset_multiplier;
    [ServerVar]
public static float npc_deliberate_hit_randomizer;
    [ServerVar]
public static float npc_htn_player_base_damage_modifier;
    [ServerVar]
public static bool npc_spawn_on_cargo_ship;
    [ServerVar]
public static int npc_htn_player_frustration_threshold;
    [ServerVar]
public static float tickrate;
    private static AI();
    [ServerVar]
public static void sleepwakestats(Arg args);
    [ServerVar]
public static void wakesleepingai(Arg args);
    [ServerVar]
public static void brainstats(Arg args);
    [ServerVar]
public static void aizonestats(Arg args);
    [ServerVar]
public static void killscientists(Arg args);
    [ServerVar]
public static void killanimals(Arg args);
    [ServerVar]
public static void addignoreplayer(Arg args);
    [ServerVar]
public static void removeignoreplayer(Arg args);
    [ServerVar]
public static void clearignoredplayers(Arg args);
    [ServerVar]
public static void printignoredplayers(Arg args);
    public static float TickDelta();
    [ServerVar]
public static void selectNPCLookatServer(Arg args);
}
[Factory("antihack")]
public class ConVar.AntiHack : ConsoleSystem {
    [HelpAttribute("collider margin when checking for noclipping on dismount")]
[ReplicatedVar]
public static float noclip_margin_dismount;
    [ReplicatedVar]
[HelpAttribute("collider backtracking when checking for noclipping")]
public static float noclip_backtracking;
    [HelpAttribute("report violations to the anti cheat backend")]
[ServerVar]
public static bool reporting;
    [HelpAttribute("are admins allowed to use their admin cheat")]
[ServerVar]
public static bool admincheat;
    [ServerVar]
[HelpAttribute("use antihack to verify object placement by players")]
public static bool objectplacement;
    [ServerVar]
[HelpAttribute("use antihack to verify model state sent by players")]
public static bool modelstate;
    [HelpAttribute("whether or not to force the position on the client")]
[ServerVar]
public static bool forceposition;
    [HelpAttribute("0 == allow RPCs from stalled players, 1 == ignore RPCs from currently stalled players, 2 == ignore RPCs from recently stalled players")]
[ServerVar]
public static int rpcstallmode;
    [HelpAttribute("time in seconds before player is no longer treated as wasStalled")]
[ServerVar]
public static float rpcstallfade;
    [HelpAttribute("time in seconds we can receive no ticks for before player is considered stalling")]
[ServerVar]
public static float rpcstallthreshold;
    [HelpAttribute("0 == users, 1 == admins, 2 == developers")]
[ServerVar]
public static int userlevel;
    [HelpAttribute("0 == no enforcement, 1 == kick, 2 == ban (DISABLED)")]
[ServerVar]
public static int enforcementlevel;
    [HelpAttribute("max allowed client desync, lower value = more false positives")]
[ServerVar]
public static float maxdesync;
    [ServerVar]
[HelpAttribute("max allowed client tick interval delta time, lower value = more false positives")]
public static float maxdeltatime;
    [ServerVar]
[HelpAttribute("for how many seconds to keep a tick history to use for distance checks")]
public static float tickhistorytime;
    [ServerVar]
[HelpAttribute("how much forgiveness to add when checking the distance from the player tick history")]
public static float tickhistoryforgiveness;
    [ServerVar]
[HelpAttribute("the rate at which violation values go back down")]
public static float relaxationrate;
    [HelpAttribute("the time before violation values go back down")]
[ServerVar]
public static float relaxationpause;
    [ServerVar]
[HelpAttribute("violation value above this results in enforcement")]
public static float maxviolation;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == enabled")]
public static int terrain_protection;
    [ServerVar]
[HelpAttribute("how many slices to subdivide players into for the terrain check")]
public static int terrain_timeslice;
    [ServerVar]
[HelpAttribute("how far to penetrate the terrain before violating")]
public static float terrain_padding;
    [ServerVar]
[HelpAttribute("violation penalty to hand out when terrain is detected")]
public static float terrain_penalty;
    [HelpAttribute("whether or not to kill the player when terrain is detected")]
[ServerVar]
public static bool terrain_kill;
    [ServerVar]
[HelpAttribute("whether or not to check for player inside geometry like rocks as well as base terrain")]
public static bool terrain_check_geometry;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == ray, 2 == sphere, 3 == curve")]
public static int noclip_protection;
    [ServerVar]
[HelpAttribute("whether or not to reject movement when noclip is detected")]
public static bool noclip_reject;
    [HelpAttribute("violation penalty to hand out when noclip is detected")]
[ServerVar]
public static float noclip_penalty;
    [ServerVar]
[HelpAttribute("collider margin when checking for noclipping")]
public static float noclip_margin;
    [HelpAttribute("movement curve step size, lower value = less false positives")]
[ServerVar]
public static float noclip_stepsize;
    [ServerVar]
[HelpAttribute("movement curve max steps, lower value = more false positives")]
public static int noclip_maxsteps;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == simple, 2 == advanced, 3 == vertical swim protection")]
public static int speedhack_protection;
    [ServerVar]
[HelpAttribute("whether or not to reject movement when speedhack is detected")]
public static bool speedhack_reject;
    [HelpAttribute("violation penalty to hand out when speedhack is detected")]
[ServerVar]
public static float speedhack_penalty;
    [ServerVar]
[HelpAttribute("speed threshold to assume speedhacking, lower value = more false positives")]
public static float speedhack_forgiveness;
    [ServerVar]
[HelpAttribute("speed threshold to assume speedhacking, lower value = more false positives")]
public static float speedhack_forgiveness_inertia;
    [ServerVar]
[HelpAttribute("speed forgiveness when moving down slopes, lower value = more false positives")]
public static float speedhack_slopespeed;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == client, 2 == capsule, 3 == curve")]
public static int flyhack_protection;
    [HelpAttribute("whether or not to reject movement when flyhack is detected")]
[ServerVar]
public static bool flyhack_reject;
    [HelpAttribute("violation penalty to hand out when flyhack is detected")]
[ServerVar]
public static float flyhack_penalty;
    [ServerVar]
[HelpAttribute("distance threshold to assume flyhacking, lower value = more false positives")]
public static float flyhack_forgiveness_vertical;
    [HelpAttribute("distance threshold to assume flyhacking, lower value = more false positives")]
[ServerVar]
public static float flyhack_forgiveness_vertical_inertia;
    [HelpAttribute("distance threshold to assume flyhacking, lower value = more false positives")]
[ServerVar]
public static float flyhack_forgiveness_horizontal;
    [HelpAttribute("distance threshold to assume flyhacking, lower value = more false positives")]
[ServerVar]
public static float flyhack_forgiveness_horizontal_inertia;
    [HelpAttribute("collider downwards extrusion when checking for flyhacking")]
[ServerVar]
public static float flyhack_extrusion;
    [ServerVar]
[HelpAttribute("collider margin when checking for flyhacking")]
public static float flyhack_margin;
    [HelpAttribute("movement curve step size, lower value = less false positives")]
[ServerVar]
public static float flyhack_stepsize;
    [HelpAttribute("movement curve max steps, lower value = more false positives")]
[ServerVar]
public static int flyhack_maxsteps;
    [ServerVar]
[HelpAttribute("serverside fall damage, requires flyhack_protection >= 2 for proper functionality")]
public static bool serverside_fall_damage;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == speed, 2 == speed + entity, 3 == speed + entity + LOS, 4 == speed + entity + LOS + trajectory, 5 == speed + entity + LOS + trajectory + update, 6 == speed + entity + LOS + trajectory + tickhistory")]
public static int projectile_protection;
    [ServerVar]
[HelpAttribute("violation penalty to hand out when projectile hack is detected")]
public static float projectile_penalty;
    [ServerVar]
[HelpAttribute("projectile speed forgiveness in percent, lower value = more false positives")]
public static float projectile_forgiveness;
    [HelpAttribute("projectile server frames to include in delay, lower value = more false positives")]
[ServerVar]
public static float projectile_serverframes;
    [HelpAttribute("projectile client frames to include in delay, lower value = more false positives")]
[ServerVar]
public static float projectile_clientframes;
    [ServerVar]
[HelpAttribute("projectile trajectory forgiveness, lower value = more false positives")]
public static float projectile_trajectory;
    [ServerVar]
[HelpAttribute("projectile penetration angle change, lower value = more false positives")]
public static float projectile_anglechange;
    [ServerVar]
[HelpAttribute("projectile penetration velocity change, lower value = more false positives")]
public static float projectile_velocitychange;
    [ServerVar]
[HelpAttribute("projectile desync forgiveness, lower value = more false positives")]
public static float projectile_desync;
    [HelpAttribute("projectile backtracking when checking for LOS")]
[ServerVar]
public static float projectile_backtracking;
    [ServerVar]
[HelpAttribute("line of sight directional forgiveness when checking eye or center position")]
public static float projectile_losforgiveness;
    [ServerVar]
[HelpAttribute("how often a projectile is allowed to penetrate something before its damage is ignored")]
public static int projectile_damagedepth;
    [ServerVar]
[HelpAttribute("how often a projectile is allowed to penetrate something before its impact spawn is ignored")]
public static int projectile_impactspawndepth;
    [ServerVar]
[HelpAttribute("whether or not to include terrain in the projectile LOS checks")]
public static bool projectile_terraincheck;
    [ServerVar]
[HelpAttribute("whether or not to include vehicles in the projectile LOS checks")]
public static bool projectile_vehiclecheck;
    [ServerVar]
[HelpAttribute("whether or not to compensate for the client / server vehicle position offset")]
public static bool projectile_positionoffset;
    [ServerVar]
[HelpAttribute("minimum distance before we verify client projectile distance mismatch, lower value = more false positives")]
public static float projectile_distance_forgiveness_minimum;
    [HelpAttribute("maximum number of projectile updates to allow before rejecting damage")]
[ServerVar]
public static int projectile_update_limit;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == initiator, 2 == initiator + target, 3 == initiator + target + LOS, 4 == initiator + target + LOS + tickhistory")]
public static int melee_protection;
    [ServerVar]
[HelpAttribute("violation penalty to hand out when melee hack is detected")]
public static float melee_penalty;
    [ServerVar]
[HelpAttribute("melee distance forgiveness in percent, lower value = more false positives")]
public static float melee_forgiveness;
    [HelpAttribute("melee server frames to include in delay, lower value = more false positives")]
[ServerVar]
public static float melee_serverframes;
    [ServerVar]
[HelpAttribute("melee client frames to include in delay, lower value = more false positives")]
public static float melee_clientframes;
    [ServerVar]
[HelpAttribute("melee backtracking when checking for LOS")]
public static float melee_backtracking;
    [ServerVar]
[HelpAttribute("line of sight directional forgiveness when checking eye or center position")]
public static float melee_losforgiveness;
    [ServerVar]
[HelpAttribute("whether or not to include terrain in the melee LOS checks")]
public static bool melee_terraincheck;
    [HelpAttribute("whether or not to include vehicles in the melee LOS checks")]
[ServerVar]
public static bool melee_vehiclecheck;
    [ServerVar]
[HelpAttribute("0 == disabled, 1 == distance, 2 == distance + LOS, 3 = distance + LOS + altitude, 4 = distance + LOS + altitude + noclip, 5 = distance + LOS + altitude + noclip + history")]
public static int eye_protection;
    [HelpAttribute("violation penalty to hand out when eye hack is detected")]
[ServerVar]
public static float eye_penalty;
    [HelpAttribute("eye distance forgiveness, lower value = more false positives")]
[ServerVar]
public static float eye_forgiveness;
    [ServerVar]
[HelpAttribute("eye distance forgiveness for parented or mounted players, lower value = more false positives")]
public static float eye_distance_parented_mounted_forgiveness;
    [ServerVar]
[HelpAttribute("eye server frames to include in delay, lower value = more false positives")]
public static float eye_serverframes;
    [ServerVar]
[HelpAttribute("eye client frames to include in delay, lower value = more false positives")]
public static float eye_clientframes;
    [ServerVar]
[HelpAttribute("whether or not to include terrain in the eye LOS checks")]
public static bool eye_terraincheck;
    [HelpAttribute("whether or not to include vehicles in the eye LOS checks")]
[ServerVar]
public static bool eye_vehiclecheck;
    [HelpAttribute("distance at which to start testing eye noclipping")]
[ServerVar]
public static float eye_noclip_cutoff;
    [ServerVar]
[HelpAttribute("collider margin when checking for noclipping")]
public static float eye_noclip_margin;
    [ServerVar]
[HelpAttribute("collider backtracking when checking for noclipping")]
public static float eye_noclip_backtracking;
    [ServerVar]
[HelpAttribute("line of sight sphere cast radius, 0 == raycast")]
public static float eye_losradius;
    [HelpAttribute("violation penalty to hand out when eye history mismatch is detected")]
[ServerVar]
public static float eye_history_penalty;
    [ServerVar]
[HelpAttribute("how much forgiveness to add when checking the distance between player tick history and player eye history")]
public static float eye_history_forgiveness;
    [ServerVar]
[HelpAttribute("maximum distance an impact effect can be from the entities bounds")]
public static float impact_effect_distance_forgiveness;
    [HelpAttribute("line of sight sphere cast radius, 0 == raycast")]
[ServerVar]
public static float build_losradius;
    [ServerVar]
[HelpAttribute("line of sight sphere cast radius, 0 == raycast")]
public static float build_losradius_sleepingbag;
    [ServerVar]
[HelpAttribute("whether or not to include terrain in the build LOS checks")]
public static bool build_terraincheck;
    [ServerVar]
[HelpAttribute("whether or not to include vehicles in the build LOS checks")]
public static bool build_vehiclecheck;
    [ServerVar]
[HelpAttribute("whether or not to check for building being done on the wrong side of something (e.g. inside rocks). 0 = Disabled, 1 = Info only, 2 = Enabled")]
public static int build_inside_check;
    [HelpAttribute("whether or not to ensure players are always networked to server administrators")]
[ServerVar]
public static bool server_occlusion_admin_bypass;
    [HelpAttribute("0 == silent, 1 == print max violation, 2 == print nonzero violation, 3 == print any violation except noclip, 4 == print any violation")]
[ServerVar]
public static int debuglevel;
    private static AntiHack();
}
[Factory("app")]
public class ConVar.App : ConsoleSystem {
    [ServerVar]
public static string listenip;
    [ServerVar]
public static int port;
    [ServerVar]
public static string publicip;
    [ServerVar]
public static bool update;
    [ServerVar]
public static bool notifications;
    [ServerVar]
public static int queuelimit;
    [ReplicatedVar]
public static string serverid;
    [ServerVar]
public static float alarmcooldown;
    [ServerVar]
public static int maxconnections;
    [ServerVar]
public static int maxconnectionsperip;
    [ServerVar]
public static int maxmessagesize;
    private static App();
    [AsyncStateMachineAttribute("ConVar.App/<pair>d__11")]
[ServerUserVar]
public static void pair(Arg arg);
    [ServerUserVar]
public static void regeneratetoken(Arg arg);
    [ServerVar]
public static void info(Arg arg);
    [ServerVar]
public static void retry_initialize(Arg arg);
    [ServerVar]
public static void resetlimiter(Arg arg);
    [ServerVar]
public static void connections(Arg arg);
    [ServerVar]
public static void appban(Arg arg);
    [ServerVar]
public static void appunban(Arg arg);
    public static IPAddress GetListenIP();
    [AsyncStateMachineAttribute("ConVar.App/<GetPublicIPAsync>d__20")]
public static ValueTask`1<string> GetPublicIPAsync();
    public static string GetPublicIP();
}
[Factory("audio")]
public class ConVar.Audio : ConsoleSystem {
    [ClientVar]
public static float master;
    [ClientVar]
public static float musicvolume;
    [ClientVar]
public static float musicvolumemenu;
    [ClientVar]
public static float game;
    [ClientVar]
public static float voices;
    [ClientVar]
public static float instruments;
    [ClientVar]
public static float voiceProps;
    [ClientVar]
public static float eventAudio;
    [ClientVar]
public static bool ambience;
    [ClientVar]
public static float framebudget;
    [ClientVar]
public static float minupdatefraction;
    [ClientVar]
public static bool advancedocclusion;
    [ClientVar]
public static bool hqsoundfade;
    [ClientVar]
public static bool debugVoiceLimiting;
    [ClientVar]
public static bool enableSoundPooling;
    [ClientVar]
public static int speakers { get; public set; }
    private static Audio();
    public static int get_speakers();
    public static void set_speakers(int value);
    [ClientVar]
public static void printSounds(Arg arg);
    [ClientVar]
public static void printEngineSounds(Arg arg);
}
[Factory("batching")]
public class ConVar.Batching : ConsoleSystem {
    [ClientVar]
public static bool renderers;
    [ClientVar]
public static bool renderer_threading;
    [ClientVar]
public static int renderer_capacity;
    [ClientVar]
public static int renderer_vertices;
    [ClientVar]
public static int renderer_submeshes;
    [ClientVar]
[ServerVar]
public static int verbose;
    private static Batching();
}
[Factory("bradley")]
public class ConVar.Bradley : ConsoleSystem {
    [ServerVar]
public static float respawnDelayMinutes;
    [ServerVar]
public static float respawnDelayVariance;
    [ServerVar]
public static bool enabled;
    private static Bradley();
    [ServerVar]
public static void quickrespawn(Arg arg);
}
[Factory("chat")]
public class ConVar.Chat : ConsoleSystem {
    [ServerVar]
public static float localChatRange;
    [ReplicatedVar]
public static bool globalchat;
    [ReplicatedVar]
public static bool localchat;
    private static float textVolumeBoost;
    [ReplicatedVar]
public static bool hideChatInTutorial;
    [ClientVar]
[ServerVar]
public static bool enabled;
    [ServerVar]
public static int historysize;
    public static CircularBuffer`1<ChatEntry> History;
    [ServerVar]
public static bool serverlog;
    private static Chat();
    public static void Broadcast(string message, string username, string color, ulong userid);
    [ServerUserVar]
public static void say(Arg arg);
    [ServerUserVar]
public static void localsay(Arg arg);
    [ServerUserVar]
public static void teamsay(Arg arg);
    [ServerUserVar]
public static void cardgamesay(Arg arg);
    [ServerUserVar]
public static void clansay(Arg arg);
    private static void sayImpl(ChatChannel targetChannel, Arg arg);
    internal static string GetNameColor(ulong userId, BasePlayer player);
    [AsyncStateMachineAttribute("ConVar.Chat/<sayAs>d__19")]
internal static ValueTask`1<bool> sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player);
    [ServerVar]
[HelpAttribute("Return the last x lines of the console. Default is 200")]
public static IEnumerable`1<ChatEntry> tail(Arg arg);
    [ServerVar]
[HelpAttribute("Search the console for a particular string")]
public static IEnumerable`1<ChatEntry> search(Arg arg);
    public static void Record(ChatEntry ce);
}
[Factory("clan")]
public class ConVar.Clan : ConsoleSystem {
    [ReplicatedVar]
public static bool editsRequireClanTable;
    [ServerVar]
public static bool enabled;
    [ServerVar]
public static int maxMemberCount;
    [ServerVar]
public static int scoreForKillingPlayerInOtherClan;
    [ServerVar]
public static int scoreForKilledByPlayerInOtherClan;
    [ServerVar]
public static int scoreForKillingUnarmedPlayer;
    [ServerVar]
public static int scoreForDestroyingToolCupboards;
    [ServerVar]
public static int scoreForHackingCrates;
    [ServerVar]
public static int scoreForOpeningHackedCrates;
    [ServerVar]
public static int scoreForDestroyingBradley;
    [ServerVar]
public static int scoreForRunningExcavator;
    [ServerVar]
public static int scoreForReachingCargoShip;
    [ServerVar]
public static int scoreForLootingEliteCrate;
    private static Clan();
    [ServerVar]
public static void Info(Arg arg);
    [AsyncStateMachineAttribute("ConVar.Clan/<GetPlayerClan>d__14")]
private static ValueTask`1<IClan> GetPlayerClan(BasePlayer player);
    [AsyncStateMachineAttribute("ConVar.Clan/<GetClanByID>d__15")]
private static ValueTask`1<IClan> GetClanByID(long clanId, BasePlayer player);
    public static int GetScoreForEvent(ClanScoreEventType eventType);
    [AsyncStateMachineAttribute("ConVar.Clan/<<Info>g__SendClanInfoConsole|13_1>d")]
[CompilerGeneratedAttribute]
internal static void <Info>g__SendClanInfoConsole|13_1(long id);
    [CompilerGeneratedAttribute]
internal static string <Info>g__FormatClan|13_2(IClan clan);
    [CompilerGeneratedAttribute]
internal static int <GetScoreForEvent>g__Unknown|16_0(ClanScoreEventType type);
}
[Factory("client")]
public class ConVar.Client : ConsoleSystem {
}
[Factory("console")]
public class ConVar.Console : ConsoleSystem {
    [ServerVar]
[HelpAttribute("Return the last x lines of the console. Default is 200")]
public static IEnumerable`1<Entry> tail(Arg arg);
    [HelpAttribute("Search the console for a particular string")]
[ServerVar]
public static IEnumerable`1<Entry> search(Arg arg);
}
[Factory("construct")]
public class ConVar.Construct : ConsoleSystem {
    [ServerVar]
[HelpAttribute("How many minutes before a placed frame gets destroyed")]
public static float frameminutes;
    private static Construct();
}
[Factory("craft")]
public class ConVar.Craft : ConsoleSystem {
    [ServerVar]
public static bool instant;
    [ServerUserVar]
public static void add(Arg args);
    [ServerUserVar]
public static void canceltask(Arg args);
    [ServerUserVar]
public static void cancel(Arg args);
    [ServerUserVar]
public static void fasttracktask(Arg args);
}
public class ConVar.Creative : ConsoleSystem {
    [ReplicatedVar]
public static bool allUsers;
    [ReplicatedVar]
public static bool freeRepair;
    [ReplicatedVar]
public static bool freeBuild;
    [ReplicatedVar]
public static bool freePlacement;
    [ReplicatedVar]
public static bool unlimitedIo;
    [ServerVar]
public static void toggleCreativeModeUser(Arg arg);
}
[Factory("culling")]
public class ConVar.Culling : ConsoleSystem {
}
[Factory("data")]
public class ConVar.Data : ConsoleSystem {
    [ClientVar]
[ServerVar]
public static void export(Arg args);
}
public class ConVar.DDraw : object {
}
[Factory("debug")]
public class ConVar.Debugging : ConsoleSystem {
    [ServerVar]
[ClientVar]
public static bool checktriggers;
    [ServerVar]
public static bool checkparentingtriggers;
    [ClientVar]
[ServerVar]
public static bool DebugDismounts;
    [ServerVar]
public static bool disablecondition;
    [ServerVar]
public static int tutorial_start_cooldown;
    [ServerVar]
public static bool printMissionSpeakInfo;
    [ClientVar]
[ServerVar]
public static bool callbacks;
    [ClientVar]
[ServerVar]
public static bool log { get; public set; }
    private static Debugging();
    [ClientVar]
[ServerVar]
public static void renderinfo(Arg arg);
    public static void set_log(bool value);
    public static bool get_log();
    [ServerVar]
public static void enable_player_movement(Arg arg);
    [ClientVar]
[ServerVar]
public static void stall(Arg arg);
    [ServerVar]
public static void repair_inventory(Arg args);
    [ServerVar]
public static void spawnParachuteTester(Arg arg);
    [ServerVar]
public static string testTutorialCinematic(Arg arg);
    [ServerVar]
public static void clearTutorialForPlayer(Arg arg);
    [ServerVar]
public static void deleteEntitiesByShortname(Arg arg);
    [ServerVar]
public static void printgroups(Arg arg);
    [ServerVar]
public static void flushgroup(Arg arg);
    [ServerVar]
public static void breakheld(Arg arg);
    [ServerVar]
public static void breakheld_almost(Arg arg);
    [ServerVar]
public static void puzzlereset(Arg arg);
    [ServerVar]
public static void puzzleprefabrespawn(Arg arg);
    [ServerVar]
public static void breakitem(Arg arg);
    [ServerVar]
public static void refillvitals(Arg arg);
    [ServerVar]
public static void refillvitalsall(Arg arg);
    private static void RefillPlayerVitals(BasePlayer player);
    [ServerVar]
public static void heal(Arg arg);
    [ServerVar]
public static void hurt(Arg arg);
    [ServerVar]
public static void eat(Arg arg);
    [ServerVar]
public static void drink(Arg arg);
    [ServerVar]
public static void sethealth(Arg arg);
    [ServerVar]
public static void setdamage(Arg arg);
    [ServerVar]
public static void setfood(Arg arg);
    [ServerVar]
public static void setwater(Arg arg);
    [ServerVar]
public static void setradiation(Arg arg);
    private static void AdjustHealth(BasePlayer player, float amount, string bone);
    private static void AdjustCalories(BasePlayer player, float amount, float time);
    private static void AdjustHydration(BasePlayer player, float amount, float time);
    private static void AdjustRadiation(BasePlayer player, float amount, float time);
    private static void AdjustBleeding(BasePlayer player, float amount, float time);
    private static void setattribute(Arg arg, Type type);
    private static BasePlayer GetUsePlayer(Arg arg, int playerArgument);
    [ServerVar]
public static void ResetSleepingBagTimers(Arg arg);
    [ServerVar]
public static void bench_io(Arg arg);
    [ServerVar]
public static void completeMissionStage(Arg arg);
    [ServerVar]
public static void completeMission(Arg arg);
    [ServerUserVar]
public static void startTutorial(Arg arg);
    [ServerVar]
public static void completeTutorial(Arg arg);
    [ServerUserVar]
public static void quitTutorial(Arg arg);
    [ServerVar]
public static void tutorialStatus(Arg arg);
    [CompilerGeneratedAttribute]
internal static void <bench_io>g__Connect|42_0(IOEntity InputIOEnt, IOEntity OutputIOEnt);
}
[Factory("decay")]
public class ConVar.Decay : ConsoleSystem {
    [ServerVar]
public static float outside_test_range;
    [ServerVar]
public static float tick;
    [ServerVar]
public static float scale;
    [ServerVar]
public static bool debug;
    [ServerVar]
public static bool upkeep;
    [ServerVar]
public static float upkeep_period_minutes;
    [ServerVar]
public static float upkeep_grief_protection;
    [ServerVar]
public static float upkeep_heal_scale;
    [ServerVar]
public static float upkeep_inside_decay_scale;
    [ServerVar]
public static float delay_override;
    [ServerVar]
public static float delay_twig;
    [ServerVar]
public static float delay_wood;
    [ServerVar]
public static float delay_stone;
    [ServerVar]
public static float delay_metal;
    [ServerVar]
public static float delay_toptier;
    [ServerVar]
public static float duration_override;
    [ServerVar]
public static float duration_twig;
    [ServerVar]
public static float duration_wood;
    [ServerVar]
public static float duration_stone;
    [ServerVar]
public static float duration_metal;
    [ServerVar]
public static float duration_toptier;
    [ServerVar]
public static int bracket_0_blockcount;
    [ServerVar]
public static float bracket_0_costfraction;
    [ServerVar]
public static int bracket_1_blockcount;
    [ServerVar]
public static float bracket_1_costfraction;
    [ServerVar]
public static int bracket_2_blockcount;
    [ServerVar]
public static float bracket_2_costfraction;
    [ServerVar]
public static int bracket_3_blockcount;
    [ServerVar]
public static float bracket_3_costfraction;
    private static Decay();
}
[Factory("decor")]
public class ConVar.Decor : ConsoleSystem {
}
[Factory("demo")]
public class ConVar.Demo : ConsoleSystem {
    public static UInt32 Version;
    [ServerVar]
public static float splitseconds;
    [ServerVar]
public static float splitmegabytes;
    [ServerVar]
public static string recordlist;
    private static int _recordListModeValue;
    [ServerVar]
public static bool UploadDemos { get; public set; }
    [ServerVar]
public static string UploadUrl { get; public set; }
    [ServerVar]
public static bool ServerDemosEnabled { get; public set; }
    [ServerVar]
public static int ServerDemoFlushInterval { get; public set; }
    [ServerVar]
public static float UploadBandwidthLimitRatio { get; public set; }
    [ServerVar]
public static string ServerDemoDirectory { get; public set; }
    [ServerVar]
public static bool DeleteDemoAfterUpload { get; public set; }
    [ServerVar]
public static bool ZipServerDemos { get; public set; }
    [ServerVar]
public static int MaxDemoDiskSpaceGB { get; public set; }
    [ServerVar]
public static int DemoDiskCleanupIntervalMinutes { get; public set; }
    [ServerVar]
public static int DemoUploadConcurrency { get; public set; }
    [ServerVar]
public static int recordlistmode { get; public set; }
    private static Demo();
    public static bool get_UploadDemos();
    public static void set_UploadDemos(bool value);
    public static string get_UploadUrl();
    public static void set_UploadUrl(string value);
    public static bool get_ServerDemosEnabled();
    public static void set_ServerDemosEnabled(bool value);
    public static int get_ServerDemoFlushInterval();
    public static void set_ServerDemoFlushInterval(int value);
    public static float get_UploadBandwidthLimitRatio();
    public static void set_UploadBandwidthLimitRatio(float value);
    public static string get_ServerDemoDirectory();
    public static void set_ServerDemoDirectory(string value);
    public static bool get_DeleteDemoAfterUpload();
    public static void set_DeleteDemoAfterUpload(bool value);
    public static bool get_ZipServerDemos();
    public static void set_ZipServerDemos(bool value);
    public static int get_MaxDemoDiskSpaceGB();
    public static void set_MaxDemoDiskSpaceGB(int value);
    public static int get_DemoDiskCleanupIntervalMinutes();
    public static void set_DemoDiskCleanupIntervalMinutes(int value);
    public static int get_DemoUploadConcurrency();
    public static void set_DemoUploadConcurrency(int value);
    [ServerVar]
public static void BenchmarkDemoUpload(Arg arg);
    public static int get_recordlistmode();
    public static void set_recordlistmode(int value);
    [ServerVar]
public static string record(Arg arg);
    [ServerVar]
public static string stop(Arg arg);
}
[Factory("editor")]
public class ConVar.Editor : ConsoleSystem {
}
[Factory("effects")]
public class ConVar.Effects : ConsoleSystem {
}
[Factory("entity")]
public class ConVar.Entity : ConsoleSystem {
    private static TextTable GetEntityTable(Func`2<EntityInfo, bool> filter);
    [ServerVar]
[ClientVar]
public static void find_entity(Arg args);
    [ServerVar]
[ClientVar]
public static void find_id(Arg args);
    [ServerVar]
[ClientVar]
public static void find_group(Arg args);
    [ClientVar]
[ServerVar]
public static void find_parent(Arg args);
    [ClientVar]
[ServerVar]
public static void find_status(Arg args);
    [ServerVar]
[ClientVar]
public static void find_radius(Arg args);
    [ClientVar]
[ServerVar]
public static void find_self(Arg args);
    [ServerVar]
public static void debug_toggle(Arg args);
    [ServerVar]
public static void nudge(Arg args);
    public static EntitySpawnRequest GetSpawnEntityFromName(string name);
    [ServerVar]
public static string svspawn(string name, Vector3 pos, Vector3 dir, int forceUp);
    [ServerVar]
public static string svspawnitem(string name, Vector3 pos);
    [ServerVar]
public static string svspawngrid(string name, int width, int height, int spacing);
    [ServerVar]
public static void spawnlootfrom(Arg args);
    public static int DeleteBy(ulong id);
    [ServerVar]
public static int DeleteBy(Arg arg);
    private static int DeleteBy(List`1<ulong> ids);
    [ServerVar]
public static void DeleteByTextBlock(Arg arg);
}
[Factory("env")]
public class ConVar.Env : ConsoleSystem {
    [ClientVar]
public static bool nightlight_enabled;
    [ClientVar]
public static bool nightlight_debugcamera_enabled;
    private static float nightlight_distance_internal;
    private static float nightlight_fadefraction_internal;
    private static float nightlight_brightness_internal;
    [ServerVar]
public static bool progresstime { get; public set; }
    [ServerVar]
public static float time { get; public set; }
    [ServerVar]
public static int day { get; public set; }
    [ServerVar]
public static int month { get; public set; }
    [ServerVar]
public static int year { get; public set; }
    [ReplicatedVar]
public static float oceanlevel { get; public set; }
    [ReplicatedVar]
public static float nightlight_distance { get; public set; }
    [ReplicatedVar]
public static float nightlight_fadefraction { get; public set; }
    [ReplicatedVar]
public static float nightlight_brightness { get; public set; }
    private static Env();
    public static void set_progresstime(bool value);
    public static bool get_progresstime();
    public static void set_time(float value);
    public static float get_time();
    public static void set_day(int value);
    public static int get_day();
    public static void set_month(int value);
    public static int get_month();
    public static void set_year(int value);
    public static int get_year();
    [ServerVar]
public static void addtime(Arg arg);
    public static float get_oceanlevel();
    public static void set_oceanlevel(float value);
    public static float get_nightlight_distance();
    public static void set_nightlight_distance(float value);
    public static float get_nightlight_fadefraction();
    public static void set_nightlight_fadefraction(float value);
    public static float get_nightlight_brightness();
    public static void set_nightlight_brightness(float value);
}
[Factory("file")]
public class ConVar.FileConVar : ConsoleSystem {
    [ClientVar]
public static bool debug { get; public set; }
    [ClientVar]
public static bool time { get; public set; }
    public static bool get_debug();
    public static void set_debug(bool value);
    public static bool get_time();
    public static void set_time(bool value);
}
[Factory("fps")]
public class ConVar.FPS : ConsoleSystem {
    private static int _limit;
    private static int m_graph;
    [ServerVar]
[ClientVar]
public static int limit { get; public set; }
    [ClientVar]
public static int graph { get; public set; }
    private static FPS();
    public static int get_limit();
    public static void set_limit(int value);
    public static int get_graph();
    public static void set_graph(int value);
}
[Factory("gamemode")]
public class ConVar.gamemode : ConsoleSystem {
    [ServerUserVar]
public static void setteam(Arg arg);
    [ServerVar]
public static void set(Arg arg);
}
[Factory("gc")]
public class ConVar.GC : ConsoleSystem {
    [ClientVar]
public static bool buffer_enabled;
    [ClientVar]
public static int debuglevel;
    [ClientVar]
public static int buffer;
    public static int safeBuffer { get; public set; }
    [ClientVar]
[ServerVar]
public static bool incremental_enabled { get; public set; }
    [ClientVar]
[ServerVar]
public static int incremental_milliseconds { get; public set; }
    [ClientVar]
[ServerVar]
public static bool enabled { get; public set; }
    private static GC();
    public static int get_safeBuffer();
    public static void set_safeBuffer(int value);
    public static bool get_incremental_enabled();
    public static void set_incremental_enabled(bool value);
    public static int get_incremental_milliseconds();
    public static void set_incremental_milliseconds(int value);
    public static bool get_enabled();
    public static void set_enabled(bool value);
    [ClientVar]
[ServerVar]
public static void collect();
    [ClientVar]
[ServerVar]
public static void unload();
    [ServerVar]
[ClientVar]
public static void alloc(Arg args);
}
[Factory("global")]
public class ConVar.Global : ConsoleSystem {
    private static int _developer;
    [ServerVar]
[ClientVar]
public static bool skipAssetWarmup_crashes;
    [ServerVar]
[ClientVar]
public static int maxthreads;
    private static int DefaultWarmupConcurrency;
    private static int DefaultPreloadConcurrency;
    [ServerVar]
[ClientVar]
public static int warmupConcurrency;
    [ServerVar]
[ClientVar]
public static int preloadConcurrency;
    [ClientVar]
[ServerVar]
public static bool forceUnloadBundles;
    private static bool DefaultAsyncWarmupEnabled;
    [ClientVar]
[ServerVar]
public static bool asyncWarmup;
    [ClientVar]
public static int asyncLoadingPreset;
    [ServerVar]
public static bool updateNetworkPositionWithDebugCameraWhileSpectating;
    [ServerVar]
[ClientVar]
public static int perf;
    [ClientVar]
public static bool god;
    [ClientVar]
[ServerVar]
public static bool cinematicGingerbreadCorpses;
    private static UInt32 _gingerbreadMaterialID;
    [ServerVar]
public static float SprayOutOfAuthMultiplier;
    [ServerVar]
public static float SprayDuration;
    [ServerVar]
public static int MaxSpraysPerPlayer;
    [ServerVar]
public static bool disableBagDropping;
    [ClientVar]
public static bool blockEmojiAnimations;
    [ClientVar]
public static bool blockEmoji;
    [ClientVar]
public static bool blockServerEmoji;
    [ClientVar]
public static bool showEmojiErrors;
    [ServerVar]
[ClientVar]
public static int developer { get; public set; }
    [ClientVar]
[ServerVar]
public static int job_system_threads { get; public set; }
    private static Global();
    public static void set_developer(int value);
    public static int get_developer();
    public static int get_job_system_threads();
    public static void set_job_system_threads(int value);
    public static void ApplyAsyncLoadingPreset();
    [ServerVar]
public static void restart(Arg args);
    [ClientVar]
[ServerVar]
public static void quit(Arg args);
    [ServerVar]
public static void report(Arg args);
    [ClientVar]
[ServerVar]
public static void objects(Arg args);
    [ServerVar]
[ClientVar]
public static void textures(Arg args);
    [ClientVar]
[ServerVar]
public static void colliders(Arg args);
    [ClientVar]
[ServerVar]
public static void error(Arg args);
    [ClientVar]
[ServerVar]
public static void queue(Arg args);
    [ServerUserVar]
public static void setinfo(Arg args);
    [ServerVar]
public static void sleep(Arg args);
    [ServerVar]
public static void sleeptarget(Arg args);
    [ServerUserVar]
public static void kill(Arg args);
    [ServerUserVar]
public static void respawn(Arg args);
    [ServerVar]
public static void injure(Arg args);
    public static void InjurePlayer(BasePlayer ply);
    [ServerVar]
public static void recover(Arg args);
    public static void RecoverPlayer(BasePlayer ply);
    [ServerVar]
public static void spectate(Arg args);
    [ServerVar]
public static void toggleSpectateTeamInfo(Arg args);
    [ServerVar]
public static void spectateid(Arg args);
    [ServerUserVar]
public static void respawn_sleepingbag(Arg args);
    [ServerUserVar]
public static void respawn_sleepingbag_remove(Arg args);
    [ServerUserVar]
public static void status_sv(Arg args);
    [ClientVar]
public static void status_cl(Arg args);
    [ServerVar]
public static void teleport(Arg args);
    [ServerVar]
public static void teleport2me(Arg args);
    [ServerVar]
public static void teleporteveryone2me(Arg args);
    [ServerVar]
public static void teleportsleepers2me(Arg args);
    [ServerVar]
public static void teleportnonsleepers2me(Arg args);
    private static void TeleportPlayersToMe(BasePlayer player, bool includeSleepers, bool includeNonSleepers);
    [ServerVar]
public static void teleportany(Arg args);
    [ServerVar]
public static void teleportpos(Arg args);
    [ServerVar]
public static void teleportlos(Arg args);
    [ServerVar]
public static void teleport2owneditem(Arg arg);
    [ServerVar]
public static void teleport2autheditem(Arg arg);
    [ServerVar]
public static void teleport2marker(Arg arg);
    private static void TeleportToMarker(MapNote marker, BasePlayer player);
    [ServerVar]
public static void teleport2death(Arg arg);
    [ServerVar]
[ClientVar]
public static void free(Arg args);
    [ServerVar]
[ClientVar]
public static void version(Arg arg);
    [ClientVar]
[ServerVar]
public static void sysinfo(Arg arg);
    [ServerVar]
[ClientVar]
public static void sysuid(Arg arg);
    [ServerVar]
public static void breakitem(Arg args);
    [ServerVar]
public static void breakclothing(Arg args);
    [ClientVar]
[ServerVar]
public static void subscriptions(Arg arg);
    public static UInt32 GingerbreadMaterialID();
    [ServerVar]
public static void ClearAllSprays();
    [ServerVar]
public static void ClearAllSpraysByPlayer(Arg arg);
    [ServerVar]
public static void ClearSpraysInRadius(Arg arg);
    private static int ClearSpraysInRadius(Vector3 position, float radius);
    [ServerVar]
public static void ClearSpraysAtPositionInRadius(Arg arg);
    [ServerVar]
public static void ClearDroppedItems();
    [ClientVar]
[ServerVar]
public static string printAllScenesInBuild(Arg args);
    [ServerVar]
public static void UpdateManifest(Arg args);
    [AsyncStateMachineAttribute("ConVar.Global/<<respawn_sleepingbag>g__NexusRespawn|39_0>d")]
[CompilerGeneratedAttribute]
internal static void <respawn_sleepingbag>g__NexusRespawn|39_0(BasePlayer player, NexusZoneDetails toZone, NetworkableId sleepingBag);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("ConVar.Global/<<respawn_sleepingbag_remove>g__NexusRemoveBag|40_0>d")]
internal static void <respawn_sleepingbag_remove>g__NexusRemoveBag|40_0(BasePlayer player, string zoneKey, NetworkableId sleepingBag);
}
[Factory("graphics")]
public class ConVar.Graphics : ConsoleSystem {
    private static float MinShadowDistance;
    private static float MaxShadowDistance2Split;
    private static float MaxShadowDistance4Split;
    private static float _shadowdistance;
    [ClientVar]
public static int shadowmode;
    [ClientVar]
public static int shadowlights;
    private static int _shadowquality;
    [ClientVar]
public static bool grassshadows;
    [ClientVar]
public static bool contactshadows;
    [ClientVar]
public static float drawdistance;
    private static EncryptedValue`1<float> _fov;
    [ClientVar]
public static bool hud;
    [ClientVar]
public static bool chat;
    [ClientVar]
public static bool branding;
    [ClientVar]
public static int compass;
    [ClientVar]
public static bool dof;
    [ClientVar]
public static float dof_aper;
    [ClientVar]
public static float dof_blur;
    [ClientVar]
public static int dof_mode;
    [ClientVar]
public static float dof_focus_dist;
    [ClientVar]
public static float dof_focus_time;
    [ClientVar]
public static float dof_squeeze;
    [ClientVar]
public static float dof_barrel;
    [ClientVar]
public static bool dof_debug;
    [ClientVar]
public static int dof_kernel_count;
    public static BaseEntity dof_focus_target_entity;
    [ClientVar]
public static bool vm_fov_scale;
    [ClientVar]
public static bool vm_horizontal_flip;
    private static float _uiscale;
    private static int _anisotropic;
    private static int _parallax;
    [ClientVar]
public static int quality { get; public set; }
    [ClientVar]
public static float shadowdistance { get; public set; }
    [ClientVar]
public static int shadowcascades { get; public set; }
    [ClientVar]
public static int shadowquality { get; public set; }
    [ClientVar]
public static float fov { get; public set; }
    [ClientVar]
public static float lodbias { get; public set; }
    [ClientVar]
public static int shaderlod { get; public set; }
    [ClientVar]
public static float uiscale { get; public set; }
    [ClientVar]
public static int af { get; public set; }
    [ClientVar]
public static int parallax { get; public set; }
    [ClientVar]
public static bool itemskins { get; public set; }
    [ClientVar]
public static bool itemskinunload { get; public set; }
    [ClientVar]
public static float itemskintimeout { get; public set; }
    private static Graphics();
    public static int get_quality();
    public static void set_quality(int value);
    public static float EnforceShadowDistanceBounds(float distance);
    public static float get_shadowdistance();
    public static void set_shadowdistance(float value);
    public static int get_shadowcascades();
    public static void set_shadowcascades(int value);
    public static int get_shadowquality();
    public static void set_shadowquality(int value);
    public static float get_fov();
    public static void set_fov(float value);
    public static float get_lodbias();
    public static void set_lodbias(float value);
    [ClientVar]
public static void dof_focus_target(Arg arg);
    [ClientVar]
public static void dof_nudge(Arg arg);
    public static int get_shaderlod();
    public static void set_shaderlod(int value);
    public static float get_uiscale();
    public static void set_uiscale(float value);
    public static int get_af();
    public static void set_af(int value);
    public static int get_parallax();
    public static void set_parallax(int value);
    public static bool get_itemskins();
    public static void set_itemskins(bool value);
    public static bool get_itemskinunload();
    public static void set_itemskinunload(bool value);
    public static float get_itemskintimeout();
    public static void set_itemskintimeout(float value);
}
[Factory("grass")]
public class ConVar.Grass : ConsoleSystem {
}
[Factory("halloween")]
public class ConVar.Halloween : ConsoleSystem {
    [ServerVar]
public static bool enabled;
    [ServerVar]
public static float murdererpopulation;
    [ServerVar]
public static float scarecrowpopulation;
    [ServerVar]
public static bool scarecrows_throw_beancans;
    [ServerVar]
public static float scarecrow_throw_beancan_global_delay;
    [ServerVar]
public static float scarecrow_beancan_vs_player_dmg_modifier;
    [ServerVar]
public static float scarecrow_body_dmg_modifier;
    [ServerVar]
public static float scarecrow_chase_stopping_distance;
    private static Halloween();
}
[Factory("harmony")]
public class ConVar.Harmony : ConsoleSystem {
    [ServerVar]
public static void Load(Arg args);
    [ServerVar]
public static void Unload(Arg args);
}
[Factory("hierarchy")]
public class ConVar.Hierarchy : ConsoleSystem {
    private static GameObject currentDir;
    private static Transform[] GetCurrent();
    [ServerVar]
public static void ls(Arg args);
    [ServerVar]
public static void cd(Arg args);
    [ServerVar]
public static void del(Arg args);
}
[Factory("input")]
public class ConVar.Input : ConsoleSystem {
}
[Factory("instruments")]
public class ConVar.instruments : ConsoleSystem {
    public static string InstrumentsFolder;
}
[Factory("inventory")]
public class ConVar.Inventory : ConsoleSystem {
    [ReplicatedVar]
public static bool disableAttireLimitations;
    private static string LoadoutDirectory;
    [ServerUserVar]
public static void lighttoggle(Arg arg);
    [ServerUserVar]
public static void endloot(Arg arg);
    [ServerVar]
public static void give(Arg arg);
    [ServerVar]
public static void resetbp(Arg arg);
    [ServerVar]
public static void unlockall(Arg arg);
    [ServerVar]
public static void giveall(Arg arg);
    [ServerVar]
public static void giveto(Arg arg);
    [ServerVar]
public static void giveid(Arg arg);
    [ServerVar]
public static void givearm(Arg arg);
    [ServerVar]
public static void pipetteid(Arg arg);
    [ServerVar]
public static void copyTo(Arg arg);
    public static void copyTo(BasePlayer from, BasePlayer toply);
    [ServerVar]
public static void deployLoadoutInRange(Arg arg);
    [ServerVar]
public static void deployLoadout(Arg arg);
    [ServerVar]
public static void clearInventory(Arg arg);
    private static string GetLoadoutPath(string loadoutName);
    [ServerVar]
public static void saveloadout(Arg arg);
    public static bool LoadLoadout(string name, SavedLoadout& so);
    [ServerVar]
public static void listloadouts(Arg arg);
    [ClientVar]
[ServerVar]
public static void defs(Arg arg);
    [ClientVar]
[ServerVar]
public static void reloaddefs(Arg arg);
    [ServerVar]
public static void equipslottarget(Arg arg);
    [ServerVar]
public static void equipslot(Arg arg);
    public static void EquipItemInSlot(BasePlayer player, int slot);
    private static int GetSlotIndex(BasePlayer player);
    [ServerVar]
public static void giveBp(Arg arg);
}
[Factory("layer")]
public class ConVar.Layer : ConsoleSystem {
}
[Factory("legs")]
public class ConVar.Legs : ConsoleSystem {
}
[Factory("lerp")]
public class ConVar.Lerp : ConsoleSystem {
}
public class ConVar.Manifest : object {
    [ClientVar]
[ServerVar]
public static object PrintManifest();
    [ClientVar]
[ServerVar]
public static object PrintManifestRaw();
}
[Factory("memsnap")]
public class ConVar.MemSnap : ConsoleSystem {
    private static string NeedProfileFolder();
    [ClientVar]
[ServerVar]
public static void managed(Arg arg);
    [ClientVar]
[ServerVar]
public static void native(Arg arg);
    [ClientVar]
[ServerVar]
public static void full(Arg arg);
}
[Factory("mesh")]
public class ConVar.Mesh : ConsoleSystem {
}
[Factory("music")]
public class ConVar.Music : ConsoleSystem {
    [ClientVar]
public static bool enabled;
    [ClientVar]
public static int songGapMin;
    [ClientVar]
public static int songGapMax;
    private static Music();
    [ClientVar]
public static void info(Arg arg);
}
[Factory("net")]
public class ConVar.Net : ConsoleSystem {
    [ServerVar]
public static bool visdebug;
    [ClientVar]
public static bool debug;
    [ServerVar]
public static int visibilityRadiusFarOverride;
    [ServerVar]
public static int visibilityRadiusNearOverride;
    [ServerVar]
public static bool globalNetworkedBases;
    [ServerVar]
public static bool global_network_debug;
    [ServerVar]
public static bool network_group_debug;
    [ServerVar]
public static bool limit_global_update_broadcast;
    private static Net();
}
[Factory("netgraph")]
public class ConVar.Netgraph : ConsoleSystem {
}
[Factory("nexus")]
public class ConVar.Nexus : ConsoleSystem {
    public static Phrase RedirectPhrase;
    private static string DefaultEndpoint;
    [ReplicatedVar]
public static string endpoint;
    [ServerVar]
public static bool logging;
    [ServerVar]
public static string secretKey;
    [ServerVar]
public static string zoneController;
    [ServerVar]
public static int messageLockDuration;
    [ServerVar]
public static int transferFlushTime;
    [ServerVar]
public static float islandSpawnDistance;
    [ServerVar]
public static float defaultZoneContactRadius;
    [ServerVar]
public static float timeOffset;
    [ServerVar]
public static float rpcTimeoutMultiplier;
    [ServerVar]
public static float loadingTimeout;
    [ServerVar]
public static float pingInterval;
    [ServerVar]
public static float protectionDuration;
    [ServerVar]
public static float clanClatBatchDuration;
    [ServerVar]
public static float playerManifestInterval;
    [ServerVar]
public static float mapImageScale;
    private static Nexus();
    [ServerVar]
public static void transfer(Arg arg);
    [ServerVar]
public static void refreshislands(Arg arg);
    [ServerVar]
public static void ping(Arg arg);
    [ServerVar]
public static void broadcast_ping(Arg arg);
    [ServerVar]
public static void playeronline(Arg arg);
    [ServerVar]
public static void uploadmap(Arg arg);
    [AsyncStateMachineAttribute("ConVar.Nexus/<<ping>g__SendPing|20_0>d")]
[CompilerGeneratedAttribute]
internal static void <ping>g__SendPing|20_0(BasePlayer requester, string to);
    [AsyncStateMachineAttribute("ConVar.Nexus/<<broadcast_ping>g__SendBroadcastPing|21_0>d")]
[CompilerGeneratedAttribute]
internal static void <broadcast_ping>g__SendBroadcastPing|21_0(BasePlayer requester);
}
[Factory("note")]
public class ConVar.Note : ConsoleSystem {
}
[Factory("particle")]
public class ConVar.Particle : ConsoleSystem {
}
[Factory("heli")]
public class ConVar.PatrolHelicopter : ConsoleSystem {
    private static string path;
    [ServerVar]
public static float lifetimeMinutes;
    [ServerVar]
public static int guns;
    [ServerVar]
public static float bulletDamageScale;
    [ServerVar]
public static float bulletAccuracy;
    private static PatrolHelicopter();
    [ServerVar]
public static void drop(Arg arg);
    [ServerVar]
public static void calltome(Arg arg);
    [ServerVar]
public static void call(Arg arg);
    [ServerVar]
public static void strafe(Arg arg);
    [ServerVar]
public static void orbit(Arg arg);
    [ServerVar]
public static void orbitstrafe(Arg arg);
    [ServerVar]
public static void move(Arg arg);
    [ServerVar]
public static void flee(Arg arg);
    [ServerVar]
public static void patrol(Arg arg);
    [ServerVar]
public static void death(Arg arg);
    [ServerVar]
public static void testpuzzle(Arg arg);
}
[Factory("physics")]
public class ConVar.Physics : ConsoleSystem {
    [ServerVar]
public static int droppedmode;
    [ServerVar]
public static bool sendeffects;
    [ServerVar]
public static bool groundwatchdebug;
    [ServerVar]
public static int groundwatchfails;
    [ServerVar]
public static float groundwatchdelay;
    [ServerVar]
public static int serverragdollmode;
    private static float baseGravity;
    private static bool _serversideragdolls;
    [ServerVar]
[ClientVar]
public static bool batchsynctransforms;
    private static bool _treecollision;
    [ServerVar]
public static float bouncethreshold { get; public set; }
    [ServerVar]
public static float sleepthreshold { get; public set; }
    [ServerVar]
public static int solveriterationcount { get; public set; }
    [ReplicatedVar]
public static float gravity { get; public set; }
    [ReplicatedVar]
public static bool serversideragdolls { get; public set; }
    [ClientVar]
[ServerVar]
public static bool autosynctransforms { get; public set; }
    [ReplicatedVar]
public static bool treecollision { get; public set; }
    private static Physics();
    public static float get_bouncethreshold();
    public static void set_bouncethreshold(float value);
    public static float get_sleepthreshold();
    public static void set_sleepthreshold(float value);
    public static int get_solveriterationcount();
    public static void set_solveriterationcount(int value);
    internal static void ApplyDropped(Rigidbody rigidBody);
    public static float get_gravity();
    public static void set_gravity(float value);
    public static bool get_serversideragdolls();
    public static void set_serversideragdolls(bool value);
    public static bool get_autosynctransforms();
    public static void set_autosynctransforms(bool value);
    public static bool get_treecollision();
    public static void set_treecollision(bool value);
}
[Factory("ping")]
public class ConVar.Ping : ConsoleSystem {
    [ClientVar]
[ServerVar]
public static int ping_samples { get; public set; }
    [ServerVar]
[ClientVar]
public static bool ping_parallel { get; public set; }
    [ClientVar]
[ServerVar]
public static int ping_refresh_interval { get; public set; }
    [ClientVar]
[ServerVar]
public static bool auto_refresh_region { get; public set; }
    [ClientVar]
[ServerVar]
public static bool ping_estimate_logging { get; public set; }
    [ClientVar]
[ServerVar]
public static bool ping_estimation { get; public set; }
    public static int get_ping_samples();
    public static void set_ping_samples(int value);
    public static bool get_ping_parallel();
    public static void set_ping_parallel(bool value);
    public static int get_ping_refresh_interval();
    public static void set_ping_refresh_interval(int value);
    public static bool get_auto_refresh_region();
    public static void set_auto_refresh_region(bool value);
    public static bool get_ping_estimate_logging();
    public static void set_ping_estimate_logging(bool value);
    public static bool get_ping_estimation();
    public static void set_ping_estimation(bool value);
}
[Factory("player")]
public class ConVar.Player : ConsoleSystem {
    public static string serverTickRateDefaultString;
    public static int serverTickRate;
    public static int serverTickRateDefault;
    public static int serverTickRateMin;
    public static int serverTickRateMax;
    public static float serverTickInterval;
    public static string clientTickRateDefaultString;
    public static int clientTickRateDefault;
    public static int clientTickRateMin;
    public static int clientTickRateMax;
    public static EncryptedValue`1<int> clientTickRate;
    public static EncryptedValue`1<float> clientTickInterval;
    [ClientVar]
public static bool InfiniteAmmo;
    [ServerVar]
public static bool woundforever;
    [ReplicatedVar]
public static int tickrate_sv { get; public set; }
    [ReplicatedVar]
public static int tickrate_cl { get; public set; }
    private static Player();
    public static int get_tickrate_sv();
    public static void set_tickrate_sv(int value);
    public static int get_tickrate_cl();
    public static void set_tickrate_cl(int value);
    [ServerUserVar]
[ClientVar]
public static void cinematic_play(Arg arg);
    [ClientVar]
[ServerUserVar]
public static void cinematic_stop(Arg arg);
    [ServerUserVar]
public static void cinematic_gesture(Arg arg);
    [ServerUserVar]
public static void copyrotation(Arg arg);
    [ServerUserVar]
public static void abandonmission(Arg arg);
    [ServerUserVar]
public static void mount(Arg arg);
    [ServerVar]
public static void gotosleep(Arg arg);
    [ServerVar]
public static void dismount(Arg arg);
    [ServerVar]
public static void swapseat(Arg arg);
    [ServerVar]
public static void wakeup(Arg arg);
    [ServerVar]
public static void wakeupall(Arg arg);
    [ServerVar]
public static void printstats(Arg arg);
    [ServerVar]
public static void printpresence(Arg arg);
    [ServerVar]
public static void resetstate(Arg args);
    [ServerVar]
public static void fillwater(Arg arg);
    [ServerVar]
public static void reloadweapons(Arg arg);
    [ServerVar]
public static void createskull(Arg arg);
    [ServerVar]
public static string createTrophy(Arg arg);
    [ServerVar]
public static void trigger_wildlife_trap(Arg arg);
    [ServerVar]
public static void gesture_radius(Arg arg);
    [ServerVar]
public static void gesture_radius_notme(Arg arg);
    public static void gesture_radius(Arg arg, bool includeMe);
    [ServerVar]
public static void stopgesture_radius(Arg arg);
    [ServerVar]
public static void markhostile(Arg arg);
}
public class ConVar.PlayerCull : ConsoleSystem {
}
[Factory("pool")]
public class ConVar.Pool : ConsoleSystem {
    [ServerVar]
[ClientVar]
public static int mode;
    [ServerVar]
[ClientVar]
public static bool prewarm;
    [ServerVar]
[ClientVar]
public static bool enabled;
    [ServerVar]
[ClientVar]
public static bool debug;
    private static Pool();
    [ServerVar]
[ClientVar]
public static void print_memory(Arg arg);
    [ServerVar]
[ClientVar]
public static void reset_max_pool_counter(Arg arg);
    [ClientVar]
[ServerVar]
public static void print_arraypool(Arg arg);
    [ServerVar]
[ClientVar]
public static void print_prefabs(Arg arg);
    [ServerVar]
[ClientVar]
public static void print_assets(Arg arg);
    [ServerVar]
[ClientVar]
public static void clear_memory(Arg arg);
    [ServerVar]
[ClientVar]
public static void clear_prefabs(Arg arg);
    [ServerVar]
[ClientVar]
public static void clear_assets(Arg arg);
    [ServerVar]
[ClientVar]
public static void export_prefabs(Arg arg);
    [ClientVar]
[ServerVar]
public static void fill_prefabs(Arg arg);
}
[Factory("profile")]
public class ConVar.Profile : ConsoleSystem {
    private static void NeedProfileFolder();
    [ClientVar]
[ServerVar]
public static void start(Arg arg);
    [ServerVar]
[ClientVar]
public static void stop(Arg arg);
    [ServerVar]
[ClientVar]
public static void flush_analytics(Arg arg);
}
[Factory("reflection")]
public class ConVar.Reflection : ConsoleSystem {
}
[Factory("render")]
public class ConVar.Render : ConsoleSystem {
    public static bool use_normal_rendering;
    [CompilerGeneratedAttribute]
private static bool <show_building_blocked_client>k__BackingField;
    [CompilerGeneratedAttribute]
private static float <building_blocked_preview_distance>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <show_building_blocked_server>k__BackingField;
    [ClientVar]
public static int instanced_rendering;
    [ClientVar]
public static bool instanced_toggle_all;
    [ClientVar]
public static bool instanced_toggle_cliffs;
    [ClientVar]
public static bool instanced_toggle_buildings;
    [ClientVar]
public static bool instanced_toggle_other;
    [ClientVar]
public static bool multidraw;
    [ClientVar]
public static int upload_multidraw_meshes_mode;
    [ClientVar]
public static bool render_shadows;
    [ClientVar]
public static bool computebuffer_setdata_immediate;
    [ClientVar]
public static int max_renderers;
    [ClientVar]
public static float instancing_render_distance;
    public static bool IsInstancingDisabled { get; }
    public static bool IsInstancingEnabled { get; }
    [ClientVar]
public static bool show_building_blocked_client { get; public set; }
    [ClientVar]
public static float building_blocked_preview_distance { get; public set; }
    [ReplicatedVar]
public static bool show_building_blocked_server { get; public set; }
    public static bool IsMultidrawEnabled { get; }
    private static Render();
    public static bool get_IsInstancingDisabled();
    public static bool get_IsInstancingEnabled();
    [CompilerGeneratedAttribute]
public static bool get_show_building_blocked_client();
    [CompilerGeneratedAttribute]
public static void set_show_building_blocked_client(bool value);
    [CompilerGeneratedAttribute]
public static float get_building_blocked_preview_distance();
    [CompilerGeneratedAttribute]
public static void set_building_blocked_preview_distance(float value);
    [CompilerGeneratedAttribute]
public static bool get_show_building_blocked_server();
    [CompilerGeneratedAttribute]
public static void set_show_building_blocked_server(bool value);
    public static bool get_IsMultidrawEnabled();
    [ClientVar]
[ServerVar]
public static void tree_entities(Arg arg);
    [ServerVar]
[ClientVar]
public static void print_global_entities(Arg arg);
    private static void global_entities_client(StringBuilder builder);
    [ClientVar]
public static void instanced_memory_usage(Arg arg);
    [ClientVar]
public static void test_instancing_culling(Arg arg);
    [ClientVar]
public static void instanced_renderers_debug(Arg arg);
    [ClientVar]
public static void print_instanced_grid(Arg arg);
    [ClientVar]
public static void expand_instancing(Arg arg);
}
[Factory("reports")]
public class ConVar.reports : ConsoleSystem {
    [ServerVar]
[ClientVar]
public static int ExceptionReportMaxLength { get; public set; }
    public static int get_ExceptionReportMaxLength();
    public static void set_ExceptionReportMaxLength(int value);
}
[Factory("sentry")]
public class ConVar.Sentry : ConsoleSystem {
    [ServerVar]
public static bool targetall;
    [ServerVar]
public static float hostileduration;
    [ReplicatedVar]
public static float interferenceradius;
    [ReplicatedVar]
public static int maxinterference;
    [ServerVar]
public static bool debugPreventDuplicates;
    private static Sentry();
}
[Factory("server")]
public class ConVar.Server : ConsoleSystem {
    [ServerVar]
public static string ip;
    [ServerVar]
public static int port;
    [ServerVar]
public static int queryport;
    [ServerVar]
public static int maxplayers;
    [ServerVar]
public static string hostname;
    [ServerVar]
public static string identity;
    [ServerVar]
public static string level;
    [ServerVar]
public static string levelurl;
    [ServerVar]
public static bool leveltransfer;
    [ServerVar]
public static int seed;
    [ServerVar]
public static int salt;
    [ServerVar]
public static int worldsize;
    [ServerVar]
public static int saveinterval;
    [ServerVar]
public static bool secure;
    [ServerVar]
public static int encryption;
    [ServerVar]
public static string anticheatid;
    [ServerVar]
public static string anticheatkey;
    [ServerVar]
public static bool anticheattoken;
    [ServerVar]
public static bool strictauth_eac;
    [ServerVar]
public static bool strictauth_steam;
    [ServerVar]
public static int tickrate;
    [ServerVar]
public static int entityrate;
    [ServerVar]
public static float schematime;
    [ServerVar]
public static float cycletime;
    [ServerVar]
public static bool official;
    [ServerVar]
public static bool stats;
    [ServerVar]
public static bool stability;
    [ServerVar]
public static bool radiation;
    [ServerVar]
public static float itemdespawn;
    [ServerVar]
public static float itemdespawn_container_scale;
    [ServerVar]
public static int itemdespawn_container_max_multiplier;
    [ServerVar]
public static float itemdespawn_quick;
    [ServerVar]
public static float corpsedespawn;
    [ServerVar]
public static float debrisdespawn;
    [ServerVar]
public static bool pve;
    [ServerVar]
public static bool cinematic;
    [ServerVar]
public static string description;
    [ServerVar]
public static string url;
    [ServerVar]
public static string branch;
    [ServerVar]
public static int queriesPerSecond;
    [ServerVar]
public static int ipQueriesPerMin;
    [ServerVar]
public static bool statBackup;
    [ServerVar]
public static int rejoin_delay;
    [ServerVar]
public static string ping_region_code_override;
    private static string _favoritesEndpoint;
    [ServerVar]
public static string headerimage;
    [ServerVar]
public static string logoimage;
    [ServerVar]
public static int saveBackupCount;
    [ReplicatedVar]
public static string motd;
    [ServerVar]
public static float meleedamage;
    [ServerVar]
public static float arrowdamage;
    [ServerVar]
public static float bulletdamage;
    [ServerVar]
public static float bleedingdamage;
    [ServerVar]
public static float oilrig_radiation_amount_scale;
    [ServerVar]
public static float oilrig_radiation_time_scale;
    [ServerVar]
public static float oilrig_radiation_alarm_threshold;
    [ReplicatedVar]
public static float funWaterDamageThreshold;
    [ReplicatedVar]
public static float funWaterWetnessGain;
    [ServerVar]
public static float meleearmor;
    [ServerVar]
public static float arrowarmor;
    [ServerVar]
public static float bulletarmor;
    [ServerVar]
public static float bleedingarmor;
    [ServerVar]
public static int updatebatch;
    [ServerVar]
public static int updatebatchspawn;
    [ServerVar]
public static int entitybatchsize;
    [ServerVar]
public static float entitybatchtime;
    [ServerVar]
public static float composterUpdateInterval;
    [ReplicatedVar]
public static float planttick;
    [ServerVar]
public static float planttickscale;
    private static int _maxHttp;
    [ServerVar]
public static bool useMinimumPlantCondition;
    [ServerVar]
public static float nonPlanterDeathChancePerTick;
    [ServerVar]
public static float ceilingLightGrowableRange;
    [ServerVar]
public static float artificialTemperatureGrowableRange;
    [ServerVar]
public static float ceilingLightHeightOffset;
    [ServerVar]
public static float sprinklerRadius;
    [ServerVar]
public static float sprinklerEyeHeightOffset;
    [ServerVar]
public static float optimalPlanterQualitySaturation;
    [ServerVar]
public static float metabolismtick;
    [ServerVar]
public static float modifierTickRate;
    [ServerVar]
public static float rewounddelay;
    [ServerVar]
public static bool woundingenabled;
    [ServerVar]
public static bool crawlingenabled;
    [ServerVar]
public static float woundedrecoverchance;
    [ServerVar]
public static float incapacitatedrecoverchance;
    [ServerVar]
public static float woundedmaxfoodandwaterbonus;
    [ServerVar]
public static int crawlingminimumhealth;
    [ServerVar]
public static int crawlingmaximumhealth;
    [ServerVar]
public static bool playerserverfall;
    [ServerVar]
public static bool plantlightdetection;
    [ServerVar]
public static float respawnresetrange;
    [ReplicatedVar]
public static int max_sleeping_bags;
    [ReplicatedVar]
public static int max_shelters;
    [ReplicatedVar]
public static bool bag_quota_item_amount;
    [ServerVar]
public static int maxunack;
    [ServerVar]
public static bool netcache;
    [ServerVar]
public static bool corpses;
    [ServerVar]
public static bool events;
    [ServerVar]
public static bool dropitems;
    [ServerVar]
public static int netcachesize;
    [ServerVar]
public static int savecachesize;
    [ServerVar]
public static int combatlogsize;
    [ServerVar]
public static int combatlogdelay;
    [ServerVar]
public static int authtimeout;
    [ServerVar]
public static int playertimeout;
    [ServerVar]
public static int idlekick;
    [ServerVar]
public static int idlekickmode;
    [ServerVar]
public static int idlekickadmins;
    [ServerVar]
public static string gamemode;
    private static string _tags;
    [ServerVar]
public static bool censorplayerlist;
    [ServerVar]
public static string bansServerEndpoint;
    [ServerVar]
public static int bansServerFailureMode;
    [ServerVar]
public static int bansServerTimeout;
    [ServerVar]
public static string reportsServerEndpoint;
    [ServerVar]
public static string reportsServerEndpointKey;
    [ServerVar]
public static bool printReportsToConsole;
    [ServerVar]
public static bool respawnAtDeathPosition;
    [ServerVar]
public static bool respawnWithLoadout;
    [ServerVar]
public static bool waterContainersLeaveWaterBehind;
    [ServerVar]
public static float conveyorMoveFrequency;
    [ServerVar]
public static float industrialCrafterFrequency;
    [ReplicatedVar]
public static int defaultBlueprintResearchCost;
    [ServerVar]
public static bool enforcePipeChecksOnBuildingBlockChanges;
    [ServerVar]
public static int maxItemStacksMovedPerTickIndustrial;
    [ServerVar]
public static float industrialFrameBudgetMs;
    [ServerVar]
public static bool industrialTransferStrictTimeLimits;
    [ServerVar]
public static bool industrialAllowQuickMove;
    [ReplicatedVar]
public static int maximumMapMarkers;
    [ServerVar]
public static int maximumPings;
    [ServerVar]
public static float pingDuration;
    [ServerVar]
public static bool canEquipBackpacksInAir;
    [ReplicatedVar]
public static float parachuteRepackTime;
    public static bool emojiOwnershipCheck;
    [ReplicatedVar]
public static bool skipDeathScreenFade;
    [ReplicatedVar]
public static bool tutorialEnabled;
    [ReplicatedVar]
public static float workbench1TaxRate;
    [ServerVar]
public static bool autoUploadMap;
    [ReplicatedVar]
public static float workbench2TaxRate;
    [ReplicatedVar]
public static float workbench3TaxRate;
    [ServerVar]
public static float waterWellNpcSalesRefreshFrequency;
    [ReplicatedVar]
public static bool useLegacyWorkbenchInteraction;
    [ServerVar]
public static bool showHolsteredItems;
    [ServerVar]
public static int maxpacketspersecond_world;
    [ServerVar]
public static int maxpacketspersecond_rpc;
    [ServerVar]
public static int maxpacketspersecond_rpc_signal;
    [ServerVar]
public static int maxpacketspersecond_command;
    [ServerVar]
public static int maxpacketsize_command;
    [ServerVar]
public static int maxpacketsize_globaltrees;
    [ServerVar]
public static int maxpacketsize_globalentities;
    [ServerVar]
public static int maxpacketspersecond_tick;
    [ServerVar]
public static int maxpacketspersecond_voice;
    [ServerVar]
public static bool packetlog_enabled;
    [ServerVar]
public static bool rpclog_enabled;
    [ServerVar]
public static string server_id { get; public set; }
    [ServerVar]
public static string favoritesEndpoint { get; public set; }
    [ServerVar]
public static int anticheatlog { get; public set; }
    [ServerVar]
public static int http_connection_limit { get; public set; }
    [ServerVar]
public static string tags { get; public set; }
    [ServerVar]
public static int maxclientinfosize { get; public set; }
    [ServerVar]
public static int maxconnectionsperip { get; public set; }
    [ServerVar]
public static int maxreceivetime { get; public set; }
    [ServerVar]
public static int maxmainthreadwait { get; public set; }
    [ServerVar]
public static int maxreadthreadwait { get; public set; }
    [ServerVar]
public static int maxwritethreadwait { get; public set; }
    [ServerVar]
public static int maxdecryptthreadwait { get; public set; }
    [ServerVar]
public static int maxreadqueuelength { get; public set; }
    [ServerVar]
public static int maxwritequeuelength { get; public set; }
    [ServerVar]
public static int maxdecryptqueuelength { get; public set; }
    [ServerVar]
public static int maxreadqueuebytes { get; public set; }
    [ServerVar]
public static int maxwritequeuebytes { get; public set; }
    [ServerVar]
public static int maxdecryptqueuebytes { get; public set; }
    [ServerVar]
public static int player_state_cache_size { get; public set; }
    [ServerVar]
public static int maxpacketspersecond { get; public set; }
    public static string rootFolder { get; }
    public static string backupFolder { get; }
    public static string backupFolder1 { get; }
    public static string backupFolder2 { get; }
    public static string backupFolder3 { get; }
    [ServerVar]
public static bool compression { get; public set; }
    [ServerVar]
public static bool netlog { get; public set; }
    private static Server();
    public static string get_server_id();
    public static void set_server_id(string value);
    public static string get_favoritesEndpoint();
    public static void set_favoritesEndpoint(string value);
    public static int get_anticheatlog();
    public static void set_anticheatlog(int value);
    public static int get_http_connection_limit();
    public static void set_http_connection_limit(int value);
    public static string get_tags();
    public static void set_tags(string value);
    public static float GetTaxRateForWorkbenchUnlock(int workbenchLevel);
    public static float TickDelta();
    public static float TickTime(UInt32 tick);
    [ServerVar]
public static void setshowholstereditems(Arg arg);
    public static int get_maxclientinfosize();
    public static void set_maxclientinfosize(int value);
    public static int get_maxconnectionsperip();
    public static void set_maxconnectionsperip(int value);
    public static int get_maxreceivetime();
    public static void set_maxreceivetime(int value);
    public static int get_maxmainthreadwait();
    public static void set_maxmainthreadwait(int value);
    public static int get_maxreadthreadwait();
    public static void set_maxreadthreadwait(int value);
    public static int get_maxwritethreadwait();
    public static void set_maxwritethreadwait(int value);
    public static int get_maxdecryptthreadwait();
    public static void set_maxdecryptthreadwait(int value);
    public static int get_maxreadqueuelength();
    public static void set_maxreadqueuelength(int value);
    public static int get_maxwritequeuelength();
    public static void set_maxwritequeuelength(int value);
    public static int get_maxdecryptqueuelength();
    public static void set_maxdecryptqueuelength(int value);
    public static int get_maxreadqueuebytes();
    public static void set_maxreadqueuebytes(int value);
    public static int get_maxwritequeuebytes();
    public static void set_maxwritequeuebytes(int value);
    public static int get_maxdecryptqueuebytes();
    public static void set_maxdecryptqueuebytes(int value);
    public static int get_player_state_cache_size();
    public static void set_player_state_cache_size(int value);
    [ServerVar]
public static void player_state_cache_count(Arg args);
    [ServerVar]
public static void player_state_cache_evictions(Arg args);
    [ServerVar]
public static string printreadqueue(Arg arg);
    [ServerVar]
public static string printwritequeue(Arg arg);
    [ServerVar]
public static string printdecryptqueue(Arg arg);
    public static int get_maxpacketspersecond();
    public static void set_maxpacketspersecond(int value);
    [ServerVar]
public static string packetlog(Arg arg);
    [ServerVar]
public static string rpclog(Arg arg);
    [ServerVar]
public static void start(Arg arg);
    [ServerVar]
public static void stop(Arg arg);
    public static string get_rootFolder();
    public static string get_backupFolder();
    public static string get_backupFolder1();
    public static string get_backupFolder2();
    public static string get_backupFolder3();
    [ServerVar]
public static void backup();
    public static string GetServerFolder(string folder);
    [ServerVar]
public static void writecfg(Arg arg);
    [ServerVar]
public static void fps(Arg arg);
    [ServerVar]
public static void save(Arg arg);
    [ServerVar]
public static string readcfg(Arg arg);
    public static bool get_compression();
    public static void set_compression(bool value);
    public static bool get_netlog();
    public static void set_netlog(bool value);
    [ServerVar]
public static string netprotocol(Arg arg);
    [ServerUserVar]
public static void cheatreport(Arg arg);
    [ServerVar]
public static void corpseinfo(Arg arg);
    [ServerAllVar]
public static string combatlog(Arg arg);
    [ServerAllVar]
public static string combatlog_outgoing(Arg arg);
    [ServerVar]
public static string printpos(Arg arg);
    [ServerVar]
public static string printrot(Arg arg);
    [ServerVar]
public static string printeyes(Arg arg);
    [ServerVar]
public static void snapshot(Arg arg);
    [ServerVar]
public static void sendnetworkupdate(Arg arg);
    [ServerVar]
public static void playerlistpos(Arg arg);
    [ServerVar]
public static void listvendingmachines(Arg arg);
    [ServerVar]
public static void listtoolcupboards(Arg arg);
    [ServerVar]
public static void BroadcastPlayVideo(Arg arg);
    [ServerVar]
public static void ResetServerEmoji();
    private static string AutoCorrectTags(string value);
    [CompilerGeneratedAttribute]
internal static void <AutoCorrectTags>g__Add|264_1(String[] options, <>c__DisplayClass264_0& );
}
[Factory("spawn")]
public class ConVar.Spawn : ConsoleSystem {
    [ServerVar]
public static float min_rate;
    [ServerVar]
public static float max_rate;
    [ServerVar]
public static float min_density;
    [ServerVar]
public static float max_density;
    [ServerVar]
public static float player_base;
    [ServerVar]
public static float player_scale;
    [ServerVar]
public static bool respawn_populations;
    [ServerVar]
public static bool respawn_groups;
    [ServerVar]
public static bool respawn_individuals;
    [ServerVar]
public static float tick_populations;
    [ServerVar]
public static float tick_individuals;
    private static Spawn();
    [ServerVar]
public static void fill_populations(Arg args);
    [ServerVar]
public static void fill_groups(Arg args);
    [ServerVar]
public static void fill_individuals(Arg args);
    [ServerVar]
public static void report(Arg args);
    [ServerVar]
public static void scalars(Arg args);
    [ServerVar]
public static void cargoshipevent(Arg args);
    [ServerVar]
public static void ch47event(Arg args);
    [ServerVar]
public static void cargoshipdockingtest(Arg args);
}
[Factory("SSS")]
public class ConVar.SSS : ConsoleSystem {
    [ClientVar]
public static bool enabled;
    [ClientVar]
public static int quality;
    [ClientVar]
public static bool halfres;
    [ClientVar]
public static float scale;
    private static SSS();
}
[Factory("stability")]
public class ConVar.Stability : ConsoleSystem {
    [ServerVar]
public static int verbose;
    [ServerVar]
public static int strikes;
    [ServerVar]
public static float collapse;
    [ServerVar]
public static float accuracy;
    [ServerVar]
public static float stabilityqueue;
    [ServerVar]
public static float surroundingsqueue;
    private static Stability();
    [ServerVar]
public static void refresh_stability(Arg args);
}
public class ConVar.Steam : object {
    [CompilerGeneratedAttribute]
private static bool <server_allow_steam_nicknames>k__BackingField;
    [ReplicatedVar]
public static bool server_allow_steam_nicknames { get; public set; }
    private static Steam();
    [CompilerGeneratedAttribute]
public static bool get_server_allow_steam_nicknames();
    [CompilerGeneratedAttribute]
public static void set_server_allow_steam_nicknames(bool value);
}
[Factory("supply")]
public class ConVar.Supply : ConsoleSystem {
    private static string path;
    [ServerVar]
public static void drop(Arg arg);
    [ServerVar]
public static void call(Arg arg);
}
[Factory("system")]
public static class ConVar.SystemCommands : object {
    [ServerVar]
[ClientVar]
public static void cpu_affinity(Arg arg);
    [ClientVar]
[ServerVar]
public static void cpu_priority(Arg arg);
}
[Factory("terrain")]
public class ConVar.Terrain : ConsoleSystem {
    [ClientVar]
public static float quality;
    private static Terrain();
}
[Factory("texture")]
public class ConVar.Texture : ConsoleSystem {
    [ClientVar]
public static int streamingBudgetOverride;
    [ClientVar]
public static bool streaming { get; public set; }
    public static bool get_streaming();
    public static void set_streaming(bool value);
    [ClientVar]
public static void stats(Arg arg);
}
[Factory("time")]
public class ConVar.Time : ConsoleSystem {
    public static int SERVER_DEFAULT_TICKS;
    public static int CLIENT_DEFAULT_TICKS;
    public static string CLIENT_DEFAULT_TICKS_STR;
    [ServerVar]
[HelpAttribute("Pause time while loading")]
public static bool pausewhileloading;
    private static int _cl_steps;
    private static int _cl_maxstepsperframe;
    [ServerVar]
public static int sv_steps { get; public set; }
    [ServerVar]
public static int sv_maxstepsperframe { get; public set; }
    [ServerVar]
[HelpAttribute("The time scale")]
public static float timescale { get; public set; }
    [ReplicatedVar]
public static int cl_steps { get; public set; }
    [ReplicatedVar]
public static int cl_maxstepsperframe { get; public set; }
    private static Time();
    public static int get_sv_steps();
    public static void set_sv_steps(int value);
    public static int get_sv_maxstepsperframe();
    public static void set_sv_maxstepsperframe(int value);
    public static float get_timescale();
    public static void set_timescale(float value);
    public static int get_cl_steps();
    public static void set_cl_steps(int value);
    public static int get_cl_maxstepsperframe();
    public static void set_cl_maxstepsperframe(int value);
}
[Factory("tree")]
public class ConVar.Tree : ConsoleSystem {
    [ServerVar]
public static bool global_broadcast;
    [ServerVar]
public static bool simplified_collider;
}
[Factory("vehicle")]
public class ConVar.vehicle : ConsoleSystem {
    [ServerVar]
[HelpAttribute("how long until boat corpses despawn (excluding tugboat - use tugboat_corpse_seconds)")]
public static float boat_corpse_seconds;
    [ServerVar]
public static bool cinematictrains;
    [ServerVar]
public static bool trainskeeprunning;
    [ServerVar]
public static bool carwrecks;
    [ServerVar]
public static bool vehiclesdroploot;
    private static vehicle();
    [ServerUserVar]
public static void swapseats(Arg arg);
    [ServerVar]
public static void fixcars(Arg arg);
    [ServerVar]
public static void autohover(Arg arg);
    [ServerVar]
public static void stop_all_trains(Arg arg);
    [ServerVar]
public static void killcars(Arg args);
    [ServerVar]
public static void killpushbikes(Arg args);
    [ServerVar]
public static void killmotorbikes(Arg args);
    [ServerVar]
public static void killminis(Arg args);
    [ServerVar]
public static void killscraphelis(Arg args);
    [ServerVar]
public static void killtrains(Arg args);
    [ServerVar]
public static void killboats(Arg args);
    [ServerVar]
public static void killdrones(Arg args);
    [ServerVar]
public static void boatdriftinfo(Arg args);
}
[Factory("vis")]
public class ConVar.Vis : ConsoleSystem {
    [ClientVar]
[HelpAttribute("Turns on debug display of lerp")]
public static bool lerp;
    [ServerVar]
[HelpAttribute("Turns on debug display of damages")]
public static bool damage;
    [ClientVar]
[ServerVar]
[HelpAttribute("Turns on debug display of attacks")]
public static bool attack;
    [HelpAttribute("Turns on debug display of protection")]
[ClientVar]
[ServerVar]
public static bool protection;
    [ServerVar]
[HelpAttribute("Turns on debug display of weakspots")]
public static bool weakspots;
    [ServerVar]
[HelpAttribute("Show trigger entries")]
public static bool triggers;
    [ServerVar]
[HelpAttribute("Turns on debug display of hitboxes")]
public static bool hitboxes;
    [ServerVar]
[HelpAttribute("Turns on debug display of line of sight checks")]
public static bool lineofsight;
    [HelpAttribute("Turns on debug display of senses, which are received by Ai")]
[ServerVar]
public static bool sense;
}
[Factory("voice")]
public class ConVar.Voice : ConsoleSystem {
    [ClientVar]
public static bool loopback;
    private static float _voiceRangeBoostAmount;
    [ReplicatedVar]
public static float voiceRangeBoostAmount { get; public set; }
    private static Voice();
    public static float get_voiceRangeBoostAmount();
    public static void set_voiceRangeBoostAmount(float value);
    [ServerVar]
public static void ToggleVoiceRangeBoost(Arg arg);
}
[Factory("water")]
public class ConVar.Water : ConsoleSystem {
    [ClientVar]
public static int quality;
    public static int MaxQuality;
    public static int MinQuality;
    [ClientVar]
public static int reflections;
    public static int MaxReflections;
    public static int MinReflections;
    [ClientVar]
public static bool scaled_time;
    private static Water();
}
[Factory("weather")]
public class ConVar.Weather : ConsoleSystem {
    [ServerVar]
public static float wetness_rain;
    [ServerVar]
public static float wetness_snow;
    [ReplicatedVar]
public static float ocean_time;
    [ReplicatedVar]
public static float clear_chance { get; public set; }
    [ReplicatedVar]
public static float dust_chance { get; public set; }
    [ReplicatedVar]
public static float fog_chance { get; public set; }
    [ReplicatedVar]
public static float overcast_chance { get; public set; }
    [ReplicatedVar]
public static float storm_chance { get; public set; }
    [ReplicatedVar]
public static float rain_chance { get; public set; }
    [ReplicatedVar]
public static float rain { get; public set; }
    [ReplicatedVar]
public static float wind { get; public set; }
    [ReplicatedVar]
public static float thunder { get; public set; }
    [ReplicatedVar]
public static float rainbow { get; public set; }
    [ReplicatedVar]
public static float fog { get; public set; }
    [ReplicatedVar]
public static float atmosphere_rayleigh { get; public set; }
    [ReplicatedVar]
public static float atmosphere_mie { get; public set; }
    [ReplicatedVar]
public static float atmosphere_brightness { get; public set; }
    [ReplicatedVar]
public static float atmosphere_contrast { get; public set; }
    [ReplicatedVar]
public static float atmosphere_directionality { get; public set; }
    [ReplicatedVar]
public static float cloud_size { get; public set; }
    [ReplicatedVar]
public static float cloud_opacity { get; public set; }
    [ReplicatedVar]
public static float cloud_coverage { get; public set; }
    [ReplicatedVar]
public static float cloud_sharpness { get; public set; }
    [ReplicatedVar]
public static float cloud_coloring { get; public set; }
    [ReplicatedVar]
public static float cloud_attenuation { get; public set; }
    [ReplicatedVar]
public static float cloud_saturation { get; public set; }
    [ReplicatedVar]
public static float cloud_scattering { get; public set; }
    [ReplicatedVar]
public static float cloud_brightness { get; public set; }
    [ReplicatedVar]
public static float ocean_scale { get; public set; }
    private static Weather();
    [ServerVar]
[ClientVar]
public static void load(Arg args);
    public static WeatherPreset GetWeatherPreset(string withName);
    [ClientVar]
[ServerVar]
public static void reset(Arg args);
    [ServerVar]
[ClientVar]
public static void report(Arg args);
    public static float get_clear_chance();
    public static void set_clear_chance(float value);
    public static float get_dust_chance();
    public static void set_dust_chance(float value);
    public static float get_fog_chance();
    public static void set_fog_chance(float value);
    public static float get_overcast_chance();
    public static void set_overcast_chance(float value);
    public static float get_storm_chance();
    public static void set_storm_chance(float value);
    public static float get_rain_chance();
    public static void set_rain_chance(float value);
    public static float get_rain();
    public static void set_rain(float value);
    public static float get_wind();
    public static void set_wind(float value);
    public static float get_thunder();
    public static void set_thunder(float value);
    public static float get_rainbow();
    public static void set_rainbow(float value);
    public static float get_fog();
    public static void set_fog(float value);
    public static float get_atmosphere_rayleigh();
    public static void set_atmosphere_rayleigh(float value);
    public static float get_atmosphere_mie();
    public static void set_atmosphere_mie(float value);
    public static float get_atmosphere_brightness();
    public static void set_atmosphere_brightness(float value);
    public static float get_atmosphere_contrast();
    public static void set_atmosphere_contrast(float value);
    public static float get_atmosphere_directionality();
    public static void set_atmosphere_directionality(float value);
    public static float get_cloud_size();
    public static void set_cloud_size(float value);
    public static float get_cloud_opacity();
    public static void set_cloud_opacity(float value);
    public static float get_cloud_coverage();
    public static void set_cloud_coverage(float value);
    public static float get_cloud_sharpness();
    public static void set_cloud_sharpness(float value);
    public static float get_cloud_coloring();
    public static void set_cloud_coloring(float value);
    public static float get_cloud_attenuation();
    public static void set_cloud_attenuation(float value);
    public static float get_cloud_saturation();
    public static void set_cloud_saturation(float value);
    public static float get_cloud_scattering();
    public static void set_cloud_scattering(float value);
    public static float get_cloud_brightness();
    public static void set_cloud_brightness(float value);
    public static float get_ocean_scale();
    public static void set_ocean_scale(float value);
}
[Factory("workshop")]
public class ConVar.Workshop : ConsoleSystem {
    [ServerVar]
public static void print_approved_skins(Arg arg);
}
[Factory("world")]
public class ConVar.World : ConsoleSystem {
    [ServerVar]
[ClientVar]
public static bool cache;
    [ClientVar]
public static bool streaming;
    [ServerVar]
public static string configString;
    [ServerVar]
public static string configFile;
    private static World();
    [ClientVar]
[ServerVar]
public static void monuments(Arg arg);
    [ServerVar]
public static void rendermap(Arg arg);
    [ServerVar]
public static void rendertunnels(Arg arg);
    [ServerVar]
public static void renderlabs(Arg arg);
    private static void RenderMapLayerToFile(Arg arg, string name, MapLayer layer);
}
[Factory("xmas")]
public class ConVar.XMas : ConsoleSystem {
    private static string path;
    [ServerVar]
public static bool enabled;
    [ServerVar]
public static float spawnRange;
    [ServerVar]
public static int spawnAttempts;
    [ServerVar]
public static int giftsPerPlayer;
    private static XMas();
    [ServerVar]
public static void refill(Arg arg);
}
public class ConvarComponent : MonoBehaviour {
    public bool runOnServer;
    public bool runOnClient;
    public List`1<ConvarEvent> List;
    protected void OnEnable();
    protected void OnDisable();
    private bool ShouldRun();
}
public class ConvarControlledSpawnPointPopulation : ConvarControlledSpawnPopulation {
    public SpawnPointType spawnPointType;
    private List`1<BaseSpawnPoint> spawnPoints;
    protected virtual bool Initialize();
    public virtual bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot);
    private bool TryGetSpawnPoints(List`1& result);
}
[CreateAssetMenuAttribute]
public class ConvarControlledSpawnPopulation : DensitySpawnPopulation {
    [HeaderAttribute("Convars")]
public string PopulationConvar;
    private Command _command;
    protected Command Command { get; }
    public float TargetDensity { get; }
    protected Command get_Command();
    public virtual float get_TargetDensity();
}
public class ConvarControlledSpawnPopulationRail : ConvarControlledSpawnPopulation {
    private static float MIN_MARGIN;
    public virtual bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot);
    public virtual void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);
    protected virtual int GetPrefabWeight(Prefab`1<Spawnable> prefab);
    private bool TryGetRandomPointOnSpline(TrainTrackSpline spline, TrainCar trainCar, Vector3& pos, Quaternion& rot);
}
public class ConvarToggleChildren : MonoBehaviour {
    public string ConvarName;
    public string ConvarEnabled;
    private bool state;
    private Command Command;
    protected void Awake();
    protected void Update();
    private void SetState(bool newState);
}
public class ConvarWater : MonoBehaviour {
    [FormerlySerializedAsAttribute("waterEx")]
public WaterSystem water;
}
[CreateAssetMenuAttribute]
public class ConversationData : ScriptableObject {
    public string shortname;
    public Phrase providerNameTranslated;
    public Sprite providerIcon;
    public bool canBeCancelled;
    public SpeechNode[] speeches;
    public string providerName { get; }
    public string get_providerName();
    public int GetSpeechNodeIndex(string speechShortName);
    public void FindAllMissionAssignments(List`1<BaseMission> results);
}
public class ConversationManager : MonoBehaviour {
}
public class CopyLODValues : MonoBehaviour {
    [SerializeField]
private LODGroup source;
    [SerializeField]
private LODGroup destination;
    [SerializeField]
[TooltipAttribute("Is false, exact values are copied. If true, values are scaled based on LODGroup size, so the changeover point will match.")]
private bool scale;
    public bool CanCopy();
    public void Copy();
}
public class CopyText : MonoBehaviour {
    public RustText TargetText;
    public void TriggerCopy();
}
public class CounterConfig : IOConfig`1<PowerCounter> {
}
[RequireComponent("UnityEngine.Camera")]
[RequireComponent("UnityEngine.Camera")]
[RequireComponent("UnityEngine.Camera")]
public class CoverageQueries : MonoBehaviour {
    public float depthBias;
    public bool debug;
}
public class CoverageQueryFlare : BaseMonoBehaviour {
    public bool isDynamic;
    public bool timeShimmer;
    public bool positionalShimmer;
    public bool rotate;
    public float maxVisibleDistance;
    public bool lightScaled;
    public float dotMin;
    public float dotMax;
    public RadiusSpace coverageRadiusSpace;
    public float coverageRadius;
    public LODDistanceMode DistanceMode;
}
public class CraftingNotice : MonoBehaviour {
    public CanvasGroup canvasGroup;
    public TextMeshProUGUI itemName;
    public TextMeshProUGUI craftSeconds;
}
public class CraftingQueue : SingletonComponent`1<CraftingQueue> {
    public GameObject queueContainer;
    public GameObject queueItemPrefab;
    private ScrollRect scrollRect;
}
public class CraftingQueueIcon : MonoBehaviour {
    public CanvasGroup canvasGroup;
    public Image icon;
    public Image iconCancel;
    public GameObject timeLeft;
    public GameObject craftingCount;
}
public static class Craptography : object {
    private static Byte[] hash;
    private static Craptography();
    public static void XOR(UInt32 seed, ArraySegment`1<byte> src, ArraySegment`1& dst);
}
public class CreateEffect : MonoBehaviour {
    public GameObjectRef EffectToCreate;
    public void OnEnable();
}
public class CreationGibSpawner : BaseMonoBehaviour {
    private GameObject gibSource;
    public GameObject gibsInstance;
    public float startTime;
    public float duration;
    public float buildScaleAdditionalAmount;
    [TooltipAttribute("Entire object will be scaled on xyz during duration by this curve")]
public AnimationCurve scaleCurve;
    [TooltipAttribute("Object will be pushed out along transform.forward/right/up based on build direction by this amount")]
public AnimationCurve buildCurve;
    [TooltipAttribute("Additional scaling to apply to object based on build direction")]
public AnimationCurve buildScaleCurve;
    public AnimationCurve xCurve;
    public AnimationCurve yCurve;
    public AnimationCurve zCurve;
    public Vector3[] spawnPositions;
    public GameObject[] particles;
    public Single[] gibProgress;
    public PhysicMaterial physMaterial;
    public List`1<Transform> gibs;
    public bool started;
    public GameObjectRef placeEffect;
    public GameObject smokeEffect;
    public float effectSpacing;
    public bool invert;
    public Vector3 buildDirection;
    [HorizontalAttribute("1", "0")]
public GibReplacement[] GibReplacements;
    public EffectMaterialPair[] effectLookup;
    private float startDelay;
    public List`1<ConditionalGibSource> conditionalGibSources;
    private float nextEffectTime;
    public GameObjectRef GetEffectForMaterial(PhysicMaterial mat);
    public void SetDelay(float newDelay);
    public void FinishSpawn();
    public float GetProgress(float delay);
    public void AddConditionalGibSource(GameObject cGibSource, Vector3 pos, Quaternion rot);
    public void SetGibSource(GameObject newGibSource);
    private int SortsGibs(Transform a, Transform b);
    public void Init();
    public float GetPushDir(Vector3 spawnPos, Transform theGib);
    public void DestroyMe();
    public float GetStartDelay(Transform gib);
    public void Update();
}
public class CrossbowWeapon : BaseProjectile {
    public virtual bool ForceSendMagazine(SaveInfo saveInfo);
    public virtual void DidAttackServerside();
}
public class Crosshair : BaseMonoBehaviour {
    public static bool Enabled;
    public Image Image;
    public RectTransform reticleTransform;
    public CanvasGroup reticleAlpha;
    public RectTransform hitNotifyMarker;
    public CanvasGroup hitNotifyAlpha;
    public static Crosshair instance;
    public static float lastHitTime;
    public float crosshairAlpha;
    public float aimconeMultiplier;
    public float aimconeLerpSpeed;
    public GameObjectRef pointsSplashEffect;
    private static Crosshair();
}
public class CrushTrigger : TriggerHurt {
    public bool includeNPCs;
    public bool requireCentreBelowPosition;
    internal virtual GameObject InterestedInObject(GameObject obj);
    protected virtual bool CanHurt(BaseCombatEntity ent);
}
public class cui : object {
    [ServerUserVar]
public static void cui_test(Arg args);
    [ServerUserVar]
public static void cui_test_update(Arg args);
    [ServerUserVar]
public static void endtest(Arg args);
}
public class CullingManager : SingletonComponent`1<CullingManager> {
}
public class CullingVolume : MonoBehaviour {
    [TooltipAttribute("Override occludee root from children of this object (default) to children of any other object.")]
public GameObject OccludeeRoot;
    [TooltipAttribute("Invert visibility. False will show occludes. True will hide them.")]
public bool Invert;
    [TooltipAttribute("A portal in the culling volume chain does not toggle objects visible, it merely signals the non-portal volumes to hide their occludees.")]
public bool Portal;
    [TooltipAttribute("Secondary culling volumes, connected to this one, that will get signaled when this trigger is activated.")]
public List`1<CullingVolume> Connections;
}
public class CullWhenInside : MonoBehaviour {
}
public class CursorManager : SingletonComponent`1<CursorManager> {
    private static int iHoldOpen;
    private static int iPreviousOpen;
    private static float lastTimeVisible;
    private static float lastTimeInvisible;
    private void Update();
    public void SwitchToGame();
    private void SwitchToUI();
    public static void HoldOpen(bool cursorVisible);
    public static bool WasVisible(float deltaTime);
    public static bool WasInvisible(float deltaTime);
}
public class CustomDoorManipulator : DoorManipulator {
    public static Phrase pairAttemptPhrase;
    private int inputOpenAmount;
    private int inputCloseAmount;
    private DoorEffect delayedAction;
    private static CustomDoorManipulator();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsPaired();
    public virtual void SetupInitialDoorConnection();
    public virtual void SetTargetDoor(Door newTargetDoor);
    public virtual void DoAction(DoorEffect action);
    private void DoDelayedAction();
    public virtual void DoActionDoorMissing();
    public virtual Door FindDoor(bool allowLocked);
    [RPC_Server]
[IsVisible("3")]
public void RPC_DoPair(RPCMessage msg);
    private void PairDoorAttempt(Door door, BasePlayer byPlayer);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    private int GetPowerAtInput(int slotIndex);
    public virtual void Load(LoadInfo info);
}
[CreateAssetMenuAttribute]
public class CustomPostEffectsResources : ScriptableObject {
    public Shader[] shaders;
}
public class CustomTimerSwitch : TimerSwitch {
    public GameObjectRef timerPanelPrefab;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsVisible("3")]
[RPC_Server]
public void SERVER_SetTime(RPCMessage msg);
    public bool CanPlayerAdmin(BasePlayer player);
}
[CreateAssetMenuAttribute]
public class DamageProperties : ScriptableObject {
    public DamageProperties fallback;
    [HorizontalAttribute("1", "0")]
public HitAreaProperty[] bones;
    public float GetMultiplier(HitArea area);
    public void ScaleDamage(HitInfo info);
}
public class DamageRenderer : MonoBehaviour {
    [SerializeField]
private List`1<Material> damageShowingMats;
    [SerializeField]
private float maxDamageOpacity;
    [SerializeField]
[HideInInspector]
private List`1<DamageShowingRenderer> damageShowingRenderers;
    [SerializeField]
[HideInInspector]
private List`1<GlassPane> damageShowingGlassRenderers;
}
[RequireComponent("UnityEngine.UI.Toggle")]
public class DamageToggle : MonoBehaviour {
    public Toggle toggle;
    private void Reset();
}
public static class DamageUtil : object {
    public static void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List`1<DamageTypeEntry> damage, int layers, bool useLineOfSight, bool ignoreAI, bool ignoreAttackingPlayer);
    private static bool IsIgnoredAI(BaseEntity ent);
}
public class DebrisEntity : BaseCombatEntity {
    public float DebrisDespawnOverride;
    public virtual void ServerInit();
    public void RemoveCorpse();
    public void ResetRemovalTime(float dur);
    public float GetRemovalTime();
    public void ResetRemovalTime();
    public virtual string Categorize();
}
public class DebugCameraInfoReadout : SingletonComponent`1<DebugCameraInfoReadout> {
    public RustText ReadoutText;
}
public class DebugWorldPosition : ListComponent`1<DebugWorldPosition> {
    public WorldPositionGenerator GeneratorToFake;
}
public class DecalBlood : DecalRecycle {
}
public abstract class DecalComponent : PrefabAttribute {
    protected virtual Type GetIndexedType();
}
public class DecalCull : LODComponent {
    public float Distance;
}
public class DecalRecycle : BasePrefab {
    public float LifeTime;
    [RangeAttribute("1", "50")]
public int WarmedUpAmount;
}
public static class DecalRecycleEx : object {
}
public class DecalRotate : DecalComponent {
    [MinMaxAttribute("0", "360")]
public MinMax range;
}
public class DecalScale : DecalComponent {
    [MinMaxAttribute("0", "2")]
public MinMax range;
}
public abstract class Decay : PrefabAttribute {
    private static float hours;
    protected float GetDecayDelay(Enum grade);
    protected float GetDecayDuration(Enum grade);
    public static void BuildingDecayTouch(BuildingBlock buildingBlock);
    public static void EntityLinkDecayTouch(BaseEntity ent);
    public static void RadialDecayTouch(Vector3 pos, float radius, int mask);
    public virtual bool ShouldDecay(BaseEntity entity);
    public abstract virtual float GetDecayDelay(BaseEntity entity);
    public abstract virtual float GetDecayDuration(BaseEntity entity);
    public virtual float GetDecayTickOverride();
    public virtual float GetHealScale(BaseEntity entity);
    public virtual float GetHealDelay(DecayEntity decayEntity);
    protected virtual Type GetIndexedType();
}
public class DecayEntity : BaseCombatEntity {
    public GameObjectRef debrisPrefab;
    public Vector3 debrisRotationOffset;
    public DebrisPosition[] DebrisPositions;
    public UInt32 buildingID;
    public float decayTimer;
    public float upkeepTimer;
    public Upkeep upkeep;
    public Decay decay;
    public DecayPoint[] decayPoints;
    public float lastDecayTick;
    public float decayVariance;
    public Upkeep Upkeep { get; }
    public bool BypassInsideDecayMultiplier { get; }
    public bool AllowOnCargoShip { get; }
    public Upkeep get_Upkeep();
    public virtual void ResetState();
    public void AttachToBuilding(UInt32 id);
    public Building GetBuilding();
    public virtual BuildingPrivlidge GetBuildingPrivilege();
    public void CalculateUpkeepCostAmounts(List`1<ItemAmount> itemAmounts, float multiplier);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void AttachToBuilding(DecayEntity other);
    public BuildingBlock GetNearbyBuildingBlock();
    public void ResetUpkeepTime();
    public void DecayTouch();
    public void AddUpkeepTime(float time);
    public float GetProtectedSeconds();
    public virtual float GetEntityDecayDuration();
    public virtual float GetEntityHealScale();
    public virtual float GetEntityDecayDelay();
    public virtual void DecayTick();
    public virtual void OnDecay(Decay decay, float decayDeltaTime);
    public virtual void OnRepairFinished();
    public virtual void OnKilled(HitInfo info);
    private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain);
    public virtual bool get_BypassInsideDecayMultiplier();
    public virtual bool get_AllowOnCargoShip();
    public virtual bool SupportsChildDeployables();
    public virtual bool ForceDeployableSetParent();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class DecayPoint : PrefabAttribute {
    [TooltipAttribute("If this point is occupied this will take this % off the power of the decay")]
public float protection;
    public Socket_Base socket;
    public bool IsOccupied(BaseEntity entity);
    protected virtual Type GetIndexedType();
}
public class DecorAlign : DecorComponent {
    public float NormalAlignment;
    public float GradientAlignment;
    public Vector3 SlopeOffset;
    public Vector3 SlopeScale;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public abstract class DecorComponent : PrefabAttribute {
    internal bool isRoot;
    public abstract virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class DecorComponentEx : object {
    [ExtensionAttribute]
public static void ApplyDecorComponents(Transform transform, DecorComponent[] components, Vector3& pos, Quaternion& rot, Vector3& scale);
    [ExtensionAttribute]
public static void ApplyDecorComponents(Transform transform, DecorComponent[] components);
    [ExtensionAttribute]
public static void ApplyDecorComponentsScaleOnly(Transform transform, DecorComponent[] components);
}
public class DecorDeployable : DecayEntity {
}
public class DecorFlip : DecorComponent {
    public AxisType FlipAxis;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DecorOffset : DecorComponent {
    public Vector3 MinOffset;
    public Vector3 MaxOffset;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DecorPatch : object {
}
public class DecorRotate : DecorComponent {
    public Vector3 MinRotation;
    public Vector3 MaxRotation;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DecorScale : DecorComponent {
    public Vector3 MinScale;
    public Vector3 MaxScale;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DecorSocketFemale : PrefabAttribute {
    protected virtual Type GetIndexedType();
    protected void OnDrawGizmosSelected();
}
public class DecorSocketMale : PrefabAttribute {
    protected virtual Type GetIndexedType();
    protected void OnDrawGizmosSelected();
}
public class DecorSpawn : MonoBehaviour {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public UInt32 Seed;
    public float ObjectCutoff;
    public float ObjectTapering;
    public int ObjectsPerPatch;
    public float ClusterRadius;
    public int ClusterSizeMin;
    public int ClusterSizeMax;
    public int PatchCount;
    public int PatchSize;
    public bool LOD;
}
public class DecorSwim : DecorComponent {
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DecorTransform : DecorComponent {
    public Vector3 Position;
    public Vector3 Rotation;
    public Vector3 Scale;
    public virtual void Apply(Vector3& pos, Quaternion& rot, Vector3& scale);
}
public class DeferredAction : object {
    private Object sender;
    private Action action;
    private ActionPriority priority;
    [CompilerGeneratedAttribute]
private bool <Idle>k__BackingField;
    public bool Idle { get; private set; }
    public int Index { get; }
    public DeferredAction(Object sender, Action action, ActionPriority priority);
    [CompilerGeneratedAttribute]
public bool get_Idle();
    [CompilerGeneratedAttribute]
private void set_Idle(bool value);
    public int get_Index();
    public void Action();
    public void Invoke();
    public static bool op_Implicit(DeferredAction obj);
    public static void Invoke(Object sender, Action action, ActionPriority priority);
}
[ExecuteInEditMode]
public class DeferredDecal : MonoBehaviour {
    public Mesh mesh;
    public Material material;
    public DeferredDecalQueue queue;
    public bool applyImmediately;
}
public enum DeferredDecalQueue : Enum {
    public int value__;
    public static DeferredDecalQueue Background;
    public static DeferredDecalQueue Foreground;
}
[ExecuteInEditMode]
public class DeferredDecalRenderer : BaseCommandBuffer {
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Camera")]
[RequireComponent("CommandBufferManager")]
public class DeferredExtension : MonoBehaviour {
    public ExtendGBufferParams extendGBuffer;
    public SubsurfaceScatteringParams subsurfaceScattering;
    public ScreenSpaceRefractionParams screenSpaceRefraction;
    public float depthScale;
    public bool debug;
    public bool forceToCameraResolution;
    public bool excludeMainLight;
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Renderer")]
public class DeferredExtensionMesh : MonoBehaviour {
    public SubsurfaceProfile subsurfaceProfile;
}
[RequireComponent("UnityEngine.Renderer")]
[ExecuteInEditMode]
public class DeferredMeshDecal : MonoBehaviour {
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Camera")]
public class DeferredMeshDecalRenderer : MonoBehaviour {
}
public class DeleteEventButton : MonoBehaviour {
    public sealed virtual void OnPointerDown(PointerEventData eventData);
}
public class DeliveryDrone : Drone {
    [HeaderAttribute("Delivery Drone")]
public float stateTimeout;
    public float targetPositionTolerance;
    public float preferredCruiseHeight;
    public float preferredHeightAboveObstacle;
    public float marginAbovePreferredHeight;
    public float obstacleHeightLockDuration;
    public int pickUpDelayInTicks;
    public DeliveryDroneConfig config;
    public GameObjectRef mapMarkerPrefab;
    public EntityRef`1<Marketplace> sourceMarketplace;
    public EntityRef`1<MarketTerminal> sourceTerminal;
    public EntityRef`1<VendingMachine> targetVendingMachine;
    public State _state;
    public RealTimeSince _sinceLastStateChange;
    public Nullable`1<Vector3> _stateGoalPosition;
    public Nullable`1<float> _goToY;
    public TimeSince _sinceLastObstacleBlock;
    public Nullable`1<float> _minimumYLock;
    public int _pickUpTicks;
    public BaseEntity _mapMarkerInstance;
    public void Setup(Marketplace marketplace, MarketTerminal terminal, VendingMachine vendingMachine);
    public virtual void ServerInit();
    public void CreateMapMarker();
    public void Think();
    public void ForceRemove();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual bool CanControl(ulong playerID);
    [CompilerGeneratedAttribute]
public float <Think>g__CalculatePreferredY|24_0(Boolean& isBlocked, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public float <Think>g__GetMinimumHeight|24_1(Vector3 offset, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public Vector3 <Think>g__LandingPosition|24_2(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public void <Think>g__SetGoalPosition|24_3(Vector3 position, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public bool <Think>g__IsAtGoalPosition|24_4(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public void <Think>g__SetGoToY|24_5(float y, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public bool <Think>g__IsAtGoToY|24_6(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
public void <Think>g__SetState|24_7(State newState, <>c__DisplayClass24_0& );
}
[CreateAssetMenuAttribute]
public class DeliveryDroneConfig : BaseScriptableObject {
    public Vector3 vendingMachineOffset;
    public float maxDistanceFromVendingMachine;
    public Vector3 halfExtents;
    public float testHeight;
    public LayerMask layerMask;
    public void FindDescentPoints(VendingMachine vendingMachine, float currentY, Vector3& waitPosition, Vector3& descendPosition);
    public bool IsVendingMachineAccessible(VendingMachine vendingMachine, Vector3 offset, RaycastHit& hitInfo);
}
public class DemoItem : RustButton {
    public Demos demos;
    public int itemId;
    public RustText nameText;
    public RustText dateText;
    public RustText lengthText;
}
public class DemoPlaybackUI : SingletonComponent`1<DemoPlaybackUI> {
    public GameObject Root;
}
public class DemoPlaybackWidget : MonoBehaviour {
    public RustSlider DemoProgress;
    public RustText DemoName;
    public RustText DemoDuration;
    public RustText DemoCurrentTime;
    public GameObject PausedRoot;
    public GameObject PlayingRoot;
    public RectTransform DemoPlaybackHandle;
    public RectTransform ShotPlaybackWindow;
    public RustButton LoopButton;
    public GameObject ShotButtonRoot;
    public RustText ShotNameText;
    public GameObject ShotNameRoot;
    public RectTransform ShotRecordWindow;
}
public class DemoRecorder : SingletonComponent`1<DemoRecorder> {
    public RustInput nameInputField;
    public GameObject RecordingUnderlay;
    public GameObject Panel;
    public CanvasGroup CanvasGroup;
    public UIConfirmationPopup confirmationPopup;
    public RustButton autofillButton;
    private bool autoFill;
    public static Phrase overwritePhrase;
    private static DemoRecorder();
}
public class DemoRecorderProgress : SingletonComponent`1<DemoRecorderProgress> {
    public RustText RecordingLabel;
    public RustText ProgressLabel;
    public GameObject RecordingUnderlay;
}
public class DemoRootFade : MonoBehaviour {
    public CanvasGroup Canvas;
}
public class Demos : MonoBehaviour {
    public VirtualScroll virtualScroll;
    public GameObject deletePopup;
}
public class DemoShotButton : RustButton {
    public bool FireEventOnClicked;
    public virtual void OnPointerDown(PointerEventData eventData);
    public virtual void OnPointerUp(PointerEventData eventData);
    public sealed virtual void OnPointerClick(PointerEventData eventData);
}
public class DemoShotEntry : MonoBehaviour {
    public RustButton PlayButton;
    public Sprite DragSprite;
    public RustInput RenameInput;
}
public static class DemoShotHelpers : object {
}
public class DemoShotListFolderWidget : MonoBehaviour {
    public RustButton FolderName;
    public Transform ChildRoot;
    public GameObject UpArrow;
    public GameObject DownArrow;
    public RustText CountText;
    public GameObject OpenRoot;
    public GameObject ModifyRoot;
    public RustInput FolderRenameInput;
}
public class DemoShotListRootFolder : MonoBehaviour {
}
public class DemoShotListWidget : SingletonComponent`1<DemoShotListWidget> {
    public GameObjectRef ShotListEntry;
    public GameObjectRef FolderEntry;
    public Transform ShotListParent;
    public RustInput FolderNameInput;
    public GameObject ShotsRoot;
    public GameObject NoShotsRoot;
    public GameObject TopUpArrow;
    public GameObject TopDownArrow;
    public Canvas DragCanvas;
}
public class DemoShotPlayback : MonoBehaviour {
}
public class DemoShotRecorder : SingletonComponent`1<DemoShotRecorder> {
}
public class DemoShotRecordWidget : MonoBehaviour {
    public RustInput NameInput;
    public GameObject RecordingRoot;
    public GameObject PreRecordingRoot;
    public RustButton CountdownToggle;
    public RustButton PauseOnSaveToggle;
    public RustButton ReturnToStartToggle;
    public RustButton RecordDofToggle;
    public RustOption FolderDropdown;
    public GameObject RecordingUnderlay;
    public AudioSource CountdownAudio;
    public GameObject ShotRecordTime;
    public RustText ShotRecordTimeText;
    public RustText ShotNameText;
    public GameObject RecordingInProcessRoot;
    public GameObject CountdownActiveRoot;
    public GameObject CountdownActiveSliderRoot;
    public RustSlider CountdownActiveSlider;
    public RustText CountdownActiveText;
}
public class DemoText : MonoBehaviour {
    public RustText TimeText;
    public RustText TotalSecondText;
    public RustText TimeScaleText;
    public RustText FilenameText;
    public RustText DateTimeText;
    public RustText ParentText;
    public RustText DofText;
    public GameObject InternalRoot;
    public GameObject ParentRoot;
    public GameObject DofRoot;
}
public class DemoTimelineController : MonoBehaviour {
    public PlayableDirector Director;
}
public class DemoTrackBehaviour : PlayableBehaviour {
    public string DemoName;
}
[CreateAssetMenuAttribute]
public class DensitySpawnPopulation : SpawnPopulationBase {
    [HeaderAttribute("Spawn Info")]
[TooltipAttribute("Usually per square km")]
[SerializeField]
[FormerlySerializedAsAttribute("TargetDensity")]
public float _targetDensity;
    public int ClusterSizeMin;
    public int ClusterSizeMax;
    public int ClusterDithering;
    public int SpawnAttemptsInitial;
    public int SpawnAttemptsRepeating;
    public bool ScaleWithLargeMaps;
    public bool ScaleWithSpawnFilter;
    public bool AlignToNormal;
    public SpawnFilter Filter;
    public float FilterCutoff;
    public float FilterRadius;
    public bool FilterOutTutorialIslands;
    public MonumentType[] FilterOutMonuments;
    private int sumToSpawn;
    public float TargetDensity { get; }
    public virtual float get_TargetDensity();
    public virtual void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);
    public void UpdateWeights(SpawnDistribution distribution, int targetCount);
    protected virtual int GetPrefabWeight(Prefab`1<Spawnable> prefab);
    public bool TryTakeRandomPrefab(Prefab`1& result);
    public void ReturnPrefab(Prefab`1<Spawnable> prefab);
    public float GetCurrentSpawnDensity();
    public float GetMaximumSpawnDensity();
    public virtual bool GetSpawnPosOverride(Prefab`1<Spawnable> prefab, Vector3& newPos, Quaternion& newRot);
    public virtual Byte[] GetBaseMapValues(int populationRes);
    public virtual int GetTargetCount(SpawnDistribution distribution);
    public virtual SpawnFilter GetSpawnFilter();
}
public class Deployable : PrefabAttribute {
    public Mesh guideMesh;
    public Vector3 guideMeshScale;
    public bool overrideRotation;
    public Vector3 guideMeshOrientation;
    public bool guideLights;
    public bool wantsInstanceData;
    public bool copyInventoryFromItem;
    public bool setSocketParent;
    public bool toSlot;
    public Slot slot;
    public GameObjectRef placeEffect;
    [TooltipAttribute("Only required if the guideMesh is in a significantly different position or there are multiple meshes")]
public Transform[] guideTargets;
    public Bounds bounds;
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected virtual Type GetIndexedType();
    public bool IsGuideTarget(Transform t);
}
public class DeployableBoomBox : ContainerIOEntity {
    public BoomBox BoxController;
    public int PowerUsageWhilePlaying;
    public static int MaxBacktrackHopsClient;
    public bool IsStatic;
    public BaseEntity ToBaseEntity { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual BaseEntity get_ToBaseEntity();
    public sealed virtual IOEntity ToEntity();
    public virtual int ConsumptionAmount();
    public virtual int DesiredPower(int inputIndex);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void ServerInit();
    public bool ItemFilter(Item item, int count);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    [RPC_Server]
[IsVisible("3")]
public void ServerTogglePlay(RPCMessage msg);
    [CallsPerSecond("2")]
[IsVisible("3")]
[RPC_Server]
public void Server_UpdateRadioIP(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public bool ClearRadioByUserId(ulong id);
    public sealed virtual void OnCassetteInserted(Cassette c);
    public sealed virtual void OnCassetteRemoved(Cassette c);
    public void HurtCallback(float amount);
    public virtual void Load(LoadInfo info);
}
public class DeployableDecay : Decay {
    public float decayDelay;
    public float decayDuration;
    public bool overrideHealRate;
    public float decayTickOverride;
    public bool decayIndoors;
    public float healRate;
    public virtual float GetDecayDelay(BaseEntity entity);
    public virtual float GetDecayDuration(BaseEntity entity);
    public virtual float GetHealScale(BaseEntity entity);
    public virtual float GetDecayTickOverride();
    public virtual bool ShouldDecay(BaseEntity entity);
}
public class DeployableToSlot : MonoBehaviour {
    public Slot slot;
}
public class DeployedFigurine : BaseCombatEntity {
    public float UseCooldown;
    public float HurtPerUse;
    public Animator WobbleAnimator;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[IsVisible("3")]
private void Server_Poke(RPCMessage msg);
    private void ClearBusy();
    public virtual void PostServerLoad();
    private bool CanWobble();
}
public class DeployedRecorder : StorageContainer {
    public AudioSource SoundSource;
    public ItemDefinition[] ValidCassettes;
    public SoundDefinition PlaySfx;
    public SoundDefinition StopSfx;
    public SwapKeycard TapeSwapper;
    private Nullable`1<CollisionDetectionMode> initialCollisionDetectionMode;
    public BaseEntity ToBaseEntity { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual BaseEntity get_ToBaseEntity();
    [RPC_Server]
[IsVisible("3")]
public void ServerTogglePlay(RPCMessage msg);
    private void ServerTogglePlay(bool play);
    public sealed virtual void OnCassetteInserted(Cassette c);
    public sealed virtual void OnCassetteRemoved(Cassette c);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    private void DoCollisionStick(Collision collision, BaseEntity ent);
    public virtual void SetMotionEnabled(bool wantsMotion);
    public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider hitCollider);
    private void UnStick();
    internal virtual void OnParentRemoved();
    public virtual void SetCollisionEnabled(bool wantsCollision);
    public virtual void ResetState();
}
public class Deployer : HeldEntity {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public ItemModDeployable GetModDeployable();
    public Deployable GetDeployable();
    public Quaternion GetDeployedRotation(Vector3 normal, Vector3 placeDir);
    public bool IsPlacementAngleAcceptable(Vector3 pos, Quaternion rot);
    public bool CheckPlacement(Deployable deployable, Ray ray, float fDistance);
    [RPC_Server]
[IsActiveItem]
private void DoDeploy(RPCMessage msg);
    public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID);
    public void DoDeploy_Regular(Deployable deployable, Ray ray);
}
public class DeployGuide : BaseMonoBehaviour {
    public static DeployGuide current;
}
public class DeployShell : PrefabAttribute {
    public Bounds bounds;
    public OBB WorldSpaceBounds(Transform transform);
    public float LineOfSightPadding();
    protected virtual Type GetIndexedType();
}
public abstract class DeployVolume : PrefabAttribute {
    public LayerMask layers;
    [InspectorFlagsAttribute]
public Flags ignore;
    public EntityMode entityMode;
    [FormerlySerializedAsAttribute("entities")]
public BaseEntity[] entityList;
    [SerializeField]
public EntityListScriptableObject[] entityGroups;
    [CompilerGeneratedAttribute]
private bool <IsBuildingBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private static Collider <LastDeployHit>k__BackingField;
    public bool IsBuildingBlock { get; public set; }
    public static Collider LastDeployHit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsBuildingBlock();
    [CompilerGeneratedAttribute]
public void set_IsBuildingBlock(bool value);
    protected virtual Type GetIndexedType();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected abstract virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected abstract virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected abstract virtual bool Check(Vector3 position, Quaternion rotation, OBB test, int mask);
    public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask);
    public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, List`1<Type> allowedTypes, int mask);
    public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, OBB test, int mask);
    public static bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume);
    public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume);
    public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume);
    public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume, List`1<Type> allowedTypes);
    public static bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume);
    [CompilerGeneratedAttribute]
public static Collider get_LastDeployHit();
    [CompilerGeneratedAttribute]
public static void set_LastDeployHit(Collider value);
    private static bool CheckFlags(List`1<Collider> list, DeployVolume volume, List`1<Type> allowedTypes);
    private static bool CheckEntityList(BaseEntity entity, BaseEntity[] entities, bool trueIfAnyFound);
}
public class DeployVolumeCapsule : DeployVolume {
    public Vector3 center;
    public float radius;
    public float height;
    protected virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask);
}
public class DeployVolumeEntityBounds : DeployVolume {
    public Bounds bounds;
    protected virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class DeployVolumeEntityBoundsReverse : DeployVolume {
    public Bounds bounds;
    public int layer;
    protected virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, OBB test, int mask);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class DeployVolumeOBB : DeployVolume {
    public Bounds bounds;
    public DeployVolumeOBB(Bounds bounds, LayerMask layers);
    protected virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, OBB test, int mask);
}
public class DeployVolumeSphere : DeployVolume {
    public Vector3 center;
    public float radius;
    protected virtual bool Check(Vector3 position, Quaternion rotation, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, List`1<Type> allowedTypes, int mask);
    protected virtual bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask);
}
[PostProcessAttribute("DepthOfFieldEffectRenderer", "Unity/Depth of Field (Custom)", "False")]
public class DepthOfFieldEffect : PostProcessEffectSettings {
    public FloatParameter focalLength;
    public FloatParameter focalSize;
    public FloatParameter aperture;
    [RangeAttribute("0", "3")]
public FloatParameter anamorphicSqueeze;
    [RangeAttribute("0", "1")]
public FloatParameter anamorphicBarrel;
    public FloatParameter maxBlurSize;
    public BoolParameter highResolution;
    public DOFBlurSampleCountParameter blurSampleCount;
    public Transform focalTransform;
}
public class DepthOfFieldEffectRenderer : PostProcessEffectRenderer`1<DepthOfFieldEffect> {
    private float focalDistance01;
    private float internalBlurWidth;
    private Shader dofShader;
    public virtual void Init();
    private float FocalDistance01(Camera cam, float worldDist);
    private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet);
    public virtual void Render(PostProcessRenderContext context);
}
public class DestroyArcadeEntity : BaseMonoBehaviour {
    public ArcadeEntity ent;
    public float TimeToDie;
    public float TimeToDieVariance;
    private void Start();
    private void DestroyAction();
}
public class DestroyOnGroundMissing : MonoBehaviour {
    private void OnGroundMissing();
}
public class DestroyOutsideMonument : FacepunchBehaviour {
    [SerializeField]
private BaseCombatEntity baseCombatEntity;
    [SerializeField]
private float checkEvery;
    private MonumentInfo ourMonument;
    private Vector3 OurPos { get; }
    private Vector3 get_OurPos();
    protected void OnEnable();
    protected void OnDisable();
    private MonumentInfo GetOurMonument();
    private void CheckPosition();
    private void DoOutsideMonument();
}
public class DetachMonumentChildren : MonoBehaviour {
    private void Awake();
}
public class Detonator : HeldEntity {
    public int frequency;
    private float timeSinceDeploy;
    public GameObjectRef frequencyPanelPrefab;
    public GameObjectRef attackEffect;
    public GameObjectRef unAttackEffect;
    private float nextChangeTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
public void SetPressed(RPCMessage msg);
    internal void InternalSetPressed(bool pressed);
    public sealed virtual Vector3 GetPosition();
    public sealed virtual float GetMaxRange();
    public sealed virtual void RFSignalUpdate(bool on);
    public virtual void SetHeld(bool bHeld);
    [RPC_Server]
public void ServerSetFrequency(RPCMessage msg);
    public void ServerSetFrequency(BasePlayer player, int freq);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public sealed virtual int GetFrequency();
}
public class DevBotSpawner : FacepunchBehaviour {
    public GameObjectRef bot;
    public Transform waypointParent;
    public bool autoSelectLatestSpawnedGameObject;
    public float spawnRate;
    public int maxPopulation;
    private Transform[] waypoints;
    private List`1<BaseEntity> _spawned;
    public bool HasFreePopulation();
    public void SpawnBot();
    public void Start();
}
public class DevCamera : MonoBehaviour {
    public float movementScale;
}
[ExecuteInEditMode]
public class DevControls : MonoBehaviour {
    public GUISkin skin;
}
public class DevControlsTab : BaseMonoBehaviour {
}
public class DevDressPlayer : MonoBehaviour {
    public bool DressRandomly;
    public List`1<ItemAmount> clothesToWear;
    private void ServerInitComponent();
    private void DoRandomClothes(BasePlayer player);
}
public static class DeveloperList : object {
    public static bool Contains(string steamid);
    public static bool Contains(ulong steamid);
    public static bool IsDeveloper(BasePlayer ply);
}
public class DeveloperTools : SingletonComponent`1<DeveloperTools> {
    public GameObject developerTools;
    public GameObject navButton;
    public GameObject panelContainer;
    public Text ConsoleInput;
}
public class DeveloperUI : MonoBehaviour {
}
public class DevEnableDisable : DevControlsTab {
    public GameObject[] Objects;
    public string CookieName;
    public string TabName;
}
public class DevEnvironment : DevControlsTab {
    public TOD_Sky sky;
}
public class DevImpactEffectTest : MonoBehaviour {
}
public class DevMovePlayer : BaseMonoBehaviour {
    public BasePlayer player;
    public Transform[] Waypoints;
    public bool moveRandomly;
    public Vector3 destination;
    public Vector3 lookPoint;
    private int waypointIndex;
    private float randRun;
    public void Awake();
    public void LateSpawn();
    public void SetWaypoints(Transform[] wps);
    public void Update();
}
public class DevTimeAdjust : MonoBehaviour {
    private void Start();
    private void OnGUI();
}
public class DevWeatherAdjust : MonoBehaviour {
    protected void Awake();
    protected void OnGUI();
}
[Factory("global")]
public class DiagnosticsConSys : ConsoleSystem {
    private static void DumpAnimators(string targetFolder);
    [ServerVar]
[ClientVar]
public static void dump(Arg args);
    private static void DumpSystemInformation(string targetFolder);
    private static void WriteTextToFile(string file, string text);
    private static void DumpEntities(string targetFolder);
    private static void DumpLODGroups(string targetFolder);
    private static void DumpLODGroupTotals(string targetFolder);
    private static void DumpNetwork(string targetFolder);
    private static void DumpObjects(string targetFolder);
    private static void DumpPhysics(string targetFolder);
    private static void DumpTotals(string targetFolder);
    private static void DumpColliders(string targetFolder);
    private static void DumpRigidBodies(string targetFolder);
    private static string GetOutputDirectoryForScene(string targetFolder, int sceneIndex, Scene scene);
    private static void DumpSceneGameObjects(string targetFolder, int sceneIndex);
    private static void DumpAllGameObjects(string targetFolder);
    private static void DumpGameObjects(string targetFolder, Transform[] rootObjects);
    private static void DumpGameObjectRecursive(StringBuilder str, Transform tx, int indent, bool includeComponents);
    private static void DumpWarmup(string targetFolder);
    private static void DumpWarmupTimings(string targetFolder);
    private static void DumpWorldSpawnTimings(string targetFolder);
}
public class DieselEngine : StorageContainer {
    public GameObjectRef rumbleEffect;
    public Transform rumbleOrigin;
    public static Flags Flag_HasFuel;
    public float runningTimePerFuelUnit;
    public float cachedFuelTime;
    private static float rumbleMaxDistSq;
    private static string EXCAVATOR_ACTIVATED_STAT;
    private BasePlayer startedByPlayer;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void FixedUpdate();
    [RPC_Server]
[IsVisible("6")]
public void EngineSwitch(RPCMessage msg);
    public void TimedShutdown();
    public bool ConsumeFuelItem(int amount);
    public int GetFuelAmount();
    public void UpdateHasFuelFlag();
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public void EngineOff();
    public void EngineOn();
    public void RescheduleEngineShutdown();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public bool HasFuel();
}
[CreateAssetMenuAttribute]
public class DiggableEntityLoot : ScriptableObject {
    public List`1<ItemEntry> Items;
    [InspectorFlagsAttribute]
public Enum Biomes;
    [InspectorFlagsAttribute]
public Enum Topology;
    public bool VerifyLootListForWorldPosition(Vector3 worldPos);
}
public class DigitalClock : IOEntity {
    [SerializeField]
private TextMeshPro clockText;
    [SerializeField]
private SoundDefinition ringingSoundDef;
    [SerializeField]
private SoundDefinition ringingStartSoundDef;
    [SerializeField]
private SoundDefinition ringingStopSoundDef;
    public GameObjectRef clockConfigPanel;
    public List`1<Alarm> alarms;
    [HideInInspector]
public bool muted;
    private bool isRinging;
    public static float ringDuration;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private void OnMinute();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public bool CanPlayerAdmin(BasePlayer player);
    public virtual void ServerInit();
    private void CheckAlarms();
    private void Ring();
    private void StopRinging();
    [CallsPerSecond("5")]
[IsVisible("3")]
[RPC_Server]
public void RPC_SetAlarms(RPCMessage msg);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void ResetIOState();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class DigitalClockConfig : IOConfig`1<DigitalClock> {
    public DigitalClockConfigAlarm alarmPrefab;
    public Transform alarmParent;
    public GameObject placeHolder;
    public Button addButton;
    public RustButton muteButton;
}
public class DigitalClockConfigAlarm : MonoBehaviour {
    public CanvasGroup canvasGroup;
    public ClockSlider slider;
    public RustButton toggleButton;
    [SpaceAttribute]
public GameObject deleteButton;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    private DigitalClockConfig owner;
    private bool deleteButtonHovered;
    public bool Active { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
private void set_Active(bool value);
}
[ExtensionAttribute]
public static class DigitalClockEx : object {
    [ExtensionAttribute]
public static TimeSpan ToTimeSpan(float value);
    [ExtensionAttribute]
public static float ToFloat(TimeSpan timeSpan);
}
public class DirectionalDamageTrigger : TriggerBase {
    public float repeatRate;
    public List`1<DamageTypeEntry> damageType;
    public GameObjectRef attackEffect;
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnObjects();
    public virtual void OnEmpty();
    private void OnTick();
}
public class DirectionProperties : PrefabAttribute {
    private static float radius;
    public Bounds bounds;
    public ProtectionProperties extraProtection;
    protected virtual Type GetIndexedType();
    public bool IsWeakspot(Transform tx, HitInfo info);
    private bool CheckWeakpointRoof(BaseEntity hitEntity);
    private bool IsWeakspotVisible(BaseEntity hitEntity, Vector3 playerEyes, Vector3 weakspotPos);
}
[ExtensionAttribute]
public static class DirectoryEx : object {
    public static void Backup(DirectoryInfo parent, String[] names);
    [ExtensionAttribute]
public static bool MoveToSafe(DirectoryInfo parent, string target, int retries);
    public static void Backup(String[] names);
    public static void CopyAll(string sourceDirectory, string targetDirectory);
    public static void CopyAll(DirectoryInfo source, DirectoryInfo target);
}
public class DisableSave : MonoBehaviour {
    private void OnValidate();
}
public class DisableWithMainMenu : MonoBehaviour {
}
public class DiscoFloor : AudioVisualisationEntity {
    public float GradientDuration;
    public float VolumeSensitivityMultiplier;
    public float BaseSpeed;
    public Light[] LightSources;
    public DiscoFloorMesh FloorMesh;
}
public class DiscoFloorColourLookups : PrefabAttribute {
    public Single[] InOutLookup;
    public Single[] RadialLookup;
    public Single[] RippleLookup;
    public Single[] CheckerLookup;
    public Single[] BlockLookup;
    public Gradient[] ColourGradients;
    protected virtual Type GetIndexedType();
}
public class DiscoFloorMesh : MonoBehaviour {
    public int GridRows;
    public int GridColumns;
    public float GridSize;
    [RangeAttribute("0", "10")]
public float TestOffset;
    public Color OffColor;
    public MeshRenderer Renderer;
    public bool DrawInEditor;
    public MeshFilter Filter;
    public AnimationCurve customCurveX;
    public AnimationCurve customCurveY;
}
public class DistanceField : object {
    private static Int32[] GaussOffsets;
    private static Single[] GaussWeights;
    private static DistanceField();
    public static void Generate(Int32& size, Byte& threshold, Byte[]& image, Single[]& distanceField);
    private static float SampleClamped(Single[] data, int size, int x, int y);
    private static Vector4 SampleClamped(Vector4[] data, int size, int x, int y);
    private static ushort SampleClamped(UInt16[] data, int size, int x, int y);
    public static void GenerateVectors(Int32& size, Single[]& distanceField, Vector4[]& vectorField);
    public static void ApplyGaussianBlur(int size, Single[] distanceField, int steps);
}
public class DistanceFlareLOD : FacepunchBehaviour {
    public bool isDynamic;
    public float minEnabledDistance;
    public float maxEnabledDistance;
    public bool toggleFade;
    public float toggleFadeDuration;
}
public class DiverPropulsionVehicle : BaseMountable {
    [HeaderAttribute("DPV")]
[SerializeField]
private Buoyancy buoyancy;
    [SerializeField]
private GameObjectRef fuelStoragePrefab;
    [SerializeField]
private Transform propellerTransform;
    [SerializeField]
private float engineKW;
    [SerializeField]
private float turnPower;
    [SerializeField]
private float depthChangeTargetSpeed;
    [SerializeField]
private float engineStartupTime;
    [SerializeField]
private float idleFuelPerSec;
    [SerializeField]
private float maxFuelPerSec;
    [SerializeField]
private GameObject characterWorldCollider;
    [SerializeField]
private float timeUntilAutoSurface;
    [SerializeField]
private float minWaterDepth;
    [HeaderAttribute("DPV - Control stability")]
[SerializeField]
private float rotStability;
    [SerializeField]
private float rotPower;
    [SerializeField]
private float rotTargetChangeRate;
    [SerializeField]
private float vertStability;
    [SerializeField]
private float maxPitchDegrees;
    [SerializeField]
private float maxRollDegrees;
    [SerializeField]
[HeaderAttribute("DPV - UI")]
private Canvas dashboardCanvas;
    [SerializeField]
private RustText fuelBarsText;
    [SerializeField]
private RustText speedometerText;
    [SerializeField]
private float fuelAmountWarning;
    [SerializeField]
private RustText batteryWarningText;
    [SerializeField]
private float healthWarningFraction;
    [SerializeField]
private RustText healthWarningText;
    [SerializeField]
[HeaderAttribute("DPV - FX")]
private Transform leftHandGrip;
    [SerializeField]
private Transform rightHandGrip;
    [SerializeField]
private GameObject lightsToggleGroup;
    [SerializeField]
private DiverPropulsionVehicleAudio dpvAudio;
    [SerializeField]
private ParticleSystem fxUnderWaterEngineThrustForward;
    [SerializeField]
private ParticleSystem[] fxUnderWaterEngineThrustForwardSubs;
    [SerializeField]
private ParticleSystem fxUnderWaterEngineThrustReverse;
    [SerializeField]
private ParticleSystem[] fxUnderWaterEngineThrustReverseSubs;
    private float waterLevelY;
    private float waterDepthHere;
    private float ourDepthInWaterY;
    public static Flags Flag_Headlights;
    public static Flags Flag_Stationary;
    protected VehicleEngineController`1<DiverPropulsionVehicle> engineController;
    private float _throttle;
    private float _steer;
    private float _upDown;
    private float normalDrag;
    private float highDrag;
    private float targetClimbSpeed;
    private TimeSince timeSinceLastUsed;
    private static float DECAY_TICK_TIME;
    private float targetPitch;
    private float targetRoll;
    private bool IsInWater { get; }
    public EngineState<DiverPropulsionVehicle> EngineState { get; }
    public bool LightsOn { get; }
    public bool IsActive { get; }
    public float ThrottleInput { get; protected set; }
    public float SteerInput { get; public set; }
    public float UpDownInput { get; protected set; }
    protected bool PositionTickFixedTime { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool get_IsInWater();
    public EngineState<DiverPropulsionVehicle> get_EngineState();
    public bool get_LightsOn();
    public bool get_IsActive();
    public float get_ThrottleInput();
    protected void set_ThrottleInput(float value);
    public float get_SteerInput();
    public void set_SteerInput(float value);
    public float get_UpDownInput();
    protected void set_UpDownInput(float value);
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual bool CanPickup(BasePlayer player);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    private void UpdateWaterInfo();
    private static void GetWaterInfo(BaseEntity forEntity, Transform referencePoint, Single& surfaceY, Single& depth);
    private bool WaterIsDeepEnough(bool updateWaterInfo);
    public virtual void ServerInit();
    private void SendClientUpdate();
    public virtual void LightToggle(BasePlayer player);
    protected virtual void OnChildAdded(BaseEntity child);
    private void SetFuelUpdateInventoryCallback(StorageContainer sc);
    private void UpdateMovementState();
    public virtual float GetNetworkTime();
    protected virtual bool get_PositionTickFixedTime();
    public virtual void VehicleFixedUpdate();
    public virtual Vector3 GetLocalVelocityServer();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void Save(SaveInfo info);
    public IFuelSystem GetFuelSystem();
    public bool AdminFixUp();
    public sealed virtual void OnEngineStartFailed();
    public sealed virtual bool MeetsEngineRequirements();
    public virtual bool CanBeLooted(BasePlayer player);
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    public virtual void OnPlayerMounted();
    private void SendClientFuelInfo();
    private void DPVDecay();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    private sealed virtual override void IEngineControllerUser.Invoke(Action action, float time);
    private sealed virtual override void IEngineControllerUser.CancelInvoke(Action action);
    [CompilerGeneratedAttribute]
private void <SetFuelUpdateInventoryCallback>b__79_0(Item _, bool _);
}
public class DiverPropulsionVehicleAudio : MonoBehaviour {
    [HeaderAttribute("Engine")]
[SerializeField]
private SoundDefinition engineStartSound;
    [SerializeField]
private SoundDefinition engineStopSound;
    [SerializeField]
private SoundDefinition engineStartFailSound;
    [SerializeField]
private SoundDefinition engineLoopSound;
    [SerializeField]
private AnimationCurve engineLoopPitchCurve;
    [SerializeField]
private SoundDefinition engineActiveLoopDef;
    [SerializeField]
[HeaderAttribute("Propeller")]
private SoundDefinition propellerLoopSoundDef;
    [SerializeField]
private AnimationCurve propellerPitchCurve;
    [SerializeField]
private AnimationCurve propellerGainCurve;
    [SerializeField]
[HeaderAttribute("Water")]
private SoundDefinition waterMovementLoopDef;
    [SerializeField]
private AnimationCurve waterMovementGainCurve;
    [SerializeField]
private SoundDefinition waterSurfaceLoopDef;
    [SerializeField]
private float surfaceWaterMovementStartDepth;
    [SerializeField]
private float surfaceWaterMovementEndDepth;
    [SerializeField]
private float waterMovementYSpeedScale;
    [SerializeField]
private SoundDefinition waterEmergeSoundDef;
    [SerializeField]
private SoundDefinition waterSubmergeSoundDef;
}
public class DiveSite : JunkPile {
    public Transform bobber;
    public virtual float TimeoutPlayerCheckRadius();
}
public class DiveSiteBuoy : BaseEntity {
    public float UpdateCullRange;
    public Vector3 RotationRate;
    private Action _updateAction;
    private Action updateAction { get; }
    private Action get_updateAction();
    public virtual void ServerInit();
    private void CheckForNearbyPlayers();
    private void UpdateMovement();
}
public enum DOFBlurSampleCount : Enum {
    public int value__;
    public static DOFBlurSampleCount Low;
    public static DOFBlurSampleCount Medium;
    public static DOFBlurSampleCount High;
    public static DOFBlurSampleCount VeryHigh;
}
public class DOFBlurSampleCountParameter : ParameterOverride`1<DOFBlurSampleCount> {
}
[ExecuteInEditMode]
public class DofExposer : ListComponent`1<DofExposer> {
    public PostProcessVolume PostVolume;
    public bool DofEnabled;
    public float FocalLength;
    public float Blur;
    public float FocalAperture;
    public float AnamorphicSqueeze;
    public float AnamorphicBarrel;
    public bool debug;
}
[ObsoleteAttribute]
public class DontBecomeSolidWithPlayerInside : MonoBehaviour {
}
public class Door : AnimatedBuildingBlock {
    public GameObjectRef knockEffect;
    public bool canTakeLock;
    public bool hasHatch;
    public bool canTakeCloser;
    public bool canTakeKnocker;
    public bool canNpcOpen;
    public bool canHandOpen;
    public bool isSecurityDoor;
    public bool canReverseOpen;
    public TriggerNotify[] vehiclePhysBoxes;
    public bool checkPhysBoxesOnOpen;
    public SoundDefinition vehicleCollisionSfx;
    public GameObject[] ClosedColliderRoots;
    public bool allowOnCargoShip;
    [ReadOnlyAttribute]
[SerializeField]
private float openAnimLength;
    [ReadOnlyAttribute]
[SerializeField]
private float closeAnimLength;
    public static Flags ReverseOpen;
    public NavMeshModifierVolume NavMeshVolumeAnimals;
    public NavMeshModifierVolume NavMeshVolumeHumanoids;
    public NPCDoorTriggerBox NpcTriggerBox;
    public NavMeshLink NavMeshLink;
    private static int nonWalkableArea;
    private static int animalAgentTypeId;
    private static int humanoidAgentTypeId;
    private float decayResetTimeLast;
    private Dictionary`2<BasePlayer, TimeSince> woundedOpens;
    private Dictionary`2<BasePlayer, TimeSince> woundedCloses;
    private float nextKnockTime;
    private static int openHash;
    private static int closeHash;
    private static int reverseOpenHash;
    public bool AllowOnCargoShip { get; }
    private bool HasVehiclePushBoxes { get; }
    private static Door();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual bool get_AllowOnCargoShip();
    public virtual void ServerInit();
    public virtual bool HasSlot(Slot slot);
    public virtual bool CanPickup(BasePlayer player);
    public void CloseRequest();
    public void SetOpen(bool open, bool suppressBlockageChecks);
    public void SetLocked(bool locked);
    public bool GetPlayerLockPermission(BasePlayer player);
    public void SetNavMeshLinkEnabled(bool wantsOn);
    [MaxDistance("3")]
[RPC_Server]
protected void RPC_OpenDoor(RPCMessage rpc);
    private void DelayedDoorOpening();
    protected virtual void OnPlayerOpenedDoor(BasePlayer p);
    protected virtual bool ShouldDelayOpen(BasePlayer forPlayer, Single& delay);
    private void StartCheckingForBlockages(bool isOpening);
    private void StopCheckingForBlockages();
    [MaxDistance("3")]
[RPC_Server]
private void RPC_CloseDoor(RPCMessage rpc);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_KnockDoor(RPCMessage rpc);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_ToggleHatch(RPCMessage rpc);
    private void EnableVehiclePhysBoxes();
    private void DisableVehiclePhysBox();
    private bool get_HasVehiclePushBoxes();
    private void ToggleVehiclePushBoxes(bool state);
    [RPC_Server]
[IsVisible("3")]
private void Server_NotifyWoundedOpen(RPCMessage msg);
    private void CheckTimedOutPlayers(Dictionary`2<BasePlayer, TimeSince> dictionary);
    [RPC_Server]
[IsVisible("3")]
private void Server_NotifyWoundedClose(RPCMessage msg);
    public virtual bool SupportsChildDeployables();
    public virtual void OnPickedUp(Item createdItem, BasePlayer player);
    private void ReverseDoorAnimation(bool wasOpening);
    public virtual float BoundsPadding();
    public sealed virtual void OnObjects(TriggerNotify trigger);
    public sealed virtual void OnEmpty();
    protected virtual void ApplySubAnimationParameters(bool init, Animator toAnimator);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    [CompilerGeneratedAttribute]
private void <Server_NotifyWoundedOpen>b__54_0();
    [CompilerGeneratedAttribute]
private void <Server_NotifyWoundedClose>b__56_0();
}
public class DoorAnimEvents : MonoBehaviour {
    public GameObjectRef openStart;
    public GameObjectRef openEnd;
    public GameObjectRef closeStart;
    public GameObjectRef closeEnd;
    public GameObject soundTarget;
    public bool checkAnimSpeed;
    public Animator animator { get; }
    public Animator get_animator();
    public void DoorOpenStart();
    public void DoorOpenEnd();
    public void DoorCloseStart();
    public void DoorCloseEnd();
}
public class DoorCloser : BaseEntity {
    [ItemSelector("11")]
public ItemDefinition itemType;
    public float delay;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float BoundsPadding();
    public void Think();
    public void SendClose();
    [MaxDistance("3")]
[RPC_Server]
public void RPC_Take(RPCMessage rpc);
    public Door GetDoor();
}
public class DoorKnocker : BaseCombatEntity {
    public Animator knocker1;
    public Animator knocker2;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void Knock(BasePlayer player);
}
public class DoorManipulator : IOEntity {
    public EntityRef entityRef;
    public Door targetDoor;
    public DoorEffect powerAction;
    private bool toggle;
    public virtual bool CanPairWithLockedDoors();
    public virtual void Init();
    public virtual void SetupInitialDoorConnection();
    public virtual void SetTargetDoor(Door newTargetDoor);
    public virtual Door FindDoor(bool allowLocked);
    public virtual void DoActionDoorMissing();
    public virtual void DoAction(DoorEffect action);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class DoorWithLock : Door {
    [ItemSelector("11")]
[HeaderAttribute("Lock Settings")]
public GameObjectRef lockObject;
}
public class DoubleShotgunViewModel : BaseViewModel {
    public GameObject NoSkinRoot;
}
[PostProcessAttribute("DoubleVisionRenderer", "2", "Custom/DoubleVision", "True")]
public class DoubleVision : PostProcessEffectSettings {
    [RangeAttribute("0", "1")]
public Vector2Parameter displace;
    [RangeAttribute("0", "1")]
public FloatParameter amount;
}
public class DoubleVisionRenderer : PostProcessEffectRenderer`1<DoubleVision> {
    private int displaceProperty;
    private int amountProperty;
    private Shader doubleVisionShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class DragMe : MonoBehaviour {
    public static DragMe dragging;
    public static GameObject dragIcon;
    public static object data;
    public string dragType;
    protected Canvas TopCanvas { get; }
    public virtual void OnBeginDrag(PointerEventData eventData);
    protected virtual Canvas get_TopCanvas();
    public virtual void OnDrag(PointerEventData eventData);
    public virtual void OnEndDrag(PointerEventData eventData);
    public void CancelDrag();
}
public class DragMeCustomParent : DragMe {
    public Canvas OverrideCanvas;
    public bool ShouldCancelOnDrop;
}
public class DragReceiver : MonoBehaviour {
    public TriggerEvent onEndDrag;
}
public class DrawArrow : MonoBehaviour {
    public Color color;
    public float length;
    public float arrowLength;
    private void OnDrawGizmos();
}
[RequireComponent("UnityEngine.Camera")]
public class DrawCameraFrustum : MonoBehaviour {
    [SerializeField]
private Material lineMaterial;
}
public class DrawSkeleton : MonoBehaviour {
    private void OnDrawGizmos();
    private static void DrawTransform(Transform t);
}
public class Drone : RemoteControlEntity {
    [ReplicatedVar]
public static float maxControlRange;
    [ServerVar]
public static float movementSpeedOverride;
    [ServerVar]
public static float altitudeSpeedOverride;
    [ClientVar]
public static float windTimeDivisor;
    [ClientVar]
public static float windPositionDivisor;
    [ClientVar]
public static float windPositionScale;
    [ClientVar]
public static float windRotationMultiplier;
    [ClientVar]
public static float windLerpSpeed;
    public static Flags Flag_ThrottleUp;
    public static Flags Flag_Flying;
    [HeaderAttribute("Drone")]
public Rigidbody body;
    public Transform modelRoot;
    public bool killInWater;
    public bool enableGrounding;
    public bool keepAboveTerrain;
    public float groundTraceDist;
    public float groundCheckInterval;
    public float altitudeAcceleration;
    public float movementAcceleration;
    public float yawSpeed;
    public float uprightSpeed;
    public float uprightPrediction;
    public float uprightDot;
    public float leanWeight;
    public float leanMaxVelocity;
    public float hurtVelocityThreshold;
    public float hurtDamagePower;
    public float collisionDisableTime;
    public float pitchMin;
    public float pitchMax;
    public float pitchSensitivity;
    public bool disableWhenHurt;
    [RangeAttribute("0", "1")]
public float disableWhenHurtChance;
    public float playerCheckInterval;
    public float playerCheckRadius;
    public float deployYOffset;
    [HeaderAttribute("Sound")]
public SoundDefinition movementLoopSoundDef;
    public SoundDefinition movementStartSoundDef;
    public SoundDefinition movementStopSoundDef;
    public AnimationCurve movementLoopPitchCurve;
    public float movementSpeedReference;
    [HeaderAttribute("Animation")]
public float propellerMaxSpeed;
    public float propellerAcceleration;
    public Transform propellerA;
    public Transform propellerB;
    public Transform propellerC;
    public Transform propellerD;
    public float pitch;
    public Nullable`1<Vector3> targetPosition;
    public DroneInputState currentInput;
    public float lastInputTime;
    public double lastCollision;
    public TimeSince lastGroundCheck;
    public bool isGrounded;
    public RealTimeSinceEx lastPlayerCheck;
    public bool RequiresMouse { get; }
    public float MaxRange { get; }
    public bool CanAcceptInput { get; }
    protected bool PositionTickFixedTime { get; }
    private static Drone();
    public virtual bool get_RequiresMouse();
    public virtual float get_MaxRange();
    public virtual void Spawn();
    public virtual bool get_CanAcceptInput();
    public virtual void StopControl(CameraViewerId viewerID);
    public virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public virtual void Update_Server();
    public void FixedUpdate();
    public void OnCollisionEnter(Collision collision);
    public void OnCollisionStay();
    public virtual void Hurt(HitInfo info);
    public virtual float GetNetworkTime();
    protected virtual bool get_PositionTickFixedTime();
    public virtual Vector3 GetLocalVelocityServer();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void Update();
    public virtual bool CanChangeID(BasePlayer player);
    public virtual bool CanPickup(BasePlayer player);
    public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual bool ShouldNetworkOwnerInfo();
    public virtual bool ShouldInheritNetworkGroup();
    public virtual float MaxVelocity();
}
public class DroneInformationPanel : ItemInformationPanel {
    public RustText identifierLabel;
}
public class DropBox : Mailbox {
    public Transform EyePoint;
    public virtual bool PlayerIsOwner(BasePlayer player);
    public bool PlayerBehind(BasePlayer player);
    public bool PlayerInfront(BasePlayer player);
    public virtual bool SupportsChildDeployables();
}
public class DropMe : MonoBehaviour {
    public String[] droppableTypes;
    public virtual void OnDrop(PointerEventData eventData);
}
public class DroppedItem : WorldItem {
    [HeaderAttribute("DroppedItem")]
public GameObjectRef itemModel;
    public GameObjectRef splashEffect;
    [CompilerGeneratedAttribute]
private Collider <childCollider>k__BackingField;
    [ServerVar]
public static float underwater_drag_budget_ms;
    private static Flags FLAG_STUCK;
    private static Flags FLAG_UNDERWATER;
    private int originalLayer;
    public DropReasonEnum DropReason;
    public ulong DroppedBy;
    public DateTime DroppedTime;
    public bool NeverCombine;
    private Rigidbody rB;
    private CollisionDetectionMode originalCollisionMode;
    private Vector3 prevLocalPos;
    private static float SLEEP_CHECK_FREQUENCY;
    private static float AIR_DRAG;
    private static float UNDERWATER_DRAG;
    private bool hasLastPos;
    private Vector3 lastGoodColliderCentre;
    private Vector3 lastGoodPos;
    private Quaternion lastGoodRot;
    private Action cachedSleepCheck;
    private float maxBoundsExtent;
    private Vector3 smallVerticalOffset;
    public static DroppedItemUnderwaterQueue underwaterStatusQueue;
    private TimeSince lastUnderwaterFlowImpulse;
    public Collider childCollider { get; private set; }
    private bool StuckInSomething { get; }
    public SoundDefinition OpenSound { get; }
    public SoundDefinition CloseSound { get; }
    private static DroppedItem();
    [CompilerGeneratedAttribute]
public Collider get_childCollider();
    [CompilerGeneratedAttribute]
private void set_childCollider(Collider value);
    private bool get_StuckInSomething();
    public SoundDefinition get_OpenSound();
    public SoundDefinition get_CloseSound();
    public virtual float GetNetworkTime();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual float GetDespawnDuration();
    public void IdleDestroy();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public void OnDroppedOn(DroppedItem di);
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    internal virtual void OnParentRemoved();
    public void StickIn();
    public void Unstick();
    private void SleepCheck();
    private void OnPhysicsNeighbourChanged();
    public virtual void OnPositionalNetworkUpdate();
    protected virtual bool ShouldUpdateNetworkPosition();
    private void CheckValidPosition();
    private void OnUnparented();
    private void OnParented();
    public virtual void PostInitShared();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    private void BecomeActive();
    private void BecomeInactive();
    private void EnableCollider();
    public void UpdateItemMass();
    public virtual bool ShouldInheritNetworkGroup();
    private void CheckUnderwaterStatus(bool canSplash);
    private void UpdateUnderwaterDrag();
}
public class DroppedItemContainer : BaseCombatEntity {
    public string lootPanelName;
    public int maxItemCount;
    public ulong playerSteamID;
    public string _playerName;
    public bool ItemBasedDespawn;
    public bool onlyOwnerLoot;
    public SoundDefinition openSound;
    public SoundDefinition closeSound;
    public static Flags HasItems;
    public static Flags HasBeenOpened;
    [CompilerGeneratedAttribute]
private ulong <LastLootedBy>k__BackingField;
    public ItemContainer inventory;
    public Phrase LootPanelTitle { get; }
    public string playerName { get; public set; }
    public ulong LastLootedBy { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Phrase get_LootPanelTitle();
    public string get_playerName();
    public void set_playerName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_LastLootedBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastLootedBy(ulong value);
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual void ServerInit();
    public void RemoveMe();
    private void EvaluateBagConditions();
    public void ResetRemovalTime(float dur);
    public void ResetRemovalTime();
    public float CalculateRemovalTime();
    internal virtual void DoServerDestroy();
    public void TakeFrom(ItemContainer[] source, float destroyPercent);
    [IsVisible("3")]
[RPC_Server]
private void RPC_OpenLoot(RPCMessage rpc);
    public void PlayerStoppedLooting(BasePlayer player);
    public virtual void PreServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class DropUtil : object {
    public static void DropItems(ItemContainer container, Vector3 position);
}
public class DudTimedExplosive : TimedExplosive {
    public GameObjectRef fizzleEffect;
    public GameObject wickSpark;
    public AudioSource wickSound;
    public float dudChance;
    [ItemSelector("11")]
public ItemDefinition itemToGive;
    private float explodeTime;
    public bool becomeDudInWater;
    protected bool AlwaysRunWaterCheck { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool IsWickBurning();
    protected virtual bool get_AlwaysRunWaterCheck();
    public virtual void WaterCheck();
    public virtual float GetRandomTimerTime();
    [MaxDistance("3")]
[RPC_Server]
public void RPC_Pickup(RPCMessage msg);
    public virtual void SetFuse(float fuseLength);
    public virtual void Explode();
    public virtual bool CanStickTo(BaseEntity entity);
    public virtual void BecomeDud();
    public virtual void Save(SaveInfo info);
    public sealed virtual void Ignite(Vector3 fromPos);
    public sealed virtual bool CanIgnite();
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public virtual void Load(LoadInfo info);
}
public class DummySwitch : IOEntity {
    public string listenString;
    public string listenStringOff;
    public float duration;
    public virtual bool WantsPower(int inputIndex);
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public void SetOn(bool wantsOn);
    public void SetOff();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
}
public class DungeonBaseFloor : object {
    public List`1<DungeonBaseLink> Links;
    public float Distance(Vector3 position);
    public float SignedDistance(Vector3 position);
}
public class DungeonBaseInfo : LandmarkInfo {
    public List`1<GameObject> Links;
    public List`1<DungeonBaseFloor> Floors;
    public float Distance(Vector3 position);
    public float SqrDistance(Vector3 position);
    public void Add(DungeonBaseLink link);
    protected virtual void Awake();
    protected void Start();
    [CompilerGeneratedAttribute]
private int <Add>b__4_0(DungeonBaseFloor l, DungeonBaseFloor r);
}
[RequireComponent("DungeonBaseLink")]
public class DungeonBaseLandmarkInfo : LandmarkInfo {
    private DungeonBaseLink baseLink;
    private Nullable`1<MapLayer> layer;
    public MapLayer MapLayer { get; }
    protected virtual void Awake();
    public virtual MapLayer get_MapLayer();
}
public class DungeonBaseLink : MonoBehaviour {
    public DungeonBaseLinkType Type;
    public int Cost;
    public int MaxFloor;
    public int MaxCountLocal;
    public int MaxCountGlobal;
    [TooltipAttribute("If set to a positive number, all segments with the same MaxCountIdentifier are counted towards MaxCountLocal and MaxCountGlobal")]
public int MaxCountIdentifier;
    public DungeonBaseInfo Dungeon;
    public RendererLOD[] MapRendererLods;
    private List`1<DungeonBaseSocket> sockets;
    private List`1<DungeonVolume> volumes;
    internal List`1<DungeonBaseSocket> Sockets { get; }
    internal List`1<DungeonVolume> Volumes { get; }
    internal List`1<DungeonBaseSocket> get_Sockets();
    internal List`1<DungeonVolume> get_Volumes();
    protected void Awake();
    internal void Initialize();
}
public enum DungeonBaseLinkType : Enum {
    public int value__;
    public static DungeonBaseLinkType Room;
    public static DungeonBaseLinkType Corridor;
    public static DungeonBaseLinkType End;
}
public class DungeonBaseSocket : MonoBehaviour {
    public DungeonBaseSocketType Type;
    public bool Male;
    public bool Female;
}
public enum DungeonBaseSocketType : Enum {
    public int value__;
    public static DungeonBaseSocketType Horizontal;
    public static DungeonBaseSocketType Vertical;
    public static DungeonBaseSocketType Pillar;
}
public class DungeonBaseTransition : MonoBehaviour {
    public DungeonBaseSocketType Type;
    public DungeonBaseLinkType Neighbour1;
    public DungeonBaseLinkType Neighbour2;
}
public class DungeonGridCell : MonoBehaviour {
    public DungeonGridConnectionType North;
    public DungeonGridConnectionType South;
    public DungeonGridConnectionType West;
    public DungeonGridConnectionType East;
    public DungeonGridConnectionVariant NorthVariant;
    public DungeonGridConnectionVariant SouthVariant;
    public DungeonGridConnectionVariant WestVariant;
    public DungeonGridConnectionVariant EastVariant;
    public GameObjectRef[] AvoidNeighbours;
    public RendererLOD[] MapRendererLods;
    public bool Replaceable;
    public bool ShouldAvoid(UInt32 id);
    protected void Awake();
}
public class DungeonGridConnectionHash : ValueType {
    public bool North;
    public bool South;
    public bool West;
    public bool East;
    public int Value { get; }
    public int get_Value();
}
public enum DungeonGridConnectionType : Enum {
    public int value__;
    public static DungeonGridConnectionType None;
    public static DungeonGridConnectionType TrainTunnel;
}
public enum DungeonGridConnectionVariant : Enum {
    public int value__;
    public static DungeonGridConnectionVariant A;
    public static DungeonGridConnectionVariant B;
}
public class DungeonGridInfo : LandmarkInfo {
    [HeaderAttribute("DungeonGridInfo")]
public int CellSize;
    public float LinkHeight;
    public float LinkRadius;
    internal List`1<GameObject> Links;
    public float MinDistance { get; }
    public float get_MinDistance();
    public float Distance(Vector3 position);
    public float SqrDistance(Vector3 position);
    public bool IsValidSpawnPosition(Vector3 position);
    public Vector3 SnapPosition(Vector3 pos);
    protected virtual void Awake();
    protected void Start();
}
public class DungeonGridLink : MonoBehaviour {
    public Transform UpSocket;
    public Transform DownSocket;
    public DungeonGridLinkType UpType;
    public DungeonGridLinkType DownType;
    public int Priority;
    public int Rotation;
    protected void Start();
}
public enum DungeonGridLinkType : Enum {
    public int value__;
    public static DungeonGridLinkType Default;
    public static DungeonGridLinkType Elevator;
    public static DungeonGridLinkType Transition;
}
public class DungeonNavmesh : FacepunchBehaviour {
    public int NavMeshAgentTypeIndex;
    [TooltipAttribute("The default area associated with the NavMeshAgent index.")]
public string DefaultAreaName;
    public float NavmeshResolutionModifier;
    [TooltipAttribute("Bounds which are auto calculated from CellSize * CellCount")]
public Bounds Bounds;
    public NavMeshData NavMeshData;
    public NavMeshDataInstance NavMeshDataInstance;
    public LayerMask LayerMask;
    public NavMeshCollectGeometry NavMeshCollectGeometry;
    public static List`1<DungeonNavmesh> Instances;
    [ServerVar]
public static bool use_baked_terrain_mesh;
    private List`1<NavMeshBuildSource> sources;
    private AsyncOperation BuildingOperation;
    private bool HasBuildOperationStarted;
    private Stopwatch BuildTimer;
    private int defaultArea;
    private int agentTypeId;
    public bool IsBuilding { get; }
    private static DungeonNavmesh();
    public static bool NavReady();
    public bool get_IsBuilding();
    private void OnEnable();
    private void OnDisable();
    [ContextMenu("Update Monument Nav Mesh")]
public void UpdateNavMeshAsync();
    public void NotifyInformationZonesOfCompletion();
    public void SourcesCollected();
    [IteratorStateMachineAttribute("DungeonNavmesh/<UpdateNavMeshAndWait>d__24")]
public IEnumerator UpdateNavMeshAndWait();
    private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources);
    public void FinishBuildingNavmesh();
}
public class DungeonVolume : MonoBehaviour {
    public Bounds bounds;
    public OBB GetBounds(Vector3 position, Quaternion rotation);
    public OBB GetBounds(Vector3 position, Quaternion rotation, Vector3 extrude);
}
public class DynamicDungeon : BaseEntity {
    public Transform exitEntitySpawn;
    public GameObjectRef exitEntity;
    public string exitString;
    public MonumentNavMesh monumentNavMesh;
    private static List`1<DynamicDungeon> _dungeons;
    public GameObjectRef portalPrefab;
    public Transform portalSpawnPoint;
    public BasePortal exitPortal;
    public GameObjectRef doorPrefab;
    public Transform doorSpawnPoint;
    public Door doorInstance;
    public static Vector3 nextDungeonPos;
    public static Vector3 dungeonStartPoint;
    public static float dungeonSpacing;
    public SpawnGroup[] spawnGroups;
    public bool AutoMergeAIZones;
    private static DynamicDungeon();
    public static void AddDungeon(DynamicDungeon newDungeon);
    public static void RemoveDungeon(DynamicDungeon dungeon);
    public static Vector3 GetNextDungeonPoint();
    [IteratorStateMachineAttribute("DynamicDungeon/<UpdateNavMesh>d__19")]
public IEnumerator UpdateNavMesh();
    public virtual void DestroyShared();
    public virtual void ServerInit();
    private void MergeAIZones();
    public sealed virtual void MissionStarted(BasePlayer assignee, MissionInstance instance);
    public sealed virtual void MissionEnded(BasePlayer assignee, MissionInstance instance);
}
public class DynamicMouseCursor : MonoBehaviour {
    public Texture2D RegularCursor;
    public Vector2 RegularCursorPos;
    public Texture2D HoverCursor;
    public Vector2 HoverCursorPos;
    private Texture2D current;
    private void LateUpdate();
    private void UpdateCursor(Texture2D cursor, Vector2 offs);
    private GameObject CurrentlyHoveredItem();
}
public class DynamicNavMesh : SingletonComponent`1<DynamicNavMesh> {
    public int NavMeshAgentTypeIndex;
    [TooltipAttribute("The default area associated with the NavMeshAgent index.")]
public string DefaultAreaName;
    public int AsyncTerrainNavMeshBakeCellSize;
    public int AsyncTerrainNavMeshBakeCellHeight;
    public Bounds Bounds;
    public NavMeshData NavMeshData;
    public NavMeshDataInstance NavMeshDataInstance;
    public LayerMask LayerMask;
    public NavMeshCollectGeometry NavMeshCollectGeometry;
    [ServerVar]
public static bool use_baked_terrain_mesh;
    private List`1<NavMeshBuildSource> sources;
    private AsyncOperation BuildingOperation;
    private bool HasBuildOperationStarted;
    private Stopwatch BuildTimer;
    private int defaultArea;
    private int agentTypeId;
    public bool IsBuilding { get; }
    public bool get_IsBuilding();
    private void OnEnable();
    private void OnDisable();
    [ContextMenu("Update Nav Mesh")]
public void UpdateNavMeshAsync();
    [IteratorStateMachineAttribute("DynamicNavMesh/<UpdateNavMeshAndWait>d__21")]
public IEnumerator UpdateNavMeshAndWait();
    private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources);
    public void FinishBuildingNavmesh();
}
public class DynamicPreventBuilding : BaseEntity {
}
public class DynamicZNear : MonoBehaviour {
    public float minimum;
    public float maximum;
}
public static class EAC : object {
}
public static class EACServer : object {
    private static AntiCheatServerInterface Interface;
    private static ReportsInterface Reports;
    private static ConcurrentDictionary`2<UInt32, Connection> client2connection;
    private static ConcurrentDictionary`2<Connection, UInt32> connection2client;
    private static ConcurrentDictionary`2<Connection, AntiCheatCommonClientAuthStatus> connection2status;
    private static UInt32 clientHandleCounter;
    private static bool CanEnableGameplayData { get; }
    private static bool CanSendAnalytics { get; }
    private static bool CanSendReports { get; }
    private static EACServer();
    private static bool get_CanEnableGameplayData();
    private static bool get_CanSendAnalytics();
    private static bool get_CanSendReports();
    private static IntPtr GenerateCompatibilityClient();
    public static void Encrypt(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
    public static void Decrypt(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
    private static IntPtr GetClient(Connection connection);
    private static Connection GetConnection(IntPtr client);
    public static bool IsAuthenticated(Connection connection);
    private static void OnAuthenticatedLocal(Connection connection);
    private static void OnAuthenticatedRemote(Connection connection);
    private static void OnVerifyIdToken(VerifyIdTokenCallbackInfo& data);
    private static void OnClientAuthStatusChanged(OnClientAuthStatusChangedCallbackInfo& data);
    private static void OnClientActionRequired(OnClientActionRequiredCallbackInfo& data);
    private static void SendToClient(OnMessageToClientCallbackInfo& data);
    public static void DoStartup();
    public static void DoUpdate();
    public static void DoShutdown();
    public static void OnLeaveGame(Connection connection);
    public static void OnJoinGame(Connection connection);
    public static void OnStartLoading(Connection connection);
    public static void OnFinishLoading(Connection connection);
    public static void OnMessageReceived(Message message);
    public static void LogPlayerUseWeapon(BasePlayer player, BaseProjectile weapon);
    public static void LogPlayerSpawn(BasePlayer player);
    public static void LogPlayerDespawn(BasePlayer player);
    public static void LogPlayerTakeDamage(BasePlayer player, HitInfo info);
    public static void LogPlayerTick(BasePlayer player);
    public static void LogPlayerRevive(BasePlayer source, BasePlayer target);
    public static void SendPlayerBehaviorReport(BasePlayer reporter, PlayerReportsCategory reportCategory, string reportedID, string reportText);
    public static void SendPlayerBehaviorReport(PlayerReportsCategory reportCategory, string reportedID, string reportText);
}
public class EasterBasket : AttackEntity {
    public GameObjectRef eggProjectile;
    public ItemDefinition ammoType;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction);
    public Item GetAmmo();
    public bool HasAmmo();
    public void UseAmmo();
    [RPC_Server]
[IsActiveItem]
public void ThrowEgg(RPCMessage msg);
}
public class Effect : EffectData {
    public Vector3 Up;
    public Vector3 worldPos;
    public Vector3 worldNrm;
    public bool attached;
    public Transform transform;
    public GameObject gameObject;
    public string pooledString;
    public bool broadcast;
    public List`1<Connection> targets;
    private static Effect reusableInstace;
    public Effect(string effectName, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection);
    public Effect(string effectName, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection);
    private static Effect();
    public void Init(Type fxtype, BaseEntity ent, UInt32 boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection);
    public void Init(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection);
    public void Clear();
}
public class EffectAudioPerspectiveSwitcher : MonoBehaviour {
    [HideInInspector]
public EffectParentToWeaponBone parentToWeaponComponent;
}
public class EffectBlood : EffectRecycle {
    public GameObjectRef ReplacementEffect;
}
public class EffectDictionary : object {
    private static Dictionary`2<string, String[]> effectDictionary;
    public static string GetParticle(string impactType, string materialName);
    public static string GetParticle(DamageType damageType, string materialName);
    public static string GetDecal(string impactType, string materialName);
    public static string GetDecal(DamageType damageType, string materialName);
    public static string GetDisplacement(string impactType, string materialName);
    private static string LookupEffect(string category, string effect, string material);
}
public static class EffectLibrary : object {
}
public class EffectMount : EntityComponent`1<BaseEntity> {
    public bool firstPerson;
    public GameObject effectPrefab;
    public GameObject spawnedEffect;
    public GameObject mountBone;
    public SoundDefinition onSoundDef;
    public SoundDefinition offSoundDef;
    public bool blockOffSoundWhenGettingDisabled;
}
public class EffectMuzzleFlash : MonoBehaviour {
}
public static class EffectNetwork : object {
    public static void Send(Effect effect);
    public static void Send(Effect effect, Connection target);
}
public class EffectParent : EntityComponent`1<BaseEntity> {
    public GameObject effect;
    [TooltipAttribute("If true the effect isn't our direct child and is in another hierarchy - USE WITH CAUTION")]
public bool separatedEffect;
}
public class EffectParentToWeaponBone : BaseMonoBehaviour {
    public string boneName;
    public bool singleFrame;
}
public class EffectRecycle : BaseMonoBehaviour {
    [ReadOnlyAttribute]
[FormerlySerializedAsAttribute("lifeTime")]
public float detachTime;
    [FormerlySerializedAsAttribute("lifeTime")]
[ReadOnlyAttribute]
public float recycleTime;
    public PlayMode playMode;
    public ParentDestroyBehaviour onParentDestroyed;
    [RangeAttribute("1", "50")]
public int WarmedUpAmount;
}
public class EffectRecycleDetach : BaseMonoBehaviour {
    public float recycleTime;
}
public class EffectRecycleLite : BasePrefab {
    private static float lifeTime;
}
public class EffectsBenchmarkScene : BenchmarkScene {
    public GameObjectRef[] effectPrefabs;
}
public class EffectScaleWithCameraDistance : MonoBehaviour {
    public float minScale;
    public float maxScale;
    public float scaleStartDistance;
    public float scaleEndDistance;
}
public class EggAmmoRepresentation : MonoBehaviour {
    public GameObject[] eggAmmo;
}
public class EggHuntEvent : BaseHuntEvent {
    public float warmupTime;
    public float warnTime;
    public float timeAlive;
    public static EggHuntEvent serverEvent;
    public static EggHuntEvent clientEvent;
    public static float durationSeconds;
    public Dictionary`2<ulong, EggHunter> _eggHunters;
    public ItemAmount[] placementAwards;
    private Dictionary`2<ulong, List`1<CollectableEasterEgg>> _spawnedEggs;
    private float eggSpawningFrameBudget;
    private int maxEggPerPlayer;
    private int initialSpawnIndex;
    private Stopwatch stopwatch;
    public static Phrase topBunnyPhrase;
    public static Phrase noPlayersPhrase;
    public static Phrase placePhrase;
    public static Phrase rewardPhrase;
    private static EggHuntEvent();
    public bool IsEventActive();
    public void Update();
    public virtual void DestroyShared();
    public virtual void ServerInit();
    private void StartEvent();
    private void EnableEggs();
    [ContextMenu("SpawnDebug")]
public void SpawnEggs();
    [IteratorStateMachineAttribute("EggHuntEvent/<SpawnInitialEggs>d__21")]
private IEnumerator SpawnInitialEggs();
    private CollectableEasterEgg SpawnEggAtPoint(Vector3 pos, bool active);
    private Vector3 GetRandomSpawnPoint(Vector3 pos, Vector3 aimDir, float minDist, float maxDist);
    public void OnEggCollected(BasePlayer player, CollectableEasterEgg collectedEgg);
    private void IncrementScore(BasePlayer player);
    private void QueueUpdate();
    private void DoNetworkUpdate();
    private List`1<CollectableEasterEgg> TryGetPlayerEggs(ulong userID);
    protected List`1<EggHunter> GetTopHunters();
    protected virtual Phrase GetTopBunnyPhrase();
    protected virtual Phrase GetNoPlayersPhrase();
    protected virtual Phrase GetPlacePhrase();
    protected virtual Phrase GetRewardPhrase();
    protected void PrintWinnersAndAward();
    protected virtual void ReportEggsCollected(int numEggs);
    protected virtual void ReportPlayerParticipated(int topCount);
    private void CleanupEggs();
    private void Cooldown();
    public virtual void Save(SaveInfo info);
}
public class EggHuntNote : MonoBehaviour {
    public CanvasGroup mainGroup;
    public CanvasGroup timerGroup;
    public RustText timerText;
    public static Phrase startsInPhrase;
    private static EggHuntNote();
}
public class EggSwap : MonoBehaviour {
    public Renderer[] eggRenderers;
    public void Show(int index);
    public void HideAll();
}
public class ElectricalBlocker : IOEntity {
    protected int input1Amount;
    protected int input2Amount;
    public virtual int ConsumptionAmount();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void UpdateBlocked();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
}
public class ElectricalBranch : IOEntity {
    public int branchAmount;
    public GameObjectRef branchPanelPrefab;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("5")]
public void RPC_SetBranchOffPower(RPCMessage msg);
    public void SetBranchOffPower(int power);
    public virtual bool AllowDrainFrom(int outputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ElectricalCombiner : IOEntity {
    public int input1Amount;
    public int input2Amount;
    public int input3Amount;
    public bool BlockFluidDraining { get; }
    public virtual bool IsRootEntity();
    public virtual int ConsumptionAmount();
    public virtual bool get_BlockFluidDraining();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int slot);
}
public class ElectricalDFlipFlop : IOEntity {
    private int setAmount;
    private int resetAmount;
    private int toggleAmount;
    public virtual int ConsumptionAmount();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public bool GetDesiredState();
    public void UpdateState();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateOutputs();
    public virtual bool AllowDrainFrom(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
}
public class ElectricalHeater : IOEntity {
    public float fadeDuration;
    public Light sourceLight;
    public GrowableHeatSource growableHeatSource;
    public virtual int ConsumptionAmount();
    public virtual void ResetState();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual void OnKilled(HitInfo info);
}
public class ElectricBattery : IOEntity {
    public int maxOutput;
    public float maxCapactiySeconds;
    public float rustWattSeconds;
    private int activeDrain;
    public bool rechargable;
    [TooltipAttribute("How much energy we can request from power sources for charging is this value * our maxOutput")]
public float maximumInboundEnergyRatio;
    public float chargeRatio;
    private static float tickRateSeconds;
    public static Flags Flag_HalfFull;
    public static Flags Flag_VeryFull;
    private bool wasLoaded;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ValueTuple`2<IOEntity, int>> connectedList;
    private Queue`1<int> inputHistory;
    private static int inputHistorySize;
    public virtual bool IsRootEntity();
    public virtual int ConsumptionAmount();
    public virtual int MaximalPowerOutput();
    public int GetActiveDrain();
    public sealed virtual void ReceiveInstanceData(InstanceData data);
    public virtual void PostServerLoad();
    public virtual void OnPickedUp(Item createdItem, BasePlayer player);
    public virtual int GetCurrentEnergy();
    public virtual int DesiredPower(int inputIndex);
    public virtual void SendAdditionalData(BasePlayer player, int slot, bool input);
    public virtual void ServerInit();
    public int GetDrainFor(IOEntity ent);
    public void AddConnectedRecursive(IOEntity root, int inputIndex, HashSet`1& listToUse);
    public int GetDrain();
    public virtual void OnCircuitChanged(bool forceUpdate);
    public void CheckDischarge();
    public void SetDischarging(bool wantsOn);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
    private int GetHighestInputFromHistory();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public void TickUsage();
    public virtual void ChargeChanged(float oldCharge);
    public void AddCharge();
    public void SetPassthroughOn(bool wantsOn);
    public void Unbusy();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    [ServerVar]
public static void batteryid(Arg arg);
}
public class ElectricFurnaceIO : IOEntity {
    public int PowerConsumption;
    public ItemContainer Container { get; }
    public BaseEntity IndustrialEntity { get; }
    public virtual int ConsumptionAmount();
    public virtual int DesiredPower(int inputIndex);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    private ElectricOven GetParentOven();
    public sealed virtual ItemContainer get_Container();
    public sealed virtual Vector2i InputSlotRange(int slotIndex);
    public sealed virtual Vector2i OutputSlotRange(int slotIndex);
    public sealed virtual void OnStorageItemTransferBegin();
    public sealed virtual void OnStorageItemTransferEnd();
    public sealed virtual BaseEntity get_IndustrialEntity();
}
public class ElectricGenerator : IOEntity {
    public float electricAmount;
    public virtual bool IsRootEntity();
    public virtual int MaximalPowerOutput();
    public virtual int ConsumptionAmount();
    public virtual int GetCurrentEnergy();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateOutputs();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void PostServerLoad();
    private void ForcePuzzleReset();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ElectricOven : BaseOven {
    public GameObjectRef IoEntity;
    public Transform IoEntityAnchor;
    public EntityRef`1<IOEntity> spawnedIo;
    public bool CanRunWithNoFuel { get; }
    public virtual void ServerInit();
    public void SpawnIOEnt();
    public virtual bool get_CanRunWithNoFuel();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void OvenFull();
    private void PauseCooking();
    public virtual void OnItemAddedOrRemoved(Item item, bool bAdded);
    protected virtual bool CanPickupOven();
}
public class ElectricSwitch : IOEntity {
    public bool isToggleSwitch;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool WantsPower(int inputIndex);
    public virtual int ConsumptionAmount();
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void ServerInit();
    public virtual void SetSwitch(bool state);
    public void Flip();
    [IsVisible("3")]
[RPC_Server]
public void RPC_Switch(RPCMessage msg);
    private void UnBusy();
}
public class ElectricWindmill : IOEntity {
    public Animator animator;
    public int maxPowerGeneration;
    public Transform vaneRot;
    public SoundDefinition wooshSound;
    public Transform wooshOrigin;
    public float targetSpeed;
    public float serverWindSpeed;
    public virtual int MaximalPowerOutput();
    public virtual bool IsRootEntity();
    public float GetWindSpeedScale();
    public virtual void Load(LoadInfo info);
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public bool AmIVisible();
    public void WindUpdate();
    public virtual int GetPassthroughAmount(int outputSlot);
    public Vector3 GetWindAimDir(float time);
}
public class Elevator : IOEntity {
    public Transform LiftRoot;
    public GameObjectRef LiftEntityPrefab;
    public GameObjectRef IoEntityPrefab;
    public Transform IoEntitySpawnPoint;
    public GameObject FloorBlockerVolume;
    public float LiftSpeedPerMetre;
    public GameObject[] PoweredObjects;
    public MeshRenderer PoweredMesh;
    [ColorUsageAttribute("True", "True")]
public Color PoweredLightColour;
    [ColorUsageAttribute("True", "True")]
public Color UnpoweredLightColour;
    public float LiftMoveDelay;
    [CompilerGeneratedAttribute]
private int <Floor>k__BackingField;
    protected static Flags TopFloorFlag;
    public static Flags ElevatorPowered;
    public EntityRef`1<ElevatorLift> liftEntity;
    public IOEntity ioEntity;
    public Int32[] previousPowerAmount;
    public bool IsStatic { get; }
    public int Floor { get; public set; }
    public bool IsTop { get; }
    public float FloorHeight { get; }
    public virtual bool get_IsStatic();
    [CompilerGeneratedAttribute]
public int get_Floor();
    [CompilerGeneratedAttribute]
public void set_Floor(int value);
    public bool get_IsTop();
    public virtual void Load(LoadInfo info);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void CallElevator();
    public void Server_RaiseLowerElevator(Direction dir, bool goTopBottom);
    public bool RequestMoveLiftTo(int targetFloor, Single& timeToTravel, Elevator fromElevator);
    protected virtual void OpenLiftDoors();
    public virtual void OnMoveBegin();
    public float TimeToTravelDistance(float distance);
    public virtual Vector3 GetWorldSpaceFloorPosition(int targetFloor);
    public virtual float get_FloorHeight();
    public virtual void ClearBusy();
    public virtual bool IsValidFloor(int targetFloor);
    public Elevator GetElevatorInDirection(Direction dir);
    public void UpdateChildEntities(bool isTop);
    public void FindExistingIOChild();
    public virtual void Save(SaveInfo info);
    public int LiftPositionToFloor();
    public virtual void DestroyShared();
    private void Cleanup();
    public virtual void PostServerLoad();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    private void OnPhysicsNeighbourChanged();
    public bool HasFloorSocketConnection();
    public void NotifyLiftEntityDoorsOpen(bool state);
    protected virtual void OpenDoorsAtFloor(int floor);
    internal virtual void DoServerDestroy();
    public virtual void OnKilled(HitInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public void FindExistingLiftChild();
    public sealed virtual void OnFlagToggled(bool state);
    [CompilerGeneratedAttribute]
private void <CallElevator>b__26_0(Elevator elevatorEnt);
}
public class ElevatorIOEntity : IOEntity {
    public int Consumption;
    public virtual int ConsumptionAmount();
}
public class ElevatorLift : BaseCombatEntity {
    public GameObject DescendingHurtTrigger;
    public GameObject MovementCollider;
    public Transform UpButtonPoint;
    public Transform DownButtonPoint;
    public TriggerNotify VehicleTrigger;
    public GameObjectRef LiftArrivalScreenBounce;
    public SoundDefinition liftMovementLoopDef;
    public SoundDefinition liftMovementStartDef;
    public SoundDefinition liftMovementStopDef;
    public SoundDefinition liftMovementAccentSoundDef;
    public GameObjectRef liftButtonPressedEffect;
    public float movementAccentMinInterval;
    public float movementAccentMaxInterval;
    private Sound liftMovementLoopSound;
    private float nextMovementAccent;
    public Vector3 lastPosition;
    public List`1<BaseEntity> vehicleWhitelist;
    private EntityRef`1<Elevator> ownerElevator;
    private static Flags PressedUp;
    private static Flags PressedDown;
    public static Flags FlagCanMove;
    private HashSet`1<UInt32> vehiclePrefabWhitelist;
    private Elevator owner { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private Elevator get_owner();
    public virtual void Load(LoadInfo info);
    public void SetOwnerElevator(Elevator e);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public void ToggleHurtTrigger(bool state);
    [RPC_Server]
[IsVisible("3")]
public void Server_RaiseLowerFloor(RPCMessage msg);
    private void FillVehicleWhitelist();
    private void ClearDirection();
    public virtual void Hurt(HitInfo info);
    public virtual void AdminKill();
    public virtual void PostServerLoad();
    public bool CanMove();
    public virtual void NotifyNewFloor(int newFloor, int totalFloors);
    private void ToggleMovementCollider(bool state);
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class ElevatorLiftPlayer : ElevatorLift {
    public Transform CableRoot;
    public Transform CableRootTop;
    public float CableRootOffset;
    public float CableRootTopOffset;
}
public class ElevatorLiftStatic : ElevatorLift {
    public GameObjectRef ElevatorDoorRef;
    public Transform ElevatorDoorLocation;
    public bool BlockPerFloorMovement;
    private static Flags CanGoUp;
    private static Flags CanGoDown;
    public virtual void ServerInit();
    public virtual void NotifyNewFloor(int newFloor, int totalFloors);
}
public class ElevatorStatic : Elevator {
    public bool StaticTop;
    public static Flags LiftRecentlyArrived;
    public List`1<ElevatorStatic> floorPositions;
    public ElevatorStatic ownerElevator;
    public bool IsStatic { get; }
    public virtual bool get_IsStatic();
    public virtual void Spawn();
    private void UpdateFloorPositions();
    public virtual void PostServerLoad();
    public virtual void PostMapEntitySpawn();
    public virtual bool IsValidFloor(int targetFloor);
    public virtual Vector3 GetWorldSpaceFloorPosition(int targetFloor);
    public void SetFloorDetails(int floor, ElevatorStatic owner);
    public virtual void CallElevator();
    public ElevatorStatic ElevatorAtFloor(int floor);
    protected virtual void OpenDoorsAtFloor(int floor);
    public virtual void OnMoveBegin();
    public void OnLiftLeavingFloor();
    public virtual void ClearBusy();
    protected virtual void OpenLiftDoors();
    public void OnLiftArrivedAtFloor();
    public void ClearPowerOutput();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void Load(LoadInfo info);
}
public class EmissionBlink : FacepunchBehaviour {
    public EmissionToggle emissionToggle;
    public float blinkDuration;
    public float blinkInterval;
}
public class EmissionOffsetStepped : MonoBehaviour {
    public Material material;
    public float offsetAmount;
    public float minInterval;
    public float maxInterval;
}
public class EmissionScaledByLight : MonoBehaviour {
    private Color emissionColor;
    public Renderer[] targetRenderers;
    public int materialIndex;
    private static MaterialPropertyBlock block;
    public Light lightToFollow;
    public float maxEmissionValue;
}
public class EmissionToggle : MonoBehaviour {
    private Color emissionColor;
    public Renderer[] targetRenderers;
    public int materialIndex;
}
public class EmojiAutocomplete : MonoBehaviour {
    public RectTransform Parent;
    public GameObjectRef EmojiPrefab;
    public RectTransform Selector;
}
public class EmojiController : ListComponent`1<EmojiController> {
    public Image Image;
    public RawImage VideoImage;
    public RectTransform rectTransform;
}
public class EmojiControllerGallery : EmojiController {
    public RustText NameText;
}
public class EmojiGallery : MonoBehaviour {
    public GameObjectRef EmojiPrefab;
    public Transform Parent;
    public RustEmojiLibrary Library;
    public GameObject HighlightRoot;
    public RustText HighlightText;
    public EmojiController SkinIndicator;
    public EmojiController[] SkinToneGallery;
    public RustEmojiConfig SkinDemoConfig;
    public GameObject SkinPickerRoot;
    public TmProEmojiInputField TargetInputField;
}
public class EmojiResult : ValueType {
    public Sprite Sprite;
    public VideoClip Video;
}
public class EncryptedValue`1 : ValueType {
    private TInner _value;
    private int _padding;
    public TInner Get();
    public void Set(TInner value);
    public virtual string ToString();
    public static EncryptedValue`1<TInner> op_Implicit(TInner value);
    public static TInner op_Implicit(EncryptedValue`1<TInner> encrypted);
}
public class EngineAudioClip : MonoBehaviour {
    public AudioClip granularClip;
    public AudioClip accelerationClip;
    public TextAsset accelerationCyclesJson;
    public List`1<EngineCycle> accelerationCycles;
    public List`1<EngineCycleBucket> cycleBuckets;
    public Dictionary`2<int, EngineCycleBucket> accelerationCyclesByRPM;
    public Dictionary`2<int, int> rpmBucketLookup;
    public int sampleRate;
    public int samplesUntilNextGrain;
    public int lastCycleId;
    public List`1<Grain> grains;
    public int currentRPM;
    public int targetRPM;
    public int minRPM;
    public int maxRPM;
    public int cyclePadding;
    [RangeAttribute("0", "1")]
public float RPMControl;
    public AudioSource source;
    public float rpmLerpSpeed;
    public float rpmLerpSpeedDown;
    private int GetBucketRPM(int RPM);
}
[CreateAssetMenuAttribute]
public class EngineAudioSet : ScriptableObject {
    public BlendedEngineLoopDefinition[] engineAudioLoops;
    public int priority;
    public float idleRpm;
    public float gearUpRpm;
    public float gearDownRpm;
    public int numGears;
    public float minRpm;
    public float maxRpm;
    public float gearUpRpmRate;
    public float gearDownRpmRate;
    public SoundDefinition badPerformanceLoop;
    public BlendedEngineLoopDefinition GetEngineLoopDef(int numEngines);
}
public class EngineDamageOverTime : object {
    private List`1<RecentDamage> recentDamage;
    private float maxSeconds;
    private float triggerDamage;
    private Action trigger;
    public EngineDamageOverTime(float triggerDamage, float maxSeconds, Action trigger);
    public void TakeDamage(float amount);
    private float GetRecentDamage();
}
public class EngineItemInformationPanel : ItemInformationPanel {
    [SerializeField]
private Text tier;
    [SerializeField]
private Phrase low;
    [SerializeField]
private Phrase medium;
    [SerializeField]
private Phrase high;
    [SerializeField]
private GameObject accelerationRoot;
    [SerializeField]
private GameObject topSpeedRoot;
    [SerializeField]
private GameObject fuelEconomyRoot;
}
public class EngineSwitch : BaseEntity {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[MaxDistance("3")]
public void StopEngine(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void StartEngine(RPCMessage msg);
}
public class EntityCollisionMessage : EntityComponent`1<BaseEntity> {
    private void OnCollisionEnter(Collision collision);
}
public class EntityComponent`1 : EntityComponentBase {
    public T _baseEntity;
    public T baseEntity { get; }
    public T get_baseEntity();
    protected void UpdateBaseEntity();
    public virtual BaseEntity GetBaseEntity();
}
public class EntityComponentBase : BaseMonoBehaviour {
    public virtual BaseEntity GetBaseEntity();
    public virtual void SaveComponent(SaveInfo info);
    public virtual void LoadComponent(LoadInfo info);
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class EntityDebug : EntityComponent`1<BaseEntity> {
    internal Stopwatch stopwatch;
    private void Update();
}
public class EntityFlag_Animator : EntityFlag_Toggle {
    public Animator TargetAnimator;
    public string ParamName;
    public AnimatorMode AnimationMode;
    public float FloatOnState;
    public float FloatOffState;
    public int IntegerOnState;
    public int IntegerOffState;
}
public class EntityFlag_TOD : EntityComponent`1<BaseEntity> {
    public Flags desiredFlag;
    public bool onAtNight;
    public void Start();
    public void Initialize();
    public bool WantsOn();
    private void DoTimeCheck();
}
public class EntityFlag_Toggle : EntityComponent`1<BaseEntity> {
    public bool runClientside;
    [TooltipAttribute("Server-side only works if the EntityFlag_Toggle is on the same GameObject as the Entity")]
public bool runServerside;
    public Flags flag;
    [TooltipAttribute("If multiple flags are defined in 'flag', should they all be set, or any?")]
[SerializeField]
private FlagCheck flagCheck;
    [TooltipAttribute("Specify any flags that must NOT be on for this toggle to be on")]
[SerializeField]
private Flags notFlag;
    [SerializeField]
private UnityEvent onFlagEnabled;
    [SerializeField]
private UnityEvent onFlagDisabled;
    internal bool hasRunOnce;
    internal bool lastToggleOn;
    protected void OnDisable();
    public void DoUpdate(BaseEntity entity);
    protected virtual void OnStateToggled(bool state);
    public sealed virtual void OnPostNetworkUpdate(BaseEntity entity);
    public sealed virtual void OnSendNetworkUpdate(BaseEntity entity);
    public sealed virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class EntityFlag_ToggleNotify : EntityFlag_Toggle {
    public bool UseEntityParent;
    protected virtual void OnStateToggled(bool state);
}
public class EntityFuelSystem : object {
    public bool isServer;
    private bool editorGiveFreeFuel;
    private UInt32 fuelStorageID;
    public EntityRef`1<StorageContainer> fuelStorageInstance;
    public float nextFuelCheckTime;
    public bool cachedHasFuel;
    public float pendingFuel;
    public EntityFuelSystem(bool isServer, GameObjectRef fuelStoragePrefab, List`1<BaseEntity> children, bool editorGiveFreeFuel);
    public sealed virtual bool HasValidInstance(bool isServer);
    public sealed virtual NetworkableId GetInstanceID();
    public sealed virtual void SetInstanceID(NetworkableId uid);
    public bool IsInFuelInteractionRange(BasePlayer player);
    public StorageContainer GetFuelContainer();
    public sealed virtual bool CheckNewChild(BaseEntity child);
    public Item GetFuelItem();
    public sealed virtual int GetFuelAmount();
    public sealed virtual float GetFuelFraction();
    public sealed virtual bool HasFuel(bool forceCheck);
    public sealed virtual int TryUseFuel(float seconds, float fuelUsedPerSecond);
    public sealed virtual void LootFuel(BasePlayer player);
    public sealed virtual void AddFuel(int amount);
    public sealed virtual void FillFuel();
    public sealed virtual int GetFuelCapacity();
}
public class EntityHUDRender : MonoBehaviour {
}
public class EntityItem_RotateWhenOn : EntityComponent`1<BaseEntity> {
    public State on;
    public State off;
    internal bool currentlyOn;
    internal bool stateInitialized;
    public Flags targetFlag;
}
public class EntityLink : object {
    public BaseEntity owner;
    public Socket_Base socket;
    public List`1<EntityLink> connections;
    public int capacity;
    public string name { get; }
    public string get_name();
    public void Setup(BaseEntity owner, Socket_Base socket);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public bool Contains(EntityLink entity);
    public void Add(EntityLink entity);
    public void Remove(EntityLink entity);
    public void Clear();
    public bool IsEmpty();
    public bool IsOccupied();
    public bool IsMale();
    public bool IsFemale();
    public bool CanConnect(EntityLink link);
}
[ExtensionAttribute]
public static class EntityLinkEx : object {
    [ExtensionAttribute]
public static void FreeLinks(List`1<EntityLink> links);
    [ExtensionAttribute]
public static void ClearLinks(List`1<EntityLink> links);
    [ExtensionAttribute]
public static void AddLinks(List`1<EntityLink> links, BaseEntity entity, Socket_Base[] sockets);
}
[CreateAssetMenuAttribute]
public class EntityListScriptableObject : ScriptableObject {
    [SerializeField]
public BaseEntity[] entities;
    public bool blockIfAny;
    public bool IsInList(UInt32 prefabId);
}
public class EntityPrivilege : SimplePrivilege {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[MaxDistance("3")]
private void AddSelfAuthorize(RPCMessage rpc);
    public void AddPlayer(BasePlayer player);
    [MaxDistance("3")]
[RPC_Server]
private void RemoveSelfAuthorize(RPCMessage rpc);
    [MaxDistance("3")]
[RPC_Server]
private void ClearList(RPCMessage rpc);
}
internal class EntityRealm : object {
}
public class EntityRef : ValueType {
    internal BaseEntity ent_cached;
    internal NetworkableId id_cached;
    public NetworkableId uid { get; public set; }
    public bool IsSet();
    public bool IsValid(bool serverside);
    public void Set(BaseEntity ent);
    public BaseEntity Get(bool serverside);
    public NetworkableId get_uid();
    public void set_uid(NetworkableId value);
}
public class EntityRef`1 : ValueType {
    private EntityRef entityRef;
    public bool IsSet { get; }
    public NetworkableId uid { get; public set; }
    public EntityRef`1(NetworkableId uid);
    public bool get_IsSet();
    public bool IsValid(bool serverside);
    public void Set(T entity);
    public T Get(bool serverside);
    public bool TryGet(bool serverside, T& entity);
    public NetworkableId get_uid();
    public void set_uid(NetworkableId value);
}
public class EntityTimedDestroy : EntityComponent`1<BaseEntity> {
    public float secondsTillDestroy;
    private void OnEnable();
    private void TimedDestroy();
}
[FlagsAttribute]
public enum EntityType : Enum {
    public int value__;
    public static EntityType Player;
    public static EntityType NPC;
    public static EntityType WorldItem;
    public static EntityType Corpse;
    public static EntityType TimedExplosive;
    public static EntityType Chair;
    public static EntityType BasePlayerNPC;
}
public class EnumListItemUI : MonoBehaviour {
    public object Value;
    public RustText TextValue;
    private EnumListUI list;
    public void Init(object value, string valueText, EnumListUI list);
    public void Clicked();
}
public class EnumListUI : MonoBehaviour {
    public Transform PrefabItem;
    public Transform Container;
    private Action`1<object> clickedAction;
    private CanvasScaler canvasScaler;
    private void Awake();
    public void Show(List`1<object> values, Action`1<object> clicked);
    public void ItemClicked(object value);
    public void Hide();
}
public class EnvironmentManager : SingletonComponent`1<EnvironmentManager> {
    public static EnvironmentType Get(OBB obb);
    public static EnvironmentType Get(Vector3 pos, List`1& list, float radius);
    public static EnvironmentType Get(Vector3 pos, float radius);
    public static bool Check(OBB obb, EnvironmentType type);
    public static bool Check(Vector3 pos, EnvironmentType type, float radius);
}
[FlagsAttribute]
public enum EnvironmentType : Enum {
    public int value__;
    public static EnvironmentType Underground;
    public static EnvironmentType Building;
    public static EnvironmentType Outdoor;
    public static EnvironmentType Elevator;
    public static EnvironmentType PlayerConstruction;
    public static EnvironmentType TrainTunnels;
    public static EnvironmentType UnderwaterLab;
    public static EnvironmentType Submarine;
    public static EnvironmentType BuildingDark;
    public static EnvironmentType BuildingVeryDark;
    public static EnvironmentType NoSunlight;
}
[ExecuteInEditMode]
public class EnvironmentVolume : MonoBehaviour {
    [InspectorFlagsAttribute]
public EnvironmentType Type;
    [InspectorFlagsAttribute]
public NetworkGroupType NetworkType;
    public Vector3 Center;
    public Vector3 Size;
    [CompilerGeneratedAttribute]
private Collider <trigger>k__BackingField;
    public Collider trigger { get; private set; }
    [CompilerGeneratedAttribute]
public Collider get_trigger();
    [CompilerGeneratedAttribute]
private void set_trigger(Collider value);
    protected virtual void Awake();
    protected void OnEnable();
    protected void OnDisable();
    public void UpdateTrigger();
}
[ExtensionAttribute]
public static class EnvironmentVolumeEx : object {
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumes(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type);
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumes(Transform transform, EnvironmentType type);
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumesInsideTerrain(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding);
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumesInsideTerrain(Transform transform, EnvironmentType type);
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumesOutsideTerrain(Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding);
    [ExtensionAttribute]
public static bool CheckEnvironmentVolumesOutsideTerrain(Transform transform, EnvironmentType type);
}
[CreateAssetMenuAttribute]
public class EnvironmentVolumeProperties : ScriptableObject {
}
[CreateAssetMenuAttribute]
public class EnvironmentVolumePropertiesCollection : ScriptableObject {
    public float TransitionSpeed;
    public LayerMask ReflectionMask;
    [HorizontalAttribute("1", "0")]
public EnvironmentMultiplier[] ReflectionMultipliers;
    public float DefaultReflectionMultiplier;
    [HorizontalAttribute("1", "0")]
public EnvironmentMultiplier[] AmbientMultipliers;
    public float DefaultAmbientMultiplier;
    public OceanParameters OceanOverrides;
}
public class EnvironmentVolumeTrigger : MonoBehaviour {
    [CompilerGeneratedAttribute]
private EnvironmentVolume <volume>k__BackingField;
    [HideInInspector]
public Vector3 Center;
    [HideInInspector]
public Vector3 Size;
    public EnvironmentVolume volume { get; private set; }
    [CompilerGeneratedAttribute]
public EnvironmentVolume get_volume();
    [CompilerGeneratedAttribute]
private void set_volume(EnvironmentVolume value);
    protected void Awake();
    protected virtual void OnVolumeTriggerUpdate();
}
public class EnvSync : PointEntity {
    private static float syncInterval;
    private static float syncIntervalInv;
    public virtual void ServerInit();
    private void UpdateNetwork();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ErrorText : MonoBehaviour {
    public TextMeshProUGUI text;
    public int maxLength;
    private Stopwatch stopwatch;
    public void OnEnable();
    public void OnDisable();
    internal void CaptureLog(string error, string stacktrace, LogType type);
    protected void Update();
}
public class ERVegetationStudio : ScriptableObject {
    public static bool VegetationStudio();
    public static bool VegetationStudioPro();
    public static void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter);
    public static void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter);
    public static void UpdateHeightmap(Bounds bounds);
    public static void RemoveVegetationMaskLine(GameObject go);
    public static void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise);
    public static void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise);
    public static void RemoveBiomeArea(GameObject go);
}
public class EventSchedule : BaseMonoBehaviour {
    [TooltipAttribute("The minimum amount of hours between events")]
public float minimumHoursBetween;
    [TooltipAttribute("The maximum amount of hours between events")]
public float maxmumHoursBetween;
    public static HashSet`1<EventSchedule> allEvents;
    public float hoursRemaining;
    public long lastRun;
    private static EventSchedule();
    [ServerVar]
public static void TriggerEvent(Arg arg);
    [ServerVar]
public static void KillAllEvents();
    public string GetName();
    private void OnEnable();
    private void OnDisable();
    public virtual void RunSchedule();
    private void Trigger();
    private void CountHours();
}
public class EventScheduleWipeOffset : EventSchedule {
    [ServerVar]
public static float hoursBeforeWipeRealtime;
    private static EventScheduleWipeOffset();
    public virtual void RunSchedule();
}
public class ExcavatorArm : BaseEntity {
    public float yaw1;
    public float yaw2;
    public Transform wheel;
    public float wheelSpeed;
    public float turnSpeed;
    public Transform miningOffset;
    public GameObjectRef bounceEffect;
    public LightGroupAtTime lights;
    public Material conveyorMaterial;
    public float beltSpeedMax;
    public static Flags Flag_HasPower;
    public List`1<ExcavatorOutputPile> outputPiles;
    public SoundDefinition miningStartButtonSoundDef;
    [HeaderAttribute("Production")]
public ItemAmount[] resourcesToMine;
    public float resourceProductionTickRate;
    public float timeForFullResources;
    public ItemAmount[] pendingResources;
    public Phrase excavatorPhrase;
    public float movedAmount;
    public float currentTurnThrottle;
    public float lastMoveYaw;
    private float excavatorStartTime;
    private float nextNotificationTime;
    public int resourceMiningIndex;
    protected float PositionTickRate { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsPowered();
    public bool IsMining();
    protected virtual float get_PositionTickRate();
    public virtual float GetNetworkTime();
    public void FixedUpdate();
    public void BeginMining();
    public void StopMining();
    public void ProduceResources();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_SetResourceTarget(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_StopMining(RPCMessage msg);
    public virtual void Spawn();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void PostMapEntitySpawn();
    public void Init();
}
public class ExcavatorEffects : MonoBehaviour {
    public static ExcavatorEffects instance;
    public ParticleSystemContainer[] miningParticles;
    public SoundPlayer[] miningSounds;
    public SoundFollowCollider[] beltSounds;
    public SoundPlayer[] miningStartSounds;
    public GameObject[] ambientMetalRattles;
    public bool wasMining;
}
public class ExcavatorEngineSounds : MonoBehaviour {
    public SoundPlayer[] engineStartClunks;
    public void PlayStartClunks();
}
public class ExcavatorOutputPile : StorageContainer {
}
public class ExcavatorServerEffects : MonoBehaviour {
    public static ExcavatorServerEffects instance;
    public TriggerBase[] miningTriggers;
    public void Awake();
    public void OnDestroy();
    public static void SetMining(bool isMining, bool force);
}
public class ExcavatorSignalComputer : BaseCombatEntity {
    public float chargePower;
    public static Flags Flag_Ready;
    public static Flags Flag_HasPower;
    public GameObjectRef supplyPlanePrefab;
    public Transform[] dropPoints;
    public Text statusText;
    public Text timerText;
    public static Phrase readyphrase;
    public static Phrase chargephrase;
    [ServerVar]
public static float chargeNeededForSupplies;
    private float lastChargeTime;
    private static ExcavatorSignalComputer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public void ChargeThink();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    [IsVisible("3")]
[CallsPerSecond("5")]
[RPC_Server]
public void RequestSupplies(RPCMessage rpc);
    public bool IsPowered();
    public virtual void Load(LoadInfo info);
}
public class ExcavatorYawSounds : MonoBehaviour {
    public SoundPlayer[] miningStartClunks;
    public void PlayStartClunks();
}
public class ExecComponent : MonoBehaviour {
    public string ExecToRun;
    public void Run();
}
public class ExpandedLifeStats : MonoBehaviour {
    public GameObject DisplayRoot;
    public GameObjectRef GenericStatRow;
    [HeaderAttribute("Resources")]
public Transform ResourcesStatRoot;
    public List`1<GenericStatDisplay> ResourceStats;
    [HeaderAttribute("Weapons")]
public GameObjectRef WeaponStatRow;
    public Transform WeaponsRoot;
    [HeaderAttribute("Misc")]
public Transform MiscRoot;
    public List`1<GenericStatDisplay> MiscStats;
    public LifeInfographic Infographic;
    public RectTransform MoveRoot;
    public Vector2 OpenPosition;
    public Vector2 ClosedPosition;
    public GameObject OpenButtonRoot;
    public GameObject CloseButtonRoot;
    public GameObject ScrollGradient;
    public ScrollRect Scroller;
}
[ImageEffectAllowedInSceneView]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Camera")]
public class Explosion_Bloom : MonoBehaviour {
    [SerializeField]
public Settings settings;
    [SerializeField]
[HideInInspector]
private Shader m_Shader;
    private Material m_Material;
    private static int kMaxIterations;
    private RenderTexture[] m_blurBuffer1;
    private RenderTexture[] m_blurBuffer2;
    private int m_Threshold;
    private int m_Curve;
    private int m_PrefilterOffs;
    private int m_SampleScale;
    private int m_Intensity;
    private int m_BaseTex;
    public Shader shader { get; }
    public Material material { get; }
    public static bool supportsDX11 { get; }
    public Shader get_shader();
    public Material get_material();
    public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect);
    public static Material CheckShaderAndCreateMaterial(Shader s);
    public static bool get_supportsDX11();
    private void Awake();
    private void OnEnable();
    private void OnDisable();
    private void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class ExplosionDemoGUI : MonoBehaviour {
    public GameObject[] Prefabs;
    public float reactivateTime;
    public Light Sun;
    private int currentNomber;
    private GameObject currentInstance;
    private GUIStyle guiStyleHeader;
    private float sunIntensity;
    private float dpiScale;
    private void Start();
    private void OnGUI();
    private void ChangeCurrent(int delta);
}
public class ExplosionDemoReactivator : MonoBehaviour {
    public float TimeDelayToReactivate;
    private void Start();
    private void Reactivate();
}
public class ExplosionPlatformActivator : MonoBehaviour {
    public GameObject Effect;
    public float TimeDelay;
    public float DefaultRepeatTime;
    public float NearRepeatTime;
    private float currentTime;
    private float currentRepeatTime;
    private bool canUpdate;
    private void Start();
    private void Init();
    private void Update();
    private void OnTriggerEnter(Collider coll);
    private void OnTriggerExit(Collider other);
}
public class ExplosionsBillboard : MonoBehaviour {
    public Camera Camera;
    public bool Active;
    public bool AutoInitCamera;
    private GameObject myContainer;
    private Transform t;
    private Transform camT;
    private Transform contT;
    private void Awake();
    private void Update();
}
public class ExplosionScreenBounceFade : ScreenBounceFade {
    [FormerlySerializedAsAttribute("explosionVolumeWeight")]
public AnimationCurve volumeWeight;
}
public class ExplosionsDeactivateRendererByTime : MonoBehaviour {
    public float TimeDelay;
    private Renderer rend;
    private void Awake();
    private void DeactivateRenderer();
    private void OnEnable();
}
public class ExplosionsFPS : MonoBehaviour {
    private GUIStyle guiStyleHeader;
    private float timeleft;
    private float fps;
    private int frames;
    private void Awake();
    private void OnGUI();
    private void Update();
}
public class ExplosionsLightCurves : MonoBehaviour {
    public AnimationCurve LightCurve;
    public float GraphTimeMultiplier;
    public float GraphIntensityMultiplier;
    private bool canUpdate;
    private float startTime;
    private Light lightSource;
    private void Awake();
    private void OnEnable();
    private void Update();
}
public class ExplosionsOverlay : MonoBehaviour {
    public static ExplosionsOverlay Instance;
    public PostProcessVolume postProcessVolume;
    public AnimationCurve radialBlurStartCurve;
    public AnimationCurve radialBlurAmountCurve;
    public AnimationCurve lensDirtinessCurve;
}
[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour {
    public float particlesScale;
    private void Start();
    private void Update();
}
public class ExplosionsScaleCurves : MonoBehaviour {
    public AnimationCurve ScaleCurveX;
    public AnimationCurve ScaleCurveY;
    public AnimationCurve ScaleCurveZ;
    public Vector3 GraphTimeMultiplier;
    public Vector3 GraphScaleMultiplier;
    private float startTime;
    private Transform t;
    private float evalX;
    private float evalY;
    private float evalZ;
    private void Awake();
    private void OnEnable();
    private void Update();
}
public class ExplosionsShaderColorGradient : MonoBehaviour {
    public string ShaderProperty;
    public int MaterialID;
    public Gradient Color;
    public float TimeMultiplier;
    private bool canUpdate;
    private Material matInstance;
    private int propertyID;
    private float startTime;
    private Color oldColor;
    private void Start();
    private void OnEnable();
    private void Update();
}
public class ExplosionsShaderFloatCurves : MonoBehaviour {
    public string ShaderProperty;
    public int MaterialID;
    public AnimationCurve FloatPropertyCurve;
    public float GraphTimeMultiplier;
    public float GraphScaleMultiplier;
    private bool canUpdate;
    private Material matInstance;
    private int propertyID;
    private float startTime;
    private void Start();
    private void OnEnable();
    private void Update();
}
public class ExplosionsShaderQueue : MonoBehaviour {
    public int AddQueue;
    private Renderer rend;
    private void Start();
    private void SetProjectorQueue();
    private void OnDisable();
}
internal class ExplosionsSpriteSheetAnimation : MonoBehaviour {
    public int TilesX;
    public int TilesY;
    public float AnimationFPS;
    public bool IsInterpolateFrames;
    public int StartFrameOffset;
    public bool IsLoop;
    public float StartDelay;
    public AnimationCurve FrameOverTime;
    private bool isInizialised;
    private int index;
    private int count;
    private int allCount;
    private float animationLifeTime;
    private bool isVisible;
    private bool isCorutineStarted;
    private Renderer currentRenderer;
    private Material instanceMaterial;
    private float currentInterpolatedTime;
    private float animationStartTime;
    private bool animationStoped;
    private void Start();
    private void InitDefaultVariables();
    private void Play();
    private void PlayDelay();
    private void OnEnable();
    private void OnDisable();
    [IteratorStateMachineAttribute("ExplosionsSpriteSheetAnimation/<UpdateCorutine>d__26")]
private IEnumerator UpdateCorutine();
    private void UpdateFrame();
    private void Update();
    private void OnDestroy();
}
public class ExplosiveInformationPanel : ItemInformationPanel {
    public ItemTextValue explosiveDmgDisplay;
    public ItemTextValue lethalDmgDisplay;
    public ItemTextValue throwDistanceDisplay;
    public ItemTextValue projectileDistanceDisplay;
    public ItemTextValue fuseLengthDisplay;
    public ItemTextValue blastRadiusDisplay;
    public Text unreliableText;
}
public class ExtendGBufferParams : ValueType {
    public bool enabled;
    public static ExtendGBufferParams Default;
    private static ExtendGBufferParams();
}
public class EyeBlink : MonoBehaviour {
    public Transform LeftEye;
    public Transform LeftEyelid;
    public Vector3 LeftEyeOffset;
    public Transform RightEye;
    public Transform RightEyelid;
    public Vector3 RightEyeOffset;
    public Vector3 ClosedEyelidPosition;
    public Vector3 ClosedEyelidRotation;
    public Vector2 TimeWithoutBlinking;
    public float BlinkSpeed;
    public Vector3 LeftEyeInitial;
    public Vector3 RightEyeInitial;
}
public class EyeController : MonoBehaviour {
    public static float MaxLookDot;
    public bool debug;
    public Transform LeftEye;
    public Transform RightEye;
    public Transform EyeTransform;
    public Vector3 Fudge;
    public Vector3 FlickerRange;
    private Transform Focus;
    private float FocusUpdateTime;
}
[RequireComponent("HitboxSystem")]
public class EZSoftBoneHitboxSystemCollider : EZSoftBoneColliderBase {
    public float radius;
    public virtual void Collide(Vector3& position, float spacing);
}
public class F15 : BaseCombatEntity {
    public float speed;
    public float defaultAltitude;
    public float altitude;
    public float altitudeLerpSpeed;
    public float turnRate;
    public float flybySoundLengthUntilMax;
    public SoundPlayer flybySound;
    public GameObject body;
    public float rollSpeed;
    public Vector3 movePosition;
    public GameObjectRef missilePrefab;
    private float nextMissileTime;
    private float blockTurningFor;
    private bool isRetiring;
    private CH47PathFinder pathFinder;
    private float turnSeconds;
    protected float PositionTickRate { get; }
    protected bool PositionTickFixedTime { get; }
    protected virtual float get_PositionTickRate();
    protected virtual bool get_PositionTickFixedTime();
    public virtual float GetNetworkTime();
    public float GetDesiredAltitude();
    public virtual void ServerInit();
    public void RetireToSunset();
    public void PickNewPatrolPoint();
    private void FixedUpdate();
    public void DelayedDestroy();
}
public class Facepunch.CardGames.BlackjackController : CardGameController {
    public List`1<PlayingCard> dealerCards;
    public static float BLACKJACK_PAYOUT_RATIO;
    public static float INSURANCE_PAYOUT_RATIO;
    private static float DEALER_MOVE_TIME;
    [CompilerGeneratedAttribute]
private BlackjackInputOption <LastAction>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastActionTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastActionValue>k__BackingField;
    private static int NUM_DECKS;
    private StackOfCards cardStack;
    public int MinPlayers { get; }
    public int MinBuyIn { get; }
    public int MaxBuyIn { get; }
    public int MinToPlay { get; }
    public int EndRoundDelay { get; }
    public int TimeBetweenRounds { get; }
    public BlackjackInputOption LastAction { get; private set; }
    public ulong LastActionTarget { get; private set; }
    public int LastActionValue { get; private set; }
    public bool AllBetsPlaced { get; }
    public BlackjackController(BaseCardGameEntity owner);
    public virtual int get_MinPlayers();
    public virtual int get_MinBuyIn();
    public virtual int get_MaxBuyIn();
    public virtual int get_MinToPlay();
    public virtual int get_EndRoundDelay();
    public virtual int get_TimeBetweenRounds();
    [CompilerGeneratedAttribute]
public BlackjackInputOption get_LastAction();
    [CompilerGeneratedAttribute]
private void set_LastAction(BlackjackInputOption value);
    [CompilerGeneratedAttribute]
public ulong get_LastActionTarget();
    [CompilerGeneratedAttribute]
private void set_LastActionTarget(ulong value);
    [CompilerGeneratedAttribute]
public int get_LastActionValue();
    [CompilerGeneratedAttribute]
private void set_LastActionValue(int value);
    public bool get_AllBetsPlaced();
    protected virtual int GetFirstPlayerRelIndex(bool startOfRound);
    public virtual List`1<PlayingCard> GetTableCards();
    public void InputsToList(int availableInputs, List`1<BlackjackInputOption> result);
    public bool WaitingForOtherPlayers(CardPlayerData pData);
    public int GetCardsValue(List`1<PlayingCard> cards, CardsValueMode mode);
    public int GetOptimalCardsValue(List`1<PlayingCard> cards);
    public int GetCardValue(PlayingCard card, CardsValueMode mode);
    public bool Has21(List`1<PlayingCard> cards);
    public bool HasBlackjack(List`1<PlayingCard> cards);
    public bool HasBusted(List`1<PlayingCard> cards);
    private bool CanSplit(CardPlayerDataBlackjack pData);
    private bool HasAnyAces(List`1<PlayingCard> cards);
    private bool CanDoubleDown(CardPlayerDataBlackjack pData);
    private bool CanTakeInsurance(CardPlayerDataBlackjack pData);
    private bool HasSplit(CardPlayerDataBlackjack pData);
    protected virtual CardPlayerData GetNewCardPlayerData(int mountIndex);
    public bool TryGetCardPlayerDataBlackjack(int index, CardPlayerDataBlackjack& cpBlackjack);
    public int ResultsToInt(BlackjackRoundResult mainResult, BlackjackRoundResult splitResult, int insurancePayout);
    public void ResultsFromInt(int result, BlackjackRoundResult& mainResult, BlackjackRoundResult& splitResult, Int32& insurancePayout);
    public virtual void Save(CardGame syncData);
    private void EditorMakeRandomMove(CardPlayerDataBlackjack pdBlackjack);
    protected virtual int GetAvailableInputsForPlayer(CardPlayerData pData);
    protected virtual void SubEndGameplay();
    protected virtual void SubEndRound();
    private int PayOut(CardPlayerData pData, int winnings);
    protected virtual void HandlePlayerLeavingTable(CardPlayerData pData);
    protected virtual void SubReceivedInputFromPlayer(CardPlayerData pData, int input, int value, bool countAsAction);
    private void DoInRoundPlayerInput(CardPlayerDataBlackjack pdBlackjack, BlackjackInputOption& selectedMove, Int32& selectedMoveValue);
    private void DoBettingPhasePlayerInput(CardPlayerDataBlackjack pdBlackjack, int value, bool countAsAction, BlackjackInputOption& selectedMove, Int32& selectedMoveValue);
    private int TryMakeBet(CardPlayerDataBlackjack pdBlackjack, int maxAmount, BetType betType);
    protected virtual void SubStartRound();
    protected virtual void OnTurnTimeout(CardPlayerData pData);
    protected virtual void StartNextCycle();
    protected virtual bool ShouldEndCycle();
    protected virtual void EndCycle();
    private void DealerPlayInvoke();
    private void DealInitialCards();
    private void ClearLastAction();
    [CompilerGeneratedAttribute]
private BlackjackRoundResult <SubEndRound>g__CheckResult|59_0(List`1<PlayingCard> cards, int betAmount, Int32& winnings, <>c__DisplayClass59_0& );
}
public abstract class Facepunch.CardGames.CardGameController : object {
    [CompilerGeneratedAttribute]
private CardGameState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private CardPlayerData[] <PlayerData>k__BackingField;
    public static int IDLE_KICK_SECONDS;
    [CompilerGeneratedAttribute]
private BaseCardGameEntity <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private RoundResults <resultInfo>k__BackingField;
    public CardList localPlayerCards;
    protected int activePlayerIndex;
    public static int STD_RAISE_INCREMENTS;
    protected bool isWaitingBetweenTurns;
    public CardGameState State { get; public set; }
    public bool HasGameInProgress { get; }
    public bool HasRoundInProgressOrEnding { get; }
    public bool HasActiveRound { get; }
    public CardPlayerData[] PlayerData { get; private set; }
    public int MinPlayers { get; }
    public int MinBuyIn { get; }
    public int MaxBuyIn { get; }
    public int MinToPlay { get; }
    public float MaxTurnTime { get; }
    public int EndRoundDelay { get; }
    public int TimeBetweenRounds { get; }
    protected float TimeBetweenTurns { get; }
    public BaseCardGameEntity Owner { get; public set; }
    public int ScrapItemID { get; }
    protected bool IsServer { get; }
    protected bool IsClient { get; }
    public RoundResults resultInfo { get; private set; }
    public CardGameController(BaseCardGameEntity owner);
    [CompilerGeneratedAttribute]
public CardGameState get_State();
    [CompilerGeneratedAttribute]
public void set_State(CardGameState value);
    public bool get_HasGameInProgress();
    public bool get_HasRoundInProgressOrEnding();
    public bool get_HasActiveRound();
    [CompilerGeneratedAttribute]
public CardPlayerData[] get_PlayerData();
    [CompilerGeneratedAttribute]
private void set_PlayerData(CardPlayerData[] value);
    public abstract virtual int get_MinPlayers();
    public abstract virtual int get_MinBuyIn();
    public abstract virtual int get_MaxBuyIn();
    public abstract virtual int get_MinToPlay();
    public virtual float get_MaxTurnTime();
    public virtual int get_EndRoundDelay();
    public virtual int get_TimeBetweenRounds();
    protected virtual float get_TimeBetweenTurns();
    [CompilerGeneratedAttribute]
public BaseCardGameEntity get_Owner();
    [CompilerGeneratedAttribute]
public void set_Owner(BaseCardGameEntity value);
    public int get_ScrapItemID();
    protected bool get_IsServer();
    protected bool get_IsClient();
    [CompilerGeneratedAttribute]
public RoundResults get_resultInfo();
    [CompilerGeneratedAttribute]
private void set_resultInfo(RoundResults value);
    [IteratorStateMachineAttribute("Facepunch.CardGames.CardGameController/<PlayersInRound>d__51")]
public IEnumerable`1<CardPlayerData> PlayersInRound();
    protected abstract virtual int GetFirstPlayerRelIndex(bool startOfRound);
    public sealed virtual void Dispose();
    public int NumPlayersAllowedToPlay(CardPlayerData ignore);
    public Playability GetPlayabilityStatus(CardPlayerData cpd);
    public bool TryGetActivePlayer(CardPlayerData& activePlayer);
    protected bool ToCardPlayerData(int relIndex, bool includeOutOfRound, CardPlayerData& result);
    public int RelToAbsIndex(int relIndex, bool includeFolded);
    public int GameToRoundIndex(int gameRelIndex);
    public int NumPlayersInGame();
    public int NumPlayersInCurrentRound();
    public int MaxPlayersAtTable();
    public bool PlayerIsInGame(BasePlayer player);
    public bool IsAtTable(BasePlayer player);
    public virtual List`1<PlayingCard> GetTableCards();
    public void StartTurnTimer(CardPlayerData pData, float turnTime);
    public bool IsAtTable(ulong userID);
    public int GetScrapInPot();
    public bool TryGetCardPlayerData(int index, CardPlayerData& cardPlayer);
    public bool TryGetCardPlayerData(ulong forPlayer, CardPlayerData& cardPlayer);
    public bool TryGetCardPlayerData(BasePlayer forPlayer, CardPlayerData& cardPlayer);
    public bool IsAllowedToPlay(CardPlayerData cpd);
    protected void ClearResultsInfo();
    protected abstract virtual CardPlayerData GetNewCardPlayerData(int mountIndex);
    protected abstract virtual void OnTurnTimeout(CardPlayerData playerData);
    protected abstract virtual void SubStartRound();
    protected abstract virtual void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction);
    protected abstract virtual int GetAvailableInputsForPlayer(CardPlayerData playerData);
    protected abstract virtual void HandlePlayerLeavingTable(CardPlayerData pData);
    protected abstract virtual void SubEndRound();
    protected abstract virtual void SubEndGameplay();
    protected abstract virtual void EndCycle();
    protected abstract virtual bool ShouldEndCycle();
    public void EditorMakeRandomMove();
    public void JoinTable(BasePlayer player);
    protected void SyncAllLocalPlayerCards();
    protected void SyncLocalPlayerCards(CardPlayerData pData);
    public void JoinTable(ulong userID);
    public void LeaveTable(ulong userID);
    public void LeaveTable(CardPlayerData pData);
    protected int TryAddBet(CardPlayerData playerData, int maxAmount);
    protected int GoAllIn(CardPlayerData playerData);
    protected int TryMoveToPotStorage(CardPlayerData playerData, int maxAmount);
    protected int PayOutFromPot(CardPlayerData playerData, int maxAmount);
    protected int PayOutAllFromPot(CardPlayerData playerData);
    protected void ClearPot();
    public int RemoveScrapFromStorage(CardPlayerData data);
    public virtual void Save(CardGame syncData);
    public void InvokeStartNewRound();
    public bool TryStartNewRound();
    protected void BeginRoundEnd();
    protected void EndRoundWithDelay();
    public void EndRound();
    protected virtual void AddRoundResult(CardPlayerData pData, int winnings, int resultCode);
    protected void EndGameplay();
    public void ReceivedInputFromPlayer(BasePlayer player, int input, bool countAsAction, int value);
    public void ReceivedInputFromPlayer(CardPlayerData pData, int input, bool countAsAction, int value, bool playerInitiated);
    public void UpdateAllAvailableInputs();
    public void PlayerStorageChanged();
    public void ServerPlaySound(SoundType type);
    public void GetConnectionsInGame(List`1<Connection> connections);
    public virtual void OnTableDestroyed();
    protected bool TryMoveToNextPlayerWithInputs(int startIndex, CardPlayerData& newActivePlayer);
    protected virtual void StartNextCycle();
    protected void QueueNextCycleInvoke();
    private void CancelNextCycleInvoke();
}
public class Facepunch.CardGames.CardPlayerData : object {
    [CompilerGeneratedAttribute]
private ulong <UserID>k__BackingField;
    public List`1<PlayingCard> Cards;
    [CompilerGeneratedAttribute]
private CardPlayerState <State>k__BackingField;
    public int mountIndex;
    private bool isServer;
    public int availableInputs;
    public int betThisRound;
    public int betThisTurn;
    [CompilerGeneratedAttribute]
private bool <LeftRoundEarly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendCardDetails>k__BackingField;
    public int finalScore;
    [CompilerGeneratedAttribute]
private bool <hasCompletedTurn>k__BackingField;
    public float lastActionTime;
    public int remainingToPayOut;
    private Func`2<int, StorageContainer> getStorage;
    public int scrapItemID;
    private Action`1<CardPlayerData> turnTimerCallback;
    public ulong UserID { get; public set; }
    public CardPlayerState State { get; public set; }
    public bool HasUser { get; }
    public bool HasUserInGame { get; }
    public bool HasUserInCurrentRound { get; }
    public bool HasAvailableInputs { get; }
    public bool AllCardsAreKnown { get; }
    private bool IsClient { get; }
    public bool LeftRoundEarly { get; public set; }
    public bool SendCardDetails { get; public set; }
    public bool hasCompletedTurn { get; private set; }
    public CardPlayerData(int mountIndex, bool isServer);
    public CardPlayerData(int scrapItemID, Func`2<int, StorageContainer> getStorage, int mountIndex, bool isServer);
    [CompilerGeneratedAttribute]
public ulong get_UserID();
    [CompilerGeneratedAttribute]
public void set_UserID(ulong value);
    [CompilerGeneratedAttribute]
public CardPlayerState get_State();
    [CompilerGeneratedAttribute]
public void set_State(CardPlayerState value);
    public bool get_HasUser();
    public bool get_HasUserInGame();
    public bool get_HasUserInCurrentRound();
    public bool get_HasAvailableInputs();
    public bool get_AllCardsAreKnown();
    private bool get_IsClient();
    [CompilerGeneratedAttribute]
public bool get_LeftRoundEarly();
    [CompilerGeneratedAttribute]
public void set_LeftRoundEarly(bool value);
    [CompilerGeneratedAttribute]
public bool get_SendCardDetails();
    [CompilerGeneratedAttribute]
public void set_SendCardDetails(bool value);
    public virtual void Dispose();
    public int GetScrapAmount();
    public virtual int GetTotalBetThisRound();
    public virtual List`1<PlayingCard> GetMainCards();
    public virtual List`1<PlayingCard> GetSecondaryCards();
    [CompilerGeneratedAttribute]
public bool get_hasCompletedTurn();
    [CompilerGeneratedAttribute]
private void set_hasCompletedTurn(bool value);
    public void SetHasCompletedTurn(bool hasActed);
    public bool HasBeenIdleFor(int seconds);
    public StorageContainer GetStorage();
    public void AddUser(ulong userID);
    public void ClearAllData();
    public void JoinRound();
    protected virtual void ClearPerRoundData();
    public virtual void LeaveCurrentRound(bool clearBets, bool leftRoundEarly);
    public virtual void LeaveGame();
    public void EnableSendingCards();
    public string HandToString();
    public static string HandToString(List`1<PlayingCard> cards);
    public virtual void Save(CardGame syncData);
    public void StartTurnTimer(Action`1<CardPlayerData> callback, float maxTurnTime);
    public void CancelTurnTimer();
    public void TimeoutTurn();
}
public class Facepunch.CardGames.CardPlayerDataBlackjack : CardPlayerData {
    public List`1<PlayingCard> SplitCards;
    public int splitBetThisRound;
    public int insuranceBetThisRound;
    public bool playingSplitCards;
    public CardPlayerDataBlackjack(int mountIndex, bool isServer);
    public CardPlayerDataBlackjack(int scrapItemID, Func`2<int, StorageContainer> getStorage, int mountIndex, bool isServer);
    public virtual void Dispose();
    public virtual int GetTotalBetThisRound();
    public virtual List`1<PlayingCard> GetSecondaryCards();
    protected virtual void ClearPerRoundData();
    public virtual void LeaveCurrentRound(bool clearBets, bool leftRoundEarly);
    public virtual void LeaveGame();
    public virtual void Save(CardGame syncData);
    public bool TrySwitchToSplitHand();
    private void SwapSplitCardsWithMain();
}
public class Facepunch.CardGames.PlayingCard : object {
    public bool IsUnknownCard;
    public Suit Suit;
    public Rank Rank;
    public static PlayingCard[] cards;
    public static PlayingCard unknownCard;
    private PlayingCard(Suit suit, Rank rank);
    private static PlayingCard();
    public static PlayingCard GetCard(Suit suit, Rank rank);
    public static PlayingCard GetCard(int suit, int rank);
    public static PlayingCard GetCard(int index);
    public int GetIndex();
    public static int GetIndex(Suit suit, Rank rank);
    public int GetPokerEvaluationValue();
    private int GetPokerSuitCode();
    private static PlayingCard[] GenerateAllCards();
}
public enum Facepunch.CardGames.Rank : Enum {
    public int value__;
    public static Rank Two;
    public static Rank Three;
    public static Rank Four;
    public static Rank Five;
    public static Rank Six;
    public static Rank Seven;
    public static Rank Eight;
    public static Rank Nine;
    public static Rank Ten;
    public static Rank Jack;
    public static Rank Queen;
    public static Rank King;
    public static Rank Ace;
}
public class Facepunch.CardGames.StackOfCards : object {
    private List`1<PlayingCard> cards;
    public StackOfCards(int numDecks);
    public bool TryTakeCard(PlayingCard& card);
    public void AddCard(PlayingCard card);
    public void ShuffleDeck();
    public void Print();
}
public enum Facepunch.CardGames.Suit : Enum {
    public int value__;
    public static Suit Spades;
    public static Suit Hearts;
    public static Suit Diamonds;
    public static Suit Clubs;
}
public class Facepunch.CardGames.TexasHoldEmController : CardGameController {
    public List`1<PlayingCard> communityCards;
    public static int SMALL_BLIND;
    public static int BIG_BLIND;
    public static string WON_HAND_STAT;
    [CompilerGeneratedAttribute]
private PokerInputOption <LastAction>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastActionTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastActionValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BiggestRaiseThisTurn>k__BackingField;
    private int dealerIndex;
    private StackOfCards deck;
    public int MinPlayers { get; }
    public int MinBuyIn { get; }
    public int MaxBuyIn { get; }
    public int MinToPlay { get; }
    public PokerInputOption LastAction { get; private set; }
    public ulong LastActionTarget { get; private set; }
    public int LastActionValue { get; private set; }
    public int BiggestRaiseThisTurn { get; private set; }
    public TexasHoldEmController(BaseCardGameEntity owner);
    public virtual int get_MinPlayers();
    public virtual int get_MinBuyIn();
    public virtual int get_MaxBuyIn();
    public virtual int get_MinToPlay();
    [CompilerGeneratedAttribute]
public PokerInputOption get_LastAction();
    [CompilerGeneratedAttribute]
private void set_LastAction(PokerInputOption value);
    [CompilerGeneratedAttribute]
public ulong get_LastActionTarget();
    [CompilerGeneratedAttribute]
private void set_LastActionTarget(ulong value);
    [CompilerGeneratedAttribute]
public int get_LastActionValue();
    [CompilerGeneratedAttribute]
private void set_LastActionValue(int value);
    [CompilerGeneratedAttribute]
public int get_BiggestRaiseThisTurn();
    [CompilerGeneratedAttribute]
private void set_BiggestRaiseThisTurn(int value);
    public int GetCurrentBet();
    public bool TryGetDealer(CardPlayerData& dealer);
    public bool TryGetSmallBlind(CardPlayerData& smallBlind);
    public bool TryGetBigBlind(CardPlayerData& bigBlind);
    protected virtual int GetFirstPlayerRelIndex(bool startOfRound);
    public static ushort EvaluatePokerHand(List`1<PlayingCard> cards);
    public int GetCurrentMinRaise(CardPlayerData playerData);
    public virtual List`1<PlayingCard> GetTableCards();
    public void InputsToList(int availableInputs, List`1<PokerInputOption> result);
    protected virtual CardPlayerData GetNewCardPlayerData(int mountIndex);
    public virtual void Save(CardGame syncData);
    protected virtual void SubStartRound();
    protected virtual void SubEndRound();
    protected virtual void AddRoundResult(CardPlayerData pData, int winnings, int winState);
    protected virtual void SubEndGameplay();
    private void IncrementDealer();
    private void DealHoleCards();
    private bool DealCommunityCards();
    private void ClearLastAction();
    protected virtual void OnTurnTimeout(CardPlayerData pData);
    protected virtual void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction);
    protected virtual void StartNextCycle();
    protected virtual bool ShouldEndCycle();
    protected virtual void EndCycle();
    protected virtual int GetAvailableInputsForPlayer(CardPlayerData playerData);
    protected virtual void HandlePlayerLeavingTable(CardPlayerData pData);
    private bool AnyoneElseCanBetMore(CardPlayerData excluding);
}
[DefaultMemberAttribute("Item")]
public class Facepunch.FPNativeList`1 : object {
    private NativeArray`1<T> _array;
    private int _length;
    private int _capacity;
    public NativeArray`1<T> Array { get; }
    public int Count { get; }
    public int Capacity { get; }
    public T Item { get; public set; }
    public NativeArray`1<T> get_Array();
    public int get_Count();
    public int get_Capacity();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public void RemoveLast();
    public void SetLength(int newLength);
    public void Clear();
    public void Resize(int count);
    public void EnsureCapacity(int requiredCapacity);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
}
public static class Facepunch.GUI.Controls : object {
    public static float labelWidth;
    private static Controls();
    public static float FloatSlider(string strLabel, float value, float low, float high, string format);
    public static int IntSlider(string strLabel, int value, int low, int high, string format);
    public static string TextArea(string strName, string value);
    public static bool Checkbox(string strName, bool value);
    public static bool Button(string strName);
}
internal class Facepunch.GUI.TabbedPanel : object {
    private int selectedTabID;
    private List`1<Tab> tabs;
    public Tab selectedTab { get; }
    public Tab get_selectedTab();
    public void Add(Tab tab);
    internal void DrawVertical(float width);
    internal void DrawContents();
}
public static class Facepunch.Output : object {
    [CompilerGeneratedAttribute]
private static Action`3<string, string, LogType> OnMessage;
    [CompilerGeneratedAttribute]
private static Action`3<string, string, LogType> OnPostMessage;
    public static bool installed;
    public static List`1<Entry> HistoryOutput;
    private static Output();
    [CompilerGeneratedAttribute]
public static void add_OnMessage(Action`3<string, string, LogType> value);
    [CompilerGeneratedAttribute]
public static void remove_OnMessage(Action`3<string, string, LogType> value);
    [CompilerGeneratedAttribute]
public static void add_OnPostMessage(Action`3<string, string, LogType> value);
    [CompilerGeneratedAttribute]
public static void remove_OnPostMessage(Action`3<string, string, LogType> value);
    public static void Install();
    public static void LogHandler(string log, string stacktrace, LogType type);
}
public class Facepunch.RCon : object {
    public static string Password;
    [ServerVar]
public static int Port;
    [ServerVar]
public static string Ip;
    [ServerVar]
public static bool Web;
    [ServerVar]
public static bool Print;
    internal static RConListener listener;
    public static Listener listenerNew;
    private static ConcurrentQueue`1<Command> Commands;
    private static float lastRunTime;
    internal static List`1<BannedAddresses> bannedAddresses;
    private static int responseIdentifier;
    private static int responseConnection;
    private static bool isInput;
    private static Stopwatch timer;
    internal static int SERVERDATA_AUTH;
    internal static int SERVERDATA_EXECCOMMAND;
    internal static int SERVERDATA_AUTH_RESPONSE;
    internal static int SERVERDATA_RESPONSE_VALUE;
    internal static int SERVERDATA_CONSOLE_LOG;
    internal static int SERVERDATA_SWITCH_UTF8;
    private static RCon();
    [ServerVar]
public static void print_rcon_clients(Arg arg);
    public static void Initialize();
    public static void Shutdown();
    public static void Broadcast(LogType type, object obj);
    public static void Broadcast(LogType type, string message);
    public static void Update();
    public static void BanIP(IPAddress addr, float seconds);
    public static bool IsBanned(IPAddress addr);
    private static void OnCommand(Command cmd);
    private static void OnMessage(string message, string stacktrace, LogType type);
}
public static class Facepunch.Rust.Analytics : object {
    private static HashSet`1<NetworkableId> trackedSpawnedIds;
    [CompilerGeneratedAttribute]
private static string <ClientAnalyticsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ServerAnalyticsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AnalyticsHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AnalyticsSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AnalyticsPublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <BulkUploadConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <ServerPerformanceConVar>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <GameplayAnalyticsConVar>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <GameplayTickAnalyticsConVar>k__BackingField;
    public static string ClientAnalyticsUrl { get; public set; }
    [ServerVar]
public static string ServerAnalyticsUrl { get; public set; }
    [ServerVar]
public static string AnalyticsHeader { get; public set; }
    [ServerVar]
public static string AnalyticsSecret { get; public set; }
    public static string AnalyticsPublicKey { get; public set; }
    [ServerVar]
public static string BulkUploadConnectionString { get; public set; }
    [ServerVar]
public static bool ServerPerformanceConVar { get; public set; }
    [ServerVar]
public static bool GameplayAnalyticsConVar { get; public set; }
    [ServerVar]
public static bool GameplayTickAnalyticsConVar { get; public set; }
    private static Analytics();
    [CompilerGeneratedAttribute]
public static string get_ClientAnalyticsUrl();
    [CompilerGeneratedAttribute]
public static void set_ClientAnalyticsUrl(string value);
    [CompilerGeneratedAttribute]
public static string get_ServerAnalyticsUrl();
    [CompilerGeneratedAttribute]
public static void set_ServerAnalyticsUrl(string value);
    [CompilerGeneratedAttribute]
public static string get_AnalyticsHeader();
    [CompilerGeneratedAttribute]
public static void set_AnalyticsHeader(string value);
    [CompilerGeneratedAttribute]
public static string get_AnalyticsSecret();
    [CompilerGeneratedAttribute]
public static void set_AnalyticsSecret(string value);
    [CompilerGeneratedAttribute]
public static string get_AnalyticsPublicKey();
    [CompilerGeneratedAttribute]
public static void set_AnalyticsPublicKey(string value);
    [CompilerGeneratedAttribute]
public static string get_BulkUploadConnectionString();
    [CompilerGeneratedAttribute]
public static void set_BulkUploadConnectionString(string value);
    [CompilerGeneratedAttribute]
public static bool get_ServerPerformanceConVar();
    [CompilerGeneratedAttribute]
public static void set_ServerPerformanceConVar(bool value);
    [CompilerGeneratedAttribute]
public static bool get_GameplayAnalyticsConVar();
    [CompilerGeneratedAttribute]
public static void set_GameplayAnalyticsConVar(bool value);
    [CompilerGeneratedAttribute]
public static bool get_GameplayTickAnalyticsConVar();
    [CompilerGeneratedAttribute]
public static void set_GameplayTickAnalyticsConVar(bool value);
    [ClientVar]
[ServerVar]
public static void GetPendingAnalytics(Arg arg);
}
public enum Facepunch.Rust.AnalyticsDocumentMode : Enum {
    public int value__;
    public static AnalyticsDocumentMode JSON;
    public static AnalyticsDocumentMode CSV;
}
public class Facepunch.Rust.AzureAnalyticsUploader : object {
    public static bool UsePooling;
    [CompilerGeneratedAttribute]
private TimeSpan <LoopDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictMode>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyticsDocumentMode <DocumentMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseJsonDataObject>k__BackingField;
    private ConcurrentQueue`1<EventRecord> queue;
    private BlobClient _blobClient;
    private Stream Stream;
    private GZipStream ZipStream;
    private Utf8ValueStringBuilder Writer;
    private bool disposed;
    public TimeSpan LoopDelay { get; public set; }
    public DateTime Expiry { get; private set; }
    public bool StrictMode { get; public set; }
    public AnalyticsDocumentMode DocumentMode { get; private set; }
    public bool UseJsonDataObject { get; public set; }
    [CompilerGeneratedAttribute]
public TimeSpan get_LoopDelay();
    [CompilerGeneratedAttribute]
public void set_LoopDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_Expiry();
    [CompilerGeneratedAttribute]
private void set_Expiry(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_StrictMode();
    [CompilerGeneratedAttribute]
public void set_StrictMode(bool value);
    [CompilerGeneratedAttribute]
public AnalyticsDocumentMode get_DocumentMode();
    [CompilerGeneratedAttribute]
private void set_DocumentMode(AnalyticsDocumentMode value);
    [CompilerGeneratedAttribute]
public bool get_UseJsonDataObject();
    [CompilerGeneratedAttribute]
public void set_UseJsonDataObject(bool value);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    private void Initialize();
    public bool TryFlush();
    public static AzureAnalyticsUploader Create(string table, TimeSpan timeout, AnalyticsDocumentMode mode);
    public void Append(EventRecord record);
    [AsyncStateMachineAttribute("Facepunch.Rust.AzureAnalyticsUploader/<CreateBlobAsync>d__34")]
private Task CreateBlobAsync();
    [AsyncStateMachineAttribute("Facepunch.Rust.AzureAnalyticsUploader/<UploadThread>d__35")]
private Task UploadThread();
    private void EmptyUploadQueue();
    [AsyncStateMachineAttribute("Facepunch.Rust.AzureAnalyticsUploader/<DisposeStreamsAsync>d__37")]
private Task DisposeStreamsAsync();
}
[ExtensionAttribute]
public static class Facepunch.Rust.AzureAnalyticsUploaderEx : object {
    [ExtensionAttribute]
public static bool NeedsCreation(AzureAnalyticsUploader uploader);
}
public class Facepunch.Rust.EventRecord : object {
    public static long TicksToNS;
    public DateTime Timestamp;
    public bool IsServer;
    [CompilerGeneratedAttribute]
private string <EventType>k__BackingField;
    public List`1<EventRecordField> Data;
    public int TimesCreated;
    public int TimesSubmitted;
    public string EventType { get; private set; }
    private static EventRecord();
    [CompilerGeneratedAttribute]
public string get_EventType();
    [CompilerGeneratedAttribute]
private void set_EventType(string value);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public static EventRecord CSV();
    public static EventRecord New(string type, bool isServer);
    public EventRecord AddObject(string key, object data);
    public EventRecord SetTimestamp(DateTime timestamp);
    public EventRecord AddField(string key, DateTime time);
    public EventRecord AddField(string key, bool value);
    public EventRecord AddField(string key, string value);
    public EventRecord AddField(string key, byte value);
    public EventRecord AddField(string key, sbyte value);
    public EventRecord AddField(string key, short value);
    public EventRecord AddField(string key, ushort value);
    public EventRecord AddField(string key, int value);
    public EventRecord AddField(string key, UInt32 value);
    public EventRecord AddField(string key, ulong value);
    [ObsoleteAttribute("Char not supported, either cast to int or string", "True")]
public EventRecord AddField(string key, char value);
    public EventRecord AddField(string key, float value);
    public EventRecord AddField(string key, long value);
    public EventRecord AddField(string key, double value);
    public EventRecord AddField(string key, TimeSpan value);
    public EventRecord AddLegacyTimespan(string key, TimeSpan value);
    public EventRecord AddField(string key, Guid value);
    public EventRecord AddField(string key, Vector3 value);
    public EventRecord AddField(string key, BaseNetworkable entity);
    public EventRecord AddField(string key, Item item);
    public void MarkSubmitted();
    public void Submit();
    public void SerializeAsCSV(Utf8ValueStringBuilder& writer);
    public void SerializeAsJson(Utf8ValueStringBuilder& writer, bool useDataObject);
    public EventRecord AddField(byte value);
    public EventRecord AddField(short value);
    public EventRecord AddField(ushort value);
    public EventRecord AddField(int value);
    public EventRecord AddField(UInt32 value);
    public EventRecord AddField(ulong value);
    public EventRecord AddField(float value);
    [ObsoleteAttribute("Char not supported, either cast to int or string")]
public EventRecord AddField(char value);
    public EventRecord AddField(long value);
    public EventRecord AddField(double value);
    public EventRecord AddField(string value);
    public EventRecord AddField(bool value);
    public EventRecord AddField(DateTime value);
    public EventRecord AddField(TimeSpan value);
    public EventRecord AddField(Guid value);
    public EventRecord AddField(Vector3 vector);
    public EventRecord AddField(string key1, string key2, byte value);
    public EventRecord AddField(string key1, string key2, short value);
    public EventRecord AddField(string key1, string key2, ushort value);
    public EventRecord AddField(string key1, string key2, int value);
    public EventRecord AddField(string key1, string key2, UInt32 value);
    public EventRecord AddField(string key1, string key2, ulong value);
    public EventRecord AddField(string key1, string key2, float value);
    [ObsoleteAttribute("Char not supported, either cast to int or string")]
public EventRecord AddField(string key1, string key2, char value);
    public EventRecord AddField(string key1, string key2, long value);
    public EventRecord AddField(string key1, string key2, double value);
    public EventRecord AddField(string key1, string key2, string value);
    public EventRecord AddField(string key1, string key2, bool value);
    public EventRecord AddField(string key1, string key2, DateTime value);
    public EventRecord AddField(string key1, string key2, TimeSpan value);
    public EventRecord AddField(string key1, string key2, Guid value);
    public EventRecord AddField(string key1, string key2, Vector3 vector);
}
public class Facepunch.Rust.EventRecordField : ValueType {
    public string Key1;
    public string Key2;
    public string String;
    public Nullable`1<long> Number;
    public Nullable`1<double> Float;
    public Nullable`1<Vector3> Vector;
    public Nullable`1<Guid> Guid;
    public DateTime DateTime;
    public bool IsObject;
    public EventRecordField(string key1);
    public EventRecordField(string key1, string key2);
    public void Serialize(Utf8ValueStringBuilder& writer, AnalyticsDocumentMode format);
}
public static class Facepunch.Rust.HttpManager : object {
    public static void UpdateMaxConnections();
}
public class Facepunch.Rust.PerformanceLogging : object {
    public static PerformanceLogging server;
    public static PerformanceLogging client;
    private TimeSpan ClientInterval;
    private TimeSpan ServerInterval;
    private TimeSpan PublicServerInterval;
    private TimeSpan PingInterval;
    private List`1<TimeSpan> Frametimes;
    private List`1<int> PingHistory;
    private List`1<LagSpike> lagSpikes;
    private List`1<GarbageCollect> garbageCollections;
    private Dictionary`2<string, int> pendingTimings;
    private bool isClient;
    private Stopwatch frameWatch;
    private DateTime nextPingTime;
    private DateTime nextFlushTime;
    private DateTime connectedTime;
    private int serverIndex;
    private Guid totalSessionId;
    private Guid sessionId;
    private int lastFrameGC;
    private Type oxideType;
    private bool hasOxideType;
    public PerformanceLogging(bool client);
    private static PerformanceLogging();
    private TimeSpan GetLagSpikeThreshold();
    public void OnFrame();
    private Dictionary`2<string, string> FindModifiedConvars();
    public void FlushMainThread();
    private TimeSpan GetFlushInterval();
    private void ResetMeasurements();
    private Task ProcessPerformanceData(EventRecord record, List`1<TimeSpan> frametimes, List`1<int> ping);
    public void SetTiming(string category, TimeSpan elapsed);
}
public static class Facepunch.Rust.Profiling.EntityProfiler : object {
    public static int mode;
    public static TimeSpan aggregateEntityCountDelay;
    public static int spawned;
    public static int killed;
    public static Dictionary`2<UInt32, EntityCounter> counts;
    public static List`1<EntityCounter> list;
    private static DateTime aggregateEntityCountCooldown;
    private static EntityProfiler();
    public static void OnSpawned(BaseNetworkable entity);
    public static void OnKilled(BaseNetworkable entity);
    public static void Reset();
    public static void TrySerializeEntityAggregates(int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader);
    public static void Serialize(EventRecord record, int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader);
}
public static class Facepunch.Rust.Profiling.LagSpikeProfiler : object {
    public static bool enabled;
    private static List`1<EventRecord> pendingEvents;
    private static LagSpikeProfiler();
    public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp);
    public static void Reset();
    private static void AddPendingRecord(EventRecord record);
    public static void RPC(TimeSpan time, Message packet, BaseEntity entity, UInt32 rpcId);
    public static void ConsoleCommand(TimeSpan time, Message packet, string command);
    public static void RconCommand(TimeSpan time, string command);
    private static EventRecord CreateRecord(TimeSpan duration, string reason);
}
[Factory("profile")]
public static class Facepunch.Rust.Profiling.RuntimeProfiler : object {
    [CompilerGeneratedAttribute]
private static TimeSpan <RpcWarningThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <ConsoleCommandWarningThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private static TimeSpan <RconCommandWarningThreshold>k__BackingField;
    private static int profilingPreset;
    [CompilerGeneratedAttribute]
private static bool <runtime_profiling_persist>k__BackingField;
    private static int _profilingInterval;
    [CompilerGeneratedAttribute]
private static int <runtime_profiling_pooling>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <runtime_profiling_pool_flush_interval>k__BackingField;
    private static bool _init;
    private static Stopwatch serializationTimer;
    private static AzureAnalyticsUploader frameProfilingUploader;
    private static AzureAnalyticsUploader entityProfilingUploader;
    private static AzureAnalyticsUploader entityAggregateUploader;
    private static AzureAnalyticsUploader invokeDetailsUploader;
    private static AzureAnalyticsUploader methodUploader;
    private static AzureAnalyticsUploader objectWorkQueueUploader;
    private static AzureAnalyticsUploader packetUploader;
    private static AzureAnalyticsUploader lagSpikeUploader;
    private static AzureAnalyticsUploader rconUploader;
    private static AzureAnalyticsUploader raknetUploader;
    private static AzureAnalyticsUploader poolUploader;
    public static TimeSpan ServerMgr_Update;
    public static TimeSpan Net_Cycle;
    public static TimeSpan Physics_SyncTransforms;
    public static TimeSpan Companion_Tick;
    public static TimeSpan BasePlayer_ServerCycle;
    private static DateTime nextPoolFlush;
    private static ProfilerRecorderOptions PhysicsRecorderOptions;
    private static List`1<RustProfilerRecorder> recorders;
    private static Stopwatch invokeExecutionResetTimer;
    [ServerVar]
public static int rpc_lagspike_threshold { get; public set; }
    [ServerVar]
public static int command_lagspike_threshold { get; public set; }
    [ServerVar]
public static int rcon_lagspike_threshold { get; public set; }
    public static TimeSpan RpcWarningThreshold { get; private set; }
    public static TimeSpan ConsoleCommandWarningThreshold { get; private set; }
    public static TimeSpan RconCommandWarningThreshold { get; private set; }
    [ServerVar]
public static int runtime_profiling { get; public set; }
    [ServerVar]
public static bool runtime_profiling_persist { get; public set; }
    [ServerVar]
public static bool profiling_lagspikes { get; public set; }
    [ServerVar]
public static bool profiling_packets { get; public set; }
    [ServerVar]
public static int profiling_invokes { get; public set; }
    [ServerVar]
public static int profiling_fixed_invokes { get; public set; }
    [ServerVar]
public static int profiling_entities { get; public set; }
    [ServerVar]
public static int profiling_entity_count_interval { get; public set; }
    [ServerVar]
public static bool profiling_work_queue { get; public set; }
    [ServerVar]
public static int profiling_rcon { get; public set; }
    [ServerVar]
public static int profiling_rcon_message_length { get; public set; }
    [ServerVar]
public static int runtime_profiling_interval { get; public set; }
    [ServerVar]
public static bool runtime_profiling_uploader_pooling { get; public set; }
    [ServerVar]
public static int profiling_ping { get; public set; }
    [ServerVar]
public static int runtime_profiling_pooling { get; public set; }
    [ServerVar]
public static float profiling_ping_interval { get; public set; }
    [ServerVar]
public static int profiling_ping_per_frame { get; public set; }
    [ServerVar]
public static int runtime_profiling_pool_flush_interval { get; public set; }
    private static RuntimeProfiler();
    [ServerVar]
[ClientVar]
public static void dump_profile_recorders(Arg arg);
    public static int get_rpc_lagspike_threshold();
    public static void set_rpc_lagspike_threshold(int value);
    public static int get_command_lagspike_threshold();
    public static void set_command_lagspike_threshold(int value);
    public static int get_rcon_lagspike_threshold();
    public static void set_rcon_lagspike_threshold(int value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_RpcWarningThreshold();
    [CompilerGeneratedAttribute]
private static void set_RpcWarningThreshold(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_ConsoleCommandWarningThreshold();
    [CompilerGeneratedAttribute]
private static void set_ConsoleCommandWarningThreshold(TimeSpan value);
    [CompilerGeneratedAttribute]
public static TimeSpan get_RconCommandWarningThreshold();
    [CompilerGeneratedAttribute]
private static void set_RconCommandWarningThreshold(TimeSpan value);
    public static int get_runtime_profiling();
    public static void set_runtime_profiling(int value);
    [CompilerGeneratedAttribute]
public static bool get_runtime_profiling_persist();
    [CompilerGeneratedAttribute]
public static void set_runtime_profiling_persist(bool value);
    public static bool get_profiling_lagspikes();
    public static void set_profiling_lagspikes(bool value);
    public static bool get_profiling_packets();
    public static void set_profiling_packets(bool value);
    public static int get_profiling_invokes();
    public static void set_profiling_invokes(int value);
    public static int get_profiling_fixed_invokes();
    public static void set_profiling_fixed_invokes(int value);
    public static int get_profiling_entities();
    public static void set_profiling_entities(int value);
    public static int get_profiling_entity_count_interval();
    public static void set_profiling_entity_count_interval(int value);
    public static bool get_profiling_work_queue();
    public static void set_profiling_work_queue(bool value);
    public static int get_profiling_rcon();
    public static void set_profiling_rcon(int value);
    public static int get_profiling_rcon_message_length();
    public static void set_profiling_rcon_message_length(int value);
    public static int get_runtime_profiling_interval();
    public static void set_runtime_profiling_interval(int value);
    public static bool get_runtime_profiling_uploader_pooling();
    public static void set_runtime_profiling_uploader_pooling(bool value);
    public static int get_profiling_ping();
    public static void set_profiling_ping(int value);
    [CompilerGeneratedAttribute]
public static int get_runtime_profiling_pooling();
    [CompilerGeneratedAttribute]
public static void set_runtime_profiling_pooling(int value);
    public static float get_profiling_ping_interval();
    public static void set_profiling_ping_interval(float value);
    public static int get_profiling_ping_per_frame();
    public static void set_profiling_ping_per_frame(int value);
    [CompilerGeneratedAttribute]
public static int get_runtime_profiling_pool_flush_interval();
    [CompilerGeneratedAttribute]
public static void set_runtime_profiling_pool_flush_interval(int value);
    public static void Disable();
    private static void Start();
    private static void OnProfilingPresetChanged();
    public static void Update();
    private static void EnsureUploadersCreated();
    private static void CollectLastFrameStats();
    private static void WriteFrameData(int frameIndex);
    private static void ResetAllMeasurements();
    private static void SerializeCommon(EventRecord record, RconProfilerStats rconStats);
    private static void SerializeNetworking(EventRecord frameRecord, int frameIndex, DateTime timestamp);
    private static void SerializeInvokes(EventRecord record);
    private static void SerializeInvokeExecutionTime(InvokeProfiler profiler, AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, bool reset);
    private static void SerializeProfilingSamples(EventRecord record);
    private static void SerializeRconEvents(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, RconProfilerStats rconStats);
    private static void SerializeMemoryPool(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp);
    private static EventRecord CreatePoint(string type, int frameIndex, DateTime timestamp);
}
public class Facepunch.Rust.Profiling.RustProfilerRecorder : ValueType {
    public string ColumnName;
    public ProfilerRecorder Recorder;
    public RustProfilerRecorder(string column, ProfilerCategory category, string sample, int sampleCount, ProfilerRecorderOptions options);
}
public static class Facepunch.Rust.Profiling.UnityProfiler : object {
    private static List`1<RecorderInfo> ActiveRecorders;
    private static bool _enabled;
    public static bool enabled { get; public set; }
    private static UnityProfiler();
    public static bool get_enabled();
    public static void set_enabled(bool value);
    private static void SetEnabled(bool state);
    public static void Unload();
    public static void Serialize(AzureAnalyticsUploader uploader, DateTime timestamp, int frameIndex);
}
public static class Facepunch.Rust.Profiling.WorkQueueProfiler : object {
    public static bool enabled;
    public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp);
    public static void Reset();
}
public class Facepunch.Rust.TickLogging : object {
    public static AzureAnalyticsUploader tickUploader;
}
public class Facepunch.UI.ESPCanvas : SingletonComponent`1<ESPCanvas> {
    [TooltipAttribute("Amount of times per second we should update the visible panels")]
public float RefreshRate;
    [TooltipAttribute("This object will be duplicated in place")]
public ESPPlayerInfo Source;
    private static int NameplateCount;
    [ClientVar]
public static float OverrideMaxDisplayDistance;
    [ClientVar]
public static bool DisableOcclusionChecks;
    [ClientVar]
public static bool ShowHealth;
    [ClientVar]
public static bool ColourCodeTeams;
    [ClientVar]
public static bool UseRandomTeamColours;
    [ReplicatedVar]
public static float DisplayDistanceMultiplier;
    [ClientVar]
public static int MaxNameplates { get; public set; }
    private static ESPCanvas();
    public static int get_MaxNameplates();
    public static void set_MaxNameplates(int value);
}
public class Facepunch.UI.ESPPlayerInfo : MonoBehaviour {
    public Vector3 WorldOffset;
    public RustText Text;
    public TextMeshProUGUI[] TextElements;
    public RustIcon Loading;
    public GameObject ClanElement;
    public RustText ClanText;
    public CanvasGroup group;
    public Gradient gradientNormal;
    public Gradient gradientTeam;
    public AccessibilityColourCollection TeamLookup;
    public AccessibilityColourCollection ClanLookup;
    public AccessibilityColourCollection AllyLookup;
    public AccessibilityColourCollection EnemyLookup;
    public QueryVis visCheck;
    [CompilerGeneratedAttribute]
private BasePlayer <Entity>k__BackingField;
    public BasePlayer Entity { get; public set; }
    [CompilerGeneratedAttribute]
public BasePlayer get_Entity();
    [CompilerGeneratedAttribute]
public void set_Entity(BasePlayer value);
}
public static class Facepunch.Unity.RenderInfo : object {
    public static void GenerateReport();
}
public class Facepunch.Utility.Compression : object {
    public static Byte[] Compress(Byte[] data);
    public static Byte[] Uncompress(Byte[] data);
    public static int PackVector3ToInt(Vector3 vector, float minValue, float maxValue);
    public static Vector3 UnpackVector3FromInt(int packed, float minValue, float maxValue);
}
public class Facepunch.VirtualScroll : MonoBehaviour {
    public int ItemHeight;
    public int ItemSpacing;
    public RectOffset Padding;
    [TooltipAttribute("Optional, we'll try to GetComponent IDataSource from this object on awake")]
public GameObject DataSourceObject;
    public GameObject SourceObject;
    public ScrollRect ScrollRect;
    public RectTransform OverrideContentRoot;
    private IDataSource dataSource;
    private Dictionary`2<int, GameObject> ActivePool;
    private Stack`1<GameObject> InactivePool;
    private int BlockHeight { get; }
    public void Awake();
    public void OnDestroy();
    private void OnScrollChanged(Vector2 pos);
    public void SetDataSource(IDataSource source, bool forceRebuild);
    private int get_BlockHeight();
    public void FullRebuild();
    public void DataChanged();
    public void Rebuild();
    public void Update();
    private void RecycleOutOfRange(int startVisible, float endVisible);
    private void Recycle(int key);
    private void BuildItem(int i);
    private GameObject GetItem();
}
public class FavouriteRadioStation : MonoBehaviour {
    public RustText UrlText;
    public GameObject XmasRoot;
}
[ExtensionAttribute]
public static class FileEx : object {
    public static void Backup(DirectoryInfo parent, String[] names);
    [ExtensionAttribute]
public static bool MoveToSafe(FileInfo parent, string target, int retries);
    public static void Backup(String[] names);
}
public class FileStorage : object {
    private FileDatabase db;
    private CRC32 crc;
    private MruDictionary`2<UInt32, CacheData> _cache;
    public static FileStorage server;
    protected FileStorage(string name, bool server);
    private static FileStorage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private UInt32 GetCRC(Byte[] data, Type type);
    public UInt32 Store(Byte[] data, Type type, NetworkableId entityID, UInt32 numID);
    public Byte[] Get(UInt32 crc, Type type, NetworkableId entityID, UInt32 numID);
    public void Remove(UInt32 crc, Type type, NetworkableId entityID);
    public void RemoveExact(UInt32 crc, Type type, NetworkableId entityID, UInt32 numid);
    public void RemoveEntityNum(NetworkableId entityid, UInt32 numid);
    public void RemoveAllByEntity(NetworkableId entityid);
    public void ReassignEntityId(NetworkableId oldId, NetworkableId newId);
    public IEnumerable`1<AssociatedFile> QueryAllByEntity(NetworkableId entityID);
}
public class FileSystem_Warmup : MonoBehaviour {
    public static bool ranInBackground;
    public static Coroutine warmupTask;
    private static List`1<ValueTuple`2<string, TimeSpan>> warmupTimes;
    private static bool run;
    public static String[] ExcludeFilter;
    private static Stopwatch warmupTimer;
    private static FileSystem_Warmup();
    public static IEnumerable`1<ValueTuple`2<string, TimeSpan>> GetWarmupTimes();
    public static void Run();
    public static IEnumerator Run(String[] assetList, Action`1<string> statusFunction, string format, int priority);
    [IteratorStateMachineAttribute("FileSystem_Warmup/<RunAsyncImpl>d__8")]
private static IEnumerator RunAsyncImpl(String[] assetList, Action`1<string> statusFunction, string format, int priority);
    [IteratorStateMachineAttribute("FileSystem_Warmup/<RunImpl>d__9")]
private static IEnumerator RunImpl(String[] assetList, Action`1<string> statusFunction, string format);
    private static float CalculateFrameBudget();
    private static bool ShouldIgnore(string path);
    public static String[] GetAssetList(Nullable`1<bool> poolFilter);
    private static void PrefabWarmup(string path);
}
public class FireBall : BaseEntity {
    public float lifeTimeMin;
    public float lifeTimeMax;
    public ParticleSystem[] movementSystems;
    public ParticleSystem[] restingSystems;
    public float generation;
    public GameObjectRef spreadSubEntity;
    public float tickRate;
    public float damagePerSecond;
    public float radius;
    public int waterToExtinguish;
    public bool canMerge;
    public LayerMask AttackLayers;
    public bool ignoreNPC;
    private Vector3 lastPos;
    private float deathTime;
    private int wetness;
    private float spawnTime;
    private Vector3 delayedVelocity;
    public void SetDelayedVelocity(Vector3 delayed);
    private void ApplyDelayedVelocity();
    public virtual void ServerInit();
    public float GetDeathTime();
    public void AddLife(float amountToAdd);
    public float MaxLifeTime();
    public float TimeLeft();
    public void TryToSpread();
    public void SetGeneration(int gen);
    public void Think();
    public void DoRadialDamage();
    public bool CanMerge();
    public float TimeAlive();
    public void SetResting(bool isResting);
    public void Extinguish();
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public bool IsResting();
    public virtual void Load(LoadInfo info);
}
public class FireBomb : MonoBehaviour {
    public GameObject fireParticle;
    public float bombRadius;
    public float particleDuration;
    public float emitDuration;
}
public class FirecrackerRepeater : BaseMonoBehaviour {
    public GameObjectRef singleExplosionEffect;
    public Transform[] parts;
    public float partWidth;
    public float partLength;
    public Quaternion[] targetRotations;
    public Quaternion[] initialRotations;
    public Renderer[] renderers;
    public Material materialSource;
    public float explodeRepeatMin;
    public float explodeRepeatMax;
    public float explodeLerpSpeed;
    public Vector3 twistAmount;
    public float fuseLength;
    public float explodeStrength;
    public float explodeDirBlend;
    public float duration;
    public ParticleSystemContainer smokeParticle;
}
public class FireSpot : BaseEntity {
    public GameObject flameEffect;
    public virtual void Load(LoadInfo info);
}
public class FireworkBenchmarkScene : BenchmarkScene {
    public GameObjectRef[] shellTypes;
    public int fireworkCount;
}
public class FireworkShell : BaseMonoBehaviour {
    public float fuseLengthMin;
    public float fuseLengthMax;
    public float speedMin;
    public float speedMax;
    public ParticleSystem explodePFX;
    public SoundPlayer explodeSound;
    public float inaccuracyDegrees;
    public LightEx explosionLight;
    public float lifetime;
}
public class FirstPersonEffect : MonoBehaviour {
    public bool isGunShot;
    [HideInInspector]
public EffectParentToWeaponBone parentToWeaponComponent;
}
public class FishBrain : BaseAIBrain {
    public static int Count;
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
}
public class FishingBobber : BaseCombatEntity {
    public Transform centerOfMass;
    public Rigidbody myRigidBody;
    public Transform lineAttachPoint;
    public Transform bobberRoot;
    public static Flags CaughtFish;
    public float HorizontalMoveSpeed;
    public float PullAwayMoveSpeed;
    public float SidewaysInputForce;
    public float ReelInMoveSpeed;
    private float bobberForcePingPong;
    private Vector3 initialDirection;
    [CompilerGeneratedAttribute]
private float <TireAmount>k__BackingField;
    private Vector3 initialTargetPosition;
    private Vector3 spawnPosition;
    private TimeSince initialCastTime;
    private float initialDistance;
    public float TireAmount { get; private set; }
    [CompilerGeneratedAttribute]
public float get_TireAmount();
    [CompilerGeneratedAttribute]
private void set_TireAmount(float value);
    public virtual void ServerInit();
    public void InitialiseBobber(BasePlayer forPlayer, WaterBody forBody, Vector3 targetPos, float maxDuration);
    private void ProcessInitialCast();
    public void ServerMovementUpdate(bool inputLeft, bool inputRight, bool inputBack, FishState& state, Vector3 playerPos, ItemModFishable fishableModifier);
    private bool IsDirectionValid(Vector3 pos, float checkLength, Vector3 playerPos);
    private void TimeOutBobber();
}
public class FishingRodViewmodel : MonoBehaviour {
    public Transform PitchTransform;
    public Transform YawTransform;
    public float YawLerpSpeed;
    public float PitchLerpSpeed;
    public Transform LineRendererStartPos;
    public ParticleSystem[] StrainParticles;
    public bool ApplyTransformRotation;
    public GameObject CatchRoot;
    public Transform CatchLinePoint;
    public FishViewmodel[] FishViewmodels;
    public float ShakeMaxScale;
}
[CreateAssetMenuAttribute]
public class FishLookup : BaseScriptableObject {
    public ItemModFishable FallbackFish;
    private static FishLookup _instance;
    private static ItemModFishable[] AvailableFish;
    public static ItemDefinition[] BaitItems;
    private static TimeSince lastShuffle;
    public static int ALL_FISH_COUNT;
    public static string ALL_FISH_ACHIEVEMENT_NAME;
    public static FishLookup Instance { get; }
    public static FishLookup get_Instance();
    public static void LoadFish();
    public ItemDefinition GetFish(Vector3 worldPos, WaterBody bodyType, Item lure, ItemModFishable& fishable, ItemModFishable ignoreFish, Int32& usedLureAmount, float overrideDepth);
    public void CheckCatchAllAchievement(BasePlayer player);
}
public class FishMount : StorageContainer {
    public Animator[] FishRoots;
    public GameObjectRef FishInteractSound;
    public float UseCooldown;
    public static Flags HasFish;
    private int GetCurrentFishItemIndex { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Save(SaveInfo info);
    private int get_GetCurrentFishItemIndex();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void PostServerLoad();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    [IsVisible("3")]
[RPC_Server]
private void UseFish(RPCMessage msg);
    private void ClearBusy();
}
public class FishNavigator : BaseNavigator {
    [CompilerGeneratedAttribute]
private BaseNpc <NPC>k__BackingField;
    public BaseNpc NPC { get; private set; }
    [CompilerGeneratedAttribute]
public BaseNpc get_NPC();
    [CompilerGeneratedAttribute]
private void set_NPC(BaseNpc value);
    public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent);
    protected virtual bool SetCustomDestination(Vector3 pos, float speedFraction, float updateInterval);
    protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta);
    private void UpdateRotation(Vector3 moveToPosition, float delta);
}
public class FishShoal : object {
    private static float maxFishDistance;
    private FishType fishType;
    private JobHandle jobHandle;
    private NativeArray`1<RaycastCommand> castCommands;
    private NativeArray`1<RaycastHit> castResults;
    private NativeArray`1<int> fishCastIndices;
    private NativeArray`1<FishData> fishData;
    private NativeArray`1<FishRenderData> fishRenderData;
    private NativeArray`1<int> fishCount;
    private MaterialPropertyBlock materialPropertyBlock;
    private ComputeBuffer fishBuffer;
    public FishShoal(FishType fishType);
    private static float3 GetTarget(float3 spawnPos, Random& random);
    private int GetPopulationScaleForPoint(float3 cameraPosition);
    public void TrySpawn(float3 cameraPosition);
    public void OnUpdate(float3 cameraPosition);
    private void UpdateJobs(float3 cameraPosition);
    public void OnLateUpdate(float3 cameraPosition);
    public sealed virtual void Dispose();
    public void OnDrawGizmosSelected();
}
[ExtensionAttribute]
public static class FishStateExtensions : object {
    [ExtensionAttribute]
public static bool Contains(FishState state, FishState check);
    [ExtensionAttribute]
public static FishState FlipHorizontal(FishState state);
}
public class FishSwarm : MonoBehaviour {
    public FishType[] fishTypes;
    public FishShoal[] fishShoals;
    private void Awake();
    [IteratorStateMachineAttribute("FishSwarm/<SpawnFish>d__3")]
private IEnumerator SpawnFish();
    private void Update();
    private void LateUpdate();
    private void OnDestroy();
    private void OnDrawGizmosSelected();
}
public class FixedIntParameter : ParameterOverride`1<int> {
}
public class FixedRateStepped : object {
    public float rate;
    public int maxSteps;
    internal float nextCall;
    public bool ShouldStep();
}
public class FixedSByteNorm3 : ValueType {
    private static int FracBits;
    private static float MaxFrac;
    private static float RcpMaxFrac;
    public sbyte x;
    public sbyte y;
    public sbyte z;
    public FixedSByteNorm3(Vector3 vec);
    public static Vector3 op_Explicit(FixedSByteNorm3 vec);
}
public class FixedSByteNorm4 : ValueType {
    private static int FracBits;
    private static float MaxFrac;
    private static float RcpMaxFrac;
    public sbyte x;
    public sbyte y;
    public sbyte z;
    public sbyte w;
    public FixedSByteNorm4(Vector4 vec);
    public static Vector4 op_Explicit(FixedSByteNorm4 vec);
}
public class FixedShort3 : ValueType {
    private static int FracBits;
    private static float MaxFrac;
    private static float RcpMaxFrac;
    public short x;
    public short y;
    public short z;
    public FixedShort3(Vector3 vec);
    public static Vector3 op_Explicit(FixedShort3 vec);
}
public class FlameExplosive : TimedExplosive {
    public GameObjectRef createOnExplode;
    public bool blockCreateUnderwater;
    public float numToCreate;
    public float minVelocity;
    public float maxVelocity;
    public float spreadAngle;
    public bool forceUpForExplosion;
    public AnimationCurve velocityCurve;
    public AnimationCurve spreadCurve;
    public virtual void Explode();
    public void FlameExplode(Vector3 surfaceNormal);
    public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin);
}
public class FlameJet : MonoBehaviour {
    public LineRenderer line;
    public float tesselation;
    private float length;
    public float maxLength;
    public float drag;
    private int numSegments;
    private float spacing;
    public bool on;
    private Vector3[] lastWorldSegments;
    private Vector3[] currentSegments;
    public Color startColor;
    public Color endColor;
    public Color currentColor;
    public bool externalUpdate;
    private void Initialize();
    private void Awake();
    public void LateUpdate();
    public void SetOn(bool isOn);
    private float curve(float x);
    public void UpdateLine();
}
public class FlameThrower : AttackEntity {
    [HeaderAttribute("Flame Thrower")]
public int maxAmmo;
    public int ammo;
    public ItemDefinition fuelType;
    public float timeSinceLastAttack;
    [FormerlySerializedAsAttribute("nextAttackTime")]
public float nextReadyTime;
    public float flameRange;
    public float flameRadius;
    public ParticleSystem[] flameEffects;
    public FlameJet jet;
    public GameObjectRef fireballPrefab;
    public List`1<DamageTypeEntry> damagePerSec;
    public float playerDamageMultiplier;
    public SoundDefinition flameStart3P;
    public SoundDefinition flameLoop3P;
    public SoundDefinition flameStop3P;
    public SoundDefinition pilotLoopSoundDef;
    private float tickRate;
    private float lastFlameTick;
    public float fuelPerSec;
    private float ammoRemainder;
    public float reloadDuration;
    private float lastReloadTime;
    private float nextFlameTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool IsWeaponBusy();
    private void SetBusyFor(float dur);
    private void ClearBusy();
    public void ReduceAmmo(float firingTime);
    public void PilotLightToggle_Shared();
    public bool IsPilotOn();
    public bool IsFlameOn();
    public bool HasAmmo();
    public Item GetAmmo();
    public virtual void Load(LoadInfo info);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void Save(SaveInfo info);
    [IsActiveItem]
[RPC_Server]
public void SetFiring(RPCMessage msg);
    public virtual void ServerUse();
    public virtual void TopUpAmmo();
    public virtual float AmmoFraction();
    public virtual bool ServerIsReloading();
    public virtual bool CanReload();
    public virtual void ServerReload();
    public void StopFlameState();
    [RPC_Server]
[IsActiveItem]
public void DoReload(RPCMessage msg);
    public void SetFlameState(bool wantsOn);
    [RPC_Server]
[IsActiveItem]
public void TogglePilotLight(RPCMessage msg);
    public virtual void OnHeldChanged();
    public void FlameTick();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class flamethrowerFire : MonoBehaviour {
    public ParticleSystem pilotLightFX;
    public ParticleSystem[] flameFX;
    public FlameJet jet;
    public AudioSource oneShotSound;
    public AudioSource loopSound;
    public AudioClip pilotlightIdle;
    public AudioClip flameLoop;
    public AudioClip flameStart;
    public flamethrowerState flameState;
    private flamethrowerState previousflameState;
    public void PilotLightOn();
    public void SetFlameStatus(bool status);
    public void ShutOff();
    public void FlameOn();
    private void Start();
    private void Update();
}
public class FlameThrowerInformationPanel : ItemInformationPanel {
    public ItemStatValue damageDisplay;
    public ItemStatValue rangeDisplay;
}
public enum flamethrowerState : Enum {
    public int value__;
    public static flamethrowerState OFF;
    public static flamethrowerState PILOT_LIGHT;
    public static flamethrowerState FLAME_ON;
}
public class FlameTurret : StorageContainer {
    public Transform upper;
    public Vector3 aimDir;
    public float arc;
    public float triggeredDuration;
    public float flameRange;
    public float flameRadius;
    public float fuelPerSec;
    public Transform eyeTransform;
    public List`1<DamageTypeEntry> damagePerSec;
    public GameObjectRef triggeredEffect;
    public GameObjectRef fireballPrefab;
    public GameObjectRef explosionEffect;
    public TargetTrigger trigger;
    private float nextFireballTime;
    private int turnDir;
    private float lastMovementUpdate;
    private float triggeredTime;
    private float lastServerThink;
    private float triggerCheckRate;
    private float nextTriggerCheckTime;
    private float pendingFuel;
    public static UpdateFlameTurretWorkQueue updateFlameTurretQueueServer;
    private static FlameTurret();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsTriggered();
    public Vector3 GetEyePosition();
    public virtual bool CanPickup(BasePlayer player);
    public void SetTriggered(bool triggered);
    public virtual void ServerInit();
    public void SendAimDir();
    public float GetSpinSpeed();
    public virtual void OnAttacked(HitInfo info);
    public void MovementUpdate(float delta);
    public void ServerThink();
    public bool CheckTrigger();
    public virtual void OnKilled(HitInfo info);
    public int GetFuelAmount();
    public bool HasFuel();
    public bool UseFuel(float seconds);
    public void DoFlame(float delta);
}
public class Flashbang : TimedExplosive {
    public SoundDefinition deafLoopDef;
    public float flashReductionPerSecond;
    public float flashToAdd;
    public float flashMinRange;
    public float flashMaxRange;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Explode();
    public void DelayedDestroy();
}
[PostProcessAttribute("FlashbangEffectRenderer", "2", "Custom/FlashbangEffect", "False")]
public class FlashbangEffect : PostProcessEffectSettings {
    [RangeAttribute("0", "1")]
public FloatParameter burnIntensity;
    [RangeAttribute("0", "1")]
public FloatParameter whiteoutIntensity;
}
public class FlashbangEffectRenderer : PostProcessEffectRenderer`1<FlashbangEffect> {
    public static bool needsCapture;
    private Shader flashbangEffectShader;
    private RenderTexture screenRT;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
    public virtual void Release();
    private static void CheckCreateRenderTexture(RenderTexture& rt, string name, int width, int height, RenderTextureFormat format);
    private static void SafeDestroyRenderTexture(RenderTexture& rt);
}
public class FlashbangOverlay : MonoBehaviour {
    public static FlashbangOverlay Instance;
    public PostProcessVolume postProcessVolume;
    public AnimationCurve burnIntensityCurve;
    public AnimationCurve whiteoutIntensityCurve;
    public SoundDefinition deafLoopDef;
}
public class FlasherLight : IOEntity {
    public EmissionToggle toggler;
    public Light myLight;
    public float flashSpacing;
    public float flashBurstSpacing;
    public float flashOnTime;
    public int numFlashesPerBurst;
    public virtual void ResetState();
}
public class FlashlightBeam : MonoBehaviour {
    public Vector2 scrollDir;
    public Vector3 localEndPoint;
    public LineRenderer beamRenderer;
}
public class FlintStrikeWeapon : BaseProjectile {
    public float successFraction;
    [TooltipAttribute("By how much do we increase the chance of firing after each failed strike")]
public float successIncrease;
    public RecoilProperties strikeRecoil;
    public virtual RecoilProperties GetRecoil();
}
[ExtensionAttribute]
public static class Float4x4Ex : object {
    [ExtensionAttribute]
public static float3 ToPosition(float4x4 m);
    [ExtensionAttribute]
public static Quaternion ToRotation(float4x4 m);
}
public class FloatConditions : object {
    public Condition[] conditions;
    public bool AllTrue(float val);
}
public static class FloodedSpawnHandler : object {
    private static Int32[] SpreadSteps;
    private static FloodedSpawnHandler();
    public static bool GetSpawnPoint(SpawnPoint spawnPoint, float searchHeight);
    private static Vector3 FindSpawnPoint(float searchHeight);
    private static Vector3 Step(float angle, float distance);
    private static float RandomAngle();
}
public class FluidSwitch : ElectricSwitch {
    private Flags Flag_PumpPowered;
    public Animator PumpAnimator;
    private bool pumpEnabled;
    private int lastToggleInput;
    public bool IsGravitySource { get; }
    protected bool DisregardGravityRestrictionsOnLiquid { get; }
    public virtual void ResetState();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void SetSwitch(bool wantsOn);
    private void DelayedSendChanged();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual int ConsumptionAmount();
    public virtual bool get_IsGravitySource();
    protected virtual bool get_DisregardGravityRestrictionsOnLiquid();
    public virtual bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement);
}
public class FlybySound : MonoBehaviour {
    public SoundDefinition flybySound;
    public float flybySoundDistance;
    public SoundDefinition closeFlybySound;
    public float closeFlybyDistance;
}
public class FogMachine : ContainerIOEntity {
    public static Flags FogFieldOn;
    public static Flags MotionMode;
    public static Flags Emitting;
    public static Flags Flag_HasJuice;
    public float fogLength;
    public float nozzleBlastDuration;
    public float fuelPerSec;
    public TriggerBase motionTrigger;
    private float pendingFuel;
    public bool IsEmitting();
    public bool HasJuice();
    [RPC_Server]
[IsVisible("3")]
public void SetFogOn(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void SetFogOff(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void SetMotionDetection(RPCMessage msg);
    public void UpdateMotionMode();
    public void CheckTrigger();
    public void StartFogging();
    public virtual void EnableFogField();
    public void DisableNozzle();
    public virtual void FinishFogging();
    public virtual void PostServerLoad();
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public int GetFuelAmount();
    public bool HasFuel();
    public bool UseFuel(float seconds);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual int ConsumptionAmount();
    public virtual bool MotionModeEnabled();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class FogSettings : ValueType {
    public Gradient ColorOverDaytime;
    public float Density;
    public float StartDistance;
    public float Height;
    public float HeightDensity;
}
public class FoliageBaker : MonoBehaviour {
    public FoliageGridBaked BakedGrid;
}
public class FoliageDisplacement : MonoBehaviour {
    public bool moving;
    public bool billboard;
    public Mesh mesh;
    public Material material;
}
public class FoliageDisplacementManager : SingletonComponent`1<FoliageDisplacementManager> {
}
public class FoliageGrid : SingletonComponent`1<FoliageGrid> {
    public static bool Paused;
    public GameObjectRef BatchPrefab;
    public float CellSize;
    public LayerSelect FoliageLayer;
    public ShadowCastingMode FoliageShadows;
}
public class FoliageGridBaked : FoliageGrid {
    public BakedFoliagePlacement[] BakedData;
}
public class FoliageGridBatch : MeshBatch {
    private Vector3 position;
    private Mesh meshBatch;
    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    private FoliageGridMeshData meshData;
    private MeshGroup meshGroup;
    private bool hasRunAwake;
    public int VertexCapacity { get; }
    public int VertexCutoff { get; }
    public virtual int get_VertexCapacity();
    public virtual int get_VertexCutoff();
    protected void Awake();
    public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer);
    public void Add(MeshInstance instance);
    protected virtual void AllocMemory();
    protected virtual void FreeMemory();
    protected virtual void RefreshMesh();
    protected virtual void ApplyMesh();
    protected virtual void ToggleMesh(bool state);
    protected virtual void OnPooled();
}
public class FoliageGridBenchmarkScene : BenchmarkScene {
    private static TerrainMeta terrainMeta;
    public GameObjectRef foliagePrefab;
    private GameObject foliageInstance;
    public GameObjectRef lodPrefab;
    private GameObject lodInstance;
    public GameObjectRef batchingPrefab;
    private GameObject batchingInstance;
    public Terrain terrain;
    public Transform viewpointA;
    public Transform viewpointB;
    public bool moveVantangePoint;
}
public class FoliageGridMeshData : object {
    public List`1<FoliageVertex> vertices;
    public List`1<int> triangles;
    public Bounds bounds;
    public void Alloc();
    public void Free();
    public void Clear();
    public void Combine(MeshGroup meshGroup);
    public void Apply(Mesh mesh);
}
[CreateAssetMenuAttribute]
public class FoliagePlacement : ScriptableObject {
    [HeaderAttribute("Placement")]
public float Density;
    [HeaderAttribute("Filter")]
public SpawnFilter Filter;
    [FormerlySerializedAsAttribute("Cutoff")]
public float FilterCutoff;
    public float FilterFade;
    [FormerlySerializedAsAttribute("Scaling")]
public float FilterScaling;
    [HeaderAttribute("Randomization")]
public float RandomScaling;
    [MinMaxAttribute("0", "1")]
[HeaderAttribute("Placement Range")]
public MinMax Range;
    public float RangeFade;
    [HeaderAttribute("LOD")]
[RangeAttribute("0", "1")]
public float DistanceDensity;
    [RangeAttribute("1", "2")]
public float DistanceScaling;
    [HeaderAttribute("Visuals")]
public Material material;
    [FormerlySerializedAsAttribute("mesh")]
public Mesh mesh0;
    [FormerlySerializedAsAttribute("mesh")]
public Mesh mesh1;
    [FormerlySerializedAsAttribute("mesh")]
public Mesh mesh2;
    public static int lods;
    public static int octaves;
    public static float frequency;
    public static float amplitude;
    public static float offset;
}
public class FoliageRenderer : MonoBehaviour {
    public Material material;
    public Mesh LOD0;
    public Mesh LOD1;
}
public class FoliageSpawn : MonoBehaviour {
    public FoliagePlacement Placement;
}
public class FoliageTrigger : MonoBehaviour {
}
public class FollowCamera : MonoBehaviour {
    private void LateUpdate();
}
public class FootstepEffects : BaseFootstepEffect {
    public Transform leftFoot;
    public Transform rightFoot;
    public string footstepEffectName;
    public string jumpStartEffectName;
    public string jumpLandEffectName;
    public SoundDefinition accentSound;
}
public class FootstepSound : MonoBehaviour {
    public SoundDefinition lightSound;
    public SoundDefinition medSound;
    public SoundDefinition hardSound;
    private static float panAmount;
}
public class ForceChildSingletonSetup : MonoBehaviour {
    [ComponentHelpAttribute("Any child objects of this object that contain SingletonComponents will be registered - even if they're not enabled")]
private void Awake();
}
public class FPSGraph : Graph {
    public void Refresh();
    protected void OnEnable();
    protected virtual float GetValue();
    protected virtual Color GetColor(float value);
}
public class FpStandaloneInputModule : StandaloneInputModule {
    public PointerEventData CurrentData { get; }
    public PointerEventData get_CurrentData();
}
public class FPSText : MonoBehaviour {
    public Text text;
    private Stopwatch fpsTimer;
    protected void Update();
}
public class FrankensteinBrain : PetBrain {
    [ServerVar]
public static float MoveTowardsRate;
    private static FrankensteinBrain();
    public virtual void AddStates();
    public virtual void InitializeAI();
    public FrankensteinPet GetEntity();
    public virtual void OnDestroy();
}
public class FrankensteinPartInformationPanel : ItemInformationPanel {
    public ItemTextValue healthDisplay;
    public ItemTextValue speedDisplay;
    public ItemTextValue attackRateDisplay;
    public ItemTextValue attackDamageDisplay;
}
public class FrankensteinPet : BasePet {
    [ServerVar]
[HeaderAttribute("Frankenstein")]
public static float decayminutes;
    [HeaderAttribute("Audio")]
public SoundDefinition AttackVocalSFX;
    public float nextAttackTime;
    protected string CorpsePath { get; }
    protected bool ShouldCorpseTakeChildren { get; }
    protected bool KeepCorpseClothingIntact { get; }
    protected string OverrideCorpseName { get; }
    private static FrankensteinPet();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    [IteratorStateMachineAttribute("FrankensteinPet/<DelayEquipWeapon>d__5")]
public IEnumerator DelayEquipWeapon(ItemDefinition item, float delay);
    private void TickDecay();
    public sealed virtual float EngagementRange();
    public sealed virtual bool IsThreat(BaseEntity entity);
    public sealed virtual bool IsTarget(BaseEntity entity);
    public sealed virtual bool IsFriendly(BaseEntity entity);
    public sealed virtual bool CanAttack(BaseEntity entity);
    public sealed virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public sealed virtual bool CanSeeTarget(BaseEntity entity);
    public sealed virtual bool NeedsToReload();
    public sealed virtual bool Reload();
    public sealed virtual float CooldownDuration();
    public sealed virtual bool IsOnCooldown();
    public sealed virtual bool StartAttacking(BaseEntity target);
    private void Attack(BaseCombatEntity target);
    public sealed virtual void StopAttacking();
    public sealed virtual float GetAmmoFraction();
    public sealed virtual BaseEntity GetBestTarget();
    public sealed virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
    public virtual bool ShouldDropActiveItem();
    protected virtual string get_CorpsePath();
    protected virtual bool get_ShouldCorpseTakeChildren();
    protected virtual bool get_KeepCorpseClothingIntact();
    protected virtual string get_OverrideCorpseName();
}
public class FrankensteinTable : StorageContainer {
    public GameObjectRef FrankensteinPrefab;
    public Transform SpawnLocation;
    public ItemDefinition WeaponItem;
    public List`1<ItemDefinition> HeadItems;
    public List`1<ItemDefinition> TorsoItems;
    public List`1<ItemDefinition> LegItems;
    [HideInInspector]
public List`1<ItemDefinition> ItemsToUse;
    public FrankensteinTableVisuals TableVisuals;
    [HeaderAttribute("Timings")]
public float TableDownDuration;
    private bool waking;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsHeadItem(ItemDefinition itemDef);
    public bool IsTorsoItem(ItemDefinition itemDef);
    public bool IsLegsItem(ItemDefinition itemDef);
    public bool HasValidItems(ItemContainer container);
    public List`1<ItemDefinition> GetValidItems(ItemContainer container);
    public bool HasAllValidItems(List`1<ItemDefinition> items);
    private void CheckItem(ItemDefinition item, List`1<ItemDefinition> itemList, List`1<ItemDefinition> validItems, Boolean& set);
    public virtual void ServerInit();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    private bool CanAcceptItem(Item item, int targetSlot);
    [RPC_Server]
[MaxDistance("3")]
private void CreateFrankenstein(RPCMessage msg);
    private bool CanStartCreating(BasePlayer player);
    private bool IsInventoryEmpty();
    private void ConsumeInventory();
    [RPC_Server]
[MaxDistance("3")]
private void RequestWakeFrankenstein(RPCMessage msg);
    private void WakeFrankenstein(BasePlayer owner);
    [IteratorStateMachineAttribute("FrankensteinTable/<DelayWakeFrankenstein>d__27")]
private IEnumerator DelayWakeFrankenstein(BasePlayer owner);
    private void EquipFrankenstein(FrankensteinPet frank);
    [MaxDistance("3")]
[RPC_Server]
private void RequestSleepFrankenstein(RPCMessage msg);
    private void SleepFrankenstein(BasePlayer owner);
    private void ReturnFrankensteinItems(FrankensteinPet frank);
    [IteratorStateMachineAttribute("FrankensteinTable/<WaitForFrankensteinBrainInit>d__32")]
private IEnumerator WaitForFrankensteinBrainInit(BasePet frankenstein, BasePlayer player);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class FrankensteinTableVisuals : MonoBehaviour {
    public GameObject FXReady;
    public GameObject FXNotReady;
    public GameObject FXWake;
    public Transform HeadVisualAnchor;
    public Transform TorsoVisualAnchor;
    public Transform LegsVisualAnchor;
    public Animator Animator;
}
public class FreeableLootContainer : LootContainer {
    private static Flags tiedDown;
    public Buoyancy buoyancy;
    public GameObjectRef freedEffect;
    private Rigidbody rb;
    public UInt32 skinOverride;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public Rigidbody GetRB();
    public bool IsTiedDown();
    public virtual void ServerInit();
    public virtual void OnAttacked(HitInfo info);
    public void Release(BasePlayer ply);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_FreeCrate(RPCMessage msg);
}
public class FrequencyConfig : IOConfig`1<IRFObject> {
}
[PostProcessAttribute("FrostRenderer", "2", "Custom/Frost", "True")]
public class Frost : PostProcessEffectSettings {
    [RangeAttribute("0", "16")]
public FloatParameter scale;
    public BoolParameter enableVignette;
    [RangeAttribute("0", "100")]
public FloatParameter sharpness;
    [RangeAttribute("0", "100")]
public FloatParameter darkness;
}
public class FrostRenderer : PostProcessEffectRenderer`1<Frost> {
    private int scaleProperty;
    private int sharpnessProperty;
    private int darknessProperty;
    private Shader frostShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class FruitScale : MonoBehaviour {
    public void SetProgress(float progress);
}
public class FuelElectricGenerator : IOEntity {
    public float electricAmount;
}
public class FuelGenerator : ContainerIOEntity {
    public int outputEnergy;
    public float fuelPerSec;
    protected float fuelTickRate;
    private float pendingFuel;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool IsRootEntity();
    public virtual int MaximalPowerOutput();
    public virtual int ConsumptionAmount();
    public virtual void Init();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    public void UpdateCurrentEnergy();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool AllowDrainFrom(int outputSlot);
    [IsVisible("3")]
[RPC_Server]
public void RPC_EngineSwitch(RPCMessage msg);
    public void SetGeneratorState(bool wantsOn);
    public int GetFuelAmount();
    public bool HasFuel();
    public bool UseFuel(float seconds);
    public void TurnOn();
    public void FuelConsumption();
    public void TurnOff();
}
public class FuseBox : IOEntity {
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
}
[AddComponentMenu("Image Effects/FXAA")]
public class FXAA : FXAAPostEffectsBase {
    public Shader shader;
    private Material mat;
    private void CreateMaterials();
    private void Start();
    public sealed virtual bool IsActive();
    public sealed virtual void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class FXAAPostEffectsBase : MonoBehaviour {
    protected bool supportHDRTextures;
    protected bool isSupported;
    public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create);
    private Material CreateMaterial(Shader s, Material m2Create);
    private void OnEnable();
    private bool CheckSupport();
    private bool CheckResources();
    private void Start();
    public bool CheckSupport(bool needDepth);
    private bool CheckSupport(bool needDepth, bool needHdr);
    private void ReportAutoDisable();
    private bool CheckShader(Shader s);
    private void NotSupported();
    private void DrawBorder(RenderTexture dest, Material material);
}
public class GameContentList : MonoBehaviour {
    public ResourceType resourceType;
    public List`1<Object> foundObjects;
}
public class GameManager : object {
    public static GameManager server;
    public PrefabPreProcess preProcessed;
    public PrefabPoolCollection pool;
    public bool Clientside;
    public bool Serverside;
    public GameManager(bool clientside, bool serverside);
    private static GameManager();
    public void Reset();
    public GameObject FindPrefab(UInt32 prefabID);
    public GameObject FindPrefab(BaseEntity ent);
    public GameObject FindPrefab(string strPrefab);
    public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, Vector3 scale, bool active);
    public GameObject CreatePrefab(string strPrefab, Vector3 pos, Quaternion rot, bool active);
    public GameObject CreatePrefab(string strPrefab, bool active);
    public GameObject CreatePrefab(string strPrefab, Transform parent, bool active);
    public BaseEntity CreateEntity(string strPrefab, Vector3 pos, Quaternion rot, bool startActive);
    private GameObject Instantiate(string strPrefab, Vector3 pos, Quaternion rot);
    public static void Destroy(Component component, float delay);
    public static void Destroy(GameObject instance, float delay);
    public static void DestroyImmediate(Component component, bool allowDestroyingAssets);
    public static void DestroyImmediate(GameObject instance, bool allowDestroyingAssets);
    public void Retire(GameObject instance);
}
public class GameManifest : ScriptableObject {
    internal static GameManifest loadedManifest;
    public static Dictionary`2<string, string> guidToPath;
    public static Dictionary`2<string, string> pathToGuid;
    public static Dictionary`2<string, Object> guidToObject;
    public PooledString[] pooledStrings;
    public PrefabProperties[] prefabProperties;
    public EffectCategory[] effectCategories;
    public GuidPath[] guidPaths;
    public String[] entities;
    public static GameManifest Current { get; }
    private static GameManifest();
    public static GameManifest get_Current();
    public static void Load();
    public static void LoadAssets();
    internal static Dictionary`2<string, String[]> LoadEffectDictionary();
    internal static string GUIDToPath(string guid);
    internal static Object GUIDToObject(string guid);
    public static void Invalidate(string path);
    private static string GetMetadataStatus();
    private static string GetAssetStatus();
}
public class GameModeCapturePoint : BaseEntity {
    public CapturePointTrigger captureTrigger;
    public float timeToCapture;
    public int scorePerSecond;
    public string scoreName;
    private float captureFraction;
    private int captureTeam;
    private int capturingTeam;
    public EntityRef capturingPlayer;
    public EntityRef capturedPlayer;
    public static Flags Flag_Contested;
    public RustText capturePointText;
    public RustText captureOwnerName;
    public Image captureProgressImage;
    public GameObjectRef progressBeepEffect;
    public GameObjectRef progressCompleteEffect;
    public Transform computerPoint;
    private float nextBeepTime;
    public bool IsContested();
    public virtual void ServerInit();
    public void Update();
    public void AssignPoints();
    public void DoCaptureEffect();
    public void DoProgressEffect();
    public void UpdateCaptureAmount();
    public virtual void Save(SaveInfo info);
}
public class GameModeHardcore : GameModeVanilla {
    protected virtual void OnCreated();
    public virtual ResearchCostResult GetScrapCostForResearch(ItemDefinition item, ResearchType researchType);
}
[CreateAssetMenuAttribute]
public class GameModeManifest : ScriptableObject {
    public static GameModeManifest instance;
    public List`1<GameObjectRef> gameModePrefabs;
    public static GameModeManifest Get();
}
public class GameModeObjectToggle : BaseMonoBehaviour {
    public String[] gameModeTags;
    public String[] tagsToDisable;
    public GameObject[] toToggle;
    public bool defaultState;
    public void Awake();
    public void OnDestroy();
    public void OnGameModeChanged(BaseGameMode newGameMode);
    public void SetToggle(bool wantsOn);
    public bool ShouldBeVisible(BaseGameMode newGameMode);
}
public class GameModeSoftcore : GameModeVanilla {
    public GameObjectRef reclaimManagerPrefab;
    public GameObjectRef reclaimBackpackPrefab;
    public static Phrase ReclaimToast;
    public ItemAmount[] startingGear;
    [ServerVar]
public static float reclaim_fraction_belt;
    [ServerVar]
public static float reclaim_fraction_wear;
    [ServerVar]
public static float reclaim_fraction_main;
    private static GameModeSoftcore();
    protected virtual void OnCreated();
    public void AddFractionOfContainer(ItemContainer from, List`1& to, float fraction, bool takeLastItem);
    public List`1<Item> RemoveItemsFrom(ItemContainer itemContainer, ItemAmount[] types);
    public void ReturnItemsTo(List`1& source, ItemContainer itemContainer);
    public virtual void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo);
    public virtual void OnPlayerRespawn(BasePlayer player);
    public virtual SleepingBag[] FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers);
    public virtual float CorpseRemovalTime(BaseCorpse corpse);
    public void SetInventoryLocked(BasePlayer player, bool wantsLocked);
    public virtual void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info);
    public virtual void OnPlayerRevived(BasePlayer instigator, BasePlayer victim);
    public virtual bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item);
}
public class GameModeSpawnGroup : SpawnGroup {
    public String[] gameModeTags;
    public void ResetSpawnGroup();
    public bool ShouldSpawn();
    protected virtual void Spawn(int numToSpawn);
}
public class GameModeVanilla : BaseGameMode {
}
public class GameObjectLOD : LODComponent {
    public float Distance;
    public GameObject TargetGameObject;
}
public class GameObjectRef : ResourceRef`1<GameObject> {
    public GameObject Instantiate(Transform parent);
    public BaseEntity GetEntity();
}
[FlagsAttribute]
public enum GameObjectTag : Enum {
    public int value__;
    public static GameObjectTag AllowBarricadePlacement;
    public static GameObjectTag Road;
    public static GameObjectTag BlockBarricadePlacement;
    public static GameObjectTag BlockPlacement;
}
public class GameObjectToggleState : StateMachineBehaviour {
    public bool UseCurve;
    [TooltipAttribute("The normalised range in the animation in which to apply the TargetState")]
[MinMaxAttribute("0", "1")]
public Vector2 ValidNormalisedRange;
    public AnimationCurve CurveRange;
    [TooltipAttribute("What state to set the target object to, true = enabled, false = disabled")]
public bool TargetState;
    [TooltipAttribute("What gameObject to toggle (ensure it's a unique name in the hierarchy)")]
public string GameObjectName;
    public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public static class GameObjectUtil : object {
    public static void GlobalBroadcast(string messageName, object param);
}
public static class GamePhysics : object {
    public static int BufferLength;
    private static RaycastHit[] hitBuffer;
    private static RaycastHit[] hitBufferB;
    private static Collider[] colBuffer;
    private static GamePhysics();
    public static bool CheckSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckOBBAndEntity(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity);
    public static bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckInsideNonConvexMesh(Vector3 point, int layerMask);
    public static bool CheckInsideAnyCollider(Vector3 point, int layerMask);
    public static void OverlapSphere(Vector3 position, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool OverlapSphere(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void CapsuleSweep(Vector3 position0, Vector3 position1, float radius, Vector3 direction, float distance, List`1<RaycastHit> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapOBB(OBB obb, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapBounds(Bounds bounds, List`1<Collider> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    private static void BufferToList(Collider[] buffer, int count, List`1<Collider> list);
    public static bool CheckSphere(Vector3 pos, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckOBB(OBB obb, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool CheckBounds(Bounds bounds, int layerMask, QueryTriggerInteraction triggerInteraction);
    private static bool CheckComponent(List`1<Collider> list);
    public static void OverlapSphere(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapCapsule(Vector3 point0, Vector3 point1, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapOBB(OBB obb, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void OverlapBounds(Bounds bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    private static void BufferToList(Collider[] buffer, int count, List`1<T> list);
    private static void HitBufferToList(int count, List`1<RaycastHit> list);
    public static bool Trace(Ray ray, float radius, RaycastHit& hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity);
    public static void TraceAll(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity);
    public static void TraceAllUnordered(Ray ray, float radius, List`1<RaycastHit> hits, float maxDistance, int layerMask, QueryTriggerInteraction triggerInteraction, BaseEntity ignoreEntity);
    public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity);
    public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding, BaseEntity ignoreEntity);
    public static bool LineOfSightRadius(Vector3 p0, Vector3 p1, int layerMask, float radius, BaseEntity ignoreEntity);
    public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding0, float padding1, BaseEntity ignoreEntity);
    public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, float padding, BaseEntity ignoreEntity);
    public static bool LineOfSight(Vector3 p0, Vector3 p1, int layerMask, BaseEntity ignoreEntity);
    private static bool LineOfSightInternal(Vector3 p0, Vector3 p1, int layerMask, float radius, float padding0, float padding1, BaseEntity ignoreEntity);
    public static bool Verify(RaycastHit hitInfo, Vector3 rayOrigin, BaseEntity ignoreEntity);
    public static bool Verify(Collider collider, Vector3 point, BaseEntity ignoreEntity);
    public static bool CompareEntity(BaseEntity a, BaseEntity b);
    public static int HandleIgnoreCollision(Vector3 position, int layerMask);
    public static void Sort(List`1<RaycastHit> hits);
    public static void Sort(RaycastHit[] hits);
}
public class GameSetup : MonoBehaviour {
    public static bool RunOnce;
    public bool startServer;
    public string clientConnectCommand;
    public bool loadMenu;
    public bool loadLevel;
    public string loadLevelScene;
    public bool loadSave;
    public string loadSaveFile;
    public string initializationCommands;
    public bool normalRendering;
    protected void Awake();
    [IteratorStateMachineAttribute("GameSetup/<DoGameSetup>d__11")]
private IEnumerator DoGameSetup();
    [IteratorStateMachineAttribute("GameSetup/<StartServer>d__12")]
private IEnumerator StartServer();
}
public class GameStat : MonoBehaviour {
    public float refreshTime;
    public Text title;
    public Text globalStat;
    public Text localStat;
    private long globalValue;
    private long localValue;
    private float secondsSinceRefresh;
    private float secondsUntilUpdate;
    private float secondsUntilChange;
    public Stat[] stats;
}
public class GameTip : SingletonComponent`1<GameTip> {
    public Canvas canvas;
    public CanvasGroup canvasGroup;
    public RustIcon icon;
    public Image background;
    public RustText text;
    public Theme[] themes;
}
public abstract class GameTips.BaseTip : object {
    public bool ShouldShow { get; }
    public string Type { get; }
    public bool CanShowInTutorial { get; }
    protected bool PlayerIsInTutorial { get; }
    public abstract virtual Phrase GetPhrase();
    public abstract virtual bool get_ShouldShow();
    public string get_Type();
    public virtual bool get_CanShowInTutorial();
    protected bool get_PlayerIsInTutorial();
}
public class GeigerCounter : AttackEntity {
    public Transform geigerRod;
}
public class GenerateBiome : ProceduralComponent {
    public static void Native_GenerateBiome(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, Int16[] heightmap, int heightres);
    public virtual void Process(UInt32 seed);
}
public class GenerateCliffSplat : ProceduralComponent {
    private static int filter;
    public static void Process(int x, int z);
    public virtual void Process(UInt32 seed);
}
public class GenerateCliffTopology : ProceduralComponent {
    public bool KeepExisting;
    private static float slopeCutoff;
    private static float splatCutoff;
    private static int filter;
    public static void Process(int x, int z);
    private static void Process(int x, int z, bool keepExisting);
    public virtual void Process(UInt32 seed);
}
public class GenerateClutterTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public static class Generated.AnimatorController.PlayerMenuAnimation : object {
}
public class GenerateDecorTopology : ProceduralComponent {
    public bool KeepExisting;
    public virtual void Process(UInt32 seed);
}
public class GenerateDungeonBase : ProceduralComponent {
    public string EntranceFolder;
    public string LinkFolder;
    public string EndFolder;
    public string TransitionFolder;
    public InfrastructureType ConnectionType;
    private static Vector3 VolumeExtrudePositive;
    private static Vector3 VolumeExtrudeNegative;
    private static int MaxCount;
    private static int MaxDepth;
    private static int MaxFloor;
    private List`1<DungeonSegment> segmentsTotal;
    private Quaternion[] horizontalRotations;
    private Quaternion[] pillarRotations;
    private Quaternion[] verticalRotations;
    public bool RunOnCache { get; }
    private static GenerateDungeonBase();
    public virtual bool get_RunOnCache();
    public virtual void Process(UInt32 seed);
    private Quaternion[] GetRotationList(DungeonBaseSocketType type);
    private int GetSocketFloor(DungeonBaseSocketType type);
    private bool IsFullyOccupied(List`1<DungeonSegment> segments, DungeonSegment segment);
    private bool NeighbourMatches(List`1<DungeonSegment> segments, DungeonBaseTransition transition, Vector3 transitionPos, Quaternion transitionRot);
    private int SocketMatches(List`1<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot);
    private bool IsOccupied(List`1<DungeonSegment> segments, DungeonBaseSocket socket, Vector3 socketPos, Quaternion socketRot);
    private int CountLocal(List`1<DungeonSegment> segments, DungeonBaseLink link);
    private int CountGlobal(List`1<DungeonSegment> segments, DungeonBaseLink link);
    private bool IsBlocked(List`1<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot);
    private void PlaceSegments(UInt32& seed, int count, int budget, int floors, bool attachToFemale, bool attachToMale, List`1<DungeonSegment> segments, Prefab`1[] prefabs);
    private void PlaceTransitions(UInt32& seed, List`1<DungeonSegment> segments, Prefab`1[] prefabs);
    private bool Place(UInt32& seed, List`1<DungeonSegment> segments, DungeonBaseSocket targetSocket, Vector3 targetPos, Quaternion targetRot, Prefab`1<DungeonBaseLink> prefab, Quaternion[] rotations, DungeonBaseSocket& linkSocket, Vector3& linkPos, Quaternion& linkRot, Int32& linkScore);
    public static void SetupAI();
}
public class GenerateDungeonGrid : ProceduralComponent {
    public string TunnelFolder;
    public string StationFolder;
    public string UpwardsFolder;
    public string TransitionFolder;
    public string LinkFolder;
    public InfrastructureType ConnectionType;
    public int CellSize;
    public float LinkHeight;
    public float LinkRadius;
    public float LinkTransition;
    private static int MaxDepth;
    public bool RunOnCache { get; }
    public virtual bool get_RunOnCache();
    public virtual void Process(UInt32 seed);
    private float GetDistanceToAboveGroundRail(Vector3 pos);
}
public class GenerateErosion : ProceduralComponent {
    public virtual void Process(UInt32 seed);
    [CompilerGeneratedAttribute]
internal static float <Process>g__CalculateDelta|0_0(Single[] data, int res, int x, int z, float cntr, float side, float diag);
}
public class GenerateHeight : ProceduralComponent {
    public static void Native_GenerateHeight(Int16[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic);
    public virtual void Process(UInt32 seed);
}
public class GenerateOceanTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class GeneratePowerlineLayout : ProceduralComponent {
    private static int MaxDepth;
    public virtual void Process(UInt32 seed);
}
public class GeneratePowerlineTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class GenerateRailBranching : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static Quaternion rot90;
    private static int MaxDepth;
    private static GenerateRailBranching();
    private PathList CreateSegment(int number, Vector3[] points);
    public virtual void Process(UInt32 seed);
}
public class GenerateRailLayout : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static Quaternion rot90;
    private static int MaxDepth;
    private static GenerateRailLayout();
    private PathList CreateSegment(int number, Vector3[] points);
    public virtual void Process(UInt32 seed);
    [CompilerGeneratedAttribute]
internal static float <Process>g__DistanceToRail|13_0(Vector3 vec);
}
public class GenerateRailMeshes : ProceduralComponent {
    public static float NormalSmoothing;
    public static bool SnapToTerrain;
    public Mesh RailMesh;
    public Mesh[] RailMeshes;
    public Material RailMaterial;
    public PhysicMaterial RailPhysicMaterial;
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
    private void AddTrackSpline(PathList rail);
}
public class GenerateRailRing : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static int MaxDepth;
    public int MinWorldSize;
    public virtual void Process(UInt32 seed);
}
public class GenerateRailSiding : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static Quaternion rotRight;
    private static Quaternion rotLeft;
    private static int MaxDepth;
    private static GenerateRailSiding();
    private PathList CreateSegment(int number, Vector3[] points);
    public virtual void Process(UInt32 seed);
}
public class GenerateRailTerrain : ProceduralComponent {
    public static int SmoothenLoops;
    public static int SmoothenIterations;
    public static int SmoothenY;
    public static int SmoothenXZ;
    public static int TransitionSteps;
    private float AdjustTerrainFade(float xn, float zn);
    private float SmoothenFilter(PathList path, int index);
    public virtual void Process(UInt32 seed);
}
public class GenerateRailTexture : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class GenerateRailTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
    private void MarkRailside();
}
public class GenerateRiverLayout : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static Quaternion rot90;
    private static GenerateRiverLayout();
    public virtual void Process(UInt32 seed);
}
public class GenerateRiverMeshes : ProceduralComponent {
    public static float NormalSmoothing;
    public static bool SnapToTerrain;
    public Mesh RiverMesh;
    public Mesh[] RiverMeshes;
    public Material RiverMaterial;
    public PhysicMaterial RiverPhysicMaterial;
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class GenerateRiverTerrain : ProceduralComponent {
    public static int SmoothenLoops;
    public static int SmoothenIterations;
    public static int SmoothenY;
    public static int SmoothenXZ;
    public virtual void Process(UInt32 seed);
}
public class GenerateRiverTexture : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class GenerateRiverTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
    public void MarkRiverside();
}
public class GenerateRoadLayout : ProceduralComponent {
    public InfrastructureType RoadType;
    public static float RoadWidth;
    public static float TrailWidth;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static int MaxDepth;
    private PathList CreateSegment(int number, Vector3[] points);
    public virtual void Process(UInt32 seed);
}
public class GenerateRoadMeshes : ProceduralComponent {
    public static float NormalSmoothing;
    public static bool SnapToTerrain;
    public Mesh RoadMesh;
    public Mesh[] RoadMeshes;
    public Material RoadMaterial;
    public Material RoadRingMaterial;
    public PhysicMaterial RoadPhysicMaterial;
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class GenerateRoadRing : ProceduralComponent {
    public static float Width;
    public static float InnerPadding;
    public static float OuterPadding;
    public static float InnerFade;
    public static float OuterFade;
    public static float RandomScale;
    public static float MeshOffset;
    public static float TerrainOffset;
    private static int MaxDepth;
    public int MinWorldSize;
    public virtual void Process(UInt32 seed);
}
public class GenerateRoadTerrain : ProceduralComponent {
    public static int SmoothenLoops;
    public static int SmoothenIterations;
    public static int SmoothenY;
    public static int SmoothenXZ;
    private float SmoothenFilter(PathList path, int index);
    public virtual void Process(UInt32 seed);
}
public class GenerateRoadTexture : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class GenerateRoadTopology : ProceduralComponent {
    public virtual void Process(UInt32 seed);
    private void MarkRoadside();
}
public class GenerateSplat : ProceduralComponent {
    public static void Native_GenerateSplat(Byte[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float biomeAngle, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres, Int32[] topologymap, int topologyres);
    public virtual void Process(UInt32 seed);
}
public class GenerateTerrainMesh : ProceduralComponent {
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class GenerateTextures : ProceduralComponent {
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class GenerateTopology : ProceduralComponent {
    public static void Native_GenerateTopology(Int32[] map, int res, Vector3 pos, Vector3 size, UInt32 seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, Int16[] heightmap, int heightres, Byte[] biomemap, int biomeres);
    public virtual void Process(UInt32 seed);
}
public class GenerateWireMeshes : ProceduralComponent {
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class GenericSpawnPoint : BaseSpawnPoint {
    public bool dropToGround;
    public bool randomRot;
    [RangeAttribute("1", "180")]
public float randomRotSnapDegrees;
    public GameObjectRef spawnEffect;
    public UnityEvent OnObjectSpawnedEvent;
    public UnityEvent OnObjectRetiredEvent;
    public Quaternion GetRandomRotation();
    public virtual void GetLocation(Vector3& pos, Quaternion& rot);
    public virtual void ObjectSpawned(SpawnPointInstance instance);
    public virtual void ObjectRetired(SpawnPointInstance instance);
}
[CreateAssetMenuAttribute]
public class GestureCollection : ScriptableObject {
    public static UInt32 HeavyLandingId;
    public GestureConfig[] AllGestures;
    public float GestureVmInDuration;
    public AnimationCurve GestureInCurve;
    public float GestureVmOutDuration;
    public AnimationCurve GestureOutCurve;
    public float GestureViewmodelDeployDelay;
    private static GestureCollection();
    public GestureConfig IdToGesture(UInt32 id);
    public GestureConfig StringToGesture(string gestureName);
}
[CreateAssetMenuAttribute]
public class GestureConfig : ScriptableObject {
    [ReadOnlyAttribute]
public UInt32 gestureId;
    public string gestureCommand;
    public string convarName;
    public Phrase gestureName;
    public Phrase gestureDescription;
    public Sprite icon;
    public int order;
    public float duration;
    public bool canCancel;
    [HeaderAttribute("Player model setup")]
public PlayerModelLayer playerModelLayer;
    public GestureType gestureType;
    public bool hideHeldEntity;
    public bool canDuckDuringGesture;
    public bool hideInWheel;
    public bool hasViewmodelAnimation;
    public float viewmodelHolsterDelay;
    public MovementCapabilities movementMode;
    public AnimationType animationType;
    public CameraMode viewMode;
    public bool useRootMotion;
    public bool forceForwardRotation;
    [HeaderAttribute("Ownership")]
public GestureActionType actionType;
    public bool forceUnlock;
    public SteamDLCItem dlcItem;
    public SteamInventoryItem inventoryItem;
    public bool IsOwnedBy(BasePlayer player);
    public bool CanBeUsedBy(BasePlayer player);
}
public class GestureDoor : Door {
    public GestureConfig OpenGesture;
    public GestureConfig KickGesture;
    public float KickAnimationDelay;
    public float PushAnimationDelay;
    public float WeaponAdditiveDelay;
    private bool wasKick;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    protected virtual void OnPlayerOpenedDoor(BasePlayer p);
    protected virtual bool ShouldDelayOpen(BasePlayer player, Single& delay);
    [MaxDistance("3")]
[RPC_Server]
private void ServerKick(RPCMessage msg);
}
public class GhostSheetSystemSpaceUpdater : MonoBehaviour {
    private EZSoftBone[] ezSoftBones;
    private BasePlayer player;
    public void Awake();
    public void Update();
    private void SetSimulateSpace(Transform transform, bool collisionEnabled);
}
public class Gib : ListComponent`1<Gib> {
    public static int gibCount;
    public MeshFilter _meshFilter;
    public MeshRenderer _meshRenderer;
    public MeshCollider _meshCollider;
    public BoxCollider _boxCollider;
    public SphereCollider _sphereCollider;
    public CapsuleCollider _capsuleCollider;
    public Rigidbody _rigidbody;
    public static string GetEffect(PhysicMaterial physicMaterial);
}
public class Gibbable : PrefabAttribute {
    public GameObject gibSource;
    public Material[] customMaterials;
    public GameObject materialSource;
    public bool copyMaterialBlock;
    public bool applyDamageTexture;
    public PhysicMaterial physicsMaterial;
    public GameObjectRef fxPrefab;
    public bool spawnFxPrefab;
    [TooltipAttribute("If enabled, gibs will spawn even though we've hit a gib limit")]
public bool important;
    public bool useContinuousCollision;
    public float explodeScale;
    public float scaleOverride;
    [ReadOnlyAttribute]
public int uniqueId;
    public BoundsEffectType boundsEffectType;
    public bool isConditional;
    [ReadOnlyAttribute]
public Bounds effectBounds;
    public List`1<OverrideMesh> MeshOverrides;
    public bool UsePerGibWaterCheck;
    protected virtual Type GetIndexedType();
}
public class GingerbreadBrain : BaseAIBrain {
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
}
public class GingerbreadNPC : HumanNPC {
    public GameObjectRef OverrideCorpseMale;
    public GameObjectRef OverrideCorpseFemale;
    public PhysicMaterial HitMaterial;
    public bool RoamAroundHomePoint;
    protected string CorpsePath { get; }
    protected string OverrideCorpseName { get; }
    protected bool ShouldCorpseTakeChildren { get; }
    protected bool KeepCorpseClothingIntact { get; }
    protected bool CopyInventoryToCorpse { get; }
    protected string CorpseResourcePath { get; }
    public virtual void OnAttacked(HitInfo info);
    public virtual string Categorize();
    public virtual bool ShouldDropActiveItem();
    protected virtual string get_CorpsePath();
    protected virtual string get_OverrideCorpseName();
    protected virtual bool get_ShouldCorpseTakeChildren();
    protected virtual bool get_KeepCorpseClothingIntact();
    protected virtual bool get_CopyInventoryToCorpse();
    public virtual void AttackerInfo(DeathInfo info);
    protected string get_CorpseResourcePath();
    public sealed virtual void OnClientStateChanged(AIState state);
    [CompilerGeneratedAttribute]
internal static float <get_CorpseResourcePath>g__GetFloatBasedOnUserID|19_0(ulong steamid, ulong seed);
}
public static class GizmosUtil : object {
    public static void DrawWireCircleX(Vector3 pos, float radius);
    public static void DrawWireCircleY(Vector3 pos, float radius);
    public static void DrawWireCircleZ(Vector3 pos, float radius);
    public static void DrawCircleX(Vector3 pos, float radius);
    public static void DrawCircleY(Vector3 pos, float radius);
    public static void DrawCircleZ(Vector3 pos, float radius);
    public static void DrawWireCylinderX(Vector3 pos, float radius, float height);
    public static void DrawWireCylinderY(Vector3 pos, float radius, float height);
    public static void DrawWireCylinderZ(Vector3 pos, float radius, float height);
    public static void DrawCylinderX(Vector3 pos, float radius, float height);
    public static void DrawCylinderY(Vector3 pos, float radius, float height);
    public static void DrawCylinderZ(Vector3 pos, float radius, float height);
    public static void DrawWireCapsuleX(Vector3 pos, float radius, float height);
    public static void DrawWireCapsuleY(Vector3 pos, float radius, float height);
    public static void DrawWireCapsuleZ(Vector3 pos, float radius, float height);
    public static void DrawCapsuleX(Vector3 pos, float radius, float height);
    public static void DrawCapsuleY(Vector3 pos, float radius, float height);
    public static void DrawCapsuleZ(Vector3 pos, float radius, float height);
    public static void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot);
    public static void DrawCube(Vector3 pos, Vector3 size, Quaternion rot);
    public static void DrawWirePath(Vector3 a, Vector3 b, float thickness);
    public static void DrawSemiCircle(float radius);
    public static void DrawArrowHead(Vector3 pos, Vector3 dir, float arrowHeadLength, float arrowHeadAngle);
    public static void DrawMeshes(Transform transform);
    public static void DrawBounds(Transform transform);
}
public class GlassPane : BaseMonoBehaviour {
    public Renderer glassRendereer;
    [SerializeField]
private BaseVehicleModule module;
    [SerializeField]
private float showFullDamageAt;
}
public class GlobalMessages : object {
}
public class GlobalNetworkHandler : PointEntity {
    public static GlobalNetworkHandler server;
    public Dictionary`2<NetworkableId, GlobalEntityData> serverData;
    private List`1<Connection> globalConnections;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public static bool ShouldSendEntity(BaseEntity entity);
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public void OnClientConnected(Connection connection);
    public void OnClientDisconnected(Connection connection);
    private void LoadEntitiesOnStartup();
    public void TrySendNetworkUpdate(BaseNetworkable net);
    private void OnEntityUpdate(BaseEntity entity, bool sendNetworkUpdate);
    public void OnEntityKilled(BaseNetworkable entity);
    public void StartSendingSnapshot(BasePlayer player);
    private void SendSnapshot(BasePlayer player);
    private void SendEntityDelete(NetworkableId networkableId, SendInfo info);
    private void SendGlobalEntities(GlobalEntityCollection entities, SendInfo info);
    private void SendGlobalEntity(GlobalEntityData entity, SendInfo info);
}
[PostProcessAttribute("GodRaysRenderer", "1", "Custom/GodRays", "True")]
public class GodRays : PostProcessEffectSettings {
    public BoolParameter UseDepth;
    public BlendModeTypeParameter BlendMode;
    public FloatParameter Intensity;
    public ResolutionTypeParameter Resolution;
    public IntParameter BlurIterations;
    public FloatParameter BlurRadius;
    public FloatParameter MaxRadius;
}
public class GodRaysRenderer : PostProcessEffectRenderer`1<GodRays> {
    private static int PASS_SCREEN;
    private static int PASS_ADD;
    public Shader GodRayShader;
    public Shader ScreenClearShader;
    public Shader SkyMaskShader;
    public virtual void Init();
    private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1);
    private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius);
    public virtual void Render(PostProcessRenderContext context);
}
public class GranularAudioClip : MonoBehaviour {
    public AudioClip sourceClip;
    private Single[] sourceAudioData;
    private int sourceChannels;
    public AudioClip granularClip;
    public int sampleRate;
    public float sourceTime;
    public float sourceTimeVariation;
    public float grainAttack;
    public float grainSustain;
    public float grainRelease;
    public float grainFrequency;
    public int grainAttackSamples;
    public int grainSustainSamples;
    public int grainReleaseSamples;
    public int grainFrequencySamples;
    public int samplesUntilNextGrain;
    public List`1<Grain> grains;
    private Random random;
    private bool inited;
    private void Update();
    private void RefreshCachedData();
    private void InitAudioClip();
    private void OnAudioRead(Single[] data);
    private void SpawnGrain();
    private void CleanupFinishedGrains();
}
public abstract class Graph : MonoBehaviour {
    public Material Material;
    public int Resolution;
    public Vector2 ScreenFill;
    public Vector2 ScreenOrigin;
    public Vector2 Pivot;
    public Rect Area;
    internal float CurrentValue;
    private int index;
    private Single[] values;
    private float max;
    protected abstract virtual float GetValue();
    protected abstract virtual Color GetColor(float value);
    protected Vector3 GetVertex(float x, float y);
    protected void Update();
    protected void OnGUI();
}
public class GraveyardFence : SimpleBuildingBlock {
    public BoxCollider[] pillars;
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public virtual void UpdatePillars();
}
public class GrenadeWeapon : ThrownWeapon {
}
[PostProcessAttribute("GreyScaleRenderer", "2", "Custom/GreyScale", "True")]
public class GreyScale : PostProcessEffectSettings {
    [RangeAttribute("0", "1")]
public FloatParameter redLuminance;
    [RangeAttribute("0", "1")]
public FloatParameter greenLuminance;
    [RangeAttribute("0", "1")]
public FloatParameter blueLuminance;
    [RangeAttribute("0", "1")]
public FloatParameter amount;
    [ColorUsageAttribute("False", "True")]
public ColorParameter color;
}
public class GreyScaleRenderer : PostProcessEffectRenderer`1<GreyScale> {
    private int dataProperty;
    private int colorProperty;
    private Shader greyScaleShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class GridLayoutGroupNeat : GridLayoutGroup {
    private float IdealCellWidth(float cellSize);
    public virtual void SetLayoutHorizontal();
    public virtual void SetLayoutVertical();
}
public abstract class GroundVehicle : BaseVehicle {
    [HeaderAttribute("GroundVehicle")]
[SerializeField]
protected GroundVehicleAudio gvAudio;
    [SerializeField]
private GameObjectRef fuelStoragePrefab;
    [SerializeField]
public Transform waterloggedPoint;
    [SerializeField]
public GameObjectRef collisionEffect;
    [SerializeField]
public float engineStartupTime;
    [SerializeField]
private float minCollisionDamageForce;
    [SerializeField]
private float maxCollisionDamageForce;
    [SerializeField]
private float collisionDamageMultiplier;
    [SerializeField]
private Rigidbody secondaryRigidbody;
    [CompilerGeneratedAttribute]
private Vector3 <Velocity>k__BackingField;
    public VehicleEngineController`1<GroundVehicle> engineController;
    private Dictionary`2<BaseEntity, float> damageSinceLastTick;
    private float nextCollisionDamageTime;
    private float dragMod;
    private float dragModDuration;
    private TimeSince timeSinceDragModSet;
    public Vector3 Velocity { get; private set; }
    public float DriveWheelVelocity { get; }
    public bool LightsAreOn { get; }
    public EngineState<GroundVehicle> CurEngineState { get; }
    [CompilerGeneratedAttribute]
public sealed virtual Vector3 get_Velocity();
    [CompilerGeneratedAttribute]
private void set_Velocity(Vector3 value);
    public abstract virtual float get_DriveWheelVelocity();
    public bool get_LightsAreOn();
    public EngineState<GroundVehicle> get_CurEngineState();
    public virtual void InitShared();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual float GetSpeed();
    public abstract virtual float GetMaxForwardSpeed();
    public abstract virtual float GetThrottleInput();
    public abstract virtual float GetBrakeInput();
    protected virtual bool CanPushNow(BasePlayer pusher);
    protected virtual IFuelSystem CreateFuelSystem();
    public virtual void ServerInit();
    public abstract virtual void OnEngineStartFailed();
    public abstract virtual bool MeetsEngineRequirements();
    protected virtual void ServerFlagsChanged(Flags old, Flags next);
    protected void OnCollisionEnter(Collision collision);
    public virtual void VehicleFixedUpdate();
    public virtual void LightToggle(BasePlayer player);
    public sealed virtual float GetDamageMultiplier(BaseEntity ent);
    public sealed virtual void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
    private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude);
    protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage);
    protected void ProcessCollision(Collision collision, Rigidbody ourRigidbody);
    public virtual float GetModifiedDrag();
    public virtual IFuelSystem GetFuelSystem();
    protected virtual void OnChildAdded(BaseEntity child);
    private void SetTempDrag(float drag, float duration);
    private sealed virtual override void IEngineControllerUser.Invoke(Action action, float time);
    private sealed virtual override void IEngineControllerUser.CancelInvoke(Action action);
}
public abstract class GroundVehicleAudio : MonoBehaviour {
    [SerializeField]
protected GroundVehicle groundVehicle;
    [HeaderAttribute("Engine")]
[SerializeField]
private SoundDefinition engineStartSound;
    [SerializeField]
private SoundDefinition engineStopSound;
    [SerializeField]
private SoundDefinition engineStartFailSound;
    [SerializeField]
private BlendedLoopEngineSound blendedEngineLoops;
    [SerializeField]
private float wheelRatioMultiplier;
    [SerializeField]
private float overallVolume;
    [HeaderAttribute("Water")]
[SerializeField]
private SoundDefinition waterSplashSoundDef;
    [SerializeField]
private BlendedSoundLoops waterLoops;
    [SerializeField]
private float waterSoundsMaxSpeed;
    [SerializeField]
[HeaderAttribute("Brakes")]
private SoundDefinition brakeSoundDef;
    [SerializeField]
private SoundDefinition brakeStartSoundDef;
    [SerializeField]
private SoundDefinition brakeStopSoundDef;
    [SerializeField]
[HeaderAttribute("Lights")]
private SoundDefinition lightsToggleSound;
}
public class GroundWatch : BaseMonoBehaviour {
    public Vector3 groundPosition;
    public LayerMask layers;
    public float radius;
    [TooltipAttribute("By default, we consider a deployable as not grounded when at least one AreaCheck fails. This allows you to consider it grounded as long as one AreaCheck passes.")]
public bool needOnlyOneAreaCheckValid;
    [HeaderAttribute("Whitelist")]
public BaseEntity[] whitelist;
    public int fails;
    private void OnDrawGizmosSelected();
    public static void PhysicsChanged(GameObject obj);
    public static void PhysicsChanged(Vector3 origin, float radius, int layerMask);
    public void OnPhysicsNeighbourChanged();
    public bool OnGround();
}
public class GrowableEntity : BaseCombatEntity {
    public PlantProperties Properties;
    public ItemDefinition SourceItemDef;
    [CompilerGeneratedAttribute]
private State <State>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Age>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LightQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GroundQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private float <WaterQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private float <WaterConsumption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Fertilized>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TemperatureQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private float <OverallQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Yield>k__BackingField;
    public float stageAge;
    public GrowableGenes Genes;
    public static float startingHealth;
    public static float artificalLightQuality;
    public static float planterGroundModifierBase;
    public static float fertilizerGroundModifierBonus;
    public static float growthGeneSpeedMultiplier;
    public static float waterGeneRequirementMultiplier;
    public static float hardinessGeneModifierBonus;
    public static float hardinessGeneTemperatureModifierBonus;
    public static float baseYieldIncreaseMultiplier;
    public static float yieldGeneBonusMultiplier;
    public static float maxNonPlanterGroundQuality;
    public static float deathRatePerQuality;
    public TimeCachedValue`1<float> sunExposure;
    public TimeCachedValue`1<float> artificialLightExposure;
    public TimeCachedValue`1<float> artificialTemperatureExposure;
    [HelpAttribute("How many miliseconds to budget for processing growable quality updates per frame")]
[ServerVar]
public static float framebudgetms;
    public static Flags GodSpawn;
    public static GrowableEntityUpdateQueue growableEntityUpdateQueue;
    public bool underWater;
    public int seasons;
    public int harvests;
    public float terrainTypeValue;
    public float yieldPool;
    public PlanterBox planter;
    public State State { get; public set; }
    public float Age { get; public set; }
    public float LightQuality { get; public set; }
    public float GroundQuality { get; public set; }
    public float WaterQuality { get; public set; }
    public float WaterConsumption { get; public set; }
    public bool Fertilized { get; public set; }
    public float TemperatureQuality { get; public set; }
    public float OverallQuality { get; public set; }
    public float Yield { get; public set; }
    public float StageProgressFraction { get; }
    public Stage currentStage { get; }
    public static float ThinkDeltaTime { get; }
    public float growDeltaTime { get; }
    public int CurrentPickAmount { get; }
    public float CurrentPickAmountFloat { get; }
    private bool god { get; }
    public float CurrentTemperature { get; }
    private static GrowableEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public State get_State();
    [CompilerGeneratedAttribute]
public void set_State(State value);
    [CompilerGeneratedAttribute]
public float get_Age();
    [CompilerGeneratedAttribute]
public void set_Age(float value);
    [CompilerGeneratedAttribute]
public float get_LightQuality();
    [CompilerGeneratedAttribute]
public void set_LightQuality(float value);
    [CompilerGeneratedAttribute]
public float get_GroundQuality();
    [CompilerGeneratedAttribute]
public void set_GroundQuality(float value);
    [CompilerGeneratedAttribute]
public float get_WaterQuality();
    [CompilerGeneratedAttribute]
public void set_WaterQuality(float value);
    [CompilerGeneratedAttribute]
public float get_WaterConsumption();
    [CompilerGeneratedAttribute]
public void set_WaterConsumption(float value);
    [CompilerGeneratedAttribute]
public bool get_Fertilized();
    [CompilerGeneratedAttribute]
public void set_Fertilized(bool value);
    [CompilerGeneratedAttribute]
public float get_TemperatureQuality();
    [CompilerGeneratedAttribute]
public void set_TemperatureQuality(float value);
    [CompilerGeneratedAttribute]
public float get_OverallQuality();
    [CompilerGeneratedAttribute]
public void set_OverallQuality(float value);
    [CompilerGeneratedAttribute]
public float get_Yield();
    [CompilerGeneratedAttribute]
public void set_Yield(float value);
    public float get_StageProgressFraction();
    public Stage get_currentStage();
    public static float get_ThinkDeltaTime();
    public float get_growDeltaTime();
    public sealed virtual void ReceiveInstanceData(InstanceData data);
    public virtual void ResetState();
    public bool CanPick();
    public int get_CurrentPickAmount();
    public float get_CurrentPickAmountFloat();
    public bool CanTakeSeeds();
    public bool CanClone();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public void ChangeState(State state, bool resetAge, bool loading);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    private bool get_god();
    public void QueueForQualityUpdate();
    public void SetGodQuality(bool qual);
    public void CalculateQualities(bool firstTime, bool forceArtificialLightUpdates, bool forceArtificialTemperatureUpdates);
    private void CalculateQualities_Water();
    public void CalculateLightQuality(bool forceArtificalUpdate);
    public float CalculateSunExposure(bool force);
    public float SunRaycast();
    public float GetArtificialLightExposure(bool force);
    public float CalculateArtificialLightExposure();
    public static float CalculateArtificialLightExposure(Transform forTransform);
    public static float SunRaycast(Vector3 checkPosition);
    public void CalculateWaterQuality();
    public void CalculateGroundQuality(bool firstCheck);
    public float GetGroundTypeValue(Vector3 pos);
    public void CalculateTemperatureQuality();
    public void SetMaxGrowingConditions();
    public float CalculateOverallQuality();
    public void CalculateWaterConsumption();
    public float CalculateArtificialTemperature();
    public static float CalculateArtificialTemperature(Transform forTransform);
    public int CalculateMarketValue();
    private static float RemapValue(float inValue, float minA, float maxA, float minB, float maxB);
    public bool IsFood();
    public float get_CurrentTemperature();
    public virtual void ServerInit();
    public PlanterBox GetPlanter();
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    public virtual void PostServerLoad();
    public void ResetSeason();
    public void RunUpdate();
    public float UpdateAge(float overallQuality);
    public void UpdateHealthAndYield(float overallQuality, float actualStageAgeIncrease);
    public void ApplyDeathRate();
    public float GetGrowthBonus(float overallQuality);
    public State UpdateState();
    public void ConsumeWater();
    public void Fertilize();
    [IsVisible("3")]
[MaxDistance("3")]
[RPC_Server]
public void RPC_TakeClone(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
[IsVisible("3")]
public void RPC_TakeCloneAll(RPCMessage msg);
    public void TakeClones(BasePlayer player);
    public void PickFruit(BasePlayer player, bool eat);
    public void GiveFruit(BasePlayer player, int amount, bool eat);
    public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat);
    [IsVisible("3")]
[RPC_Server]
[MaxDistance("3")]
public void RPC_PickFruit(RPCMessage msg);
    [IsVisible("3")]
[MaxDistance("3")]
[RPC_Server]
public void RPC_EatFruit(RPCMessage msg);
    [MaxDistance("3")]
[IsVisible("3")]
[RPC_Server]
public void RPC_PickFruitAll(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_RemoveDying(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_RemoveDyingAll(RPCMessage msg);
    public void RemoveAllForce();
    public void ForceRemove();
    public void RemoveDying(BasePlayer receiver);
    private void TellPlanter();
    [ServerVar]
public static void GrowAll(Arg arg);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_RequestQualityUpdate(RPCMessage msg);
}
public class GrowableGene : object {
    [CompilerGeneratedAttribute]
private GeneType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneType <PreviousType>k__BackingField;
    public GeneType Type { get; private set; }
    public GeneType PreviousType { get; private set; }
    [CompilerGeneratedAttribute]
public GeneType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(GeneType value);
    [CompilerGeneratedAttribute]
public GeneType get_PreviousType();
    [CompilerGeneratedAttribute]
private void set_PreviousType(GeneType value);
    public void Set(GeneType geneType, bool firstSet);
    public void SetPrevious(GeneType type);
    public string GetDisplayCharacter();
    public static string GetDisplayCharacter(GeneType type);
    public string GetColourCodedDisplayCharacter();
    public static string GetColourCodedDisplayCharacter(GeneType type);
    public static bool IsPositive(GeneType type);
    public bool IsPositive();
}
public static class GrowableGeneEncoding : object {
    public static void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem);
    public static void EncodeGenesToItem(int genes, Item targetItem);
    public static int EncodeGenesToInt(GrowableGenes genes);
    public static int EncodePreviousGenesToInt(GrowableGenes genes);
    public static void DecodeIntToGenes(int data, GrowableGenes genes);
    public static void DecodeIntToPreviousGenes(int data, GrowableGenes genes);
    public static string DecodeIntToGeneString(int data);
    private static int Set(int storage, int slot, int value);
    private static int Get(int storage, int slot);
}
[CreateAssetMenuAttribute]
public class GrowableGeneProperties : ScriptableObject {
    [ArrayIndexIsEnum]
public GeneWeight[] Weights;
}
public class GrowableGenes : object {
    public GrowableGene[] Genes;
    private static GeneWeighting[] baseWeights;
    private static GeneWeighting[] slotWeights;
    private static GrowableGenes();
    private void Clear();
    public void GenerateFavourableGenes(GrowableEntity growable);
    public void GenerateRandom(GrowableEntity growable);
    private void CalculateBaseWeights(GrowableGeneProperties properties);
    private void CalculateSlotWeights(GrowableGeneProperties properties, int slot);
    private GeneType PickWeightedGeneType();
    private GeneType PickFavourableGeneType();
    public int GetGeneTypeCount(GeneType geneType);
    public int GetPositiveGeneCount();
    public int GetNegativeGeneCount();
    public void Save(SaveInfo info);
    public void Load(LoadInfo info);
    public void DebugPrint();
    private string GetDisplayString(bool previousGenes);
}
public static class GrowableGenetics : object {
    public static int GeneSlotCount;
    public static float CrossBreedingRadius;
    private static GeneWeighting[] neighbourWeights;
    private static GeneWeighting dominant;
    private static GrowableGenetics();
    public static void CrossBreed(GrowableEntity growable);
    private static GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List`1<GrowableEntity> neighbours, int slot);
}
public class GrowableHeatSource : EntityComponent`1<BaseEntity> {
    public float heatAmount;
    public AnimationCurve HeatFalloff;
    public float ApplyHeat(Vector3 forPosition);
    public void ForceUpdateGrowablesInRange();
}
public class GunModInformationPanel : ItemInformationPanel {
    public ItemTextValue fireRateDisplay;
    public ItemTextValue velocityDisplay;
    public ItemTextValue damageDisplay;
    public ItemTextValue accuracyDisplay;
    public ItemTextValue recoilDisplay;
    public ItemTextValue zoomDisplay;
    public ItemTextValue ammoDisplay;
}
public class GunTrap : StorageContainer {
    public GameObjectRef gun_fire_effect;
    public GameObjectRef bulletEffect;
    public GameObjectRef triggeredEffect;
    public Transform muzzlePos;
    public Transform eyeTransform;
    public int numPellets;
    public int aimCone;
    public float sensorRadius;
    public ItemDefinition ammoType;
    public TargetTrigger trigger;
    private float triggerCooldown;
    private BuildingPrivlidge _cachedTc;
    private float _cacheTimeout;
    [ServerVar]
public static float gun_trap_budget_ms;
    public static GunTrapScanWorkQueue updateGunTrapWorkQueue;
    private static GunTrap();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual string Categorize();
    public bool UseAmmo();
    public void FireWeapon();
    public void FireBullet();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void TriggerCheck();
    private BuildingPrivlidge GetCachedTc();
    public bool CheckTrigger();
    public bool IsTriggered();
    public Vector3 GetEyePosition();
}
public class HackableLockedCrate : LootContainer {
    public static Flags Flag_Hacking;
    public static Flags Flag_FullyHacked;
    public Text timerText;
    [ServerVar]
public static float requiredHackSeconds;
    [ServerVar]
public static float decaySeconds;
    public SoundPlayer hackProgressBeep;
    public float hackSeconds;
    public GameObjectRef shockEffect;
    public GameObjectRef mapMarkerEntityPrefab;
    public GameObjectRef landEffect;
    public bool shouldDecay;
    public BasePlayer originalHackerPlayer;
    public ulong originalHackerPlayerId;
    public bool hasBeenOpened;
    public BaseEntity mapMarkerInstance;
    public bool hasLanded;
    public bool wasDropped;
    private static HackableLockedCrate();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsBeingHacked();
    public bool IsFullyHacked();
    public virtual void DestroyShared();
    public void CreateMapMarker(float durationMinutes);
    public void RefreshDecay();
    public void DelayedDestroy();
    public virtual void OnAttacked(HitInfo info);
    public void SetWasDropped();
    public virtual void ServerInit();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public void LandCheck();
    public virtual void PostServerLoad();
    [RPC_Server]
[IsVisible("3")]
public void RPC_Hack(RPCMessage msg);
    public void StartHacking();
    public void HackProgress();
    public virtual bool OnStartBeingLooted(BasePlayer player);
}
[FlagsAttribute]
public enum HairCapMask : Enum {
    public int value__;
    public static HairCapMask Head;
    public static HairCapMask Eyebrow;
    public static HairCapMask Facial;
    public static HairCapMask Armpit;
    public static HairCapMask Pubic;
}
public class HairDye : object {
    [ColorUsageAttribute("False", "True")]
public Color capBaseColor;
    public Material sourceMaterial;
    [InspectorFlagsAttribute]
public CopyPropertyMask copyProperties;
    private static MaterialPropertyDesc[] transferableProps;
    public static int _HairBaseColorUV1;
    public static int _HairBaseColorUV2;
    public static int _HairPackedMapUV1;
    public static int _HairPackedMapUV2;
    private static HairDye();
    public void Apply(HairDyeCollection collection, MaterialPropertyBlock block);
    public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block);
}
[CreateAssetMenuAttribute]
public class HairDyeCollection : ScriptableObject {
    public Texture capMask;
    public bool applyCap;
    public HairDye[] Variations;
    public HairDye Get(float seed);
}
[CreateAssetMenuAttribute]
public class HairSet : ScriptableObject {
    public MeshReplace[] MeshReplacements;
    public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block);
    public void ProcessMorphs(GameObject obj, int blendShapeIndex);
}
[CreateAssetMenuAttribute]
public class HairSetCollection : ScriptableObject {
    public HairSetEntry[] Head;
    public HairSetEntry[] Eyebrow;
    public HairSetEntry[] Facial;
    public HairSetEntry[] Armpit;
    public HairSetEntry[] Pubic;
    public HairSetEntry[] GetListByType(HairType hairType);
    public int GetIndex(HairSetEntry[] list, float typeNum);
    public int GetIndex(HairType hairType, float typeNum);
    public HairSetEntry Get(HairType hairType, float typeNum);
}
public enum HairType : Enum {
    public int value__;
    public static HairType Head;
    public static HairType Eyebrow;
    public static HairType Facial;
    public static HairType Armpit;
    public static HairType Pubic;
    public static HairType Count;
}
public class Half3 : ValueType {
    public ushort x;
    public ushort y;
    public ushort z;
    public Half3(Vector3 vec);
    public static Vector3 op_Explicit(Half3 vec);
}
public class Half4 : ValueType {
    public ushort x;
    public ushort y;
    public ushort z;
    public ushort w;
    public Half4(Vector4 vec);
    public static Vector4 op_Explicit(Half4 vec);
}
public class HalloweenDungeon : BasePortal {
    public GameObjectRef dungeonPrefab;
    public EntityRef`1<ProceduralDynamicDungeon> dungeonInstance;
    [ServerVar]
public static float population;
    [ServerVar]
public static float lifetime;
    private float secondsUsed;
    private float timeAlive;
    public AnimationCurve radiationCurve;
    public Phrase collapsePhrase;
    public Phrase mountPhrase;
    private bool anyplayers_cached;
    private float nextPlayerCheckTime;
    private static HalloweenDungeon();
    public virtual float GetLifetime();
    public virtual void Load(LoadInfo info);
    public float GetLifeFraction();
    public void Update();
    public void KillIfNoPlayers();
    public bool AnyPlayersInside();
    private void ClearAllEntitiesInRadius(float radius);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public virtual void UsePortal(BasePlayer player);
    public virtual void Spawn();
    public virtual void ServerInit();
    public void CheckBlocked();
    public static Vector3 GetDungeonSpawnPoint();
    internal virtual void DoServerDestroy();
    public void DelayedDestroy();
    public void SpawnSubEntities();
}
public class HalloweenEventNote : EggHuntNote {
}
public class HalloweenHunt : EggHuntEvent {
    public static Phrase topCreepPhrase;
    public static Phrase placeCreepPhrase;
    private static HalloweenHunt();
    protected virtual Phrase GetTopBunnyPhrase();
    protected virtual Phrase GetPlacePhrase();
    protected virtual void ReportPlayerParticipated(int topCount);
    protected virtual void ReportEggsCollected(int numEggs);
}
public class Hammer : BaseMelee {
    public virtual bool CanHit(HitTest info);
    public virtual void DoAttackShared(HitInfo info);
}
public class Handcuffs : BaseMelee {
    public static int PrisonerHoodItemID;
    [ServerVar]
public static float restrainedPushDamage;
    [ServerVar]
public static float maxConditionRepairLossOnPush;
    [HeaderAttribute("Handcuffs")]
public AnimatorOverrideController CaptiveHoldAnimationOverride;
    public GameObjectRef lockEffect;
    public GameObjectRef escapeEffect;
    [HeaderAttribute("Handcuff Behaviour")]
public bool BlockInventory;
    public bool BlockSuicide;
    public bool BlockUse;
    public bool BlockCrafting;
    public float UnlockMiniGameDuration;
    public float UseDistance;
    public float ConditionLossPerSecond;
    private float unlockStartTime;
    private float startCondition;
    public bool Locked { get; }
    private static Handcuffs();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_Locked();
    public virtual void Load(LoadInfo info);
    private void SetWMLocked(bool flag);
    private void StartUnlockMiniGame();
    public void HeldWhenOwnerDied(BasePlayer player);
    public void SetLocked(bool flag, BasePlayer player, Item handcuffsItem);
    [ServerVar]
public static void togglecuffslocked(Arg args);
    private void ModifyConditionForElapsedTime(float elapsed);
    public void RepairOnPush();
    public void InterruptUnlockMiniGame(bool wasPushedOrDamaged);
    [RPC_Server]
[CallsPerSecond("5")]
[FromOwner]
private void RPC_ReqStartUnlockMiniGame(RPCMessage rpc);
    private void SV_StartUnlockMiniGame(BasePlayer player);
    [FromOwner]
[RPC_Server]
[CallsPerSecond("5")]
private void RPC_ReqCancelUnlockMiniGame(RPCMessage rpc);
    private void SV_CancelUnlockMiniGame(BasePlayer player);
    [FromOwner]
[CallsPerSecond("5")]
[RPC_Server]
private void RPC_ReqCompleteUnlockMiniGame(RPCMessage rpc);
    private void SV_ReqCompleteUnlockMiniGame(BasePlayer player);
    [CallsPerSecond("5")]
[FromOwner]
[RPC_Server]
private void RPC_ReqLock(RPCMessage rpc);
    private void SV_HandcuffVictim(BasePlayer victim, BasePlayer handcuffer);
    public void UnlockAndReturnToPlayer(BasePlayer returnToPlayer);
    public virtual bool CanHit(HitTest info);
    public virtual void DoAttackShared(HitInfo info);
}
public class HandcuffsViewModel : BaseViewModel {
    public SkinnedMeshRenderer handcuffsRenderer;
}
public class HandSnowball : BaseMelee {
}
public class HarborBridgeSounds : MonoBehaviour {
    public HarborProximityEntity bridge;
    public SoundDefinition rootRotationLoopDef;
    public SoundDefinition rootRotationStartDef;
    public SoundDefinition rootRotationStopDef;
}
public class HarborCrane : HarborProximityEntity {
    public Transform CraneGrab;
    public Transform ArmRoot;
    public TransformLineRenderer[] LineRenderers;
}
public class HarborCraneContainerPickup : HarborCrane {
    public Transform ServerTowerGrab;
    public float LockTime;
    public float MaxMoveDistance;
    public float PickedUpObjectRotationSpeed;
    private List`1<ContainerStack> Stacks;
    public GameObjectRef ContainerPrefab;
    private static float ContainerSize;
    public int MaxContainerStackSize;
    public bool DebugContainerSpawns;
    public bool DebugContainerDestinations;
    private Vector3 grabOffset;
    public static ListHashSet`1<HarborCraneContainerPickup> AllCranes;
    private Vector3 startForward;
    private List`1<QueuedMove> movesToMake;
    private Nullable`1<QueuedMove> moveInProcess;
    private EntityRef`1<CargoShip> toParent;
    private float moveDelay;
    private PickupState currentPickupState;
    private float lockOnTime;
    private float maxTargetHeight;
    private static HarborCraneContainerPickup();
    public virtual void ServerInit();
    public virtual void PostMapEntitySpawn();
    internal virtual void DoServerDestroy();
    private void FindNearbyContainerSpawns(List`1<HarborCraneContainerSpawnPoint> foundPoints);
    private void ReplenishContainers(int totalContainers);
    public virtual void Save(SaveInfo info);
    private QueuedMove CreateMove(QueuedMove from);
    private void CreateMove(QueuedMove move, QueuedMove target);
    private void CountdownDelay();
    private void CheckMoveQueue();
    private void ProcessCraneMovement();
    public void ReplenishContainers();
    public void AssignDestination(List`1<Transform> destinations, CargoShip targetShip, float delay);
    public bool IsDestinationValidForCrane(CargoShipContainerDestination destination);
    public virtual void Load(LoadInfo info);
    private void UpdateArm();
    [CompilerGeneratedAttribute]
private bool <ReplenishContainers>g__SpawnContainerOnStack|23_0(ContainerStack stack);
}
public class HarborCraneContainerSpawnPoint : MonoBehaviour {
    public int MaxStackSize;
}
public class HarborCraneSounds : MonoBehaviour {
    public HarborCrane crane;
    public SoundDefinition rootRotationLoopDef;
    public SoundDefinition rootRotationStartDef;
    public SoundDefinition rootRotationStopDef;
    public SoundDefinition armRotationLoopDef;
    public SoundDefinition armRotationStartDef;
    public SoundDefinition armRotationStopDef;
    public Transform grabSoundPosition;
    public SoundDefinition grabMoveLoopDef;
    public SoundDefinition grabMoveStartDef;
    public SoundDefinition grabMoveStopDef;
}
public class HarborCraneStatic : HarborCrane {
    public float StartingDepth;
    public float StartingHeight;
    public float StartingAngle;
    public Transform HangingLadder;
    public virtual void PostMapEntitySpawn();
    public virtual void Save(SaveInfo info);
    private void SetArmPos(float angle, float height, float depth);
    public virtual void Load(LoadInfo info);
}
public class HarborProximityEntity : BaseEntity {
    public bool SupportChildDeployables;
    private static ListHashSet`1<HarborProximityEntity> harborEntities;
    private static HarborProximityEntity();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public static HarborProximityEntity GetEntity(Vector3 worldPos);
    public virtual bool SupportsChildDeployables();
}
public class HarborProximityManager : MonoBehaviour {
    public MoveToMake[] Moves;
    public bool DebugCargo;
    [RangeAttribute("0", "1")]
public float DebugVisPoint;
    private float localNormalisedState;
    public void StartMovement();
    public void UpdateNormalisedState(float f);
    public void EndMovement();
    private void Apply(float f);
}
public class HBHFConfig : UIDialog {
    public RustButton authButton;
    public RustButton nonAuthButton;
}
public class HBHFSensor : BaseDetector {
    public GameObjectRef detectUp;
    public GameObjectRef detectDown;
    public GameObjectRef panelPrefab;
    public static Flags Flag_IncludeOthers;
    public static Flags Flag_IncludeAuthed;
    private int detectedPlayers;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void OnObjects();
    public virtual void OnEmpty();
    public void UpdatePassthroughAmount();
    [RPC_Server]
[IsVisible("3")]
public void SetConfig(RPCMessage msg);
    public bool CanUse(BasePlayer player);
    public bool ShouldIncludeAuthorized();
    public bool ShouldIncludeOthers();
}
public class HeadDispenser : EntityComponent`1<BaseEntity> {
    public ItemDefinition HeadDef;
    public GameObjectRef SourceEntity;
    private bool hasDispensed;
    [CompilerGeneratedAttribute]
private BaseEntity <overrideEntity>k__BackingField;
    public BaseEntity overrideEntity { get; public set; }
    [CompilerGeneratedAttribute]
public BaseEntity get_overrideEntity();
    [CompilerGeneratedAttribute]
public void set_overrideEntity(BaseEntity value);
    public void DispenseHead(HitInfo info, BaseCorpse corpse);
}
public class HeadEntity : BaseEntity {
    public HeadData CurrentTrophyData;
    private static OccupationSlots HeadMask;
    public virtual void Save(SaveInfo info);
    public void SetupSourceId(UInt32 sourceID);
    public void SetupPlayerId(string playerName, ulong playerId);
    public void AssignClothing(ItemContainer container);
    public void AssignHorseBreed(int breed);
    private void InitTrophyData();
    public virtual void Load(LoadInfo info);
    public GameObject GetHeadSource();
}
public class HeadInformationPanel : ItemInformationPanel {
    public ItemDefinition HeadInfo;
    public GameObject PlayerRoot;
    public GameObject NPCRoot;
    public GameObject HorseRoot;
    public Image NPCImage;
    public Text NPCText;
    public Text PlayerNameText;
    public Text PlayerIdText;
    public Text HorseBreedText;
}
public class HealthBelowAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <HealthFraction>k__BackingField;
    private BaseCombatEntity combatEntity;
    public float HealthFraction { get; public set; }
    [CompilerGeneratedAttribute]
public float get_HealthFraction();
    [CompilerGeneratedAttribute]
public void set_HealthFraction(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class HealthBelowEventUI : BaseEventUI {
}
public class HeldBoomBox : HeldEntity {
    public BoomBox BoxController;
    public SwapKeycard cassetteSwapper;
    public BaseEntity ToBaseEntity { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual BaseEntity get_ToBaseEntity();
    public virtual void ServerInit();
    [RPC_Server]
[IsActiveItem]
public void ServerTogglePlay(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("2")]
[IsActiveItem]
private void Server_UpdateRadioIP(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public sealed virtual void OnCassetteInserted(Cassette c);
    public sealed virtual void OnCassetteRemoved(Cassette c);
    public bool ClearRadioByUserId(ulong id);
    public void HurtCallback(float amount);
    public virtual void OnHeldChanged();
    public virtual void Load(LoadInfo info);
}
public class HeldEntity : BaseEntity {
    public Animator worldModelAnimator;
    public SoundDefinition thirdPersonDeploySound;
    public SoundDefinition thirdPersonAimSound;
    public SoundDefinition thirdPersonAimEndSound;
    public static Flags Flag_ForceVisible;
    [HeaderAttribute("Held Entity")]
public string handBone;
    public AnimatorOverrideController HoldAnimationOverride;
    public bool isBuildingTool;
    [HeaderAttribute("Hostility")]
public float hostileScore;
    public HolsterInfo holsterInfo;
    [HeaderAttribute("Camera")]
public CameraMode HeldCameraMode;
    public Vector3 FirstPersonArmOffset;
    public Vector3 FirstPersonArmRotation;
    [RangeAttribute("0", "1")]
public float FirstPersonRotationStrength;
    public bool holsterVisible;
    public bool genericVisible;
    private heldEntityVisState currentVisState;
    private TimeSince lastHeldEvent;
    public ItemId ownerItemUID;
    private Item cachedItem;
    public bool hostile { get; }
    public Transform MuzzleTransform { get; }
    public ItemModWearable WearableWhileEquipped { get; }
    public bool IsUsableByTurret { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_hostile();
    public virtual Transform get_MuzzleTransform();
    public bool LightsOn();
    public bool IsDeployed();
    public BasePlayer GetOwnerPlayer();
    public Connection GetOwnerConnection();
    public virtual ItemModWearable get_WearableWhileEquipped();
    public virtual void SetOwnerPlayer(BasePlayer player);
    public virtual void ClearOwnerPlayer();
    public virtual void SetVisibleWhileHolstered(bool visible);
    public virtual void SetGenericVisible(bool wantsVis);
    public UInt32 GetBone(string bone);
    public virtual void SetLightsOn(bool isOn);
    public void UpdateHeldItemVisibility();
    public bool UpdateVisibility_Hand();
    public bool UpdateVisibility_GenericVis();
    public bool UpdateVisiblity_Holster();
    public bool UpdateVisiblity_Invis();
    public virtual void SetHeld(bool bHeld);
    public virtual void OnHeldChanged();
    public virtual bool get_IsUsableByTurret();
    public virtual bool CanBeUsedInWater();
    public virtual bool BlocksGestures();
    protected Item GetOwnerItem();
    public virtual Item GetItem();
    public ItemDefinition GetOwnerItemDefinition();
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter);
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    public virtual void SetupHeldEntity(Item item);
    public Item GetCachedItem();
    public void OnItemChanged(Item item);
    public virtual void PostServerLoad();
    private void InitOwnerPlayer();
    public virtual void Save(SaveInfo info);
    public void DestroyThis();
    protected bool HasItemAmount();
    protected bool UseItemAmount(int iAmount);
    public virtual void ServerUse();
    public virtual void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness);
    public virtual bool IsInstrument();
    public virtual void Load(LoadInfo info);
    public void SendPunch(Vector3 amount, float duration);
}
public class HelicopterDebris : ServerGib {
    public ItemDefinition metalFragments;
    public ItemDefinition hqMetal;
    public ItemDefinition charcoal;
    [TooltipAttribute("Divide mass by this amount to produce a scalar of resources, default = 5")]
public float massReductionScalar;
    private ResourceDispenser resourceDispenser;
    public float tooHotUntil;
    public virtual void ServerInit();
    public virtual void PhysicsInit(Mesh mesh);
    public bool IsTooHot();
    public virtual void OnAttacked(HitInfo info);
}
public class HelicopterTurret : MonoBehaviour {
    public PatrolHelicopterAI _heliAI;
    public float fireRate;
    public float burstLength;
    public float timeBetweenBursts;
    public float maxTargetRange;
    public float loseTargetAfter;
    public Transform gun_yaw;
    public Transform gun_pitch;
    public Transform muzzleTransform;
    public bool left;
    public BaseCombatEntity _target;
    private float lastBurstTime;
    private float lastFireTime;
    private float lastSeenTargetTime;
    private bool targetVisible;
    public void SetTarget(BaseCombatEntity newTarget);
    public bool NeedsNewTarget();
    public bool UpdateTargetFromList(List`1<targetinfo> newTargetList);
    public bool TargetVisible();
    public float TimeSinceTargetLastSeen();
    public bool HasTarget();
    public void ClearTarget();
    public void TurretThink();
    public void FireGun();
    public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget);
    public float AngleToTarget(BaseCombatEntity potentialtarget);
    public bool InFiringArc(BaseCombatEntity potentialtarget);
    public void UpdateTargetVisibility();
}
public class HiddenValue`1 : object {
    private T _value;
    public HiddenValue`1(T value);
    public T Get();
    public HiddenValue`1<T> Set(T value);
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    public sealed virtual void Dispose();
    public static T op_Implicit(HiddenValue`1<T> hidden);
}
public class HideIfAiming : MonoBehaviour {
    public ParticleSystem[] systems;
}
public class HideIfOwnerFirstPerson : EntityComponent`1<BaseEntity> {
    public GameObject[] disableGameObjects;
    public bool worldModelEffect;
}
public class HideIfScoped : MonoBehaviour {
    public Renderer[] renderers;
    public void SetVisible(bool vis);
}
public class HideUntilMobile : EntityComponent`1<BaseEntity> {
    public GameObject[] visuals;
    private Vector3 startPos;
}
public static class HierarchyUtil : object {
    public static Dictionary`2<string, GameObject> rootDict;
    private static HierarchyUtil();
    public static GameObject GetRoot(string strName, bool groupActive, bool persistant);
}
[FlagsAttribute]
public enum HitArea : Enum {
    public int value__;
    public static HitArea Head;
    public static HitArea Chest;
    public static HitArea Stomach;
    public static HitArea Arm;
    public static HitArea Hand;
    public static HitArea Leg;
    public static HitArea Foot;
}
public static class HitAreaConst : object {
    public static HitArea Nothing;
    public static HitArea Everything;
}
public static class HitAreaUtil : object {
    public static string Format(HitArea area);
}
public class HitboxCollision : BaseCollision {
}
public class HitboxDefinition : MonoBehaviour {
    public Vector3 center;
    public Vector3 rotation;
    public Type type;
    public int priority;
    public PhysicMaterial physicMaterial;
    [SerializeField]
private Vector3 scale;
    public Vector3 Scale { get; public set; }
    public Matrix4x4 LocalMatrix { get; }
    public Vector3 get_Scale();
    public void set_Scale(Vector3 value);
    public Matrix4x4 get_LocalMatrix();
    private void OnValidate();
    protected virtual void OnDrawGizmosSelected();
    protected virtual void OnDrawGizmos();
}
public class HitboxSystem : MonoBehaviour {
    public List`1<HitboxShape> hitboxes;
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class HitchTrough : StorageContainer {
    public HitchSpot[] hitchSpots;
    public float caloriesToDecaySeconds;
    public Item GetFoodItem();
    public bool ValidHitchPosition(Vector3 pos);
    public bool HasSpace();
    public HitchSpot GetClosest(Vector3 testPos, bool includeOccupied, float maxRadius);
    public void Unhitch(RidableHorse horse);
    public int NumHitched();
    public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public void UnhitchAll();
    public virtual void DestroyShared();
    public virtual void OnKilled(HitInfo info);
    public virtual void Load(LoadInfo info);
}
public class HitDetectionBenchmark : BenchmarkScene {
    private static int PlayerCount;
    public GameObjectRef PlayerModelPrefab;
    public GameObjectRef PlayerCollisionPrefab;
}
public class HitInfo : object {
    public BaseEntity Initiator;
    public BaseEntity WeaponPrefab;
    public AttackEntity Weapon;
    public bool DoHitEffects;
    public bool DoDecals;
    public bool IsPredicting;
    public bool UseProtection;
    public Connection Predicted;
    public bool DidHit;
    public BaseEntity HitEntity;
    public UInt32 HitBone;
    public UInt32 HitPart;
    public UInt32 HitMaterial;
    public Vector3 HitPositionWorld;
    public Vector3 HitPositionLocal;
    public Vector3 HitNormalWorld;
    public Vector3 HitNormalLocal;
    public Vector3 PointStart;
    public Vector3 PointEnd;
    public int ProjectileID;
    public int ProjectileHits;
    public float ProjectileDistance;
    public float ProjectileIntegrity;
    public float ProjectileTravelTime;
    public float ProjectileTrajectoryMismatch;
    public Vector3 ProjectileVelocity;
    public Projectile ProjectilePrefab;
    public PhysicMaterial material;
    public DamageProperties damageProperties;
    public DamageTypeList damageTypes;
    public bool CanGather;
    public bool DidGather;
    public float gatherScale;
    public BasePlayer InitiatorPlayer { get; }
    public Vector3 attackNormal { get; }
    public bool hasDamage { get; }
    public bool InitiatorParented { get; }
    public bool HitEntityParented { get; }
    public bool isHeadshot { get; }
    public Phrase bonePhrase { get; }
    public string boneName { get; }
    public HitArea boneArea { get; }
    public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition);
    public HitInfo(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public void Clear();
    public bool IsProjectile();
    public BasePlayer get_InitiatorPlayer();
    public Vector3 get_attackNormal();
    public bool get_hasDamage();
    public void Init(BaseEntity attacker, BaseEntity target, DamageType type, float damageAmount, Vector3 vhitPosition);
    public void LoadFromAttack(Attack attack, bool serverSide);
    public bool get_InitiatorParented();
    public bool get_HitEntityParented();
    public bool get_isHeadshot();
    public Phrase get_bonePhrase();
    public string get_boneName();
    public HitArea get_boneArea();
    public Vector3 PositionOnRay(Vector3 position);
    public Vector3 HitPositionOnRay();
    public bool IsNaNOrInfinity();
}
public class HitNumber : MonoBehaviour {
    public HitType hitType;
    public int ColorToMultiplier(HitType type);
    public void OnDrawGizmosSelected();
}
public class HittableByTrains : EntityComponent`1<BaseCombatEntity> {
    [SerializeField]
private float trainDamagePerMPS;
    [SerializeField]
private float barricadeDamageMultiplier;
    [SerializeField]
private float minVelToDestroy;
    [SerializeField]
private float velReduction;
    [SerializeField]
private GameObjectRef barricadeDamageEffect;
    [CompilerGeneratedAttribute]
private float <FrontWheelSplineDist>k__BackingField;
    private TrainCar hitTrain;
    private TriggerTrainCollisions hitTrainTrigger;
    private TrainTrackSpline track;
    public Vector3 Position { get; }
    public float FrontWheelSplineDist { get; private set; }
    public TrainCarType CarType { get; }
    public sealed virtual bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);
    public sealed virtual Vector3 get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual float get_FrontWheelSplineDist();
    [CompilerGeneratedAttribute]
private void set_FrontWheelSplineDist(float value);
    public sealed virtual TrainCarType get_CarType();
    public sealed virtual bool EqualNetID(BaseNetworkable other);
    public sealed virtual Vector3 GetWorldVelocity();
    public sealed virtual void OnParentSpawning();
    public sealed virtual void OnParentDestroying();
    private void SetHitTrain(TrainCar train, TriggerTrainCollisions trainTrigger);
    private void ClearHitTrain();
    private void DestroyThisBarrier();
    private void PushForceTick();
    public virtual void SaveComponent(SaveInfo info);
}
public class HitTest : object {
    public Type type;
    public Ray AttackRay;
    public float Radius;
    public float Forgiveness;
    public float MaxDistance;
    public RaycastHit RayHit;
    public bool MultiHit;
    public bool BestHit;
    public bool DidHit;
    public DamageProperties damageProperties;
    public GameObject gameObject;
    public Collider collider;
    public BaseEntity ignoreEntity;
    public List`1<Type> ignoredTypes;
    public BaseEntity HitEntity;
    public Vector3 HitPoint;
    public Vector3 HitNormal;
    public float HitDistance;
    public Transform HitTransform;
    public UInt32 HitPart;
    public string HitMaterial;
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public void CopyFrom(HitTest other, bool copyHitInfo);
    public Vector3 HitPointWorld();
    public Vector3 HitNormalWorld();
    public void Clear();
}
public class HLODBounds : MonoBehaviour {
    [TooltipAttribute("The bounds that this HLOD will cover. This should not overlap with any other HLODs")]
public Bounds MeshBounds;
    [TooltipAttribute("Assets created will use this prefix. Make sure multiple HLODS in a scene have different prefixes")]
public string MeshPrefix;
    [TooltipAttribute("The point from which to calculate the HLOD. Any RendererLODs that are visible at this distance will baked into the HLOD mesh")]
public float CullDistance;
    [TooltipAttribute("If set, the lod will take over at this distance instead of the CullDistance (eg. we make a model based on what this area looks like at 200m but we actually want it take over rendering at 300m)")]
public float OverrideLodDistance;
    [TooltipAttribute("Any renderers below this height will considered culled even if they are visible from a distance. Good for underground areas")]
public float CullBelowHeight;
    [TooltipAttribute("Optimises the mesh produced by removing non-visible and small faces. Can turn it off during dev but should be on for final builds")]
public bool ApplyMeshTrimming;
    public MeshTrimSettings Settings;
    public LODComponent DebugComponent;
    public bool ShowTrimSettings;
    [TooltipAttribute("Prints out information about what the baker is doing, helpful for diagnosing errors")]
public bool DebugMode;
}
public class HolosightReticlePositioning : MonoBehaviour {
    public IronsightAimPoint aimPoint;
    public RectTransform rectTransform { get; }
    public RectTransform get_rectTransform();
    private void Update();
    private void UpdatePosition(Camera cam);
}
public class HomingLauncherCamOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public NVGCamera nvgCameraOverlay;
}
public class HomingLauncherUIDialog : UIDialog {
    [HeaderAttribute("Homing Launcher")]
[SerializeField]
private Canvas canvas;
    [SerializeField]
private GameObject mainUI;
    [SerializeField]
private GameObject scopeCircle;
    [SerializeField]
private RawImage blackScreen;
    [SerializeField]
private AnimationCurve fadeEffectCurve;
    [SerializeField]
private float visualSwapTime;
    [SerializeField]
private Image lockPercentImage;
    [SerializeField]
private Image trackingImage;
    [SerializeField]
private GameObject armedObj;
    [SerializeField]
private GameObject lockedObj;
    [SerializeField]
private GameObject noAmmoObj;
}
public class HomingLauncherViewModel : BaseViewModel {
}
public class Horse : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual void ServerInit();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
[CreateAssetMenuAttribute]
public class HorseBreed : ScriptableObject {
    public Phrase breedName;
    public Phrase breedDesc;
    public Sprite trophyHeadSprite;
    public Material[] materialOverrides;
    public float maxHealth;
    public float maxSpeed;
    public float staminaDrain;
    public float maxStamina;
}
public class HorseCorpse : LootableCorpse {
    public int breedIndex;
    public Phrase lootPanelTitle;
    public string playerName { get; }
    public virtual string get_playerName();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class HorseEquipmentInformationPanel : ItemInformationPanel {
    public ItemTextValue horseProtectionDisplay;
    public ItemTextValue riderProtectionDisplay;
    public ItemTextValue maxSpeedDisplay;
    public ItemTextValue storageAmountDisplay;
}
public class HorseIdleMultiConditionCrossfade : StateMachineBehaviour {
    public string TargetState;
    public float NormalizedTransitionDuration;
}
public class HorseRagdoll : AnimalRagdoll {
    public GameObject mane;
    public GameObject woodArmor;
    public GameObject roadsignArmor;
    public HorseBreed overrideBreed;
    public GameObject singleSaddle;
    public GameObject doubleSaddle;
    public GameObjectRef breedSource;
}
public class HorseSpawner : VehicleSpawner {
    public float respawnDelay;
    public float respawnDelayVariance;
    public bool spawnForSale;
    protected bool LogAnalytics { get; }
    public virtual void ServerInit();
    public virtual int GetOccupyLayer();
    public void RespawnHorse();
    protected virtual bool get_LogAnalytics();
}
public class HostileNote : MonoBehaviour {
    public CanvasGroup warnGroup;
    public CanvasGroup group;
    public CanvasGroup timerGroup;
    public CanvasGroup smallWarning;
    public Text timerText;
    public RustText smallWarningText;
    public static float unhostileTime;
    public static float weaponDrawnDuration;
    public Color warnColor;
    public Color hostileColor;
    public float requireDistanceToSafeZone;
}
public class HotAirBalloon : BaseCombatEntity {
    public static Flags Flag_HasFuel;
    public static Flags Flag_Grounded;
    public static Flags Flag_CanModifyEquipment;
    public static Flags Flag_HalfInflated;
    public static Flags Flag_FullInflated;
    public static Flags Flag_OnlyOwnerEntry;
    public Transform centerOfMass;
    public Rigidbody myRigidbody;
    public Transform buoyancyPoint;
    public float liftAmount;
    public Transform windSock;
    public Transform[] windFlags;
    public GameObject staticBalloonDeflated;
    public GameObject staticBalloon;
    public GameObject animatedBalloon;
    public Animator balloonAnimator;
    public Transform groundSample;
    public float inflationLevel;
    [HeaderAttribute("Fuel")]
public GameObjectRef fuelStoragePrefab;
    public float fuelPerSec;
    [HeaderAttribute("Storage")]
public GameObjectRef storageUnitPrefab;
    public EntityRef`1<StorageContainer> storageUnitInstance;
    [HeaderAttribute("Damage")]
public DamageRenderer damageRenderer;
    public Transform engineHeight;
    public GameObject[] killTriggers;
    [HeaderAttribute("Upgrades")]
public List`1<UpgradeOption> UpgradeOptions;
    public EntityFuelSystem fuelSystem;
    [ServerVar]
public static float population;
    [ServerVar]
public static float outsidedecayminutes;
    public float NextUpgradeTime;
    public float windForce;
    public Vector3 currentWindVec;
    public Bounds collapsedBounds;
    public Bounds raisedBounds;
    public GameObject[] balloonColliders;
    [ServerVar]
public static float serviceCeiling;
    [ServerVar]
public static float minimumAltitudeTerrain;
    public Vector3 lastFailedDecayPosition;
    public float currentBuoyancy;
    public TimeSince sinceLastBlast;
    public float avgTerrainHeight;
    public bool grounded;
    public float spawnTime;
    public float safeAreaRadius;
    public Vector3 safeAreaOrigin;
    public bool IsFullyInflated { get; }
    public bool Grounded { get; }
    public SamTargetType SAMTargetType { get; }
    public bool IsClient { get; }
    private static HotAirBalloon();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_IsFullyInflated();
    public virtual void InitShared();
    public bool get_Grounded();
    public virtual void Load(LoadInfo info);
    public bool CanModifyEquipment();
    public void DelayNextUpgrade(float delay);
    public int GetEquipmentCount(ItemModHABEquipment item);
    public void RemoveItemsOfType(ItemModHABEquipment item);
    public bool WaterLogged();
    public bool OnlyOwnerAccessible();
    public sealed virtual SamTargetType get_SAMTargetType();
    public sealed virtual bool get_IsClient();
    public virtual void OnAttacked(HitInfo info);
    protected virtual void OnChildAdded(BaseEntity child);
    protected virtual void OnChildRemoved(BaseEntity child);
    internal virtual void DoServerDestroy();
    public sealed virtual bool IsValidSAMTarget(bool staticRespawn);
    public virtual float GetNetworkTime();
    public virtual void PostServerLoad();
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public void DecayTick();
    [RPC_Server]
[IsVisible("3")]
public void EngineSwitch(RPCMessage msg);
    public void ScheduleOff();
    public void UpdateIsGrounded();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public void CheckGlobal(Flags flags);
    protected void FixedUpdate();
    public virtual Vector3 GetLocalVelocityServer();
    public virtual Quaternion GetAngularVelocityServer();
    public void ClearOwnerEntry();
    public bool IsSafe();
    public sealed virtual void SetupOwner(BasePlayer owner, Vector3 newSafeAreaOrigin, float newSafeAreaRadius);
    public sealed virtual bool IsDespawnEligable();
    public sealed virtual IFuelSystem GetFuelSystem();
    public sealed virtual int StartingFuelUnits();
    public Vector3 GetWindAtPos(Vector3 pos);
    public bool PlayerHasEquipmentItem(BasePlayer player, int tokenItemID);
    public Item GetEquipmentItem(BasePlayer player, int tokenItemID);
    public virtual float MaxHealth();
    public virtual List`1<ItemAmount> BuildCost();
    [IsVisible("3")]
[RPC_Server]
public void RPC_ReqEquipItem(RPCMessage msg);
}
public class HotAirBalloonArmor : HotAirBalloonEquipment {
    public float AdditionalHealth;
    public virtual void Added(HotAirBalloon hab, bool fromSave);
    public virtual void Removed(HotAirBalloon hab);
    public virtual void Hurt(HitInfo info);
}
public class HotAirBalloonEquipment : BaseCombatEntity {
    [SerializeField]
private DamageRenderer damageRenderer;
    [HideInInspector]
public float DelayNextUpgradeOnRemoveDuration;
    private EntityRef`1<HotAirBalloon> hotAirBalloon;
    public virtual void Added(HotAirBalloon hab, bool fromSave);
    public virtual void Removed(HotAirBalloon hab);
    public virtual void DoRepair(BasePlayer player);
}
public class HotOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public float smoothTime;
    public bool preventInstantiation;
}
public class HudElement : MonoBehaviour {
    public Text[] ValueText;
    public Image[] FilledImage;
    public float lastValue;
    private float lastMax;
    public void SetValue(float value, float max);
    private void SetText(string v);
    private void SetImage(float f);
}
public class HumanBodyResourceDispenser : ResourceDispenser {
    public virtual bool OverrideOwnership(Item item, AttackEntity weapon);
    public static string CreateSkullName(string playerName);
}
public class HumanFuelSystem : object {
    private bool isServer;
    private float percentFood;
    private EntityRef`1<BaseVehicle> vehilceRef;
    private float pendingFuel;
    public HumanFuelSystem(bool isServer, BaseVehicle owner, float percentFood);
    public sealed virtual bool HasValidInstance(bool isServer);
    public sealed virtual NetworkableId GetInstanceID();
    public sealed virtual void SetInstanceID(NetworkableId uid);
    private BaseVehicle GetVehilce();
    public sealed virtual int GetFuelCapacity();
    public sealed virtual bool CheckNewChild(BaseEntity child);
    public sealed virtual int GetFuelAmount();
    public sealed virtual float GetFuelFraction();
    public sealed virtual bool HasFuel(bool forceCheck);
    public sealed virtual int TryUseFuel(float seconds, float fuelUsedPerSecond);
    public sealed virtual void LootFuel(BasePlayer player);
    public sealed virtual void AddFuel(int amount);
    public sealed virtual void FillFuel();
    private bool TryGetHuman(BasePlayer& driver);
}
public class HumanNPC : NPCPlayer {
    [HeaderAttribute("LOS")]
public int AdditionalLosBlockingLayer;
    [HeaderAttribute("Loot")]
public LootSpawnSlot[] LootSpawnSlots;
    [HeaderAttribute("Damage")]
public float aimConeScale;
    public float lastDismountTime;
    [CompilerGeneratedAttribute]
private ScientistBrain <Brain>k__BackingField;
    public bool lightsOn;
    public float nextZoneSearchTime;
    public AIInformationZone cachedInfoZone;
    public float targetAimedDuration;
    private float lastAimSetTime;
    public Vector3 aimOverridePosition;
    public ScientistBrain Brain { get; public set; }
    public virtual float StartHealth();
    public virtual float StartMaxHealth();
    public virtual float MaxHealth();
    [CompilerGeneratedAttribute]
public ScientistBrain get_Brain();
    [CompilerGeneratedAttribute]
public void set_Brain(ScientistBrain value);
    public virtual bool IsLoadBalanced();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void LightCheck();
    public virtual float GetAimConeScale();
    public virtual void EquipWeapon(bool skipDeployDelay);
    public virtual void DismountObject();
    public bool RecentlyDismounted();
    public virtual float GetIdealDistanceFromTarget();
    public AIInformationZone GetInformationZone(Vector3 pos);
    public sealed virtual float EngagementRange();
    public void SetDucked(bool flag);
    public virtual void TryThink();
    public virtual void ServerThink(float delta);
    public void TickAttack(float delta, BaseCombatEntity target, bool targetIsLOS);
    public virtual void Hurt(HitInfo info);
    public float GetAimSwayScalar();
    public virtual Vector3 GetAimDirection();
    public virtual void SetAimDirection(Vector3 newAim);
    public void SetStationaryAimPoint(Vector3 aimAt);
    public void ClearStationaryAimPoint();
    public virtual bool ShouldDropActiveItem();
    public virtual void AttackerInfo(DeathInfo info);
    public sealed virtual bool IsThreat(BaseEntity entity);
    public sealed virtual bool IsTarget(BaseEntity entity);
    public sealed virtual bool IsFriendly(BaseEntity entity);
    public sealed virtual bool CanAttack(BaseEntity entity);
    public sealed virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public sealed virtual bool CanSeeTarget(BaseEntity entity);
    public bool CanSeeTarget(BaseEntity entity, Vector3 fromOffset);
    public sealed virtual bool NeedsToReload();
    public sealed virtual bool Reload();
    public sealed virtual float CooldownDuration();
    public sealed virtual bool IsOnCooldown();
    public sealed virtual bool StartAttacking(BaseEntity entity);
    public sealed virtual void StopAttacking();
    public sealed virtual float GetAmmoFraction();
    public sealed virtual BaseEntity GetBestTarget();
    public sealed virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
    public void UseHealingItem(Item item);
    [IteratorStateMachineAttribute("HumanNPC/<Heal>d__57")]
private IEnumerator Heal(Item item);
    public Item FindHealingItem();
    protected virtual void ApplyLoot(NPCPlayerCorpse corpse);
    public virtual bool IsOnGround();
}
public class HumanPathFinder : BasePathFinder {
    private BaseEntity npc;
    public void Init(BaseEntity npc);
    public virtual AIMovePoint GetBestRoamPoint(Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float anchorClampDistance, float lookupMaxRange);
    private AIMovePoint GetBestRoamPoint(AIInformationZone aiZone, Vector3 anchorPos, Vector3 currentPos, Vector3 currentDirection, float clampDistance, float lookupMaxRange);
}
public class HungerAboveAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; private set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class HungerAboveEventUI : BaseEventUI {
}
public class HuntingTrophy : StorageContainer {
    public HeadData CurrentTrophyData;
    public PlayerModel Player;
    public GameObject MaleRope;
    public GameObject FemaleRope;
    public Renderer[] HorseRenderers;
    public Renderer[] HorseHairRenderers;
    public static UInt32 HORSE_PREFAB_ID;
    public GameObject NameRoot;
    public RustText NameText;
    public TrophyRoot[] Trophies;
    public HeadData TrophyData { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public HeadData get_TrophyData();
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public virtual bool ItemFilter(Item item, int targetSlot);
    [RPC_Server]
[IsVisible("3")]
private void ServerRequestSubmit();
    [RPC_Server]
[IsVisible("3")]
private void ServerRequestClear(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public bool CanSubmitHead(HeadEntity headEnt);
    public virtual void Load(LoadInfo info);
    public virtual void ResetState();
    [CompilerGeneratedAttribute]
private GameObject <CanSubmitHead>g__GetCurrentTrophyDataSource|19_0();
}
public class HurtOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public float smoothTime;
}
public class HurtPunch : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public static float punchHurtDuration;
    private static HurtPunch();
}
public interface IAIAttack {
    public abstract virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
    public abstract virtual BaseEntity GetBestTarget();
    public abstract virtual bool CanAttack(BaseEntity entity);
    public abstract virtual float EngagementRange();
    public abstract virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public abstract virtual bool CanSeeTarget(BaseEntity entity);
    public abstract virtual float GetAmmoFraction();
    public abstract virtual bool NeedsToReload();
    public abstract virtual bool Reload();
    public abstract virtual float CooldownDuration();
    public abstract virtual bool IsOnCooldown();
    public abstract virtual bool StartAttacking(BaseEntity entity);
    public abstract virtual void StopAttacking();
}
internal interface IAIDesign {
    public abstract virtual void LoadAIDesign(AIDesign design, BasePlayer player);
    public abstract virtual void StopDesigning();
    public abstract virtual bool CanPlayerDesignAI(BasePlayer player);
}
public interface IAIEventListener {
    public abstract virtual void EventTriggeredStateChange(int newStateContainerID, int sourceEventID);
}
public interface IAIGroupable {
    public abstract virtual bool AddMember(IAIGroupable member);
    public abstract virtual void RemoveMember(IAIGroupable member);
    public abstract virtual void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity);
    public abstract virtual void SetGroupRoamRootPosition(Vector3 rootPos);
    public abstract virtual bool InGroup();
    public abstract virtual void LeaveGroup();
    public abstract virtual void SetUngrouped();
}
public interface IAIHungerAbove {
    public abstract virtual bool IsHungerAbove(float val);
}
public interface IAIMounted {
    public abstract virtual bool IsMounted();
}
public interface IAIPath {
    public IEnumerable`1<IAIPathSpeedZone> SpeedZones { get; }
    public IEnumerable`1<IAIPathInterestNode> InterestNodes { get; }
    public abstract virtual IEnumerable`1<IAIPathSpeedZone> get_SpeedZones();
    public abstract virtual IEnumerable`1<IAIPathInterestNode> get_InterestNodes();
    public abstract virtual void GetNodesNear(Vector3 point, List`1& nearNodes, float dist);
    public abstract virtual IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist);
    public abstract virtual IAIPathNode GetClosestToPoint(Vector3 point);
    public abstract virtual void AddInterestNode(IAIPathInterestNode interestNode);
    public abstract virtual void AddSpeedZone(IAIPathSpeedZone speedZone);
}
public interface IAIPathInterestNode {
    public Vector3 Position { get; }
    public float NextVisitTime { get; public set; }
    public abstract virtual Vector3 get_Position();
    public abstract virtual float get_NextVisitTime();
    public abstract virtual void set_NextVisitTime(float value);
}
public interface IAIPathNode {
    public Vector3 Position { get; }
    public bool Straightaway { get; }
    public IEnumerable`1<IAIPathNode> Linked { get; }
    public abstract virtual Vector3 get_Position();
    public abstract virtual bool get_Straightaway();
    public abstract virtual IEnumerable`1<IAIPathNode> get_Linked();
    public abstract virtual bool IsValid();
    public abstract virtual void AddLink(IAIPathNode link);
}
public interface IAIPathSpeedZone {
    public abstract virtual OBB WorldSpaceBounds();
    public abstract virtual float GetMaxSpeed();
}
public interface IAirSupply {
    public AirSupplyType AirType { get; }
    public abstract virtual AirSupplyType get_AirType();
    public abstract virtual float GetAirTimeRemaining();
}
public interface IAISenses {
    public abstract virtual bool IsThreat(BaseEntity entity);
    public abstract virtual bool IsTarget(BaseEntity entity);
    public abstract virtual bool IsFriendly(BaseEntity entity);
}
public interface IAISleep {
    public abstract virtual void StartSleeping();
    public abstract virtual void StopSleeping();
}
public interface IAISleepable {
    public abstract virtual bool AllowedToSleep();
    public abstract virtual void SleepAI();
    public abstract virtual void WakeAI();
}
public interface IAITirednessAbove {
    public abstract virtual bool IsTirednessAbove(float val);
}
public interface IAmmoContainer {
    public abstract virtual Item FindAmmo(AmmoTypes ammoType);
    public abstract virtual void FindAmmo(List`1<Item> list, AmmoTypes ammoType);
    public abstract virtual Item FindItemByItemID(int id);
    public abstract virtual List`1<Item> FindItemsByItemID(int id);
    public abstract virtual Item FindItemByItemName(string name);
    public abstract virtual bool HasAmmo(AmmoTypes ammoType);
    public abstract virtual Item FindItemByUID(ItemId iUID);
    public abstract virtual bool GiveItem(Item item, ItemContainer container);
}
public interface IAnimationEventReceiver {
}
public interface IAudioConnectionSource {
    public abstract virtual IOEntity ToEntity();
}
public interface IBatchingHandler {
}
public interface IBlueprintsChanged {
}
public interface ICassettePlayer {
    public BaseEntity ToBaseEntity { get; }
    public abstract virtual void OnCassetteInserted(Cassette c);
    public abstract virtual void OnCassetteRemoved(Cassette c);
    public abstract virtual BaseEntity get_ToBaseEntity();
}
public class IceFence : GraveyardFence {
    public GameObject[] styles;
    private bool init;
    public AdaptMeshToTerrain snowMesh;
    public int GetStyleFromID();
    public virtual void ServerInit();
    public void InitStyle();
    public void SetStyle(int style);
    public virtual void UpdatePillars();
}
internal interface IClientBrainStateListener {
    public abstract virtual void OnClientStateChanged(AIState state);
}
public interface IClothingChanged {
}
public class IconSkin : MonoBehaviour {
    public Image icon;
    public Text text;
}
public class IconSkinPicker : MonoBehaviour {
    public GameObjectRef pickerIcon;
    public GameObject container;
    public Action skinChangedEvent;
    public ScrollRect scroller;
    public SearchFilterInput searchFilter;
}
public interface IContainerSounds {
}
public interface IConversationProvider {
    public abstract virtual bool ProviderBusy();
}
public class IdentifierConfig : IOConfig`1<IRemoteControllable> {
    [HideInInspector]
public string id;
}
public interface IDetector {
    public abstract virtual bool ShouldTrigger();
    public abstract virtual void OnObjects();
    public abstract virtual void OnObjectAdded(GameObject obj, Collider col);
    public abstract virtual void OnEmpty();
}
public interface IDraggable {
}
public interface IEffect {
}
public interface IEffectRecycle {
}
public interface IEngineControllerUser {
    public abstract virtual bool HasFlag(Flags f);
    public abstract virtual bool IsDead();
    public abstract virtual void SetFlag(Flags f, bool b, bool recursive, bool networkupdate);
    public abstract virtual void Invoke(Action action, float time);
    public abstract virtual void CancelInvoke(Action action);
    public abstract virtual void OnEngineStartFailed();
    public abstract virtual bool MeetsEngineRequirements();
}
public interface IEntityPingSource {
    public abstract virtual bool IsPingValid(MapNote note);
}
public interface IFlagNotify {
    public abstract virtual void OnFlagToggled(bool state);
}
public interface IFuelSystem {
    public abstract virtual bool HasValidInstance(bool isServer);
    public abstract virtual NetworkableId GetInstanceID();
    public abstract virtual void SetInstanceID(NetworkableId uid);
    public abstract virtual bool CheckNewChild(BaseEntity child);
    public abstract virtual int GetFuelAmount();
    public abstract virtual float GetFuelFraction();
    public abstract virtual bool HasFuel(bool forceCheck);
    public abstract virtual int TryUseFuel(float seconds, float fuelUsedPerSecond);
    public abstract virtual int GetFuelCapacity();
    public abstract virtual void LootFuel(BasePlayer player);
    public abstract virtual void AddFuel(int amount);
    public abstract virtual void FillFuel();
}
public class Igniter : IOEntity {
    public float IgniteRange;
    public float IgniteFrequency;
    public float IgniteStartDelay;
    public Transform LineOfSightEyes;
    public float SelfDamagePerIgnite;
    public int PowerConsumption;
    public virtual int ConsumptionAmount();
    public bool CanIgnite();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    private void IgniteInRange();
    public virtual int DesiredPower(int inputIndex);
    public virtual void OnRepair();
}
public class IgnoreCollision : MonoBehaviour {
    public Collider collider;
    protected void OnTriggerEnter(Collider other);
}
public interface IHLODMeshSource {
}
public interface IHurtTrigger {
}
public interface IIdealSlotEntity {
    public abstract virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public abstract virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifiers);
}
public interface IIgniteable {
    public abstract virtual void Ignite(Vector3 fromPos);
    public abstract virtual bool CanIgnite();
}
public interface IImageReceiver {
}
public interface IIndustrialStorage {
    public ItemContainer Container { get; }
    public BaseEntity IndustrialEntity { get; }
    public abstract virtual ItemContainer get_Container();
    public abstract virtual Vector2i InputSlotRange(int slotIndex);
    public abstract virtual Vector2i OutputSlotRange(int slotIndex);
    public abstract virtual void OnStorageItemTransferBegin();
    public abstract virtual void OnStorageItemTransferEnd();
    public abstract virtual BaseEntity get_IndustrialEntity();
}
public interface IInstanceDataReceiver {
    public abstract virtual void ReceiveInstanceData(InstanceData data);
}
public interface IInventoryChanged {
}
public interface IItemAmountChanged {
}
public interface IItemContainerEntity {
    public ItemContainer inventory { get; }
    public Transform Transform { get; }
    public bool DropsLoot { get; }
    public float DestroyLootPercent { get; }
    public bool DropFloats { get; }
    public abstract virtual ItemContainer get_inventory();
    public abstract virtual Transform get_Transform();
    public abstract virtual bool get_DropsLoot();
    public abstract virtual float get_DestroyLootPercent();
    public abstract virtual bool get_DropFloats();
    public abstract virtual void DropItems(BaseEntity initiator);
    public abstract virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public abstract virtual bool ShouldDropItemsIndividually();
    public abstract virtual void DropBonusItems(BaseEntity initiator, ItemContainer container);
    public abstract virtual Vector3 GetDropPosition();
}
public interface IItemIconChanged {
}
public interface IItemPanel {
}
public interface IItemSetup {
    public abstract virtual void OnItemSetup(Item item);
}
public interface IItemUpdate {
    public abstract virtual void OnItemUpdate(Item item);
}
public interface ILerpInfo {
    public abstract virtual float GetExtrapolationTime();
    public abstract virtual float GetInterpolationDelay(LerpType lerpType);
    public abstract virtual float GetInterpolationSmoothing();
}
public interface ILOD {
}
public interface ILootableEntity {
    public ulong LastLootedBy { get; public set; }
    public abstract virtual ulong get_LastLootedBy();
    public abstract virtual void set_LastLootedBy(ulong value);
}
public class ImagePainter : MonoBehaviour {
    public OnDrawingEvent onDrawing;
    public MonoBehaviour redirectRightClick;
    [TooltipAttribute("Spacing scale will depend on your texel size, tweak to what's right.")]
public float spacingScale;
    internal Brush brush;
    internal PointerState[] pointerState;
    public RectTransform rectTransform { get; }
    public RectTransform get_rectTransform();
    public virtual void OnPointerDown(PointerEventData eventData);
    public virtual void OnPointerUp(PointerEventData eventData);
    public virtual void OnDrag(PointerEventData eventData);
    public virtual void OnBeginDrag(PointerEventData eventData);
    public virtual void OnEndDrag(PointerEventData eventData);
    public virtual void OnInitializePotentialDrag(PointerEventData eventData);
    private void DrawAt(Vector2 position, InputButton button);
    private void Start();
    public void UpdateBrush(Brush brush);
}
public static class ImageProcessing : object {
    private static Byte[] signaturePNG;
    private static Byte[] signatureIHDR;
    private static ImageProcessing();
    public static void GaussianBlur2D(Single[] data, int len1, int len2, int iterations);
    public static void GaussianBlur2D(Single[] data, int len1, int len2, int len3, int iterations);
    public static void Average2D(Single[] data, int len1, int len2, int iterations);
    public static void Average2D(Single[] data, int len1, int len2, int len3, int iterations);
    public static void Upsample2D(Single[] src, int srclen1, int srclen2, Single[] dst, int dstlen1, int dstlen2);
    public static void Upsample2D(Single[] src, int srclen1, int srclen2, int srclen3, Single[] dst, int dstlen1, int dstlen2, int dstlen3);
    public static void Dilate2D(Int32[] src, int len1, int len2, int srcmask, int radius, Action`2<int, int> action);
    public static void FloodFill2D(int x, int y, Int32[] data, int len1, int len2, int mask_any, int mask_not, Func`2<int, int> action);
    public static bool IsValidPNG(Byte[] data, int maxSizeSquare);
    public static bool IsValidPNG(Byte[] data, int maxWidth, int maxHeight);
    public static bool IsValidJPG(Byte[] data, int maxSizeSquare);
    public static bool IsValidJPG(Byte[] data, int maxWidth, int maxHeight);
    public static bool IsClear(Color32[] data);
}
public class ImageRenderController : SingletonComponent`1<ImageRenderController> {
    public Camera Camera;
}
public class ImageStorageEntity : BaseEntity {
    private List`1<ImageRequest> _requests;
    protected Type StorageType { get; }
    protected UInt32 CrcToLoad { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    protected virtual Type get_StorageType();
    protected virtual UInt32 get_CrcToLoad();
    [CallsPerSecond("3")]
[RPC_Server]
private void ImageRequested(RPCMessage msg);
}
public class IMagnetLiftable : MonoBehaviour {
    private void Start();
    private void Update();
}
public interface IMetalDetectable {
    public abstract virtual List`1<Vector3> GetScanLocations();
    public abstract virtual Vector3 GetNearestPosition(Vector3 pos);
    public abstract virtual bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos);
    public abstract virtual void Detected(Vector3 pos);
    public abstract virtual float GetRadius();
}
public interface IMissionEntityListener {
    public abstract virtual void MissionStarted(BasePlayer assignee, MissionInstance instance);
    public abstract virtual void MissionEnded(BasePlayer assignee, MissionInstance instance);
}
public interface IMissionProvider {
    public abstract virtual NetworkableId ProviderID();
    public abstract virtual Vector3 ProviderPosition();
    public abstract virtual BaseEntity Entity();
}
public interface IMountable {
}
[RequireComponent("UnityEngine.MeshFilter")]
[RequireComponent("UnityEngine.MeshRenderer")]
[ExecuteInEditMode]
public class Impostor : MonoBehaviour {
    public ImpostorAsset asset;
    [HeaderAttribute("Baking")]
public GameObject reference;
    public float angle;
    public int resolution;
    public int padding;
    public bool spriteOutlineAsMesh;
    private void OnEnable();
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class ImpostorAsset : ScriptableObject {
    public TextureEntry[] textures;
    public Vector2 size;
    public Vector2 pivot;
    public Mesh mesh;
    public Texture2D FindTexture(string name);
}
public class ImpostorBatch : object {
    [CompilerGeneratedAttribute]
private Mesh <Mesh>k__BackingField;
    [CompilerGeneratedAttribute]
private Material <Material>k__BackingField;
    [CompilerGeneratedAttribute]
private ComputeBuffer <PositionBuffer>k__BackingField;
    public FPNativeList`1<Vector4> Positions;
    [CompilerGeneratedAttribute]
private ComputeBuffer <ArgsBuffer>k__BackingField;
    private FPNativeList`1<UInt32> args;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    private Queue`1<int> recycle;
    public Mesh Mesh { get; private set; }
    public Material Material { get; private set; }
    public ComputeBuffer PositionBuffer { get; private set; }
    public ComputeBuffer ArgsBuffer { get; private set; }
    public bool IsDirty { get; public set; }
    public int Count { get; }
    public bool Visible { get; }
    [CompilerGeneratedAttribute]
private void set_Mesh(Mesh value);
    [CompilerGeneratedAttribute]
public Mesh get_Mesh();
    [CompilerGeneratedAttribute]
private void set_Material(Material value);
    [CompilerGeneratedAttribute]
public Material get_Material();
    [CompilerGeneratedAttribute]
private void set_PositionBuffer(ComputeBuffer value);
    [CompilerGeneratedAttribute]
public ComputeBuffer get_PositionBuffer();
    [CompilerGeneratedAttribute]
private void set_ArgsBuffer(ComputeBuffer value);
    [CompilerGeneratedAttribute]
public ComputeBuffer get_ArgsBuffer();
    [CompilerGeneratedAttribute]
public bool get_IsDirty();
    [CompilerGeneratedAttribute]
public void set_IsDirty(bool value);
    public int get_Count();
    public bool get_Visible();
    private ComputeBuffer SafeRelease(ComputeBuffer buffer);
    public void Initialize(Mesh mesh, Material material);
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    public void AddInstance(ImpostorInstanceData data);
    public void RemoveInstance(ImpostorInstanceData data);
    public void UpdateBuffers();
}
public class ImpostorInstanceData : object {
    [CompilerGeneratedAttribute]
private Renderer <Renderer>k__BackingField;
    [CompilerGeneratedAttribute]
private Mesh <Mesh>k__BackingField;
    [CompilerGeneratedAttribute]
private Material <Material>k__BackingField;
    public ImpostorBatch Batch;
    public int BatchIndex;
    private int hash;
    private Vector4 positionAndScale;
    public Renderer Renderer { get; private set; }
    public Mesh Mesh { get; private set; }
    public Material Material { get; private set; }
    public ImpostorInstanceData(Renderer renderer, Mesh mesh, Material material);
    public ImpostorInstanceData(Vector3 position, Vector3 scale, Mesh mesh, Material material);
    [CompilerGeneratedAttribute]
private void set_Renderer(Renderer value);
    [CompilerGeneratedAttribute]
public Renderer get_Renderer();
    [CompilerGeneratedAttribute]
private void set_Mesh(Mesh value);
    [CompilerGeneratedAttribute]
public Mesh get_Mesh();
    [CompilerGeneratedAttribute]
private void set_Material(Material value);
    [CompilerGeneratedAttribute]
public Material get_Material();
    private int GenerateHashCode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Vector4 PositionAndScale();
    public void Update();
}
[RequireComponent("UnityEngine.Camera")]
public class ImpostorRenderer : MonoBehaviour {
    public static string MainPassName;
}
[RequireComponent("UnityEngine.Light")]
public class ImpostorShadows : MonoBehaviour {
}
public class InAttackRangeAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class InAttackRangeEventUI : BaseEventUI {
}
public class IndependentScale : MonoBehaviour {
    public Transform scaleParent;
    public Vector3 initialScale;
}
public class IndependentScaleImagePPU : MonoBehaviour {
    public Transform scaleParent;
    public Image image;
}
public class IndividualSpawner : BaseMonoBehaviour {
    public GameObjectRef entityPrefab;
    public float respawnDelayMin;
    public float respawnDelayMax;
    public bool useCustomBoundsCheckMask;
    public LayerMask customBoundsCheckMask;
    [SerializeField]
[TooltipAttribute("Simply spawns the entity once. No respawning. Entity can be saved if desired.")]
public bool oneTimeSpawner;
    internal bool isSpawnerActive;
    public SpawnPointInstance spawnInstance;
    public float nextSpawnTime;
    public int currentPopulation { get; }
    public bool IsSpawned { get; }
    public sealed virtual int get_currentPopulation();
    public bool get_IsSpawned();
    protected void Awake();
    protected void OnDestroy();
    protected void OnDrawGizmosSelected();
    public sealed virtual void ObjectSpawned(SpawnPointInstance instance);
    public sealed virtual void ObjectRetired(SpawnPointInstance instance);
    public sealed virtual void Fill();
    public sealed virtual void SpawnInitial();
    public sealed virtual void Clear();
    public sealed virtual void SpawnRepeating();
    public bool HasSpaceToSpawn();
    public virtual void TrySpawnEntity();
    public bool TryGetEntityBounds(Bounds& result);
}
public class IndividualSpawnerNexusOnly : IndividualSpawner {
    protected virtual void TrySpawnEntity();
}
public class IndustrialConveyor : IndustrialEntity {
    public int MaxStackSizePerMove;
    public GameObjectRef FilterDialog;
    private static float ScreenUpdateRange;
    public static Flags FilterPassFlag;
    public static Flags FilterFailFlag;
    public static int MaxContainerDepth;
    public SoundDefinition transferItemSoundDef;
    public SoundDefinition transferItemStartSoundDef;
    public List`1<ItemFilter> filterItems;
    public ConveyorMode mode;
    public static int MAX_FILTER_SIZE;
    public Image IconTransferImage;
    private bool refreshInputOutputs;
    private IIndustrialStorage workerOutput;
    private Func`3<IIndustrialStorage, int, bool> filterFunc;
    private List`1<ContainerInputOutput> splitOutputs;
    private List`1<ContainerInputOutput> splitInputs;
    private Nullable`1<bool> lastFilterState;
    private Stopwatch transferStopWatch;
    private bool multiFrameTransferInProcess;
    private int multiFrameOutputIndex;
    private int multiFrameInputIndex;
    private bool isFirstTransfer;
    private bool wasOnWhenPowerLost;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    private void ScheduleMove();
    private Item GetItemToMove(IIndustrialStorage storage, ItemFilter& associatedFilter, int slot, ItemContainer targetContainer);
    private bool FilterHasItem(Item item, ValueTuple`2& filter);
    private bool FilterMatches(ItemFilter filter, Item item);
    private bool FilterContainerInput(IIndustrialStorage storage, int slot);
    protected virtual void RunJob();
    protected virtual void OnIndustrialNetworkChanged();
    public virtual void PostServerLoad();
    private bool CheckIfAnyInputPassesFilters(List`1<ContainerInputOutput> inputs);
    public virtual void Save(SaveInfo info);
    [CallsPerSecond("1")]
[MaxDistance("3")]
[RPC_Server]
private void RPC_ChangeFilters(RPCMessage msg);
    [CallsPerSecond("2")]
[RPC_Server]
[IsVisible("3")]
private void SvSwitch(RPCMessage msg);
    public virtual void SetSwitch(bool wantsOn);
    public void Unbusy();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool ShouldDrainBattery(IOEntity battery);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("1")]
private void Server_RequestUpToDateFilters(RPCMessage msg);
    public virtual void Load(LoadInfo info);
    [CompilerGeneratedAttribute]
internal static bool <RunJob>g__FilterMatchItem|32_1(ItemFilter filter, Item item);
    [CompilerGeneratedAttribute]
internal static void <RunJob>g__AddTransfer|32_2(int itemId, int amount, BaseEntity fromEntity, BaseEntity toEntity, <>c__DisplayClass32_1& );
    [CompilerGeneratedAttribute]
private void <RunJob>g__UpdateFilterPassthroughs|32_0(<>c__DisplayClass32_0& );
}
public class IndustrialCrafter : IndustrialEntity {
    public string LootPanelName;
    public bool NeedsBuildingPrivilegeToUse;
    public bool OnlyOneUser;
    public SoundDefinition ContainerOpenSound;
    public SoundDefinition ContainerCloseSound;
    public AnimationCurve MaterialOffsetCurve;
    public static Flags Crafting;
    public static Flags FullOutput;
    public Renderer MeshRenderer;
    public ParticleSystemContainer JobCompleteFx;
    public SoundDefinition JobCompleteSoundDef;
    [CompilerGeneratedAttribute]
private TimeUntilWithDuration <jobFinishes>k__BackingField;
    public static int BlueprintSlotStart;
    public static int BlueprintSlotEnd;
    public ItemContainer _inventory;
    [CompilerGeneratedAttribute]
private bool <IItemContainerEntity.DropFloats>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ILootableEntity.LastLootedBy>k__BackingField;
    private ItemDefinition currentlyCrafting;
    private int currentlyCraftingAmount;
    private static int StorageSize;
    private static int InputSlotStart;
    private static int InputSlotEnd;
    private static int OutputSlotStart;
    private static int OutputSlotEnd;
    private Phrase _lootPanelTitle;
    public TimeUntilWithDuration jobFinishes { get; private set; }
    public ItemContainer IItemContainerEntity.inventory { get; }
    private Transform IItemContainerEntity.Transform { get; }
    private bool IItemContainerEntity.DropsLoot { get; }
    private float IItemContainerEntity.DestroyLootPercent { get; }
    private bool IItemContainerEntity.DropFloats { get; }
    private ulong ILootableEntity.LastLootedBy { get; private set; }
    private ItemContainer IIndustrialStorage.Container { get; }
    private BaseEntity IIndustrialStorage.IndustrialEntity { get; }
    private Phrase LootPanel.IHasLootPanel.LootPanelTitle { get; }
    public SoundDefinition OpenSound { get; }
    public SoundDefinition CloseSound { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public TimeUntilWithDuration get_jobFinishes();
    [CompilerGeneratedAttribute]
private void set_jobFinishes(TimeUntilWithDuration value);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public sealed virtual override ItemContainer IItemContainerEntity.get_inventory();
    private sealed virtual override Transform IItemContainerEntity.get_Transform();
    private sealed virtual override bool IItemContainerEntity.get_DropsLoot();
    private sealed virtual override float IItemContainerEntity.get_DestroyLootPercent();
    [CompilerGeneratedAttribute]
private sealed virtual override bool IItemContainerEntity.get_DropFloats();
    [CompilerGeneratedAttribute]
private sealed virtual override ulong ILootableEntity.get_LastLootedBy();
    [CompilerGeneratedAttribute]
private sealed virtual override void ILootableEntity.set_LastLootedBy(ulong value);
    public virtual void OnKilled(HitInfo info);
    public sealed virtual void DropItems(BaseEntity initiator);
    public sealed virtual bool ShouldDropItemsIndividually();
    public sealed virtual void DropBonusItems(BaseEntity initiator, ItemContainer container);
    [RPC_Server]
[IsVisible("3")]
private void RPC_OpenLoot(RPCMessage rpc);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void CreateInventory(bool giveUID);
    private bool CanAcceptItem(Item item, int index);
    private void CheckCraft();
    private Item GetTargetBlueprint(int index);
    protected virtual void RunJob();
    private void CompleteCraft();
    private int GetInputAmount(ItemDefinition def);
    private bool ConsumeInputIngredient(ItemAmount am);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    private sealed virtual override ItemContainer IIndustrialStorage.get_Container();
    public sealed virtual Vector2i InputSlotRange(int slotIndex);
    public sealed virtual Vector2i OutputSlotRange(int slotIndex);
    public sealed virtual void OnStorageItemTransferBegin();
    public sealed virtual void OnStorageItemTransferEnd();
    private sealed virtual override BaseEntity IIndustrialStorage.get_IndustrialEntity();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual bool ShouldDrainBattery(IOEntity battery);
    public virtual bool WantsPassthroughPower();
    public virtual bool WantsPower(int inputIndex);
    public virtual void SetSwitch(bool wantsOn);
    public void Unbusy();
    [CallsPerSecond("2")]
[IsVisible("3")]
[RPC_Server]
private void SvSwitch(RPCMessage msg);
    public virtual bool CanPickup(BasePlayer player);
    public sealed virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public sealed virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier);
    private sealed virtual override Phrase LootPanel.IHasLootPanel.get_LootPanelTitle();
    public SoundDefinition get_OpenSound();
    public SoundDefinition get_CloseSound();
    public Workbench GetWorkbench();
}
public class IndustrialEntity : IOEntity {
    public static IndustrialProcessQueue Queue;
    private static IndustrialEntity();
    protected virtual void RunJob();
}
public class IndustrialFilterBuffer : MonoBehaviour {
    public RustText ItemName;
    public Image ItemIcon;
    public GameObject BlueprintRoot;
    public RustSlider BufferSlider;
    public RustText BufferProgressText;
}
public class IndustrialFilterDialog : UIDialog {
    public GameObjectRef ItemPrefab;
    public Transform ItemParent;
    public GameObject ItemSearchParent;
    public ItemSearchEntry ItemSearchEntryPrefab;
    public GameObject NoItemsPrompt;
    public Dropdown FilterModeDropdown;
    public GameObject[] FilterModeExplanations;
    public GameObject FilterModeBlocker;
    public RustText FilterCountText;
    public GameObject BufferRoot;
    public GameObjectRef BufferItemPrefab;
    public Transform BufferTransform;
    public RustButton PasteButton;
    public GameObject[] RegularCopyPasteButtons;
    public GameObject[] JsonCopyPasteButtons;
    public bool closeWhenClicked;
    public int count;
}
public class IndustrialFilterItemIcon : MonoBehaviour {
    public Image ItemIcon;
    public RustText ItemName;
    public RustInput MaxInput;
    public RustInput BufferInput;
    public RustInput MinInput;
    public GameObject BlueprintIcon;
    public GameObject InverseModeBlocker;
}
public class IndustrialStorageAdaptor : IndustrialEntity {
    public GameObject GreenLight;
    public GameObject RedLight;
    public BaseEntity _cachedParent;
    public ItemContainer cachedContainer;
    public BaseEntity cachedParent { get; }
    public ItemContainer Container { get; }
    public BaseEntity IndustrialEntity { get; }
    public BaseEntity get_cachedParent();
    public sealed virtual ItemContainer get_Container();
    public virtual void ServerInit();
    public sealed virtual Vector2i InputSlotRange(int slotIndex);
    public sealed virtual Vector2i OutputSlotRange(int slotIndex);
    public sealed virtual void OnStorageItemTransferBegin();
    public sealed virtual void OnStorageItemTransferEnd();
    public sealed virtual BaseEntity get_IndustrialEntity();
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    public virtual int ConsumptionAmount();
    public void ClientNotifyItemAddRemoved(bool add);
}
public interface INexusTransferTriggerController {
    public abstract virtual bool CanTransfer(BaseEntity entity);
    public abstract virtual ValueTuple`2<string, string> GetTransferDestination();
}
public class InfoBar : MonoBehaviour {
    public Text TextValue;
    public RustText RustTextValue;
    public Image ImageFill;
    public Color GoodColor;
    public Color BadColor;
}
public enum InfrastructureType : Enum {
    public int value__;
    public static InfrastructureType Road;
    public static InfrastructureType Power;
    public static InfrastructureType Trail;
    public static InfrastructureType Tunnel;
    public static InfrastructureType UnderwaterLab;
    public static InfrastructureType Boat;
    public static InfrastructureType Rail;
}
public class IngameMenuBackground : MonoBehaviour {
    public static bool Enabled;
    public CanvasGroup canvasGroup;
}
public interface INotifyEntityTrigger {
    public abstract virtual void OnEntityEnter(BaseEntity ent);
    public abstract virtual void OnEntityLeave(BaseEntity ent);
}
public interface INotifyLOD {
}
public interface INotifyTrigger {
    public abstract virtual void OnObjects(TriggerNotify trigger);
    public abstract virtual void OnEmpty();
}
public class InputState : object {
    public InputMessage current;
    public InputMessage previous;
    private int SwallowedButtons;
    public bool IsDown(BUTTON btn);
    public bool WasDown(BUTTON btn);
    public bool IsAnyDown();
    public bool WasJustPressed(BUTTON btn);
    public bool WasJustReleased(BUTTON btn);
    public void SwallowButton(BUTTON btn);
    public Quaternion AimAngle();
    public Vector3 MouseDelta();
    public void Flip(InputMessage newcurrent);
    public void Clear();
    public void SetMouseDelta(Vector3 d);
}
public class InRangeAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class InRangeEventUI : BaseEventUI {
}
public class InRangeOfHomeAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class InRangeOfHomeEventUI : BaseEventUI {
}
public class InspectorNameAttribute : PropertyAttribute {
    public string name;
    public InspectorNameAttribute(string name);
}
public class InstancedCameraComponent : MonoBehaviour {
    public bool IsMirror;
}
public class InstancedEntityComponent : PrefabAttribute {
    public bool HideInsideNetworkRange;
    protected virtual Type GetIndexedType();
}
public class InstancedMeshFilter : PrefabAttribute {
    public MeshRenderer MeshRenderer;
    public RendererLOD RendererLOD;
    public MeshLOD MeshLOD;
    public InstancedMeshConfig Config;
    protected virtual Type GetIndexedType();
}
public class InstancedScheduler : SingletonComponent`1<InstancedScheduler> {
    public ComputeShader CullShader;
    public ComputeShader SimplePostCullShader;
    public ComputeShader ClearBufferShader;
    public ComputeShader WriteIndirectArgsShader;
    public ComputeShader CopyMeshShader;
    public ConstructionSkin_ColourLookup ContainerColorLookup;
    public List`1<BuildingGrade> coloredSkins;
}
public class Instancing.BuildingBlockConfig : object {
    public UInt32 PrefabId;
    public List`1<BuildingBlockSkin> Skins;
}
public class Instancing.BuildingBlockSkin : object {
    public UInt32 SkinPrefabId;
    public int Grade;
    public ulong Skin;
    public Matrix4x4 LocalToWorld;
}
public class Instancing.BuildingSkinConfig : object {
    public UInt32 PrefabId;
    public List`1<ConditionalModelConfig> Conditionals;
}
public class Instancing.CellHeader : ValueType {
    public int StartIndex;
    public int Count;
    public int PartitionKey;
}
public class Instancing.CellId : ValueType {
    public int Index;
    public CellId(int index);
    public virtual string ToString();
}
public class Instancing.CellMeshAllocator : object {
    public static int CellCapacity;
    private static int initialCellCount;
    public static int InitialCapacity;
    private Dictionary`2<int, CellPartition> partitions;
    private List`1<CellId> recycledCells;
    [CompilerGeneratedAttribute]
private int <CellCount>k__BackingField;
    private Dictionary`2<long, int> meshLookup;
    public Dictionary`2<long, int> sliceIndexLookup;
    private Dictionary`2<int, List`1<long>> sliceLists;
    public NativeArray`1<CellHeader> Cells;
    public NativeArray`1<InstancedCullData> CullData;
    public NativeArray`1<float4x4> PositionData;
    public NativeArray`1<MeshOverrideData> OverrideArray;
    public GPUBuffer`1<float4x4> PositionBuffer;
    public GPUBuffer`1<InstancedCullData> CullingDataBuffer;
    public GPUBuffer`1<MeshOverrideData> OverrideBuffer;
    private bool dirty;
    public int CellCount { get; private set; }
    [CompilerGeneratedAttribute]
public int get_CellCount();
    [CompilerGeneratedAttribute]
private void set_CellCount(int value);
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public CellId AddMesh(InstancedCullData data, int partitionKey, float4x4 localToWorld);
    public bool TryRemoveMesh(long virtualMeshId, InstancedCullData& removedData);
    public Nullable`1<InstancedMeshData> TryGetMeshData(long virtualMeshId);
    public void SetMeshVisible(long virtualMeshId, bool visible);
    public void SetOverride(long virtualMeshId, MeshOverrideData newData);
    private CellId CreateCell(int sortingKey);
    public void ExpandData();
    private void RecycleCell(CellId cellId);
    private CellId GetCellId(int index);
    public void PrintMemoryUsage(StringBuilder builder);
    public void FlushComputeBuffers();
}
[ExtensionAttribute]
public static class Instancing.ComputeBufferEx : object {
    [ExtensionAttribute]
public static void SetBuffer(ComputeShader shader, int kernel, int name, GPUBuffer`1<T> buffer);
}
public class Instancing.ConditionalModelConfig : object {
    public int ModelStateMask;
    public UInt32 TargetPrefabId;
    public Matrix4x4 LocalToWorld;
}
public class Instancing.CullingManager : object {
    public NativeArray`1<RenderSlice> RenderSlicesArray;
    public GPUBuffer`1<RenderSlice> RenderSlicesBuffer;
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public void EnsureCapacity(int rendererCount);
    public void PrintMemoryUsage(StringBuilder builder);
    public void UpdateComputeBuffers();
}
public class Instancing.DrawCallJobData : ValueType {
    public int DrawCallIndex;
    public int RendererIndex;
    public UInt32 IndexCount;
    public UInt32 IndexStart;
    public UInt32 VertexStart;
    public UInt32 MultidrawIndexStart;
    public UInt32 MultidrawVertexStart;
    public int Padding1;
}
public class Instancing.DrawCallKey : ValueType {
    public Material Material;
    public ShadowCastingMode ShadowMode;
    public bool ReceiveShadows;
    public LightProbeUsage LightProbes;
    public DrawCallKey(Material material, ShadowCastingMode shadowMode, bool receiveShadows, LightProbeUsage lightProbes);
    public sealed virtual int CompareTo(DrawCallKey other);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(DrawCallKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DrawCallKey a, DrawCallKey b);
    public static bool op_Inequality(DrawCallKey a, DrawCallKey b);
}
public class Instancing.DrawCallManager : object {
    private CellMeshAllocator cellAllocator;
    private GeometryBuffers GeometryBuffers;
    public NativeArray`1<DrawCallJobData> DrawCallArray;
    public GPUBuffer`1<DrawCallJobData> DrawCallBuffer;
    public GPUBuffer`1<UInt32> IndirectArgsBuffer;
    public GPUBuffer`1<UInt32> IndirectExtraArgBuffer;
    public GPUBuffer`1<UInt32> RenderBuffer;
    private int _overrideBufferVersion;
    private int _positionBufferVersion;
    private List`1<DrawCall> DrawCalls;
    private bool _needsDrawCallRebuild;
    private int IndirectArgCapacity;
    [CompilerGeneratedAttribute]
private int <DrawCallsLastFrame>k__BackingField;
    private static int renderLayer;
    private static int initialCapacity;
    private Bounds cullingBounds;
    public int DrawCallsLastFrame { get; private set; }
    public int DrawCallCount { get; }
    public DrawCallManager(CellMeshAllocator cellAllocator, GeometryBuffers geometryBuffers);
    [CompilerGeneratedAttribute]
public int get_DrawCallsLastFrame();
    [CompilerGeneratedAttribute]
private void set_DrawCallsLastFrame(int value);
    public int get_DrawCallCount();
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public void AddDrawCall(InstancedMeshRenderer renderer, int submeshIndex, UInt32 indicies, UInt32 indiciesIndex, UInt32 vertexIndex, MultidrawMeshInfo multidraw);
    private bool NeedsToRebuildMaterialBlocks();
    private void RebuildAllMaterialBlocks();
    private void UpdateMaterialBlock(DrawCall drawCall);
    public void EnsureCapacity(int totalMeshCount);
    private void EnsureDrawCallCapcity();
    public void UpdateComputeBuffers();
    private void SortAndBatchDrawCalls();
    public void SubmitDrawCalls();
    private void SubmitDrawCallsInternal(Camera camera);
    public void PrintMemoryUsage(StringBuilder builder);
}
public class Instancing.GeometryBuffers : object {
    private int _meshCopyMode;
    public GPUBuffer`1<VertexData> VertexBuffer;
    public GPUBuffer`1<int> TriangleBuffer;
    private int VertexIndex;
    private int TriangleIndex;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    private Dictionary`2<Mesh, MultidrawMeshInfo[]> _meshes;
    public bool IsDirty { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsDirty();
    [CompilerGeneratedAttribute]
public void set_IsDirty(bool value);
    public void Initialize(int meshCopyMode);
    private void ResetStreamPosition();
    public void Destroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public MultidrawMeshInfo[] CopyMesh(Mesh mesh);
    private void CopyMeshViaShader(Mesh mesh);
    public void Rebuild();
    private MultidrawMeshInfo[] CalculateSubmeshInfo(Mesh mesh);
    private void CopyMeshViaCPU(Mesh mesh);
    public void PrintMemoryUsage(StringBuilder builder);
}
public class Instancing.GPUBuffer : object {
}
public class Instancing.GPUBuffer`1 : GPUBuffer {
    [CompilerGeneratedAttribute]
private int <BufferVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphicsBuffer <Buffer>k__BackingField;
    private Target _type;
    [CompilerGeneratedAttribute]
private Target <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <stride>k__BackingField;
    public int BufferVersion { get; private set; }
    public GraphicsBuffer Buffer { get; private set; }
    public Target Type { get; private set; }
    public int count { get; private set; }
    public int stride { get; private set; }
    public int ByteLength { get; }
    public GPUBuffer`1(int length, Target target);
    [CompilerGeneratedAttribute]
public int get_BufferVersion();
    [CompilerGeneratedAttribute]
private void set_BufferVersion(int value);
    [CompilerGeneratedAttribute]
public GraphicsBuffer get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(GraphicsBuffer value);
    [CompilerGeneratedAttribute]
public Target get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Target value);
    [CompilerGeneratedAttribute]
public int get_count();
    [CompilerGeneratedAttribute]
private void set_count(int value);
    [CompilerGeneratedAttribute]
public int get_stride();
    [CompilerGeneratedAttribute]
private void set_stride(int value);
    public int get_ByteLength();
    public void SetData(List`1<T> data);
    public void SetData(List`1<int> data, int nativeArrayIndex, int computeBufferIndex, int length);
    public void SetData(T[] data);
    public void SetData(T[] data, int nativeArrayIndex, int computeBufferIndex, int length);
    public void SetData(NativeArray`1<T> data);
    public void SetData(NativeArray`1<T> data, int nativeArrayIndex, int computeBufferIndex, int length);
    public void ClearData();
    public void Expand(int newCapacity, bool preserveData);
    public void EnsureCapacity(int size, bool preserveData, float expandRatio);
    public sealed virtual void Dispose();
}
public class Instancing.GPUInstancedCulling : object {
    private static int Param_InputBuffer;
    private static int Param_OutputBuffer;
    private static int Param_ComputeBuffer;
    private static int Param_IndirectArgs;
    private static int Param_IndirectExtraArgs;
    private static int Param_RenderSlices;
    private static int Param_SliceCounts;
    private static int Param_FrustumPlanes;
    private static int Param_ShadowFrustumCount;
    private static int Param_CameraPosition;
    private static int Param_MaxDistance;
    private static int Param_DistanceScale;
    private static int Param_SliceCount;
    private static int Param_Length;
    private static int Param_DrawCalls;
    private static int Param_DrawCallCount;
    private static int Param_Multidraw_Enabled;
    private static int Param_FrustumCullingEnabled;
    private GPUBuffer`1<UInt32> tempBuffer;
    private GPUBuffer`1<UInt32> postCullMeshCounts;
    private static GPUInstancedCulling();
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public void SimpleCulling(CullingParameters options);
    private static void CullingShader(ComputeShader shader, GPUBuffer`1<InstancedCullData> inputBuffer, int inputLength, GPUBuffer`1<UInt32> outputBuffer, GPUBuffer`1<RenderSlice> renderSlices, GPUBuffer`1<float4> frustumPlanes, int shadowCameras, Vector3 cameraPosition, float maxDistance, float distanceScale, bool frustumCulling);
    private static void SimplePostCull(ComputeShader shader, GPUBuffer`1<UInt32> inputBuffer, GPUBuffer`1<UInt32> outputBuffer, GPUBuffer`1<RenderSlice> renderSlices, int sliceCount, GPUBuffer`1<UInt32> sliceCounts);
    private static void WriteIndirectArgs(ComputeShader shader, GPUBuffer`1<UInt32> sliceCounts, GPUBuffer`1<RenderSlice> renderSlices, GPUBuffer`1<DrawCallJobData> drawCalls, int drawCallCount, GPUBuffer`1<UInt32> indirectArgs, GPUBuffer`1<UInt32> indirectExtraArgs);
    private static void ClearBuffer(ComputeShader shader, GPUBuffer`1<UInt32> buffer);
    private static int GetIterationCount(int count, int threads);
}
public class Instancing.GridAllocation : ValueType {
    public int StartIndex;
    public int Capacity;
}
public class Instancing.GridJobData : ValueType {
    public int GridId;
    public int StartIndex;
    public int Count;
    public int Capacity;
    public float3 MinBounds;
    public float3 MaxBounds;
    public bool CanBeFrustumCulled;
    public bool CanBeDistanceCulled;
}
public class Instancing.InstancedCommandBufferManager : object {
    private CommandBuffer normalCommandBuffer;
    private CommandBuffer shadowCommandBuffer;
    public void OnCameraEnabled(Camera camera);
    public void OnCameraDisabled(Camera camera);
    public void UpdateCameraHook();
}
public class Instancing.InstancedCullData : ValueType {
    public float3 CullPosition;
    public float3 BoundsMin;
    public float3 BoundsMax;
    public float MinDistance;
    public float MaxDistance;
    public int RendererId;
    public int SliceIndex;
    public BitFlags Flags;
    public long VirtualMeshId;
    public bool IsVisible { get; public set; }
    public bool HasShadow { get; public set; }
    public bool HasMesh { get; public set; }
    public bool LastLOD { get; public set; }
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    public bool get_HasShadow();
    public void set_HasShadow(bool value);
    public bool get_HasMesh();
    public void set_HasMesh(bool value);
    public bool get_LastLOD();
    public void set_LastLOD(bool value);
}
public class Instancing.InstancedCullingManager : object {
    public NativeArray`1<int> RenderSliceIndexes;
    public NativeArray`1<int> PostCullingMeshCounts;
}
public class Instancing.InstancedEntityConfig : object {
    public UInt32 PrefabId;
    public bool HideInsideNetworkRange;
}
public class Instancing.InstancedLODState : object {
    public Mesh Mesh;
    public Material[] Materials;
    public Matrix4x4 LocalToWorld;
    public ShadowCastingMode CastShadows;
    public bool RecieveShadows;
    public LightProbeUsage LightProbes;
    public int LodLevel;
    public int TotalLodLevels;
    public InstancedMeshCategory MeshCategory;
    public float MinimumDistance;
    public float MaximumDistance;
    public InstancedLODState(Matrix4x4 localToWorld, MeshRenderer renderer, float minDistance, float maxDistance, int lodLevel, int lodLevels, InstancedMeshCategory category);
}
public enum Instancing.InstancedMeshCategory : Enum {
    public int value__;
    public static InstancedMeshCategory BuildingBlock;
    public static InstancedMeshCategory Cliff;
    public static InstancedMeshCategory Other;
}
public class Instancing.InstancedMeshConfig : object {
    public List`1<InstancedLODState> states;
}
public class Instancing.InstancedMeshData : ValueType {
    public InstancedCullData CullData;
    public float4x4 LocalToWorld;
}
public class Instancing.InstancedMeshRenderer : object {
    [CompilerGeneratedAttribute]
private int <RendererId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DrawCallIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DrawCallCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Mesh <Mesh>k__BackingField;
    [CompilerGeneratedAttribute]
private Material[] <Materials>k__BackingField;
    [CompilerGeneratedAttribute]
private Material[] <MultidrawMaterials>k__BackingField;
    [CompilerGeneratedAttribute]
private ShadowCastingMode <CastShadows>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecieveShadows>k__BackingField;
    [CompilerGeneratedAttribute]
private LightProbeUsage <LightProbes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Verticies>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Triangles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VertexStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LodLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalLodLevels>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastLod>k__BackingField;
    [CompilerGeneratedAttribute]
private InstancedMeshCategory <MeshCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private MultidrawMeshInfo[] <MultidrawSubmeshes>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3[] <BoundsPoints>k__BackingField;
    public int RendererId { get; }
    public int DrawCallIndex { get; }
    public int DrawCallCount { get; }
    public string MeshName { get; }
    public Mesh Mesh { get; }
    public Material[] Materials { get; private set; }
    public Material[] MultidrawMaterials { get; private set; }
    public ShadowCastingMode CastShadows { get; }
    public bool RecieveShadows { get; }
    public LightProbeUsage LightProbes { get; }
    public int Verticies { get; }
    public int Triangles { get; }
    public int VertexStart { get; private set; }
    public int IndexStart { get; private set; }
    public int LodLevel { get; }
    public int TotalLodLevels { get; }
    public bool IsLastLod { get; }
    public InstancedMeshCategory MeshCategory { get; }
    public MultidrawMeshInfo[] MultidrawSubmeshes { get; }
    public bool HasShadow { get; }
    public bool HasMesh { get; }
    public Vector3[] BoundsPoints { get; }
    public InstancedMeshRenderer(int rendererIndex, int drawCallIndex, MeshRenderKey key, Material[] multidrawMaterials, int lodLevel, int lodLevels, InstancedMeshCategory meshCategory, GeometryBuffers buffers);
    [CompilerGeneratedAttribute]
public int get_RendererId();
    [CompilerGeneratedAttribute]
public int get_DrawCallIndex();
    [CompilerGeneratedAttribute]
public int get_DrawCallCount();
    public string get_MeshName();
    [CompilerGeneratedAttribute]
public Mesh get_Mesh();
    [CompilerGeneratedAttribute]
public Material[] get_Materials();
    [CompilerGeneratedAttribute]
private void set_Materials(Material[] value);
    [CompilerGeneratedAttribute]
public Material[] get_MultidrawMaterials();
    [CompilerGeneratedAttribute]
private void set_MultidrawMaterials(Material[] value);
    [CompilerGeneratedAttribute]
public ShadowCastingMode get_CastShadows();
    [CompilerGeneratedAttribute]
public bool get_RecieveShadows();
    [CompilerGeneratedAttribute]
public LightProbeUsage get_LightProbes();
    [CompilerGeneratedAttribute]
public int get_Verticies();
    [CompilerGeneratedAttribute]
public int get_Triangles();
    [CompilerGeneratedAttribute]
public int get_VertexStart();
    [CompilerGeneratedAttribute]
private void set_VertexStart(int value);
    [CompilerGeneratedAttribute]
public int get_IndexStart();
    [CompilerGeneratedAttribute]
private void set_IndexStart(int value);
    [CompilerGeneratedAttribute]
public int get_LodLevel();
    [CompilerGeneratedAttribute]
public int get_TotalLodLevels();
    [CompilerGeneratedAttribute]
public bool get_IsLastLod();
    [CompilerGeneratedAttribute]
public InstancedMeshCategory get_MeshCategory();
    [CompilerGeneratedAttribute]
public MultidrawMeshInfo[] get_MultidrawSubmeshes();
    public bool get_HasShadow();
    public bool get_HasMesh();
    [CompilerGeneratedAttribute]
public Vector3[] get_BoundsPoints();
    public void SetMaterials(Material[] materials);
    public void SetPlaceholderMaterials(Material[] materials);
    public int GetDrawCallIndex(int submesh);
    public int GetIndirectArgIndex(int submesh);
    public int GetIndirectArgByteIndex(int submesh);
}
public class Instancing.InstancedPrefabConfig : object {
    public UInt32 PrefabId;
    public List`1<InstancedMeshConfig> Meshes;
    public InstancedPrefabConfig(UInt32 prefabId);
}
public static class Instancing.InstancedPrefabConverter : object {
    private static InstancedMeshCategory GetMeshCategory(string prefabPath);
    public static InstancedPrefabConfig ExtractInstancedRenderers(GameObject prefab, UInt32 prefabId, IEnumerable`1<InstancedMeshFilter> instancedFilters);
}
public static class Instancing.InstancedPrefabPreProcess : object {
}
public class Instancing.InstancedRendererJobData : ValueType {
    public int Id;
    public int DrawCallCount;
    public float MinDistance;
    public float MaxDistance;
    public ShadowCastingMode ShadowMode;
    public bool HasMesh { get; }
    public bool HasShadow { get; }
    public bool get_HasMesh();
    public bool get_HasShadow();
}
[ExtensionAttribute]
internal static class Instancing.InstancingUtil : object {
    public static int PositionBufferProperty;
    public static int RenderBufferProperty;
    public static int IndirectExtraArgProperty;
    public static int Param_MeshOverrideBuffer;
    public static int Param_RenderSliceIndexes;
    public static int DrawCallIndexProperty;
    public static int Param_RendererIndex;
    public static int Param_Verticies;
    public static int Param_Triangles;
    public static GlobalKeyword Keyword_Rust_Procedural_Rendering;
    public static int CullingGPUThreads;
    private static InstancingUtil();
    public static float MB(int bytes);
    [ExtensionAttribute]
public static StringBuilder MemoryUsage(StringBuilder builder, string name, ComputeBuffer buffer);
    [ExtensionAttribute]
public static StringBuilder MemoryUsage(StringBuilder builder, string name, GraphicsBuffer buffer);
    [ExtensionAttribute]
public static StringBuilder MemoryUsage(StringBuilder builder, string name, NativeArray`1<T> array, int count);
    [ExtensionAttribute]
public static StringBuilder MemoryUsage(StringBuilder builder, string name, ICollection`1<T> array);
    public static int GetIterationCount(int count, int threads);
}
public class Instancing.JobInt : ValueType {
    private NativeArray`1<int> Array;
    public int Value { get; public set; }
    public int get_Value();
    public void set_Value(int value);
    public static JobInt Create();
    public static void Destroy(JobInt instance);
}
public class Instancing.MaterialCache : object {
    public Dictionary`2<Material, Material> modifiedMaterials;
    public Material EnableProceduralInstancing(Material material);
    private void RequestTextureStreaming(Material material);
    private void RequestMipmap(Material material, string textureName);
    public void FreeMemory();
}
public class Instancing.MeshGridManager : object {
    public NativeArray`1<GridJobData> Grids;
    private float HalfWorldSize;
    private float GridSize;
    private static int GridCount;
    private static int normalGridCount;
    private static int shadowGridCount;
    private static int outOfBoundsGrid;
    private static int lastGridId;
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public int GetPartitionKey(float3 position, bool hasShadow);
    public void SetWorldSize(float worldSize);
    private void UpdateGridBounds();
    private int GetGridId(float3 point);
    private float3 GetGridCenter(int gridId);
    private Bounds GetGridBounds(int gridId);
    public void PrintMemoryUsage(StringBuilder builder);
}
public class Instancing.MeshOverrideData : ValueType {
    public float4 Color;
    public sealed virtual bool Equals(MeshOverrideData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MeshOverrideData left, MeshOverrideData right);
    public static bool op_Inequality(MeshOverrideData left, MeshOverrideData right);
}
public class Instancing.MeshRenderKey : ValueType {
    public Mesh Mesh;
    public Material[] Materials;
    public ShadowCastingMode CastShadows;
    public bool RecieveShadows;
    public LightProbeUsage LightProbeUsages;
    public MeshRenderKey(Mesh mesh, Material[] materials, ShadowCastingMode castShadows, bool recieveShadows, LightProbeUsage lightProbes);
    public sealed virtual bool Equals(MeshRenderKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Instancing.MultidrawMeshInfo : ValueType {
    public int VertexStart;
    public int VertexCount;
    public int IndexStart;
}
[BurstCompileAttribute]
public class Instancing.PreCullingJob : ValueType {
    [ReadOnlyAttribute]
public NativeArray`1<InstancedRendererJobData> Meshes;
    [ReadOnlyAttribute]
public int RendererCount;
    [ReadOnlyAttribute]
public NativeArray`1<UInt32> CountPerMesh;
    [ReadOnlyAttribute]
public NativeArray`1<DrawCallJobData> DrawCalls;
    [ReadOnlyAttribute]
public int DrawCallCount;
    [WriteOnlyAttribute]
public NativeArray`1<RenderSlice> RenderSlices;
    public sealed virtual void Execute();
    private void CalculateRenderSlices();
}
public class Instancing.PrefabRenderKey : ValueType {
    public UInt32 PrefabId;
    public int Grade;
    public ulong Skin;
    public PrefabRenderKey(UInt32 prefabId, int grade, ulong skin);
    public sealed virtual bool Equals(PrefabRenderKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Instancing.RenderManager : object {
    public NativeArray`1<InstancedRendererJobData> RendererArray;
    public NativeArray`1<UInt32> MeshCountArray;
    private Dictionary`2<MeshRenderKey, InstancedMeshRenderer> rendererLookup;
    public List`1<InstancedMeshRenderer> Renderers;
    public GeometryBuffers GeometryBuffers;
    [CompilerGeneratedAttribute]
private int <TotalMeshCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalDrawCallCount>k__BackingField;
    private static int initialRendererCapacity;
    private DrawCallManager drawCallManager;
    private MaterialCache _materialCache;
    public int TotalMeshCount { get; private set; }
    public int TotalDrawCallCount { get; private set; }
    public int RendererCount { get; }
    public RenderManager(DrawCallManager drawCalls, GeometryBuffers geometryBuffers, MaterialCache materialCache);
    [CompilerGeneratedAttribute]
public int get_TotalMeshCount();
    [CompilerGeneratedAttribute]
private void set_TotalMeshCount(int value);
    [CompilerGeneratedAttribute]
public int get_TotalDrawCallCount();
    [CompilerGeneratedAttribute]
private void set_TotalDrawCallCount(int value);
    public int get_RendererCount();
    public void Initialize();
    public void OnDestroy();
    private void AllocateNativeMemory();
    private void FreeNativeMemory();
    public void OnMeshAdded(int rendererId);
    public void OnMeshRemoved(int rendererId);
    public Bounds CalculateMeshBounds(int meshId, Matrix4x4 localToWorld);
    public bool DoesRendererHaveShadow(int meshId);
    public bool DoesRendererHaveMesh(int rendererId);
    public bool IsLastLOD(int rendererId);
    public int GetRendererId(InstancedLODState lod);
    public float GetMinDistance(int rendererId);
    public float GetMaxDistance(int rendererId);
    public Mesh GetMeshForRenderer(int rendererId);
    private InstancedMeshRenderer GetRenderer(InstancedLODState lod);
    private InstancedMeshRenderer RegisterRenderer(InstancedLODState lod);
    private void EnsureJobDataCapacity();
    public void PrintMemoryUsage(StringBuilder builder);
    [CompilerGeneratedAttribute]
private Material <RegisterRenderer>b__34_0(Material x);
}
public class Instancing.RenderSlice : ValueType {
    public UInt32 StartIndex;
    public UInt32 Length;
}
public class Instancing.RenderUpdate : ValueType {
    public UInt32 PrefabId;
    public NetworkableId NetworkId;
    public int Grade;
    public ulong Skin;
    public int ModelState;
    public Vector3 Position;
    public Quaternion Rotation;
    public Color CustomColor;
    public int CustomColorIndex;
    public bool IsGlobalUpdate;
    public bool InsideNetworkRange;
}
public class Instancing.TextureAtlasScheduler : object {
    public static TextureAtlasScheduler Instanced;
    private Dictionary`2<int, TextureAtlas> textureAtlases;
    private static TextureAtlasScheduler();
    private int AddTexture(TextureAtlas atlas, Texture texture);
    private void UpdateTexture(TextureAtlas atlas, Texture texture, int index);
    public int AddTextureToAtlas(Texture texture);
    public void ReplaceTextureInAtlas(Texture texture, int index);
    private TextureAtlas GetOrCreateAtlas(int width, int height);
    private int GetResolutionKey(int xSize, int ySize);
}
public class Instancing.VirtualMeshScheduler : object {
    public static VirtualMeshScheduler Instance;
    private static VirtualMeshScheduler();
}
public class Instancing.VirtualPrefabScheduler : object {
}
public class Instancing.WorkshopSkinScheduler : object {
    private Dictionary`2<ulong, SkinData> skinLookup;
    private Dictionary`2<ulong, Skinnable> skinnableLookup;
    public SkinTexture[] GetTextures(Skin skinDef, ulong skinId);
    private SkinnableData GetOrCreateSkinnable(Skin skinDef);
    private SkinData InitializeSkin(Skin skinDef, ulong skinId);
    private string FindSkinTexturePath(ulong workshopSkin);
    private void LoadTextureAsync(string path, int resolution, int textureIndex);
}
public class InstancingConfigComponent : PrefabAttribute {
    public bool DisableInstancing;
    protected virtual Type GetIndexedType();
}
public class InstantCameraTool : HeldEntity {
    public ItemDefinition photoItem;
    public GameObjectRef screenshotEffect;
    public SoundDefinition startPhotoSoundDef;
    public SoundDefinition finishPhotoSoundDef;
    [RangeAttribute("640", "1920")]
public int resolutionX;
    [RangeAttribute("480", "1080")]
public int resolutionY;
    [RangeAttribute("10", "100")]
public int quality;
    [RangeAttribute("0", "5")]
public float cooldownSeconds;
    public TimeSince _sinceLastPhoto;
    private bool hasSentAchievement;
    public static string PhotographPlayerAchievement;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("3")]
private void TakePhoto(RPCMessage msg);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
}
public class InstrumentDebugInput : MonoBehaviour {
    public InstrumentKeyController KeyController;
    public KeySet Note;
    public float Frequency;
    public float StopAfter;
    public SoundDefinition OverrideDefinition;
}
public class InstrumentIKController : MonoBehaviour {
    public Vector3 HitRotationVector;
    public Transform[] LeftHandIkTargets;
    public Transform[] LeftHandIKTargetHitRotations;
    public Transform[] RightHandIkTargets;
    public Transform[] RightHandIKTargetHitRotations;
    public Transform[] RightFootIkTargets;
    public AnimationCurve HandHeightCurve;
    public float HandHeightMultiplier;
    public float HandMoveLerpSpeed;
    public bool DebugHitRotation;
    public AnimationCurve HandHitCurve;
    public float NoteHitTime;
    [HeaderAttribute("Look IK")]
public float BodyLookWeight;
    public float HeadLookWeight;
    public float LookWeightLimit;
    public bool HoldHandsAtPlay;
}
public class InstrumentIKTargetAttribute : PropertyAttribute {
}
public class InstrumentKeyController : MonoBehaviour {
    public static float DEFAULT_NOTE_VELOCITY;
    public NoteBindingCollection Bindings;
    public NoteBinding[] NoteBindings;
    public Transform[] NoteSoundPositions;
    public InstrumentIKController IKController;
    public Transform LeftHandProp;
    public Transform RightHandProp;
    public Animator InstrumentAnimator;
    public BaseEntity RPCHandler;
    public UInt32 overrideAchievementId;
    [CompilerGeneratedAttribute]
private bool <PlayedNoteThisFrame>k__BackingField;
    private static string ALL_NOTES_STATNAME;
    public bool PlayedNoteThisFrame { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_PlayedNoteThisFrame();
    [CompilerGeneratedAttribute]
private void set_PlayedNoteThisFrame(bool value);
    public void ProcessServerPlayedNote(BasePlayer forPlayer);
}
public class InstrumentStateBehaviour : StateMachineBehaviour {
}
public class InstrumentTool : HeldEntity {
    public InstrumentKeyController KeyController;
    public SoundDefinition DeploySound;
    public Vector2 PitchClamp;
    public bool UseAnimationSlotEvents;
    public Transform MuzzleT;
    public bool UsableByAutoTurrets;
    private NoteData lastPlayedTurretData;
    public Transform MuzzleTransform { get; }
    public bool IsUsableByTurret { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual Transform get_MuzzleTransform();
    [RPC_Server]
private void Server_PlayNote(RPCMessage msg);
    [RPC_Server]
private void Server_StopNote(RPCMessage msg);
    public virtual void ServerUse();
    private void StopAfterTime();
    public virtual bool get_IsUsableByTurret();
    public virtual bool IsInstrument();
}
public class InstrumentToolGuitar : InstrumentTool {
    public Transform InUseAligner;
    public Transform DeployAligner;
    public string DeployBone;
}
public class InstrumentViewmodel : MonoBehaviour {
    public Animator ViewAnimator;
    public bool UpdateA;
    public bool UpdateB;
    public bool UpdateC;
    public bool UpdateD;
    public bool UpdateE;
    public bool UpdateF;
    public bool UpdateG;
    public bool UpdateRecentlyPlayed;
    public bool UpdatePlayedNoteTrigger;
    public bool UseTriggers;
    private int note_a;
    private int note_b;
    private int note_c;
    private int note_d;
    private int note_e;
    private int note_f;
    private int note_g;
    private int recentlyPlayedHash;
    private int playedNoteHash;
    public void UpdateSlots(AnimationSlot currentSlot, bool recentlyPlayed, bool playedNoteThisFrame);
    private void UpdateState(int param, bool state);
}
public class InventoryUI : MonoBehaviour {
    public GameObject ContactsButton;
    public GameObject ClanButton;
}
public class InvisibleVendingMachine : NPCVendingMachine {
    public GameObjectRef buyEffect;
    public NPCVendingOrderManifest vmoManifest;
    public bool canRefreshOrders;
    public EntityRef`1<NPCShopKeeper> cachedShopKeeper;
    public static Flags HasAttachedShopkeeper;
    private static ListHashSet`1<InvisibleVendingMachine> allMachines;
    public TimeUntil nextOrderRefresh;
    protected bool BlockOrderRefreshOnLoad { get; }
    private static InvisibleVendingMachine();
    public static InvisibleVendingMachine GetMachineAtPosition(float tolerance, Vector3 position);
    public void KeeperLookAt(Vector3 pos);
    public virtual bool HasVendingSounds();
    public virtual float GetBuyDuration();
    public virtual void CompletePendingOrder();
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    protected virtual bool get_BlockOrderRefreshOnLoad();
    internal virtual void DoServerDestroy();
    public void CheckSellOrderRefresh();
    public void SetAttachedNPC(NPCShopKeeper shopkeeper);
    public virtual bool CanBeLooted(BasePlayer player);
    protected virtual bool CanShop(BasePlayer bp);
    public virtual void Load(LoadInfo info);
}
public class InvokeSpammer : MonoBehaviour {
    public int InvokeMilliseconds;
    public float RepeatTime;
    private void Start();
    private void TestInvoke();
}
public abstract class IOConfig`1 : UIDialog {
    [SpaceAttribute]
public RustInput input;
    public float minValue;
    public float maxValue;
}
public class IOEntity : DecayEntity {
    [HeaderAttribute("IOEntity")]
public Transform debugOrigin;
    public ItemDefinition sourceItem;
    public int lastResetIndex;
    [HelpAttribute("How many milliseconds to budget for processing high priority electric io entities per server frame (monuments)")]
[ServerVar]
public static float frameBudgetElectricHighPriorityMs;
    [HelpAttribute("How many milliseconds to budget for processing low priority io entities per server frame (player placed)")]
[ServerVar]
public static float frameBudgetElectricLowPriorityMs;
    [ServerVar]
[HelpAttribute("How many milliseconds to budget for processing fluid io entities per server frame")]
public static float frameBudgetFluidMs;
    [ServerVar]
[HelpAttribute("How many milliseconds to budget for processing kinetic io entities per server frame (monuments)")]
public static float frameBudgetKineticMs;
    [ServerVar]
[HelpAttribute("How many milliseconds to budget for processing generic io entities per server frame (unused for now)")]
public static float frameBudgetGenericMs;
    [ServerVar]
[HelpAttribute("How many milliseconds to budget for processing industrial entities per server frame")]
public static float frameBudgetIndustrialMs;
    [ServerVar]
public static float responsetime;
    [ServerVar]
public static int backtracking;
    [ServerVar]
public static bool debugBudget;
    [ServerVar]
public static float debugBudgetThreshold;
    public static Flags Flag_ShortCircuit;
    public static Flags Flag_HasPower;
    public IOSlot[] inputs;
    public IOSlot[] outputs;
    public IOType ioType;
    public static Dictionary`2<QueueType, Queue`1<IOEntity>> _processQueues;
    public static Dictionary`2<QueueType, string> _processQueueProfilerString;
    private static List`1<FrameTiming> timings;
    public int cachedOutputsUsed;
    public int lastPassthroughEnergy;
    public int lastEnergy;
    public int currentEnergy;
    private int changedCount;
    private float lastChangeTime;
    public float lastUpdateTime;
    public int lastUpdateBlockedFrame;
    public bool ensureOutputsUpdated;
    public static int MaxContainerSourceCount;
    private List`1<Collider> spawnedColliders;
    public bool IsGravitySource { get; }
    protected bool PreventDuplicatesInQueue { get; }
    private bool HasBlockedUpdatedOutputsThisFrame { get; }
    public bool BlockFluidDraining { get; }
    protected float LiquidPassthroughGravityThreshold { get; }
    protected bool DisregardGravityRestrictionsOnLiquid { get; }
    private static IOEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public Phrase GetDisplayName();
    public virtual bool IsRootEntity();
    public virtual bool get_IsGravitySource();
    public IOEntity FindGravitySource(Vector3& worldHandlePosition, int depth, bool ignoreSelf);
    public virtual void SetFuelType(ItemDefinition def, IOEntity source);
    public virtual bool WantsPower(int inputIndex);
    public virtual bool AllowWireConnections();
    public virtual bool WantsPassthroughPower();
    public virtual int ConsumptionAmount();
    public virtual bool ShouldDrainBattery(IOEntity battery);
    public virtual bool ShouldBlockCircuit(IOEntity battery);
    public virtual int MaximalPowerOutput();
    public virtual bool AllowDrainFrom(int outputSlot);
    public QueueType GetQueueType();
    public static float GetFrameBudgetForQueue(QueueType type);
    public virtual bool IsPowered();
    public bool IsConnectedToAnySlot(IOEntity entity, int slot, int depth, bool defaultReturn);
    public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn);
    public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn);
    protected virtual bool ConsiderConnectedTo(IOEntity entity);
    [RPC_Server]
[IsVisible("6")]
[CallsPerSecond("10")]
private void Server_RequestData(RPCMessage msg);
    public virtual void SendAdditionalData(BasePlayer player, int slot, bool input);
    protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot);
    public static void ProcessQueue();
    [ServerVar]
public static void DebugQueue(Arg arg);
    public virtual void ResetIOState();
    public virtual void Init();
    internal virtual void DoServerDestroy();
    public void ClearConnections();
    public void Shutdown();
    public void MarkDirtyForceUpdateOutputs();
    public void UpdateUsedOutputs();
    public virtual void MarkDirty();
    public virtual int DesiredPower(int inputIndex);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    public virtual int GetCurrentEnergy();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public void TouchInternal();
    protected virtual bool get_PreventDuplicatesInQueue();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public virtual void TouchIOState();
    public virtual void SendIONetworkUpdate();
    public bool IsFlickering();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void OnCircuitChanged(bool forceUpdate);
    public virtual void SendChangedToRoot(bool forceUpdate);
    public virtual void SendChangedToRootRecursive(bool forceUpdate, List`1& existing);
    public void NotifyIndustrialNetworkChanged();
    private void NotifyIndustrialNetworkChanged(List`1<IOEntity> existing, bool input, int maxDepth);
    protected virtual void OnIndustrialNetworkChanged();
    public bool ShouldUpdateOutputs();
    private bool get_HasBlockedUpdatedOutputsThisFrame();
    public virtual void UpdateOutputs();
    public virtual void Spawn();
    public virtual void PostServerLoad();
    public virtual void PostMapEntitySpawn();
    public virtual void Save(SaveInfo info);
    public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot);
    public virtual bool get_BlockFluidDraining();
    public bool Disconnect(int index, bool isInput);
    public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex);
    public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex, List`1<Vector3> points, List`1<float> slackLevels, LineAnchor[] lineAnchors, WireColour colour);
    public void FindContainerSource(List`1<ContainerInputOutput> found, int depth, bool input, List`1<IOEntity> ignoreList, int parentId, int stackSize);
    protected virtual float get_LiquidPassthroughGravityThreshold();
    protected virtual bool get_DisregardGravityRestrictionsOnLiquid();
    public virtual bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement);
    public virtual void Load(LoadInfo info);
    public int GetConnectedInputCount();
    public int GetConnectedOutputCount();
    public bool HasConnections();
    public virtual void DestroyShared();
    public void RefreshIndustrialPreventBuilding();
    private void ClearIndustrialPreventBuilding();
    [CompilerGeneratedAttribute]
internal static int <FindContainerSource>g__GetExistingCount|107_0(IIndustrialStorage storage, <>c__DisplayClass107_0& );
}
public class IOEntityInformationPanel : ItemInformationPanel {
    public ItemTextValue requiredPowerDisplay;
    public ItemTextValue requiredFluidDisplay;
    public ItemTextValue generatedPowerDisplay;
    public ItemTextValue capacityDisplay;
    public ItemTextValue chargeDisplay;
    public ItemTextValue rangeDisplay;
}
[RequireComponent("IOEntity")]
public class IOEntityMovementChecker : FacepunchBehaviour {
    private IOEntity ioEntity;
    private Vector3 prevPos;
    private static float MAX_MOVE;
    private static float MAX_MOVE_SQR;
    protected void Awake();
    protected void OnEnable();
    protected void OnDisable();
    private void CheckPosition();
}
public class IOEntityUISlotEntry : MonoBehaviour {
    public RawImage icon;
    public Text leftText;
    public Text rightText;
}
public class IOManager : SingletonComponent`1<IOManager> {
}
public interface IOnParentDestroying {
    public abstract virtual void OnParentDestroying();
}
public interface IOnParentSpawning {
    public abstract virtual void OnParentSpawning();
}
public interface IOnPostNetworkUpdate {
    public abstract virtual void OnPostNetworkUpdate(BaseEntity entity);
}
public interface IOnSendNetworkUpdate {
    public abstract virtual void OnSendNetworkUpdate(BaseEntity entity);
}
[JsonModelAttribute]
public class IPAddressJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
public interface IPathListener {
    public abstract virtual void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction);
    public abstract virtual void OnBasePathTrigger(int pathId, BasePath path);
}
public interface IPet {
    public abstract virtual bool IsPet();
    public abstract virtual void SetPetOwner(BasePlayer player);
    public abstract virtual bool IsOwnedBy(BasePlayer player);
    public abstract virtual bool IssuePetCommand(PetCommandType cmd, int param, Nullable`1<Ray> ray);
}
public interface IPoolVehicle {
    public abstract virtual void OnPoolDestroyed();
    public abstract virtual void WakeUp();
}
public interface IPosLerpTarget {
    public abstract virtual float GetInterpolationInertia();
    public abstract virtual Vector3 GetNetworkPosition();
    public abstract virtual Quaternion GetNetworkRotation();
    public abstract virtual void SetNetworkPosition(Vector3 pos);
    public abstract virtual void SetNetworkRotation(Quaternion rot);
    public abstract virtual void DrawInterpolationState(Segment<TransformSnapshot> segment, List`1<TransformSnapshot> entries);
    public abstract virtual void LerpIdleDisable();
}
public interface IPreInventoryChanged {
}
internal interface IRagdollInhert {
}
public interface IRemoteControllable {
    public bool RequiresMouse { get; }
    public float MaxRange { get; }
    public RemoteControllableControls RequiredControls { get; }
    public Nullable`1<CameraViewerId> ControllingViewerId { get; }
    public bool CanPing { get; }
    public abstract virtual Transform GetEyes();
    public abstract virtual float GetFovScale();
    public abstract virtual BaseEntity GetEnt();
    public abstract virtual string GetIdentifier();
    public abstract virtual float Health();
    public abstract virtual float MaxHealth();
    public abstract virtual void UpdateIdentifier(string newID, bool clientSend);
    public abstract virtual void RCSetup();
    public abstract virtual void RCShutdown();
    public abstract virtual bool CanControl(ulong playerID);
    public abstract virtual bool get_RequiresMouse();
    public abstract virtual float get_MaxRange();
    public abstract virtual RemoteControllableControls get_RequiredControls();
    public abstract virtual Nullable`1<CameraViewerId> get_ControllingViewerId();
    public abstract virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public abstract virtual bool InitializeControl(CameraViewerId viewerID);
    public abstract virtual void StopControl(CameraViewerId viewerID);
    public abstract virtual bool get_CanPing();
}
public interface IRemoteControllableClientCallbacks {
}
public interface IRFObject {
    public abstract virtual Vector3 GetPosition();
    public abstract virtual float GetMaxRange();
    public abstract virtual void RFSignalUpdate(bool on);
    public abstract virtual int GetFrequency();
}
public class IronsightAimPoint : MonoBehaviour {
    public Transform targetPoint;
    private void OnDrawGizmos();
    private void DrawArrow(Vector3 start, Vector3 end, float arrowLength);
}
public class IronSightOverride : MonoBehaviour {
    public IronsightAimPoint aimPoint;
    public float fieldOfViewOffset;
    public float zoomFactor;
    [TooltipAttribute("If set to 1, the FOV is set to what this override is set to. If set to 0.5 it's half way between the weapon iconsights default and this scope.")]
public float fovBias;
}
public class IronSights : MonoBehaviour {
    [HeaderAttribute("View Setup")]
public IronsightAimPoint aimPoint;
    public float fieldOfViewOffset;
    public float zoomFactor;
    [HeaderAttribute("Animation")]
public float introSpeed;
    public AnimationCurve introCurve;
    public float outroSpeed;
    public AnimationCurve outroCurve;
    [HeaderAttribute("Sounds")]
public SoundDefinition upSound;
    public SoundDefinition downSound;
    [HeaderAttribute("Info")]
public IronSightOverride ironsightsOverride;
    public bool processUltrawideOffset;
}
public class IsBlindedAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class IsBlindedEventUI : BaseEventUI {
}
public interface IServerFileReceiver {
}
public interface ISignage {
    public Vector2i TextureSize { get; }
    public int TextureCount { get; }
    public NetworkableId NetworkID { get; }
    public Type FileType { get; }
    public abstract virtual bool CanUpdateSign(BasePlayer player);
    public abstract virtual float Distance(Vector3 position);
    public abstract virtual Vector2i get_TextureSize();
    public abstract virtual int get_TextureCount();
    public abstract virtual UInt32[] GetTextureCRCs();
    public abstract virtual NetworkableId get_NetworkID();
    public abstract virtual Type get_FileType();
    public abstract virtual void SetTextureCRCs(UInt32[] crcs);
}
public class IsMountedAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class IsMountedEventUI : BaseEventUI {
}
public interface ISoundBudgetedUpdate {
    public abstract virtual void DoUpdate();
    public abstract virtual bool IsSyncedToParent();
}
public interface ISpawnGroup {
    public int currentPopulation { get; }
    public abstract virtual void Clear();
    public abstract virtual void Fill();
    public abstract virtual void SpawnInitial();
    public abstract virtual void SpawnRepeating();
    public abstract virtual int get_currentPopulation();
}
public interface ISpawnPointUser {
    public abstract virtual void ObjectSpawned(SpawnPointInstance instance);
    public abstract virtual void ObjectRetired(SpawnPointInstance instance);
}
public interface ISplashable {
    public abstract virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public abstract virtual int DoSplash(ItemDefinition splashType, int amount);
}
public interface ISubscribable {
    public abstract virtual bool AddSubscription(ulong steamId);
    public abstract virtual bool RemoveSubscription(ulong steamId);
    public abstract virtual bool HasSubscription(ulong steamId);
}
public class IsVisibleAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class IsVisibleEventUI : BaseEventUI {
}
public class Item : object {
    private static string DefaultArmourBreakEffectPath;
    public float _condition;
    public float _maxCondition;
    public ItemDefinition info;
    public ItemId uid;
    public bool dirty;
    public int amount;
    public int position;
    public float busyTime;
    public float removeTime;
    public float fuel;
    public bool isServer;
    public InstanceData instanceData;
    public ulong skin;
    public string name;
    public string streamerName;
    public string text;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ammoCount>k__BackingField;
    public float cookTimeLeft;
    public float radioactivity;
    [CompilerGeneratedAttribute]
private Action`1<Item> OnDirty;
    public Flag flags;
    public ItemContainer contents;
    public ItemContainer parent;
    private EntityRef worldEnt;
    private EntityRef heldEntity;
    [CompilerGeneratedAttribute]
private Action`2<Item, float> onCycle;
    public float condition { get; public set; }
    public float maxCondition { get; public set; }
    public float maxConditionNormalized { get; }
    public float conditionNormalized { get; public set; }
    public bool hasCondition { get; }
    public bool isBroken { get; }
    public Nullable`1<int> ammoCount { get; public set; }
    public int despawnMultiplier { get; }
    public ItemDefinition blueprintTargetDef { get; }
    public int blueprintTarget { get; public set; }
    public int blueprintAmount { get; public set; }
    public Item parentItem { get; }
    public float temperature { get; }
    public TraitFlag Traits { get; }
    public void set_condition(float value);
    public float get_condition();
    public void set_maxCondition(float value);
    public float get_maxCondition();
    public float get_maxConditionNormalized();
    public float get_conditionNormalized();
    public void set_conditionNormalized(float value);
    public bool get_hasCondition();
    public bool get_isBroken();
    public void LoseCondition(float amount);
    public void RepairCondition(float amount);
    public void DoRepair(float maxLossFraction);
    public ItemContainer GetRootContainer();
    public virtual void OnBroken();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ammoCount();
    [CompilerGeneratedAttribute]
public void set_ammoCount(Nullable`1<int> value);
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    public string GetName(Nullable`1<bool> streamerModeOverride);
    public int get_despawnMultiplier();
    public ItemDefinition get_blueprintTargetDef();
    public int get_blueprintTarget();
    public void set_blueprintTarget(int value);
    public int get_blueprintAmount();
    public void set_blueprintAmount(int value);
    public bool IsBlueprint();
    [CompilerGeneratedAttribute]
public void add_OnDirty(Action`1<Item> value);
    [CompilerGeneratedAttribute]
public void remove_OnDirty(Action`1<Item> value);
    public bool HasFlag(Flag f);
    public void SetFlag(Flag f, bool b);
    public bool IsOn();
    public bool IsOnFire();
    public bool IsCooking();
    public bool IsLocked();
    public bool IsRadioactive();
    public Item get_parentItem();
    public void MarkDirty();
    public void OnChanged();
    public void CollectedForCrafting(BasePlayer crafter);
    public void ReturnedFromCancelledCraft(BasePlayer crafter);
    public void Initialize(ItemDefinition template);
    public void OnItemCreated();
    public void OnVirginSpawn();
    public float GetDespawnDuration();
    public void RemoveFromWorld();
    public void OnRemovedFromWorld();
    public void RemoveFromContainer();
    public bool DoItemSlotsConflict(Item other);
    public void SetParent(ItemContainer target);
    public void RecalulateParentEntity(bool children);
    private void ForbidHeldEntitySaving();
    private void RestoreHeldEntitySaving();
    public void OnAttacked(HitInfo hitInfo);
    public BaseEntity GetEntityOwner();
    public bool IsChildContainer(ItemContainer c);
    public bool CanMoveTo(ItemContainer newcontainer, int iTargetPos);
    public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap);
    private void RemoveConflictingSlots(ItemContainer container, BaseEntity entityOwner, BasePlayer sourcePlayer);
    public BaseEntity CreateWorldObject(Vector3 pos, Quaternion rotation, BaseEntity parentEnt, UInt32 parentBone);
    public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation);
    public BaseEntity DropAndTossUpwards(Vector3 vPos, float force);
    public bool IsBusy();
    public void BusyFor(float fTime);
    public bool IsRemoved();
    public void Remove(float fTime);
    public void DoRemove();
    public void SwitchOnOff(bool bNewState);
    public void LockUnlock(bool bNewState);
    public float get_temperature();
    public BasePlayer GetOwnerPlayer();
    public bool IsBackpack();
    public int GetChildItemCount();
    public int GetItemVolume();
    public Item SplitItem(int split_Amount);
    public void UnloadAmmo();
    public bool CanBeHeld();
    public bool CanStack(Item item);
    public bool IsValid();
    public bool IsDroppedInWorld(bool serverside);
    public void SetWorldEntity(BaseEntity ent);
    public void OnMovedToWorld();
    public BaseEntity GetWorldEntity();
    public void SetHeldEntity(BaseEntity ent);
    public BaseEntity GetHeldEntity();
    [CompilerGeneratedAttribute]
public void add_onCycle(Action`2<Item, float> value);
    [CompilerGeneratedAttribute]
public void remove_onCycle(Action`2<Item, float> value);
    public void OnCycle(float delta);
    public void ServerCommand(string command, BasePlayer player);
    public void UseItem(int amountToConsume);
    public bool HasAmmo(AmmoTypes ammoType);
    public Item FindAmmo(AmmoTypes ammoType);
    public void FindAmmo(List`1<Item> list, AmmoTypes ammoType);
    public int GetAmmoAmount(AmmoTypes ammoType);
    public int GetAmmoAmount(List`1<AmmoTypes> ammoTypes);
    public virtual string ToString();
    public Item FindItem(ItemId iUID);
    public int MaxStackable();
    private void SetRadioactivity(ItemDefinition template);
    public TraitFlag get_Traits();
    public GameObjectRef GetWorldModel();
    public virtual Item Save(bool bIncludeContainer, bool bIncludeOwners);
    public virtual void Load(Item load);
}
public class ItemAmount : object {
    [ItemSelector("11")]
public ItemDefinition itemDef;
    public float amount;
    public float startAmount;
    public bool ignoreInTutorial;
    public bool isBP;
    public int itemid { get; }
    public ItemAmount(ItemDefinition item, float amt);
    public int get_itemid();
    public virtual float GetAmount();
    public virtual void OnAfterDeserialize();
    public virtual void OnBeforeSerialize();
    public static ItemAmountList SerialiseList(List`1<ItemAmount> list);
    public static void DeserialiseList(List`1<ItemAmount> target, ItemAmountList source);
}
public class ItemAmountRandom : object {
    [ItemSelector("11")]
public ItemDefinition itemDef;
    public AnimationCurve amount;
    public int RandomAmount();
}
public class ItemAmountRanged : ItemAmount {
    public float maxAmount;
    public ItemAmountRanged(ItemDefinition item, float amt, float max);
    public virtual void OnAfterDeserialize();
    public virtual float GetAmount();
}
public class ItemBasedFlowRestrictor : IOEntity {
    public ItemDefinition passthroughItem;
    public ContentsType allowedContents;
    public int maxStackSize;
    public int numSlots;
    public string lootPanelName;
    public static Flags HasPassthrough;
    public static Flags Sparks;
    public float passthroughItemConditionLossPerSec;
    public SoundDefinition openSound;
    public SoundDefinition closeSound;
    public ItemContainer inventory;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual bool HasPassthroughItem();
    public virtual void TickPassthroughItem();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void PreServerLoad();
    public void CreateInventory(bool giveUID);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void OnInventoryFirstCreated(ItemContainer container);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    [RPC_Server]
[IsVisible("3")]
private void RPC_OpenLoot(RPCMessage rpc);
    public void PlayerStoppedLooting(BasePlayer player);
}
public class ItemBlueprint : MonoBehaviour {
    public List`1<ItemAmount> ingredients;
    public List`1<ItemDefinition> additionalUnlocks;
    public bool defaultBlueprint;
    public bool userCraftable;
    public bool isResearchable;
    public bool forceShowInConveyorFilter;
    public Rarity rarity;
    [HeaderAttribute("Workbench")]
public int workbenchLevelRequired;
    [HeaderAttribute("Scrap")]
public int scrapRequired;
    public int scrapFromRecycle;
    [HeaderAttribute("Unlocking")]
[TooltipAttribute("This item won't show anywhere unless you have the corresponding SteamItem in your inventory - which is defined on the ItemDefinition")]
public bool NeedsSteamItem;
    public int blueprintStackSize;
    public float time;
    public int amountToCreate;
    public string UnlockAchievment;
    public string RecycleStat;
    public ItemDefinition targetItem { get; }
    public bool NeedsSteamDLC { get; }
    public ItemDefinition get_targetItem();
    public bool get_NeedsSteamDLC();
}
public class ItemButtonTools : MonoBehaviour {
    public Image image;
    public ItemDefinition itemDef;
    public void GiveSelf(int amount);
    public void GiveArmed();
    public void GiveBlueprint();
}
public enum ItemCategory : Enum {
    public int value__;
    public static ItemCategory Weapon;
    public static ItemCategory Construction;
    public static ItemCategory Items;
    public static ItemCategory Resources;
    public static ItemCategory Attire;
    public static ItemCategory Tool;
    public static ItemCategory Medical;
    public static ItemCategory Food;
    public static ItemCategory Ammunition;
    public static ItemCategory Traps;
    public static ItemCategory Misc;
    public static ItemCategory All;
    public static ItemCategory Common;
    public static ItemCategory Component;
    public static ItemCategory Search;
    public static ItemCategory Favourite;
    public static ItemCategory Electrical;
    public static ItemCategory Fun;
}
public class ItemContainer : object {
    public static int BackpackSlotIndex;
    public Flag flags;
    public ContentsType allowedContents;
    public ItemDefinition[] onlyAllowedItems;
    public HashSet`1<ItemDefinition> blockedItems;
    public List`1<ItemSlot> availableSlots;
    public int capacity;
    public ItemContainerId uid;
    public bool dirty;
    public List`1<Item> itemList;
    public float temperature;
    public Item parent;
    public BasePlayer playerOwner;
    public BaseEntity entityOwner;
    public bool isServer;
    public int maxStackSize;
    public int containerVolume;
    [CompilerGeneratedAttribute]
private Action onDirty;
    public Func`3<Item, int, bool> canAcceptItem;
    public Func`3<Item, int, bool> slotIsReserved;
    public Action`2<Item, bool> onItemAddedRemoved;
    public Action`2<Item, int> onItemAddedToStack;
    public Action`2<Item, int> onItemRemovedFromStack;
    public Action`1<Item> onPreItemRemove;
    public Action`2<Item, float> onItemRadiationChanged;
    public Action`2<Item, Item> onItemParentChanged;
    public bool HasAvailableSlotsDefined { get; }
    public bool HasLimitedAllowedItems { get; }
    public Vector3 dropPosition { get; }
    public Vector3 dropVelocity { get; }
    public bool get_HasAvailableSlotsDefined();
    public void UpdateAvailableSlots(List`1<ItemSlot> newSlots);
    public bool HasFlag(Flag f);
    public void SetFlag(Flag f, bool b);
    public bool IsLocked();
    public bool PlayerItemInputBlocked();
    public bool get_HasLimitedAllowedItems();
    [CompilerGeneratedAttribute]
public void add_onDirty(Action value);
    [CompilerGeneratedAttribute]
public void remove_onDirty(Action value);
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    public float GetTemperature(int slot);
    public void ServerInitialize(Item parentItem, int iMaxCapacity);
    public void GiveUID();
    public void MarkDirty();
    public DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, float destroyPercent);
    public static DroppedItemContainer Drop(string prefab, Vector3 pos, Quaternion rot, ItemContainer[] containers);
    public BaseEntity GetEntityOwner(bool returnHeldEntity);
    public void OnChanged();
    public sealed virtual Item FindItemByUID(ItemId iUID);
    public bool IsFull();
    public bool HasSpaceFor(Item item);
    public bool IsEmpty();
    public bool HasPartialStack(Item toStack, Int32& slot);
    public float GetRadioactiveMaterialInContainer();
    public bool HasPartialStack(Item toStack);
    public bool CanAccept(Item item);
    public int GetMaxTransferAmount(ItemDefinition def);
    public void SetOnlyAllowedItem(ItemDefinition def);
    public void SetOnlyAllowedItems(ItemDefinition[] defs);
    public void SetBlacklist(ItemDefinition[] defs);
    public bool Insert(Item item);
    public bool SlotTaken(Item item, int i);
    public Item GetSlot(int slot);
    public bool QuickIndustrialPreCheck(Item toTransfer, Vector2i range, Int32& foundSlot);
    public bool FindPosition(Item item);
    public bool HasItem(ItemDefinition searchFor);
    public void SetLocked(bool isLocked);
    public bool Remove(Item item);
    public void Clear();
    public void Kill();
    public int GetAmount(int itemid, bool onlyUsableAmounts);
    public int GetAmount(int blueprintBaseId, int itemId, bool onlyUsableAmounts);
    public int GetOkConditionAmount(int itemid, bool onlyUsableAmounts);
    public sealed virtual Item FindItemByItemID(int itemid);
    public sealed virtual Item FindItemByItemName(string name);
    public Item FindBySubEntityID(NetworkableId subEntityID);
    public sealed virtual List`1<Item> FindItemsByItemID(int itemid);
    public ItemContainer Save(bool bIncludeContainer);
    public void Load(ItemContainer container);
    public BasePlayer GetOwnerPlayer();
    public int ContainerMaxStackSize();
    public int Take(List`1<Item> collect, int itemid, int iAmount);
    public bool TryTakeOne(int itemid, Item& item);
    public sealed virtual bool GiveItem(Item item, ItemContainer container);
    public Vector3 get_dropPosition();
    public Vector3 get_dropVelocity();
    public void OnCycle(float delta);
    public sealed virtual Item FindAmmo(AmmoTypes ammoType);
    public sealed virtual void FindAmmo(List`1<Item> list, AmmoTypes ammoType);
    public sealed virtual bool HasAmmo(AmmoTypes ammoType);
    public int GetAmmoAmount(ItemDefinition specificAmmo);
    public int GetAmmoAmount(AmmoTypes ammoType);
    public int TotalItemAmount();
    public bool HasAny(ItemDefinition itemDef);
    public int GetTotalItemAmount(Item item, int slotStartInclusive, int slotEndInclusive);
    public int TotalItemAmount(ItemDefinition itemDef);
    public int GetTotalCategoryAmount(ItemCategory category, int slotStartInclusive, int slotEndInclusive);
    public void AddItem(ItemDefinition itemToCreate, int amount, ulong skin, LimitStack limitStack);
    public void OnMovedToWorld();
    public void OnRemovedFromWorld();
    public UInt32 ContentsHash();
    public ItemContainer FindContainer(ItemContainerId id);
    public CanAcceptResult CanAcceptItem(Item item, int targetPos);
    public bool HasBackpackItem();
    public void BubbleUpRadiationChanged(Item item, float amount);
}
public abstract class ItemContainerSource : MonoBehaviour {
    public abstract virtual ItemContainer GetItemContainer();
}
public class ItemCorpseOverride : MonoBehaviour {
    public GameObjectRef MaleCorpse;
    public GameObjectRef FemaleCorpse;
    public bool BlockWearableCopy;
}
public class ItemCrafter : EntityComponent`1<BasePlayer> {
    public List`1<ItemContainer> containers;
    public LinkedList`1<ItemCraftTask> queue;
    public int taskUID;
    public BasePlayer owner;
    public void AddContainer(ItemContainer container);
    public static float GetScaledDuration(ItemBlueprint bp, float workbenchLevel, bool isInTutorial);
    public void ServerUpdate(float delta);
    public void CollectIngredient(int item, int amount, List`1<Item> collect);
    public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player);
    public bool CraftItem(ItemBlueprint bp, BasePlayer owner, InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free);
    public void FinishCrafting(ItemCraftTask task);
    public bool CancelTask(int iID);
    public bool CancelBlueprint(int itemid);
    public void CancelAll();
    private bool DoesHaveOKConditionItem(int item, int iAmount);
    public bool DoesHaveUsableItem(int item, int iAmount);
    public bool CanCraft(ItemBlueprint bp, int amount, bool free);
    public bool CanCraft(ItemDefinition def, int amount, bool free);
    public bool FastTrackTask(int taskID);
    public ItemCrafter Save();
    public void Load(ItemCrafter proto);
    public void SendToOwner();
    [CompilerGeneratedAttribute]
internal static List`1<Item> <Save>g__SaveItems|19_0(List`1<Item> items);
    [CompilerGeneratedAttribute]
internal static List`1<Item> <Load>g__LoadItems|20_0(List`1<Item> itemProtos);
}
public class ItemCraftTask : object {
    public ItemBlueprint blueprint;
    public float endTime;
    public int taskUID;
    public bool cancelled;
    public InstanceData instanceData;
    public int amount;
    public int skinID;
    public List`1<Item> takenItems;
    public int numCrafted;
    public float conditionScale;
    public BaseEntity workbenchEntity;
}
public class ItemDefinition : MonoBehaviour {
    [HeaderAttribute("Item")]
[ReadOnlyAttribute]
public int itemid;
    [TooltipAttribute("The shortname should be unique. A hash will be generated from it to identify the item type. If this name changes at any point it will make all saves incompatible")]
public string shortname;
    [HeaderAttribute("Appearance")]
public Phrase displayName;
    public Phrase displayDescription;
    public Sprite iconSprite;
    public ItemCategory category;
    public ItemSelectionPanel selectionPanel;
    [HeaderAttribute("Containment")]
public int maxDraggable;
    public ContentsType itemType;
    public AmountType amountType;
    [InspectorFlagsAttribute]
public ItemSlot occupySlots;
    public int stackable;
    public int volume;
    public float baseRadioactivity;
    public bool quickDespawn;
    public bool blockStealingInSafeZone;
    public TutorialItemAllowance tutorialAllowance;
    [HeaderAttribute("Spawn Tables")]
[TooltipAttribute("How rare this item is and how much it costs to research")]
public Rarity rarity;
    public Rarity despawnRarity;
    public bool spawnAsBlueprint;
    [HeaderAttribute("Sounds")]
public SoundDefinition inventoryGrabSound;
    public SoundDefinition inventoryDropSound;
    public SoundDefinition physImpactSoundDef;
    public Condition condition;
    [HeaderAttribute("Misc")]
public bool hidden;
    [InspectorFlagsAttribute]
public Flag flags;
    public bool hideSelectedPanel;
    [TooltipAttribute("User can craft this item on any server if they have this steam item")]
public SteamInventoryItem steamItem;
    [TooltipAttribute("User can craft this item if they have this DLC purchased")]
public SteamDLCItem steamDlc;
    [TooltipAttribute("Can only craft this item if the parent is craftable (tech tree)")]
public ItemDefinition Parent;
    [HeaderAttribute("World Model")]
public GameObjectRef worldModelPrefab;
    public OverrideWorldModel[] worldModelOverrides;
    public bool treatAsComponentForRepairs;
    public bool AlignWorldModelOnDrop;
    public Vector3 WorldModelDropOffset;
    public ItemDefinition isRedirectOf;
    public RedirectVendingBehaviour redirectVendingBehaviour;
    public ItemMod[] itemMods;
    public TraitFlag Traits;
    public Skin[] skins;
    public IPlayerItemDefinition[] _skins2;
    private float _worldModelMass;
    [TooltipAttribute("Panel to show in the inventory menu when selected")]
public GameObject panel;
    [CompilerGeneratedAttribute]
private ItemModWearable <ItemModWearable>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemModBurnable <ItemModBurnable>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemModCookable <ItemModCookable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <isHoldable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <isUsable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CraftableWithSkin>k__BackingField;
    public ItemDefinition[] Children;
    public IPlayerItemDefinition[] skins2 { get; }
    public ItemBlueprint Blueprint { get; }
    public int craftingStackable { get; }
    public bool isWearable { get; }
    public ItemModWearable ItemModWearable { get; public set; }
    public ItemModBurnable ItemModBurnable { get; public set; }
    public ItemModCookable ItemModCookable { get; public set; }
    public bool isHoldable { get; private set; }
    public bool isUsable { get; private set; }
    public bool HasSkins { get; }
    public bool CraftableWithSkin { get; private set; }
    public IPlayerItemDefinition[] get_skins2();
    public void InvalidateWorkshopSkinCache();
    public static ulong FindSkin(int itemID, int skinID);
    public float GetWorldModelMass();
    public ItemBlueprint get_Blueprint();
    public int get_craftingStackable();
    public bool HasFlag(Flag f);
    public void Initialize(List`1<ItemDefinition> itemList);
    public bool get_isWearable();
    [CompilerGeneratedAttribute]
public ItemModWearable get_ItemModWearable();
    [CompilerGeneratedAttribute]
public void set_ItemModWearable(ItemModWearable value);
    [CompilerGeneratedAttribute]
public ItemModBurnable get_ItemModBurnable();
    [CompilerGeneratedAttribute]
public void set_ItemModBurnable(ItemModBurnable value);
    [CompilerGeneratedAttribute]
public ItemModCookable get_ItemModCookable();
    [CompilerGeneratedAttribute]
public void set_ItemModCookable(ItemModCookable value);
    [CompilerGeneratedAttribute]
public bool get_isHoldable();
    [CompilerGeneratedAttribute]
private void set_isHoldable(bool value);
    [CompilerGeneratedAttribute]
public bool get_isUsable();
    [CompilerGeneratedAttribute]
private void set_isUsable(bool value);
    public bool get_HasSkins();
    [CompilerGeneratedAttribute]
public bool get_CraftableWithSkin();
    [CompilerGeneratedAttribute]
private void set_CraftableWithSkin(bool value);
    public GameObjectRef GetWorldModel(int amount);
    public int GetWorldModelIndex(int amount);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__58_0(ItemDefinition x);
}
public class ItemDropCommand : MonoBehaviour {
    public string command;
}
public class ItemEventFlag : MonoBehaviour {
    public Flag flag;
    public UnityEvent onEnabled;
    public UnityEvent onDisable;
    internal bool firstRun;
    internal bool lastState;
    public virtual void OnItemUpdate(Item item);
}
public class ItemFootstepSounds : MonoBehaviour {
    public bool setEffectFolder;
    public string effectFolder;
    public SoundDefinition accentSound;
}
public class ItemIcon : BaseMonoBehaviour {
    private Color backgroundColor;
    public Color selectedBackgroundColor;
    public float unoccupiedAlpha;
    public Color unoccupiedColor;
    public ItemContainerSource containerSource;
    public int slotOffset;
    [RangeAttribute("0", "64")]
public int slot;
    public bool setSlotFromSiblingIndex;
    public GameObject slots;
    public CanvasGroup iconContents;
    public CanvasGroup canvasGroup;
    public Image iconImage;
    public Image underlayImage;
    public Text amountText;
    public Text hoverText;
    public Image hoverOutline;
    public Image cornerIcon;
    public Image lockedImage;
    public Image progressImage;
    public Image backgroundImage;
    public Image backgroundUnderlayImage;
    public Image progressPanel;
    public Sprite emptySlotBackgroundSprite;
    public CanvasGroup conditionObject;
    public Image conditionFill;
    public Image maxConditionFill;
    public GameObject lightEnabled;
    public GameObject burstEnabled;
    public bool allowSelection;
    public bool allowDropping;
    public bool allowMove;
    public bool showCountDropShadow;
    public Item item;
    public bool invalidSlot;
    public SoundDefinition hoverSound;
    public virtual void OnPointerClick(PointerEventData eventData);
    public sealed virtual void OnPointerEnter(PointerEventData eventData);
    public sealed virtual void OnPointerExit(PointerEventData eventData);
}
public static class ItemIconUpload : object {
}
public class ItemInformationPanel : MonoBehaviour {
    public bool ForceHidden(ItemDefinition info);
    public virtual bool EligableForDisplay(ItemDefinition info);
    public virtual void SetupForItem(ItemDefinition info, Item item);
}
public class ItemListTools : MonoBehaviour {
    public GameObject categoryButton;
    public GameObject itemButton;
    public RustInput searchInputText;
    internal Button lastCategory;
    private IOrderedEnumerable`1<ItemDefinition> currentItems;
    private IOrderedEnumerable`1<ItemDefinition> allItems;
    public void OnPanelOpened();
    private void OnOpenDevTools();
    private void CacheAllItems();
    public void Refresh();
    private void RebuildCategories();
    private void SwitchItemCategory(ItemDefinition[] defs);
    public void FilterItems(string searchText);
}
public class ItemManager : object {
    [ServerVar]
public static bool EnablePooling;
    public static List`1<ItemDefinition> itemList;
    public static Dictionary`2<int, ItemDefinition> itemDictionary;
    public static Dictionary`2<string, ItemDefinition> itemDictionaryByName;
    public static List`1<ItemBlueprint> bpList;
    public static Int32[] defaultBlueprints;
    public static ItemDefinition blueprintBaseDef;
    private static List`1<ItemRemove> ItemRemoves;
    private static ItemManager();
    public static void InvalidateWorkshopSkinCache();
    public static void Initialize();
    public static Item CreateByName(string strName, int iAmount, ulong skin);
    public static Item CreateByPartialName(string strName, int iAmount, ulong skin);
    public static ItemDefinition FindDefinitionByPartialName(string strName);
    public static Item CreateByItemID(int itemID, int iAmount, ulong skin);
    public static Item Create(ItemDefinition template, int iAmount, ulong skin, bool isServerSide);
    private static void TrySkinChangeItem(ItemDefinition& template, UInt64& skinId);
    public static Item Load(Item load, Item created, bool isServer);
    public static ItemDefinition FindItemDefinition(int itemID);
    public static ItemDefinition FindItemDefinition(string shortName);
    public static ItemBlueprint FindBlueprint(ItemDefinition item);
    public static List`1<ItemDefinition> GetItemDefinitions();
    public static List`1<ItemBlueprint> GetBlueprints();
    public static void DoRemoves();
    public static void Heartbeat();
    public static void RemoveItem(Item item, float fTime);
}
public class ItemMod : MonoBehaviour {
    protected ItemMod[] siblingMods;
    public virtual void ModInit();
    public virtual void OnItemCreated(Item item);
    public virtual void OnVirginItem(Item item);
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    public virtual void DoAction(Item item, BasePlayer player);
    public virtual void OnRemove(Item item);
    public virtual void OnParentChanged(Item item);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter);
    public virtual void OnAttacked(Item item, HitInfo info);
    public virtual void OnChanged(Item item);
    public virtual bool CanDoAction(Item item, BasePlayer player);
    public virtual bool Passes(Item item);
    public virtual void OnRemovedFromWorld(Item item);
    public virtual void OnMovedToWorld(Item item);
}
public class ItemModActionChange : ItemMod {
    public ItemMod[] actions;
    public virtual void OnChanged(Item item);
    private void OnValidate();
}
public class ItemModActionContainerChange : ItemMod {
    public ItemMod[] actions;
    public virtual void OnParentChanged(Item item);
    private void OnValidate();
}
public class ItemModAlterCondition : ItemMod {
    public float conditionChange;
    public virtual void DoAction(Item item, BasePlayer player);
}
public class ItemModAnimalEquipment : ItemMod {
    public Flags WearableFlag;
    public bool hideHair;
    public ProtectionProperties animalProtection;
    public ProtectionProperties riderProtection;
    public int additionalInventorySlots;
    public float speedModifier;
    public float staminaUseModifier;
    public SlotType slot;
}
public abstract class ItemModAssociatedEntity`1 : ItemMod {
    public GameObjectRef entityPrefab;
    protected bool AllowNullParenting { get; }
    protected bool AllowHeldEntityParenting { get; }
    protected bool ShouldAutoCreateEntity { get; }
    protected bool OwnedByParentPlayer { get; }
    protected virtual bool get_AllowNullParenting();
    protected virtual bool get_AllowHeldEntityParenting();
    protected virtual bool get_ShouldAutoCreateEntity();
    protected virtual bool get_OwnedByParentPlayer();
    public virtual void OnItemCreated(Item item);
    public T CreateAssociatedEntity(Item item);
    protected virtual void OnAssociatedItemCreated(T ent);
    public virtual void OnRemove(Item item);
    public virtual void OnMovedToWorld(Item item);
    public virtual void OnRemovedFromWorld(Item item);
    public void UpdateParent(Item item);
    public virtual void OnParentChanged(Item item);
    public BaseEntity GetEntityForParenting(Item item);
    public static bool GetAssociatedEntity(Item item, T& result, bool isServer);
    public static T GetAssociatedEntity(Item item, bool isServer);
}
public class ItemModAssociatedEntityMobile : ItemModAssociatedEntity`1<MobileInventoryEntity> {
    protected bool AllowNullParenting { get; }
    protected virtual bool get_AllowNullParenting();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModBackpack : ItemMod {
    public SoundDefinition ZipSound;
    [HeaderAttribute("Should the 'selected' panel be hidden when the backpack is selected when equipped")]
public bool hideSelectedPanel;
    [HeaderAttribute("Backpack's item volume when items are in it")]
public int containerVolumeWhenFilled;
    public bool DropWhenDowned;
    public virtual void OnItemCreated(Item item);
    public bool CanAcceptItem(Item backpack, Item item, int slot);
}
public class ItemModBaitContainer : ItemModContainer {
    protected bool ForceAcceptItemCheck { get; }
    protected virtual bool get_ForceAcceptItemCheck();
    protected virtual bool CanAcceptItem(Item item, int count);
    protected virtual void SetAllowedItems(ItemContainer container);
}
public class ItemModBlueprintCraft : ItemMod {
    public static Phrase CraftItemTitle;
    public static Phrase CraftItemDesc;
    public static Phrase CraftAllTitle;
    public static Phrase CraftAllDesc;
    public GameObjectRef successEffect;
    private static ItemModBlueprintCraft();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModBurnable : ItemMod {
    public float fuelAmount;
    [ItemSelector("11")]
public ItemDefinition byproductItem;
    public int byproductAmount;
    public float byproductChance;
    public virtual void OnItemCreated(Item item);
}
public class ItemModCassette : ItemModAssociatedEntity`1<Cassette> {
    public int noteSpriteIndex;
    public PreloadedCassetteContent PreloadedContent;
    protected bool AllowNullParenting { get; }
    protected bool AllowHeldEntityParenting { get; }
    protected virtual bool get_AllowNullParenting();
    protected virtual bool get_AllowHeldEntityParenting();
    protected virtual void OnAssociatedItemCreated(Cassette ent);
}
public class ItemModCassetteContainer : ItemModContainer {
    public ItemDefinition[] CassetteItems;
    protected bool ForceAcceptItemCheck { get; }
    protected virtual bool get_ForceAcceptItemCheck();
    protected virtual void SetAllowedItems(ItemContainer container);
}
public class ItemModChildIO : ItemMod {
    public GameObjectRef TargetChildIO;
}
public class ItemModCompostable : MonoBehaviour {
    public float TotalFertilizerProduced;
    public float BaitValue;
    public int MaxBaitStack;
}
public class ItemModConditionContainerFlag : ItemMod {
    public Flag flag;
    public bool requiredState;
    public virtual bool Passes(Item item);
}
public class ItemModConditionHasCondition : ItemMod {
    public float conditionTarget;
    [TooltipAttribute("If set to above 0 will check for fraction instead of raw value")]
public float conditionFractionTarget;
    public bool lessThan;
    public virtual bool Passes(Item item);
}
public class ItemModConditionHasContents : ItemMod {
    [TooltipAttribute("Can be null to mean any item")]
public ItemDefinition itemDef;
    public bool requiredState;
    public virtual bool Passes(Item item);
    [CompilerGeneratedAttribute]
private bool <Passes>b__2_0(Item x);
}
public class ItemModConditionHasFlag : ItemMod {
    public Flag flag;
    public bool requiredState;
    public virtual bool Passes(Item item);
}
public class ItemModConditionInWater : ItemMod {
    public bool requiredState;
    public virtual bool Passes(Item item);
}
public class ItemModConditionIsSleeping : ItemMod {
    public bool requiredState;
    public virtual bool Passes(Item item);
}
public class ItemModConsumable : MonoBehaviour {
    public int amountToConsume;
    public float conditionFractionToLose;
    public string achievementWhenEaten;
    public List`1<ConsumableEffect> effects;
    public List`1<ModifierDefintion> modifiers;
    public float GetIfType(Type typeToPick);
}
[RequireComponent("ItemModConsumable")]
public class ItemModConsume : ItemMod {
    public GameObjectRef consumeEffect;
    public string eatGesture;
    [TooltipAttribute("Items that are given on consumption of this item")]
public ItemAmountRandom[] product;
    public ItemModConsumable primaryConsumable;
    public virtual ItemModConsumable GetConsumable();
    public virtual GameObjectRef GetConsumeEffect();
    public virtual void DoAction(Item item, BasePlayer player);
    public virtual bool CanDoAction(Item item, BasePlayer player);
}
public class ItemModConsumeChance : ItemModConsume {
    public float chanceForSecondaryConsume;
    public GameObjectRef secondaryConsumeEffect;
    public ItemModConsumable secondaryConsumable;
    private bool GetChance();
    public virtual ItemModConsumable GetConsumable();
    public virtual GameObjectRef GetConsumeEffect();
}
public class ItemModConsumeContents : ItemMod {
    public GameObjectRef consumeEffect;
    public virtual void DoAction(Item item, BasePlayer player);
    public virtual bool CanDoAction(Item item, BasePlayer player);
}
public class ItemModContainer : ItemMod {
    public int capacity;
    public int maxStackSize;
    public int containerVolume;
    public bool canLootInWorld;
    public float pickupInWorldDelay;
    public float maxWeight;
    public float worldWeightScale;
    [InspectorFlagsAttribute]
public Flag containerFlags;
    public ContentsType onlyAllowedContents;
    public ItemDefinition onlyAllowedItemType;
    public List`1<ItemSlot> availableSlots;
    public ItemDefinition[] validItemWhitelist;
    public bool openInDeployed;
    public bool openInInventory;
    public List`1<ItemAmount> defaultContents;
    [TooltipAttribute("If true items in this container won't be usable as ammo for reloads")]
public bool blockAmmoSource;
    [HeaderAttribute("Sounds")]
public SoundDefinition openSound;
    public SoundDefinition closeSound;
    protected bool ForceAcceptItemCheck { get; }
    public virtual void OnItemCreated(Item item);
    protected virtual void SetAllowedItems(ItemContainer container);
    protected virtual bool get_ForceAcceptItemCheck();
    protected virtual bool CanAcceptItem(Item item, int count);
    private void OnItemAddedOrRemoved(Item item, bool added);
    public virtual void OnVirginItem(Item item);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
}
public class ItemModContainerRads : ItemModContainer {
    public virtual void OnItemCreated(Item item);
    public virtual void OnRemove(Item item);
    public virtual void OnParentChanged(Item item);
    private void OnItemParentChanged(Item parent, Item child);
    private void OnItemRadiationChanged(Item item, float rads);
    private void OnItemAddedRemoved(Item childItem, bool added);
    private void OnItemRemovedFromStack(Item childItem, int amount);
    private void OnItemAddedToStack(Item childItem, int amount);
    private void ProcessRadCountFromChild(Item childItem);
    private void ProcessRadCountFromParent(Item item, bool skipEvent);
    private void CountRads(ItemContainer container, bool skipEvent);
}
public class ItemModContainerRestriction : ItemMod {
    [InspectorFlagsAttribute]
public SlotFlags slotFlags;
    public bool CanExistWith(ItemModContainerRestriction other);
}
public class ItemModConversation : ItemMod {
    public static Phrase SquakTitle;
    public static Phrase SquakDesc;
    public ConversationData conversationData;
    public GameObjectRef conversationEntity;
    public GameObjectRef squakEffect;
    private static ItemModConversation();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModCookable : ItemMod {
    [ItemSelector("11")]
public ItemDefinition becomeOnCooked;
    public float cookTime;
    public int amountOfBecome;
    public int lowTemp;
    public int highTemp;
    public bool setCookingFlag;
    public void OnValidate();
    public bool CanBeCookedByAtTemperature(float temperature);
    private void CycleCooking(Item item, float delta);
    public virtual void OnItemCreated(Item itemcreated);
}
public class ItemModCrackOpen : ItemModUnwrap {
    public static Phrase CrackOpenTitle;
    public static Phrase CrackOpenDesc;
    private static ItemModCrackOpen();
}
public class ItemModCycle : ItemMod {
    public ItemMod[] actions;
    public float timeBetweenCycles;
    public float timerStart;
    public bool onlyAdvanceTimerWhenPass;
    public virtual void OnItemCreated(Item itemcreated);
    private bool CanCycle(Item item);
    public void CustomCycle(Item item, float delta);
    private void OnValidate();
}
public class ItemModDeployable : MonoBehaviour {
    public GameObjectRef entityPrefab;
    [HeaderAttribute("Tooltips")]
public bool showCrosshair;
    public string UnlockAchievement;
    public Deployable GetDeployable(BaseEntity entity);
    internal void OnDeployed(BaseEntity ent, BasePlayer player);
}
public class ItemModEntity : ItemMod {
    public GameObjectRef entityPrefab;
    public string defaultBone;
    public bool playerOnlyEntity;
    public virtual void OnChanged(Item item);
    public virtual void OnItemCreated(Item item);
    private void CreateEntity(Item item);
    public virtual void OnRemove(Item item);
    private bool ParentToParent(Item item, BaseEntity ourEntity);
    private bool ParentToPlayer(Item item, BaseEntity ourEntity);
    public virtual void OnParentChanged(Item item);
    public virtual void CollectedForCrafting(Item item, BasePlayer crafter);
    public virtual void ReturnedFromCancelledCraft(Item item, BasePlayer crafter);
}
public class ItemModEntityReference : MonoBehaviour {
    public GameObjectRef entityPrefab;
}
public class ItemModFishable : ItemMod {
    public bool CanBeFished;
    [HeaderAttribute("Catching Behaviour")]
public float StrainModifier;
    public float MoveMultiplier;
    public float ReelInSpeedMultiplier;
    public float CatchWaitTimeMultiplier;
    [HeaderAttribute("Catch Criteria")]
public float MinimumBaitLevel;
    public float MaximumBaitLevel;
    public float MinimumWaterDepth;
    public float MaximumWaterDepth;
    [InspectorFlagsAttribute]
public FishingTag RequiredTag;
    [RangeAttribute("0", "1")]
public float Chance;
    public string SteamStatName;
    [HeaderAttribute("Mounting")]
public bool CanBeMounted;
    public int FishMountIndex;
}
public class ItemModForceSelectFromBelt : ItemMod {
    public bool IfIsOn;
    public bool IfPlayerRestrained;
}
public class ItemModForceWearFromBelt : ItemMod {
    public bool IfPlayerRestrained;
}
public class ItemModGiveOxygen : ItemMod {
    public AirSupplyType airType;
    public int amountToConsume;
    public GameObjectRef inhaleEffect;
    public GameObjectRef exhaleEffect;
    public GameObjectRef bubblesEffect;
    private float timeRemaining;
    private float cycleTime;
    private bool inhaled;
    public AirSupplyType AirType { get; }
    public sealed virtual AirSupplyType get_AirType();
    public sealed virtual float GetAirTimeRemaining();
    public virtual void ModInit();
    public virtual void DoAction(Item item, BasePlayer player);
    public virtual void OnChanged(Item item);
}
public class ItemModHABEquipment : ItemMod {
    public SlotType slot;
    public GameObjectRef Prefab;
    public int MaxEquipCount;
    public bool GroundEquipOnly;
    public float DelayNextUpgradeOnRemoveDuration;
    public Phrase MenuOptionTitle;
    public Phrase MenuOptionDesc;
    public bool CanEquipToHAB(HotAirBalloon hab);
    public void ApplyToHAB(HotAirBalloon hab);
}
public class ItemModHead : ItemModAssociatedEntity`1<HeadEntity> {
    protected bool AllowNullParenting { get; }
    protected virtual bool get_AllowNullParenting();
}
public class ItemModHideInfoPanel : ItemMod {
}
public class ItemModKeycard : ItemMod {
    public int accessLevel;
}
public class ItemModMenuOption : ItemMod {
    public string commandName;
    public ItemMod actionTarget;
    public Option option;
    [TooltipAttribute("If true, this is the command that will run when an item is 'selected' on the toolbar")]
public bool isPrimaryOption;
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    private void OnValidate();
}
public class ItemModOpenLootBag : ItemModUnwrap {
    public static Phrase OpenLootBagTitle;
    public static Phrase OpenLootBagDesc;
    private static ItemModOpenLootBag();
}
public class ItemModOpenWrapped : ItemMod {
    public GameObjectRef successEffect;
    public static Phrase open_wrapped_gift;
    public static Phrase open_wrapped_gift_desc;
    private static ItemModOpenWrapped();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModPager : ItemModRFListener {
    public static Phrase SilentOffTitle;
    public static Phrase SilentOffDesc;
    public static Phrase SilentOnTitle;
    public static Phrase SilentOnDesc;
    public static Phrase StopTitle;
    public static Phrase StopDesc;
    private static ItemModPager();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
[RequireComponent("ItemModWearable")]
public class ItemModPaintable : ItemModAssociatedEntity`1<PaintedItemStorageEntity> {
    public static Phrase ItemPaintTitle;
    public static Phrase ItemPaintDesc;
    public GameObjectRef ChangeSignTextDialog;
    public MeshPaintableSource[] PaintableSources;
    protected bool AllowNullParenting { get; }
    protected bool OwnedByParentPlayer { get; }
    private static ItemModPaintable();
    protected virtual bool get_AllowNullParenting();
    protected virtual bool get_OwnedByParentPlayer();
}
public class ItemModParachute : ItemModBackpack {
    public GameObjectRef ParachuteVehiclePrefab;
}
public class ItemModPetStats : ItemMod {
    [TooltipAttribute("Speed modifier. Value, not percentage.")]
public float SpeedModifier;
    [TooltipAttribute("HP amount to modify max health by. Value, not percentage.")]
public float MaxHealthModifier;
    [TooltipAttribute("Damage amount to modify base attack damage by. Value, not percentage.")]
public float AttackDamageModifier;
    [TooltipAttribute("Attack rate (seconds) to modify base attack rate by. Value, not percentage.")]
public float AttackRateModifier;
    public void Apply(BasePet pet);
}
public class ItemModPhoto : ItemModAssociatedEntity`1<PhotoEntity> {
    protected bool AllowNullParenting { get; }
    protected virtual bool get_AllowNullParenting();
}
public class ItemModProjectile : MonoBehaviour {
    public GameObjectRef projectileObject;
    public ItemModProjectileMod[] mods;
    public AmmoTypes ammoType;
    public int numProjectiles;
    public float projectileSpread;
    public float projectileVelocity;
    public float projectileVelocitySpread;
    public bool useCurve;
    public AnimationCurve spreadScalar;
    public GameObjectRef attackEffectOverride;
    public float barrelConditionLoss;
    public string category;
    public float GetRandomVelocity();
    public float GetSpreadScalar();
    public float GetIndexedSpreadScalar(int shotIndex, int maxShots);
    public float GetAverageVelocity();
    public float GetMinVelocity();
    public float GetMaxVelocity();
    public bool IsAmmo(AmmoTypes ammo);
    public virtual void ServerProjectileHit(HitInfo info);
}
public class ItemModProjectileMod : MonoBehaviour {
    public virtual void ServerProjectileHit(HitInfo info);
}
public class ItemModProjectileRadialDamage : ItemModProjectileMod {
    public float radius;
    public DamageTypeEntry damage;
    public GameObjectRef effect;
    public bool ignoreHitObject;
    public int vibrationLevel;
    public virtual void ServerProjectileHit(HitInfo info);
}
public class ItemModProjectileSpawn : ItemModProjectile {
    public float createOnImpactChance;
    public GameObjectRef createOnImpact;
    public float spreadAngle;
    public float spreadVelocityMin;
    public float spreadVelocityMax;
    public int numToCreateChances;
    public virtual void ServerProjectileHit(HitInfo info);
}
public class ItemModRackMountable : ItemMod {
}
public class ItemModRecycleInto : ItemMod {
    public static Phrase RecycleIntoTitle;
    public static Phrase RecycleIntoDesc;
    public ItemDefinition recycleIntoItem;
    public int numRecycledItemMin;
    public int numRecycledItemMax;
    public GameObjectRef successEffect;
    private static ItemModRecycleInto();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModReload : ItemMod {
    public float conditionLost;
    public GameObjectRef successEffect;
    public int workbenchLvlRequired;
    public Phrase reloadPhrase;
    public bool HasCraftLevel(BasePlayer player);
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModRepair : ItemMod {
    public static Phrase RefillItemTitle;
    public static Phrase RefillItemDesc;
    public float conditionLost;
    public GameObjectRef successEffect;
    public int workbenchLvlRequired;
    public bool canUseRepairBench;
    private static ItemModRepair();
    public bool HasCraftLevel(BasePlayer player);
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModRestraint : ItemMod {
}
public class ItemModReveal : ItemMod {
    public static Phrase RevealItemTitle;
    public static Phrase RevealItemDesc;
    public int numForReveal;
    public ItemDefinition revealedItemOverride;
    public int revealedItemAmount;
    public LootSpawn revealList;
    public GameObjectRef successEffect;
    private static ItemModReveal();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModRFListener : ItemModAssociatedEntity`1<BaseEntity> {
    public static Phrase SetFreqTitle;
    public static Phrase SetFreqDesc;
    public GameObjectRef frequencyPanelPrefab;
    private static ItemModRFListener();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModSetFrequency : ItemMod {
    public static Phrase RfOffTitle;
    public static Phrase RfOffDesc;
    public static Phrase RfOnTitle;
    public static Phrase RfOnDesc;
    public GameObjectRef frequencyPanelPrefab;
    public bool allowArmDisarm;
    public bool onlyFrequency;
    public int defaultFrequency;
    public bool loseConditionOnChange;
    private static List`1<ItemTime> itemsOnCooldown;
    private static ItemModSetFrequency();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    public virtual void OnItemCreated(Item item);
}
public class ItemModSign : ItemModAssociatedEntity`1<SignContent> {
    protected bool AllowNullParenting { get; }
    protected bool ShouldAutoCreateEntity { get; }
    protected virtual bool get_AllowNullParenting();
    protected virtual bool get_ShouldAutoCreateEntity();
    public void OnSignPickedUp(ISignage s, IUGCBrowserEntity ugc, Item toItem);
}
public class ItemModSound : ItemMod {
    public GameObjectRef effect;
    public Type actionType;
    public virtual void OnParentChanged(Item item);
}
public class ItemModStudyBlueprint : ItemMod {
    public GameObjectRef studyEffect;
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
    private static bool IsBlueprintUnlocked(Item item, BasePlayer player, ItemDefinition& blueprintTargetDef, ItemBlueprint& blueprint);
    public static bool IsBlueprintUnlocked(ItemDefinition def, BasePlayer player);
}
public class ItemModSummerSunglassesEquip : ItemMod {
    public float SunsetTime;
    public float SunriseTime;
    public string AchivementName;
    public virtual void DoAction(Item item, BasePlayer player);
}
public class ItemModSwap : ItemMod {
    public GameObjectRef actionEffect;
    public ItemAmount[] becomeItem;
    public bool sendPlayerPickupNotification;
    public bool sendPlayerDropNotification;
    public float xpScale;
    public ItemAmount[] RandomOptions;
    public virtual void DoAction(Item item, BasePlayer player);
}
public class ItemModSwitchFlag : ItemMod {
    public Flag flag;
    public bool state;
    public virtual void DoAction(Item item, BasePlayer player);
}
public class ItemModUnwrap : ItemMod {
    public static Phrase UnwrapGiftTitle;
    public static Phrase UnwrapGiftDesc;
    public LootSpawn revealList;
    public GameObjectRef successEffect;
    public int minTries;
    public int maxTries;
    private static ItemModUnwrap();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModUpgrade : ItemMod {
    public static Phrase UpgradeItemTitle;
    public static Phrase UpgradeItemDesc;
    public int numForUpgrade;
    public float upgradeSuccessChance;
    public int numToLoseOnFail;
    public ItemDefinition upgradedItem;
    public int numUpgradedItem;
    public GameObjectRef successEffect;
    public GameObjectRef failEffect;
    private static ItemModUpgrade();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModUseContent : ItemMod {
    public int amountToConsume;
    public virtual void DoAction(Item item, BasePlayer player);
}
public class ItemModWearable : ItemMod {
    public GameObjectRef entityPrefab;
    public GameObjectRef entityPrefabFemale;
    public ProtectionProperties protectionProperties;
    public ArmorProperties armorProperties;
    public ClothingMovementProperties movementProperties;
    public blackoutType occlusionType;
    public bool blocksAiming;
    public bool emissive;
    public float accuracyBonus;
    public bool blocksEquipping;
    public float eggVision;
    public float weight;
    public bool equipOnRightClick;
    public bool equipOnPickup;
    public bool npcOnly;
    public GameObjectRef breakEffect;
    public bool preventsMounting;
    public bool preventsMap;
    public GameObjectRef viewmodelAddition;
    public Wearable targetWearable { get; }
    public Wearable get_targetWearable();
    private void DoPrepare();
    public virtual void ModInit();
    public bool ProtectsArea(HitArea area);
    public bool HasProtections();
    internal float GetProtection(Item item, DamageType damageType);
    public float ConditionProtectionScale(Item item);
    public void CollectProtection(Item item, ProtectionProperties protection);
    private bool IsHeadgear();
    public bool IsFootwear();
    public virtual void OnAttacked(Item item, HitInfo info);
    public bool CanExistWith(ItemModWearable wearable);
}
public class ItemModWrap : ItemMod {
    public GameObjectRef successEffect;
    public ItemDefinition wrappedDefinition;
    public static Phrase wrap_gift;
    public static Phrase wrap_gift_desc;
    private static ItemModWrap();
    public virtual void ServerCommand(Item item, string command, BasePlayer player);
}
public class ItemModXMasTreeDecoration : ItemMod {
    public xmasFlags flagsToChange;
}
public class ItemModXPWhenUsed : ItemMod {
    public float xpPerUnit;
    public int unitSize;
    public void GiveConsumeXP(Item item);
}
public class ItemOptionButton : MonoBehaviour {
    public RustText name;
    public Image icon;
}
public class ItemPanel : SingletonComponent`1<ItemPanel> {
}
public class ItemPickup : DroppedItem {
    public ItemDefinition itemDef;
    public int amount;
    public ulong skinOverride;
    public virtual float GetDespawnDuration();
    public virtual void Spawn();
    internal virtual void DoServerDestroy();
    public virtual void PostServerLoad();
}
public class ItemPickupNotice : MonoBehaviour {
    public TextMeshProUGUI Text;
    public TextMeshProUGUI Amount;
}
public class ItemPreviewIcon : BaseMonoBehaviour {
    public ItemContainerSource containerSource;
    [RangeAttribute("0", "64")]
public int slot;
    public bool setSlotFromSiblingIndex;
    public CanvasGroup iconContents;
    public Image iconImage;
    public Text amountText;
    public Item item;
}
public class ItemSearchEntry : MonoBehaviour {
    public Button button;
    public Text text;
    public RawImage image;
    public RawImage bpImage;
}
public static class ItemSearchUtils : object {
    public static IOrderedEnumerable`1<ItemDefinition> SearchForItems(string searchString, Func`2<ItemDefinition, bool> validFilter);
    public static bool IsValidSearchResult(string search, ItemDefinition target, bool checkItemIsValid);
    private static float ScoreSearchResult(string search, ItemDefinition target);
}
public enum ItemSelectionPanel : Enum {
    public int value__;
    public static ItemSelectionPanel None;
    public static ItemSelectionPanel Vessel;
    public static ItemSelectionPanel Modifications;
    public static ItemSelectionPanel GunInformation;
}
public class ItemSelector : PropertyAttribute {
    public ItemCategory category;
    public ItemSelector(ItemCategory category);
}
[CreateAssetMenuAttribute]
public class ItemSkin : SteamInventoryItem {
    public Skinnable Skinnable;
    public Material[] Materials;
    [TooltipAttribute("If set, whenever we make an item with this skin, we'll spawn this item without a skin instead")]
public ItemDefinition Redirect;
    public SteamInventoryItem UnlockedViaSteamItem;
    public bool UnlockedByDefault;
    public void ApplySkin(GameObject obj);
    public virtual bool HasUnlocked(ulong playerId);
}
public class ItemSkinDirectory : ScriptableObject {
    private static ItemSkinDirectory _Instance;
    public Skin[] skins;
    public static ItemSkinDirectory Instance { get; }
    public static ItemSkinDirectory get_Instance();
    public static Skin[] ForItem(ItemDefinition item);
    public static Skin FindByInventoryDefinitionId(int id);
    public static bool TryGetItemFromDefinitionID(int id, ItemDefinition& result);
}
[FlagsAttribute]
public enum ItemSlot : Enum {
    public int value__;
    public static ItemSlot None;
    public static ItemSlot Barrel;
    public static ItemSlot Silencer;
    public static ItemSlot Scope;
    public static ItemSlot UnderBarrel;
    public static ItemSlot Magazine;
    public static ItemSlot Internal;
}
public class ItemSplitter : MonoBehaviour {
    public Slider slider;
    public TextMeshProUGUI textValue;
    public TextMeshProUGUI splitAmountText;
    public TMP_InputField amountInputField;
}
public class ItemSplitterDragOut : MonoBehaviour {
    public ItemSplitter rootSplitter;
}
public class ItemSplitterSlider : MonoBehaviour {
    public ItemSplitter Splitter;
}
public class ItemStatValue : MonoBehaviour {
    public Text text;
    public Slider slider;
    public bool selectedItem;
    public bool smallerIsBetter;
    public bool asPercentage;
}
public class ItemStore : SingletonComponent`1<ItemStore> {
    public static Phrase CartEmptyPhrase;
    public static Phrase CartSingularPhrase;
    public static Phrase CartPluralPhrase;
    public GameObject LimitedItemPrefab;
    public GameObject GeneralItemPrefab;
    public GameObject DLCItemPrefab;
    public float TransitionDelayPerItem;
    [FormerlySerializedAsAttribute("ItemParent")]
public RectTransform LimitedItemParent;
    public RectTransform GeneralItemParent;
    public RectTransform DLCItemParent;
    public List`1<IPlayerItemDefinition> Cart;
    public ItemStoreItemInfoModal ItemStoreInfoModal;
    public GameObject BuyingModal;
    public ItemStoreBuyFailedModal ItemStoreBuyFailedModal;
    public ItemStoreBuySuccessModal ItemStoreBuySuccessModal;
    public SoundDefinition AddToCartSound;
    public RustText CartButtonLabel;
    public RustText QuantityValue;
    public RustText TotalValue;
    public RectTransform TakeoverParent;
    public ItemStoreTakeover[] Takeovers;
    private static ItemStore();
    public sealed virtual int GetItemCount();
    public sealed virtual void SetItemData(int i, GameObject obj);
}
public class ItemStoreBuyButton : ListComponent`1<ItemStoreBuyButton> {
    public RectTransform Buy;
    public RectTransform InCart;
    public RectTransform AlreadyPurchased;
}
public class ItemStoreBuyFailedModal : MonoBehaviour {
    public void Show(ulong orderid);
    public void Hide();
    [CompilerGeneratedAttribute]
private void <Hide>b__1_0();
}
public class ItemStoreBuySuccessModal : MonoBehaviour {
    public void Show(ulong orderId);
    public void Hide();
    [CompilerGeneratedAttribute]
private void <Hide>b__1_0();
}
public class ItemStoreCartItem : MonoBehaviour {
    public int Index;
    public TextMeshProUGUI Name;
    public TextMeshProUGUI Price;
    public void Init(int index, IPlayerItemDefinition def);
}
public class ItemStoreDLC : ItemStoreProduct {
    public UInt32 AppId;
    public GameObjectRef Modal;
}
public class ItemStoreItem : ItemStoreProduct {
    public Button Button;
    public HttpImage Icon;
    public RawImage IconImage;
    public Material IconImageDisabledMaterial;
    public RustText Name;
    public TextMeshProUGUI Price;
    public RustText ItemName;
    public GameObject NewTag;
    public GameObject InInventoryTag;
    public RustText InInventoryText;
    public GameObject InCartTag;
    public GameObject Footer;
}
public class ItemStoreItemInfoModal : FacepunchBehaviour {
    public HttpImage Icon;
    public RustText Name;
    public RustText Price;
    public RustText Description;
    public RustText itemCategory;
    public RawImage skinViewerImage;
    public GameObjectRef skinViewerPrefab;
    public RectTransform sectionReplaces;
    public Image replacesIcon;
    public RustText replacesName;
    public RectTransform sectionBreakdown;
    public RectTransform breakdownCloth;
    public RectTransform breakdownMetal;
    public RectTransform breakdownWood;
    [SerializeField]
[SpaceAttribute]
private GameObject icon2D;
    [SerializeField]
private GameObject icon3D;
    [SerializeField]
private Image loadingSpinner;
    public static Phrase ItemClothing;
    public static Phrase ItemWeapon;
    public static Phrase ItemArmor;
    public static Phrase ItemDeployable;
    public static Phrase ItemResource;
    private static ItemStoreItemInfoModal();
}
public class ItemStorePack : RevealTransitionBase {
    public ScrollRect ScrollRect;
    public RustText[] PriceTags;
}
public class ItemStorePackItem : FacepunchBehaviour {
    [SerializeField]
private GameObjectRef skinViewerPrefab;
    [SerializeField]
private Image iconImage2D;
    [SerializeField]
private RawImage iconImage3D;
    [SerializeField]
private ItemDefinition modelItemDef;
    [SerializeField]
private GameObjectRef modelPrefab;
}
public abstract class ItemStoreProduct : MonoBehaviour {
    public Button BuyButton;
    public GameObject AlreadyOwnedButton;
}
[RequireComponent("UnityEngine.AudioSource", "UnityEngine.UI.Toggle")]
public class ItemStoreSongPreview : BaseMonoBehaviour {
}
public class ItemStoreTakeover : ValueType {
    public Phrase Name;
    public Phrase SubtitleOverride;
    public SteamInventoryItem Item;
    public GameObjectRef Prefab;
    public Sprite IconOverride;
}
public class ItemSubmitPanel : LootPanel {
}
public class ItemTextValue : MonoBehaviour {
    public Text text;
    public Color bad;
    public Color good;
    public bool negativestat;
    public bool asPercentage;
    public bool useColors;
    public bool signed;
    public string suffix;
    public float multiplier;
    public void SetValue(float val, int numDecimals, string overrideText);
}
public class ItemTools : MonoBehaviour {
}
public interface IThinker {
    public abstract virtual void TryThink();
}
public interface ITrainCollidable {
    public abstract virtual bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);
    public abstract virtual bool EqualNetID(BaseNetworkable other);
}
public interface IUGCBrowserEntity {
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    public abstract virtual UInt32[] get_GetContentCRCs();
    public abstract virtual void ClearContent();
    public abstract virtual UGCType get_ContentType();
    public abstract virtual List`1<ulong> get_EditingHistory();
    public abstract virtual BaseNetworkable get_UgcEntity();
}
public interface IUIPlayerRefreshCallback {
}
public interface IUIScreen {
}
public interface IVehicleLockUser {
    public abstract virtual bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule);
    public abstract virtual bool PlayerHasUnlockPermission(BasePlayer player);
    public abstract virtual bool PlayerCanUseThis(BasePlayer player, LockType lockType);
    public abstract virtual void RemoveLock();
}
public interface IVendingMachineInterface {
}
public interface IViewModeChanged {
}
public interface IViewmodelComponent {
}
public interface IViewModelUpdated {
}
public interface IVitalNotice {
}
public class Jackhammer : BaseMelee {
    public float HotspotBonusScale;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool HasAmmo();
    [RPC_Server]
public void Server_SetEngineStatus(RPCMessage msg);
    public void SetEngineStatus(bool on);
    public virtual void SetHeld(bool bHeld);
}
public class JesseStiller.TerrainFormerExtension.TerrainFormer : MonoBehaviour {
    private void Awake();
}
public class JesseStiller.TerrainFormerExtension.TerrainSetNeighbours : MonoBehaviour {
    [SerializeField]
private Terrain leftTerrain;
    [SerializeField]
private Terrain topTerrain;
    [SerializeField]
private Terrain rightTerrain;
    [SerializeField]
private Terrain bottomTerrain;
    private void Awake();
    public void SetNeighbours(Terrain leftTerrain, Terrain topTerrain, Terrain rightTerrain, Terrain bottomTerrain);
}
public class JiggleBone : BaseMonoBehaviour {
    public bool debugMode;
    private Vector3 targetPos;
    private Vector3 dynamicPos;
    public Vector3 boneAxis;
    public float targetDistance;
    public float bStiffness;
    public float bMass;
    public float bDamping;
    public float bGravity;
    private Vector3 force;
    private Vector3 acc;
    private Vector3 vel;
    public bool SquashAndStretch;
    public float sideStretch;
    public float frontStretch;
    public float disableDistance;
    private void Awake();
    private void LateUpdate();
}
public class JunkPile : BaseEntity {
    public GameObjectRef sinkEffect;
    public SpawnGroup[] spawngroups;
    public NPCSpawner NPCSpawn;
    private static float lifetimeMinutes;
    protected bool isSinking;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    private void SpawnInitial();
    public bool SpawnGroupsEmpty();
    public void CheckEmpty();
    public virtual float TimeoutPlayerCheckRadius();
    public void TimeOut();
    public void SinkAndDestroy();
    public void KillMe();
}
public class JunkPileBuoyancyPoint : MonoBehaviour {
}
public class JunkpileNPCSpawner : NPCSpawner {
    [HeaderAttribute("Junkpile NPC Spawner")]
public bool UseSpawnChance;
    protected virtual void Spawn(int numToSpawn);
}
public class JunkPileWater : JunkPile {
    public Transform[] buoyancyPoints;
    public bool debugDraw;
    public float updateCullRange;
    public float VehicleCheckRadius;
    private Quaternion baseRotation;
    private bool first;
    private TimeUntil nextPlayerCheck;
    private bool hasPlayersNearby;
    public static JunkpileWaterWorkQueue junkpileWaterWorkQueue;
    [HelpAttribute("How many milliseconds to budget for processing junk pile updates per frame")]
[ServerVar]
public static float framebudgetms;
    private static JunkPileWater();
    public virtual void Spawn();
    public void FixedUpdate();
    public void UpdateMovement();
    public void UpdateNearbyPlayers();
}
public class JunkPileWaterSpawner : SpawnGroup {
    public BaseEntity attachToParent;
    protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint);
}
public class Kayak : BaseBoat {
    public ItemDefinition OarItem;
    public float maxPaddleFrequency;
    public float forwardPaddleForce;
    public float multiDriverPaddleForceMultiplier;
    public float rotatePaddleForce;
    public GameObjectRef forwardSplashEffect;
    public GameObjectRef backSplashEffect;
    public ParticleSystem moveSplashEffect;
    public float animationLerpSpeed;
    [HeaderAttribute("Audio")]
public BlendedSoundLoops waterLoops;
    public float waterSoundSpeedDivisor;
    public GameObjectRef pushLandEffect;
    public GameObjectRef pushWaterEffect;
    public MountPoses noPaddlePose;
    public TimeSince[] playerPaddleCooldowns;
    public TimeCachedValue`1<float> fixedDragUpdate;
    public TimeSince timeSinceLastUsed;
    private static float DECAY_TICK_TIME;
    private Vector3 lastTravelPos;
    private bool inCinematic;
    private Quaternion cinematicWorldRotation;
    private int lastDownhillUpdate;
    private float distanceRemainder;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void OnPlayerMounted();
    public virtual void OnPlayerDismounted(BasePlayer player);
    public virtual void DriverInput(InputState inputState, BasePlayer player);
    private void TravelDistanceUpdate();
    public virtual bool EngineOn();
    public virtual void DoPushAction(BasePlayer player);
    public virtual void VehicleFixedUpdate();
    public float CalculateDesiredDrag();
    public void BoatDecay();
    public virtual bool CanPickup(BasePlayer player);
    public void PrepareForTutorialCinematic(Quaternion worldRotation);
    public bool IsPlayerHoldingPaddle(BasePlayer player);
    public Vector3 GetPaddlePoint(int index, PaddleDirection direction);
    public bool IsInWater();
}
public class KayakSeat : BaseVehicleSeat {
    public ItemDefinition PaddleItem;
    public virtual void OnPlayerMounted();
    public virtual void OnPlayerDismounted(BasePlayer player);
}
public class KeybindCategory : MonoBehaviour {
    private List`1<KeyBindUI> keybinds;
    private void Awake();
    public void UpdateVisibility();
}
public class KeybindSearch : MonoBehaviour {
    public GameObject rootPanel;
    public TMP_InputField input;
}
public class KeyBindUI : MonoBehaviour {
    public GameObject blockingCanvas;
    public RustText Label;
    public Button btnA;
    public Button btnB;
    public string bindString;
    [CompilerGeneratedAttribute]
private static bool <IsBinding>k__BackingField;
    public static bool IsBinding { get; private set; }
    [CompilerGeneratedAttribute]
public static bool get_IsBinding();
    [CompilerGeneratedAttribute]
private static void set_IsBinding(bool value);
}
public class Keycard : AttackEntity {
    public int accessLevel { get; }
    public int get_accessLevel();
}
public class KeyCodeEntry : UIDialog {
    public Text textDisplay;
    public Action onClosed;
    public Text typeDisplay;
    public Phrase masterCodePhrase;
    public Phrase guestCodePhrase;
    public GameObject memoryKeycodeButton;
}
public class KeyframeView : MonoBehaviour {
    public ScrollRect Scroller;
    public GameObjectRef KeyframePrefab;
    public RectTransform KeyframeRoot;
    public Transform CurrentPositionIndicator;
    public bool LockScrollToCurrentPosition;
    public RustText TrackName;
}
public class KeyframeWidget : MonoBehaviour {
    public Tooltip AttachedTooltip;
}
public class KeyInformationPanel : ItemInformationPanel {
    [SerializeField]
private Text id;
}
public class KeyLock : BaseLock {
    [ItemSelector("11")]
public ItemDefinition keyItemType;
    public int keyCode;
    public bool firstKeyCreated;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool HasLockPermission(BasePlayer player);
    private bool CanKeyUnlockUs(Item key);
    public virtual void Load(LoadInfo info);
    public virtual bool ShouldNetworkOwnerInfo();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual bool OnTryToOpen(BasePlayer player);
    public virtual bool OnTryToClose(BasePlayer player);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Unlock(RPCMessage rpc);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Lock(RPCMessage rpc);
    private void Lock(BasePlayer player);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_CreateKey(RPCMessage rpc);
    public void LockLock(BasePlayer player);
}
public class LadderMinMountHeight : MonoBehaviour {
    private void Start();
    private void Update();
}
public class LakeInfo : MonoBehaviour {
    protected void Awake();
}
public class LandmarkInfo : MonoBehaviour {
    [HeaderAttribute("LandmarkInfo")]
public bool shouldDisplayOnMap;
    public bool isLayerSpecific;
    public Phrase displayPhrase;
    public Sprite mapIcon;
    public MapLayer MapLayer { get; }
    public virtual MapLayer get_MapLayer();
    protected virtual void Awake();
}
public class Landmine : BaseTrap {
    public GameObjectRef explosionEffect;
    public GameObjectRef triggeredEffect;
    public float minExplosionRadius;
    public float explosionRadius;
    public int vibrationLevel;
    public bool blocked;
    private ulong triggerPlayerID;
    public List`1<DamageTypeEntry> damageTypes;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool Triggered();
    public bool Armed();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void ServerInit();
    public virtual void ObjectEntered(GameObject obj);
    public void Trigger(BasePlayer ply);
    public virtual void OnEmpty();
    public virtual void Explode();
    public virtual void OnKilled(HitInfo info);
    private void OnGroundMissing();
    private void TryExplode();
    public virtual void Arm();
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Disarm(RPCMessage rpc);
}
public class LanguageSelection : MonoBehaviour {
    public GameObject buttonContainer;
}
public class LargeShredder : BaseEntity {
    public Transform shredRail;
    public Transform shredRailStartPos;
    public Transform shredRailEndPos;
    public Vector3 shredRailStartRotation;
    public Vector3 shredRailEndRotation;
    public LargeShredderTrigger trigger;
    public float shredDurationRotation;
    public float shredDurationPosition;
    public float shredSwayAmount;
    public float shredSwaySpeed;
    public BaseEntity currentlyShredding;
    public GameObject[] shreddingWheels;
    public float shredRotorSpeed;
    public GameObjectRef shredSoundEffect;
    public Transform resourceSpawnPoint;
    private Quaternion entryRotation;
    public static string SHRED_STAT;
    public bool isShredding;
    public float shredStartTime;
    public virtual void OnEntityEnteredTrigger(BaseEntity ent);
    public void CreateShredResources();
    public void UpdateBonePosition(float delta);
    public void SetShredding(bool isShredding);
    public void FireShredEffect();
    public void ServerUpdate();
    private void Update();
}
public class LargeShredderTrigger : TriggerBase {
    public LargeShredder shredder;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
}
public class LaserBeam : MonoBehaviour {
    public float scrollSpeed;
    public LineRenderer beamRenderer;
    public GameObject dotObject;
    public Renderer dotRenderer;
    public GameObject dotSpotlight;
    public Vector2 scrollDir;
    public float maxDistance;
    public float stillBlendFactor;
    public float movementBlendFactor;
    public float movementThreshhold;
    public bool isFirstPerson;
    public Transform emissionOverride;
}
public class LaserDetector : BaseDetector {
    public virtual void OnObjects();
}
public class LaserLight : AudioVisualisationEntity {
    public Animator LaserAnimator;
    public LineRenderer[] LineRenderers;
    public MeshRenderer[] DotRenderers;
    public MeshRenderer FlareRenderer;
    public Light[] LightSources;
    public ColourSetting RedSettings;
    public ColourSetting GreenSettings;
    public ColourSetting BlueSettings;
    public ColourSetting YellowSettings;
    public ColourSetting PinkSettings;
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class LayerCullDistance : MonoBehaviour {
    public string Layer;
    public float Distance;
    protected void OnEnable();
}
public class LayerSelect : ValueType {
    [SerializeField]
private int layer;
    public int Mask { get; }
    public string Name { get; }
    public LayerSelect(int layer);
    public static int op_Implicit(LayerSelect layer);
    public static LayerSelect op_Implicit(int layer);
    public int get_Mask();
    public string get_Name();
}
[CreateAssetMenuAttribute]
public class LazyAimProperties : ScriptableObject {
    [RangeAttribute("0", "10")]
public float snapStrength;
    [RangeAttribute("0", "45")]
public float deadzoneAngle;
}
public class LeavesBlowing : MonoBehaviour {
    public ParticleSystem m_psLeaves;
    public float m_flSwirl;
    public float m_flSpeed;
    public float m_flEmissionRate;
    private void Start();
    private void Update();
}
public class LegacyShelter : DecayEntity {
    private static Dictionary`2<ulong, List`1<LegacyShelter>> sheltersPerPlayer;
    public static int FpShelterDefault;
    public static Phrase shelterLimitPhrase;
    public static Phrase shelterLimitReachedPhrase;
    [HeaderAttribute("Shelter References")]
public GameObjectRef smallPrivilegePrefab;
    public GameObjectRef includedDoorPrefab;
    public GameObjectRef includedLockPrefab;
    public EntityRef`1<EntityPrivilege> entityPrivilege;
    private EntityRef`1<LegacyShelterDoor> childDoorInstance;
    private EntityRef`1<BaseLock> lockEntityInstance;
    private Decay decayReference;
    private float lastShelterDecayTick;
    public float lastInteractedWithDoor;
    private ulong shelterOwnerID;
    public static Dictionary`2<ulong, List`1<LegacyShelter>> SheltersPerPlayer { get; }
    private static LegacyShelter();
    public static Dictionary`2<ulong, List`1<LegacyShelter>> get_SheltersPerPlayer();
    public static Nullable`1<CanBuildResult> CanBuildShelter(BasePlayer player, Construction construction);
    internal virtual void DoServerDestroy();
    public static int GetShelterCount(ulong userId);
    private void AddToShelterList(ulong id);
    private bool IsShelterInList(List`1<LegacyShelter> shelters, LegacyShelter& thisShelter);
    public virtual EntityPrivilege GetEntityBuildingPrivilege();
    public EntityPrivilege GetEntityPrivilege();
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual void Load(LoadInfo info);
    public virtual void DecayTick();
    public void HasInteracted();
    public void SetupDecay();
    public virtual float GetEntityDecayDuration();
    public LegacyShelterDoor GetChildDoor();
    public virtual void Save(SaveInfo info);
    public virtual void OnPlaced(BasePlayer player);
    public virtual void Hurt(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual void OnRepair();
    public virtual void OnRepairFinished();
    public void ProtectedHurt(HitInfo info);
    public virtual void PostServerLoad();
    private void Setup(BaseEntity child);
    private void UpdateDoorHp();
}
public class LegacyShelterDoor : Door {
    public GameObjectRef includedLockPrefab;
    private LegacyShelter shelter;
    public void SetupDoor(LegacyShelter shelter);
    public virtual void DecayTick();
    protected virtual void OnChildAdded(BaseEntity child);
    protected virtual void OnPlayerOpenedDoor(BasePlayer p);
    public virtual void OnRepair();
    public virtual void OnRepairFinished();
    public virtual void Hurt(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public void ProtectedHurt(HitInfo info);
    private void UpdateShelterHp();
}
public class LegacyWeatherState : object {
    private WeatherPreset preset;
    public float Wind { get; public set; }
    public float Rain { get; public set; }
    public float Clouds { get; public set; }
    public float Fog { get; public set; }
    public LegacyWeatherState(WeatherPreset preset);
    public float get_Wind();
    public void set_Wind(float value);
    public float get_Rain();
    public void set_Rain(float value);
    public float get_Clouds();
    public void set_Clouds(float value);
    public float get_Fog();
    public void set_Fog(float value);
}
[PostProcessAttribute("LensDirtinessRenderer", "2", "Custom/LensDirtiness", "True")]
public class LensDirtinessEffect : PostProcessEffectSettings {
    public TextureParameter dirtinessTexture;
    public BoolParameter sceneTintsBloom;
    public FloatParameter gain;
    public FloatParameter threshold;
    public FloatParameter bloomSize;
    public FloatParameter dirtiness;
    public ColorParameter bloomColor;
}
public class LensDirtinessRenderer : PostProcessEffectRenderer`1<LensDirtinessEffect> {
    private int dataProperty;
    private Shader lensDirtinessShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class LerpBetweenPointsBool : MonoBehaviour {
    public Vector3 offsetPosLocal;
    public float speed;
    public bool UseAsOffset;
    public void SetAtOffset(bool should);
}
public class LevelInfo : SingletonComponent`1<LevelInfo> {
    public string shortName;
    public string displayName;
    [TextAreaAttribute]
public string description;
    [TooltipAttribute("A background image to be shown when loading the map")]
public Texture2D image;
    [TooltipAttribute("You should incrememnt this version when you make changes to the map that will invalidate old saves")]
[SpaceAttribute("10")]
public int version;
}
public static class LevelManager : object {
    public static string CurrentLevelName;
    public static bool isLoaded { get; }
    public static bool get_isLoaded();
    public static bool IsValid(string strName);
    public static void LoadLevel(string strName, bool keepLoadingScreenOpen);
    [IteratorStateMachineAttribute("LevelManager/<LoadLevelAsync>d__5")]
public static IEnumerator LoadLevelAsync(string strName, bool keepLoadingScreenOpen);
    public static void UnloadLevel(bool loadingScreen);
}
public class LifeInfographic : MonoBehaviour {
    public PlayerLifeStory life;
    public GameObject container;
    public RawImage AttackerAvatarImage;
    public Image DamageSourceImage;
    public LifeInfographicStat[] Stats;
    public Animator[] AllAnimators;
    public GameObject WeaponRoot;
    public GameObject DistanceRoot;
    public GameObject DistanceDivider;
    public Image WeaponImage;
    public DamageSetting[] DamageDisplays;
    public Texture2D defaultAvatarTexture;
    public bool ShowDebugData;
}
public class LifeInfographicStat : MonoBehaviour {
    public DataType dataSource;
    [HeaderAttribute("Generic Stats")]
public string genericStatKey;
    [HeaderAttribute("Weapon Info")]
public string targetWeaponName;
    public WeaponInfoType weaponInfoType;
    public TextMeshProUGUI targetText;
    public Image StatImage;
}
public class LifeInfographicStatDynamicRow : LifeInfographicStat {
    public RustText StatName;
    public void SetStatName(Phrase phrase);
}
public class LifeInfographicStatWeapon : MonoBehaviour {
    public RustText WeaponName;
    public RustText ShotsFired;
    public RustText ShotsHit;
    public RustText ShotsPercent;
    public Image WeaponIcon;
}
public class LifeScale : BaseMonoBehaviour {
    private bool initialized;
    private Vector3 initialScale;
    public Vector3 finalScale;
    private Vector3 targetLerpScale;
    private Action updateScaleAction;
    protected void Awake();
    public void OnEnable();
    public void SetProgress(float progress);
    public void Init();
    public void UpdateScale();
}
public class Lift : AnimatedBuildingBlock {
    public GameObjectRef triggerPrefab;
    public string triggerBone;
    public float resetDelay;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_UseLift(RPCMessage rpc);
    private void MoveUp();
    private void MoveDown();
    protected virtual void OnAnimatorDisabled();
    public virtual void Spawn();
}
[ExecuteInEditMode]
public class LightCloneShadow : MonoBehaviour {
    public bool cloneShadowMap;
    public bool cloneShadowMask;
    [RangeAttribute("0", "2")]
public int shadowMaskDownscale;
}
public class LightEx : UpdateBehaviour {
    public bool alterColor;
    public float colorTimeScale;
    public Color colorA;
    public Color colorB;
    public AnimationCurve blendCurve;
    public bool loopColor;
    public bool alterIntensity;
    public float intensityTimeScale;
    public AnimationCurve intenseCurve;
    public float intensityCurveScale;
    public bool loopIntensity;
    public bool randomOffset;
    public float randomIntensityStartScale;
    public List`1<Light> syncLights;
    protected void OnValidate();
    public static bool CheckConflict(GameObject go);
}
public class LightGroupAtTime : FacepunchBehaviour {
    public float IntensityOverride;
    public AnimationCurve IntensityScaleOverTime;
    public Transform SearchRoot;
    [HeaderAttribute("Power Settings")]
public bool requiresPower;
    [TooltipAttribute("Can NOT be entity, use new blank gameobject!")]
public Transform powerOverrideTransform;
    public LayerMask checkLayers;
    public GameObject enableWhenLightsOn;
    public float timeBetweenPowerLookup;
}
public class LightListener : BaseEntity {
    public string onMessage;
    public string offMessage;
    [TooltipAttribute("Must be part of this prefab")]
public LightGroupAtTime onLights;
    [TooltipAttribute("Must be part of this prefab")]
public LightGroupAtTime offLights;
    public virtual void OnEntityMessage(BaseEntity from, string msg);
}
public class LightLOD : MonoBehaviour {
    public float DistanceBias;
    public bool ToggleLight;
    public bool ToggleShadows;
    protected void OnValidate();
}
public class LightOccludee : MonoBehaviour {
    public float RadiusScale;
    public float MinTimeVisible;
    public bool IsDynamic;
}
public class LightPulse : MonoBehaviour {
    public Light TargetLight;
    public float PulseSpeed;
    public float Lifetime;
    public float MaxIntensity;
    public float FadeOutSpeed;
}
[ExecuteInEditMode]
public class LinearFog : MonoBehaviour {
    public Material fogMaterial;
    public Color fogColor;
    public float fogStart;
    public float fogRange;
    public float fogDensity;
    public bool fogSky;
    private void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class LineRendererActivate : MonoBehaviour {
    private void OnEnable();
}
[ExtensionAttribute]
public static class LinqEx : object {
    [ExtensionAttribute]
public static int MaxIndex(IEnumerable`1<T> sequence);
}
public class LiquidContainer : ContainerIOEntity {
    public ItemDefinition defaultLiquid;
    public int startingAmount;
    public bool autofillOutputs;
    public float autofillTickRate;
    public int autofillTickAmount;
    public int maxOutputFlow;
    public ItemDefinition[] ValidItems;
    private int currentDrainAmount;
    private HashSet`1<IOEntity> connectedList;
    private HashSet`1<ContainerIOEntity> pushTargets;
    private static int maxPushTargets;
    private IOEntity considerConnectedTo;
    private Action updateDrainAmountAction;
    private Action updatePushLiquidTargetsAction;
    private Action pushLiquidAction;
    private Action deductFuelAction;
    private TimeUntil waterTransferStartTime;
    private float lastOutputDrainUpdate;
    private static HashSet`1<IOEntity> pushLiquidCheckEntityHash;
    public bool IsGravitySource { get; }
    protected bool DisregardGravityRestrictionsOnLiquid { get; }
    public bool BlockFluidDraining { get; }
    private static LiquidContainer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool get_IsGravitySource();
    protected virtual bool get_DisregardGravityRestrictionsOnLiquid();
    public virtual bool AllowWireConnections();
    public virtual bool IsRootEntity();
    private bool CanAcceptItem(Item item, int count);
    public virtual void ServerInit();
    public virtual void OnCircuitChanged(bool forceUpdate);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    private void ClearDrains();
    public virtual int GetCurrentEnergy();
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    private void UpdateDrainAmount();
    public virtual bool get_BlockFluidDraining();
    private void CalculateDrain(IOEntity ent, Vector3 fromSlotWorld, int depth, Int32& amount, IOEntity lastEntity, ItemDefinition waterType);
    public virtual void UpdateOutputs();
    private void DeductFuel();
    protected void UpdateOnFlag();
    public virtual void OpenTap(float duration);
    public virtual void ShutTap();
    public bool HasLiquidItem();
    public Item GetLiquidItem();
    public int GetLiquidCount();
    [MaxDistance("3")]
[RPC_Server]
public void SVDrink(RPCMessage rpc);
    private void UpdatePushLiquidTargets();
    private void PushLiquidThroughOutputs();
    private void CheckPushLiquid(IOEntity connected, Item ourFuel, IOEntity fromSource, int depth, HashSet`1<IOEntity> checkEntities);
    public void SetConnectedTo(IOEntity entity);
    protected virtual bool ConsiderConnectedTo(IOEntity entity);
}
public class LiquidVessel : HeldEntity {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool CanDrink();
    [IsActiveItem]
[RPC_Server]
private void DoEmpty(RPCMessage msg);
    public void AddLiquid(ItemDefinition liquidType, int amount);
    public bool CanFillHere(Vector3 pos);
    public int AmountHeld();
    public float HeldFraction();
    public bool IsFull();
    public int MaxHoldable();
}
public class LiquidWeapon : BaseLiquidVessel {
    [HeaderAttribute("Liquid Weapon")]
public float FireRate;
    public float MaxRange;
    public int FireAmountML;
    public int MaxPressure;
    public int PressureLossPerTick;
    public int PressureGainedPerPump;
    public float MinDmgRadius;
    public float MaxDmgRadius;
    public float SplashRadius;
    public GameObjectRef ImpactSplashEffect;
    public AnimationCurve PowerCurve;
    public List`1<DamageTypeEntry> Damage;
    public LiquidWeaponEffects EntityWeaponEffects;
    public bool RequiresPumping;
    public bool AutoPump;
    public bool WaitForFillAnim;
    public bool UseFalloffCurve;
    public AnimationCurve FalloffCurve;
    public float PumpingBlockDuration;
    public float StartFillingBlockDuration;
    public float StopFillingBlockDuration;
    public float cooldownTime;
    public bool HoldFireInput;
    public int pressure;
    public static string RadiationFightAchievement;
    public static string SoakedAchievement;
    public static string LiquidatorAchievement;
    public static string NoPressureAchievement;
    public float PressureFraction { get; }
    public float MinimumPressureFraction { get; }
    public float CurrentRange { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[IsActiveItem]
private void StartFiring(RPCMessage msg);
    [RPC_Server]
[IsActiveItem]
private void StopFiring();
    private bool CanFire(BasePlayer player);
    [RPC_Server]
[IsActiveItem]
public void PumpWater(RPCMessage msg);
    private void PumpWater();
    private void FireTick();
    private void DoSplash(BasePlayer attacker, Vector3 position, Vector3 direction, int amount);
    public virtual void OnHeldChanged();
    public float get_PressureFraction();
    public float get_MinimumPressureFraction();
    public float get_CurrentRange();
    private void StartCooldown(float duration);
    private bool OnCooldown();
    private bool Firing();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class LiquidWeaponEffects : MonoBehaviour {
    public ParticleSystem RootPS;
    public ParticleSystem EmissionPS;
    public ParticleSystem InnerEmissionPS;
    public LiquidWobble Liquid;
    [HeaderAttribute("Main Stream")]
public float MinPressureSpeed;
    public float MaxPressureSpeed;
    public AnimationCurve PressureSpeedCurve;
    public Vector2 StreamSize;
    public AnimationCurve PressureSizeMultiplierCurve;
    [HeaderAttribute("Inner Stream")]
public float MinPressureInnerSpeed;
    public float MaxPressureInnerSpeed;
    public AnimationCurve InnerPressureSpeedCurve;
    public Vector2 InnerStreamSize;
    public AnimationCurve InnerPressureSizeMultiplierCurve;
    [HeaderAttribute("Misc")]
public bool UseImpactSplashEffect;
    public GameObjectRef ImpactSplashEffect;
    public float ImpactSplashEffectInterval;
    public float FillSpeed;
    [HeaderAttribute("Audio")]
public bool firstPersonSounds;
    public SoundDefinition shootStartSoundDef;
    public SoundDefinition shootLoopSoundDef;
    public SoundDefinition shootLowPressureLoopSoundDef;
    public SoundDefinition impactStartSoundDef;
    public SoundDefinition impactLoopSoundDef;
}
public class LiquidWobble : MonoBehaviour {
    [RangeAttribute("0", "1")]
public float CurrentWaterLevelFraction;
    public float MinWaterLevel;
    public float MaxWaterLevel;
    public float MaxWobble;
    public float WobbleSpeed;
    public float Recovery;
}
public class LoadBalancer : SingletonComponent`1<LoadBalancer> {
    public static bool Paused;
    private static float MinMilliseconds;
    private static float MaxMilliseconds;
    private static int MinBacklog;
    private static int MaxBacklog;
    private Queue`1[] queues;
    private Stopwatch watch;
    protected void LateUpdate();
    public static int Count();
    public static void ProcessAll();
    public static void Enqueue(DeferredAction action);
    private static void CreateInstance();
}
public class LoadingScreen : SingletonComponent`1<LoadingScreen> {
    [CompilerGeneratedAttribute]
private static bool <WantsSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Text>k__BackingField;
    public CanvasRenderer panel;
    public TextMeshProUGUI title;
    public TextMeshProUGUI subtitle;
    public Button skipButton;
    public Button cancelButton;
    public GameObject performanceWarning;
    public AudioSource music;
    public RectTransform serverInfo;
    public RustText serverName;
    public RustText serverPlayers;
    public RustLayout serverModeSection;
    public RustText serverMode;
    public RustText serverMap;
    public RustLayout serverTagsSection;
    public ServerBrowserTagList serverTags;
    public RectTransform demoInfo;
    public RustText demoName;
    public RustText demoLength;
    public RustText demoDate;
    public RustText demoMap;
    public RawImage backgroundImage;
    public Texture2D defaultBackground;
    public GameObject pingWarning;
    public RustText pingWarningText;
    [TooltipAttribute("Ping must be at least this many ms higher than the server browser ping")]
public int minPingDiffToShowWarning;
    [TooltipAttribute("Ping must be this many times higher than the server browser ping")]
public float pingDiffFactorToShowWarning;
    [TooltipAttribute("Number of ping samples required before showing the warning")]
public int requiredPingSampleCount;
    public GameObject blackout;
    public static Phrase pingWarningPhrase;
    public static bool isOpen { get; }
    public static bool WantsSkip { get; private set; }
    public static string Text { get; private set; }
    private static LoadingScreen();
    public static bool get_isOpen();
    [CompilerGeneratedAttribute]
public static bool get_WantsSkip();
    [CompilerGeneratedAttribute]
private static void set_WantsSkip(bool value);
    [CompilerGeneratedAttribute]
private static void set_Text(string value);
    [CompilerGeneratedAttribute]
public static string get_Text();
    public static void Update(string strType);
    public static void Update(string strType, string strSubtitle);
}
public class LocalClock : object {
    public List`1<TimedEvent> events;
    public void Add(float delta, float variance, Action action);
    public void Tick();
}
public class LocalizeText : MonoBehaviour {
    public string token;
    [TextAreaAttribute]
public string english;
    public string append;
    public SpecialMode specialMode;
    public string LanguageToken { get; public set; }
    public string LanguageEnglish { get; public set; }
    public sealed virtual string get_LanguageToken();
    public void set_LanguageToken(string value);
    public sealed virtual string get_LanguageEnglish();
    public void set_LanguageEnglish(string value);
}
public static class LocalPlayer : object {
}
public class LocalPositionAnimation : MonoBehaviour {
    public Vector3 centerPosition;
    public bool worldSpace;
    public float scaleX;
    public float timeScaleX;
    public AnimationCurve movementX;
    public float scaleY;
    public float timeScaleY;
    public AnimationCurve movementY;
    public float scaleZ;
    public float timeScaleZ;
    public AnimationCurve movementZ;
}
public class LockedByEntCrate : LootContainer {
    public GameObject lockingEnt;
    public void SetLockingEnt(GameObject ent);
    public void SetLocked(bool isLocked);
    public void Think();
}
public class Locker : StorageContainer {
    public GameObjectRef equipSound;
    public static int maxGearSets;
    public static int attireSize;
    public static int beltSize;
    public static int columnSize;
    public static int backpackSlotIndex;
    public Item[] clothingBuffer;
    public static int setSize;
    public bool isTransferringIndustrialItem;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsEquipping();
    public RowType GetRowType(int slot);
    public virtual void ServerInit();
    public void ClearEquipping();
    public void OnIndustrialItemTransferBegin();
    public void OnIndustrialItemTransferEnd();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public bool IsBackpackSlot(int slot);
    [RPC_Server]
[IsVisible("3")]
public void RPC_Equip(RPCMessage msg);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public bool DoesWearableConflictWithRow(Item item, int pos);
    public Vector2i GetIndustrialSlotRange(Vector3 localPosition);
    public virtual bool SupportsChildDeployables();
    public virtual bool CanPickup(BasePlayer player);
}
public class LockOnLauncher : BaseLauncher {
    [SerializeField]
public float lockRange;
    [SerializeField]
public float lockConeDot;
    [SerializeField]
public float timeToLock;
    [SerializeField]
private float currentLockTime;
    [SerializeField]
public float timeToLoseLock;
    [SerializeField]
private GameObjectRef camUIDialogPrefab;
    private SeekerTarget currentLockTarget;
    private SeekingServerProjectile projectile;
    private float lockTickRate;
    private float lastSentLockTime;
    private bool HasProjectile { get; }
    private bool get_HasProjectile();
    public virtual void OnHeldChanged();
    public virtual bool CanLock();
    public void UpdateLockedEntity();
    public bool HasTarget();
    protected virtual void OnReloadStarted();
    public virtual void ProjectileLaunched_Server(ServerProjectile justLaunched);
    public virtual void Save(SaveInfo info);
    private void LetExistingProjectileGo();
    public bool HasLock();
}
public class LocomotiveExtraVisuals : MonoBehaviour {
    [HeaderAttribute("Gauges")]
[SerializeField]
private TrainEngine trainEngine;
    [SerializeField]
private Transform needleA;
    [SerializeField]
private Transform needleB;
    [SerializeField]
private Transform needleC;
    [SerializeField]
private float maxAngle;
    [SerializeField]
private float speedoMoveSpeed;
    [SerializeField]
private float pressureMoveSpeed;
    [SerializeField]
private float fanAcceleration;
    [SerializeField]
private float fanMaxSpeed;
    [SerializeField]
private float speedoMax;
    [HeaderAttribute("Fans")]
[SerializeField]
private Transform[] engineFans;
}
public abstract class LODComponent : BaseMonoBehaviour {
    public LODDistanceMode DistanceMode;
    public OccludeeParameters OccludeeParams;
}
public abstract class LODComponentParticleSystem : LODComponent {
    [TooltipAttribute("Automatically call Play() the particle system when it's shown via LOD")]
public bool playOnShow;
}
public enum LODDistanceMode : Enum {
    public int value__;
    public static LODDistanceMode XYZ;
    public static LODDistanceMode XZ;
    public static LODDistanceMode Y;
}
public enum LODEnvironmentMode : Enum {
    public int value__;
    public static LODEnvironmentMode Default;
    public static LODEnvironmentMode Underground;
}
public class LODGrid : SingletonComponent`1<LODGrid> {
    public static bool Paused;
    public float CellSize;
    public float MaxMilliseconds;
    public static float MaxRefreshDistance;
    public static float TreeMeshDistance;
    public static float MinTimeBetweenRefreshes;
    private static LODGrid();
}
public class LodLevelDisplay : MonoBehaviour {
    public Color TextColor;
    [RangeAttribute("1", "6")]
public float TextScaleMultiplier;
}
public class LODManager : SingletonComponent`1<LODManager> {
    public float MaxMilliseconds;
}
public class LODMasterMesh : LODComponent {
    public MeshRenderer ReplacementMesh;
    public float Distance;
    public LODComponent[] ChildComponents;
    public bool Block;
    public Bounds MeshBounds;
}
public static class LODUtil : object {
    public static float DefaultDistance;
    public static float GetDistance(Transform transform, LODDistanceMode mode);
    public static float GetDistance(Vector3 worldPos, LODDistanceMode mode);
    public static float VerifyDistance(float distance);
    public static LODEnvironmentMode DetermineEnvironmentMode(Transform transform);
}
[ExecuteInEditMode]
public class LookAt : MonoBehaviour {
    public Transform target;
    private void Update();
}
public class LookatHealth : MonoBehaviour {
    public static bool Enabled;
    public GameObject container;
    public RustText textHealth;
    public RustText textStability;
    public Image healthBar;
    public Image healthBarBG;
    public Color barBGColorNormal;
    public Color barBGColorUnstable;
    private static LookatHealth();
}
public class LookAtIOEnt : MonoBehaviour {
    public RustText objectTitle;
    public RectTransform slotToolTip;
    public Text slotTitle;
    public RustText slotConnectionText;
    public RustText slotPowerText;
    public RustText powerText;
    public RustText passthroughText;
    public RustText chargeLeftText;
    public RustText capacityText;
    public RustText maxOutputText;
    public RustText activeOutputText;
    public RustText turretInterferenceText;
    public IOEntityUISlotEntry[] inputEntries;
    public IOEntityUISlotEntry[] outputEntries;
    public Color NoPowerColor;
    public GameObject ShortCircuitWarning;
    public GameObject GravityWarning;
    public GameObject DistanceWarning;
    public GameObject LineOfSightWarning;
    public GameObject TooManyInputsWarning;
    public GameObject TooManyOutputsWarning;
    public GameObject BuildPrivilegeWarning;
    public CanvasGroup group;
    public HandleSet[] handleSets;
    public RectTransform clearNotification;
    public CanvasGroup wireInfoGroup;
    public RustText wireLengthText;
    public RustText wireClipsText;
    public RustText errorReasonTextTooFar;
    public RustText errorReasonTextNoSurface;
    public RawImage ConnectionTypeIcon;
    public Texture ElectricSprite;
    public Texture FluidSprite;
    public Texture IndustrialSprite;
    public GameObject IndustrialIcon;
}
public class LookAtPlant : MonoBehaviour {
    public CanvasGroup group;
    public UIGenesDisplay GeneDisplay;
    public UIGenesDisplay GeneDisplay2;
    public Text TextPlant;
    public Image PlantIcon;
    public InfoBar Age;
    public InfoBar Stage;
    public InfoBar WaterIntake;
    public Text TextYieldLabel;
    public InfoBar Yield;
    public InfoBar Health;
    public InfoBar Light;
    public InfoBar WaterSaturation;
    public InfoBar Ground;
    public InfoBar Temperature;
    public InfoBar Overall;
}
public class LookAtPlanter : MonoBehaviour {
    public CanvasGroup group;
    public Text waterText;
}
public class LookatTooltip : MonoBehaviour {
    public static bool Enabled;
    public BaseEntity currentlyLookingAt;
    public RustText textLabel;
    public RustText moreOptionsLabel;
    public Image icon;
    public Phrase moreOptionsDefaultPhrase;
    public CanvasGroup canvasGroup;
    public CanvasGroup infoGroup;
    public CanvasGroup minimiseGroup;
    private static LookatTooltip();
}
public class LookAtWeaponRack : MonoBehaviour {
    public CanvasGroup weaponInfoGroup;
    public CanvasGroup rotationGroup;
    public Text TextWeapon;
    public Image IconWeapon;
    public Image IconAmmo;
    public RawImage IconHorizontal;
    public RawImage IconVertical;
    public InfoBar AmmoBar;
    public InfoBar ConditionBar;
    public Color ValidRotationColor;
    public Color InvalidRotationColor;
}
public class LootableCorpse : BaseCorpse {
    public string lootPanelName;
    public ulong playerSteamID;
    public string _playerName;
    [CompilerGeneratedAttribute]
private string <streamerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <blockBagDrop>k__BackingField;
    public ItemContainer[] containers;
    private bool firstLooted;
    public string playerName { get; public set; }
    public string streamerName { get; public set; }
    public Phrase LootPanelTitle { get; }
    public Phrase LootPanelName { get; }
    public bool blockBagDrop { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual string get_playerName();
    public virtual void set_playerName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_streamerName();
    [CompilerGeneratedAttribute]
public virtual void set_streamerName(string value);
    public sealed virtual Phrase get_LootPanelTitle();
    public Phrase get_LootPanelName();
    public virtual void ResetState();
    [CompilerGeneratedAttribute]
public bool get_blockBagDrop();
    [CompilerGeneratedAttribute]
public void set_blockBagDrop(bool value);
    internal virtual void DoServerDestroy();
    public void TakeFrom(BaseEntity fromEntity, ItemContainer[] source);
    public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA, ItemContainer containerB, ItemContainer containerC);
    public void TakeFrom(BaseEntity fromEntity, ItemContainer containerA);
    private ItemContainer SetUpContainerFromSource(ItemContainer source);
    private void SetupLootableHeadDispenser(BaseEntity fromEntity);
    public void CreateEmptyContainer(int capacity);
    public virtual bool CanRemove();
    public virtual bool CanLoot();
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    protected virtual bool CanLootContainer(ItemContainer c, int index);
    public float GetRadsInCorpse();
    [IsVisible("3")]
[RPC_Server]
private void RPC_LootCorpse(RPCMessage rpc);
    public void PlayerStoppedLooting(BasePlayer player);
    protected virtual void PreDropItems();
    public void DropItems();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class LootAllButton : MonoBehaviour {
    public Func`2<Item, bool> Filter;
    public OvenLootPanel inventoryGrid;
}
public class LootContainer : StorageContainer {
    public bool destroyOnEmpty;
    public LootSpawn lootDefinition;
    public int maxDefinitionsToSpawn;
    public float minSecondsBetweenRefresh;
    public float maxSecondsBetweenRefresh;
    public bool initialLootSpawn;
    public float xpLootedScale;
    public float xpDestroyedScale;
    public bool BlockPlayerItemInput;
    public int scrapAmount;
    public string deathStat;
    public LootSpawnSlot[] LootSpawnSlots;
    public spawnType SpawnType;
    public ClanScoreEventType clanScoreEventForFirstLooter;
    public ulong FirstLooterId;
    private static ItemDefinition scrapDef;
    public bool shouldRefreshContents { get; }
    public bool get_shouldRefreshContents();
    public virtual void ResetState();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public virtual void SpawnLoot();
    public int ScoreForRarity(Rarity rarity);
    public virtual void PopulateLoot();
    public void GenerateScrap();
    public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container);
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public void RemoveMe();
    public virtual bool ShouldDropItemsIndividually();
    public virtual void OnKilled(HitInfo info);
    public virtual void OnAttacked(HitInfo info);
    public virtual void InitShared();
}
public class LootContainerAchievement : LootContainer {
    public string AchievementName;
    public bool AllowDuringTutorial;
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
}
public class LootDistanceOverride : MonoBehaviour {
    public float amount;
}
public class LootGrid : MonoBehaviour {
    public int Container;
    public int Offset;
    public int Count;
    public GameObject ItemIconPrefab;
    public Sprite BackgroundImage;
    public ItemContainerSource Inventory;
    private List`1<ItemIcon> _icons;
    public void CreateInventory(ItemContainerSource inventory, Nullable`1<int> slots, Nullable`1<int> offset);
}
public class LootPanel : MonoBehaviour {
    public Text Title;
    public RustText TitleText;
    public bool hideInvalidIcons;
    [TooltipAttribute("Only needed if hideInvalidIcons is true")]
public CanvasGroup canvasGroup;
}
public class LootPanelBigWheelTerminal : LootPanel {
    public RustText timeRemainingText;
}
public class LootPanelCardTableTerminal : LootPanel {
    [SerializeField]
private Text buyInInfoText;
    [SerializeField]
private Phrase phraseMin;
    [SerializeField]
private Phrase phraseMax;
}
public class LootPanelContainer : MonoBehaviour {
    public static string containerName;
    public GameObject NoLootPanel;
    private static LootPanelContainer();
}
public class LootPanelEngine : LootPanel {
    [SerializeField]
private Image engineImage;
    [SerializeField]
private ItemIcon[] icons;
    [SerializeField]
private GameObject warning;
    [SerializeField]
private RustText hp;
    [SerializeField]
private RustText power;
    [SerializeField]
private RustText acceleration;
    [SerializeField]
private RustText topSpeed;
    [SerializeField]
private RustText fuelEconomy;
}
public class LootPanelFrankensteinTable : LootPanel {
    public Button StartCreatingButton;
}
public class LootPanelHorse : LootPanel {
    public Text breedTitle;
    public Text maxSpeedText;
    public Text staminaText;
    public Text healthText;
    public GameObject[] storageSlots;
}
public class LootPanelIndustrialCrafter : LootPanel {
    public GameObject CraftingRoot;
    public RustSlider ProgressSlider;
    public Transform Spinner;
    public float SpinSpeed;
    public GameObject WorkbenchLevelRoot;
}
public class LootPanelLocker : LootPanel {
    public GameObject[] controls;
}
public class LootPanelMixingTable : LootPanel {
    public GameObject controlsOn;
    public GameObject controlsOff;
    public Button StartMixingButton;
    public InfoBar ProgressBar;
    public GameObject recipeItemPrefab;
    public RectTransform recipeContentRect;
    public ScrollRect ScrollView;
    public static Phrase MixingPhrase;
    private static LootPanelMixingTable();
}
public class LootPanelOven : LootPanel {
}
public class LootPanelPlayerCorpse : LootPanel {
    public GameObject[] BeltRoots;
    public GameObject[] ClothingRoots;
}
public class LootPanelReclaim : LootPanel {
    public int oldOverflow;
    public Text overflowText;
    public GameObject overflowObject;
    public static Phrase MorePhrase;
    private static LootPanelReclaim();
}
public class LootPanelRecycler : LootPanel {
    public GameObject controlsOn;
    public GameObject controlsOff;
    public GameObject recycle_efficiency_safezone;
    public GameObject recycle_efficiency_radtown;
}
public class LootPanelToolCupboard : LootPanel {
    public List`1<VirtualItemIcon> costIcons;
    public RustText protectedText;
    public GameObject baseNotProtectedObj;
    public GameObject baseProtectedObj;
    public Phrase protectedPrefix;
    public Tooltip costToolTip;
    public Phrase blocksPhrase;
    public GameObject toolsRow;
}
public class LootPanelTrophyStand : LootPanel {
    public GameObject SubmitButton;
    public GameObject NonMatchingTrophyButton;
    public Text CountText;
    public GameObject CountRoot;
    public GameObject NameRoot;
    public RustText NameText;
    public GameObject ClearButton;
}
public class LootPanelVendingMachine : LootPanel {
    public GameObjectRef sellOrderPrefab;
    public GameObject sellOrderContainer;
    public GameObject busyOverlayPrefab;
    private GameObject busyOverlayInstance;
}
public class LootPanelWaterCatcher : LootPanel {
    public ItemIcon sourceItem;
    public Image capacityImage;
    public CanvasGroup helpCanvas;
    public CanvasGroup buttonsCanvas;
    public Button fromButton;
    public Button toButton;
    public Button drinkButton;
}
[CreateAssetMenuAttribute]
public class LootSpawn : ScriptableObject {
    public ItemAmountRanged[] items;
    public Entry[] subSpawn;
    public ItemDefinition GetBlueprintBaseDef();
    public void SpawnIntoContainer(ItemContainer container);
    private void SubCategoryIntoContainer(ItemContainer container);
}
public class m2bradleyAnimator : MonoBehaviour {
    public Animator m2Animator;
    public Material treadLeftMaterial;
    public Material treadRightMaterial;
    private Rigidbody mainRigidbody;
    [HeaderAttribute("GunBones")]
public Transform turret;
    public Transform mainCannon;
    public Transform coaxGun;
    public Transform rocketsPitch;
    public Transform spotLightYaw;
    public Transform spotLightPitch;
    public Transform sideMG;
    public Transform[] sideguns;
    [HeaderAttribute("WheelBones")]
public Transform[] ShocksBones;
    public Transform[] ShockTraceLineBegin;
    public Vector3[] vecShocksOffsetPosition;
    [HeaderAttribute("Targeting")]
public Transform targetTurret;
    public Transform targetSpotLight;
    public Transform[] targetSideguns;
    private Vector3 vecTurret;
    private Vector3 vecMainCannon;
    private Vector3 vecCoaxGun;
    private Vector3 vecRocketsPitch;
    private Vector3 vecSpotLightBase;
    private Vector3 vecSpotLight;
    private float sideMGPitchValue;
    [HeaderAttribute("MuzzleFlash locations")]
public GameObject muzzleflashCannon;
    public GameObject muzzleflashCoaxGun;
    public GameObject muzzleflashSideMG;
    public GameObject[] muzzleflashRockets;
    public GameObject spotLightHaloSawnpoint;
    public GameObject[] muzzleflashSideguns;
    [HeaderAttribute("MuzzleFlash Particle Systems")]
public GameObjectRef machineGunMuzzleFlashFX;
    public GameObjectRef mainCannonFireFX;
    public GameObjectRef rocketLaunchFX;
    [HeaderAttribute("Misc")]
public bool rocketsOpen;
    public Vector3[] vecSideGunRotation;
    public float treadConstant;
    public float wheelSpinConstant;
    [HeaderAttribute("Gun Movement speeds")]
public float sidegunsTurnSpeed;
    public float turretTurnSpeed;
    public float cannonPitchSpeed;
    public float rocketPitchSpeed;
    public float spotLightTurnSpeed;
    public float machineGunSpeed;
    private float wheelAngle;
    private void Start();
    private void Update();
    private void AnimateWheelsTreads();
    private void AdjustShocksHeight();
    private void TrackTurret();
    private void TrackSpotLight();
    private void TrackSideGuns();
    public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, Single& yaw, Single& pitch);
    public float NormalizeYaw(float flYaw);
}
public class M2BradleyPhysics : MonoBehaviour {
    private m2bradleyAnimator m2Animator;
    public WheelCollider[] Wheels;
    public WheelCollider[] TurningWheels;
    public Rigidbody mainRigidbody;
    public Transform[] waypoints;
    private Vector3 currentWaypoint;
    private Vector3 nextWaypoint;
}
public class MagnetCrane : GroundVehicle {
    [HeaderAttribute("Magnet Crane")]
public Animator animator;
    [SerializeField]
private Transform COM;
    [SerializeField]
public float arm1Speed;
    [SerializeField]
public float arm2Speed;
    [SerializeField]
public float turnYawSpeed;
    [SerializeField]
public BaseMagnet Magnet;
    [SerializeField]
private MagnetCraneAudio mcAudio;
    [SerializeField]
public Rigidbody myRigidbody;
    [SerializeField]
private Transform[] collisionTestingPoints;
    [SerializeField]
public float maxDistanceFromOrigin;
    [SerializeField]
public GameObjectRef selfDamageEffect;
    [SerializeField]
private GameObjectRef explosionEffect;
    [SerializeField]
private Transform explosionPoint;
    [SerializeField]
private CapsuleCollider driverCollision;
    [SerializeField]
private Transform leftHandTarget;
    [SerializeField]
private Transform rightHandTarget;
    [SerializeField]
private Transform leftFootTarget;
    [SerializeField]
private Transform rightFootTarget;
    [SerializeField]
public float idleFuelPerSec;
    [SerializeField]
public float maxFuelPerSec;
    [SerializeField]
private GameObject[] OnTriggers;
    [SerializeField]
public TriggerHurtEx magnetDamage;
    [SerializeField]
public int engineKW;
    [SerializeField]
private CarWheel[] wheels;
    [SerializeField]
public CarSettings carSettings;
    [SerializeField]
private ParticleSystem exhaustInner;
    [SerializeField]
private ParticleSystem exhaustOuter;
    [SerializeField]
private EmissionToggle lightToggle;
    public static Phrase ReturnMessage;
    private static Flags Flag_ArmMovement;
    private static Flags Flag_BaseMovementInput;
    private static int leftTreadParam;
    private static int rightTreadParam;
    private static int yawParam;
    private static int arm1Param;
    private static int arm2Param;
    public float steerInput;
    public float throttleInput;
    private float brakeInput;
    public float yawInput;
    public float extensionInput;
    public float raiseArmInput;
    public float extensionMove;
    public float yawMove;
    public float raiseArmMove;
    public float nextToggleTime;
    public Vector3 spawnOrigin;
    public float lastExtensionArmState;
    public float lastRaiseArmState;
    public float lastYawState;
    public bool handbrakeOn;
    public float nextSelfHealTime;
    public Vector3 lastDamagePos;
    public float lastDrivenTime;
    public float lastFixedUpdateTime;
    public CarPhysics`1<MagnetCrane> carPhysics;
    public VehicleTerrainHandler serverTerrainHandler;
    private Vector3 customInertiaTensor;
    public float extensionArmState;
    public float raiseArmState;
    public float yawState;
    public float DriveWheelVelocity { get; }
    public Surface OnSurface { get; }
    private static MagnetCrane();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float get_DriveWheelVelocity();
    public virtual float GetThrottleInput();
    public virtual float GetBrakeInput();
    public virtual void Load(LoadInfo info);
    public virtual float GetMaxForwardSpeed();
    public virtual bool CanBeLooted(BasePlayer player);
    public sealed virtual Surface get_OnSurface();
    public virtual void ServerInit();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual float MaxVelocity();
    public sealed virtual float GetSteerInput();
    public sealed virtual bool GetSteerSpeedMod(float speed);
    public sealed virtual float GetSteerMaxMult(float speed);
    public virtual void OnEngineStartFailed();
    public virtual bool MeetsEngineRequirements();
    public virtual void VehicleFixedUpdate();
    public virtual void Save(SaveInfo info);
    public void UpdateParams();
    public void LateUpdate();
    public virtual void OnAttacked(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public bool IsColliding();
    public sealed virtual float GetMaxDriveForce();
    public sealed virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public sealed virtual CarWheel[] GetWheels();
    public sealed virtual float GetWheelsMidPos();
    public void UpdateAnimator(float dt);
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    [CompilerGeneratedAttribute]
internal static float <VehicleFixedUpdate>g__UpdateMoveInput|79_0(float input, float move, float slowRate, float dt);
}
public class MagnetCraneAudio : MonoBehaviour {
    public MagnetCrane crane;
    [HeaderAttribute("Sound defs")]
public SoundDefinition engineStartSoundDef;
    public SoundDefinition engineStopSoundDef;
    public BlendedLoopEngineSound engineLoops;
    public SoundDefinition cabinRotationStartDef;
    public SoundDefinition cabinRotationStopDef;
    public SoundDefinition cabinRotationLoopDef;
    private Sound cabinRotationLoop;
    public SoundDefinition turningLoopDef;
    private Sound turningLoop;
    public SoundDefinition trackMovementLoopDef;
    private Sound trackMovementLoop;
    private Modulator trackGainMod;
    private Modulator trackPitchMod;
    public SoundDefinition armMovementLoopDef;
    public SoundDefinition armMovementStartDef;
    public SoundDefinition armMovementStopDef;
    private Sound armMovementLoop01;
    private Modulator armMovementLoop01PitchMod;
    public GameObject arm01SoundPosition;
    public GameObject arm02SoundPosition;
    private Sound armMovementLoop02;
    private Modulator armMovementLoop02PitchMod;
}
public class MagnetLiftable : EntityComponent`1<BaseEntity> {
    public ItemAmount[] shredResources;
    public Vector3 shredDirection;
    [CompilerGeneratedAttribute]
private BasePlayer <associatedPlayer>k__BackingField;
    public BasePlayer associatedPlayer { get; private set; }
    [CompilerGeneratedAttribute]
public BasePlayer get_associatedPlayer();
    [CompilerGeneratedAttribute]
private void set_associatedPlayer(BasePlayer value);
    public virtual void SetMagnetized(bool wantsOn, BaseMagnet magnetSource, BasePlayer player);
}
public class MagnetSnap : object {
    private Transform snapLocation;
    private Vector3 prevSnapLocation;
    public MagnetSnap(Transform snapLocation);
    public void FixedUpdate(Transform target);
    public void PositionTarget(Transform target);
}
public class Mailbox : StorageContainer {
    public string ownerPanel;
    public GameObjectRef mailDropSound;
    public ItemDefinition[] allowedItems;
    public bool autoSubmitWhenClosed;
    public bool shouldMarkAsFull;
    public int mailInputSlot { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int get_mailInputSlot();
    public virtual bool PlayerIsOwner(BasePlayer player);
    public bool IsFull();
    public void MarkFull(bool full);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual bool CanOpenLootPanel(BasePlayer player, string panelName);
    private bool HasFreeSpace();
    private int GetFreeSlot();
    public virtual bool MoveItemToStorage(Item item);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    [RPC_Server]
public void RPC_Submit(RPCMessage msg);
    public void SubmitInputItems(BasePlayer fromPlayer);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual bool CanMoveFrom(BasePlayer player, Item item);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
}
[ExecuteInEditMode]
public class MainCamera : RustCamera`1<MainCamera> {
    public static Camera mainCamera;
    public static Transform mainCameraTransform;
    public static Action PreCullCallback;
    [CompilerGeneratedAttribute]
private static Vector3 <velocity>k__BackingField;
    public static bool isValid { get; }
    public static Vector3 velocity { get; private set; }
    public static Vector3 position { get; public set; }
    public static Vector3 forward { get; public set; }
    public static Vector3 right { get; public set; }
    public static Vector3 up { get; public set; }
    public static Quaternion rotation { get; public set; }
    public static Ray Ray { get; }
    public static bool get_isValid();
    [CompilerGeneratedAttribute]
public static Vector3 get_velocity();
    [CompilerGeneratedAttribute]
private static void set_velocity(Vector3 value);
    public static Vector3 get_position();
    public static void set_position(Vector3 value);
    public static Vector3 get_forward();
    public static void set_forward(Vector3 value);
    public static Vector3 get_right();
    public static void set_right(Vector3 value);
    public static Vector3 get_up();
    public static void set_up(Vector3 value);
    public static Quaternion get_rotation();
    public static void set_rotation(Quaternion value);
    public static Ray get_Ray();
}
public class MainMenuSystem : SingletonComponent`1<MainMenuSystem> {
    public static bool isOpen;
    public static Action OnOpenStateChanged;
    public RustButton SessionButton;
    public GameObject SessionPanel;
    public GameObject NewsStoriesAlert;
    public GameObject ItemStoreAlert;
    public GameObject CompanionAlert;
    public GameObject DemoBrowser;
    public GameObject DemoBrowserButton;
    public GameObject SuicideButton;
    public GameObject EndDemoButton;
    public GameObject ReflexModeOption;
    public GameObject ReflexLatencyMarkerOption;
    [SerializeField]
private GameObject QuitConfirmation;
    public GameObject QuitTutorialOption;
    [SerializeField]
private GameObject Connection;
    [SerializeField]
private UISafeZoneWarning safeZoneWarning;
    private static MainMenuSystem();
}
public static class ManagedNoise : object {
    private static Int32[] hash;
    private static int hashMask;
    private static double sqrt2;
    private static double rsqrt2;
    private static double squaresToTriangles;
    private static double trianglesToSquares;
    private static double simplexScale1D;
    private static double simplexScale2D;
    private static double gradientScale2D;
    private static Double[] gradients1D;
    private static int gradientsMask1D;
    private static Double[] gradients2Dx;
    private static Double[] gradients2Dy;
    private static int gradientsMask2D;
    private static ManagedNoise();
    public static double Simplex1D(double x);
    public static double Simplex1D(double x, Double& dx);
    public static double Simplex2D(double x, double y);
    public static double Simplex2D(double x, double y, Double& dx, Double& dy);
    public static double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain);
    public static double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp);
    public static double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp);
    public static double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp);
    public static double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp);
    public static double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale);
    private static int Floor(double x);
    private static double Abs(double x);
    private static double Saturate(double x);
}
public class MapEntity : HeldEntity {
    public UInt32[] fogImages;
    public UInt32[] paintImages;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("1")]
public void ImageUpdate(RPCMessage msg);
}
public static class MapImageRenderer : object {
    private static Vector4 StartColor;
    private static Vector4 WaterColor;
    private static Vector4 GravelColor;
    private static Vector4 DirtColor;
    private static Vector4 SandColor;
    private static Vector4 GrassColor;
    private static Vector4 ForestColor;
    private static Vector4 RockColor;
    private static Vector4 SnowColor;
    private static Vector4 PebbleColor;
    private static Vector4 OffShoreColor;
    private static Vector3 SunDirection;
    private static float SunPower;
    private static float Brightness;
    private static float Contrast;
    private static float OceanWaterLevel;
    private static Vector4 Half;
    private static MapImageRenderer();
    public static Byte[] Render(Int32& imageWidth, Int32& imageHeight, Color& background, float scale, bool lossy, bool transparent, int oceanMargin);
    private static Byte[] EncodeToFile(int width, int height, Color[] pixels, bool lossy);
    private static Vector3 UnpackNormal(Vector4 value);
}
public class MapInterface : SingletonComponent`1<MapInterface> {
    public static bool IsOpen;
    public Image cameraPositon;
    public ScrollRectEx scrollRect;
    public ScrollRectZoom scrollRectZoom;
    public RustButton showGridToggle;
    public RustButton FocusButton;
    public CanvasGroup CanvasGroup;
    public SoundDefinition PlaceMarkerSound;
    public SoundDefinition ClearMarkerSound;
    public MapView View;
    public UINexusMap NexusMap;
    public GameObject NexusButtonGroup;
    public RustButton NexusToggle;
    public Color[] PointOfInterestColours;
    public PointOfInterestSpriteConfig[] PointOfInterestSprites;
    public Sprite PingBackground;
    public bool DebugStayOpen;
    public GameObject MarkerListSection;
    public GameObject ControlsRoot;
    public GameObjectRef MarkerListPrefab;
    public GameObject MarkerHeader;
    public Transform LocalPlayerMarkerListParent;
    public Transform TeamMarkerListParent;
    public GameObject TeamLeaderHeader;
    public GameObject MissionListHeader;
    public Transform MissionListContent;
    public GameObjectRef MissionListPrefab;
    public VendorList VendorList;
    public RustButton HideTeamLeaderMarkersToggle;
    public CanvasGroup TeamMarkersCanvas;
    public RustImageButton ShowSleepingBagsButton;
    public RustImageButton ShowVendingMachinesButton;
    public RustImageButton ShowMissionProvidersButton;
    public UIEscapeCapture EscapeCapture;
}
public enum MapLayer : Enum {
    public int value__;
    public static MapLayer Overworld;
    public static MapLayer TrainTunnels;
    public static MapLayer Underwater1;
    public static MapLayer Underwater2;
    public static MapLayer Underwater3;
    public static MapLayer Underwater4;
    public static MapLayer Underwater5;
    public static MapLayer Underwater6;
    public static MapLayer Underwater7;
    public static MapLayer Underwater8;
    public static MapLayer Dungeons;
}
public class MapLayerRenderer : SingletonComponent`1<MapLayerRenderer> {
    public Camera renderCamera;
    public CameraEvent cameraEvent;
    public Material renderMaterial;
    private Nullable`1<MapLayer> _currentlyRenderedLayer;
    private Nullable`1<NetworkableId> _currentlyRenderedDungeon;
    private Nullable`1<int> _underwaterLabFloorCount;
    [ClientVar]
public static bool DebugLabs;
    public void Render(MapLayer layer);
    private void RenderImpl(CommandBuffer cb);
    public static MapLayerRenderer GetOrCreate();
    private void RenderDungeonsLayer();
    private CommandBuffer BuildCommandBufferDungeons(ProceduralDynamicDungeon closest);
    public static ProceduralDynamicDungeon FindDungeon(Vector3 position, float maxDist);
    private void RenderTrainLayer();
    private CommandBuffer BuildCommandBufferTrainTunnels();
    private void RenderUnderwaterLabs(int floor);
    public int GetUnderwaterLabFloorCount();
    private CommandBuffer BuildCommandBufferUnderwaterLabs(int floor);
}
public class MapMarker : BaseEntity {
    public AppMarkerType appType;
    public GameObjectRef markerObj;
    public static List`1<MapMarker> serverMapMarkers;
    private static MapMarker();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public virtual AppMarker GetAppMarkerData();
}
public class MapMarkerCH47 : MapMarker {
    public bool IsCargoShip;
    public bool AutomaticallySetRotationToParent;
    public bool UseEntityRotation;
    private float GetRotation(BaseEntity forEntity);
    public virtual AppMarker GetAppMarkerData();
}
public class MapMarkerDeliveryDrone : MapMarker {
    public virtual void ServerInit();
    public virtual bool ShouldNetworkTo(BasePlayer player);
}
public class MapMarkerExplosion : MapMarker {
    private float duration;
    public void SetDuration(float newDuration);
    public virtual void Load(LoadInfo info);
    public void DelayedDestroy();
}
public class MapMarkerGenericRadius : MapMarker {
    public float radius;
    public Color color1;
    public Color color2;
    public float alpha;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void SendUpdate(bool fullUpdate);
    public virtual AppMarker GetAppMarkerData();
}
public class MapMarkerIconSelector : MonoBehaviour {
    public Image OuterImage;
    public Image InnerImage;
    public GameObject Selected;
}
public class MapMarkerMissionProvider : MapMarker {
    private List`1<BaseMission> missionsProvided;
    private string providerToken;
    public virtual void Load(LoadInfo info);
    public void AssignMissions(List`1<BaseMission> missions, string token);
    public virtual void Save(SaveInfo info);
}
public class MapMarkerMLRSRocket : MapMarker {
    public RectTransform uiMarkerTransform;
    public virtual void ServerInit();
    public virtual bool ShouldNetworkTo(BasePlayer player);
}
public class MapMarkerPet : MapMarker {
    public virtual void ServerInit();
    public virtual bool ShouldNetworkTo(BasePlayer player);
}
public class MapScaleIndependent : IndependentScale {
}
public static class MapUploader : object {
    [CompilerGeneratedAttribute]
private static bool <IsUploaded>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OriginalName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OriginalMapFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OriginalSaveFileName>k__BackingField;
    private static HttpClient Http;
    public static bool IsUploaded { get; private set; }
    public static string OriginalName { get; private set; }
    public static string OriginalMapFileName { get; private set; }
    public static string OriginalSaveFileName { get; private set; }
    private static MapUploader();
    [CompilerGeneratedAttribute]
public static bool get_IsUploaded();
    [CompilerGeneratedAttribute]
private static void set_IsUploaded(bool value);
    [CompilerGeneratedAttribute]
public static string get_OriginalName();
    [CompilerGeneratedAttribute]
private static void set_OriginalName(string value);
    [CompilerGeneratedAttribute]
public static string get_OriginalMapFileName();
    [CompilerGeneratedAttribute]
private static void set_OriginalMapFileName(string value);
    [CompilerGeneratedAttribute]
public static string get_OriginalSaveFileName();
    [CompilerGeneratedAttribute]
private static void set_OriginalSaveFileName(string value);
    [AsyncStateMachineAttribute("MapUploader/<UploadMap>d__17")]
public static void UploadMap();
    [AsyncStateMachineAttribute("MapUploader/<UploadMapImpl>d__18")]
private static Task`1<string> UploadMapImpl(Stream stream, string mapFileName);
}
public class MapView : FacepunchBehaviour {
    public RawImage mapImage;
    public Image cameraPositon;
    public ScrollRectEx scrollRect;
    public GameObject monumentMarkerContainer;
    public Transform clusterMarkerContainer;
    public GameObjectRef monumentMarkerPrefab;
    public GameObject missionMarkerContainer;
    public GameObjectRef missionMarkerPrefab;
    public Transform activeInteractionParent;
    public Transform localPlayerInterestPointRoot;
    public GameObject shelterMarkerContainer;
    public GameObjectRef shelterMapMarkerPrefab;
    public TeamMemberMapMarker[] teamPositions;
    public TeamMemberMapMarker[] clanPositions;
    public List`1<PointOfInterestMapMarker> PointOfInterestMarkers;
    public List`1<PointOfInterestMapMarker> TeamPointOfInterestMarkers;
    public List`1<PointOfInterestMapMarker> LocalPings;
    public List`1<PointOfInterestMapMarker> TeamPings;
    public GameObject PlayerDeathMarker;
    public List`1<SleepingBagMapMarker> SleepingBagMarkers;
    public List`1<SleepingBagClusterMapMarker> SleepingBagClusters;
    [FormerlySerializedAsAttribute("TrainLayer")]
public RawImage UndergroundLayer;
    public bool ShowGrid;
    public bool ShowPointOfInterestMarkers;
    public bool ShowDeathMarker;
    public bool ShowSleepingBags;
    public bool AllowSleepingBagDeletion;
    public bool ShowLocalPlayer;
    public bool ShowTeamMembers;
    public bool ShowBagsOnBottom;
    public bool ShowTrainLayer;
    public bool ShowMissions;
    public bool ForceShowVendingMachines;
    [FormerlySerializedAsAttribute("ShowTrainLayer")]
public bool ShowUndergroundLayers;
    public bool MLRSMarkerMode;
    public RustImageButton LockButton;
    public RustImageButton OverworldButton;
    public RustImageButton TrainButton;
    public RustImageButton[] UnderwaterButtons;
    public RustImageButton DungeonButton;
    public CanvasLineRenderer CargoPatrolPath;
    public CanvasLineRenderer[] HarborPaths;
    public CanvasLineRenderer FerryPath;
    public UnityEvent onClicked;
    public sealed virtual void OnPointerDown(PointerEventData eventData);
}
public class Marketplace : BaseEntity {
    [HeaderAttribute("Marketplace")]
public GameObjectRef terminalPrefab;
    public Transform[] terminalPoints;
    public Transform droneLaunchPoint;
    public GameObjectRef deliveryDronePrefab;
    public EntityRef`1[] terminalEntities;
    public NetworkableId SendDrone(BasePlayer player, MarketTerminal sourceTerminal, VendingMachine vendingMachine);
    public void ReturnDrone(DeliveryDrone deliveryDrone);
    public virtual void Spawn();
    private void SpawnSubEntities();
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
}
public class MarketTerminal : StorageContainer {
    public static Flags Flag_HasItems;
    public static Flags Flag_InventoryFull;
    [HeaderAttribute("Market Terminal")]
public GameObjectRef menuPrefab;
    public ulong lockToCustomerDuration;
    public ulong orderTimeout;
    public ItemDefinition deliveryFeeCurrency;
    public int deliveryFeeAmount;
    public DeliveryDroneConfig config;
    public RustText userLabel;
    private ulong _customerSteamId;
    private string _customerName;
    private TimeUntil _timeUntilCustomerExpiry;
    private EntityRef`1<Marketplace> _marketplace;
    public List`1<PendingOrder> pendingOrders;
    public Action`2<BasePlayer, Item> _onCurrencyRemovedCached;
    public Action`2<BasePlayer, Item> _onItemPurchasedCached;
    private Action _checkForExpiredOrdersCached;
    private bool _transactionActive;
    private static List`1<NetworkableId> _deliveryEligible;
    private static RealTimeSince _deliveryEligibleLastCalculated;
    private static MarketTerminal();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool CanPlayerAffordOrderAndDeliveryFee(BasePlayer player, SellOrder sellOrder, int numberOfTransactions);
    public bool HasPendingOrderFor(NetworkableId vendingMachineId);
    public bool CanPlayerInteract(BasePlayer player);
    public virtual void Load(LoadInfo info);
    public void Setup(Marketplace marketplace);
    public virtual void ServerInit();
    private void RegisterOrder(BasePlayer player, VendingMachine vendingMachine);
    public void CompleteOrder(NetworkableId vendingMachineId);
    private void CheckForExpiredOrders();
    private void RestrictToPlayer(BasePlayer player);
    private void ClearRestriction();
    [IsVisible("3")]
[CallsPerSecond("3")]
[RPC_Server]
public void Server_TryOpenMarket(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("10")]
public void Server_Purchase(RPCMessage msg);
    private void UpdateHasItems(bool sendNetworkUpdate);
    private void OnCurrencyRemoved(BasePlayer player, Item currencyItem);
    private void OnItemPurchased(BasePlayer player, Item purchasedItem);
    public virtual void Save(SaveInfo info);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual bool CanOpenLootPanel(BasePlayer player, string panelName);
    private void RemoveAnyLooters();
    public void GetDeliveryEligibleVendingMachines(List`1<NetworkableId> vendingMachineIds);
    [CompilerGeneratedAttribute]
private bool <GetDeliveryEligibleVendingMachines>g__IsEligible|42_0(VendingMachine vendingMachine, Vector3 offset, int n);
}
public class MaterialColorLerp : MonoBehaviour {
    public Color startColor;
    public Color endColor;
    public Color currentColor;
    public float delta;
}
[CreateAssetMenuAttribute]
public class MaterialConfig : ScriptableObject {
    [HorizontalAttribute("4", "0")]
public ShaderParametersFloat[] Floats;
    [HorizontalAttribute("4", "0")]
public ShaderParametersColor[] Colors;
    [HorizontalAttribute("4", "0")]
public ShaderParametersTexture[] Textures;
    [HorizontalAttribute("4", "0")]
public ShaderParametersToggle[] Toggles;
    public String[] ScaleUV;
    [HorizontalAttribute("2", "-1")]
public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;
    private MaterialPropertyBlock properties;
    public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale);
}
[CreateAssetMenuAttribute]
public class MaterialEffect : ScriptableObject {
    public GameObjectRef DefaultEffect;
    public SoundDefinition DefaultSoundDefinition;
    public Entry[] Entries;
    public int waterFootstepIndex;
    public Entry deepWaterEntry;
    public float deepWaterDepth;
    public Entry submergedWaterEntry;
    public float submergedWaterDepth;
    public bool ScaleVolumeWithSpeed;
    public AnimationCurve SpeedGainCurve;
    public Entry GetEntryFromMaterial(PhysicMaterial mat);
    public Entry GetWaterEntry();
    public void SpawnOnRay(Ray ray, int mask, float length, Vector3 forward, float speed);
    public void PlaySound(SoundDefinition definition, Vector3 position, float velocity);
}
[ExecuteInEditMode]
public class MaterialOverlay : MonoBehaviour {
    public Material material;
    private void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class MaterialParameterToggle : MonoBehaviour {
    [InspectorFlagsAttribute]
public ToggleMode Toggle;
    public Renderer[] TargetRenderers;
    [ColorUsageAttribute("True", "True")]
public Color EmissionColor;
}
public class MaterialPropertyDesc : ValueType {
    public int nameID;
    public Type type;
    public MaterialPropertyDesc(string name, Type type);
}
public class MaterialSetup : ProceduralObject {
    public MaterialConfig config;
    public bool IncludeChildren;
    protected void OnEnable();
    public virtual void Process();
    private void Setup();
}
[CreateAssetMenuAttribute]
public class MaterialSound : ScriptableObject {
    public SoundDefinition DefaultSound;
    public Entry[] Entries;
}
public class MaterialSwap : MonoBehaviour {
    public int materialIndex;
    public Renderer myRenderer;
    public Material OverrideMaterial;
}
public class MaxSpawnDistance : MonoBehaviour {
    public float maxDistance;
}
public class MedicalTool : AttackEntity {
    public float healDurationSelf;
    public float healDurationOther;
    public float healDurationOtherWounded;
    public float maxDistanceOther;
    public bool canUseOnOther;
    public bool canRevive;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsActiveItem]
[RPC_Server]
private void UseOther(RPCMessage msg);
    [RPC_Server]
[IsActiveItem]
private void UseSelf(RPCMessage msg);
    public virtual void ServerUse();
    private void GiveEffectsTo(BasePlayer player);
}
public class Megaphone : HeldEntity {
    [HeaderAttribute("Megaphone")]
public VoiceProcessor voiceProcessor;
    public float VoiceDamageMinFrequency;
    public float VoiceDamageAmount;
    public AudioSource VoiceSource;
    public SoundDefinition StartBroadcastingSfx;
    public SoundDefinition StopBroadcastingSfx;
    [CompilerGeneratedAttribute]
private static float <MegaphoneVoiceRange>k__BackingField;
    [ReplicatedVar]
public static float MegaphoneVoiceRange { get; public set; }
    private static Megaphone();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public static float get_MegaphoneVoiceRange();
    [CompilerGeneratedAttribute]
public static void set_MegaphoneVoiceRange(float value);
    public void UpdateItemCondition();
    [FromOwner]
[RPC_Server]
private void Server_ToggleBroadcasting(RPCMessage msg);
}
public class MeleeWeaponInformationPanel : ItemInformationPanel {
    public ItemStatValue damageDisplay;
    public ItemStatValue attackRateDisplay;
    public ItemStatValue attackSizeDisplay;
    public ItemStatValue attackRangeDisplay;
    public ItemStatValue oreGatherDisplay;
    public ItemStatValue treeGatherDisplay;
    public ItemStatValue fleshGatherDisplay;
    public GameObject untieCrateDisplay;
}
public enum MemoryBankType : Enum {
    public int value__;
    public static MemoryBankType Entity;
    public static MemoryBankType Position;
    public static MemoryBankType AIPoint;
}
public class MemorySlotUI : MonoBehaviour {
    public RustText Label;
}
public class MenuBackgroundOverride : MonoBehaviour {
    public Texture2D Background;
    public Color Tint;
}
public class MenuBackgroundPanel : SingletonComponent`1<MenuBackgroundPanel> {
    public CoverImage Image;
    public float FadeDuration;
}
public class MenuBackgroundVideo : SingletonComponent`1<MenuBackgroundVideo> {
    private String[] videos;
    private int index;
    private bool errored;
    protected virtual void Awake();
    private void OnVideoError(VideoPlayer source, string message);
    public void LoadVideoList();
    public void Update();
    private void NextVideo();
    [IteratorStateMachineAttribute("MenuBackgroundVideo/<ReadyVideo>d__8")]
internal IEnumerator ReadyVideo();
}
public class MenuButtonArcadeEntity : TextArcadeEntity {
    public string titleText;
    public string selectionSuffix;
    public string clickMessage;
    public bool IsHighlighted();
}
public class MenuHelp : MonoBehaviour {
    public TutorialFullScreenHelpInfo[] AllHelp;
    public RectTransform CategoriesParent;
    public RectTransform ContentParent;
    public GameObjectRef CategoryWidget;
    public GameObjectRef HelpWidget;
    public MenuCategory StartingCategory;
}
public class MenuHelpCategory : MonoBehaviour {
    public RustText CategoryText;
}
public class MenuHelpWidget : MonoBehaviour {
    public RustText HelpText;
    public Image HelpImage;
    public VideoPlayer HelpVideo;
    public RawImage HelpVideoTexture;
}
public class MenuServerPanel : MonoBehaviour {
    private void Start();
    private void Update();
}
public class MenuTip : MonoBehaviour {
    public RustText text;
    public LoadingScreen screen;
    public static Phrase[] MenuTips;
    private int currentTipIndex;
    private float nextTipTime;
    private static MenuTip();
    public void OnEnable();
    public void Update();
    public void UpdateTip();
}
public abstract class MeshBatch : MonoBehaviour {
    [CompilerGeneratedAttribute]
private bool <NeedsRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VertexCount>k__BackingField;
    public bool NeedsRefresh { get; private set; }
    public int Count { get; private set; }
    public int BatchedCount { get; private set; }
    public int VertexCount { get; private set; }
    public int VertexCapacity { get; }
    public int VertexCutoff { get; }
    public int AvailableVertices { get; }
    [CompilerGeneratedAttribute]
public bool get_NeedsRefresh();
    [CompilerGeneratedAttribute]
private void set_NeedsRefresh(bool value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_BatchedCount();
    [CompilerGeneratedAttribute]
private void set_BatchedCount(int value);
    [CompilerGeneratedAttribute]
public int get_VertexCount();
    [CompilerGeneratedAttribute]
private void set_VertexCount(int value);
    protected abstract virtual void AllocMemory();
    protected abstract virtual void FreeMemory();
    protected abstract virtual void RefreshMesh();
    protected abstract virtual void ApplyMesh();
    protected abstract virtual void ToggleMesh(bool state);
    protected abstract virtual void OnPooled();
    public abstract virtual int get_VertexCapacity();
    public abstract virtual int get_VertexCutoff();
    public int get_AvailableVertices();
    public void Alloc();
    public void Free();
    public void Refresh();
    public void Apply();
    public void Display();
    public void Invalidate();
    protected void AddVertices(int vertices);
    protected void OnEnable();
    protected void OnDisable();
}
public static class MeshCache : object {
    public static Dictionary`2<Mesh, Data> dictionary;
    private static MeshCache();
    public static Data Get(Mesh mesh);
}
public class MeshColliderData : object {
    public List`1<int> triangles;
    public List`1<Vector3> vertices;
    public List`1<Vector3> normals;
    public void Alloc();
    public void Free();
    public void Clear();
    public void Apply(Mesh mesh);
    public void Combine(MeshColliderGroup meshGroup);
    public void Combine(MeshColliderGroup meshGroup, MeshColliderLookup colliderLookup);
}
public class MeshColliderGroup : PooledList`1<MeshColliderInstance> {
}
public class MeshColliderInstance : ValueType {
    public Transform transform;
    public Rigidbody rigidbody;
    public Collider collider;
    public OBB bounds;
    public Vector3 position;
    public Quaternion rotation;
    public Vector3 scale;
    public Data data;
    public Mesh mesh { get; public set; }
    public Mesh get_mesh();
    public void set_mesh(Mesh value);
}
public class MeshColliderLookup : object {
    public LookupGroup src;
    public LookupGroup dst;
    public void Apply();
    public void Add(MeshColliderInstance instance);
    public LookupEntry Get(int index);
}
public class MeshCull : LODComponent {
    public float Distance;
}
public class MeshData : object {
    public List`1<int> triangles;
    public List`1<Vector3> vertices;
    public List`1<Vector3> normals;
    public List`1<Vector4> tangents;
    public List`1<Color32> colors32;
    public List`1<Vector2> uv;
    public List`1<Vector2> uv2;
    public List`1<Vector4> positions;
    public void AllocMinimal();
    public void Alloc();
    public void Free();
    public void Clear();
    public void Apply(Mesh mesh);
    public void Combine(MeshGroup meshGroup);
}
public class MeshDataBatch : MeshBatch {
    private Vector3 position;
    private Mesh meshBatch;
    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    private MeshData meshData;
    private MeshGroup meshGroup;
    public int VertexCapacity { get; }
    public int VertexCutoff { get; }
    public virtual int get_VertexCapacity();
    public virtual int get_VertexCutoff();
    protected void Awake();
    public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer);
    public void Add(MeshInstance instance);
    protected virtual void AllocMemory();
    protected virtual void FreeMemory();
    protected virtual void RefreshMesh();
    protected virtual void ApplyMesh();
    protected virtual void ToggleMesh(bool state);
    protected virtual void OnPooled();
}
public class MeshGroup : PooledList`1<MeshInstance> {
}
public class MeshGroupCull : LODComponent {
    public float Distance;
}
public class MeshHolder : object {
    [HideInInspector]
public Vector3[] _vertices;
    [HideInInspector]
public Vector3[] _normals;
    [HideInInspector]
public Int32[] _triangles;
    [HideInInspector]
public trisPerSubmesh[] _TrianglesOfSubs;
    [HideInInspector]
public Matrix4x4[] _bindPoses;
    [HideInInspector]
public BoneWeight[] _boneWeights;
    [HideInInspector]
public Bounds _bounds;
    [HideInInspector]
public int _subMeshCount;
    [HideInInspector]
public Vector4[] _tangents;
    [HideInInspector]
public Vector2[] _uv;
    [HideInInspector]
public Vector2[] _uv2;
    [HideInInspector]
public Vector2[] _uv3;
    [HideInInspector]
public Color[] _colors;
    [HideInInspector]
public Vector2[] _uv4;
    public void setAnimationData(Mesh mesh);
}
public class MeshInstance : ValueType {
    public Vector3 position;
    public Quaternion rotation;
    public Vector3 scale;
    public Data data;
    public Mesh mesh { get; public set; }
    public Mesh get_mesh();
    public void set_mesh(Mesh value);
}
public class MeshLOD : LODComponent {
    [HorizontalAttribute("1", "0")]
public State[] States;
    public Mesh GetHighestDetailMesh();
}
public class MeshPaintable : BaseMeshPaintable {
    public string replacementTextureName;
    public int textureWidth;
    public int textureHeight;
    public Color clearColor;
    public Texture2D targetTexture;
    public bool hasChanges;
}
public class MeshPaintable3D : BaseMeshPaintable {
    [ClientVar]
public static float brushScale;
    [ClientVar]
public static float uvBufferScale;
    public string replacementTextureName;
    public int textureWidth;
    public int textureHeight;
    public Camera cameraPreview;
    public Camera camera3D;
    private static MeshPaintable3D();
}
public class MeshPaintableSource : MonoBehaviour {
    public Vector4 uvRange;
    public int texWidth;
    public int texHeight;
    public string replacementTextureName;
    public float cameraFOV;
    public float cameraDistance;
    public Texture2D texture;
    public GameObject sourceObject;
    public Mesh collisionMesh;
    public Vector3 localPosition;
    public Vector3 localRotation;
    public bool applyToAllRenderers;
    public Renderer[] extraRenderers;
    public bool paint3D;
    public bool applyToSkinRenderers;
    public bool applyToFirstPersonLegs;
    public bool isSelected;
    public Renderer legRenderer;
    private static MaterialPropertyBlock block;
    public void Init();
    public void Free();
    public void OnDestroy();
    public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected);
    public virtual Color32[] UpdateFrom(Texture2D input);
    public void Load(Byte[] data);
    public void Clear();
}
public class MeshPaintController : MonoBehaviour {
    public Camera pickerCamera;
    public Tool currentTool;
    public Texture2D brushTexture;
    public Vector2 brushScale;
    public Color brushColor;
    public float brushSpacing;
    public float brushSpacingFactor;
    public RawImage brushImage;
    public float brushPreviewScaleMultiplier;
    public Texture2D stampTexture;
    public RotateMode brushRotation;
    public bool applyDefaults;
    public Texture2D defaltBrushTexture;
    public float defaultBrushSize;
    public Color defaultBrushColor;
    public float defaultBrushAlpha;
    public float maxBrushScale;
    public RustButton UndoButton;
    public RustButton RedoButton;
    public GameObject BackgroundBlocker;
    private Vector3 lastPosition;
}
public class MeshRendererBatch : MeshBatch {
    private Vector3 position;
    private Mesh meshBatch;
    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    private MeshRendererData meshData;
    private MeshRendererGroup meshGroup;
    private MeshRendererLookup meshLookup;
    private static MaterialPropertyBlock propertyBlock;
    public int VertexCapacity { get; }
    public int VertexCutoff { get; }
    public virtual int get_VertexCapacity();
    public virtual int get_VertexCutoff();
    protected void Awake();
    public void SetupColor(Color color);
    public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer, Color color);
    public void Add(MeshRendererInstance instance);
    protected virtual void AllocMemory();
    protected virtual void FreeMemory();
    protected virtual void RefreshMesh();
    protected virtual void ApplyMesh();
    protected virtual void ToggleMesh(bool state);
    protected virtual void OnPooled();
}
public class MeshRendererData : object {
    public List`1<int> triangles;
    public List`1<Vector3> vertices;
    public List`1<Vector3> normals;
    public List`1<Vector4> tangents;
    public List`1<Color32> colors32;
    public List`1<Vector2> uv;
    public List`1<Vector2> uv2;
    public List`1<Vector4> positions;
    public void Alloc();
    public void Free();
    public void Clear();
    public void Apply(Mesh mesh);
    public void Combine(MeshRendererGroup meshGroup);
    public void Combine(MeshRendererGroup meshGroup, MeshRendererLookup rendererLookup);
}
public class MeshRendererGroup : PooledList`1<MeshRendererInstance> {
}
public class MeshRendererInstance : ValueType {
    public Renderer renderer;
    public OBB bounds;
    public Vector3 position;
    public Quaternion rotation;
    public Vector3 scale;
    public Data data;
    public Mesh mesh { get; public set; }
    public Mesh get_mesh();
    public void set_mesh(Mesh value);
}
public class MeshRendererLookup : object {
    public LookupGroup src;
    public LookupGroup dst;
    public void Apply();
    public void Clear();
    public void Add(MeshRendererInstance instance);
    public LookupEntry Get(int index);
}
public class MeshReplacement : MonoBehaviour {
    public SkinnedMeshRenderer Female;
    internal static void Process(GameObject go, bool IsFemale);
}
[ExecuteInEditMode]
public class MeshTerrainRoot : MonoBehaviour {
    public GameObject TerrainBlendSearchRoot;
    public Mesh TerrainMeshAsset;
    public Material TerrainMaterial;
}
public class MeshToggle : MonoBehaviour {
    public Mesh[] RendererMeshes;
    public Mesh[] ColliderMeshes;
    public void SwitchRenderer(int index);
    public void SwitchRenderer(float factor);
    public void SwitchCollider(int index);
    public void SwitchCollider(float factor);
    public void SwitchAll(int index);
    public void SwitchAll(float factor);
}
[ExecuteInEditMode]
public class MeshTrimTester : MonoBehaviour {
    public MeshTrimSettings Settings;
    public Mesh SourceMesh;
    public MeshFilter TargetMeshFilter;
    public int SubtractIndex;
}
[Factory("meta")]
public class Meta : ConsoleSystem {
    [ServerVar]
public static void add(Arg args);
    [ClientVar]
public static void if_true(Arg args);
    [ClientVar]
public static void if_false(Arg args);
    [ClientVar]
public static void reset_cycle(Arg args);
    [ClientVar]
public static void exec(Arg args);
    private static Command Find(string name);
}
public class MetabolismAttribute : object {
    public float startMin;
    public float startMax;
    public float min;
    public float max;
    public float value;
    public float lastValue;
    internal float lastGreatFraction;
    private static float greatInterval;
    public float greatFraction { get; }
    public float get_greatFraction();
    public void Reset();
    public float Fraction();
    public float InverseFraction();
    public void Add(float val);
    public void Subtract(float val);
    public void Set(float val);
    public void Increase(float fTarget);
    public void MoveTowards(float fTarget, float fRate);
    public bool HasChanged();
    public bool HasGreatlyChanged();
    public void SetValue(float newValue);
}
public class MetalDetectorFlag : BaseDiggableEntity {
    public Collider Collision;
    public GameObject FlagModel;
    public float MoveUpBy;
    [ServerVar]
public static float TimeoutDuration;
    private static MetalDetectorFlag();
    public virtual void ServerInit();
    private void ResetTimeout();
    private void Timeout();
    public virtual void OnFullyDug(BasePlayer player);
    public virtual void OnSingleDig(BasePlayer player);
    public virtual void OnFirstDig(BasePlayer player);
}
public class MetalDetectorSource : BaseEntity {
    [ServerVar]
public static float Population;
    [ServerVar]
public static int AttemptsPerSubSourceSpawn;
    [ServerVar]
public static float MinDistanceBetweenSubSources;
    [ServerVar]
public static float TimeoutDuration;
    public static int ServerCount;
    [ClientVar]
public static bool DrawEditorGizmos;
    public int MinSources;
    public int MaxSources;
    public float SpawnRadiusMin;
    public float SpawnRadiusMax;
    public float SpawnRadiusBuffer;
    public GameObjectRef FlagPrefab;
    public GameObjectRef EffectPrefab;
    [CompilerGeneratedAttribute]
private float <SpawnRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Vector3> <SpawnLocations>k__BackingField;
    public static int placementMask;
    public static int blockMask;
    public float SpawnRadius { get; private set; }
    public List`1<Vector3> SpawnLocations { get; private set; }
    private static MetalDetectorSource();
    [CompilerGeneratedAttribute]
public float get_SpawnRadius();
    [CompilerGeneratedAttribute]
private void set_SpawnRadius(float value);
    [CompilerGeneratedAttribute]
public List`1<Vector3> get_SpawnLocations();
    [CompilerGeneratedAttribute]
private void set_SpawnLocations(List`1<Vector3> value);
    [ServerVar]
public static void ServerCountSources();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    private void SpawnSources();
    private void TrySpawnSource();
    private bool ValidateSourcePosition(Vector3& pos);
    private void ResetTimeout();
    private void Timeout();
    private void KillIfNoSources();
    private void AddSource(Vector3 pos);
    private void RemoveSource(Vector3 pos);
    public Vector3 FindNearestSubSource(Vector3 scanPosition);
    public void RemoveSweetSpotAndCreateFlag(Vector3 position);
    private void CreateFlag(Vector3 pos);
    public bool VerifySweetSpotPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos);
    public sealed virtual List`1<Vector3> GetScanLocations();
    public sealed virtual Vector3 GetNearestPosition(Vector3 pos);
    public sealed virtual bool VerifyScanPosition(Vector3 playerPos, Vector3 pos, Vector3& spotPos);
    public sealed virtual void Detected(Vector3 pos);
    public sealed virtual float GetRadius();
}
public class MetalDetectorViewmodel : BaseViewModel {
    public GameObject[] LongRangeLights;
    public GameObject[] SweetspotLights;
    public GameObject LongRangeLight;
    public Transform YawTransform;
    public Transform DetectPos;
    public MetalDetectorViewmodelAnimEvents viewmodelAnimEvents;
    public SkinnedMeshRenderer MeshRenderer;
    [ColorUsageAttribute("False", "True")]
public Color BulbOffColor;
    [ColorUsageAttribute("False", "True")]
public Color BulbOnColor;
}
public class MetalDetectorViewmodelAnimEvents : BaseMonoBehaviour {
    public float scanAmount;
    public SoundDefinition scanSwingSoundDef;
}
public class MicrophoneStand : BaseMountable {
    public VoiceProcessor VoiceProcessor;
    public AudioSource VoiceSource;
    private SpeechMode currentSpeechMode;
    public AudioMixerGroup NormalMix;
    public AudioMixerGroup HighPitchMix;
    public AudioMixerGroup LowPitchMix;
    public Phrase NormalPhrase;
    public Phrase NormalDescPhrase;
    public Phrase HighPitchPhrase;
    public Phrase HighPitchDescPhrase;
    public Phrase LowPitchPhrase;
    public Phrase LowPitchDescPhrase;
    public GameObjectRef IOSubEntity;
    public Transform IOSubEntitySpawnPos;
    public bool IsStatic;
    public EntityRef`1<IOEntity> ioEntity;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
public void SetMode(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public void SpawnChildEntity();
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void PostMapEntitySpawn();
    public virtual void Load(LoadInfo info);
}
public class MicrophoneStandIOEntity : IOEntity {
    public int PowerCost;
    public TriggerBase InstrumentTrigger;
    public bool IsStatic;
    public virtual int ConsumptionAmount();
    public virtual int DesiredPower(int inputIndex);
    public virtual int MaximalPowerOutput();
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool IsRootEntity();
    public sealed virtual IOEntity ToEntity();
}
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class MidiConvar : MonoBehaviour {
}
public class Minicopter : PlayerHelicopter {
    [ServerVar]
public static float population;
}
public class MiniCopterAnimation : MonoBehaviour {
    public void UpdateRotorSpeed(float newSpeed);
    private void Update();
}
public class MiningQuarry : BaseResourceExtractor {
    public Animator beltAnimator;
    public Renderer beltScrollRenderer;
    public int scrollMatIndex;
    public float animatorSpeedChange;
    public float beltScrollSpeedMultiplier;
    public SoundPlayer[] onSounds;
    public float processRate;
    public float workToAdd;
    public float workPerFuel;
    public float pendingWork;
    public GameObjectRef bucketDropEffect;
    public GameObject bucketDropTransform;
    public ChildPrefab engineSwitchPrefab;
    public ChildPrefab hopperPrefab;
    public ChildPrefab fuelStoragePrefab;
    public QuarryType staticType;
    public bool isStatic;
    public ResourceDeposit _linkedDeposit;
    public bool IsEngineOn();
    public void SetOn(bool isOn);
    public void EngineSwitch(bool isOn);
    public virtual void ServerInit();
    public bool CanAcceptItem(Item item, int targetSlot);
    public void UpdateStaticDeposit();
    public virtual void PostServerLoad();
    public void SpawnChildEntities();
    public void ProcessResources();
    public bool FuelCheck();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class MinMax : object {
    public float x;
    public float y;
    public MinMax(float x, float y);
    public float Random();
    public float Lerp(float t);
    public float Lerp(float a, float b, float t);
}
public class MinMaxAttribute : PropertyAttribute {
    public float min;
    public float max;
    public MinMaxAttribute(float min, float max);
}
public class MissionEntity : BaseMonoBehaviour {
    public string identifier;
    public bool cleanupOnMissionSuccess;
    public bool cleanupOnMissionFailed;
    public sealed virtual void OnParentDestroying();
    public virtual void Setup(BasePlayer assignee, MissionInstance instance, string identifier, bool wantsSuccessCleanup, bool wantsFailedCleanup);
    public virtual void MissionStarted(BasePlayer assignee, MissionInstance instance);
    public virtual void MissionEnded(BasePlayer assignee, MissionInstance instance);
    public BaseEntity GetEntity();
}
[CreateAssetMenuAttribute]
public class MissionManifest : ScriptableObject {
    public ScriptableObjectRef[] missionList;
    public WorldPositionGenerator[] positionGenerators;
    public static MissionManifest instance;
    public static MissionManifest Get();
    public static BaseMission GetFromShortName(string shortname);
    public static BaseMission GetFromID(UInt32 id);
}
public class MissionMapMarker : MonoBehaviour {
    public Image Icon;
    public Tooltip TooltipComponent;
}
public abstract class MissionObjective : ScriptableObject {
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance);
    public bool IsStarted(int index, MissionInstance instance);
    public bool CanProgress(int index, MissionInstance instance);
    public bool ShouldObjectiveStart(int index, MissionInstance instance);
    public bool IsCompleted(int index, MissionInstance instance);
    public virtual bool ShouldThink(int index, MissionInstance instance);
    public void ResetObjective(int index, MissionInstance instance, BasePlayer playerFor);
    public void CompleteObjective(int index, MissionInstance instance, BasePlayer playerFor);
    public void FailObjective(int index, MissionInstance instance, BasePlayer playerFor);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
    protected bool TryFindNearby(Vector3 origin, Func`2<T, bool> filter, T& entity, float radius);
    public virtual void PostServerLoad(BasePlayer player, ObjectiveStatus status);
}
[CreateAssetMenuAttribute]
public class MissionObjective_AcquireItem : MissionObjective {
    [ItemSelector("11")]
public ItemDefinition targetItem;
    public int targetItemAmount;
    public bool allowStackEvents;
    public bool showResourcePings;
    public bool acceptExistingItems;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Consume : MissionObjective {
    public ItemDefinition TargetItem;
    public int RequiredAmount;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_CookItem : MissionObjective {
    [ItemSelector("11")]
[TooltipAttribute("The cooked result that this objective is looking for (eg cooked chicken, not raw)")]
public ItemDefinition targetItem;
    public int targetItemAmount;
    public BaseEntityRef[] pingEntitiesOnTutorialIsland;
    public PingType pingType;
    public bool checkExistingInventory;
    private bool HasPings { get; }
    private bool get_HasPings();
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Craft : MissionObjective {
    [ItemSelector("11")]
public ItemDefinition[] targetItems;
    public int targetItemAmount;
    public bool checkExistingInventory;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
}
[CreateAssetMenuAttribute]
public class MissionObjective_DeployItem : MissionObjective {
    public BaseEntity[] PossibleOptions;
    public ItemDefinition[] PossibleItems;
    public int RequiredAmount;
    public bool PingTutorialTargets;
    private static PingType PingType;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    private bool Matches(MissionEventPayload payload);
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    private void UpdatePings(BasePlayer playerFor);
}
public class MissionObjective_EnterTrigger : MissionObjective {
    public string positionName;
    public float distForCompletion;
    public bool use2D;
    public BaseMountable requiredMountable;
    public bool shouldPing;
    public PingType pingType;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_EquipClothing : MissionObjective {
    public ItemDefinition[] RequiredItems;
    public bool CheckExistingClothingOnStart;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_FillTutorialToolCupboard : MissionObjective {
    public int RequiredUpkeepHours;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_FreeCrate : MissionObjective {
    public int targetAmount;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Harvest : MissionObjective {
    [ItemSelector("11")]
public ItemDefinition[] targetItems;
    public int targetItemAmount;
    public ItemDefinition[] pingResourceDispensers;
    public PingType pingType;
    public bool countExisting;
    public virtual void PostServerLoad(BasePlayer player, ObjectiveStatus status);
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    private void InitialiseResourcePings(BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance);
}
[CreateAssetMenuAttribute]
public class MissionObjective_HaveItem : MissionObjective {
    [ItemSelector("11")]
public ItemDefinition targetItem;
    public int targetItemAmount;
    public bool canBeReset;
    public BaseEntityRef[] pingEntitiesOnTutorialIsland;
    public PingType pingType;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Heal : MissionObjective {
    [RangeAttribute("0", "1")]
public float RequiredHealthNormalised;
    public BaseEntityRef RequireHealSource;
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_HurtEntityType : MissionObjective {
    public BaseEntityRef[] targetEntities;
    public float targetDamage;
    public bool shouldUpdateMissionLocation;
    private bool isInitalized;
    private UInt32[] targetPrefabIDs;
    private Func`2<BaseCombatEntity, bool> searchFilter;
    private void EnsureInitialized();
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
    [CompilerGeneratedAttribute]
private bool <Think>b__9_0(BaseCombatEntity e);
}
[CreateAssetMenuAttribute]
public class MissionObjective_HurtMissionEntity : MissionObjective {
    public string targetIdentifier;
    public float targetDamage;
    public bool shouldUpdateMissionLocation;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_IgniteOven : MissionObjective {
    public BaseEntityRef TargetOven;
    public bool PingTarget;
    public PingType PingType;
    private Func`2<BaseCombatEntity, bool> searchFilter;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    [CompilerGeneratedAttribute]
private bool <MissionStarted>b__4_0(BaseCombatEntity e);
}
[CreateAssetMenuAttribute]
public class MissionObjective_KillEntity : MissionObjective {
    public BaseEntityRef[] targetEntities;
    public int numToKill;
    public bool shouldUpdateMissionLocation;
    public bool pingTargets;
    private bool isInitalized;
    private UInt32[] targetPrefabIDs;
    private Func`2<BaseCombatEntity, bool> searchFilter;
    private void EnsureInitialized();
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
    [CompilerGeneratedAttribute]
private bool <Think>b__10_0(BaseCombatEntity e);
}
[CreateAssetMenuAttribute]
public class MissionObjective_MetalDetectorFind : MissionObjective {
    public int RequiredFinds;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_MountEntityType : MissionObjective {
    public BaseEntityRef[] targetEntities;
    public int numToMount;
    public bool shouldUpdateMissionLocation;
    private bool isInitalized;
    private UInt32[] targetPrefabIDs;
    private Func`2<BaseEntity, bool> searchFilter;
    private void EnsureInitialized();
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
    [CompilerGeneratedAttribute]
private bool <Think>b__9_0(BaseEntity e);
}
[CreateAssetMenuAttribute]
public class MissionObjective_MountMissionEntity : MissionObjective {
    public string targetIdentifier;
    public bool shouldUpdateMissionLocation;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Move : MissionObjective {
    public string positionName;
    public float distForCompletion;
    public bool use2D;
    public BaseMountable requiredMountable;
    public bool shouldPing;
    public PingType pingType;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void Think(int index, MissionInstance instance, BasePlayer assignee, float delta);
}
[CreateAssetMenuAttribute]
public class MissionObjective_OpenTutorialStorageContainer : MissionObjective {
    public ItemAmount[] Items;
    public BaseEntity TargetEntity;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance);
    private void DeregisterPing(BasePlayer playerFor);
    public virtual void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_PlayerInput : MissionObjective {
    public BUTTON requiredButton;
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_Respawn : MissionObjective {
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_RetrieveItemsFromCorpse : MissionObjective {
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
[CreateAssetMenuAttribute]
public class MissionObjective_SpeakWith : MissionObjective {
    public ItemAmount[] requiredReturnItems;
    public bool destroyReturnItems;
    public bool showPing;
    public bool checkSpaceForRewards;
    public static Phrase NoSpaceInInventoryPhrase;
    private static MissionObjective_SpeakWith();
    public virtual void ObjectiveStarted(BasePlayer playerFor, int index, MissionInstance instance);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
    public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, MissionInstance instance);
    private static void DeregisterPing(BasePlayer playerFor, MissionInstance instance);
    public virtual void ObjectiveFailed(BasePlayer playerFor, int index, MissionInstance instance);
    [CompilerGeneratedAttribute]
private bool <ProcessMissionEvent>g__CheckRewardsSpace|6_0(<>c__DisplayClass6_0& );
}
[CreateAssetMenuAttribute]
public class MissionObjective_UpgradeBuildingBlock : MissionObjective {
    public bool ShouldPingBlocksLessThanTargetGrade;
    public PingType PingType;
    public Enum TargetGrade;
    public int RequiredCount;
    public virtual void MissionStarted(int index, MissionInstance instance, BasePlayer forPlayer);
    public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionInstance instance, int index, MissionEventType type, MissionEventPayload payload, float amount);
}
public class MissionPoint : MonoBehaviour {
    public bool dropToGround;
    public static int COUNT;
    public static int EVERYTHING;
    public static int NOTHING;
    public static int EASY_MONUMENT;
    public static int MED_MONUMENT;
    public static int HARD_MONUMENT;
    public static int ITEM_HIDESPOT;
    public static int UNDERWATER;
    public static int TUTORIAL_BEAR;
    public static int EASY_MONUMENT_IDX;
    public static int MED_MONUMENT_IDX;
    public static int HARD_MONUMENT_IDX;
    public static int ITEM_HIDESPOT_IDX;
    public static int FOREST_IDX;
    public static int ROADSIDE_IDX;
    public static int BEACH;
    public static int UNDERWATER_IDX;
    public static int TUTORIAL_BEAR_IDX;
    private static Dictionary`2<int, int> type2index;
    [InspectorFlagsAttribute]
public MissionPointEnum Flags;
    public static List`1<MissionPoint> all;
    private static MissionPoint();
    public static int TypeToIndex(int id);
    public static int IndexToType(int idx);
    public void Awake();
    private void Start();
    private void DropToGround();
    public void OnDisable();
    public virtual Vector3 GetPosition();
    public virtual Quaternion GetRotation();
    public static bool GetMissionPoints(List`1& points, Vector3 near, float minDistance, float maxDistance, int flags, int exclusionFlags);
}
public class MissionPointMapMarker : MonoBehaviour {
    public RustText MissionName;
    public Image Icon;
}
public class MissionsHUD : SingletonComponent`1<MissionsHUD> {
    public SoundDefinition listComplete;
    public SoundDefinition itemComplete;
    public SoundDefinition popup;
    public Canvas Canvas;
    public RustText titleText;
    public GameObject timerObject;
    public RustText timerText;
}
public class MissionsHUDToDo : BaseMonoBehaviour {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Memoized`2<string, ValueTuple`2<float, float>> FormatProgres;
    public RustText text;
    public RectTransform checkIcon;
    public RectTransform checkBox;
    public Phrase optionalPrefix;
    public CanvasGroup group;
    [FormerlySerializedAsAttribute("AliveColor")]
public Color DefaultColor;
    [FormerlySerializedAsAttribute("DeadColor")]
public Color CompletedColor;
    [FormerlySerializedAsAttribute("HighlightColor")]
public Color CompletedHighlightColor;
    public Color FailedColor;
    public Color FailedHighlightColor;
    public PingWidget PingWidget;
    private static MissionsHUDToDo();
}
public class MissionUIPanel : MonoBehaviour {
    public GameObject activeMissionParent;
    public RustText missionTitleText;
    public RustText missionDescText;
    public GameObject rewardsParent;
    public VirtualItemIcon[] rewardIcons;
    public GameObject bonusRewardsParent;
    public VirtualItemIcon[] bonusIcons;
    public Phrase noMissionText;
    public GameObject abandonButton;
}
public class MixerSnapshotManager : SingletonComponent`1<MixerSnapshotManager> {
    public AudioMixerSnapshot defaultSnapshot;
    public AudioMixerSnapshot underwaterSnapshot;
    public AudioMixerSnapshot loadingSnapshot;
    public AudioMixerSnapshot woundedSnapshot;
    public AudioMixerSnapshot cctvSnapshot;
    public AudioMixerSnapshot fadeToBlackSnapshot;
    public SoundDefinition underwaterInSound;
    public SoundDefinition underwaterOutSound;
    public AudioMixerSnapshot recordingSnapshot;
    public SoundDefinition woundedLoop;
    private Sound woundedLoopSound;
    public SoundDefinition cctvModeLoopDef;
    private Sound cctvModeLoop;
    public SoundDefinition cctvModeStartDef;
    public SoundDefinition cctvModeStopDef;
    public float deafness;
}
public class MixingTable : StorageContainer {
    public GameObject Particles;
    public RecipeList Recipes;
    public bool OnlyAcceptValidIngredients;
    [CompilerGeneratedAttribute]
private float <RemainingMixTime>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TotalMixTime>k__BackingField;
    public float lastTickTimestamp;
    private List`1<Item> inventoryItems;
    [CompilerGeneratedAttribute]
private BasePlayer <MixStartingPlayer>k__BackingField;
    private static float mixTickInterval;
    public Recipe currentRecipe;
    public int currentQuantity;
    public ItemDefinition currentProductionItem;
    public float RemainingMixTime { get; public set; }
    public float TotalMixTime { get; public set; }
    public BasePlayer MixStartingPlayer { get; private set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public float get_RemainingMixTime();
    [CompilerGeneratedAttribute]
public void set_RemainingMixTime(float value);
    [CompilerGeneratedAttribute]
public float get_TotalMixTime();
    [CompilerGeneratedAttribute]
public void set_TotalMixTime(float value);
    [CompilerGeneratedAttribute]
public BasePlayer get_MixStartingPlayer();
    [CompilerGeneratedAttribute]
private void set_MixStartingPlayer(BasePlayer value);
    public virtual void ServerInit();
    private bool CanAcceptItem(Item item, int targetSlot);
    protected virtual void OnInventoryDirty();
    [MaxDistance("3")]
[RPC_Server]
private void SVSwitch(RPCMessage msg);
    public void StartMixing(BasePlayer player);
    protected virtual bool CanStartMixing(BasePlayer player);
    public void StopMixing();
    public void TickMix();
    public void ProduceItem(Recipe recipe, int quantity);
    private void ConsumeInventory(Recipe recipe, int quantity);
    private void ReturnExcessItems(List`1<Item> orderedContainerItems, BasePlayer player);
    protected virtual void CreateRecipeItems(Recipe recipe, int quantity);
    public virtual void Save(SaveInfo info);
    private int GetItemWaterAmount(Item item);
    public virtual void Load(LoadInfo info);
    public List`1<Item> GetOrderedContainerItems(ItemContainer container, Boolean& itemsAreContiguous);
}
public class MLRS : BaseMountable {
    [SerializeField]
[HeaderAttribute("MLRS Components")]
private GameObjectRef rocketStoragePrefab;
    [SerializeField]
private GameObjectRef dashboardStoragePrefab;
    [HeaderAttribute("MLRS Rotation")]
[SerializeField]
private Transform hRotator;
    [SerializeField]
public float hRotSpeed;
    [SerializeField]
private Transform vRotator;
    [SerializeField]
public float vRotSpeed;
    [SerializeField]
[RangeAttribute("50", "90")]
public float vRotMax;
    [SerializeField]
private Transform hydraulics;
    [HeaderAttribute("MLRS Weaponry")]
[TooltipAttribute("Minimum distance from the MLRS to a targeted hit point. In metres.")]
[SerializeField]
public float minRange;
    [TooltipAttribute("The size of the area that the rockets may hit, minus rocket damage radius.")]
[SerializeField]
public float targetAreaRadius;
    [SerializeField]
private GameObjectRef mlrsRocket;
    [SerializeField]
public Transform firingPoint;
    [SerializeField]
public RocketTube[] rocketTubes;
    [SerializeField]
[HeaderAttribute("MLRS Dashboard/FX")]
private GameObject screensChild;
    [SerializeField]
private Transform leftHandGrip;
    [SerializeField]
private Transform leftJoystick;
    [SerializeField]
private Transform rightHandGrip;
    [SerializeField]
private Transform rightJoystick;
    [SerializeField]
private Transform controlKnobHeight;
    [SerializeField]
private Transform controlKnobAngle;
    [SerializeField]
private GameObjectRef uiDialogPrefab;
    [SerializeField]
private Light fireButtonLight;
    [SerializeField]
private GameObject brokenDownEffect;
    [SerializeField]
private ParticleSystem topScreenShutdown;
    [SerializeField]
private ParticleSystem bottomScreenShutdown;
    [ServerVar]
public static float brokenDownMinutes;
    [CompilerGeneratedAttribute]
private Vector3 <UserTargetHitPos>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <TrueHitPos>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CurGravityMultiplier>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RocketAmmoCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRealigning>k__BackingField;
    public static Flags FLAG_FIRING_ROCKETS;
    public static Flags FLAG_HAS_AIMING_MODULE;
    private EntityRef rocketStorageInstance;
    private EntityRef dashboardStorageInstance;
    public float rocketBaseGravity;
    public float rocketSpeed;
    [CompilerGeneratedAttribute]
private float <RocketDamageRadius>k__BackingField;
    private bool isInitialLoad;
    public static string MLRS_PLAYER_KILL_STAT;
    private float leftRightInput;
    private float upDownInput;
    public Vector3 lastSentTargetHitPos;
    public Vector3 lastSentTrueHitPos;
    public int nextRocketIndex;
    public EntityRef rocketOwnerRef;
    public TimeSince timeSinceBroken;
    public int radiusModIndex;
    private Single[] radiusMods;
    public Vector3 trueTargetHitPos;
    public Vector3 UserTargetHitPos { get; public set; }
    public Vector3 TrueHitPos { get; public set; }
    public bool HasAimingModule { get; }
    public bool CanBeUsed { get; }
    public bool CanFire { get; }
    public float HRotation { get; public set; }
    public float VRotation { get; public set; }
    public float CurGravityMultiplier { get; public set; }
    public int RocketAmmoCount { get; public set; }
    public bool IsRealigning { get; public set; }
    public bool IsFiringRockets { get; }
    public float RocketDamageRadius { get; private set; }
    private static MLRS();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public Vector3 get_UserTargetHitPos();
    [CompilerGeneratedAttribute]
public void set_UserTargetHitPos(Vector3 value);
    [CompilerGeneratedAttribute]
public Vector3 get_TrueHitPos();
    [CompilerGeneratedAttribute]
public void set_TrueHitPos(Vector3 value);
    public bool get_HasAimingModule();
    public bool get_CanBeUsed();
    public bool get_CanFire();
    public float get_HRotation();
    public void set_HRotation(float value);
    public float get_VRotation();
    public void set_VRotation(float value);
    [CompilerGeneratedAttribute]
public float get_CurGravityMultiplier();
    [CompilerGeneratedAttribute]
public void set_CurGravityMultiplier(float value);
    [CompilerGeneratedAttribute]
public int get_RocketAmmoCount();
    [CompilerGeneratedAttribute]
public void set_RocketAmmoCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IsRealigning();
    [CompilerGeneratedAttribute]
public void set_IsRealigning(bool value);
    public bool get_IsFiringRockets();
    [CompilerGeneratedAttribute]
public float get_RocketDamageRadius();
    [CompilerGeneratedAttribute]
private void set_RocketDamageRadius(float value);
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual bool CanBeLooted(BasePlayer player);
    public void SetUserTargetHitPos(Vector3 worldPos);
    public StorageContainer GetRocketContainer();
    public StorageContainer GetDashboardContainer();
    public void HitPosToRotation(Vector3 hitPos, Single& hRot, Single& vRot, Single& g);
    public static float ProjectileDistToSpeed(float x, float y, float angle, float g, float fallbackV);
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual void VehicleFixedUpdate();
    public float GetSurfaceHeight(Vector3 pos);
    public void SetRepaired();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void Save(SaveInfo info);
    public bool AdminFixUp();
    public void Fire(BasePlayer owner);
    public void EndFiring();
    public void FireNextRocket();
    private void UpdateStorageState();
    public bool TryGetAimingModule(Item& item);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_SetTargetHitPos(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Fire_Rockets(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Open_Rockets(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Open_Dashboard(RPCMessage msg);
}
public class MLRSAmmoIcon : MonoBehaviour {
    [SerializeField]
private GameObject fill;
    protected void Awake();
    public void SetState(bool filled);
}
public class MLRSAmmoUI : MonoBehaviour {
    [SerializeField]
private RustText ammoText;
    [SerializeField]
private MLRSAmmoIcon[] ammoIcons;
}
public class MLRSAudio : MonoBehaviour {
    [SerializeField]
private MLRS mlrs;
    [SerializeField]
private Transform pitchTransform;
    [SerializeField]
private Transform yawTransform;
    [SerializeField]
private float pitchDeltaSmoothRate;
    [SerializeField]
private float yawDeltaSmoothRate;
    [SerializeField]
private float pitchDeltaThreshold;
    [SerializeField]
private float yawDeltaThreshold;
    private float lastPitch;
    private float lastYaw;
    private float pitchDelta;
    private float yawDelta;
    public SoundDefinition turretMovementStartDef;
    public SoundDefinition turretMovementLoopDef;
    public SoundDefinition turretMovementStopDef;
    private Sound turretMovementLoop;
}
public class MLRSMainUI : MonoBehaviour {
    [SerializeField]
private bool isFullscreen;
    [SerializeField]
private GameObject noAimingModuleModeGO;
    [SerializeField]
private GameObject activeModeGO;
    [SerializeField]
private MLRSAmmoUI noAimingModuleAmmoUI;
    [SerializeField]
private MLRSAmmoUI activeAmmoUI;
    [SerializeField]
private MLRSVelocityUI velocityUI;
    [SerializeField]
private RustText titleText;
    [SerializeField]
private RustText usernameText;
    [SerializeField]
private TokenisedPhrase readyStatus;
    [SerializeField]
private TokenisedPhrase realigningStatus;
    [SerializeField]
private TokenisedPhrase firingStatus;
    [SerializeField]
private RustText statusText;
    [SerializeField]
private MapView mapView;
    [SerializeField]
private ScrollRectEx mapScrollRect;
    [SerializeField]
private ScrollRectZoom mapScrollRectZoom;
    [SerializeField]
private RectTransform mapBaseRect;
    [SerializeField]
private RectTransform minRangeCircle;
    [SerializeField]
private RectTransform targetAimRect;
    [SerializeField]
private RectTransform trueAimRect;
    [SerializeField]
private UILineRenderer connectingLine;
    [SerializeField]
private GameObject noTargetCirclePrefab;
    [SerializeField]
private Transform noTargetCircleParent;
    [SerializeField]
private SoundDefinition changeTargetSoundDef;
    [SerializeField]
private SoundDefinition readyToFireSoundDef;
}
public class MLRSRocket : TimedExplosive {
    [SerializeField]
private GameObjectRef mapMarkerPrefab;
    [SerializeField]
private GameObjectRef launchBlastFXPrefab;
    [SerializeField]
private GameObjectRef explosionGroundFXPrefab;
    [SerializeField]
private ServerProjectile serverProjectile;
    private EntityRef mapMarkerInstanceRef;
    public static List`1<MLRSRocket> serverList;
    public SamTargetType SAMTargetType { get; }
    private static MLRSRocket();
    public sealed virtual SamTargetType get_SAMTargetType();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin);
    private void CreateMapMarker();
    public sealed virtual bool IsValidSAMTarget(bool staticRespawn);
    public virtual Vector3 GetLocalVelocityServer();
    private void OnTriggerEnter(Collider other);
}
public class MLRSServerProjectile : ServerProjectile {
    public bool HasRangeLimit { get; }
    protected int mask { get; }
    public virtual bool get_HasRangeLimit();
    protected virtual int get_mask();
    protected virtual bool IsAValidHit(BaseEntity hitEnt);
}
public class MLRSUIDialog : UIDialog {
    [SerializeField]
private MLRSMainUI mainUI;
    [SerializeField]
private TokenisedPhrase howToUsePhrase;
    [SerializeField]
private float titleChangeInterval;
}
public class MLRSVelocityUI : MonoBehaviour {
    [SerializeField]
private RustText percentText;
    [SerializeField]
private HudElement percentBar;
}
public class MobileInventoryEntity : BaseEntity {
    public SoundDefinition ringingLoop;
    public SoundDefinition silentLoop;
    public static Flags Ringing;
    public static Flags Flag_Silent;
    private static MobileInventoryEntity();
    public void ToggleRinging(bool state);
    public void SetSilentMode(bool wantsSilent);
}
public class MobileMapMarker : MapMarker {
    private GameObject createdMarker;
}
public class MobilePhone : HeldEntity {
    public PhoneController Controller;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    [FromOwner]
[RPC_Server]
public void ClearCurrentUser(RPCMessage msg);
    [RPC_Server]
[FromOwner]
public void SetCurrentUser(RPCMessage msg);
    [FromOwner]
[RPC_Server]
public void InitiateCall(RPCMessage msg);
    [RPC_Server]
[FromOwner]
public void AnswerPhone(RPCMessage msg);
    [RPC_Server]
[FromOwner]
private void ServerHangUp(RPCMessage msg);
    public virtual void DestroyShared();
    [CallsPerSecond("5")]
[RPC_Server]
[FromOwner]
public void UpdatePhoneName(RPCMessage msg);
    [CallsPerSecond("5")]
[FromOwner]
[RPC_Server]
public void Server_RequestPhoneDirectory(RPCMessage msg);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("5")]
public void Server_AddSavedNumber(RPCMessage msg);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("5")]
public void Server_RemoveSavedNumber(RPCMessage msg);
    [FromOwner]
[RPC_Server]
public void Server_RequestCurrentState(RPCMessage msg);
    [CallsPerSecond("5")]
[RPC_Server]
public void ServerSendVoicemail(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("5")]
[FromOwner]
public void ServerPlayVoicemail(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("5")]
[FromOwner]
public void ServerStopVoicemail(RPCMessage msg);
    [FromOwner]
[RPC_Server]
[CallsPerSecond("5")]
public void ServerDeleteVoicemail(RPCMessage msg);
    public void ToggleRinging(bool state);
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class Model : MonoBehaviour {
    public SphereCollider collision;
    public Transform rootBone;
    public Transform headBone;
    public Transform eyeBone;
    public Animator animator;
    public Skeleton skeleton;
    [HideInInspector]
public Transform[] boneTransforms;
    [HideInInspector]
public String[] boneNames;
    internal BoneDictionary boneDict;
    internal int skin;
    protected void OnEnable();
    public void BuildBoneDictionary();
    public int GetSkin();
    private Transform FindBoneInternal(string name);
    public Transform FindBone(string name);
    public Transform FindBone(UInt32 hash);
    public UInt32 FindBoneID(Transform transform);
    public Transform[] GetBones();
    public Transform FindClosestBone(Vector3 worldPos);
    public sealed virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public abstract class ModelConditionTest : PrefabAttribute {
    public abstract virtual bool DoTest(BaseEntity ent);
    protected virtual Type GetIndexedType();
}
public class ModelConditionTest_False : ModelConditionTest {
    public ConditionalModel reference;
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_FoundationSide : ModelConditionTest {
    private static string square_south;
    private static string square_north;
    private static string square_west;
    private static string square_east;
    private static string triangle_south;
    private static string triangle_northwest;
    private static string triangle_northeast;
    private string socket;
    protected void OnDrawGizmosSelected();
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_Inside : ModelConditionTest {
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_Outside : ModelConditionTest {
    public virtual bool DoTest(BaseEntity ent);
    public static bool CheckCondition(BaseEntity ent);
}
public class ModelConditionTest_RampHigh : ModelConditionTest {
    private static string socket;
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RampLow : ModelConditionTest {
    private static string socket;
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RoofBottom : ModelConditionTest {
    private static string roof_square;
    private static string roof_triangle;
    private static string socket_bot_right;
    private static string socket_bot_left;
    private static string socket_top_right;
    private static string socket_top_left;
    private static String[] sockets_bot_right;
    private static String[] sockets_bot_left;
    private static ModelConditionTest_RoofBottom();
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RoofLeft : ModelConditionTest {
    public AngleType angle;
    public ShapeType shape;
    private static string roof_square;
    private static string roof_triangle;
    private static string socket_right;
    private static string socket_left;
    private static String[] sockets_left;
    private bool IsConvex { get; }
    private bool IsConcave { get; }
    private static ModelConditionTest_RoofLeft();
    private bool get_IsConvex();
    private bool get_IsConcave();
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RoofRight : ModelConditionTest {
    public AngleType angle;
    public ShapeType shape;
    private static string roof_square;
    private static string roof_triangle;
    private static string socket_right;
    private static string socket_left;
    private static String[] sockets_right;
    private bool IsConvex { get; }
    private bool IsConcave { get; }
    private static ModelConditionTest_RoofRight();
    private bool get_IsConvex();
    private bool get_IsConcave();
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RoofTop : ModelConditionTest {
    private static string roof_square;
    private static string roof_triangle;
    private static string socket_bot_right;
    private static string socket_bot_left;
    private static string socket_top_right;
    private static string socket_top_left;
    private static String[] sockets_top_right;
    private static String[] sockets_top_left;
    private static ModelConditionTest_RoofTop();
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_RoofTriangle : ModelConditionTest {
    private static string socket;
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_SpiralStairs : ModelConditionTest {
    private static string stairs_socket_female;
    private static String[] stairs_sockets_female;
    private static string floor_socket_female;
    private static String[] floor_sockets_female;
    private static ModelConditionTest_SpiralStairs();
    protected void OnDrawGizmosSelected();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_True : ModelConditionTest {
    public ConditionalModel reference;
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_Variant : ModelConditionTest {
    public ulong VariantSeed;
    public ulong VariantIndex;
    public ulong VariantCount;
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_Wall : ModelConditionTest {
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_WallCornerLeft : ModelConditionTest {
    private static string socket;
    private static String[] sockets;
    private static ModelConditionTest_WallCornerLeft();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_WallCornerRight : ModelConditionTest {
    private static string socket;
    private static String[] sockets;
    private static ModelConditionTest_WallCornerRight();
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_Wallpaper : ModelConditionTest {
    public bool softSide;
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_WallTriangleLeft : ModelConditionTest {
    private static string socket_1;
    private static string socket_2;
    private static string socket_3;
    private static string socket_4;
    private static string socket_5;
    private static string socket_6;
    private static string socket;
    public static bool CheckCondition(BaseEntity ent);
    private static bool CheckSocketOccupied(BaseEntity ent, string socket);
    public virtual bool DoTest(BaseEntity ent);
}
public class ModelConditionTest_WallTriangleRight : ModelConditionTest {
    private static string socket_1;
    private static string socket_2;
    private static string socket_3;
    private static string socket_4;
    private static string socket_5;
    private static string socket_6;
    private static string socket;
    public static bool CheckCondition(BaseEntity ent);
    private static bool CheckSocketOccupied(BaseEntity ent, string socket);
    public virtual bool DoTest(BaseEntity ent);
}
public class Modifier : object {
    [CompilerGeneratedAttribute]
private ModifierType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ModifierSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private float <TimeRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expired>k__BackingField;
    public static Phrase WoodYieldPhrase;
    public static Phrase OreYieldPhrase;
    public static Phrase RadiationResistancePhrase;
    public static Phrase RadiationExposureResistancePhrase;
    public static Phrase MaxHealthPhrase;
    public static Phrase ScrapYieldPhrase;
    public ModifierType Type { get; private set; }
    public ModifierSource Source { get; private set; }
    public float Value { get; private set; }
    public float Duration { get; private set; }
    public float TimeRemaining { get; private set; }
    public bool Expired { get; private set; }
    private static Modifier();
    [CompilerGeneratedAttribute]
public ModifierType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ModifierType value);
    [CompilerGeneratedAttribute]
public ModifierSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(ModifierSource value);
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    [CompilerGeneratedAttribute]
public float get_Duration();
    [CompilerGeneratedAttribute]
private void set_Duration(float value);
    [CompilerGeneratedAttribute]
public float get_TimeRemaining();
    [CompilerGeneratedAttribute]
private void set_TimeRemaining(float value);
    [CompilerGeneratedAttribute]
public bool get_Expired();
    [CompilerGeneratedAttribute]
private void set_Expired(bool value);
    public void Init(ModifierType type, ModifierSource source, float value, float duration, float remaining);
    public void Tick(BaseCombatEntity ownerEntity, float delta);
    public Modifier Save();
    public void Load(Modifier m);
    public static Phrase GetPhraseForModType(ModifierType type);
}
public class ModifierDefintion : object {
    public ModifierType type;
    public ModifierSource source;
    public float value;
    public float duration;
}
public class ModularCar : BaseModularVehicle {
    [HeaderAttribute("Modular Car")]
public ModularCarChassisVisuals chassisVisuals;
    public VisualCarWheel wheelFL;
    public VisualCarWheel wheelFR;
    public VisualCarWheel wheelRL;
    public VisualCarWheel wheelRR;
    [SerializeField]
public CarSettings carSettings;
    [SerializeField]
public float hurtTriggerMinSpeed;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerFront;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerRear;
    [SerializeField]
public ProtectionProperties immortalProtection;
    [SerializeField]
public ProtectionProperties mortalProtection;
    [SerializeField]
private BoxCollider mainChassisCollider;
    [SerializeField]
public SpawnSettings spawnSettings;
    [HideInInspector]
[SerializeField]
public MeshRenderer[] damageShowingRenderers;
    [ServerVar]
public static float population;
    [ServerVar]
public static float outsidedecayminutes;
    public static BUTTON RapidSteerButton;
    [CompilerGeneratedAttribute]
private ModularCarCodeLock <CarLock>k__BackingField;
    public EngineState<GroundVehicle> lastSetEngineState;
    public float cachedFuelFraction;
    public static HashSet`1<ModularCar> allCarsList;
    public ListDictionary`2<BaseMountable, DriverSeatInputs> driverSeatInputs;
    public CarPhysics`1<ModularCar> carPhysics;
    public VehicleTerrainHandler serverTerrainHandler;
    private CarWheel[] wheels;
    public float lastEngineOnTime;
    private static float DECAY_TICK_TIME;
    private static float INSIDE_DECAY_MULTIPLIER;
    private static float CORPSE_DECAY_MINUTES;
    public Vector3 prevPosition;
    public Quaternion prevRotation;
    private Bounds collisionCheckBounds;
    private Vector3 lastGoodPos;
    private Quaternion lastGoodRot;
    private bool lastPosWasBad;
    public float deathDamageCounter;
    private static float DAMAGE_TO_GIB;
    public TimeSince timeSinceDeath;
    private static float IMMUNE_TIME;
    public Vector3 groundedCOMMultiplier;
    public Vector3 airbourneCOMMultiplier;
    public Vector3 prevCOMMultiplier;
    public float DriveWheelVelocity { get; }
    public float DriveWheelSlip { get; }
    public float SteerAngle { get; }
    public ItemDefinition AssociatedItemDef { get; }
    public float MaxSteerAngle { get; }
    public bool IsLockable { get; }
    public ModularCarCodeLock CarLock { get; private set; }
    public bool AlwaysAllowBradleyTargeting { get; }
    public Surface OnSurface { get; }
    private static ModularCar();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float get_DriveWheelVelocity();
    public float get_DriveWheelSlip();
    public sealed virtual float get_SteerAngle();
    public ItemDefinition get_AssociatedItemDef();
    public sealed virtual float get_MaxSteerAngle();
    public virtual bool get_IsLockable();
    [CompilerGeneratedAttribute]
public ModularCarCodeLock get_CarLock();
    [CompilerGeneratedAttribute]
private void set_CarLock(ModularCarCodeLock value);
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual void InitShared();
    public virtual float MaxHealth();
    public virtual float StartHealth();
    public float TotalHealth();
    public float TotalMaxHealth();
    public virtual float GetMaxForwardSpeed();
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual float GetThrottleInput();
    public virtual float GetBrakeInput();
    public sealed virtual float GetMaxDriveForce();
    public float GetFuelFraction();
    public sealed virtual bool PlayerHasUnlockPermission(BasePlayer player);
    public bool KeycodeEntryBlocked(BasePlayer player);
    public virtual bool PlayerCanUseThis(BasePlayer player, LockType lockType);
    public sealed virtual bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual bool CanPushNow(BasePlayer pusher);
    public bool RefreshEngineState();
    public float RollOffDriveForce(float driveForce);
    public void RefreshChassisProtectionState();
    public virtual void ModuleEntityAdded(BaseVehicleModule addedModule);
    public virtual void ModuleEntityRemoved(BaseVehicleModule removedModule);
    public virtual bool get_AlwaysAllowBradleyTargeting();
    public sealed virtual Surface get_OnSurface();
    public virtual void ServerInit();
    public virtual void DoServerDestroy();
    public virtual void PostServerLoad();
    public sealed virtual float GetSteerInput();
    public sealed virtual bool GetSteerSpeedMod(float speed);
    public sealed virtual float GetSteerMaxMult(float speed);
    public virtual void VehicleFixedUpdate();
    protected virtual bool DetermineIfStationary();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public virtual void Save(SaveInfo info);
    public virtual void Hurt(HitInfo info);
    public void TickFuel(float fuelUsedPerSecond);
    public virtual bool MountEligable(BasePlayer player);
    public virtual bool IsComplete();
    public void DoDecayDamage(float damage);
    public sealed virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public bool HasAnyEngines();
    public bool HasAnyWorkingEngines();
    public virtual bool MeetsEngineRequirements();
    public virtual void OnEngineStartFailed();
    public sealed virtual CarWheel[] GetWheels();
    public sealed virtual float GetWheelsMidPos();
    public virtual bool AdminFixUp(int tier);
    public virtual void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info);
    public void PropagateDamageToModules(HitInfo info, float minPropagationPercent, float maxPropagationPercent, BaseVehicleModule ignoreModule);
    public virtual void ModuleReachedZeroHealth();
    public virtual void OnKilled(HitInfo info);
    public sealed virtual void RemoveLock();
    public sealed virtual void RestoreVelocity(Vector3 vel);
    public virtual Vector3 GetCOMMultiplier();
    public void UpdateClients();
    public void DecayTick();
    public virtual void DoCollisionDamage(BaseEntity hitEntity, float damage);
    public void SpawnPreassignedModules();
    public void HandleAdminBonus();
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    [RPC_Server]
public void RPC_OpenFuelWithKeycode(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_TryMountWithKeycode(RPCMessage msg);
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
}
public class ModularCarCentralLockingSwitch : VehicleModuleButtonComponent {
    public Transform centralLockingSwitch;
    public Vector3 switchOffPos;
    public Vector3 switchOnPos;
    public virtual void ServerUse(BasePlayer player, BaseVehicleModule parentModule);
}
public class ModularCarChassisVisuals : VehicleChassisVisuals`1<ModularCar> {
    public Transform frontAxle;
    public Transform rearAxle;
    public Steering steering;
    public LookAtTarget transmission;
}
public class ModularCarCodeLock : object {
    private bool isServer;
    public ModularCar owner;
    public static Flags FLAG_CENTRAL_LOCKING;
    public static Flags FLAG_CODE_ENTRY_BLOCKED;
    public static float LOCK_DESTROY_HEALTH;
    private List`1<ulong> whitelistPlayers;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    private int wrongCodes;
    private float lastWrongTime;
    public bool HasALock { get; }
    public bool CentralLockingIsOn { get; }
    public IList`1<ulong> WhitelistPlayers { get; }
    public string Code { get; private set; }
    public ModularCarCodeLock(ModularCar owner, bool isServer);
    public bool get_HasALock();
    public bool get_CentralLockingIsOn();
    public IList`1<ulong> get_WhitelistPlayers();
    public bool PlayerCanDestroyLock(BaseVehicleModule viaModule);
    public bool CodeEntryBlocked(BasePlayer player);
    public void Load(LoadInfo info);
    public bool HasLockPermission(BasePlayer player);
    public bool PlayerCanUseThis(BasePlayer player, LockType lockType);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(string value);
    public void PostServerLoad();
    public bool CanHaveALock();
    public bool TryAddALock(string code, ulong userID);
    public bool IsValidLockCode(string code);
    public bool TrySetNewCode(string newCode, ulong userID);
    public void RemoveLock();
    public bool TryOpenWithCode(BasePlayer player, string codeEntered);
    private void ClearCodeEntryBlocked();
    public void CheckEnableCentralLocking();
    public void ToggleCentralLocking();
    public void Save(SaveInfo info);
    public bool TryAddPlayer(ulong userID);
    public bool TryRemovePlayer(ulong userID);
}
public class ModularCarCodeLockVisuals : MonoBehaviour {
    [SerializeField]
private GameObject lockedVisuals;
    [SerializeField]
private GameObject unlockedVisuals;
    [SerializeField]
private GameObject blockedVisuals;
    [SerializeField]
private GameObjectRef codelockEffectDenied;
    [SerializeField]
private GameObjectRef codelockEffectShock;
    [SerializeField]
private float xOffset;
    [SerializeField]
private ParticleSystemContainer keycodeDestroyableFX;
}
public class ModularCarGarage : ContainerIOEntity {
    [SerializeField]
public Transform vehicleLift;
    [SerializeField]
public Animation vehicleLiftAnim;
    [SerializeField]
private string animName;
    [SerializeField]
public VehicleLiftOccupantTrigger occupantTrigger;
    [SerializeField]
public float liftMoveTime;
    [SerializeField]
public EmissionToggle poweredLight;
    [SerializeField]
public EmissionToggle inUseLight;
    [SerializeField]
public Transform vehicleLiftPos;
    [SerializeField]
[RangeAttribute("0", "1")]
public float recycleEfficiency;
    [SerializeField]
public Transform recycleDropPos;
    [SerializeField]
public bool needsElectricity;
    [SerializeField]
private SoundDefinition liftStartSoundDef;
    [SerializeField]
private SoundDefinition liftStopSoundDef;
    [SerializeField]
private SoundDefinition liftStopDownSoundDef;
    [SerializeField]
private SoundDefinition liftLoopSoundDef;
    [SerializeField]
private GameObjectRef addRemoveLockEffect;
    [SerializeField]
private GameObjectRef changeLockCodeEffect;
    [SerializeField]
private GameObjectRef repairEffect;
    [SerializeField]
private TriggerBase playerTrigger;
    public ChassisBuildOption[] chassisBuildOptions;
    public ItemAmount lockResourceCost;
    [CompilerGeneratedAttribute]
private bool <PlatformIsOccupied>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasEditableOccupant>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDriveableOccupant>k__BackingField;
    [CompilerGeneratedAttribute]
private OccupantLock <OccupantLockState>k__BackingField;
    public VehicleLiftState vehicleLiftState;
    private Sound liftLoopSound;
    public Vector3 downPos;
    public static Flags Flag_DestroyingChassis;
    public static float TimeToDestroyChassis;
    public static Flags Flag_EnteringKeycode;
    public static Flags Flag_PlayerObstructing;
    public ModularCar lockedOccupant;
    public HashSet`1<BasePlayer> lootingPlayers;
    public MagnetSnap magnetSnap;
    public bool PlatformIsOccupied { get; public set; }
    public bool HasEditableOccupant { get; public set; }
    public bool HasDriveableOccupant { get; public set; }
    public OccupantLock OccupantLockState { get; public set; }
    public bool LiftIsUp { get; }
    public bool LiftIsMoving { get; }
    public bool LiftIsDown { get; }
    public bool IsDestroyingChassis { get; }
    private bool IsEnteringKeycode { get; }
    public bool PlayerObstructingLift { get; }
    public ModularCar carOccupant { get; }
    public bool HasOccupant { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public bool get_PlatformIsOccupied();
    [CompilerGeneratedAttribute]
public void set_PlatformIsOccupied(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasEditableOccupant();
    [CompilerGeneratedAttribute]
public void set_HasEditableOccupant(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasDriveableOccupant();
    [CompilerGeneratedAttribute]
public void set_HasDriveableOccupant(bool value);
    [CompilerGeneratedAttribute]
public OccupantLock get_OccupantLockState();
    [CompilerGeneratedAttribute]
public void set_OccupantLockState(OccupantLock value);
    public bool get_LiftIsUp();
    public bool get_LiftIsMoving();
    public bool get_LiftIsDown();
    public bool get_IsDestroyingChassis();
    private bool get_IsEnteringKeycode();
    public bool get_PlayerObstructingLift();
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual int ConsumptionAmount();
    public void SetOccupantState(bool hasOccupant, bool editableOccupant, bool driveableOccupant, OccupantLock occupantLockState, bool forced);
    public void RefreshLiftState(bool forced);
    public void MoveLift(VehicleLiftState desiredLiftState, float startDelay, bool forced);
    public void MoveLiftUp();
    public void MoveLiftDown();
    public ModularCar get_carOccupant();
    public bool get_HasOccupant();
    public void FixedUpdate();
    internal virtual void DoServerDestroy();
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual bool CanPickup(BasePlayer player);
    public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public bool TryGetModuleForItem(Item item, BaseVehicleModule& result);
    public void RefreshOnOffState();
    public void UpdateCarOccupant();
    public void UpdateOccupantMode();
    public void WakeNearbyRigidbodies();
    public void EditableOccupantEntered();
    public void EditableOccupantLeft();
    public void RefreshLoot();
    public void GrabOccupant(ModularCar occupant);
    public void ReleaseOccupant();
    public void StopChassisDestroy();
    [IsVisible("3")]
[RPC_Server]
[MaxDistance("3")]
public void RPC_RepairItem(RPCMessage msg);
    [MaxDistance("3")]
[IsVisible("3")]
[RPC_Server]
public void RPC_OpenEditing(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
[IsVisible("3")]
public void RPC_DiedWithKeypadOpen(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_SelectedLootItem(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void RPC_DeselectedLootItem(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_StartKeycodeEntry(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
[IsVisible("3")]
public void RPC_RequestAddLock(RPCMessage msg);
    [MaxDistance("3")]
[IsVisible("3")]
[RPC_Server]
public void RPC_RequestRemoveLock(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
[IsVisible("3")]
public void RPC_RequestNewCode(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
[MaxDistance("3")]
[CallsPerSecond("1")]
public void RPC_StartDestroyingChassis(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
[IsVisible("3")]
[CallsPerSecond("1")]
public void RPC_StopDestroyingChassis(RPCMessage msg);
    public void FinishDestroyingChassis();
}
public class ModularCarOven : BaseOven {
    private BaseVehicleModule moduleParent;
    private BaseVehicleModule ModuleParent { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private BaseVehicleModule get_ModuleParent();
    public virtual void ResetState();
    protected virtual void SVSwitch(RPCMessage msg);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    protected virtual void OnCooked();
}
[CreateAssetMenuAttribute]
public class ModularCarPresetConfig : ScriptableObject {
    public ItemModVehicleModule[] socketItemDefs;
}
public class ModularCarSeat : MouseSteerableSeat {
    [SerializeField]
public Vector3 leftFootIKPos;
    [SerializeField]
public Vector3 rightFootIKPos;
    [SerializeField]
private Vector3 leftHandIKPos;
    [SerializeField]
private Vector3 rightHandIKPos;
    public float providesComfort;
    public VehicleModuleSeating associatedSeatingModule;
    public virtual bool CanSwapToThis(BasePlayer player);
    public virtual float GetComfort();
}
public class ModularVehicleShopFront : ShopFront {
    [SerializeField]
public float maxUseDistance;
    public virtual bool CanBeLooted(BasePlayer player);
    public bool WithinUseDistance(BasePlayer player);
}
public class MolotovCocktail : GrenadeWeapon {
}
public class Monument : TerrainPlacement {
    public float Radius;
    public float Fade;
    public bool AutoCliffSplat;
    public bool AutoCliffTopology;
    public bool RemoveExistingTopology;
    protected void OnDrawGizmosSelected();
    protected virtual void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
}
public class MonumentBenchmarkScene : BenchmarkScene {
    public String[] monumentPrefabs;
    public Transform[] vantagePoints;
}
public class MonumentInfo : LandmarkInfo {
    [HeaderAttribute("MonumentInfo")]
public MonumentType Type;
    [InspectorFlagsAttribute]
public MonumentTier Tier;
    public int MinWorldSize;
    public Bounds Bounds;
    public bool HasNavmesh;
    public bool IsSafeZone;
    [HideInInspector]
public bool WantsDungeonLink;
    [HideInInspector]
public bool HasDungeonLink;
    [HideInInspector]
public DungeonGridInfo DungeonEntrance;
    private OBB obbBounds;
    protected virtual void Awake();
    private void Start();
    public bool CheckPlacement(Vector3 pos, Quaternion rot, Vector3 scale);
    public float Distance(Vector3 position);
    public float SqrDistance(Vector3 position);
    public float Distance(OBB obb);
    public float SqrDistance(OBB obb);
    public bool IsInBounds(Vector3 position);
    public Vector3 ClosestPointOnBounds(Vector3 position);
    public Point GetPathFinderPoint(int res);
    public int GetPathFinderRadius(int res);
    protected void OnDrawGizmosSelected();
    public MonumentNavMesh GetMonumentNavMesh();
    public static int TierToMask(MonumentTier tier);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    private DungeonGridInfo FindDungeonEntrance();
    private bool DetermineHasDungeonLink();
    private bool DetermineWantsDungeonLink();
}
public class MonumentMarker : MonoBehaviour {
    public RustText text;
    public Image imageBackground;
    public Image image;
    public Color dayColor;
    public Color nightColor;
    public void Setup(LandmarkInfo info);
    public void SetNightMode(bool nightMode);
}
public class MonumentNavMesh : FacepunchBehaviour {
    public int NavMeshAgentTypeIndex;
    [TooltipAttribute("The default area associated with the NavMeshAgent index.")]
public string DefaultAreaName;
    [TooltipAttribute("How many cells to use squared")]
public int CellCount;
    [TooltipAttribute("The size of each cell for async object gathering")]
public int CellSize;
    public int Height;
    public float NavmeshResolutionModifier;
    [TooltipAttribute("Use the bounds specified in editor instead of generating it from cellsize * cellcount")]
public bool overrideAutoBounds;
    [TooltipAttribute("Bounds which are auto calculated from CellSize * CellCount")]
public Bounds Bounds;
    public NavMeshData NavMeshData;
    public NavMeshDataInstance NavMeshDataInstance;
    public LayerMask LayerMask;
    public NavMeshCollectGeometry NavMeshCollectGeometry;
    public bool forceCollectTerrain;
    public bool shouldNotifyAIZones;
    public Transform CustomNavMeshRoot;
    public bool IgnoreTerrain;
    [ServerVar]
public static bool use_baked_terrain_mesh;
    private List`1<NavMeshBuildSource> sources;
    private AsyncOperation BuildingOperation;
    private bool HasBuildOperationStarted;
    private Stopwatch BuildTimer;
    private int defaultArea;
    private int agentTypeId;
    public bool IsBuilding { get; }
    private static MonumentNavMesh();
    public bool get_IsBuilding();
    private void OnEnable();
    private void OnDisable();
    [ContextMenu("Update Monument Nav Mesh")]
public void UpdateNavMeshAsync();
    [IteratorStateMachineAttribute("MonumentNavMesh/<UpdateNavMeshAndWait>d__28")]
public IEnumerator UpdateNavMeshAndWait();
    public void NotifyInformationZonesOfCompletion();
    private void AppendModifierVolumes(List`1<NavMeshBuildSource> sources);
    public void FinishBuildingNavmesh();
}
public class MonumentNode : MonoBehaviour {
    public string ResourceFolder;
    protected void Awake();
    public void Process(UInt32& seed);
}
public class MonumentSign : LODComponent {
    public float viewDistance;
    public GameObject uiRoot;
    public RustText signText;
}
public enum MonumentTier : Enum {
    public int value__;
    public static MonumentTier Tier0;
    public static MonumentTier Tier1;
    public static MonumentTier Tier2;
}
public enum MonumentType : Enum {
    public int value__;
    public static MonumentType Cave;
    public static MonumentType Airport;
    public static MonumentType Building;
    public static MonumentType Town;
    public static MonumentType Radtown;
    public static MonumentType Lighthouse;
    public static MonumentType WaterWell;
    public static MonumentType Roadside;
    public static MonumentType Mountain;
    public static MonumentType Lake;
    public static MonumentType Oasis;
    public static MonumentType Canyon;
}
public class MorphCache : FacepunchBehaviour {
}
public class MortarFirework : RepeatingFirework {
    public GameObjectRef[] shellTypes;
    public Transform emissionPoint;
}
public class MotorbikeAudio : BikeVehicleAudio {
}
public class MotorRowboat : BaseBoat {
    [HeaderAttribute("Audio")]
public BlendedSoundLoops engineLoops;
    public BlendedSoundLoops waterLoops;
    public SoundDefinition engineStartSoundDef;
    public SoundDefinition engineStopSoundDef;
    public SoundDefinition movementSplashAccentSoundDef;
    public SoundDefinition engineSteerSoundDef;
    public GameObjectRef pushLandEffect;
    public GameObjectRef pushWaterEffect;
    public float waterSpeedDivisor;
    public float turnPitchModScale;
    public float tiltPitchModScale;
    public float splashAccentFrequencyMin;
    public float splashAccentFrequencyMax;
    protected static Flags Flag_ThrottleOn;
    protected static Flags Flag_TurnLeft;
    protected static Flags Flag_TurnRight;
    protected static Flags Flag_HasFuel;
    protected static Flags Flag_RecentlyPushed;
    protected static Flags Flag_Submerged;
    protected static Flags Flag_Dying;
    public static float submergeFractionMinimum;
    public float deathSinkRate;
    [HeaderAttribute("Fuel")]
public GameObjectRef fuelStoragePrefab;
    public float fuelPerSec;
    [HeaderAttribute("Storage")]
public GameObjectRef storageUnitPrefab;
    public EntityRef`1<StorageContainer> storageUnitInstance;
    [HeaderAttribute("Effects")]
public Transform boatRear;
    public ParticleSystemContainer wakeEffect;
    public ParticleSystemContainer engineEffectIdle;
    public ParticleSystemContainer engineEffectThrottle;
    [TooltipAttribute("If not supplied, with use engineEffectThrottle for both")]
public ParticleSystemContainer engineEffectThrottleReverse;
    [TooltipAttribute("Only needed if using a forwardTravelEffect")]
public Transform boatFront;
    public ParticleSystemContainer forwardTravelEffect;
    public float forwardTravelEffectMinSpeed;
    public Projector causticsProjector;
    public Transform causticsDepthTest;
    public Transform engineLeftHandPosition;
    public Transform engineRotate;
    public float engineRotateRangeMultiplier;
    public Transform propellerRotate;
    [ServerVar]
public static float population;
    [ServerVar]
public static float outsidedecayminutes;
    [ServerVar]
public static float deepwaterdecayminutes;
    [ServerVar]
public static float decaystartdelayminutes;
    public EntityFuelSystem fuelSystem;
    public Transform[] stationaryDismounts;
    public TimeSince timeSinceLastUsedFuel;
    public float angularDragBase;
    public float engineOffAngularDragMultiplier;
    public float angularDragVelocity;
    public float landDrag;
    public float waterDrag;
    public float offAxisDrag;
    public float offAxisDot;
    protected static float DECAY_TICK_TIME;
    private TimeSince startedFlip;
    public float lastHadDriverTime;
    public static float maxVelForStationaryDismount;
    public bool IsDying { get; }
    private static MotorRowboat();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_IsDying();
    public virtual void InitShared();
    public virtual void ServerInit();
    protected virtual void OnChildAdded(BaseEntity child);
    internal virtual void DoServerDestroy();
    public virtual IFuelSystem GetFuelSystem();
    public virtual int StartingFuelUnits();
    public virtual void BoatDecay();
    public virtual void DoPushAction(BasePlayer player);
    private void FlipMonitor();
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    [RPC_Server]
public void RPC_EngineToggle(RPCMessage msg);
    public void EngineToggle(bool wantsOn);
    public virtual void PostServerLoad();
    public void CheckInvalidBoat();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual bool EngineOn();
    public float TimeSinceDriver();
    public virtual void DriverInput(InputState inputState, BasePlayer player);
    public virtual void VehicleFixedUpdate();
    private void SetFlags();
    protected virtual bool DetermineIfStationary();
    public virtual void SeatClippedWorld(BaseMountable mountable);
    public void UpdateDrag();
    public virtual void OnKilled(HitInfo info);
    protected virtual void EnterCorpseState();
    public void ActualDeath();
    public virtual bool MountEligable(BasePlayer player);
    public virtual bool HasValidDismountPosition(BasePlayer player);
    public virtual bool GetDismountPosition(BasePlayer player, Vector3& res);
    public virtual void DisableTransferProtection();
    public virtual void Save(SaveInfo info);
    public virtual bool CanPushNow(BasePlayer pusher);
    private bool ShowPushMenu(BasePlayer player);
    public virtual void Load(LoadInfo info);
}
public class MountableParentCombatEntity : BaseCombatEntity {
    private BaseMountable mountable;
    private BaseMountable Mountable { get; }
    private BaseMountable get_Mountable();
}
public class Mountain : TerrainPlacement {
    public float Fade;
    public bool AutoCliffSplat;
    public bool AutoCliffTopology;
    protected void OnDrawGizmosSelected();
    protected virtual void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
}
public class MouseSteerableSeat : BaseVehicleSeat {
    [SerializeField]
private bool supportsMouseSteer;
    public static BUTTON MouseSteerButton;
}
public class MoveForward : MonoBehaviour {
    public float Speed;
    protected void Update();
}
public class MovementSounds : MonoBehaviour {
    public SoundDefinition waterMovementDef;
    public float waterMovementFadeInSpeed;
    public float waterMovementFadeOutSpeed;
    public SoundDefinition enterWaterSmall;
    public SoundDefinition enterWaterMedium;
    public SoundDefinition enterWaterLarge;
    private Sound waterMovement;
    private Modulator waterGainMod;
    public bool inWater;
    public float waterLevel;
    public bool mute;
}
public class MovementSoundTrigger : TriggerBase {
    public SoundDefinition softSound;
    public SoundDefinition medSound;
    public SoundDefinition hardSound;
    public Collider collider;
    public virtual void PreClientComponentCull(IPrefabProcessor p);
}
[CreateAssetMenuAttribute]
public class MoveMission : BaseMission {
    public float minDistForMovePoint;
    public float maxDistForMovePoint;
    private float minDistFromLocation;
    public virtual void MissionStart(MissionInstance instance, BasePlayer assignee);
    public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee);
    public virtual Sprite GetIcon(MissionInstance instance);
    public virtual void Think(MissionInstance instance, BasePlayer assignee, float delta);
}
public class MoveObjectOverTime : MonoBehaviour {
    public Transform Mover;
    public Vector3 OffsetAmount;
    public float Speed;
}
public class MoveOverTime : MonoBehaviour {
    [RangeAttribute("-10", "10")]
public float speed;
    public Vector3 position;
    public Vector3 rotation;
    public Vector3 scale;
    private void Update();
}
public static class MurmurHash : object {
    private static UInt32 seed;
    public static int Signed(Stream stream);
    public static UInt32 Unsigned(Stream stream);
    private static UInt32 rot(UInt32 x, byte r);
    private static UInt32 mix(UInt32 h);
}
[ExtensionAttribute]
public static class MurmurHashEx : object {
    [ExtensionAttribute]
public static int MurmurHashSigned(string str);
    [ExtensionAttribute]
public static UInt32 MurmurHashUnsigned(string str);
    private static MemoryStream StringToStream(string str);
}
public class MusicChangeIntensity : MonoBehaviour {
    public float raiseTo;
    public List`1<DistanceIntensity> distanceIntensities;
    public float tickInterval;
}
public class MusicClip : ScriptableObject {
    public AudioClip audioClip;
    public int lengthInBars;
    public int lengthInBarsWithTail;
    public List`1<float> fadeInPoints;
    public float GetNextFadeInPoint(float currentClipTimeBars);
}
public class MusicClipLoader : object {
    public List`1<LoadedAudioClip> loadedClips;
    public Dictionary`2<AudioClip, LoadedAudioClip> loadedClipDict;
    public List`1<AudioClip> clipsToLoad;
    public List`1<AudioClip> clipsToUnload;
    public void Update();
    public void Refresh();
    private LoadedAudioClip FindLoadedClip(AudioClip clip);
}
public class MusicManager : SingletonComponent`1<MusicManager> {
    public AudioMixerGroup mixerGroup;
    public List`1<MusicTheme> themes;
    public MusicTheme currentTheme;
    public List`1<AudioSource> sources;
    public double nextMusic;
    public double nextMusicFromIntensityRaise;
    [RangeAttribute("0", "1")]
public float intensity;
    public Dictionary`2<PositionedClip, ClipPlaybackData> clipPlaybackData;
    public int holdIntensityUntilBar;
    public bool musicPlaying;
    public bool loadingFirstClips;
    public MusicTheme nextTheme;
    public double lastClipUpdate;
    public float clipUpdateInterval;
    public double themeStartTime;
    public int lastActiveClipRefresh;
    public int activeClipRefreshInterval;
    public bool forceThemeChange;
    public float randomIntensityJumpChance;
    public int clipScheduleBarsEarly;
    public List`1<PositionedClip> activeClips;
    public List`1<PositionedClip> activeMusicClips;
    public List`1<PositionedClip> activeControlClips;
    public List`1<MusicZone> currentMusicZones;
    public int currentBar;
    public int barOffset;
    public double currentThemeTime { get; }
    public int themeBar { get; }
    public double get_currentThemeTime();
    public int get_themeBar();
    public static void RaiseIntensityTo(float amount, int holdLengthBars);
    public void StopMusic();
}
[CreateAssetMenuAttribute]
public class MusicTheme : ScriptableObject {
    [HeaderAttribute("Basic info")]
public float tempo;
    public int intensityHoldBars;
    public int lengthInBars;
    [HeaderAttribute("Playback restrictions")]
public bool canPlayInMenus;
    [HorizontalAttribute("2", "-1")]
public ValueRange rain;
    [HorizontalAttribute("2", "-1")]
public ValueRange wind;
    [HorizontalAttribute("2", "-1")]
public ValueRange snow;
    [InspectorFlagsAttribute]
public Enum biomes;
    [InspectorFlagsAttribute]
public Enum topologies;
    public AnimationCurve time;
    [HeaderAttribute("Clip data")]
public List`1<PositionedClip> clips;
    public List`1<Layer> layers;
    private Dictionary`2<int, List`1<PositionedClip>> activeClips;
    private List`1<AudioClip> firstAudioClips;
    private Dictionary`2<AudioClip, bool> audioClipDict;
    public int layerCount { get; }
    public int samplesPerBar { get; }
    public int get_layerCount();
    public int get_samplesPerBar();
    private void OnValidate();
    public List`1<PositionedClip> GetActiveClipsForBar(int bar);
    private int ActiveClipCollectionID(int bar);
    public Layer LayerById(int id);
    public void AddLayer();
    private void UpdateLengthInBars();
    public bool CanPlayInEnvironment(int currentBiome, int currentTopology, float currentRain, float currentSnow, float currentWind);
    public bool FirstClipsLoaded();
    public bool ContainsAudioClip(AudioClip clip);
}
public class MusicUtil : object {
    public static float OneSixteenth;
    public static double BeatsToSeconds(float tempo, float beats);
    public static double BarsToSeconds(float tempo, float bars);
    public static int SecondsToSamples(double seconds);
    public static int SecondsToSamples(double seconds, int sampleRate);
    public static int SecondsToSamples(float seconds);
    public static int SecondsToSamples(float seconds, int sampleRate);
    public static int BarsToSamples(float tempo, float bars, int sampleRate);
    public static int BarsToSamples(float tempo, float bars);
    public static int BeatsToSamples(float tempo, float beats);
    public static float SecondsToBeats(float tempo, double seconds);
    public static float SecondsToBars(float tempo, double seconds);
    public static float Quantize(float position, float gridSize);
    public static float FlooredQuantize(float position, float gridSize);
}
public class MusicZone : MonoBehaviour {
    public List`1<MusicTheme> themes;
    public float priority;
    public bool suppressAutomaticMusic;
    public bool startOnEnter;
}
public class Muzzleflash_AlphaRandom : MonoBehaviour {
    public ParticleSystem[] muzzleflashParticles;
    private Gradient grad;
    private GradientColorKey[] gck;
    private GradientAlphaKey[] gak;
    private void Start();
    private void OnEnable();
}
public class MuzzleFlash_Flamelet : MonoBehaviour {
    public ParticleSystem flameletParticle;
    private void OnEnable();
}
public static class NameHelper : object {
    public static string Get(ulong userId, string name, bool isClient, bool forceFriendly);
    public static string Get(IPlayerInfo playerInfo, bool isClient);
    public static string GetPlayerNameStreamSafe(BasePlayer from, BasePlayer target);
}
[Factory("nametags")]
public class nametags : ConsoleSystem {
    [ClientVar]
public static bool enabled;
    private static nametags();
}
[SuppressUnmanagedCodeSecurityAttribute]
public static class NativeNoise : object {
    public static float Simplex1D(float x);
    public static float Simplex1D(float x, Single& dx);
    public static float Simplex2D(float x, float y);
    public static float Simplex2D(float x, float y, Single& dx, Single& dy);
    public static float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}
[AddComponentMenu("Image Effects/Natural Bloom and Dirty Lens")]
[RequireComponent("UnityEngine.Camera")]
[ExecuteInEditMode]
public class NaturalBloomAndDirtyLens : MonoBehaviour {
    public Shader shader;
    public Texture2D lensDirtTexture;
    public float range;
    public float cutoff;
    [RangeAttribute("0", "1")]
public float bloomIntensity;
    [RangeAttribute("0", "1")]
public float lensDirtIntensity;
    [RangeAttribute("0", "4")]
public float spread;
    [RangeAttribute("0", "4")]
public int iterations;
    [RangeAttribute("1", "10")]
public int mips;
    public Single[] mipWeights;
    public bool highPrecision;
    public bool downscaleSource;
    public bool debug;
    public bool temporalFilter;
    [RangeAttribute("0,01", "1")]
public float temporalFilterWeight;
}
public class NavMeshTester : MonoBehaviour {
}
public static class NavMeshTools : object {
    [IteratorStateMachineAttribute("NavMeshTools/<CollectSourcesAsync>d__0")]
public static IEnumerator CollectSourcesAsync(Bounds bounds, int mask, NavMeshCollectGeometry geometry, int area, bool useBakedTerrainMesh, int cellSize, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback, Transform customNavMeshDataRoot);
    [IteratorStateMachineAttribute("NavMeshTools/<CollectSourcesAsync>d__1")]
public static IEnumerator CollectSourcesAsync(Transform root, int mask, NavMeshCollectGeometry geometry, int area, List`1<NavMeshBuildSource> sources, Action`1<List`1<NavMeshBuildSource>> append, Action callback);
}
public class NeedsCursor : MonoBehaviour {
    private void Update();
}
public class NeedsMouseWheel : ListComponent`1<NeedsMouseWheel> {
    public static bool AnyActive();
}
public class NeighbourSocket : Socket_Base {
    private void OnDrawGizmosSelected();
    public virtual bool TestTarget(Target target);
    public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation);
}
public class NeonMeshPaintableSource : MeshPaintableSource {
    public NeonSign neonSign;
    public float editorEmissionScale;
    public AnimationCurve lightingCurve;
    public Color topLeft;
    public Color topRight;
    public Color bottomLeft;
    public Color bottomRight;
    public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected);
    public virtual Color32[] UpdateFrom(Texture2D input);
    [CompilerGeneratedAttribute]
private Color <UpdateFrom>g__GetColorForRegion|8_0(int x, int y, int regionWidth, int regionHeight, <>c__DisplayClass8_0& );
}
public class NeonSign : Signage {
    private static float FastSpeed;
    private static float MediumSpeed;
    private static float SlowSpeed;
    private static float MinSpeed;
    private static float MaxSpeed;
    [HeaderAttribute("Neon Sign")]
public Light topLeft;
    public Light topRight;
    public Light bottomLeft;
    public Light bottomRight;
    public float lightIntensity;
    [RangeAttribute("1", "100")]
public int powerConsumption;
    public Material activeMaterial;
    public Material inactiveMaterial;
    public float animationSpeed;
    public int currentFrame;
    public List`1<Lights> frameLighting;
    public bool isAnimating;
    public Action animationLoopAction;
    public AmbienceEmitter ambientSoundEmitter;
    public SoundDefinition switchSoundDef;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    public virtual void Load(LoadInfo info);
    public virtual void ServerInit();
    public virtual void ResetState();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    private void SwitchToNextFrame();
    public virtual void Save(SaveInfo info);
    [CallsPerSecond("5")]
[MaxDistance("3")]
[RPC_Server]
public void SetAnimationSpeed(RPCMessage msg);
    [MaxDistance("3")]
[CallsPerSecond("5")]
[RPC_Server]
public void UpdateNeonColors(RPCMessage msg);
    public void EnsureInitialized();
    private static Color ClampColor(Color color);
}
public static class Network.Channel.Client : object {
    public static byte Default;
    public static byte Tick;
}
public static class Network.Channel.Server : object {
    public static byte Default;
    public static byte Positions;
}
public abstract class NetworkCryptography : object {
    private Byte[] buffer;
    public sealed virtual ArraySegment`1<byte> EncryptCopy(Connection connection, ArraySegment`1<byte> data);
    public sealed virtual ArraySegment`1<byte> DecryptCopy(Connection connection, ArraySegment`1<byte> data);
    public sealed virtual void Encrypt(Connection connection, ArraySegment`1& data);
    public sealed virtual void Decrypt(Connection connection, ArraySegment`1& data);
    protected abstract virtual void EncryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
    protected abstract virtual void DecryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
}
public class NetworkCryptographyServer : NetworkCryptography {
    protected virtual void EncryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
    protected virtual void DecryptionHandler(Connection connection, ArraySegment`1<byte> src, ArraySegment`1& dst);
}
public class NetworkedProperty`1 : object {
    private T val;
    private BaseEntity entity;
    public T Value { get; public set; }
    public NetworkedProperty`1(BaseEntity entity);
    public T get_Value();
    public void set_Value(T value);
    public static T op_Implicit(NetworkedProperty`1<T> value);
}
[FlagsAttribute]
public enum NetworkGroupType : Enum {
    public int value__;
    public static NetworkGroupType Cave;
    public static NetworkGroupType TrainTunnels;
    public static NetworkGroupType Canyon;
}
public class NetworkInfoGeneralText : MonoBehaviour {
    public TextMeshProUGUI text;
    private void Update();
    private void UpdateText();
    private static string ChannelStat(int window, int left);
}
public class NetworkSleep : MonoBehaviour {
    public static int totalBehavioursDisabled;
    public static int totalCollidersDisabled;
    public Behaviour[] behaviours;
    public Collider[] colliders;
    internal int BehavioursDisabled;
    internal int CollidersDisabled;
}
public class NetworkVisibilityGrid : MonoBehaviour {
    public static int overworldLayer;
    public static int cavesLayer;
    public static int tunnelsLayer;
    public static int tutorialsLayer;
    public static int dynamicDungeonsFirstLayer;
    public int startID;
    public int gridSize;
    public int cellCount;
    [FormerlySerializedAsAttribute("visibilityRadius")]
public int visibilityRadiusFar;
    public int visibilityRadiusNear;
    public float switchTolerance;
    public static float cavesThreshold;
    public static float tunnelsThreshold;
    public float dynamicDungeonsThreshold;
    public float dynamicDungeonsInterval;
    private float halfGridSize;
    private float cellSize;
    private float halfCellSize;
    private int numIDsPerLayer;
    private static NetworkVisibilityGrid();
    public static void ResetUndergroundThresholds();
    public static void RegisterEnvironmentVolume(EnvironmentVolume volume);
    private void Awake();
    private void OnEnable();
    private void OnDisable();
    private void OnDrawGizmosSelected();
    private int PositionToGrid(float value);
    private float GridToPosition(int value);
    private int PositionToLayer(float x, float y, float z);
    private UInt32 CoordToID(int x, int y, int layer);
    private UInt32 GetID(Vector3 vPos);
    private ValueTuple`3<int, int, int> DeconstructGroupId(int groupId);
    private Bounds GetBounds(UInt32 uid);
    public sealed virtual void OnGroupAdded(Group group);
    public sealed virtual bool IsInside(Group group, Vector3 vPos);
    public sealed virtual Group GetGroup(Vector3 vPos);
    public sealed virtual void GetVisibleFromFar(Group group, List`1<Group> groups);
    public sealed virtual void GetVisibleFromNear(Group group, List`1<Group> groups);
    private void GetVisibleFrom(Group group, List`1<Group> groups, int radius);
    [CompilerGeneratedAttribute]
private void <GetVisibleFrom>g__AddLayers|37_0(int groupX, int groupY, int groupLayer, <>c__DisplayClass37_0& );
    [CompilerGeneratedAttribute]
private void <GetVisibleFrom>g__Add|37_1(int groupX, int groupY, int groupLayer, <>c__DisplayClass37_0& );
}
[ExtensionAttribute]
public static class NetworkWriteEx : object {
    [ExtensionAttribute]
public static void WriteObject(NetWrite write, T obj);
}
public class NewsParagraph : MonoBehaviour {
    public RustText Text;
    public List`1<string> Links;
    public sealed virtual void OnPointerClick(PointerEventData eventData);
}
public class NewsSource : MonoBehaviour {
    private static Regex BbcodeParse;
    public RustText title;
    public RustText date;
    public RustText authorName;
    public HttpImage coverImage;
    public RectTransform container;
    public Button button;
    public FlexElement layoutRoot;
    public RustText paragraphTemplate;
    public HttpImage imageTemplate;
    public HttpImage youtubeTemplate;
    private static String[] BulletSeparators;
    private static NewsSource();
    public void Awake();
    public void OnEnable();
    public void SetStory(Story story);
    private void ParseBbcode(ParagraphBuilder& currentParagraph, string bbcode, String& firstImage, int depth);
    private static String[] GetBulletPoints(string listContent);
    private void AppendParagraph(ParagraphBuilder& currentParagraph);
    private void AppendImage(ParagraphBuilder& currentParagraph, string url);
    private void AppendYouTube(ParagraphBuilder& currentParagraph, string videoId);
}
public class NewYearGong : BaseCombatEntity {
    public SoundDefinition gongSound;
    public float minTimeBetweenSounds;
    public GameObject soundRoot;
    public Transform gongCentre;
    public float gongRadius;
    public AnimationCurve pitchCurve;
    public Animator gongAnimator;
    private float lastSound;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Hurt(HitInfo info);
}
public class NexusClanBackend : object {
    private Dictionary`2<long, NexusClanWrapper> _clanWrappers;
    private IClanChangeSink _changeSink;
    private NexusClanChatCollector _chatCollector;
    private NexusClanEventHandler _eventHandler;
    private NexusZoneClient _client;
    public sealed virtual ValueTask Initialize(IClanChangeSink changeSink);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NexusClanBackend/<Get>d__8")]
public sealed virtual ValueTask`1<ClanValueResult`1<IClan>> Get(long clanId);
    public sealed virtual bool TryGet(long clanId, IClan& clan);
    [AsyncStateMachineAttribute("NexusClanBackend/<GetByMember>d__10")]
public sealed virtual ValueTask`1<ClanValueResult`1<IClan>> GetByMember(ulong steamId);
    [AsyncStateMachineAttribute("NexusClanBackend/<Create>d__11")]
public sealed virtual ValueTask`1<ClanValueResult`1<IClan>> Create(ulong leaderSteamId, string name);
    [AsyncStateMachineAttribute("NexusClanBackend/<ListInvitations>d__12")]
public sealed virtual ValueTask`1<ClanValueResult`1<List`1<ClanInvitation>>> ListInvitations(ulong steamId);
    [AsyncStateMachineAttribute("NexusClanBackend/<GetLeaderboard>d__13")]
public sealed virtual ValueTask`1<ClanValueResult`1<List`1<ClanLeaderboardEntry>>> GetLeaderboard(int limit);
    public void HandleClanChatBatch(ClanChatBatchRequest request);
    [IteratorStateMachineAttribute("NexusClanBackend/<BroadcastClanChatBatches>d__15")]
private IEnumerator BroadcastClanChatBatches();
    public void UpdateWrapper(long clanId);
    public void RemoveWrapper(long clanId);
    private NexusClanWrapper Wrap(NexusClan clan);
    [AsyncStateMachineAttribute("NexusClanBackend/<<BroadcastClanChatBatches>g__SendClanChatBatch|15_0>d")]
[CompilerGeneratedAttribute]
internal static void <BroadcastClanChatBatches>g__SendClanChatBatch|15_0(List`1<Message> messages);
}
public class NexusClanChatCollector : object {
    private IClanChangeSink _external;
    private List`1<Message> _messagesBuffer;
    public NexusClanChatCollector(IClanChangeSink external);
    public void TakeMessages(List`1<Message> messages);
    public void OnClanChatMessage(long clanId, ClanChatEntry entry);
}
public class NexusClanEventHandler : object {
    private NexusClanBackend _backend;
    private IClanChangeSink _changeSink;
    public NexusClanEventHandler(NexusClanBackend backend, IClanChangeSink changeSink);
    public void OnDisbanded(ClanDisbandedEvent& args);
    public void OnInvitation(ClanInvitedEvent& args);
    public void OnJoined(ClanJoinedEvent& args);
    public void OnKicked(ClanKickedEvent& args);
    public void OnChanged(ClanChangedEvent& args);
    public void OnUnload(Int64& clanId);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnDisbanded(ClanDisbandedEvent& modreq(System.Runtime.InteropServices.InAttribute) args);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnInvitation(ClanInvitedEvent& modreq(System.Runtime.InteropServices.InAttribute) args);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnJoined(ClanJoinedEvent& modreq(System.Runtime.InteropServices.InAttribute) args);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnKicked(ClanKickedEvent& modreq(System.Runtime.InteropServices.InAttribute) args);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnChanged(ClanChangedEvent& modreq(System.Runtime.InteropServices.InAttribute) args);
    private sealed virtual override void Facepunch.Nexus.INexusClanEventListener.OnUnload(Int64& modreq(System.Runtime.InteropServices.InAttribute) clanId);
}
[ExtensionAttribute]
public static class NexusClanUtil : object {
    public static string MotdVariable;
    public static string MotdAuthorVariable;
    public static string LogoVariable;
    public static string ColorVariable;
    public static string CanSetLogoVariable;
    public static string CanSetMotdVariable;
    public static string CanSetPlayerNotesVariable;
    public static string PlayerNoteVariable;
    public static List`1<VariableUpdate> DefaultLeaderVariables;
    private static Memoized`2<string, ulong> SteamIdToPlayerId;
    private static NexusClanUtil();
    public static string GetPlayerId(ulong steamId);
    public static string GetPlayerId(Nullable`1<ulong> steamId);
    public static ulong GetSteamId(string playerId);
    public static Nullable`1<ulong> TryGetSteamId(string playerId);
    [ExtensionAttribute]
public static void GetMotd(NexusClan clan, String& motd, Int64& motdTimestamp, UInt64& motdAuthor);
    [ExtensionAttribute]
public static void GetBanner(NexusClan clan, Byte[]& logo, Color32& color);
    [ExtensionAttribute]
public static ClanRole ToClanRole(NexusClanRole role);
    [ExtensionAttribute]
public static ClanMember ToClanMember(NexusClanMember member);
    [ExtensionAttribute]
public static ClanInvite ToClanInvite(ClanInvite invite);
    [ExtensionAttribute]
public static ClanResult ToClanResult(NexusClanResultCode result);
    [ExtensionAttribute]
public static ClanRoleParameters ToRoleParameters(ClanRole role);
    public static VariableUpdate FlagVariable(string key, bool value);
    private static bool ParseFlag(Variable variable, bool defaultValue);
}
public class NexusClanWrapper : object {
    private static int MaxChatScrollback;
    [CompilerGeneratedAttribute]
private string <Motd>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MotdTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MotdAuthor>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Logo>k__BackingField;
    [CompilerGeneratedAttribute]
private Color32 <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMemberCount>k__BackingField;
    public NexusClan Internal;
    private NexusClanChatCollector _chatCollector;
    private List`1<ClanRole> _roles;
    private List`1<ClanMember> _members;
    private List`1<ClanInvite> _invites;
    private List`1<ClanChatEntry> _chatHistory;
    private RealTimeSince _sinceLastRefresh;
    public long ClanId { get; }
    public string Name { get; }
    public long Created { get; }
    public ulong Creator { get; }
    public string Motd { get; private set; }
    public long MotdTimestamp { get; private set; }
    public ulong MotdAuthor { get; private set; }
    public Byte[] Logo { get; private set; }
    public Color32 Color { get; private set; }
    public long Score { get; }
    public IReadOnlyList`1<ClanRole> Roles { get; }
    public IReadOnlyList`1<ClanMember> Members { get; }
    public int MaxMemberCount { get; private set; }
    public IReadOnlyList`1<ClanInvite> Invites { get; }
    public NexusClanWrapper(NexusClan clan, NexusClanChatCollector chatCollector);
    public sealed virtual long get_ClanId();
    public sealed virtual string get_Name();
    public sealed virtual long get_Created();
    public sealed virtual ulong get_Creator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Motd();
    [CompilerGeneratedAttribute]
private void set_Motd(string value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_MotdTimestamp();
    [CompilerGeneratedAttribute]
private void set_MotdTimestamp(long value);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_MotdAuthor();
    [CompilerGeneratedAttribute]
private void set_MotdAuthor(ulong value);
    [CompilerGeneratedAttribute]
public sealed virtual Byte[] get_Logo();
    [CompilerGeneratedAttribute]
private void set_Logo(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Color32 get_Color();
    [CompilerGeneratedAttribute]
private void set_Color(Color32 value);
    public sealed virtual long get_Score();
    public sealed virtual IReadOnlyList`1<ClanRole> get_Roles();
    public sealed virtual IReadOnlyList`1<ClanMember> get_Members();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxMemberCount();
    [CompilerGeneratedAttribute]
private void set_MaxMemberCount(int value);
    public sealed virtual IReadOnlyList`1<ClanInvite> get_Invites();
    public void UpdateValuesInternal();
    [AsyncStateMachineAttribute("NexusClanWrapper/<RefreshIfStale>d__50")]
public sealed virtual ValueTask RefreshIfStale();
    [AsyncStateMachineAttribute("NexusClanWrapper/<GetLogs>d__51")]
public sealed virtual ValueTask`1<ClanValueResult`1<ClanLogs>> GetLogs(int limit, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<UpdateLastSeen>d__52")]
public sealed virtual ValueTask`1<ClanResult> UpdateLastSeen(ulong steamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SetMotd>d__53")]
public sealed virtual ValueTask`1<ClanResult> SetMotd(string newMotd, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SetLogo>d__54")]
public sealed virtual ValueTask`1<ClanResult> SetLogo(Byte[] newLogo, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SetColor>d__55")]
public sealed virtual ValueTask`1<ClanResult> SetColor(Color32 newColor, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<Invite>d__56")]
public sealed virtual ValueTask`1<ClanResult> Invite(ulong steamId, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<CancelInvite>d__57")]
public sealed virtual ValueTask`1<ClanResult> CancelInvite(ulong steamId, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<AcceptInvite>d__58")]
public sealed virtual ValueTask`1<ClanResult> AcceptInvite(ulong steamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<Kick>d__59")]
public sealed virtual ValueTask`1<ClanResult> Kick(ulong steamId, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SetPlayerRole>d__60")]
public sealed virtual ValueTask`1<ClanResult> SetPlayerRole(ulong steamId, int newRoleId, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SetPlayerNotes>d__61")]
public sealed virtual ValueTask`1<ClanResult> SetPlayerNotes(ulong steamId, string notes, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<CreateRole>d__62")]
public sealed virtual ValueTask`1<ClanResult> CreateRole(ClanRole role, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<UpdateRole>d__63")]
public sealed virtual ValueTask`1<ClanResult> UpdateRole(ClanRole role, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<SwapRoleRanks>d__64")]
public sealed virtual ValueTask`1<ClanResult> SwapRoleRanks(int roleIdA, int roleIdB, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<DeleteRole>d__65")]
public sealed virtual ValueTask`1<ClanResult> DeleteRole(int roleId, ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<Disband>d__66")]
public sealed virtual ValueTask`1<ClanResult> Disband(ulong bySteamId);
    [AsyncStateMachineAttribute("NexusClanWrapper/<GetScoreEvents>d__67")]
public sealed virtual ValueTask`1<ClanValueResult`1<ClanScoreEvents>> GetScoreEvents(int limit, ulong bySteamId);
    public sealed virtual ValueTask`1<ClanResult> AddScoreEvent(ClanScoreEvent scoreEvent);
    public sealed virtual ValueTask`1<ClanValueResult`1<ClanChatScrollback>> GetChatScrollback();
    public sealed virtual ValueTask`1<ClanResult> SendChatMessage(string name, string message, ulong bySteamId);
    public void AddScrollback(ClanChatEntry& entry);
    private bool CheckRole(ulong steamId, Func`2<ClanRole, bool> roleTest);
}
public class NexusCleanupOnShutdown : MonoBehaviour {
    public void OnDestroy();
}
public class NexusClient : SingletonComponent`1<NexusClient> {
}
public static class NexusClientUtil : object {
}
public class NexusDB : Database {
    [CompilerGeneratedAttribute]
private int <JournalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <OldestJournal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransferredCount>k__BackingField;
    public int JournalCount { get; private set; }
    public Nullable`1<DateTimeOffset> OldestJournal { get; private set; }
    public int TransferredCount { get; private set; }
    [CompilerGeneratedAttribute]
public int get_JournalCount();
    [CompilerGeneratedAttribute]
private void set_JournalCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_OldestJournal();
    [CompilerGeneratedAttribute]
private void set_OldestJournal(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public int get_TransferredCount();
    [CompilerGeneratedAttribute]
private void set_TransferredCount(int value);
    public void Initialize();
    public bool Seen(Guid id);
    public bool SeenJournaled(Guid id, Byte[] data);
    public List`1<ValueTuple`3<Guid, long, Byte[]>> ReadJournal();
    private static ValueTuple`3<Guid, long, Byte[]> ReadJournalRow(IntPtr stmHandle);
    public void ClearJournal();
    public void MarkTransferred(HashSet`1<NetworkableId> entityIds);
    public List`1<NetworkableId> ReadTransferred();
    public void ClearTransferred();
}
public class NexusDock : SingletonComponent`1<NexusDock> {
    [HeaderAttribute("Targets")]
public Transform FerryWaypoint;
    public Transform[] QueuePoints;
    public Transform Arrival;
    public Transform Docking;
    public Transform Docked;
    public Transform CastingOff;
    public Transform Departure;
    [HeaderAttribute("Ferry")]
public float WaitTime;
    [HeaderAttribute("Ejection")]
public BoxCollider EjectionZone;
    public float TraceHeight;
    public LayerMask TraceLayerMask;
    public NexusFerry[] QueuedFerries;
    public NexusFerry CurrentFerry;
    public Transform GetEntryPoint(NexusFerry ferry, Boolean& entered);
    public bool Depart(NexusFerry ferry);
    public bool TryFindEjectionPosition(Vector3& position, float radius);
    public void CleanupQueuedFerries();
}
public class NexusDockTerminal : BaseEntity {
    public static Phrase ScheduleSoonPhrase;
    public static Phrase ScheduleMinutesPhrase;
    public static Phrase ScheduleUnknownPhrase;
    public float TravelTime;
    public RustText[] ScheduleLabels;
    private List`1<ScheduleEntry> _scheduleEntries;
    private static HashSet`1<string> SeenFerries;
    private static NexusDockTerminal();
    public virtual void InitShared();
    public virtual void AdminKill();
    private void UpdateFerrySchedule();
    private void CalculateFerryEstimates(List`1<ValueTuple`2<string, Nullable`1<float>>> estimates);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    [CompilerGeneratedAttribute]
internal static void <CalculateFerryEstimates>g__NextIdx|10_1(<>c__DisplayClass10_0& );
}
public class NexusEx : Nexus {
    public static HashSet`1<StringView> Empty;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<StringView> <TagsSet>k__BackingField;
    public string Key { get; }
    public HashSet`1<StringView> TagsSet { get; }
    public NexusEx(string endpoint, Nexus nexus);
    private static NexusEx();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public HashSet`1<StringView> get_TagsSet();
}
[ExtensionAttribute]
public static class NexusExtensions : object {
    [ExtensionAttribute]
public static Vector2 Position(ZoneDetails zone);
    [ExtensionAttribute]
public static Vector2 Position(NexusZoneDetails zone);
}
public class NexusFerry : BaseEntity {
    public static Phrase RetiringPhrase;
    [HeaderAttribute("NexusFerry")]
public float TravelVelocity;
    public float ApproachVelocity;
    public float StoppingVelocity;
    public float AccelerationSpeed;
    public float TurnSpeed;
    public float VelocityPreservationOnTurn;
    public float TargetDistanceThreshold;
    public GameObjectRef hornEffect;
    public Transform hornEffectTransform;
    public float departureHornLeadTime;
    [HeaderAttribute("Pathing")]
public SphereCollider SphereCaster;
    public int CastSweepDegrees;
    [RangeAttribute("0", "1")]
public float CastSweepNoise;
    public LayerMask CastLayers;
    public float CastInterval;
    public float CastHitProtection;
    public int PathLookahead;
    public int PathLookaheadThreshold;
    [HeaderAttribute("UI")]
public RustText[] NextZoneLabels;
    private long _timestamp;
    private string _ownerZone;
    private List`1<string> _schedule;
    private int _scheduleIndex;
    private State _state;
    private bool _isRetiring;
    private int _nextScheduleIndex;
    private bool _departureHornPlayed;
    public static ListHashSet`1<NexusFerry> All;
    private List`1<NetworkableId> _transferredIds;
    private NexusDock _targetDock;
    private bool _isTransferring;
    private TimeSince _sinceStartedWaiting;
    private TimeSince _sinceLastTransferAttempt;
    private RealTimeSince _sinceLastNextIndexUpdate;
    private TimeSince _sincePathCalculation;
    private Nullable`1<Vector3> _pathTargetPosition;
    private Nullable`1<Quaternion> _pathTargetRotation;
    private Vector3 _velocity;
    public string OwnerZone { get; }
    public bool IsRetiring { get; }
    public string NextZone { get; }
    protected bool PositionTickFixedTime { get; }
    private static NexusFerry();
    public string get_OwnerZone();
    public bool get_IsRetiring();
    public string get_NextZone();
    public void Initialize(string ownerZone, List`1<string> schedule);
    private void EnsureInitialized();
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public void FixedUpdate();
    public FerryStatus GetStatus();
    public void Retire();
    public void UpdateSchedule(List`1<string> schedule);
    public virtual float GetNetworkTime();
    protected virtual bool get_PositionTickFixedTime();
    private void SwitchToNextState();
    private static State GetNextState(State currentState);
    private static State GetPreviousState(State currentState);
    [AsyncStateMachineAttribute("NexusFerry/<TransferToNextZone>d__56")]
private void TransferToNextZone();
    private Nullable`1<int> TryGetNextScheduleIndex();
    private void EjectInactiveEntities(bool forceAll);
    private void EjectEntity(BaseEntity entity);
    private static bool IsEntityActive(BaseEntity entity);
    private static bool IsPlayerReady(BasePlayer player);
    private void PlayDepartureHornEffect();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public static NexusFerry Get(NetworkableId entityId, long timestamp);
    private bool MoveTowardsTarget();
    private bool MoveTowardsPositionAvoidObstacles(Vector3 targetPosition);
    private bool MoveTowardsTargetTransform();
    private Transform GetTargetTransform(State state);
    private bool MoveTowardsPosition(Vector3 targetPosition, Quaternion targetRotation);
    private bool SphereCast(Vector3 direction, float distance, Single& travelDistance, Vector3& endPosition);
    private Vector3 GetIslandTransferPosition();
    private bool TryFindWaypointsTowards(Vector3 targetPosition, List`1<Vector3> waypoints);
    [CompilerGeneratedAttribute]
private Vector3 <MoveTowardsPositionAvoidObstacles>g__ChooseWaypoint|72_0(Vector3 target);
}
public class NexusFerrySounds : MonoBehaviour {
    [SerializeField]
private NexusFerry ferry;
    [SerializeField]
private float roughHalfWidth;
    [SerializeField]
private float roughHalfLength;
    private float soundCullDistanceSq;
    [SerializeField]
[HeaderAttribute("Engine")]
private SoundDefinition engineLoopDef;
    private Sound engineLoop;
    private Modulator engineGainMod;
    private Modulator enginePitchMod;
    [SerializeField]
private SoundDefinition engineStartDef;
    [SerializeField]
private SoundDefinition engineStopDef;
    [SerializeField]
private AnimationCurve engineGainCurve;
    [SerializeField]
private AnimationCurve enginePitchCurve;
    [SerializeField]
private float engineGainChangeRate;
    [SerializeField]
private float enginePitchChangeRate;
    [SerializeField]
private Transform engineTransform;
    [SerializeField]
[HeaderAttribute("Water")]
private SoundDefinition waterIdleDef;
    [SerializeField]
private SoundDefinition waterSideMovementSlowDef;
    [SerializeField]
private SoundDefinition waterSideMovementFastDef;
    [SerializeField]
private AnimationCurve waterMovementGainCurve;
    [SerializeField]
private float waterMovementGainChangeRate;
    [SerializeField]
private AnimationCurve waterDistanceGainCurve;
    private Sound leftWaterSound;
    private Modulator leftWaterGainMod;
    private Sound rightWaterSound;
    private Modulator rightWaterGainMod;
    [SerializeField]
private Vector3 sideSoundLineStern;
    [SerializeField]
private Vector3 sideSoundLineBow;
    [HeaderAttribute("Dock")]
[SerializeField]
private SoundDefinition dockArrivalSoundDef;
    [SerializeField]
private SoundDefinition dockDepartureSoundDef;
    [SerializeField]
private Transform dockSoundTransform;
    [HeaderAttribute("Ambient")]
private Sound ambientIdleSound;
    [SerializeField]
private SoundDefinition ambientActiveLoopDef;
    private Sound ambientActiveSound;
    private Line leftSoundLine;
    private Line rightSoundLine;
    [HeaderAttribute("Runtime")]
public bool engineOn;
}
public class NexusIsland : BaseEntity {
    public static Flags ServerFullFlag;
    [HeaderAttribute("Nexus Island")]
public Transform BillboardRoot;
    public Transform Billboard;
    public BoxCollider TransferZone;
    public BoxCollider SpawnZone;
    public float TraceHeight;
    public LayerMask TraceLayerMask;
    public Transform FerryWaypoint;
    public GameObjectRef MapMarkerPrefab;
    public Transform MapMarkerLocation;
    public string ZoneKey;
    public static List`1<NexusIsland> All;
    private static NexusIsland();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public sealed virtual bool CanTransfer(BaseEntity entity);
    public sealed virtual ValueTuple`2<string, string> GetTransferDestination();
    public bool TryFindPosition(Vector3& position, float radius);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    [CompilerGeneratedAttribute]
internal static bool <TryFindPosition>g__IsValidPosition|16_0(Vector3 center, float extent);
}
public class NexusRpcResult : object {
    public Dictionary`2<string, Response> Responses;
    public sealed virtual void Dispose();
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
}
public static class NexusServer : object {
    private static bool _isRefreshingCompanion;
    private static RealTimeSince _lastCompanionRefresh;
    private static Memoized`2<string, ulong> SteamIdToString;
    private static MemoryStream WriterStream;
    private static ByteArrayStream ReaderStream;
    private static NexusDB _database;
    [CompilerGeneratedAttribute]
private static NexusZoneClient <ZoneClient>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <FailedToStart>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, List`1<ValueTuple`2<string, FerryStatus>>> FerryEntries;
    private static bool _updatingFerries;
    private static int _cyclesWithoutFerry;
    private static float _zoneContactRadius;
    private static Dictionary`2<string, NexusIsland> _existingIslands;
    private static int MapRenderVersion;
    private static HashSet`1<ulong> PlayerManifest;
    private static Dictionary`2<string, ZonePlayerManifest> ZonePlayerManifests;
    private static RealTimeSince _lastPlayerManifestBroadcast;
    private static bool _playerManifestDirty;
    private static RealTimeSince _lastPlayerManifestRebuild;
    private static Dictionary`2<Uuid, PendingCall> PendingCalls;
    private static RealTimeSince _sinceLastRpcTimeoutCheck;
    private static Dictionary`2<string, ServerStatus> ZoneStatuses;
    private static bool _isRefreshingZoneStatus;
    private static RealTimeSince _lastZoneStatusRefresh;
    private static Nullable`1<DateTimeOffset> _lastUnsavedTransfer;
    private static string CopyFromKey;
    public static NexusZoneClient ZoneClient { get; private set; }
    public static bool Started { get; private set; }
    public static bool FailedToStart { get; private set; }
    public static Nullable`1<int> NexusId { get; }
    public static string ZoneKey { get; }
    public static Nullable`1<long> LastReset { get; }
    public static List`1<NexusZoneDetails> Zones { get; }
    public static bool NeedsJournalFlush { get; }
    private static int RpcResponseTtl { get; }
    public static bool NeedTransferFlush { get; }
    private static NexusServer();
    private static void RefreshCompanionVariables();
    [CompilerGeneratedAttribute]
public static NexusZoneClient get_ZoneClient();
    [CompilerGeneratedAttribute]
private static void set_ZoneClient(NexusZoneClient value);
    [CompilerGeneratedAttribute]
public static bool get_Started();
    [CompilerGeneratedAttribute]
private static void set_Started(bool value);
    [CompilerGeneratedAttribute]
public static bool get_FailedToStart();
    [CompilerGeneratedAttribute]
private static void set_FailedToStart(bool value);
    public static Nullable`1<int> get_NexusId();
    public static string get_ZoneKey();
    public static Nullable`1<long> get_LastReset();
    public static List`1<NexusZoneDetails> get_Zones();
    [IteratorStateMachineAttribute("NexusServer/<Initialize>d__27")]
public static IEnumerator Initialize();
    public static void Shutdown();
    public static void Update();
    public static NexusZoneDetails FindZone(string zoneKey);
    public static Task`1<NexusLoginResult> Login(ulong steamId);
    public static void Logout(ulong steamId);
    public static bool TryGetPlayer(ulong steamId, NexusPlayer& player);
    public static Task AssignInitialZone(ulong steamId, string zoneKey);
    private static ZoneController BuildZoneController(string name);
    public static void PostGameSaved();
    [AsyncStateMachineAttribute("NexusServer/<UpdateFerries>d__40")]
public static void UpdateFerries();
    [AsyncStateMachineAttribute("NexusServer/<UpdateFerriesImpl>d__41")]
private static Task UpdateFerriesImpl();
    public static bool TryGetFerryStatus(string ownerZone, String& currentZone, FerryStatus& status);
    private static Task RetireFerry(string zone, NetworkableId entityId, long timestamp);
    private static Task UpdateFerrySchedule(string zone, NetworkableId entityId, long timestamp, List`1<string> schedule);
    private static bool TryParseFerrySchedule(string zone, string scheduleString, List`1& entries);
    private static void UpdateFerryStatuses(NexusRpcResult statusResponse);
    public static void UpdateIslands();
    public static bool TryGetIsland(string zoneKey, NexusIsland& island);
    public static bool TryGetIslandPosition(string zoneKey, Vector3& position);
    private static ValueTuple`2<Vector3, Quaternion> CalculateIslandTransform(NexusZoneDetails otherZone);
    public static Bounds GetWorldBounds();
    private static bool IsCloseTo(NexusZoneDetails otherZone);
    public static bool get_NeedsJournalFlush();
    private static void ReadIncomingMessages();
    public static void RestoreUnsavedState();
    private static void ReplayJournaledMessages();
    private static void DeleteTransferredEntities();
    private static bool RequiresJournaling(Packet packet);
    [AsyncStateMachineAttribute("NexusServer/<UploadMapImage>d__63")]
public static void UploadMapImage(bool force);
    private static void HandleMessage(Uuid id, Packet packet);
    private static Packet ReadPacket(Byte[] data);
    private static Task SendRequestImpl(Uuid id, Request request, string toZoneKey, Nullable`1<int> ttl);
    [AsyncStateMachineAttribute("NexusServer/<SendResponseImpl>d__67")]
private static void SendResponseImpl(Response response, string toZoneKey, Nullable`1<int> ttl);
    private static Task SendPacket(Uuid id, Packet packet, string toZoneKey, Nullable`1<int> ttl);
    public static bool IsOnline(ulong userId);
    public static void AddZonePlayerManifest(string zoneKey, List`1<ulong> userIds);
    private static void UpdatePlayerManifest();
    [AsyncStateMachineAttribute("NexusServer/<BroadcastPlayerManifest>d__78")]
private static void BroadcastPlayerManifest();
    private static void RebuildPlayerManifestIfDirty();
    private static void RemoveInvalidPlayerManifests();
    private static int get_RpcResponseTtl();
    [AsyncStateMachineAttribute("NexusServer/<ZoneRpc>d__86")]
public static Task`1<Response> ZoneRpc(string zone, Request request, float timeoutAfter);
    public static Task`1<NexusRpcResult> BroadcastRpc(Request request, float timeoutAfter);
    [AsyncStateMachineAttribute("NexusServer/<CallRpcImpl>d__88")]
private static Task`1<NexusRpcResult> CallRpcImpl(string zone, Request request, float timeoutAfter, bool throwOnTimeout);
    private static void HandleRpcInvocation(NexusZoneDetails from, Uuid id, Request request);
    private static Response HandleRpcInvocationImpl(NexusZoneDetails from, Uuid id, Request request);
    private static bool Handle(TProto proto, NexusZoneDetails from, Uuid id, Request request, Response& response);
    private static void HandleRpcResponse(NexusZoneDetails from, Uuid id, Response response);
    private static void CheckForRpcTimeouts();
    private static void RefreshZoneStatus();
    public static bool TryGetZoneStatus(string zone, ServerStatus& status);
    private static void OnZoneStatusesRefreshed();
    public static bool get_NeedTransferFlush();
    [AsyncStateMachineAttribute("NexusServer/<TransferEntity>d__103")]
public static Task TransferEntity(BaseEntity entity, string toZoneKey, string method, bool includeFerry);
    [AsyncStateMachineAttribute("NexusServer/<TransferEntityImpl>d__104")]
public static Task TransferEntityImpl(BaseEntity rootEntity, string toZoneKey, string method, string from, string to);
    private static void UnparentUnknown(BaseEntity entity, HashSet`1<NetworkableId> knownEntityIds);
    public static void BuildTransferRequest(BaseEntity rootEntity, string method, string from, string to, Request& request, List`1& networkables, List`1& players, List`1& playerIds);
    private static bool CanTransferEntity(BaseNetworkable networkable);
    public static BaseEntity FindRootEntity(BaseEntity startEntity, bool includeFerry);
    private static string GetWorldConfigString();
    private static JObject GetWorldConfigImpl(string zoneKey, List`1<string> stack);
    private static bool TryGetWorldConfigObject(string zoneKey, bool required, JObject& cfg, String& error);
    private static JObject MergeInto(JObject baseObject, JObject sourceObject);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("NexusServer/<<RefreshCompanionVariables>g__RefreshCompanionVariablesImpl|2_0>d")]
internal static void <RefreshCompanionVariables>g__RefreshCompanionVariablesImpl|2_0();
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__RunConsoleConfig|27_2(Variable cfgVariable);
    [CompilerGeneratedAttribute]
internal static void <UpdateFerryStatuses>g__AddFerryStatus|46_0(string currentZone, FerryStatus status);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("NexusServer/<<RefreshZoneStatus>g__RefreshZoneStatusImpl|97_0>d")]
internal static void <RefreshZoneStatus>g__RefreshZoneStatusImpl|97_0();
    [CompilerGeneratedAttribute]
internal static bool <FindRootEntity>g__TryGetParent|108_0(BaseEntity entity, BaseEntity& parent);
}
public class NexusServerLogger : object {
    [CompilerGeneratedAttribute]
private static NexusServerLogger <Instance>k__BackingField;
    public static NexusServerLogger Instance { get; }
    private static NexusServerLogger();
    [CompilerGeneratedAttribute]
public static NexusServerLogger get_Instance();
    public sealed virtual void Log(NexusLogLevel level, string message, Exception exception);
}
public class NexusTransferTrigger : BaseMonoBehaviour {
    [TooltipAttribute("Must implement INexusTransferTriggerController!")]
public MonoBehaviour Controller;
    private static HashSet`1<BaseEntity> PendingEntities;
    private INexusTransferTriggerController _controller;
    private static NexusTransferTrigger();
    protected void Start();
    protected void OnTriggerEnter(Collider other);
}
[ExtensionAttribute]
public static class NexusUtil : object {
    private static Char[] ScheduleSeparators;
    private static NexusUtil();
    public static bool TryParseFerrySchedule(string zone, string scheduleString, String[]& entries);
    [ExtensionAttribute]
public static string ConnectionProtocol(NexusZoneDetails zone);
    [ExtensionAttribute]
public static bool IsStarterZone(ZoneDetails zone);
    [ExtensionAttribute]
public static bool IsStarterZone(NexusZoneDetails zone);
    [ExtensionAttribute]
private static bool IsStarterZone(VariableDictionary variables);
    [ExtensionAttribute]
public static bool TryGetString(VariableDictionary variables, string key, String& value);
}
public static class NexusVariables : object {
    public static string Blueprints;
    private static NexusVariables();
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Light")]
public class NGSS_Directional : MonoBehaviour {
    [RangeAttribute("0", "0,02")]
[TooltipAttribute("Overall softness for both PCF and PCSS shadows.
Recommended value: 0.01.")]
public float PCSS_GLOBAL_SOFTNESS;
    [RangeAttribute("0", "1")]
[TooltipAttribute("PCSS softness when shadows is close to caster.
Recommended value: 0.05.")]
public float PCSS_FILTER_DIR_MIN;
    [TooltipAttribute("PCSS softness when shadows is far from caster.
Recommended value: 0.25.
If too high can lead to visible artifacts when early bailout is enabled.")]
[RangeAttribute("0", "0,5")]
public float PCSS_FILTER_DIR_MAX;
    [TooltipAttribute("Amount of banding or noise. Example: 0.0 gives 100 % Banding and 10.0 gives 100 % Noise.")]
[RangeAttribute("0", "10")]
public float BANDING_NOISE_AMOUNT;
    [TooltipAttribute("Recommended values: Mobile = 16, Consoles = 25, Desktop Low = 32, Desktop High = 64")]
public SAMPLER_COUNT SAMPLERS_COUNT;
    private void Update();
    private void SetGlobalSettings(bool enabled);
}
[PostProcessAttribute("NightLightEffectRenderer", "1", "Custom/NightLight", "True")]
public class NightLightEffect : PostProcessEffectSettings {
    [RangeAttribute("0", "25")]
public FloatParameter distance;
    [RangeAttribute("0", "1")]
public FloatParameter fadeFraction;
    [RangeAttribute("0", "1")]
public FloatParameter brightness;
}
public class NightLightEffectRenderer : PostProcessEffectRenderer`1<NightLightEffect> {
    private int distanceProperty;
    private int fadeFractionProperty;
    private int brightnessProperty;
    private Shader nightlightShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class NightLightOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
public static class Noise : object {
    public static float MIN;
    public static float MAX;
    public static float SimplexSigned(float x);
    public static float SimplexSigned(float x, float y);
    public static float SimplexUnsigned(float x);
    public static float SimplexUnsigned(float x, float y);
    public static float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);
    public static float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);
    public static float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}
public class NoiseParameters : ValueType {
    public int Octaves;
    public float Frequency;
    public float Amplitude;
    public float Offset;
    public NoiseParameters(int octaves, float frequency, float amplitude, float offset);
}
public class NonDrawingGraphic : Graphic {
    public virtual void SetMaterialDirty();
    public virtual void SetVerticesDirty();
    protected virtual void OnPopulateMesh(VertexHelper vh);
}
public class NoPlayersIOReset : FacepunchBehaviour {
    [SerializeField]
private IOEntity[] entitiesToReset;
    [SerializeField]
private float radius;
    [SerializeField]
private float timeBetweenChecks;
    protected void OnEnable();
    protected void OnDisable();
    private void Check();
    private void Reset();
}
public class NoRespawnIcon : FacepunchBehaviour {
    [SerializeField]
private CanvasGroup noRespawnWarning;
    [SerializeField]
private GameObject noRespawnWarningGO;
}
[Factory("note")]
public class note : ConsoleSystem {
    [ServerUserVar]
public static void update(Arg arg);
}
[CreateAssetMenuAttribute]
public class NoteBindingCollection : ScriptableObject {
    public NoteData[] BaseBindings;
    public float MinimumNoteTime;
    public float MaximumNoteLength;
    public bool AllowAutoplay;
    public float AutoplayLoopDelay;
    public string NotePlayedStatName;
    public string KeyMidiMapShortname;
    public bool AllowSustain;
    public bool AllowFullKeyboardInput;
    public string InstrumentShortName;
    public InstrumentType NotePlayType;
    public int MaxConcurrentNotes;
    public bool LoopSounds;
    public float SoundFadeInTime;
    public float minimumSoundFadeOutTime;
    public KeySet PrimaryClickNote;
    public KeySet SecondaryClickNote;
    public bool RunInstrumentAnimationController;
    public bool PlayRepeatAnimations;
    public float AnimationDeadTime;
    public float AnimationResetDelay;
    public float RecentlyPlayedThreshold;
    [RangeAttribute("0", "1")]
public float CrossfadeNormalizedAnimationTarget;
    public float AnimationCrossfadeDuration;
    public float CrossfadePlayerSpeedMulti;
    public int DefaultOctave;
    public int ShiftedOctave;
    public bool UseClosestMidiNote;
    private static float MidiNoteUpOctaveShift;
    private static float MidiNoteDownOctaveShift;
    public bool FindNoteData(Notes note, int octave, NoteType type, NoteData& data, Int32& noteIndex);
    public bool FindNoteDataIndex(Notes note, int octave, NoteType type, Int32& noteIndex);
    public NoteData CreateMidiBinding(NoteData basedOn, int octave, int midiCode);
}
public class NotePanel : MonoBehaviour {
    public InputField input;
    private Item item;
}
public class NoticeArea : SingletonComponent`1<NoticeArea> {
    public GameObjectRef itemPickupPrefab;
    public GameObjectRef itemPickupCondensedText;
    public GameObjectRef itemDroppedPrefab;
    public AnimationCurve pickupSizeCurve;
    public AnimationCurve pickupAlphaCurve;
    public AnimationCurve reuseAlphaCurve;
    public AnimationCurve reuseSizeCurve;
    private IVitalNotice[] notices;
    protected virtual void Awake();
}
public class NotifyLOD : LODComponent {
    public float Distance;
    public float MinDistanceMultiplier;
    public GameObject TargetGameObject;
}
public class NPCAutoTurret : AutoTurret {
    public Transform centerMuzzle;
    public Transform muzzleLeft;
    public Transform muzzleRight;
    public bool useSleeperHostile;
    private bool useLeftMuzzle;
    [ReplicatedVar]
public static float sleeperhostiledelay;
    private static NPCAutoTurret();
    public virtual void ServerInit();
    public virtual bool HasAmmo();
    public virtual bool CheckPeekers();
    public virtual float TargetScanRate();
    public virtual bool InFiringArc(BaseCombatEntity potentialtarget);
    public virtual float GetMaxAngleForEngagement();
    public virtual bool HasFallbackWeapon();
    public virtual Transform GetCenterMuzzle();
    public virtual void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse, BaseCombatEntity target);
    public virtual bool Ignore(BasePlayer player);
    public virtual bool IsEntityHostile(BaseCombatEntity ent);
}
public class NPCBarricadeTriggerBox : MonoBehaviour {
    private Barricade target;
    private static int playerServerLayer;
    private static NPCBarricadeTriggerBox();
    public void Setup(Barricade t);
    private void OnTriggerEnter(Collider other);
}
public class NPCDoorTriggerBox : MonoBehaviour {
    private Door door;
    private static int playerServerLayer;
    private static NPCDoorTriggerBox();
    public void Setup(Door d);
    private void OnTriggerEnter(Collider other);
}
public class NPCDwelling : BaseEntity {
    public NPCSpawner npcSpawner;
    public float NPCSpawnChance;
    public SpawnGroup[] spawnGroups;
    public AIMovePoint[] movePoints;
    public AICoverPoint[] coverPoints;
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public bool ValidateAIPoint(Vector3 pos);
    public void UpdateInformationZone(bool remove);
    public void CheckDespawn();
    public void CleanupSpawned();
    public bool PlayersNearby();
    public virtual float TimeoutPlayerCheckRadius();
}
public class NPCFootstepEffects : BaseFootstepEffect {
    public string impactEffectDirectory;
    public Transform frontLeftFoot;
    public Transform frontRightFoot;
    public Transform backLeftFoot;
    public Transform backRightFoot;
}
public class NPCMissionProvider : NPCTalking {
    public MissionManifest manifest;
    public GameObjectRef MarkerPrefab;
    public sealed virtual NetworkableId ProviderID();
    public sealed virtual Vector3 ProviderPosition();
    public sealed virtual BaseEntity Entity();
    public virtual void ServerInit();
    private string GetProviderToken();
    public virtual void OnConversationEnded(BasePlayer player);
    public virtual void OnConversationStarted(BasePlayer speakingTo);
    public bool ContainsSpeech(string speech);
    public string IntroOverride(string overrideSpeech);
    public virtual string GetConversationStartSpeech(BasePlayer player);
    public virtual void OnConversationAction(BasePlayer player, string action);
}
public class NPCNavigator : BaseNavigator {
    public int DestroyOnFailedSampleCount;
    [CompilerGeneratedAttribute]
private BaseNpc <NPC>k__BackingField;
    private int sampleFailCount;
    public BaseNpc NPC { get; private set; }
    [CompilerGeneratedAttribute]
public BaseNpc get_NPC();
    [CompilerGeneratedAttribute]
private void set_NPC(BaseNpc value);
    public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent);
    public virtual void OnFailedToPlaceOnNavmesh();
    public virtual void OnPlacedOnNavmesh();
    protected virtual bool CanEnableNavMeshNavigation();
    protected virtual bool CanUpdateMovement();
    protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta);
    private void UpdateRotation(Vector3 moveToPosition, float delta);
    public virtual void ApplyFacingDirectionOverride();
    public virtual bool IsSwimming();
}
public class NPCPlayer : BasePlayer {
    public float MovementTickStartDelay;
    public AIInformationZone VirtualInfoZone;
    public Vector3 finalDestination;
    private float randomOffset;
    public Vector3 spawnPos;
    public PlayerInventoryProperties[] loadouts;
    public LayerMask movementMask;
    public bool LegacyNavigation;
    public NavMeshAgent NavAgent;
    public float damageScale;
    public float shortRange;
    public float attackLengthMaxShortRangeScale;
    private bool _isDormant;
    private string loadoutname;
    public float lastGunShotTime;
    public float triggerEndTime;
    public float nextTriggerTime;
    private float lastThinkTime;
    private float lastPositionUpdateTime;
    private float lastMovementTickTime;
    public Vector3 lastPos;
    private float lastThrowTime;
    public bool IsNpc { get; }
    public bool IsDormant { get; public set; }
    protected float PositionTickRate { get; }
    public bool IsOnNavMeshLink { get; }
    public bool HasPath { get; }
    protected string CorpsePath { get; }
    protected bool ShouldCorpseTakeChildren { get; }
    protected bool KeepCorpseClothingIntact { get; }
    protected string OverrideCorpseName { get; }
    protected bool CopyInventoryToCorpse { get; }
    public virtual bool get_IsNpc();
    public virtual bool get_IsDormant();
    public virtual void set_IsDormant(bool value);
    protected virtual float get_PositionTickRate();
    public virtual bool IsLoadBalanced();
    public virtual void ServerInit();
    public string GetLoadoutName();
    public void EquipLoadout(PlayerInventoryProperties[] loads);
    public virtual void ApplyInheritedVelocity(Vector3 velocity);
    public void RandomMove();
    public virtual void SetDestination(Vector3 newDestination);
    public AttackEntity GetAttackEntity();
    public BaseProjectile GetGun();
    public virtual float AmmoFractionRemaining();
    public virtual bool IsReloading();
    public virtual void AttemptReload();
    public virtual bool ShotTest(float targetDist);
    public virtual float GetAimConeScale();
    public void CancelBurst(float delay);
    public bool MeleeAttack();
    public virtual void TriggerDown();
    public virtual void EquipWeapon(bool skipDeployDelay);
    public void EquipTest();
    internal void ServerThink_Internal();
    public virtual void ServerThink(float delta);
    public virtual void Resume();
    public virtual bool IsNavRunning();
    public virtual bool get_IsOnNavMeshLink();
    public virtual bool get_HasPath();
    public virtual void TickAi(float delta);
    public void TickMovement();
    public virtual float GetNetworkTime();
    public virtual void MovementUpdate(float delta);
    private bool ValidateNextPosition(Vector3& moveToPosition);
    private void UpdateSpeed(float delta);
    protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition);
    public Vector3 GetPosition();
    public virtual float DesiredMoveSpeed();
    public virtual bool EligibleForWounding(HitInfo info);
    public virtual Vector3 GetAimDirection();
    public virtual void SetAimDirection(Vector3 newAim);
    public bool TryUseThrownWeapon(BaseEntity target, float attackRate);
    public bool TryUseThrownWeapon(Item item, BaseEntity target, float attackRate);
    public bool HasThrownItemCooldown();
    protected bool UseThrownWeapon(Item item, BaseEntity target);
    [IteratorStateMachineAttribute("NPCPlayer/<DoThrow>d__72")]
private IEnumerator DoThrow(ThrownWeapon thrownWeapon, BaseEntity target);
    public Item FindThrownWeapon();
    protected virtual string get_CorpsePath();
    protected virtual bool get_ShouldCorpseTakeChildren();
    protected virtual bool get_KeepCorpseClothingIntact();
    protected virtual string get_OverrideCorpseName();
    protected virtual bool get_CopyInventoryToCorpse();
    public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List`1<TriggerBase> triggersOnDeath, bool forceServerSide);
    protected virtual void ApplyLoot(NPCPlayerCorpse corpse);
}
public class NPCPlayerCorpse : PlayerCorpse {
    private bool lootEnabled;
    public virtual float GetRemovalTime();
    public virtual bool CanLoot();
    public void SetLootableIn(float when);
    public void EnableLooting();
    protected virtual bool CanLootContainer(ItemContainer c, int index);
    protected virtual void PreDropItems();
}
public class NPCPlayerNavigator : BaseNavigator {
    [CompilerGeneratedAttribute]
private NPCPlayer <NPCPlayerEntity>k__BackingField;
    public NPCPlayer NPCPlayerEntity { get; private set; }
    [CompilerGeneratedAttribute]
public NPCPlayer get_NPCPlayerEntity();
    [CompilerGeneratedAttribute]
private void set_NPCPlayerEntity(NPCPlayer value);
    public virtual void Init(BaseCombatEntity entity, NavMeshAgent agent);
    protected virtual bool CanEnableNavMeshNavigation();
    protected virtual bool CanUpdateMovement();
    protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition, float delta);
    public virtual void ApplyFacingDirectionOverride();
    private static Vector3 GetAimDirection(BasePlayer aimingPlayer, BaseEntity target);
    private static Vector3 TargetAimPositionOffset(BaseEntity target);
}
public class NPCPlayerNavigatorTester : BaseMonoBehaviour {
    public BasePathNode TargetNode;
    private BasePathNode currentNode;
    private void Update();
}
public class NPCShopKeeper : NPCPlayer {
    public EntityRef invisibleVendingMachineRef;
    public InvisibleVendingMachine machine;
    public float greetDir;
    public Vector3 initialFacingDir;
    public BasePlayer lastWavedAtPlayer;
    protected string OverrideCorpseName { get; }
    public InvisibleVendingMachine GetVendingMachine();
    public virtual void UpdateProtectionFromClothing();
    public virtual void OnKilled(HitInfo info);
    protected virtual string get_OverrideCorpseName();
    public virtual void ServerInit();
    public virtual void PostInitShared();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public void DelayedSleepEnd();
    public virtual void GreetPlayer(BasePlayer player);
    public virtual void Greeting();
}
public class NPCSpawner : SpawnGroup {
    public int AdditionalLOSBlockingLayer;
    public MonumentNavMesh monumentNavMesh;
    public bool shouldFillOnSpawn;
    [HeaderAttribute("InfoZone Config")]
public AIInformationZone VirtualInfoZone;
    [HeaderAttribute("Navigator Config")]
public AIMovePointPath Path;
    public BasePath AStarGraph;
    [HeaderAttribute("Human Stat Replacements")]
public bool UseStatModifiers;
    public float SenseRange;
    public bool CheckLOS;
    public float TargetLostRange;
    public float AttackRangeMultiplier;
    public float ListenRange;
    public float CanUseHealingItemsChance;
    [HeaderAttribute("Loadout Replacements")]
public PlayerInventoryProperties[] Loadouts;
    public virtual void SpawnInitial();
    public bool WaitingForNavMesh();
    public void LateSpawn();
    protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint);
    private void ModifyHumanBrainStats(BaseAIBrain brain);
}
public class NPCTalking : NPCShopKeeper {
    public ConversationData[] conversations;
    public NPCConversationResultAction[] conversationResultActions;
    public float maxConversationDistance;
    public List`1<BasePlayer> conversingPlayers;
    public BasePlayer lastActionPlayer;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int GetConversationIndex(string conversationName);
    public virtual string GetConversationStartSpeech(BasePlayer player);
    public ConversationData GetConversation(string conversationName);
    public ConversationData GetConversation(int index);
    public virtual ConversationData GetConversationFor(BasePlayer player);
    public sealed virtual bool ProviderBusy();
    public void ForceEndConversation(BasePlayer player);
    public void ForceSpeechNode(BasePlayer player, int speechNodeIndex);
    public virtual void OnConversationEnded(BasePlayer player);
    public void CleanupConversingPlayers();
    [CallsPerSecond("1")]
[MaxDistance("3")]
[RPC_Server]
public void Server_BeginTalking(RPCMessage msg);
    protected virtual bool CanTalkTo(BasePlayer bp);
    public void Server_BeginTalking(BasePlayer ply);
    public virtual void OnConversationStarted(BasePlayer speakingTo);
    public virtual void UpdateFlags();
    [CallsPerSecond("1")]
[MaxDistance("3")]
[RPC_Server]
public void Server_EndTalking(RPCMessage msg);
    [MaxDistance("3")]
[CallsPerSecond("5")]
[RPC_Server]
public void ConversationAction(RPCMessage msg);
    public bool ValidConversationPlayer(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
[CallsPerSecond("5")]
public void Server_ResponsePressed(RPCMessage msg);
    public BasePlayer GetActionPlayer();
    public virtual void OnConversationAction(BasePlayer player, string action);
}
public class NPCVendingMachine : VendingMachine {
    public NPCVendingOrder vendingOrders;
    public Phrase Phrase;
    public float RefillTime;
    public int StartingStock;
    public bool BypassDynamicPricing;
    public static int MaxVendingEntries;
    private static ListHashSet`1<NPCVendingMachine> allNpcVendingMachines;
    private Single[] refillTimes;
    [ServerVar]
public static bool DynamicPricingEnabled;
    [ServerVar]
public static float PriceUpdateFrequencyDefault;
    [ServerVar]
public static float PriceUpdateFrequencyBiWeekly;
    [ServerVar]
public static float PriceUpdateFrequencyWeekly;
    private static bool hasCachedTags;
    private static bool cachedBiWeekly;
    private static bool cachedWeekly;
    [ServerVar]
public static float MaximumPriceMultiplier;
    [ServerVar]
public static float MinimumPriceMultiplier;
    [ServerVar]
public static float StartingPriceMultiplier;
    [ServerVar]
public static float PriceIncreaseAmount;
    [ServerVar]
public static float PriceDecreaseAmount;
    private SalesData[] allSalesData;
    private float timeToNextSalesUpdate;
    private bool preserveSalesData;
    private static ItemDefinition _scrapItem;
    private TimeSince lastHourCheck;
    protected bool BlockOrderRefreshOnLoad { get; }
    private static float ScaledByWipeUpdateFrequency { get; }
    public static float IntervalSeconds { get; }
    public static ItemDefinition ScrapItem { get; }
    private bool CanApplyDynamicPricing { get; }
    private static NPCVendingMachine();
    public byte GetBPState(bool sellItemAsBP, bool currencyItemAsBP);
    public virtual void TakeCurrencyItem(Item takenCurrencyItem);
    public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer);
    public virtual void PostServerLoad();
    public void ChangeRefillTime(float newRefillTime);
    public virtual void ServerInit();
    protected virtual bool get_BlockOrderRefreshOnLoad();
    internal virtual void DoServerDestroy();
    public virtual void InstallFromVendingOrders();
    private void SmartAddItemForSale(Entry ent);
    public virtual void InstallDefaultSellOrders();
    public void Refill();
    public void ClearSellOrders();
    public void AddItemForSale(int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState);
    public void RefreshStock();
    protected virtual void RecordSaleAnalytics(Item itemSold, int orderId);
    public virtual string GetTranslationToken();
    protected virtual bool CanRotate();
    public virtual bool CanPlayerAdmin(BasePlayer player);
    private static float get_ScaledByWipeUpdateFrequency();
    [ServerVar]
public static void ResetFrequencyTags(Arg arg);
    public static float get_IntervalSeconds();
    [ServerVar]
public static void resetDynamicPricing();
    [ServerVar]
public static void printAllPriceChanges(Arg arg);
    [ServerVar]
public static void addHours(Arg arg);
    public void RecordSale(int index, int count);
    private void CheckSalesDataLength(bool reset);
    public static ItemDefinition get_ScrapItem();
    protected virtual float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder);
    private bool get_CanApplyDynamicPricing();
    private void DynamicPricingServerInit();
    private void ResetDynamicPricing();
    private void HourCheck();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
[CreateAssetMenuAttribute]
public class NPCVendingOrder : ScriptableObject {
    public Entry[] orders;
    public void GetRandomEntries(int count, List`1<Entry> selectedEntries);
}
[CreateAssetMenuAttribute]
public class NPCVendingOrderManifest : ScriptableObject {
    public NPCVendingOrder[] orderList;
    public int GetIndex(NPCVendingOrder sample);
    public NPCVendingOrder GetFromIndex(int index);
}
public class NpcWalkAnimation : MonoBehaviour {
    public Vector3 HipFudge;
    public BaseNpc Npc;
    public Animator Animator;
    public Transform HipBone;
    public Transform LookBone;
    public bool UpdateWalkSpeed;
    public bool UpdateFacingDirection;
    public bool UpdateGroundNormal;
    public Transform alignmentRoot;
    public bool LaggyAss;
    public bool LookAtTarget;
    public float MaxLaggyAssRotation;
    public float MaxWalkAnimSpeed;
    public bool UseDirectionBlending;
    public bool useTurnPosing;
    public float turnPoseScale;
    public float laggyAssLerpScale;
    public bool skeletonChainInverted;
}
public class NVGCamera : FacepunchBehaviour {
    public static NVGCamera instance;
    public PostProcessVolume postProcessVolume;
    public GameObject lights;
}
public class NVGColorCorrection : ColorCorrectionCurves {
}
[AddComponentMenu("Image Effects/NVG Effect")]
[ExecuteInEditMode]
public class NVGEffect : PostEffectsBase {
    public ColorCorrectionParams ColorCorrection1;
    public ColorCorrectionParams ColorCorrection2;
    public NoiseAndGrainParams NoiseAndGrain;
    private Texture2D rgbChannelTex1;
    private Texture2D rgbChannelTex2;
    private bool updateTexturesOnStartup;
    public Texture2D NoiseTexture;
    private static float NOISE_TILE_AMOUNT;
    public Shader Shader;
    private Material material;
    private static NVGEffect();
    private void Awake();
    private void OnDestroy();
    private void UpdateColorCorrectionTexture(ColorCorrectionParams param, Texture2D& tex);
    public void UpdateTextures();
    public virtual bool CheckResources();
    public sealed virtual bool IsActive();
    public sealed virtual void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class NVGToggle : ItemEventFlag {
}
public class NVidiaReflex : MonoBehaviour {
}
public class OBBComponent : MonoBehaviour {
    public Bounds Bounds;
    public OBB GetObb();
}
[ExtensionAttribute]
public static class ObjectEx : object {
    [ExtensionAttribute]
public static bool IsUnityNull(T obj);
}
public class ObjectFlasher : BaseMonoBehaviour {
    public GameObject enabledObj;
    public GameObject disabledObj;
    public float toggleLength;
    public float timeOffset;
    public float randomOffset;
}
public class ObjectMotionVectorFix : MonoBehaviour {
}
public class ObjectRotation : MonoBehaviour {
    public Camera cam;
    public bool ignoreNeedsKeyboard;
    public Transform panTransform;
}
public class ObjectSpam : MonoBehaviour {
    public GameObject source;
    public int amount;
    public float radius;
    private void Start();
}
public static class ObjWriter : object {
    public static string MeshToString(Mesh mesh);
    public static void Write(Mesh mesh, string path);
}
public class Occludee : MonoBehaviour {
    public float minTimeVisible;
    public bool isStatic;
    public bool autoRegister;
    public bool stickyGizmos;
    public OccludeeState state;
    protected int occludeeId;
    protected Vector3 center;
    protected float radius;
    protected Renderer renderer;
    protected Collider collider;
    protected virtual void Awake();
    public void OnEnable();
    public void OnDisable();
    public void Register();
    public void Unregister();
    protected virtual void OnVisibilityChanged(bool visible);
}
public class OccludeeSphere : ValueType {
    public int id;
    public OccludeeState state;
    public Sphere sphere;
    public bool IsRegistered { get; }
    public OccludeeSphere(int id);
    public OccludeeSphere(int id, Sphere sphere);
    public bool get_IsRegistered();
    public void Invalidate();
}
public class OccludeeState : SmartListValue {
    public int slot;
    public bool isStatic;
    public int layer;
    public OnVisibilityChanged onVisibilityChanged;
    public Cell cell;
    public SimpleList`1<State> states;
    public bool isVisible { get; }
    public bool get_isVisible();
    public OccludeeState Initialize(SimpleList`1<State> states, BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged);
    public void Invalidate();
    public void MakeVisible();
}
public class OcclusionCPUTest : object {
}
[RequireComponent("UnityEngine.Camera")]
[RequireComponent("UnityEngine.Camera")]
public class OcclusionCulling : MonoBehaviour {
    public ComputeShader computeShader;
    public bool usePixelShaderFallback;
    public bool useAsyncReadAPI;
    private Camera camera;
    private static int ComputeThreadsPerGroup;
    private static int InputBufferStride;
    private static int ResultBufferStride;
    private static int OccludeeMaxSlotsPerPool;
    private static int OccludeePoolGranularity;
    private static int StateBufferGranularity;
    private static int GridBufferGranularity;
    private static Queue`1<OccludeeState> statePool;
    private static SimpleList`1<OccludeeState> staticOccludees;
    private static SimpleList`1<State> staticStates;
    private static SimpleList`1<int> staticVisibilityChanged;
    private static SimpleList`1<OccludeeState> dynamicOccludees;
    private static SimpleList`1<State> dynamicStates;
    private static SimpleList`1<int> dynamicVisibilityChanged;
    private static List`1<int> staticChanged;
    private static Queue`1<int> staticRecycled;
    private static List`1<int> dynamicChanged;
    private static Queue`1<int> dynamicRecycled;
    private static BufferSet staticSet;
    private static BufferSet dynamicSet;
    private static BufferSet gridSet;
    private Vector4[] frustumPlanes;
    private String[] frustumPropNames;
    private Single[] matrixToFloatTemp;
    private Material fallbackMat;
    private Material depthCopyMat;
    private Matrix4x4 viewMatrix;
    private Matrix4x4 projMatrix;
    private Matrix4x4 viewProjMatrix;
    private Matrix4x4 prevViewProjMatrix;
    private Matrix4x4 invViewProjMatrix;
    private bool useNativePath;
    private static OcclusionCulling instance;
    public static bool Passthrough;
    private static GraphicsDeviceType[] supportedDeviceTypes;
    private static bool _enabled;
    private static bool _safeMode;
    private static DebugFilter _debugShow;
    public DebugSettings debugSettings;
    private Material debugMipMat;
    private static float debugDrawDuration;
    private Material downscaleMat;
    private Material blitCopyMat;
    private int hiZLevelCount;
    private int hiZWidth;
    private int hiZHeight;
    private RenderTexture depthTexture;
    private RenderTexture hiZTexture;
    private RenderTexture[] hiZLevels;
    private static int GridCellsPerAxis;
    private static int GridHalfCellsPerAxis;
    private static int GridMinHalfCellsPerAxis;
    private static int GridMaxHalfCellsPerAxis;
    private static float GridCellSize;
    private static float GridHalfCellSize;
    private static float GridRcpCellSize;
    private static int GridPoolCapacity;
    private static int GridPoolGranularity;
    private static HashedPool`1<Cell> grid;
    private static Queue`1<Cell> gridChanged;
    public static OcclusionCulling Instance { get; }
    public static bool Supported { get; }
    public static bool Enabled { get; public set; }
    public static bool SafeMode { get; public set; }
    public static DebugFilter DebugShow { get; public set; }
    public bool HiZReady { get; }
    private static OcclusionCulling();
    public static OcclusionCulling get_Instance();
    public static bool get_Supported();
    public static bool get_Enabled();
    public static void set_Enabled(bool value);
    public static bool get_SafeMode();
    public static void set_SafeMode(bool value);
    public static DebugFilter get_DebugShow();
    public static void set_DebugShow(DebugFilter value);
    private static void GrowStatePool();
    private static OccludeeState Allocate();
    private static void Release(OccludeeState state);
    private void Awake();
    private void OnEnable();
    private bool SupportsNativePath();
    private void OnDisable();
    public static void MakeAllVisible();
    private void Update();
    public static void RecursiveAddOccludees(Transform transform, float minTimeVisible, bool isStatic, bool stickyGizmos);
    private static int FindFreeSlot(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled);
    public static OccludeeState GetStateById(int id);
    public static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged);
    private static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, Queue`1<int> recycled, List`1<int> changed, BufferSet set, SimpleList`1<int> visibilityChanged);
    public static void UnregisterOccludee(int id);
    private static void UnregisterOccludee(int slot, SimpleList`1<OccludeeState> occludees, Queue`1<int> recycled, List`1<int> changed);
    public static void UpdateDynamicOccludee(int id, Vector3 center, float radius);
    private void UpdateBuffers(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, BufferSet set, List`1<int> changed, bool isStatic);
    private void UpdateCameraMatrices(bool starting);
    private void OnPreCull();
    private void OnPostRender();
    private Single[] MatrixToFloatArray(Matrix4x4 m);
    private void PrepareAndDispatch();
    private void IssueRead();
    public void ResetTiming(SmartList bucket);
    public void ResetTiming();
    private void ProcessCallbacks(SimpleList`1<OccludeeState> occludees, SimpleList`1<State> states, SimpleList`1<int> changed);
    public void RetrieveAndApplyVisibility();
    public static bool DebugFilterIsDynamic(int filter);
    public static bool DebugFilterIsStatic(int filter);
    public static bool DebugFilterIsGrid(int filter);
    private void DebugInitialize();
    private void DebugShutdown();
    private void DebugUpdate();
    private void DebugDraw();
    public static void NormalizePlane(Vector4& plane);
    public static void ExtractFrustum(Matrix4x4 viewProjMatrix, Vector4[]& planes);
    public bool get_HiZReady();
    public void CheckResizeHiZMap();
    private void InitializeHiZMap();
    private void FinalizeHiZMap();
    private void InitializeHiZMap(int width, int height);
    private void DestroyHiZMap();
    private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips);
    private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip);
    public void GrabDepthTexture();
    public void GenerateHiZMipChain();
    private void DebugDrawGizmos();
    private static int floor(float x);
    public static Cell RegisterToGrid(OccludeeState occludee);
    public static void UpdateInGrid(OccludeeState occludee);
    public static void UnregisterFromGrid(OccludeeState occludee);
    public void UpdateGridBuffers();
    private static bool FrustumCull(Vector4[] planes, Vector4 testSphere);
    private static int ProcessOccludees_Safe(SimpleList`1<State> states, SmartList bucket, Color32[] results, SimpleList`1<int> changed, Vector4[] frustumPlanes, float time, UInt32 frame);
    private static int ProcessOccludees_Fast(State[] states, Int32[] bucket, int bucketCount, Color32[] results, int resultCount, Int32[] changed, Int32& changedCount, Vector4[] frustumPlanes, float time, UInt32 frame);
    private static int ProcessOccludees_Native(State& states, Int32& bucket, int bucketCount, Color32& results, int resultCount, Int32& changed, Int32& changedCount, Vector4& frustumPlanes, float time, UInt32 frame);
    private void ApplyVisibility_Safe(float time, UInt32 frame);
    private void ApplyVisibility_Fast(float time, UInt32 frame);
    private void ApplyVisibility_Native(float time, UInt32 frame);
    private void ApplyVisibility_Passthrough(float time, UInt32 frame);
}
[CreateAssetMenuAttribute]
public class OceanSettings : ScriptableObject {
    [HeaderAttribute("Compute Shaders")]
public ComputeShader waveSpectrumCompute;
    public ComputeShader fftCompute;
    public ComputeShader waveMergeCompute;
    public ComputeShader waveInitialSpectrum;
    [HeaderAttribute("Global Ocean Params")]
public Single[] octaveScales;
    public float lamda;
    public float windDirection;
    public float distanceAttenuationFactor;
    public float depthAttenuationFactor;
    [HeaderAttribute("Ocean Spectra")]
public OceanSpectrumSettings[] spectrumSettings;
    [HideInInspector]
public Single[] spectrumRanges;
    public OceanDisplacementShort3[0...,0...,0...] LoadSimData();
    internal NativeOceanDisplacementShort3 LoadNativeSimData();
}
[ExecuteInEditMode]
public class OneActiveSibling : MonoBehaviour {
}
public class OnePoleLowpassFilter : MonoBehaviour {
    [RangeAttribute("10", "20000")]
public float frequency;
}
[ExtensionAttribute]
public static class OnParentDestroyingEx : object {
    [ExtensionAttribute]
public static void BroadcastOnParentDestroying(GameObject go);
    [ExtensionAttribute]
public static void SendOnParentDestroying(GameObject go);
}
[ExtensionAttribute]
public static class OnParentSpawningEx : object {
    [ExtensionAttribute]
public static void BroadcastOnParentSpawning(GameObject go);
    [ExtensionAttribute]
public static void SendOnParentSpawning(GameObject go);
}
public class OnPositionMemorySetAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class OnPositionMemorySetEventUI : BaseEventUI {
}
[ExtensionAttribute]
public static class OnPostNetworkUpdateEx : object {
    [ExtensionAttribute]
public static void BroadcastOnPostNetworkUpdate(GameObject go, BaseEntity entity);
    [ExtensionAttribute]
public static void SendOnPostNetworkUpdate(GameObject go, BaseEntity entity);
}
[ExtensionAttribute]
public static class OnSendNetworkUpdateEx : object {
    [ExtensionAttribute]
public static void BroadcastOnSendNetworkUpdate(GameObject go, BaseEntity entity);
    [ExtensionAttribute]
public static void SendOnSendNetworkUpdate(GameObject go, BaseEntity entity);
}
public class OpenSteamURL : MonoBehaviour {
    public bool openInSteam;
}
public class OpenURL : MonoBehaviour {
    public bool OpenWebURL;
}
public class OreHopper : PercentFullStorageContainer {
    [SerializeField]
private Transform oreOutputMesh;
    private float visualPercentFull;
    private Vector3 _oreScale;
    protected virtual void OnPercentFullChanged(float newPercentFull);
    private void SetVisualOreLevel(float percentFull);
    public void VisualLerpToOreLevel();
    private void OreVisualLerpUpdate();
    public virtual void ServerInit();
}
public class OreHotSpot : BaseCombatEntity {
    public float visualDistance;
    public GameObjectRef visualEffect;
    public GameObjectRef finishEffect;
    public GameObjectRef damageEffect;
    public OreResourceEntity owner;
    public void OreOwner(OreResourceEntity newOwner);
    public virtual void ServerInit();
    public virtual void OnAttacked(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public void FireFinishEffect();
}
public class OreResourceEntity : StagedResourceEntity {
    public GameObjectRef bonusPrefab;
    public GameObjectRef finishEffect;
    public GameObjectRef bonusFailEffect;
    public bool useHotspotMinigame;
    public OreHotSpot _hotSpot;
    public SoundPlayer bonusSound;
    public float heightOffset;
    public bool useManualStageCentre;
    public List`1<Vector3> stageCentres;
    private int bonusesKilled;
    public int bonusesSpawned;
    public Vector3 lastNodeDir;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void OnAttacked(HitInfo info);
    public virtual void UpdateNetworkStage();
    public void CleanupBonus();
    public virtual void DestroyShared();
    public virtual void OnKilled(HitInfo info);
    public virtual void ServerInit();
    private void InitialSpawnBonusSpot();
    public void FinishBonusAssigned();
    public void DelayedBonusSpawn();
    public void RespawnBonus();
    public OreHotSpot SpawnBonusSpot(Vector3 lastDirection);
    public Vector3 RandomCircle(float distance, bool allowInside);
    public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset, bool allowInside, bool changeHeight);
    public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec);
    public static Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight, bool allowInside);
    public Vector3 ClampToCylinder(Vector3 localPos, Vector3 cylinderAxis, float cylinderDistance, float minHeight, float maxHeight);
}
public class ORSwitch : IOEntity {
    private int input1Amount;
    private int input2Amount;
    public virtual int ConsumptionAmount();
    public virtual bool WantsPower(int inputIndex);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int slot);
}
public class OutlineManager : MonoBehaviour {
    public static Material blurMat;
    public List`1<OutlineObject> objectsToRender;
    public float blurAmount;
    public Material glowSolidMaterial;
    public Material blendGlowMaterial;
}
public class OutlineObject : MonoBehaviour {
    public Mesh[] meshes;
    public Transform[] meshTransforms;
}
public class OvenItemIcon : MonoBehaviour {
    public ItemIcon ItemIcon;
    public RustText ItemLabel;
    public RustText MaterialLabel;
    public OvenSlotType SlotType;
    public Phrase EmptyPhrase;
    public List`1<OvenSlotConfig> SlotConfigs;
    public float DisabledAlphaScale;
    public CanvasGroup CanvasGroup;
    private Item _item;
    private void Start();
    private void Update();
    private void UpdateLabels();
    [CompilerGeneratedAttribute]
private bool <Start>b__10_0(OvenSlotConfig x);
}
public class OvenLineRow : MonoBehaviour {
    public LootGrid Above;
    public LootGrid Below;
    public Transform Container;
    public Color Color;
    public Sprite TriangleSprite;
    public int LineWidth;
    public int ArrowWidth;
    public int ArrowHeight;
    public int Padding;
    private int _topCount;
    private int _bottomCount;
    private List`1<GameObject> images;
    private void Update();
    private void CreateRow(bool above);
    private Image CreateImage();
}
public class OvenLootPanel : MonoBehaviour {
    public GameObject controlsOn;
    public GameObject controlsOff;
    public Image TitleBackground;
    public RustText TitleText;
    public Color AlertBackgroundColor;
    public Color AlertTextColor;
    public Color OffBackgroundColor;
    public Color OffTextColor;
    public Color OnBackgroundColor;
    public Color OnTextColor;
    private Phrase OffPhrase;
    private Phrase OnPhrase;
    private Phrase NoFuelPhrase;
    public GameObject FuelRowPrefab;
    public GameObject MaterialRowPrefab;
    public GameObject ItemRowPrefab;
    public Sprite IconBackground_Wood;
    public Sprite IconBackGround_Input;
    public LootGrid LootGrid_Wood;
    public LootGrid LootGrid_Input;
    public LootGrid LootGrid_Output;
    public GameObject Contents;
    public GameObject[] ElectricDisableRoots;
}
public enum OvenSlotType : Enum {
    public int value__;
    public static OvenSlotType Fuel;
    public static OvenSlotType Charcoal;
    public static OvenSlotType Material;
    public static OvenSlotType Smelted;
    public static OvenSlotType FoodInput;
    public static OvenSlotType FoodOutput;
}
public enum OvenStatus : Enum {
    public int value__;
    public static OvenStatus NoFuel;
    public static OvenStatus Off;
    public static OvenStatus On;
}
public enum OverlayBlendMode : Enum {
    public int value__;
    public static OverlayBlendMode Additive;
    public static OverlayBlendMode ScreenBlend;
    public static OverlayBlendMode Multiply;
    public static OverlayBlendMode Overlay;
    public static OverlayBlendMode AlphaBlend;
    public static OverlayBlendMode AdditiveNonLit;
    public static OverlayBlendMode AlpbaBlendConst;
}
public class OverlayBlendModeParameter : ParameterOverride`1<OverlayBlendMode> {
}
public class OverlayMeshPaintableSource : MeshPaintableSource {
    private static Memoized`2<string, string> STPrefixed;
    public string baseTextureName;
    public Texture2D baseTexture;
    private static OverlayMeshPaintableSource();
    public virtual void UpdateMaterials(MaterialPropertyBlock block, Texture2D textureOverride, bool forEditing, bool isSelected);
}
public class OxygenOverlay : MonoBehaviour {
    [SerializeField]
private PostProcessVolume postProcessVolume;
    [SerializeField]
private float smoothTime;
    [TooltipAttribute("If true, only show this effect when the player is mounted in a submarine.")]
[SerializeField]
private bool submarinesOnly;
}
public class Paddle : BaseMelee {
    public float animPaddleCooldown;
    public GameObjectRef kayakSeat;
    public float animationLerpSpeed;
}
public class PaddlingPool : LiquidContainer {
    public static Flags FilledUp;
    public Transform poolWaterVolume;
    public GameObject poolWaterVisual;
    public float minimumWaterHeight;
    public float maximumWaterHeight;
    public WaterVolume waterVolume;
    public bool alignWaterUp;
    public GameObjectRef destroyedWithWaterEffect;
    public Transform destroyedWithWaterEffectPos;
    public Collider requireLookAt;
    private float lastFillAmount;
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    protected virtual void OnInventoryDirty();
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public virtual void Save(SaveInfo info);
    private float GetNormalisedFillLevel();
    private void UpdatePoolFillAmount(float normalisedAmount);
    public virtual int ConsumptionAmount();
    public virtual void DestroyShared();
}
public class PagerEntity : BaseEntity {
    public static Flags Flag_Silent;
    private int frequency;
    public float beepRepeat;
    public GameObjectRef pagerEffect;
    public GameObjectRef silentEffect;
    private float nextChangeTime;
    private static PagerEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual int GetFrequency();
    public virtual void SwitchParent(BaseEntity ent);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public sealed virtual Vector3 GetPosition();
    public sealed virtual float GetMaxRange();
    public sealed virtual void RFSignalUpdate(bool on);
    public void SetSilentMode(bool wantsSilent);
    public void SetOff();
    public void ChangeFrequency(int newFreq);
    [RPC_Server]
[IsVisible("3")]
public void ServerSetFrequency(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    internal virtual void OnParentRemoved();
    public void OnParentDestroying();
    public virtual void Load(LoadInfo info);
}
public class PaintableImageGrid : UIBehaviour {
    public UIPaintableImage templateImage;
    public int cols;
    public int rows;
}
public class PaintableItem : MonoBehaviour {
    public MeshPaintableSource PaintableSource;
}
public class PaintedItemStorageEntity : BaseEntity {
    public UInt32 _currentImageCrc;
    private ulong lastEditedBy;
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    [RPC_Server]
[CallsPerSecond("3")]
private void Server_UpdateImage(RPCMessage msg);
    internal virtual void DoServerDestroy();
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public sealed virtual UGCType get_ContentType();
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public virtual bool get_ShouldTransferAssociatedFiles();
    [ConditionalAttribute("PAINTED_ITEM_DEBUG")]
private void DebugOnlyLog(string str);
}
public class Painting.Brush : object {
    public float spacing;
    public Vector2 brushSize;
    public Texture2D texture;
    public Color color;
    public bool erase;
}
public class PaperDollSegment : BaseMonoBehaviour {
    public static HitArea selectedAreas;
    [InspectorFlagsAttribute]
public HitArea area;
    public Image overlayImg;
}
public class Parachute : BaseVehicle {
    public Collider ParachuteCollider;
    public ItemDefinition PackedParachute;
    public GameObjectRef DetachedParachute;
    public Transform DetachedSpawnPoint;
    public float ConditionLossPerUse;
    public float HurtDeployTime;
    public float HurtAmount;
    public Animator ColliderAnimator;
    public Animator ColliderWorldAnimator;
    public float UprightLerpForce;
    public float ConstantForwardForce;
    public ForceMode ForwardForceMode;
    public float TurnForce;
    public ForceMode TurnForceMode;
    public float ForwardTiltAcceleration;
    public float BackInputForceMultiplier;
    public float DeployAnimationLength;
    public float TargetDrag;
    public float TargetAngularDrag;
    public AnimationCurve DragCurve;
    public AnimationCurve DragDamageCurve;
    public AnimationCurve MassDamageCurve;
    public AnimationCurve DamageHorizontalVelocityCurve;
    [RangeAttribute("0", "1")]
public float DamageTester;
    public float AnimationInputSmoothness;
    public Vector2 AnimationInputScale;
    public ParachuteWearable FirstPersonCanopy;
    public GameObjectRef ParachuteLandScreenBounce;
    private static int AnimatorInputXParameter;
    private static int AnimatorInputYParameter;
    private TimeSince mountTime;
    public static Flags Flag_InputForward;
    public static Flags Flag_InputBack;
    public static Flags Flag_InputLeft;
    public static Flags Flag_InputRight;
    public SoundDefinition deploySoundDef;
    public SoundDefinition releaseSoundDef;
    public SoundDefinition flightLoopSoundDef;
    public SoundDefinition steerSoundDef;
    public AnimationCurve flightLoopPitchCurve;
    public AnimationCurve flightLoopGainCurve;
    [ServerVar]
public static bool BypassRepack;
    [ServerVar]
public static bool LandingAnimations;
    public bool collisionDeath;
    public Vector3 collisionImpulse;
    private float startHeight;
    private float distanceTravelled;
    private Vector3 lastPosition;
    private Vector2 lerpedInput;
    public Vector3 collisionLocalPos;
    public Vector3 collisionWorldNormal;
    protected bool BypassClothingMountBlocks { get; }
    public SamTargetType SAMTargetType { get; }
    private static Parachute();
    protected virtual bool get_BypassClothingMountBlocks();
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public virtual bool GetDismountPosition(BasePlayer player, Vector3& res);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void VehicleFixedUpdate();
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public void ProcessDeath();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public void DelayedDismount();
    public virtual float MaxVelocity();
    public virtual bool AllowPlayerInstigatedDismount(BasePlayer player);
    public sealed virtual SamTargetType get_SAMTargetType();
    public sealed virtual bool IsValidSAMTarget(bool staticRespawn);
    private Vector2 ProcessInputVector(InputState inputState, BasePlayer player);
    private Vector2 ProcessInputVectorFromFlags(BasePlayer player);
    private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown);
}
public class ParachuteSeat : SledSeat {
    protected bool BypassClothingMountBlocks { get; }
    protected virtual bool get_BypassClothingMountBlocks();
}
public class ParachuteUnpacked : DecayEntity {
    public Rigidbody targetRigidbody;
    public Transform centreOfMassRoot;
    public virtual void ServerInit();
}
public class ParachuteWearable : MonoBehaviour {
    public Animator TargetAnimator;
    public Transform LeftHandTarget;
    public Transform RightHandTarget;
}
public class ParticleCollisionLOD : LODComponentParticleSystem {
    [HorizontalAttribute("1", "0")]
public State[] States;
}
public class ParticleDisableOnParentDestroy : MonoBehaviour {
    public float destroyAfterSeconds;
    public sealed virtual void OnParentDestroying();
}
public class ParticleEmissionSound : FacepunchBehaviour {
    public ParticleSystem particleSystem;
    public SoundDefinition soundDefinition;
    public float soundCooldown;
}
public class ParticleEmitFromParentObject : MonoBehaviour {
    public string bonename;
    private Bounds bounds;
    private Transform bone;
    private BaseEntity entity;
    private float lastBoundsUpdate;
}
public class ParticlePatch : object {
}
public class ParticleRandomLifetime : MonoBehaviour {
    public ParticleSystem mySystem;
    public float minScale;
    public float maxScale;
    public void Awake();
}
public class ParticleSpawn : SingletonComponent`1<ParticleSpawn> {
    public GameObjectRef[] Prefabs;
    public int PatchCount;
    public int PatchSize;
    [CompilerGeneratedAttribute]
private Vector3 <Origin>k__BackingField;
    public Vector3 Origin { get; private set; }
    [CompilerGeneratedAttribute]
public Vector3 get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(Vector3 value);
}
public class ParticleSystemContainer : MonoBehaviour {
    public bool precached;
    public bool includeLights;
    [SerializeField]
[HideInInspector]
private ParticleSystemGroup[] particleGroups;
    [HideInInspector]
[SerializeField]
private Light[] lights;
    [HideInInspector]
[SerializeField]
private LightEx[] lightExs;
    public void Play();
    public void Pause();
    public void Stop();
    public void Clear();
    private void SetLights(bool on);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class ParticleSystemCull : LODComponentParticleSystem {
    public float Distance;
}
[ExtensionAttribute]
public static class ParticleSystemEx : object {
    [ExtensionAttribute]
public static void SetPlayingState(ParticleSystem ps, bool play);
    [ExtensionAttribute]
public static void SetEmitterState(ParticleSystem ps, bool enable);
}
public class ParticleSystemIK : MonoBehaviour {
}
public class ParticleSystemLOD : LODComponentParticleSystem {
    [HorizontalAttribute("1", "0")]
public State[] States;
}
public class ParticleSystemPlayer : MonoBehaviour {
    protected void OnEnable();
    public sealed virtual void OnParentDestroying();
}
[DefaultExecutionOrder("16000")]
public class ParticleSystemPostIK : MonoBehaviour {
}
public class PartyHatMaterialRandomiser : MonoBehaviour {
    public Material[] MaterialOptions;
    public Renderer[] TargetRenderers;
    public sealed virtual void OnItemSetup(Item item);
}
public class PathFinder : object {
    private Int32[0...,0...] costmap;
    private Int32[0...,0...] visited;
    private Point[] neighbors;
    private bool diagonals;
    private bool directional;
    public Point PushPoint;
    public int PushRadius;
    public int PushDistance;
    public int PushMultiplier;
    public List`1<Point> PushPointsAdditional;
    public HashSet`1<Point> BlockedPointsAdditional;
    private static Point[] mooreNeighbors;
    private static Point[] neumannNeighbors;
    public PathFinder(Int32[0...,0...] costmap, bool diagonals, bool directional);
    private static PathFinder();
    public int GetResolution(int index);
    public Node FindPath(Point start, Point end, int depth);
    private Node FindPathReversed(Point start, Point end, int depth);
    public Node FindPathDirected(List`1<Point> startList, List`1<Point> endList, int depth);
    public Node FindPathUndirected(List`1<Point> startList, List`1<Point> endList, int depth);
    private Node FindPathReversed(List`1<Point> startList, List`1<Point> endList, int depth);
    public Node FindClosestWalkable(Point start, int depth);
    public bool IsWalkable(Point point);
    public bool IsWalkableWithNeighbours(Point point);
    public Node Reverse(Node start);
    public Node FindEnd(Node start);
    public int Cost(Point a);
    public int Cost(Point a, Node prev);
    public int Heuristic(Point a);
    public int Heuristic(Point a, Point b);
    public int Heuristic(Point a, List`1<Point> b);
    public float Distance(Point a, Point b);
    public static Point GetPoint(Vector3 worldPos, int res);
}
public class PathInterestNode : MonoBehaviour {
    [CompilerGeneratedAttribute]
private float <NextVisitTime>k__BackingField;
    public Vector3 Position { get; }
    public float NextVisitTime { get; public set; }
    public sealed virtual Vector3 get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual float get_NextVisitTime();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NextVisitTime(float value);
    public void OnDrawGizmos();
}
public class PathInterpolator : object {
    public Vector3[] Points;
    public Vector3[] Tangents;
    [CompilerGeneratedAttribute]
private int <MinIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private float <StepSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Circular>k__BackingField;
    protected bool initialized;
    public int MinIndex { get; public set; }
    public int MaxIndex { get; public set; }
    public float Length { get; private set; }
    public float StepSize { get; private set; }
    public bool Circular { get; private set; }
    public int DefaultMinIndex { get; }
    public int DefaultMaxIndex { get; }
    public float StartOffset { get; }
    public float EndOffset { get; }
    public PathInterpolator(Vector3[] points);
    public PathInterpolator(Vector3[] points, Vector3[] tangents);
    [CompilerGeneratedAttribute]
public int get_MinIndex();
    [CompilerGeneratedAttribute]
public void set_MinIndex(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIndex();
    [CompilerGeneratedAttribute]
public void set_MaxIndex(int value);
    [CompilerGeneratedAttribute]
public virtual float get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(float value);
    [CompilerGeneratedAttribute]
public virtual float get_StepSize();
    [CompilerGeneratedAttribute]
private void set_StepSize(float value);
    [CompilerGeneratedAttribute]
public bool get_Circular();
    [CompilerGeneratedAttribute]
private void set_Circular(bool value);
    public int get_DefaultMinIndex();
    public int get_DefaultMaxIndex();
    public float get_StartOffset();
    public float get_EndOffset();
    public void RecalculateTangents();
    public void RecalculateLength();
    public void Resample(float distance);
    public void Smoothen(int iterations, Func`2<int, float> filter);
    public void Smoothen(int iterations, Vector3 multipliers, Func`2<int, float> filter);
    private void SmoothenIndex(int i, Vector3 multipliers, Func`2<int, float> filter);
    public void Straighten(int diStart, int diEnd);
    public Vector3 GetStartPoint();
    public Vector3 GetEndPoint();
    public Vector3 GetStartTangent();
    public Vector3 GetEndTangent();
    public Vector3 GetPointByIndex(int i);
    public Vector3 GetTangentByIndex(int i);
    public int GetPrevIndex(float distance);
    public int GetNextIndex(float distance);
    public Vector3 GetPoint(int index);
    public Vector3 GetPoint(float distance);
    public virtual Vector3 GetTangent(float distance);
    public virtual Vector3 GetPointCubicHermite(float distance);
}
public class PathList : object {
    private static Quaternion rot90;
    private static Quaternion rot180;
    private static Quaternion rot270;
    public static float EndWidthScale;
    public static float EndWidthScaleDistance;
    public static float LengthWidthScale;
    public static float LengthWidthScaleDistance;
    public string Name;
    public PathInterpolator Path;
    public bool Spline;
    public bool Start;
    public bool End;
    public float Width;
    public float InnerPadding;
    public float OuterPadding;
    public float InnerFade;
    public float OuterFade;
    public float RandomScale;
    public float MeshOffset;
    public float TerrainOffset;
    public int Topology;
    public int Splat;
    public int Hierarchy;
    public Node ProcgenStartNode;
    public Node ProcgenEndNode;
    public static float StepSize;
    private static Single[] placements;
    public PathList(string name, Vector3[] points);
    private static PathList();
    private void SpawnObjectsNeighborAligned(UInt32& seed, Prefab[] prefabs, List`1<Vector3> positions, SpawnFilter filter);
    private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter);
    private bool SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List`1<Prefab> previousSpawns, Prefab& spawned, int pathLength, int index, SpawnFilter filter);
    private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter);
    private void SpawnObject(UInt32& seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj);
    private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj);
    public void SpawnSide(UInt32& seed, SideObject obj);
    public void SpawnAlong(UInt32& seed, PathObject obj);
    public void SpawnBridge(UInt32& seed, BridgeObject obj);
    public void SpawnStart(UInt32& seed, BasicObject obj);
    public void SpawnEnd(UInt32& seed, BasicObject obj);
    public void TrimStart(BasicObject obj);
    public void TrimEnd(BasicObject obj);
    public void TrimTopology(int topology);
    public void ResetTrims();
    public void AdjustTerrainHeight(float intensity, float fade, bool scaleWidthWithLength);
    public void AdjustTerrainHeight(Func`3<float, float, float> intensity, Func`3<float, float, float> fade, bool scaleWidthWithLength);
    public void AdjustTerrainTexture(bool scaleWidthWithLength);
    public void AdjustTerrainTopology(bool scaleWidthWithLength);
    public void AdjustPlacementMap(float width);
    public List`1<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, bool scaleWidthWithLength);
    public static float GetRadius(float distance, float length, float baseRadius, float randomScale, bool scaleWidthWithLength);
}
public class PathSequence : PrefabAttribute {
    protected virtual Type GetIndexedType();
    public virtual void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position);
}
public class PathSequencePowerline : PathSequence {
    public SequenceRule Rule;
    private static int RegularPowerlineSpacing;
    public virtual void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position);
    private Prefab GetPrefabOfType(Prefab[] options, SequenceRule ruleToFind);
    private int GetIndexCountToRule(List`1<Prefab> sequence, SequenceRule rule);
}
public class PathSpeedZone : MonoBehaviour {
    public Bounds bounds;
    public OBB obbBounds;
    public float maxVelocityPerSec;
    public sealed virtual OBB WorldSpaceBounds();
    public sealed virtual float GetMaxSpeed();
}
public class PatrolHelicopter : BaseCombatEntity {
    public GameObject rotorPivot;
    public GameObject mainRotor;
    public GameObject mainRotor_blades;
    public GameObject mainRotor_blur;
    public GameObject tailRotor;
    public GameObject tailRotor_blades;
    public GameObject tailRotor_blur;
    public GameObject rocket_tube_left;
    public GameObject rocket_tube_right;
    public GameObject left_gun_yaw;
    public GameObject left_gun_pitch;
    public GameObject left_gun_muzzle;
    public GameObject right_gun_yaw;
    public GameObject right_gun_pitch;
    public GameObject right_gun_muzzle;
    public GameObject spotlight_rotation;
    public GameObjectRef rocket_fire_effect;
    public GameObjectRef gun_fire_effect;
    public GameObjectRef bulletEffect;
    public GameObjectRef explosionEffect;
    public GameObjectRef fireBall;
    public GameObjectRef crateToDrop;
    public int maxCratesToSpawn;
    public float bulletSpeed;
    public float bulletDamage;
    public GameObjectRef servergibs;
    public GameObjectRef debrisFieldMarker;
    public float flareDuration;
    public SoundDefinition rotorWashSoundDef;
    private Sound _rotorWashSound;
    public SoundDefinition flightEngineSoundDef;
    public SoundDefinition flightThwopsSoundDef;
    private Sound flightEngineSound;
    private Sound flightThwopsSound;
    public Modulator flightEngineGainMod;
    public Modulator flightThwopsGainMod;
    public float rotorGainModSmoothing;
    public float engineGainMin;
    public float engineGainMax;
    public float thwopGainMin;
    public float thwopGainMax;
    public float spotlightJitterAmount;
    public float spotlightJitterSpeed;
    public GameObject[] nightLights;
    public Vector3 spotlightTarget;
    public float engineSpeed;
    public float targetEngineSpeed;
    public float blur_rotationScale;
    public ParticleSystem[] _rotorWashParticles;
    public PatrolHelicopterAI myAI;
    public GameObjectRef mapMarkerEntityPrefab;
    public float lastNetworkUpdate;
    private static float networkUpdateRate;
    private BaseEntity mapMarkerInstance;
    public weakspot[] weakspots;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float MaxVelocity();
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public void RadarLock(SeekingServerProjectile incoming);
    public void CancelRadar();
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public void CreateMapMarker();
    public virtual void OnPositionalNetworkUpdate();
    public void CreateExplosionMarker(float durationMinutes);
    public virtual void OnKilled(HitInfo info);
    public sealed virtual bool IsValidHomingTarget();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public void DoFlare();
    public void ClearFlares();
    public void Update();
    public void InitalizeWeakspots();
    public virtual void OnAttacked(HitInfo info);
    public virtual void Hurt(HitInfo info);
}
public class PatrolHelicopterAI : BaseMonoBehaviour {
    public Vector3 interestZoneOrigin;
    public Vector3 destination;
    public bool hasInterestZone;
    public float moveSpeed;
    public float maxSpeed;
    public float courseAdjustLerpTime;
    public Quaternion targetRotation;
    public Vector3 windVec;
    public Vector3 targetWindVec;
    public float windForce;
    public float windFrequency;
    public float targetThrottleSpeed;
    public float throttleSpeed;
    public float maxRotationSpeed;
    public float rotationSpeed;
    public float terrainPushForce;
    public float obstaclePushForce;
    public HelicopterTurret leftGun;
    public HelicopterTurret rightGun;
    public static PatrolHelicopterAI heliInstance;
    public PatrolHelicopter helicopterBase;
    public aiState _currentState;
    public float oceanDepthTargetCutoff;
    public AIHelicopterAnimation anim;
    private Vector3 _aimTarget;
    private bool movementLockingAiming;
    private bool hasAimTarget;
    private bool aimDoorSide;
    private Vector3 pushVec;
    private Vector3 _lastPos;
    private Vector3 _lastMoveDir;
    public bool isDead;
    public bool isRetiring;
    public float spawnTime;
    public float lastDamageTime;
    private bool forceTerrainPushback;
    [ServerVar]
public static float flee_damage_percentage;
    [ServerVar]
public static bool use_danger_zones;
    [ServerVar]
public static bool monument_crash;
    private bool shouldDebug;
    public List`1<targetinfo> _targetList;
    public List`1<DangerZone> dangerZones;
    public List`1<DangerZone> noGoZones;
    private static int max_zones;
    private static float no_go_zone_size;
    private static float danger_zone_size;
    private DangerZone leastActiveZone;
    private float deathTimeout;
    private bool didImpact;
    private Collider[] collisions;
    private bool reachedSpinoutLocation;
    private float destination_min_dist;
    private float currentOrbitDistance;
    private float currentOrbitTime;
    private bool hasEnteredOrbit;
    private float orbitStartTime;
    public float maxOrbitDuration;
    private bool breakingOrbit;
    private float timeBetweenRocketsOrbit;
    private bool didGetToDesination;
    public List`1<MonumentInfo> _visitedMonuments;
    public float arrivalTime;
    public GameObjectRef rocketProjectile;
    public GameObjectRef rocketProjectile_Napalm;
    public bool leftTubeFiredLast;
    public float lastRocketTime;
    public float timeBetweenRockets;
    public int numRocketsLeft;
    public static int maxRockets;
    public Vector3 strafe_target_position;
    public BasePlayer strafe_target;
    public bool puttingDistance;
    public static float strafe_approach_range;
    public static float strafe_firing_range;
    private float get_out_of_strafe_distance;
    private bool passNapalm;
    private Vector3 cached_strafe_pos;
    private TimeSince timeSinceRefreshed;
    private bool useNapalm;
    public float lastNapalmTime;
    public float lastStrafeTime;
    private float _lastThinkTime;
    public bool IsDead { get; }
    private static PatrolHelicopterAI();
    public bool get_IsDead();
    [ServerVar]
private void dumpstate();
    public void Awake();
    public void SetInitialDestination(Vector3 dest, float mapScaleDistance);
    public void Retire();
    public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride);
    public Quaternion GetYawRotationTo(Vector3 targetDest);
    public void SetTargetDestination(Vector3 targetDest, float minDist, float minDistForFacingRotation);
    public bool AtDestination();
    public bool AtRotation();
    private void NoGoZoneAdded(DangerZone zone);
    public void MoveToDestination();
    public void TerrainPushback();
    public void UpdateRotation();
    public void UpdateSpotlight();
    public void Update();
    public void FixedUpdate();
    public void OtherDamaged(HitInfo info);
    public void WeakspotDamaged(weakspot weak, HitInfo info);
    public void TryStrafePlayer(HitInfo info, float timeSinceDamagedThreshold);
    public void CriticalDamage();
    public void DoMachineGuns();
    public void FireGun(Vector3 targetPos, float aimCone, bool left);
    public bool CanInterruptState();
    public bool IsAlive();
    public void DestroyMe();
    public Vector3 GetLastMoveDir();
    public Vector3 GetMoveDirection();
    public float GetMoveSpeed();
    public float GetMaxRotationSpeed();
    public bool IsTargeting();
    public void UpdateWind();
    public void SetAimTarget(Vector3 aimTarg, bool isDoorSide);
    public void ClearAimTarget();
    public void UpdateTargetList();
    private void UpdateTargetLineOfSightTime(targetinfo targ);
    private void AddNewTargetsToList();
    private Nullable`1<Vector3> FindTargetWithZones(bool withOffset);
    private Vector3 FindDefaultTarget(bool withOffset);
    private Vector3 GetTargetOffset();
    public bool PlayerVisible(BasePlayer ply);
    public void WasAttacked(HitInfo info);
    public void UpdateDangerZones(Vector3 position, float damage, BasePlayer ply, weakspot weak);
    public void MakeZone(Vector3 position, float damage, BaseEntity parent);
    private void UpdateNoGoZones(DangerZone zone);
    public void ClearStaleZones();
    private void RemoveLeastSignificantZone();
    public bool IsInNoGoZone(Vector3 position);
    public bool IsInDangerZone(Vector3 position, DangerZone& dangerZone);
    public void State_Death_Think(float timePassed);
    public void State_Death_Enter();
    public void State_Death_Leave();
    private MonumentInfo GetCloseMonument(float maxDistance);
    private void PhysicsDeathCheck();
    private void KillOfNaturalCauses();
    private void StartSpinout();
    public void State_Flee_Think(float timePassed);
    public void State_Flee_Enter(Vector3 newPos);
    public void State_Flee_Leave();
    public void State_Idle_Think(float timePassed);
    public void State_Idle_Enter();
    public void State_Idle_Leave();
    public void State_Move_Think(float timePassed);
    public void State_Move_Enter(Vector3 newPos);
    public void State_Move_Leave();
    private void TryMove(Vector3 newPos);
    private void UpdateMove(float timePassed);
    public void State_Orbit_Think(float timePassed);
    public Vector3 GetOrbitPosition(float rate);
    public void State_Orbit_Enter(float orbitDistance);
    public void State_Orbit_Leave();
    private void OrbitInit(float orbitDistance, float minDistForFacingRotation);
    private void OrbitUpdate(float timePassed, float minDistForFacingRotation, bool canBreak);
    private void StartBreakOrbit();
    private void DebugOrbit();
    public void State_OrbitStrafe_Enter();
    public void State_OrbitStrafe_Think(float timePassed);
    public void State_OrbitStrafe_Leave();
    public Vector3 GetRandomPatrolDestination();
    private Vector3 FindValidDestination(int maxAttempts);
    public Vector3 GenerateRandomDestination(bool forceMonument);
    public void State_Patrol_Think(float timePassed);
    private void OrbitInterestZone();
    public void State_Patrol_Enter();
    public void State_Patrol_Leave();
    private Vector3 GetRandomMapPosition();
    public int ClipRocketsLeft();
    public bool CanStrafe();
    public bool CanUseNapalm();
    public void State_Strafe_Enter(BasePlayer strafeTarget, bool shouldUseNapalm);
    public void State_Strafe_Think(float timePassed);
    private Vector3 GetPredictedPosition();
    private bool CanSeeForStrafe(Vector3 targetPos);
    public bool ValidRocketTarget(BasePlayer ply);
    public void State_Strafe_Leave();
    private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm);
    public void FireRocket(Vector3 targetPos);
    private void RefreshTargetPosition();
    public void InitializeAI();
    public void OnCurrentStateExit();
    public void ExitCurrentState();
    public float GetTime();
    public void AIThink();
    public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange, float minHeight, float maxHeight);
    public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight, float maxHeight);
    public float GetThrottleForDistance(float distToTarget);
}
public class PatternFirework : MortarFirework {
    public static int CurrentVersion;
    [HeaderAttribute("PatternFirework")]
public GameObjectRef FireworkDesignerDialog;
    public int MaxStars;
    public float ShellFuseLengthShort;
    public float ShellFuseLengthMed;
    public float ShellFuseLengthLong;
    public Design Design;
    public FuseLength ShellFuseLength;
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    public virtual void DestroyShared();
    public virtual void ServerInit();
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("5")]
private void StartOpenDesigner(RPCMessage rpc);
    [CallsPerSecond("5")]
[RPC_Server]
[IsVisible("3")]
private void ServerSetFireworkDesign(RPCMessage rpc);
    [CallsPerSecond("5")]
[IsVisible("3")]
[RPC_Server]
private void SetShellFuseLength(RPCMessage rpc);
    private bool PlayerCanModify(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public sealed virtual UGCType get_ContentType();
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public virtual void Load(LoadInfo info);
    public float GetShellFuseLength();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class PatternFireworkShell : FireworkShell {
    public GameObjectRef StarPrefab;
    public AnimationCurve StarCurve;
    public float Duration;
    public float Scale;
    [HeaderAttribute("Random Design")]
[MinMaxAttribute("0", "1")]
public MinMax RandomSaturation;
    [MinMaxAttribute("0", "1")]
public MinMax RandomValue;
}
public class PatternFireworkStar : MonoBehaviour {
    public GameObject Pixel;
    public GameObject Explosion;
    public ParticleSystem[] ParticleSystems;
    public void Initialize(Color color);
    public void Explode();
}
public class PegConfig : object {
    public PegType Type;
    public Vector3 VerticalMountLocalRotation;
    public Vector3 VerticalMountLocalOffset;
    public void Init(PegType t, Vector3 localRot, Vector3 localOffset);
}
public class PercentFullStorageContainer : StorageContainer {
    private float prevPercentFull;
    public bool IsFull();
    public bool IsEmpty();
    protected virtual void OnPercentFullChanged(float newPercentFull);
    public float GetPercentFull();
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    protected virtual void OnInventoryDirty();
}
public class Performance : SingletonComponent`1<Performance> {
    public static Tick current;
    public static Tick report;
    public static int FrameHistoryCount;
    private static int HistoryLength;
    private static long cycles;
    private static Int32[] frameRateHistory;
    private static Single[] frameTimeHistory;
    private static Int32[] frameTimes;
    private int frames;
    private float time;
    private static Performance();
    private void Update();
    public List`1<int> GetFrameTimes(int requestedStart, int maxCount, Int32& startIndex);
    private void FPSTimer();
    private float AverageFrameRate();
    private float AverageFrameTime();
}
public static class PerformanceMetrics : object {
    [CompilerGeneratedAttribute]
private static PerformanceSamplePoint <LastFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerformanceSamplePoint <PerformancePerSecond>k__BackingField;
    private static PerformanceSamplePoint current;
    private static Action OnBeforeRender;
    public static PerformanceSamplePoint LastFrame { get; private set; }
    public static PerformanceSamplePoint PerformancePerSecond { get; public set; }
    [CompilerGeneratedAttribute]
public static PerformanceSamplePoint get_LastFrame();
    [CompilerGeneratedAttribute]
private static void set_LastFrame(PerformanceSamplePoint value);
    [CompilerGeneratedAttribute]
public static PerformanceSamplePoint get_PerformancePerSecond();
    [CompilerGeneratedAttribute]
public static void set_PerformancePerSecond(PerformanceSamplePoint value);
    public static void Setup();
    private static void AddCPUTimeStopwatch();
    private static void AddStopwatch(PerformanceSample sample, Action& pre, Action& post);
}
public enum PerformanceSample : Enum {
    public int value__;
    public static PerformanceSample Update;
    public static PerformanceSample LateUpdate;
    public static PerformanceSample PreCull;
    public static PerformanceSample Render;
    public static PerformanceSample FixedUpdate;
    public static PerformanceSample NetworkMessage;
    public static PerformanceSample TotalCPU;
    public static PerformanceSample PhysicsUpdate;
    public static PerformanceSample Last;
}
public class PerformanceSamplePoint : ValueType {
    public int UpdateCount;
    public int FixedUpdateCount;
    public int RenderCount;
    public TimeSpan PreCull;
    public TimeSpan Update;
    public TimeSpan LateUpdate;
    public TimeSpan PhysicsUpdate;
    public TimeSpan Render;
    public TimeSpan FixedUpdate;
    public TimeSpan TotalCPU;
    public int CpuUpdateCount;
    public PerformanceSamplePoint Add(PerformanceSamplePoint other);
}
public class PerformanceText : MonoBehaviour {
    public TextMeshProUGUI text;
}
public class PerformedAttackAIEvent : BaseAIEvent {
    protected float lastExecuteTime;
    private BaseCombatEntity combatEntity;
    public virtual void Reset();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class PerformedAttackedEventUI : BaseEventUI {
}
public class PetBrain : BaseAIBrain {
    [HeaderAttribute("Audio")]
public SoundDefinition CommandGivenVocalSFX;
    [ServerVar]
public static bool DrownInDeepWater;
    [ServerVar]
public static bool IdleWhenOwnerOfflineOrDead;
    [ServerVar]
public static bool IdleWhenOwnerMounted;
    [ServerVar]
public static float DrownTimer;
    [ReplicatedVar]
public static float ControlDistance;
    public static int Count;
    private static PetBrain();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
    public virtual void Think(float delta);
    private bool EvaluateLoadDefaultDesignTriggers();
    public virtual void OnAIDesignLoadedAtIndex(int index);
}
public class PetCommandList : PrefabAttribute {
    public List`1<PetCommandDesc> Commands;
    protected virtual Type GetIndexedType();
    public List`1<PetCommandDesc> GetCommandDescriptions();
}
public enum PetCommandType : Enum {
    public int value__;
    public static PetCommandType LoadDesign;
    public static PetCommandType SetState;
    public static PetCommandType Destroy;
}
public class PFXRepeatingFirework : RepeatingFirework {
    public ParticleSystemContainer pfx;
}
public class PhoneController : EntityComponent`1<BaseEntity> {
    public int PhoneNumber;
    public string PhoneName;
    public bool CanModifyPhoneName;
    public bool CanSaveNumbers;
    public bool RequirePower;
    public bool RequireParent;
    public float CallWaitingTime;
    public bool AppendGridToName;
    public bool IsMobile;
    public bool CanSaveVoicemail;
    public GameObjectRef PhoneDialog;
    public VoiceProcessor VProcessor;
    public PreloadedCassetteContent PreloadedContent;
    public SoundDefinition DialToneSfx;
    public SoundDefinition RingingSfx;
    public SoundDefinition ErrorSfx;
    public SoundDefinition CallIncomingWhileBusySfx;
    public SoundDefinition PickupHandsetSfx;
    public SoundDefinition PutDownHandsetSfx;
    public SoundDefinition FailedWrongNumber;
    public SoundDefinition FailedNoAnswer;
    public SoundDefinition FailedNetworkBusy;
    public SoundDefinition FailedEngaged;
    public SoundDefinition FailedRemoteHangUp;
    public SoundDefinition FailedSelfHangUp;
    public Light RingingLight;
    public float RingingLightFrequency;
    public AudioSource answeringMachineSound;
    public EntityRef currentPlayerRef;
    [CompilerGeneratedAttribute]
private int <lastDialedNumber>k__BackingField;
    [CompilerGeneratedAttribute]
public PhoneDirectory <savedNumbers>k__BackingField;
    public List`1<VoicemailEntry> savedVoicemail;
    [CompilerGeneratedAttribute]
public CallState <serverState>k__BackingField;
    public PhoneController activeCallTo;
    public int MaxVoicemailSlots { get; }
    public BasePlayer currentPlayer { get; public set; }
    private bool isServer { get; }
    public int lastDialedNumber { get; public set; }
    public PhoneDirectory savedNumbers { get; public set; }
    public BaseEntity ParentEntity { get; }
    private Cassette cachedCassette { get; }
    public CallState serverState { get; public set; }
    public UInt32 AnsweringMessageId { get; }
    public int get_MaxVoicemailSlots();
    public BasePlayer get_currentPlayer();
    public void set_currentPlayer(BasePlayer value);
    private bool get_isServer();
    [CompilerGeneratedAttribute]
public int get_lastDialedNumber();
    [CompilerGeneratedAttribute]
public void set_lastDialedNumber(int value);
    [CompilerGeneratedAttribute]
public PhoneDirectory get_savedNumbers();
    [CompilerGeneratedAttribute]
public void set_savedNumbers(PhoneDirectory value);
    public BaseEntity get_ParentEntity();
    private Cassette get_cachedCassette();
    private bool IsPowered();
    public bool IsSavedContactValid(string contactName, int contactNumber);
    public void OnFlagsChanged(Flags old, Flags next);
    [CompilerGeneratedAttribute]
public CallState get_serverState();
    [CompilerGeneratedAttribute]
public void set_serverState(CallState value);
    public UInt32 get_AnsweringMessageId();
    public void ServerInit();
    public void PostServerLoad();
    public void DoServerDestroy();
    public void ClearCurrentUser(RPCMessage msg);
    public void ClearCurrentUser();
    public void SetCurrentUser(RPCMessage msg);
    private void UpdateServerPlayer(BasePlayer newPlayer);
    public void InitiateCall(RPCMessage msg);
    public void CallPhone(int number);
    private bool CanReceiveCall();
    public void AnswerPhone(RPCMessage msg);
    public void ReceiveCallFrom(PhoneController t);
    private void TimeOutDialing();
    public void OnDialFailed(DialFailReason reason);
    public void ServerPlayAnsweringMessage(PhoneController fromPhone);
    private void TriggerTimeOut();
    public void SetPhoneStateWithPlayer(CallState state);
    private void SetPhoneState(CallState state);
    public void BeginCall();
    public void ServerHangUp(RPCMessage msg);
    public void ServerHangUp();
    private void SelfHangUp();
    private void RemoteHangUp();
    private void TimeOutCall();
    public void OnReceivedVoiceFromUser(Byte[] data);
    public void OnReceivedDataFromConnectedPhone(Byte[] data);
    public void OnIncomingCallWhileBusy();
    public void DestroyShared();
    public void UpdatePhoneName(RPCMessage msg);
    public void Server_RequestPhoneDirectory(RPCMessage msg);
    public void Server_AddSavedNumber(RPCMessage msg);
    public void Server_RemoveSavedNumber(RPCMessage msg);
    public string GetDirectoryName();
    public static string PositionToGridCoord(Vector3 position);
    public void WatchForDisconnects();
    public void OnParentChanged(BaseEntity newParent);
    private bool HasVoicemailSlot();
    public void ServerSendVoicemail(RPCMessage msg);
    public void SaveVoicemail(Byte[] data, string playerName);
    public void ServerPlayVoicemail(RPCMessage msg);
    public void ServerStopVoicemail(RPCMessage msg);
    public void ServerDeleteVoicemail(RPCMessage msg);
    public void DeleteAllVoicemail();
}
public class PhoneDialler : UIDialog {
    public GameObject DialingRoot;
    public GameObject CallInProcessRoot;
    public GameObject IncomingCallRoot;
    public RustText ThisPhoneNumber;
    public RustInput PhoneNameInput;
    public RustText textDisplay;
    public RustText CallTimeText;
    public RustButton DefaultDialViewButton;
    public RustText[] IncomingCallNumber;
    public GameObject NumberDialRoot;
    public GameObject PromptVoicemailRoot;
    public RustButton ContactsButton;
    public RustText FailText;
    public NeedsCursor CursorController;
    public NeedsKeyboard KeyboardController;
    public Phrase WrongNumberPhrase;
    public Phrase NetworkBusy;
    public Phrase Engaged;
    public GameObjectRef DirectoryEntryPrefab;
    public Transform DirectoryRoot;
    public GameObject NoDirectoryRoot;
    public RustButton DirectoryPageUp;
    public RustButton DirectoryPageDown;
    public Transform ContactsRoot;
    public RustInput ContactsNameInput;
    public RustInput ContactsNumberInput;
    public GameObject NoContactsRoot;
    public RustButton AddContactButton;
    public SoundDefinition DialToneSfx;
    public Button[] NumberButtons;
    public Phrase AnsweringMachine;
    public VoicemailDialog Voicemail;
    public GameObject VoicemailRoot;
}
public class PhoneDirectoryEntry : MonoBehaviour {
    public RustText PhoneNumber;
    public RustText PhoneName;
    public GameObject DeleteIcon;
    public GameObject CensorIcon;
}
public class PhotoEntity : ImageStorageEntity {
    [CompilerGeneratedAttribute]
private ulong <PhotographerSteamId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ImageCrc>k__BackingField;
    public ulong PhotographerSteamId { get; private set; }
    public UInt32 ImageCrc { get; private set; }
    protected UInt32 CrcToLoad { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    [CompilerGeneratedAttribute]
public ulong get_PhotographerSteamId();
    [CompilerGeneratedAttribute]
private void set_PhotographerSteamId(ulong value);
    [CompilerGeneratedAttribute]
public UInt32 get_ImageCrc();
    [CompilerGeneratedAttribute]
private void set_ImageCrc(UInt32 value);
    protected virtual UInt32 get_CrcToLoad();
    public virtual void Load(LoadInfo info);
    public virtual bool get_ShouldTransferAssociatedFiles();
    public virtual void Save(SaveInfo info);
    public void SetImageData(ulong steamId, Byte[] data);
    internal virtual void DoServerDestroy();
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public sealed virtual UGCType get_ContentType();
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
}
[PostProcessAttribute("PhotoFilterRenderer", "2", "Custom/PhotoFilter", "True")]
public class PhotoFilter : PostProcessEffectSettings {
    public ColorParameter color;
    [RangeAttribute("0", "1")]
public FloatParameter density;
}
public class PhotoFilterRenderer : PostProcessEffectRenderer`1<PhotoFilter> {
    private int rgbProperty;
    private int densityProperty;
    private Shader greyScaleShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class PhotoFrame : StorageContainer {
    private static float TextureRequestDistance;
    public EntityRef _photoEntity;
    public UInt32 _overlayTextureCrc;
    private List`1<ulong> editHistory;
    public GameObjectRef SignEditorDialog;
    public OverlayMeshPaintableSource PaintableSource;
    public NetworkableId NetworkID { get; }
    public Type FileType { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public UInt32[] GetContentCRCs { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public BaseNetworkable UgcEntity { get; }
    public Vector2i TextureSize { get; }
    public int TextureCount { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public sealed virtual UInt32[] GetTextureCRCs();
    public sealed virtual NetworkableId get_NetworkID();
    public sealed virtual Type get_FileType();
    public sealed virtual UGCType get_ContentType();
    public virtual void Save(SaveInfo info);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public sealed virtual void SetTextureCRCs(UInt32[] crcs);
    public sealed virtual List`1<ulong> get_EditingHistory();
    private void LogEdit(BasePlayer byPlayer);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public virtual bool get_ShouldTransferAssociatedFiles();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public virtual bool CanPickup(BasePlayer player);
    public sealed virtual Vector2i get_TextureSize();
    public sealed virtual int get_TextureCount();
    public sealed virtual bool CanUpdateSign(BasePlayer player);
    public bool CanUnlockSign(BasePlayer player);
    public bool CanLockSign(BasePlayer player);
    [MaxDistance("5")]
[RPC_Server]
[CallsPerSecond("3")]
public void UpdateSign(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void LockSign(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void UnLockSign(RPCMessage msg);
    public virtual void OnKilled(HitInfo info);
    public virtual bool ShouldNetworkOwnerInfo();
    public virtual string Categorize();
}
public class PhotoPanel : MonoBehaviour {
    public RawImage Image;
    public InputField Message;
}
public class PhysicsEffects : MonoBehaviour {
    public BaseEntity entity;
    public SoundDefinition physImpactSoundDef;
    public float minTimeBetweenEffects;
    public float minDistBetweenEffects;
    public float hardnessScale;
    public float lowMedThreshold;
    public float medHardThreshold;
    public float enableDelay;
    public LayerMask ignoreLayers;
    public bool useCollisionPositionInsteadOfTransform;
    public float minimumRigidbodyImpactWeight;
    private float lastEffectPlayed;
    private float enabledAt;
    private float ignoreImpactThreshold;
    private Vector3 lastCollisionPos;
    public void OnEnable();
    public void OnCollisionEnter(Collision collision);
}
public class PickAFriend : UIDialog {
    public RustInput rustInput;
    public RustText headerText;
    public bool AutoSelectInputField;
    public bool AllowMultiple;
    public Action`2<ulong, string> onSelected;
    public Phrase sleepingBagHeaderPhrase;
    public Phrase turretHeaderPhrase;
    public SteamFriendsList friendsList;
    unknown Func`2<ulong, bool> shouldShowPlayer {public set; }
    public void set_shouldShowPlayer(Func`2<ulong, bool> value);
}
public class PIDController : object {
    [SerializeField]
public float p;
    [SerializeField]
public float i;
    [SerializeField]
public float d;
    private float oldError;
    private float integralSum;
    public float Update(float dt, float current, float target);
}
[ExecuteInEditMode]
public class PieMenu : UIBehaviour {
    public static PieMenu Instance;
    public Image middleBox;
    public PieShape pieBackgroundBlur;
    public PieShape pieBackground;
    public PieShape pieSelection;
    public GameObject pieOptionPrefab;
    public GameObject optionsCanvas;
    public MenuOption[] options;
    public GameObject scaleTarget;
    public GameObject arrowLeft;
    public GameObject arrowRight;
    public float sliceGaps;
    [RangeAttribute("0", "1")]
public float outerSize;
    [RangeAttribute("0", "1")]
public float innerSize;
    [RangeAttribute("0", "1")]
public float iconSize;
    [RangeAttribute("0", "360")]
public float startRadius;
    [RangeAttribute("0", "360")]
public float radiusSize;
    public Image middleImage;
    public RustText middleTitle;
    public RustText middleDesc;
    public RustText middleRequired;
    public Color colorIconActive;
    public Color colorIconHovered;
    public Color colorIconDisabled;
    public Color colorBackgroundDisabled;
    public SoundDefinition clipOpen;
    public SoundDefinition clipCancel;
    public SoundDefinition clipChanged;
    public SoundDefinition clipSelected;
    public MenuOption defaultOption;
    [CompilerGeneratedAttribute]
private bool <IsOpen>k__BackingField;
    public Material IconMaterial;
    public bool IsOpen { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsOpen();
    [CompilerGeneratedAttribute]
private void set_IsOpen(bool value);
}
public class PieOption : MonoBehaviour {
    public PieShape background;
    public Image imageIcon;
    public Image overlayIcon;
    public PingWidget tutorialHighlight;
}
[ExecuteInEditMode]
public class PieShape : Graphic {
    [RangeAttribute("0", "1")]
public float outerSize;
    [RangeAttribute("0", "1")]
public float innerSize;
    public float startRadius;
    public float endRadius;
    public float border;
    public bool debugDrawing;
    protected virtual void OnPopulateMesh(VertexHelper vbo);
}
public class Pinata : BaseCombatEntity {
    public Transform DropPoint;
    public float DropPointRadius;
    [HeaderAttribute("Hit Animation")]
public float TotalSwingTime;
    public float SwingForce;
    public Transform SwingTransform;
    public AnimationCurve SwingCurve;
    [HeaderAttribute("Visual")]
public VisualThreshold[] Thresholds;
    public LineRenderer Line;
    public Transform DestroyEffectSpawnPos;
    public float HangLength;
    public GameObjectRef FinalDestroyEffect;
    public virtual void OnKilled(HitInfo info);
}
public class PinataPayouts : PrefabAttribute {
    public Payout[] AllPayouts;
    private int totalChance;
    public Payout GetPayout();
    protected virtual Type GetIndexedType();
}
public class PingManager : ListComponent`1<PingManager> {
    public GameObjectRef PingWidgetRef;
    public RectTransform PingParent;
    public RectTransform TeamPingParent;
    public CanvasGroup AlphaCanvas;
}
public class PingPongRotate : MonoBehaviour {
    public Vector3 rotationSpeed;
    public Vector3 offset;
    public Vector3 rotationAmount;
    private void Update();
    public Quaternion GetRotation(int index);
}
public class PingWidget : MonoBehaviour {
    public RectTransform MoveTransform;
    public RectTransform ScaleTransform;
    public Image InnerImage;
    public Image OuterImage;
    public GameObject TeamLeaderRoot;
    public GameObject CancelHoverRoot;
    public SoundDefinition PingDeploySoundHostile;
    public SoundDefinition PingDeploySoundGoTo;
    public SoundDefinition PingDeploySoundDollar;
    public SoundDefinition PingDeploySoundLoot;
    public SoundDefinition PingDeploySoundNode;
    public SoundDefinition PingDeploySoundGun;
    public CanvasGroup FadeCanvas;
}
public class PipeMesh : MonoBehaviour {
    public float PipeRadius;
    public Material PipeMaterial;
    public float StraightLength;
    public int PipeSubdivisions;
    public int BendTesselation;
    public float RidgeHeight;
    public float UvScaleMultiplier;
    public float RidgeIncrements;
    public float RidgeLength;
    public Vector2 HorizontalUvRange;
}
[ExecuteInEditMode]
public class PipeMeshTester : MonoBehaviour {
    public List`1<Vector3> positions;
    public Vector3 startDir;
    public Vector3 endDir;
    public Transform startGuide;
    public Transform endGuide;
}
public class PlaceCliffParameters : PrefabAttribute {
    public int CutoffSlopeInitial;
    public int CutoffSlopeRepeat;
    public int MinTerrainHeight;
    public int MaxTerrainHeight;
    public int MinCliffHeight;
    public int MaxCliffHeight;
    public float MinCliffScale;
    public float MaxCliffScale;
    protected virtual Type GetIndexedType();
}
public class PlaceCliffs : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public int RetryMultiplier;
    [FormerlySerializedAsAttribute("CutoffSlope")]
public int CutoffSlopeInitial;
    public int CutoffSlopeRepeat;
    [FormerlySerializedAsAttribute("MinHeight")]
public int MinTerrainHeight;
    [FormerlySerializedAsAttribute("MaxHeight")]
public int MaxTerrainHeight;
    public int MinCliffHeight;
    public int MaxCliffHeight;
    [FormerlySerializedAsAttribute("MinScale")]
public float MinCliffScale;
    [FormerlySerializedAsAttribute("MaxScale")]
public float MaxCliffScale;
    public int TargetCount;
    public int TargetLength;
    public TerrainAnchorMode AnchorModeInitial;
    public TerrainAnchorMode AnchorModeRepeat;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterModeInitial;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterModeRepeat;
    private static float min_scale_delta;
    private static int max_scale_attempts;
    private static int min_rotation;
    private static int max_rotation;
    private static int rotation_delta;
    private static float offset_c;
    private static float offset_l;
    private static float offset_r;
    private static Vector3[] offsets;
    private static PlaceCliffs();
    public virtual void Process(UInt32 seed);
    private CliffPlacement PlaceMale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale);
    private CliffPlacement PlaceFemale(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale);
    private CliffPlacement Place(Prefab[] prefabs, UInt32& seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle, int parentCount, int parentScore);
}
public class PlaceCliffsUniform : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public float ObjectDistance;
    public float ObjectDithering;
    public TerrainAnchorMode AnchorMode;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterMode;
    private static int min_rotation_z;
    private static int max_rotation_z;
    private static int rotation_delta_z;
    private static int min_rotation_x;
    private static int max_rotation_x;
    private static int rotation_delta_x;
    private static PlaceCliffsUniform();
    public virtual void Process(UInt32 seed);
}
public class PlaceDecorUniform : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public float ObjectDistance;
    public float ObjectDithering;
    public TerrainAnchorMode AnchorMode;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterMode;
    public virtual void Process(UInt32 seed);
}
public class PlaceDecorValueNoise : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public NoiseParameters Cluster;
    public float ObjectDensity;
    public TerrainAnchorMode AnchorMode;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterMode;
    public virtual void Process(UInt32 seed);
}
public class PlaceDecorWhiteNoise : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public float ObjectDensity;
    public TerrainAnchorMode AnchorMode;
    [InspectorFlagsAttribute]
public SpawnFilterMode FilterMode;
    public virtual void Process(UInt32 seed);
}
public class PlacementTest : MonoBehaviour {
    public MeshCollider myMeshCollider;
    public Transform testTransform;
    public Transform visualTest;
    public float hemisphere;
    public float clampTest;
    public float testDist;
    private float nextTest;
    public Vector3 RandomHemisphereDirection(Vector3 input, float degreesOffset);
    public Vector3 RandomCylinderPointAroundVector(Vector3 input, float distance, float minHeight, float maxHeight);
    public Vector3 ClampToHemisphere(Vector3 hemiInput, float degreesOffset, Vector3 inputVec);
    private void Update();
    public void OnDrawGizmos();
}
public class PlaceMonument : ProceduralComponent {
    public SpawnFilter Filter;
    public GameObjectRef Monument;
    private static int Attempts;
    public virtual void Process(UInt32 seed);
}
public class PlaceMonuments : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public int TargetCount;
    public AnimationCurve TargetCountWorldSizeMultiplier;
    [FormerlySerializedAsAttribute("MinDistance")]
public int MinDistanceSameType;
    public int MinDistanceDifferentType;
    [FormerlySerializedAsAttribute("MinSize")]
public int MinWorldSize;
    [TooltipAttribute("Distance to monuments of the same type")]
public DistanceMode DistanceSameType;
    [TooltipAttribute("Distance to monuments of a different type")]
public DistanceMode DistanceDifferentType;
    [TooltipAttribute("Enable to only spawn these monuments when running as a nexus")]
public bool NexusOnly;
    public static int GroupCandidates;
    public static int IndividualCandidates;
    public static int Attempts;
    private static int MaxDepth;
    public virtual void Process(UInt32 seed);
    public DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale, Vector3 dungeonPos);
}
public class PlaceMonumentsOffshore : ProceduralComponent {
    public string ResourceFolder;
    public int TargetCount;
    public int MinDistanceFromTerrain;
    public int MaxDistanceFromTerrain;
    public int DistanceBetweenMonuments;
    [FormerlySerializedAsAttribute("MinSize")]
public int MinWorldSize;
    private static int Candidates;
    private static int Attempts;
    public virtual void Process(UInt32 seed);
    public bool CheckRadius(List`1<SpawnInfo> spawns, Vector3 pos, float radius);
}
public class PlaceMonumentsRailside : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public int TargetCount;
    public int PositionOffset;
    public int TangentInterval;
    [FormerlySerializedAsAttribute("MinDistance")]
public int MinDistanceSameType;
    public int MinDistanceDifferentType;
    [FormerlySerializedAsAttribute("MinSize")]
public int MinWorldSize;
    [TooltipAttribute("Distance to monuments of the same type")]
public DistanceMode DistanceSameType;
    [TooltipAttribute("Distance to monuments of a different type")]
public DistanceMode DistanceDifferentType;
    private static int GroupCandidates;
    private static int IndividualCandidates;
    private static Quaternion rot90;
    private static PlaceMonumentsRailside();
    public virtual void Process(UInt32 seed);
    private DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale);
    private float GetDistanceToAboveGroundRail(Vector3 pos);
}
public class PlaceMonumentsRoadside : ProceduralComponent {
    public SpawnFilter Filter;
    public string ResourceFolder;
    public int TargetCount;
    [FormerlySerializedAsAttribute("MinDistance")]
public int MinDistanceSameType;
    public int MinDistanceDifferentType;
    [FormerlySerializedAsAttribute("MinSize")]
public int MinWorldSize;
    [TooltipAttribute("Distance to monuments of the same type")]
public DistanceMode DistanceSameType;
    [TooltipAttribute("Distance to monuments of a different type")]
public DistanceMode DistanceDifferentType;
    public RoadMode RoadType;
    public static int GroupCandidates;
    public static int IndividualCandidates;
    public static Quaternion rot90;
    private static PlaceMonumentsRoadside();
    public virtual void Process(UInt32 seed);
    private DistanceInfo GetDistanceInfo(List`1<SpawnInfo> spawns, Prefab`1<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale);
}
public class PlacePowerlineObjects : ProceduralComponent {
    public BasicObject[] Start;
    public BasicObject[] End;
    public SideObject[] Side;
    [FormerlySerializedAsAttribute("PowerlineObjects")]
public PathObject[] Path;
    public virtual void Process(UInt32 seed);
}
public class PlaceRiverObjects : ProceduralComponent {
    public BasicObject[] Start;
    public BasicObject[] End;
    [FormerlySerializedAsAttribute("RiversideObjects")]
public SideObject[] Side;
    [FormerlySerializedAsAttribute("RiverObjects")]
public PathObject[] Path;
    public virtual void Process(UInt32 seed);
}
public class PlaceRoadObjects : ProceduralComponent {
    public BasicObject[] Start;
    public BasicObject[] End;
    [FormerlySerializedAsAttribute("RoadsideObjects")]
public SideObject[] Side;
    [FormerlySerializedAsAttribute("RoadObjects")]
public PathObject[] Path;
    public virtual void Process(UInt32 seed);
}
public class PlanarReflectionCamera : MonoBehaviour {
    public static PlanarReflectionCamera instance;
    public float updateRate;
    public float nearClipPlane;
    public float farClipPlane;
    public Color fogColor;
    public float fogDensity;
    public Mesh waterPlaneMesh;
    public Material waterPlaneMaterial;
}
public class Planner : HeldEntity {
    public BaseEntity[] buildableList;
    [CompilerGeneratedAttribute]
private Vector3 <serverStartDurationPlacementPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSince <serverStartDurationPlacementTime>k__BackingField;
    public bool isTypeDeployable { get; }
    public Vector3 serverStartDurationPlacementPosition { get; private set; }
    public TimeSince serverStartDurationPlacementTime { get; private set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public ItemModDeployable GetModDeployable();
    public virtual Deployable GetDeployable();
    public virtual Deployable GetDeployable(NetworkableId entityId);
    public virtual bool get_isTypeDeployable();
    [RPC_Server]
[IsActiveItem]
private void DoPlace(RPCMessage msg);
    [CompilerGeneratedAttribute]
public Vector3 get_serverStartDurationPlacementPosition();
    [CompilerGeneratedAttribute]
private void set_serverStartDurationPlacementPosition(Vector3 value);
    [CompilerGeneratedAttribute]
public TimeSince get_serverStartDurationPlacementTime();
    [CompilerGeneratedAttribute]
private void set_serverStartDurationPlacementTime(TimeSince value);
    [RPC_Server]
[CallsPerSecond("10")]
[IsActiveItem]
private void StartDurationPlace(RPCMessage msg);
    public Socket_Base FindSocket(string name, UInt32 prefabIDToFind);
    public virtual void DoBuild(CreateBuilding msg);
    public virtual BaseEntity DoBuild(Target target, Construction component);
    public GameObject DoPlacement(Target placement, Construction component);
    public void PayForPlacement(BasePlayer player, Construction component);
    public bool CanAffordToPlace(Construction component);
    protected void GetConstructionCost(ItemAmountList list, Construction component);
    private bool ShouldParent(BaseEntity targetEntity, Deployable deployable);
    private bool HandleCanBuild(Nullable`1<CanBuildResult> result, BasePlayer player);
    protected virtual bool HasLineOfSight(BasePlayer player, Vector3 deployPos, Target target, Construction component);
}
public class PlanterBox : StorageContainer {
    public int soilSaturation;
    public int soilSaturationMax;
    public MeshRenderer soilRenderer;
    private static float MinimumSaturationTriggerLevel;
    private static float MaximumSaturationTriggerLevel;
    public TimeCachedValue`1<float> sunExposure;
    public TimeCachedValue`1<float> artificialLightExposure;
    public TimeCachedValue`1<float> plantTemperature;
    public TimeCachedValue`1<float> plantArtificalTemperature;
    private TimeSince lastSplashNetworkUpdate;
    private TimeSince lastRainCheck;
    public float soilSaturationFraction { get; }
    public int availableIdealWaterCapacity { get; }
    public int availableWaterCapacity { get; }
    public int idealSaturation { get; }
    public bool BelowMinimumSaturationTriggerLevel { get; }
    public bool AboveMaximumSaturationTriggerLevel { get; }
    private static PlanterBox();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void SetupTimeCaches();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public bool InventoryItemFilter(Item item, int targetSlot);
    public virtual bool CanPickup(BasePlayer player);
    private bool ItemIsFertilizer(Item item);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public float get_soilSaturationFraction();
    public int get_availableIdealWaterCapacity();
    public int get_availableWaterCapacity();
    public int get_idealSaturation();
    public bool get_BelowMinimumSaturationTriggerLevel();
    public bool get_AboveMaximumSaturationTriggerLevel();
    public void FertilizeGrowables();
    public int GetFertilizerCount();
    public bool ConsumeFertilizer();
    public int ConsumeWater(int amount, GrowableEntity ignoreEntity);
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    private void KillAllPlants();
    public virtual void RefreshGrowables(GrowableEntity ignoreEntity);
    public void ForceLightUpdate();
    public void ForceTemperatureUpdate();
    public float GetSunExposure();
    public float CalculateSunExposure();
    public float GetArtificialLightExposure();
    public float CalculateArtificialLightExposure();
    public float GetPlantTemperature();
    public float CalculatePlantTemperature();
    private bool HasPlants();
    public void CalculateRainFactor();
    public float CalculateArtificialTemperature();
    public virtual void OnPlantRemoved(GrowableEntity entity, BasePlayer byPlayer);
    public void OnPlantInserted(GrowableEntity entity, BasePlayer byPlayer);
    [RPC_Server]
[MaxDistance("3")]
private void RPC_RequestSaturationUpdate(RPCMessage msg);
    public virtual bool SupportsChildDeployables();
}
public class PlanterBoxStatic : PlanterBox {
    [ServerVar]
public static float FavourableGeneChance;
    public List`1<GameObjectRef> staticPlantsSpawnlist;
    public bool randomPerSlot;
    public float respawnCheckTimer;
    private static PlanterBoxStatic();
    public virtual void SetupTimeCaches();
    public virtual void RefreshGrowables(GrowableEntity ignoreEntity);
    public virtual void ServerInit();
    public void CreateStaticPlants();
    private GameObjectRef GetRandomStaticPlant();
    private bool IsSpawnPointFreeSearch(Vector3 localPos);
}
[CreateAssetMenuAttribute]
public class PlantProperties : ScriptableObject {
    public Phrase Description;
    public GrowableGeneProperties Genes;
    [ArrayIndexIsEnum]
public Stage[] stages;
    [HeaderAttribute("Metabolism")]
public AnimationCurve timeOfDayHappiness;
    public AnimationCurve temperatureHappiness;
    public AnimationCurve temperatureWaterRequirementMultiplier;
    public AnimationCurve fruitVisualScaleCurve;
    public int MaxSeasons;
    public float WaterIntake;
    public float OptimalLightQuality;
    public float OptimalWaterQuality;
    public float OptimalGroundQuality;
    public float OptimalTemperatureQuality;
    [HeaderAttribute("Harvesting")]
public Option pickOption;
    public Option pickAllOption;
    public Option eatOption;
    public ItemDefinition pickupItem;
    public Option cloneOption;
    public Option cloneAllOption;
    public Option removeDyingOption;
    public Option removeDyingAllOption;
    public ItemDefinition removeDyingItem;
    public GameObjectRef removeDyingEffect;
    public int pickupMultiplier;
    public GameObjectRef pickEffect;
    public int maxHarvests;
    public bool disappearAfterHarvest;
    [HeaderAttribute("Seeds")]
public GameObjectRef CrossBreedEffect;
    public ItemDefinition SeedItem;
    public ItemDefinition CloneItem;
    public int BaseCloneCount;
    [HeaderAttribute("Market")]
public int BaseMarketValue;
}
public class PlantSkin : MonoBehaviour {
}
public class PlatformEntity : BaseEntity {
    private static float movementSpeed;
    private static float rotationSpeed;
    private static float radius;
    private Vector3 targetPosition;
    private Quaternion targetRotation;
    protected void FixedUpdate();
    public virtual float GetNetworkTime();
}
public class PlayAudioEx : MonoBehaviour {
    public float delay;
    private void Start();
    private void OnEnable();
}
public class PlayerAnimationEvents : MonoBehaviour {
}
public class PlayerBelt : object {
    public static int ClientAutoSelectSlot;
    public static UInt32 ClientAutoSeletItemUID;
    public static EncryptedValue`1<int> SelectedSlot;
    protected BasePlayer player;
    public static int MaxBeltSlots { get; }
    public PlayerBelt(BasePlayer player);
    private static PlayerBelt();
    public static int get_MaxBeltSlots();
    public void DropActive(Vector3 position, Vector3 velocity);
    public Item GetItemInSlot(int slot);
    public Handcuffs GetRestraintItem();
}
public class PlayerBlueprints : EntityComponent`1<BasePlayer> {
    public SteamInventory steamInventory;
    public void Reset();
    public void UnlockAll();
    public bool IsUnlocked(ItemDefinition itemDef);
    public void Unlock(ItemDefinition itemDef);
    public bool HasUnlocked(ItemDefinition targetItem);
    public bool CanCraft(int itemid, int skinItemId, ulong playerId);
    public bool CheckSkinOwnership(int skinItemId, ulong playerId);
}
[CreateAssetMenuAttribute]
public class PlayerBonePosData : ScriptableObject {
    public SkeletonDefinition skeletonDef;
    public GameObjectRef playerModel;
    [ReadOnlyAttribute]
public String[] boneNames;
    public BonePosData crawling;
    public BonePosData ducking;
    public BonePosData incapacitated;
    public BonePosData onladder;
    public BonePosData sleeping;
    public BonePosData standing;
    public BonePosData swimming;
    public BonePosData[] mountedPoses;
}
public class PlayerCorpse : LootableCorpse {
    public Buoyancy buoyancy;
    public static Flags Flag_Buoyant;
    public UInt32 underwearSkin;
    public PlayerBonePosData bonePosData;
    [CompilerGeneratedAttribute]
private Ragdoll <CorpseRagdollScript>k__BackingField;
    public static Flags BlockClothingRebuild;
    private Vector3 prevLocalPos;
    private static float SLEEP_CHECK_FREQUENCY;
    public Ragdoll CorpseRagdollScript { get; private set; }
    public bool CorpseIsRagdoll { get; }
    protected float PositionTickRate { get; }
    protected bool PositionTickFixedTime { get; }
    public bool IsBuoyant();
    [CompilerGeneratedAttribute]
public Ragdoll get_CorpseRagdollScript();
    [CompilerGeneratedAttribute]
private void set_CorpseRagdollScript(Ragdoll value);
    public virtual bool get_CorpseIsRagdoll();
    protected virtual float get_PositionTickRate();
    protected virtual bool get_PositionTickFixedTime();
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual void ServerInit();
    public virtual void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, PlayerFlags playerFlagsOnDeath, ModelState modelState);
    private BonePosData GetBonePositionData(PlayerFlags flagsOnDeath, ModelState modelState);
    public void BuoyancyChanged(bool isSubmerged);
    public void BecomeActive();
    public void BecomeInactive();
    protected virtual void PushRagdoll(HitInfo info);
    private void SleepCheck();
    public virtual bool BuoyancySleep(bool inWater);
    public virtual bool BuoyancyWake();
    private void OnPhysicsNeighbourChanged();
    public virtual void Save(SaveInfo info);
    public virtual string Categorize();
}
public class PlayerDetectedAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class PlayerDetectedEventUI : BaseEventUI {
}
public class PlayerDetectionTrigger : TriggerBase {
    public GameObject detector;
    public IDetector _detector;
    private IDetector myDetector { get; }
    private IDetector get_myDetector();
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnObjects();
    internal virtual void OnObjectAdded(GameObject obj, Collider col);
    public virtual void OnEmpty();
}
public class PlayerEyes : EntityComponent`1<BasePlayer> {
    public static Vector3 EyeOffset;
    public static Vector3 DuckOffset;
    public static Vector3 CrawlOffset;
    public static Vector3 ParachuteOffset;
    public Vector3 thirdPersonSleepingOffset;
    public LazyAimProperties defaultLazyAim;
    private EncryptedValue`1<Vector3> viewOffset;
    [CompilerGeneratedAttribute]
private Quaternion <bodyRotation>k__BackingField;
    public Vector3 worldMountedPosition { get; }
    public Vector3 worldStandingPosition { get; }
    public Vector3 worldCrouchedPosition { get; }
    public Vector3 worldCrawlingPosition { get; }
    public Vector3 position { get; }
    private Vector3 BodyLeanOffset { get; }
    public Vector3 center { get; }
    public Vector3 offset { get; }
    public Quaternion rotation { get; public set; }
    public Quaternion bodyRotation { get; public set; }
    public Quaternion parentRotation { get; }
    private static PlayerEyes();
    public Vector3 get_worldMountedPosition();
    public Vector3 get_worldStandingPosition();
    public Vector3 get_worldCrouchedPosition();
    public Vector3 get_worldCrawlingPosition();
    public Vector3 get_position();
    private Vector3 get_BodyLeanOffset();
    public Vector3 get_center();
    public Vector3 get_offset();
    public Quaternion get_rotation();
    public void set_rotation(Quaternion value);
    [CompilerGeneratedAttribute]
public Quaternion get_bodyRotation();
    [CompilerGeneratedAttribute]
public void set_bodyRotation(Quaternion value);
    public Quaternion get_parentRotation();
    public void NetworkUpdate(Quaternion rot);
    public Vector3 MovementForward();
    public Vector3 MovementRight();
    public Ray BodyRay();
    public Vector3 BodyForward();
    public Vector3 BodyRight();
    public Vector3 BodyUp();
    public Ray HeadRay();
    public Vector3 HeadForward();
    public Vector3 HeadRight();
    public Vector3 HeadUp();
    public Quaternion GetLookRotation();
    public Quaternion GetAimRotation();
}
public class PlayerHelicopter : BaseHelicopter {
    [HeaderAttribute("Player Helicopter")]
[SerializeField]
public Wheel[] wheels;
    [SerializeField]
public Transform waterSample;
    public PlayerHeliSounds playerHeliSounds;
    [SerializeField]
private Transform joystickPositionLeft;
    [SerializeField]
private Transform joystickPositionRight;
    [SerializeField]
private Transform passengerJoystickPositionRight;
    [SerializeField]
private Transform leftFootPosition;
    [SerializeField]
private Transform rightFootPosition;
    [SerializeField]
protected Animator animator;
    [SerializeField]
public float maxRotorSpeed;
    [SerializeField]
public float timeUntilMaxRotorSpeed;
    [SerializeField]
private Transform mainRotorBlurBone;
    [SerializeField]
private Renderer mainRotorBlurMesh;
    [SerializeField]
public float rotorBlurThreshold;
    [SerializeField]
private Transform mainRotorBladesBone;
    [SerializeField]
private Renderer[] mainRotorBladeMeshes;
    [SerializeField]
private Transform rearRotorBladesBone;
    [SerializeField]
private Renderer[] rearRotorBladeMeshes;
    [SerializeField]
private Transform rearRotorBlurBone;
    [SerializeField]
private Renderer rearRotorBlurMesh;
    [SerializeField]
public float motorForceConstant;
    [SerializeField]
public float brakeForceConstant;
    [SerializeField]
public float maxPitchAnim;
    [SerializeField]
private GameObject preventBuildingObject;
    [SerializeField]
public float maxRollAnim;
    [SerializeField]
public float maxYawAnim;
    [HeaderAttribute("Fuel")]
[SerializeField]
public GameObjectRef fuelStoragePrefab;
    [SerializeField]
public float fuelPerSec;
    [SerializeField]
public float fuelGaugeMax;
    [ServerVar]
public static float outsidedecayminutes;
    [ServerVar]
public static float insidedecayminutes;
    public VehicleEngineController`1<PlayerHelicopter> engineController;
    public TimeSince timeSinceCachedFuelFraction;
    public float cachedFuelFraction;
    protected static Flags WHEEL_GROUNDED_LR;
    protected static Flags WHEEL_GROUNDED_RR;
    protected static Flags WHEEL_GROUNDED_FRONT;
    protected static Flags RADAR_WARNING_FLAG;
    protected static Flags RADAR_LOCK_FLAG;
    protected static Flags ENGINE_STARTING_FLAG;
    [CompilerGeneratedAttribute]
private float <cachedPitch>k__BackingField;
    [CompilerGeneratedAttribute]
private float <cachedYaw>k__BackingField;
    [CompilerGeneratedAttribute]
private float <cachedRoll>k__BackingField;
    public bool isPushing;
    private Single[] recentVelocities;
    private int recentVelIndex;
    public float lastEngineOnTime;
    public EngineState<PlayerHelicopter> CurEngineState { get; }
    public bool IsStartingUp { get; }
    public float cachedPitch { get; public set; }
    public float cachedYaw { get; public set; }
    public float cachedRoll { get; public set; }
    public SamTargetType SAMTargetType { get; }
    protected bool ForceMovementHandling { get; }
    private static PlayerHelicopter();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public EngineState<PlayerHelicopter> get_CurEngineState();
    public bool get_IsStartingUp();
    public virtual void InitShared();
    public float GetFuelFraction(bool force);
    public virtual bool CanPushNow(BasePlayer pusher);
    public virtual float InheritedVelocityScale();
    public virtual bool InheritedVelocityDirection();
    [CompilerGeneratedAttribute]
public float get_cachedPitch();
    [CompilerGeneratedAttribute]
public void set_cachedPitch(float value);
    [CompilerGeneratedAttribute]
public float get_cachedYaw();
    [CompilerGeneratedAttribute]
public void set_cachedYaw(float value);
    [CompilerGeneratedAttribute]
public float get_cachedRoll();
    [CompilerGeneratedAttribute]
public void set_cachedRoll(float value);
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public sealed virtual SamTargetType get_SAMTargetType();
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual float GetServiceCeiling();
    public virtual float GetMinimumAltitudeTerrain();
    public virtual IFuelSystem GetFuelSystem();
    public virtual int StartingFuelUnits();
    public sealed virtual bool IsValidSAMTarget(bool staticRespawn);
    public virtual void PilotInput(InputState inputState, BasePlayer player);
    public bool IsGrounded();
    public virtual void SetDefaultInputState();
    public void ApplyForceAtWheels();
    public void ApplyForceWithoutWheels();
    public void ApplyWheelForce(WheelCollider wheel, float gasScale, float brakeScale, float turning);
    public virtual void MovementUpdate();
    public virtual void ServerInit();
    public void DecayTick();
    public virtual bool IsEngineOn();
    protected virtual bool get_ForceMovementHandling();
    protected virtual void TryStartEngine(BasePlayer player);
    public sealed virtual bool MeetsEngineRequirements();
    public sealed virtual void OnEngineStartFailed();
    public virtual void VehicleFixedUpdate();
    public void UpdateNetwork();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public void ClearRadarLock();
    public void ClearRadarWarning();
    public void UpdateCOM();
    public virtual void Save(SaveInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual void DoPushAction(BasePlayer player);
    public void DisablePushing();
    public virtual bool IsValidHomingTarget();
    [RPC_Server]
[IsVisible("6")]
public void RPC_OpenFuel(RPCMessage msg);
    public virtual bool ShouldDisableTransferProtectionOnLoad(BasePlayer player);
    public virtual void DisableTransferProtection();
    private void SwapDriverIfInactive();
    protected virtual void ApplyHandbrake();
    private void SetWheelFrictionMultiplier(WheelCollider wheel, float multiplier);
    private sealed virtual override void IEngineControllerUser.Invoke(Action action, float time);
    private sealed virtual override void IEngineControllerUser.CancelInvoke(Action action);
    [CompilerGeneratedAttribute]
private BasePlayer <SwapDriverIfInactive>g__FindActivePassenger|106_0();
    [CompilerGeneratedAttribute]
internal static bool <SwapDriverIfInactive>g__IsPlayerActive|106_1(BasePlayer player);
}
public class PlayerHeliSounds : MonoBehaviour {
    [FormerlySerializedAsAttribute("miniCopter")]
public PlayerHelicopter miniCopter;
    public GameObject soundAttachPoint;
    public List`1<FlightSoundLayer> flightSoundLayers;
    public SoundDefinition engineStartDef;
    public SoundDefinition engineLoopDef;
    public SoundDefinition engineStopDef;
    public SoundDefinition rotorLoopDef;
    public SoundDefinition radarWarningDef;
    public SoundDefinition radarLockDef;
    public SoundDefinition noAmmoDef;
    public SoundDefinition noFlaresDef;
    public SoundDefinition flaresReadyDef;
    public SoundDefinition flightControlMovementSoundDef;
    public GameObject flightControlSoundPosition;
    public float engineStartFadeOutTime;
    public float engineLoopFadeInTime;
    public float engineLoopFadeOutTime;
    public float engineStopFadeOutTime;
    public float rotorLoopFadeInTime;
    public float rotorLoopFadeOutTime;
    public float enginePitchInterpRate;
    public float rotorPitchInterpRate;
    public float rotorGainInterpRate;
    public float rotorStartStopPitchRateUp;
    public float rotorStartStopPitchRateDown;
    public float rotorStartStopGainRateUp;
    public float rotorStartStopGainRateDown;
    public AnimationCurve engineUpDotPitchCurve;
    public AnimationCurve rotorUpDotPitchCurve;
    public Animator animator;
    public SoundDefinition reloadStartSoundDef;
    public SoundDefinition reloadLoopSoundDef;
    public SoundDefinition reloadFinishSoundDef;
}
public class PlayerIdleAnimationRandomiser : StateMachineBehaviour {
    public int MaxValue;
    public static int Param_Random;
    private TimeSince lastRandomisation;
    private static PlayerIdleAnimationRandomiser();
}
public class PlayerInput : EntityComponent`1<BasePlayer> {
    public InputState state;
    public bool hadInputBuffer;
    protected void OnDisable();
}
public class PlayerInventory : EntityComponent`1<BasePlayer> {
    public ItemContainer containerMain;
    public ItemContainer containerBelt;
    public ItemContainer containerWear;
    public ItemCrafter crafting;
    public PlayerLoot loot;
    public static Phrase BackpackGroundedError;
    public float inventoryRadioactivity;
    public bool containsRadioactiveItems;
    [CompilerGeneratedAttribute]
private Action`2<float, bool> onRadioactivityChanged;
    private Action _deferredServerUpdateAction;
    private List`1<Item> returnItems;
    [ServerVar]
public static bool forceBirthday;
    private static float nextCheckTime;
    private static bool wasBirthday;
    private Action DeferredServerUpdateAction { get; }
    private static PlayerInventory();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public void add_onRadioactivityChanged(Action`2<float, bool> value);
    [CompilerGeneratedAttribute]
public void remove_onRadioactivityChanged(Action`2<float, bool> value);
    protected void Initialize(BasePlayer owner);
    public void DoDestroy();
    public void SetLockedByRestraint(bool flag);
    public void ServerInit(BasePlayer owner);
    public void OnItemAddedOrRemoved(Item item, bool bAdded);
    private void OnBeltItemAddedOrRemoved(Item item, bool added);
    public void UpdatedVisibleHolsteredItems();
    public void AddBackpackContentsToList(List`1<Item> items);
    public void OnContentsDirty();
    public bool CanMoveItemsFrom(BaseEntity entity, Item item);
    [FromOwner]
[RPC_Server]
private void ItemCmd(RPCMessage msg);
    [RPC_Server]
[FromOwner]
public void MoveItem(RPCMessage msg);
    private Action get_DeferredServerUpdateAction();
    public void OnClothingChanged(Item item, bool bAdded);
    private void DeferredServerUpdate();
    public void OnItemRemoved(Item item);
    public bool CanStoreInInventory(Item item, int targetSlot);
    public bool CanEquipItem(Item item, int targetSlot);
    public bool CanWearItem(Item item, int targetSlot);
    public bool CanWearItem(Item item, bool canAdjustClothing, int targetSlot);
    public bool CanReplaceBackpack(Item itemToWear);
    public void ServerUpdate(float delta);
    public void UpdateContainer(float delta, Type type, ItemContainer container, bool bSendInventoryToEveryone, float temperature);
    public void SendSnapshot();
    public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone);
    public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode);
    private WearCheckResult WearItemCheck(Item item, bool canAdjustClothing, int targetSlot, bool dontMove);
    public sealed virtual Item FindItemByUID(ItemId id);
    public Item FindItemByItemID(string itemName);
    public sealed virtual Item FindItemByItemID(int id);
    public sealed virtual Item FindItemByItemName(string name);
    public Item FindBySubEntityID(NetworkableId subEntityID);
    public sealed virtual List`1<Item> FindItemsByItemID(int id);
    public ItemContainer FindContainer(ItemContainerId id);
    public ItemContainer GetContainer(Type id);
    public Item GetAnyBackpack();
    public bool HasBackpackItem();
    public Item GetBackpackWithInventory();
    public void DropBackpackOnDeath();
    public Item GetEquippedPrisonerHoodItem();
    public Item GetUsableHoodItem();
    public sealed virtual bool GiveItem(Item item, ItemContainer container);
    public bool GiveItem(Item item, ItemMoveModifier modifiers, ItemContainer container);
    public ItemContainer GetIdealPickupContainer(Item item, bool tryWearClothing);
    public void Strip();
    public static bool IsBirthday();
    public static bool IsChristmas();
    public void GiveDefaultItems();
    public bool CanEquipParachute();
    public PlayerInventory Save(bool bForDisk);
    public void Load(PlayerInventory msg);
    public void TryDropBackpack();
    public int Take(List`1<Item> collect, int itemid, int amount);
    public bool HasEmptySlotInBeltOrMain();
    public bool HasEmptySlots(int requiredSlots);
    public int GetAmount(ItemDefinition definition);
    public int GetAmount(int itemid);
    public int GetOkConditionAmount(int itemid);
    public bool Contains(Item item);
    public int GetAllItems(List`1<Item> items);
    public sealed virtual Item FindAmmo(AmmoTypes ammoType);
    public sealed virtual void FindAmmo(List`1<Item> list, AmmoTypes ammoType);
    public sealed virtual bool HasAmmo(AmmoTypes ammoType);
    private void OnItemRadiationChanged(Item item, float rads);
    private void CalculateInventoryRadioactivity();
    private void CalculateInventoryRadioactivityCheckFast();
    [CompilerGeneratedAttribute]
private void <GiveDefaultItems>g__GiveDefaultItemWithSkin|69_0(string convarSkinName, string itemShortName);
}
public static class PlayerInventoryErrors : object {
    public static Phrase InvalidItem;
    public static Phrase CannotMoveItem;
    public static Phrase ContainerLocked;
    public static Phrase InvalidContainer;
    public static Phrase DoesntAcceptPlayerItems;
    public static Phrase CannotEquipBroken;
    public static Phrase ActiveItemBroken;
    public static Phrase LootableDoesntExist;
    private static PlayerInventoryErrors();
}
[CreateAssetMenuAttribute]
public class PlayerInventoryProperties : BaseScriptableObject {
    public string niceName;
    public int order;
    public List`1<ItemAmountSkinned> belt;
    public List`1<ItemAmountSkinned> main;
    public List`1<ItemAmountSkinned> wear;
    public PlayerInventoryProperties giveBase;
    private static PlayerInventoryProperties[] allInventories;
    public void GiveToPlayer(BasePlayer player);
    public static PlayerInventoryProperties GetInventoryConfig(string name);
    [CompilerGeneratedAttribute]
internal static void <GiveToPlayer>g__CreateItem|7_0(ItemAmountSkinned toCreate, ItemContainer destination, <>c__DisplayClass7_0& );
}
public class PlayerLoot : EntityComponent`1<BasePlayer> {
    public BaseEntity entitySource;
    public Item itemSource;
    public List`1<ItemContainer> containers;
    public bool PositionChecks;
    private bool isInvokingSendUpdate;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsLooting();
    public float GetRadsInPlayerLoot();
    public void Clear();
    public ItemContainer FindContainer(ItemContainerId id);
    public Item FindItem(ItemId id);
    public void Check();
    public void MarkDirty();
    public void SendImmediate();
    private void SendUpdate();
    public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks);
    public void AddContainer(ItemContainer container);
    public void RemoveContainer(ItemContainer container);
    public bool RemoveContainerAt(int index);
    public void StartLootingItem(Item item);
    private void ClearContainers();
}
public class PlayerMetabolism : BaseMetabolism`1<BasePlayer> {
    public static float HotThreshold;
    public static float ColdThreshold;
    public static float OxygenHurtThreshold;
    public static float OxygenDepleteTime;
    public static float OxygenRefillTime;
    public MetabolismAttribute temperature;
    public MetabolismAttribute poison;
    public MetabolismAttribute radiation_level;
    public MetabolismAttribute radiation_poison;
    public MetabolismAttribute wetness;
    public MetabolismAttribute dirtyness;
    public MetabolismAttribute oxygen;
    public MetabolismAttribute bleeding;
    public MetabolismAttribute comfort;
    public MetabolismAttribute pending_health;
    public bool isDirty;
    private float lastConsumeTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Reset();
    public virtual void ServerUpdate(BaseCombatEntity ownerEntity, float delta);
    internal bool HasChanged();
    protected virtual void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta);
    public bool SignificantBleeding();
    public void ForceUpdateWorkbenchFlags();
    private void UpdateWorkbenchFlags();
    protected virtual void RunMetabolism(BaseCombatEntity ownerEntity, float delta);
    private float DeltaHot();
    private float DeltaCold();
    private float DeltaWet();
    public void UseHeart(float frate);
    public void SendChangesToClient();
    public virtual void ApplyChange(Type type, float amount, float time);
    public bool CanConsume();
    public void MarkConsumption();
    public PlayerMetabolism Save();
    public void Load(PlayerMetabolism s);
    public void SetAttribute(Type type, float amount);
    public virtual MetabolismAttribute FindAttribute(Type type);
}
public class PlayerModel : ListComponent`1<PlayerModel> {
    protected static int speed;
    protected static int acceleration;
    protected static int rotationYaw;
    protected static int forward;
    protected static int right;
    protected static int up;
    protected static int ducked;
    protected static int grounded;
    protected static int crawling;
    protected static int waterlevel;
    protected static int attack;
    protected static int attack_alt;
    protected static int deploy;
    protected static int turnOn;
    protected static int turnOff;
    protected static int reload;
    protected static int throwWeapon;
    protected static int holster;
    protected static int aiming;
    protected static int onLadder;
    protected static int posing;
    protected static int poseType;
    protected static int relaxGunPose;
    protected static int vehicle_aim_yaw;
    protected static int vehicle_aim_speed;
    protected static int usePoseTransition;
    protected static int onPhone;
    protected static int leftFootIK;
    protected static int rightFootIK;
    protected static int vehicleSteering;
    protected static int sitReaction;
    protected static int forwardReaction;
    protected static int rightReaction;
    protected static int ladderType;
    protected static int hasParachute;
    protected static int nonGroundedTime;
    protected static int deployParachuteTrigger;
    public BoxCollider collision;
    public GameObject censorshipCube;
    public GameObject censorshipCubeBreasts;
    public GameObject jawBone;
    public GameObject neckBone;
    public GameObject headBone;
    public EyeController eyeController;
    public EyeBlink blinkController;
    public Transform[] SpineBones;
    public Transform leftFootBone;
    public Transform rightFootBone;
    public Transform leftHandPropBone;
    public Transform rightHandPropBone;
    public Vector3 rightHandTarget;
    public bool isPreview;
    [HeaderAttribute("IK")]
public Vector3 leftHandTargetPosition;
    public Quaternion leftHandTargetRotation;
    public Vector3 rightHandTargetPosition;
    public Quaternion rightHandTargetRotation;
    public float steeringTargetDegrees;
    public Vector3 rightFootTargetPosition;
    public Quaternion rightFootTargetRotation;
    public Vector3 leftFootTargetPosition;
    public Quaternion leftFootTargetRotation;
    public RuntimeAnimatorController CinematicAnimationController;
    public Avatar DefaultAvatar;
    public Avatar CinematicAvatar;
    public RuntimeAnimatorController DefaultHoldType;
    public RuntimeAnimatorController SleepGesture;
    public RuntimeAnimatorController CrawlToIncapacitatedGesture;
    public RuntimeAnimatorController CrawlToIncapacitatedGestureHandcuff;
    public RuntimeAnimatorController StandToIncapacitatedGesture;
    public RuntimeAnimatorController CurrentGesture;
    [HeaderAttribute("Skin")]
public SkinSetCollection MaleSkin;
    public SkinSetCollection FemaleSkin;
    public SubsurfaceProfile subsurfaceProfile;
    [HeaderAttribute("Parameters")]
[RangeAttribute("0", "1")]
public float voiceVolume;
    [RangeAttribute("0", "1")]
public float skinColor;
    [RangeAttribute("0", "1")]
public float skinNumber;
    [RangeAttribute("0", "1")]
public float meshNumber;
    [RangeAttribute("0", "1")]
public float hairNumber;
    [RangeAttribute("0", "1")]
public int skinType;
    public MovementSounds movementSounds;
    public bool showSash;
    public int tempPoseType;
    public UInt32 underwearSkin;
    [CompilerGeneratedAttribute]
private ulong <overrideSkinSeed>k__BackingField;
    [CompilerGeneratedAttribute]
private Quaternion <AimAngles>k__BackingField;
    [CompilerGeneratedAttribute]
private Quaternion <LookAngles>k__BackingField;
    public Transform[] Shoulders;
    public Transform[] AdditionalSpineBones;
    public ulong overrideSkinSeed { get; private set; }
    public bool IsFemale { get; }
    public SkinSetCollection SkinSet { get; }
    public Quaternion AimAngles { get; public set; }
    public Quaternion LookAngles { get; public set; }
    private static PlayerModel();
    private static Vector3 GetFlat(Vector3 dir);
    public static void RebuildAll();
    [CompilerGeneratedAttribute]
public ulong get_overrideSkinSeed();
    [CompilerGeneratedAttribute]
private void set_overrideSkinSeed(ulong value);
    public bool get_IsFemale();
    public SkinSetCollection get_SkinSet();
    [CompilerGeneratedAttribute]
public Quaternion get_AimAngles();
    [CompilerGeneratedAttribute]
public void set_AimAngles(Quaternion value);
    [CompilerGeneratedAttribute]
public Quaternion get_LookAngles();
    [CompilerGeneratedAttribute]
public void set_LookAngles(Quaternion value);
}
public class PlayerModelCinematicList : PrefabAttribute {
    public PlayerModelCinematicAnimation[] Animations;
    protected virtual Type GetIndexedType();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class PlayerModelHair : MonoBehaviour {
    public HairType type;
    private Dictionary`2<Renderer, RendererMaterials> materials;
    public Dictionary`2<Renderer, RendererMaterials> Materials { get; }
    public Dictionary`2<Renderer, RendererMaterials> get_Materials();
    private void CacheOriginalMaterials();
    private void Setup(HairType type, HairSetCollection hair, int meshIndex, float typeNum, float dyeNum, MaterialPropertyBlock block);
    public void Setup(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block);
    public static void GetRandomVariation(float hairNum, int typeIndex, int meshIndex, Single& typeNum, Single& dyeNum);
    public static float GetRandomHairType(float hairNum, int typeIndex);
}
public class PlayerModelHairCap : MonoBehaviour {
    [InspectorFlagsAttribute]
public HairCapMask hairCapMask;
    public void SetupHairCap(SkinSetCollection skin, float hairNum, float meshNum, MaterialPropertyBlock block);
}
public class PlayerModelReactionEnded : StateMachineBehaviour {
}
public class PlayerModelSkin : MonoBehaviour {
    public SkinMaterialType MaterialType;
    public Renderer SkinRenderer;
    public void Setup(SkinSetCollection skin, float hairNum, float meshNum);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class PlayerModifiers : BaseModifiers`1<BasePlayer> {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerUpdate(BaseCombatEntity ownerEntity);
    public PlayerModifiers Save();
    public void Load(PlayerModifiers m);
    public void SendChangesToClient();
}
public class PlayerNameTag : MonoBehaviour {
    public CanvasGroup canvasGroup;
    public Text text;
    public Gradient color;
    public float minDistance;
    public float maxDistance;
    public Vector3 positionOffset;
    public Transform parentBone;
}
public static class PlayerNetworkingProfiler : object {
    public static int level;
    public static TimeSpan MinFlushInterval;
    public static int ConnectionsPerFrame;
    private static int currentIndex;
    private static DateTime flushCooldown;
    private static PlayerNetworkingProfiler();
    public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp);
    private static void SerializeRaknet(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, Server server);
}
public class PlayerStateManager : object {
    private MruDictionary`2<ulong, PlayerState> _cache;
    private UserPersistance _persistence;
    public int CacheSize { get; public set; }
    public int CacheCount { get; }
    public long CacheEvictions { get; }
    public PlayerStateManager(UserPersistance persistence);
    public PlayerState Get(ulong playerId);
    public void Save(ulong playerId);
    private void SaveState(ulong playerId, PlayerState state);
    private void FreeOldState(ulong playerId, PlayerState state);
    public void Reset(ulong playerId);
    private void OnPlayerStateLoaded(PlayerState state);
    public int get_CacheSize();
    public void set_CacheSize(int value);
    public int get_CacheCount();
    public long get_CacheEvictions();
}
public class PlayerStatistics : object {
    public SteamStatistics steam;
    public ServerStatistics server;
    public CombatLog combat;
    public BasePlayer forPlayer;
    private TimeSince lastSteamSave;
    public PlayerStatistics(BasePlayer player);
    public void Init();
    public void Save(bool forceSteamSave);
    public void Add(string name, int val, Stats stats);
}
public class PlayerVoiceRecorder : EntityComponent`1<BasePlayer> {
}
public class PlayerVoiceSpeaker : EntityComponent`1<BasePlayer> {
    public VoiceProcessor voiceProcessor;
}
public class PlayerWalkMovement : BaseMovement {
    public static float WaterLevelHead;
    public static float WaterLevelNeck;
    public PhysicMaterial zeroFrictionMaterial;
    public PhysicMaterial highFrictionMaterial;
    public float capsuleHeight;
    public float capsuleCenter;
    public float capsuleHeightDucked;
    public float capsuleCenterDucked;
    public float capsuleHeightCrawling;
    public float capsuleCenterCrawling;
    public float gravityTestRadius;
    public float gravityMultiplier;
    public float gravityMultiplierSwimming;
    public float maxAngleWalking;
    public float maxAngleClimbing;
    public float maxAngleSliding;
    public float maxStepHeight;
}
public class PlayingCardSprite : MonoBehaviour {
    [SerializeField]
private Image image;
    [SerializeField]
private Animation anim;
}
public class PlayingCardsViewmodel : MonoBehaviour {
    [SerializeField]
private Canvas cardUICanvas;
    [SerializeField]
private Image cardA;
    [SerializeField]
private Image cardB;
    [SerializeField]
private Sprite blankCard;
}
public class PointEntity : BaseEntity {
}
public class PointOfInterestMapMarker : MonoBehaviour {
    public Image MapIcon;
    public Image MapIconOuter;
    public GameObject LeaderRoot;
    public GameObject EditPopup;
    public Tooltip Tooltip;
    public GameObject MarkerLabelRoot;
    public RustText MarkerLabel;
    public RustText NoMarkerLabel;
    public RustInput MarkerLabelModify;
    public MapMarkerIconSelector[] IconSelectors;
    public MapMarkerIconSelector[] ColourSelectors;
    public bool IsListWidget;
    public GameObject DeleteButton;
}
public class Polarbear : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Polarbear();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public class Poolable : MonoBehaviour {
    [HideInInspector]
public UInt32 prefabID;
    [HideInInspector]
public Behaviour[] behaviours;
    [HideInInspector]
public Rigidbody[] rigidbodies;
    [HideInInspector]
public Collider[] colliders;
    [HideInInspector]
public LODGroup[] lodgroups;
    [HideInInspector]
public Renderer[] renderers;
    [HideInInspector]
public ParticleSystem[] particles;
    [HideInInspector]
public Boolean[] behaviourStates;
    [HideInInspector]
public Boolean[] rigidbodyStates;
    [HideInInspector]
public Boolean[] colliderStates;
    [HideInInspector]
public Boolean[] lodgroupStates;
    [HideInInspector]
public Boolean[] rendererStates;
    public int ClientCount { get; }
    public int ServerCount { get; }
    public int get_ClientCount();
    public int get_ServerCount();
    public sealed virtual void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void Initialize(UInt32 id);
    public void EnterPool();
    public void LeavePool();
    public void SetBehaviourEnabled(bool state);
    public void SetComponentEnabled(bool state);
}
[ExtensionAttribute]
public static class PoolableEx : object {
    [ExtensionAttribute]
public static bool SupportsPoolingInParent(GameObject gameObject);
    [ExtensionAttribute]
public static bool SupportsPooling(GameObject gameObject);
    [ExtensionAttribute]
public static void AwakeFromInstantiate(GameObject gameObject);
}
public class PooledList`1 : object {
    public List`1<T> data;
    public void Alloc();
    public void Free();
    public void Clear();
}
public class PositionLerp : object {
    private static ListHashSet`1<PositionLerp> InstanceList;
    public static bool DebugLog;
    public static bool DebugDraw;
    public static int TimeOffsetInterval;
    public static float TimeOffset;
    public static int TimeOffsetIntervalMin;
    public static int TimeOffsetIntervalMax;
    private bool enabled;
    private Action idleDisable;
    private Interpolator`1<TransformSnapshot> interpolator;
    private IPosLerpTarget target;
    private static TransformSnapshot snapshotPrototype;
    private float timeOffset0;
    private float timeOffset1;
    private float timeOffset2;
    private float timeOffset3;
    private int timeOffsetCount;
    private float lastClientTime;
    private float lastServerTime;
    private float extrapolatedTime;
    private float enabledTime;
    public bool Enabled { get; public set; }
    public static float LerpTime { get; }
    private static PositionLerp();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public static float get_LerpTime();
    private void OnEnable();
    private void OnDisable();
    public void Initialize(IPosLerpTarget target);
    public void Snapshot(Vector3 position, Quaternion rotation, float serverTime);
    public void Snapshot(Vector3 position, Quaternion rotation);
    public void SnapTo(Vector3 position, Quaternion rotation, float serverTime);
    public void SnapTo(Vector3 position, Quaternion rotation);
    public void SnapToEnd();
    public void Wipe();
    public static void WipeAll();
    protected void DoCycle();
    public void TransformEntries(Matrix4x4 matrix);
    public Quaternion GetEstimatedAngularVelocity();
    public Vector3 GetEstimatedVelocity();
    private sealed virtual override void Facepunch.Pool.IPooled.EnterPool();
    private sealed virtual override void Facepunch.Pool.IPooled.LeavePool();
    public static void Clear();
    public static void Cycle();
}
[BurstCompileAttribute]
public class PostCullingJob : ValueType {
    [ReadOnlyAttribute]
public NativeArray`1<int> CountPerMesh;
    [ReadOnlyAttribute]
public int RendererCount;
    [ReadOnlyAttribute]
public NativeArray`1<InstancedRendererJobData> Renderers;
    [WriteOnlyAttribute]
public JobInt PostCullMeshCount;
    [WriteOnlyAttribute]
public JobInt PostCullShadowCount;
    public sealed virtual void Execute();
}
[RequireComponent("CommandBufferManager")]
[ExecuteInEditMode]
public class PostOpaqueDepth : MonoBehaviour {
    public RenderTexture postOpaqueDepth;
    public RenderTexture PostOpaque { get; }
    public RenderTexture get_PostOpaque();
}
public class PostProcessVolumeLOD : MonoBehaviour {
    public float distance;
}
[DisallowMultipleComponent]
public class PostUpdateHook : MonoBehaviour {
    public static Action OnUpdate;
    public static Action OnLateUpdate;
    public static Action OnFixedUpdate;
    public static Action EndOfFrame;
    private void Update();
    private void LateUpdate();
    private void FixedUpdate();
    private void Start();
    [IteratorStateMachineAttribute("PostUpdateHook/<EndOfFrameRoutine>d__8")]
private IEnumerator EndOfFrameRoutine();
}
public class PowerBar : MonoBehaviour {
    public static PowerBar Instance;
    public Image powerInner;
    public float fullSize;
    public CanvasGroup group;
}
public class PowerCounter : IOEntity {
    public int counterNumber;
    public int targetCounterNumber;
    public Canvas canvas;
    public CanvasGroup screenAlpha;
    public Text screenText;
    public static Flags Flag_ShowPassthrough;
    public GameObjectRef counterConfigPanel;
    public Color passthroughColor;
    public Color counterColor;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool DisplayPassthrough();
    public bool DisplayCounter();
    public bool CanPlayerAdmin(BasePlayer player);
    public int GetTarget();
    public virtual void ResetState();
    public virtual int ConsumptionAmount();
    [IsVisible("3")]
[RPC_Server]
public void SERVER_SetTarget(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void ToggleDisplayMode(RPCMessage msg);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
    public virtual void Save(SaveInfo info);
    public void SetCounterNumber(int newNumber);
    public virtual void SendIONetworkUpdate();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public virtual void Load(LoadInfo info);
}
public class PoweredLightsDeployer : HeldEntity {
    public GameObjectRef poweredLightsPrefab;
    public EntityRef activeLights;
    public MaterialReplacement guide;
    public GameObject guideObject;
    public float maxPlaceDistance;
    public float lengthPerAmount;
    private static int placementLayerMask;
    public AdvancedChristmasLights active { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool CheckValidPlacement(Vector3 position, float radius, int layerMask);
    public static bool CanPlayerUse(BasePlayer player);
    public AdvancedChristmasLights get_active();
    public void set_active(AdvancedChristmasLights value);
    [IsActiveItem]
[RPC_Server]
public void AddPoint(RPCMessage msg);
    [RPC_Server]
[IsActiveItem]
public void Finish(RPCMessage msg);
    public void DoFinish();
    public virtual void OnHeldChanged();
    public virtual void Save(SaveInfo info);
}
public class PoweredRemoteControlEntity : IOEntity {
    public string rcIdentifier;
    public Transform viewEyes;
    public GameObjectRef IDPanelPrefab;
    public RemoteControllableControls rcControls;
    public bool isStatic;
    public bool appendEntityIDToIdentifier;
    [CompilerGeneratedAttribute]
private int <ViewerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField;
    public bool RequiresMouse { get; }
    public float MaxRange { get; }
    public RemoteControllableControls RequiredControls { get; }
    public bool CanPing { get; }
    protected bool EntityCanPing { get; }
    public bool CanAcceptInput { get; }
    public int ViewerCount { get; public set; }
    public Nullable`1<CameraViewerId> ControllingViewerId { get; public set; }
    public bool IsBeingControlled { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsStatic();
    public virtual bool get_RequiresMouse();
    public virtual float get_MaxRange();
    public sealed virtual RemoteControllableControls get_RequiredControls();
    public sealed virtual bool get_CanPing();
    protected virtual bool get_EntityCanPing();
    public virtual bool get_CanAcceptInput();
    [CompilerGeneratedAttribute]
public int get_ViewerCount();
    [CompilerGeneratedAttribute]
public void set_ViewerCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<CameraViewerId> get_ControllingViewerId();
    [CompilerGeneratedAttribute]
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value);
    public bool get_IsBeingControlled();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public void UpdateRCAccess(bool isOnline);
    public virtual void Spawn();
    public virtual bool InitializeControl(CameraViewerId viewerID);
    public virtual void StopControl(CameraViewerId viewerID);
    public virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public sealed virtual Transform GetEyes();
    public virtual float GetFovScale();
    public virtual bool CanControl(ulong playerID);
    public sealed virtual BaseEntity GetEnt();
    public virtual void RCSetup();
    public virtual void RCShutdown();
    [RPC_Server]
[MaxDistance("3")]
public void Server_SetID(RPCMessage msg);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public sealed virtual void UpdateIdentifier(string newID, bool clientSend);
    public sealed virtual string GetIdentifier();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public bool CanChangeID(BasePlayer player);
}
public class PoweredWaterPurifier : WaterPurifier {
    public float ConvertInterval;
    public int PowerDrain;
    public Material PoweredMaterial;
    public Material UnpoweredMaterial;
    public MeshRenderer TargetRenderer;
    public virtual void ResetState();
    public virtual bool CanPickup(BasePlayer player);
    protected virtual void SpawnStorageEnt(bool load);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    private void ConvertWater();
    public virtual int ConsumptionAmount();
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class PowerlineNode : MonoBehaviour {
    public GameObjectRef WirePrefab;
    public float MaxDistance;
    protected void Awake();
}
[AddComponentMenu("Procedural/Mega Wire")]
public class PowerLineWire : MonoBehaviour {
    public List`1<Transform> poles;
    public List`1<PowerLineWireConnectionDef> connections;
    public List`1<PowerLineWireSpan> spans;
    public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper);
    public static PowerLineWire Create(PowerLineWire wire, List`1<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str);
    public void Init();
}
public class PowerLineWireConnection : object {
    public Vector3 inOffset;
    public Vector3 outOffset;
    public float radius;
    public Transform start;
    public Transform end;
}
public class PowerLineWireConnectionDef : object {
    public Vector3 inOffset;
    public Vector3 outOffset;
    public float radius;
    public bool hidden;
    public PowerLineWireConnectionDef(PowerLineWireConnectionDef src);
}
[AddComponentMenu("Mega Wire/Connection Helper")]
public class PowerLineWireConnectionHelper : MonoBehaviour {
    public List`1<PowerLineWireConnectionDef> connections;
    public bool showgizmo;
}
public class PowerLineWireSpan : MonoBehaviour {
    public GameObjectRef wirePrefab;
    public Transform start;
    public Transform end;
    public float WireLength;
    public List`1<PowerLineWireConnection> connections;
    public void Init(PowerLineWire wire);
}
public class Prefab : object {
    public UInt32 ID;
    public string Name;
    public string Folder;
    public GameObject Object;
    public GameManager Manager;
    public Library Attribute;
    public PrefabParameters Parameters;
    public int SpawnedCount;
    private TerrainAnchor[] cachedTerrainAnchors;
    private TerrainCheck[] cachedTerrainChecks;
    private TerrainFilter[] cachedTerrainFilters;
    private TerrainModifier[] cachedTerrainModifiers;
    private TerrainPlacement[] cachedTerrainPlacements;
    private WaterCheck[] cachedWaterChecks;
    private BoundsCheck[] cachedBoundsChecks;
    private DecorComponent[] cachedDecorComponents;
    public static Library DefaultAttribute { get; }
    public static GameManager DefaultManager { get; }
    public Prefab(string name, GameObject prefab, GameManager manager, Library attribute);
    public static GameObject op_Implicit(Prefab prefab);
    public sealed virtual int CompareTo(Prefab that);
    private int PriorityCompare(Prefab that);
    public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter);
    public bool ApplyTerrainAnchors(Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter);
    public bool ApplyTerrainChecks(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter);
    public bool ApplyTerrainFilters(Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter);
    public void ApplyTerrainModifiers(Vector3 pos, Quaternion rot, Vector3 scale);
    public void ApplyTerrainPlacements(Vector3 pos, Quaternion rot, Vector3 scale);
    public bool ApplyWaterChecks(Vector3 pos, Quaternion rot, Vector3 scale);
    public bool ApplyBoundsChecks(Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer);
    public void ApplyDecorComponents(Vector3& pos, Quaternion& rot, Vector3& scale);
    public bool CheckEnvironmentVolumes(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type);
    public bool CheckEnvironmentVolumesInsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding);
    public bool CheckEnvironmentVolumesOutsideTerrain(Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type, float padding);
    public void ApplySequenceReplacement(List`1<Prefab> sequence, Prefab& replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position);
    public GameObject Spawn(Transform transform, bool active);
    public GameObject Spawn(Vector3 pos, Quaternion rot, bool active);
    public GameObject Spawn(Vector3 pos, Quaternion rot, Vector3 scale, bool active);
    public BaseEntity SpawnEntity(Vector3 pos, Quaternion rot, bool active);
    public static Prefab`1<T> Load(UInt32 id, GameManager manager, Library attribute);
    public static Prefab Load(UInt32 id, GameManager manager, Library attribute);
    public static Prefab[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities, bool useWorldConfig);
    public static Prefab`1[] Load(string folder, GameManager manager, Library attribute, bool useProbabilities, bool useWorldConfig);
    public static Prefab`1[] Load(String[] names, GameManager manager, Library attribute);
    public static Prefab LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities);
    public static Prefab`1<T> LoadRandom(string folder, UInt32& seed, GameManager manager, Library attribute, bool useProbabilities);
    public static Library get_DefaultAttribute();
    public static GameManager get_DefaultManager();
    private static String[] FindPrefabNames(string strPrefab, bool useProbabilities, bool useWorldConfig);
}
public class Prefab`1 : Prefab {
    public T Component;
    public Prefab`1(string name, GameObject prefab, T component, GameManager manager, Library attribute);
    public sealed virtual int CompareTo(Prefab`1<T> that);
}
public abstract class PrefabAttribute : MonoBehaviour {
    public Vector3 worldPosition;
    public Quaternion worldRotation;
    public Vector3 worldForward;
    public Vector3 localPosition;
    public Vector3 localScale;
    public Quaternion localRotation;
    public string fullName;
    public string hierachyName;
    public UInt32 prefabID;
    public int instanceID;
    public Library prefabAttribute;
    public GameManager gameManager;
    public bool isServer;
    public static Library server;
    public bool isClient { get; }
    private static PrefabAttribute();
    public bool get_isClient();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    protected abstract virtual Type GetIndexedType();
    public static bool op_Equality(PrefabAttribute x, PrefabAttribute y);
    public static bool op_Inequality(PrefabAttribute x, PrefabAttribute y);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Implicit(PrefabAttribute exists);
    internal static bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y);
    public virtual string ToString();
}
public class PrefabInformation : PrefabAttribute {
    public ItemDefinition associatedItemDefinition;
    public Phrase title;
    public Phrase description;
    public Sprite sprite;
    public bool shownOnDeathScreen;
    protected virtual Type GetIndexedType();
}
public class PrefabInstantiate : MonoBehaviour {
    public GameObjectRef Prefab;
}
public class PrefabParameters : MonoBehaviour {
    public PrefabPriority Priority;
    public int Count;
}
public class PrefabPool : object {
    public Stack`1<Poolable> stack;
    [CompilerGeneratedAttribute]
private string <PrefabName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Missed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pushed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Popped>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TargetCapacity>k__BackingField;
    public string PrefabName { get; private set; }
    public int Missed { get; private set; }
    public int Pushed { get; private set; }
    public int Popped { get; private set; }
    public int Count { get; }
    public int TargetCapacity { get; private set; }
    public PrefabPool(UInt32 prefabId, int targetCapacity);
    [CompilerGeneratedAttribute]
public string get_PrefabName();
    [CompilerGeneratedAttribute]
private void set_PrefabName(string value);
    [CompilerGeneratedAttribute]
public int get_Missed();
    [CompilerGeneratedAttribute]
private void set_Missed(int value);
    [CompilerGeneratedAttribute]
public int get_Pushed();
    [CompilerGeneratedAttribute]
private void set_Pushed(int value);
    [CompilerGeneratedAttribute]
public int get_Popped();
    [CompilerGeneratedAttribute]
private void set_Popped(int value);
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_TargetCapacity();
    [CompilerGeneratedAttribute]
private void set_TargetCapacity(int value);
    public void Push(Poolable info);
    public void Push(GameObject instance);
    public GameObject Pop(Vector3 pos, Quaternion rot);
    public void Clear();
}
public class PrefabPoolCollection : object {
    public Dictionary`2<UInt32, PrefabPool> storage;
    private bool isClient;
    public PrefabPoolCollection(bool client);
    public void Push(GameObject instance);
    public GameObject Pop(UInt32 id, Vector3 pos, Quaternion rot);
    public void Clear(string filter);
}
public class PrefabPoolWarmup : object {
    public static void Run(string filter, int countOverride);
    [IteratorStateMachineAttribute("PrefabPoolWarmup/<Run>d__1")]
public static IEnumerator Run(float deltaTime, Action`1<string> statusFunction, string format);
    public static String[] GetAssetList();
    private static void PrefabWarmup(string path, int countOverride);
}
public class PrefabPrepare : MonoBehaviour {
}
public class PrefabPreProcess : object {
    public static Type[] clientsideOnlyTypes;
    public static Type[] serversideOnlyTypes;
    public bool isClientside;
    public bool isServerside;
    public bool isBundling;
    public Dictionary`2<string, GameObject> prefabList;
    public List`1<Component> destroyList;
    public List`1<GameObject> cleanupList;
    public PrefabPreProcess(bool clientside, bool serverside, bool bundling);
    private static PrefabPreProcess();
    public GameObject Find(string strPrefab);
    public bool NeedsProcessing(GameObject go);
    public void ProcessObject(string name, GameObject go, PreProcessPrefabOptions options);
    public void Process(string name, GameObject go);
    public void Invalidate(string name);
    public GameObject GetHierarchyGroup();
    public void AddPrefab(string name, GameObject go);
    private void DestroyComponents(Type t, GameObject go, bool client, bool server);
    private bool ShouldExclude(Transform transform);
    private bool HasComponents(Transform transform);
    private bool HasComponents(Transform transform, Type t);
    public List`1<T> FindComponents(Transform transform);
    public void FindComponents(Transform transform, List`1<T> list);
    public List`1<Component> FindComponents(Transform transform, Type t);
    public void FindComponents(Transform transform, List`1<Component> list, Type t);
    public sealed virtual void RemoveComponent(Component c);
    public void RemoveComponents(GameObject gameObj);
    public sealed virtual void NominateForDeletion(GameObject gameObj);
    public void RunCleanupQueue();
    public void DoCleanup(GameObject go);
}
public enum PrefabPriority : Enum {
    public int value__;
    public static PrefabPriority Lowest;
    public static PrefabPriority Low;
    public static PrefabPriority Default;
    public static PrefabPriority High;
    public static PrefabPriority Highest;
}
public class PrefabValidate : MonoBehaviour {
}
public class PreloadedCassetteContent : ScriptableObject {
    public SoundDefinition[] ShortTapeContent;
    public SoundDefinition[] MediumTapeContent;
    public SoundDefinition[] LongTapeContent;
    public SoundDefinition GetSoundContent(int index, PreloadType type);
    private SoundDefinition GetDefinition(int index, SoundDefinition[] array);
    public UInt32 GetSoundContentId(SoundDefinition def);
    public SoundDefinition GetSoundContent(UInt32 id);
}
public class PreProcessPrefabOptions : ValueType {
    public static PreProcessPrefabOptions Default;
    public static PreProcessPrefabOptions Default_NoResetPosition;
    public static PreProcessPrefabOptions Scene2Scene;
    public static PreProcessPrefabOptions Scene2Scene_Runtime;
    public bool ResetLocalTransform;
    public bool StripComponents;
    public bool StripEmptyChildren;
    public bool PreProcess;
    public bool PostProcess;
    public bool UpdateMeshCooking;
    private static PreProcessPrefabOptions();
}
public class PressButton : IOEntity {
    public float pressDuration;
    public float pressPowerTime;
    public int pressPowerAmount;
    public static Flags Flag_EmittingPower;
    public bool smallBurst;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public void UnpowerTime();
    public virtual void PostServerLoad();
    [IsVisible("3")]
[RPC_Server]
public void RPC_Press(RPCMessage msg);
    public void Press();
    public void Unpress();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class PressButton_TrainTunnel : PressButton {
}
public class PressurePad : BaseDetector {
    public float pressPowerTime;
    public int pressPowerAmount;
    public static Flags Flag_EmittingPower;
    public virtual int ConsumptionAmount();
    public virtual bool IsRootEntity();
    public virtual bool ShouldTrigger();
    public virtual void OnDetectorTriggered();
    public virtual void OnDetectorReleased();
    public void UnpowerTime();
    public virtual int GetPassthroughAmount(int outputSlot);
}
[DisallowMultipleComponent]
public class PreUpdateHook : MonoBehaviour {
    public static Action OnUpdate;
    public static Action OnLateUpdate;
    public static Action OnFixedUpdate;
    public static Action PostPhysicsUpdate;
    public static Action StartOfFrame;
    private static int lastStartOfFrame;
    private void Start();
    private void Update();
    private void LateUpdate();
    private void FixedUpdate();
    private void TryRunStartOfFrame();
    [IteratorStateMachineAttribute("PreUpdateHook/<AfterPhysicsUpdate>d__11")]
private IEnumerator AfterPhysicsUpdate();
}
public class PreventBuildingMonumentTag : MonoBehaviour {
    public bool autoFindMonument;
    [SerializeField]
private MonumentInfo AttachedMonument;
    public MonumentInfo GetAttachedMonument();
    public void SetMonument(MonumentInfo monument);
}
public abstract class ProceduralComponent : MonoBehaviour {
    [InspectorFlagsAttribute]
public Realm Mode;
    public string Description;
    public bool RunOnCache { get; }
    public virtual bool get_RunOnCache();
    public bool ShouldRun();
    public abstract virtual void Process(UInt32 seed);
}
public class ProceduralDungeonCell : BaseMonoBehaviour {
    public bool north;
    public bool east;
    public bool south;
    public bool west;
    public bool entrance;
    public bool hasSpawn;
    public Transform exitPointHack;
    public SpawnGroup[] spawnGroups;
    public RendererLOD[] mapRendererLods;
    public void Awake();
}
public class ProceduralDynamicDungeon : BaseEntity {
    public int gridResolution;
    public float gridSpacing;
    public Boolean[] grid;
    public List`1<GameObjectRef> cellPrefabReferences;
    public List`1<ProceduralDungeonCell> spawnedCells;
    public EnvironmentVolume envVolume;
    public MonumentNavMesh monumentNavMesh;
    public GameObjectRef exitPortalPrefab;
    private EntityRef`1<BasePortal> exitPortal;
    public TriggerRadiation exitRadiation;
    public UInt32 seed;
    public UInt32 baseseed;
    public Vector3 mapOffset;
    public static List`1<ProceduralDynamicDungeon> dungeons;
    public ProceduralDungeonCell entranceHack;
    private static ProceduralDynamicDungeon();
    public virtual void InitShared();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public BaseEntity GetExitPortal(bool serverSide);
    public virtual void DestroyShared();
    public bool ContainsAnyPlayers();
    public void KillPlayers();
    internal virtual void DoServerDestroy();
    public virtual void ServerInit();
    public void DoGeneration();
    private void CreateAIZ();
    public virtual void PostServerLoad();
    [IteratorStateMachineAttribute("ProceduralDynamicDungeon/<UpdateNavMesh>d__25")]
public IEnumerator UpdateNavMesh();
    public virtual void Save(SaveInfo info);
    public BasePortal GetExitPortal();
    public void InitSpawnGroups();
    public void CleanupSpawnGroups();
    public virtual void Load(LoadInfo info);
    [ExecuteInEditMode]
[ContextMenu("Test Grid")]
public void GenerateGrid();
    public ProceduralDungeonCell CellInstantiate(string path);
    public void RetireCell(GameObject cell);
    public void RetireAllCells();
    public bool CanSeeEntrance(int x, int y, List`1& checkedCells);
    public bool HasPathToEntrance(int x, int y);
    public bool CanFindEntrance(int x, int y);
    public bool IsEntrance(int x, int y);
    public int GetEntranceIndex();
    public void SetEntrance(int x, int y);
    public void SetGridState(int x, int y, bool state);
    public bool GetGridState(int x, int y);
    public int GetGridX(int index);
    public int GetGridY(int index);
    public int GetGridIndex(int x, int y);
}
public class ProceduralLift : BaseEntity {
    public float movementSpeed;
    public float resetDelay;
    public ProceduralLiftCabin cabin;
    public ProceduralLiftStop[] stops;
    public GameObjectRef triggerPrefab;
    public string triggerBone;
    private int floorIndex;
    public SoundDefinition startSoundDef;
    public SoundDefinition stopSoundDef;
    public SoundDefinition movementLoopSoundDef;
    private Sound movementLoopSound;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Spawn();
    [RPC_Server]
[MaxDistance("3")]
private void RPC_UseLift(RPCMessage rpc);
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    private void ResetLift();
    private void MoveToFloor(int floor);
    private void SnapToFloor(int floor);
    private void OnFinishedMoving();
    protected void Update();
    public void StartMovementSounds();
    public void StopMovementSounds();
}
public class ProceduralLiftCabin : MonoBehaviour {
}
public class ProceduralLiftStop : MonoBehaviour {
}
public abstract class ProceduralObject : MonoBehaviour {
    protected void Awake();
    public abstract virtual void Process();
}
public class ProcessedTexture : object {
    protected RenderTexture result;
    protected Material material;
    public void Dispose();
    protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear);
    protected void DestroyRenderTexture(RenderTexture& rt);
    protected RenderTexture CreateTemporary();
    protected void ReleaseTemporary(RenderTexture rt);
    protected Material CreateMaterial(string shader);
    protected Material CreateMaterial(Shader shader);
    protected void DestroyMaterial(Material& mat);
    public static Texture op_Implicit(ProcessedTexture t);
}
public class ProcessMonumentNodes : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class ProcessProceduralObjects : ProceduralComponent {
    public bool RunOnCache { get; }
    public virtual void Process(UInt32 seed);
    public virtual bool get_RunOnCache();
}
public class Profile : object {
    public Stopwatch watch;
    public string category;
    public string name;
    public float warnTime;
    public Profile(string cat, string nam, float WarnTime);
    public void Start();
    public void Stop();
}
public class ProgressBar : UIBehaviour {
    public static ProgressBar Instance;
    private Action`1<BasePlayer> action;
    public float timeFinished;
    private float timeCounter;
    public GameObject scaleTarget;
    public Image progressField;
    public Image iconField;
    public Text leftField;
    public Text rightField;
    public SoundDefinition clipOpen;
    public SoundDefinition clipCancel;
    private bool isOpen;
    public bool InstanceIsOpen { get; }
    public bool get_InstanceIsOpen();
}
public static class ProgressBarUI : object {
}
public class ProgressDoor : IOEntity {
    public float storedEnergy;
    public float energyForOpen;
    public float secondsToClose;
    public float openProgress;
    public virtual void ResetIOState();
    public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot);
    public virtual void NoEnergy();
    public virtual void AddEnergy(float amount);
    public virtual void UpdateProgress();
}
public class Projectile : BaseMonoBehaviour {
    public static float moveDeltaTime;
    public static float lifeTime;
    [HeaderAttribute("Attributes")]
public Vector3 initialVelocity;
    public float drag;
    public float gravityModifier;
    public float thickness;
    [TooltipAttribute("This projectile will raycast for this many units, and then become a projectile. This is typically done for bullets.")]
public float initialDistance;
    [HeaderAttribute("Impact Rules")]
public bool remainInWorld;
    [RangeAttribute("0", "1")]
public float stickProbability;
    [RangeAttribute("0", "1")]
public float breakProbability;
    [RangeAttribute("0", "1")]
public float conditionLoss;
    [RangeAttribute("0", "1")]
public float ricochetChance;
    public float penetrationPower;
    [RangeAttribute("0", "1")]
public float waterIntegrityLoss;
    [HeaderAttribute("Damage")]
public DamageProperties damageProperties;
    [HorizontalAttribute("2", "-1")]
public MinMax damageDistances;
    [HorizontalAttribute("2", "-1")]
public MinMax damageMultipliers;
    public List`1<DamageTypeEntry> damageTypes;
    [HeaderAttribute("Rendering")]
public ScaleRenderer rendererToScale;
    public ScaleRenderer firstPersonRenderer;
    public bool createDecals;
    [HeaderAttribute("Effects")]
public bool doDefaultHitEffects;
    [HeaderAttribute("Audio")]
public SoundDefinition flybySound;
    public float flybySoundDistance;
    public SoundDefinition closeFlybySound;
    public float closeFlybyDistance;
    [HeaderAttribute("Tumble")]
public float tumbleSpeed;
    public Vector3 tumbleAxis;
    [HeaderAttribute("Swim")]
public Vector3 swimScale;
    public Vector3 swimSpeed;
    public BasePlayer owner;
    public AttackEntity sourceWeaponPrefab;
    public Projectile sourceProjectilePrefab;
    public ItemModProjectile mod;
    public int projectileID;
    public int seed;
    public bool clientsideEffect;
    public bool clientsideAttack;
    public float integrity;
    public float maxDistance;
    public Modifier modifier;
    public bool invisible;
    public bool noheadshots;
    public float currentThickness;
    private static UInt32 _fleshMaterialID;
    private static UInt32 _waterMaterialID;
    private static UInt32 cachedWaterString;
    public void CalculateDamage(HitInfo info, Modifier mod, float scale);
    public static UInt32 FleshMaterialID();
    public static UInt32 WaterMaterialID();
    public static bool IsWaterMaterial(string hitMaterial);
    public static bool ShouldStopProjectile(RaycastHit hit);
}
public class ProjectileTestSpawner : MonoBehaviour {
    public Projectile TargetProjectile;
    public float RepeatTime;
    public float VelocityScale;
}
public class ProjectileWeaponInformationPanel : ItemInformationPanel {
    public ItemStatValue damageDisplay;
    public ItemStatValue recoilDisplay;
    public ItemStatValue rofDisplay;
    public ItemStatValue accuracyDisplay;
    public ItemStatValue rangeDisplay;
    public ItemStatValue minigunMoveDisplay;
    public ItemIcon[] attachmentIcons;
}
public class ProjectileWeaponMod : BaseEntity {
    [HeaderAttribute("AttackEffectAdditive")]
public GameObjectRef additiveEffect;
    [HeaderAttribute("Silencer")]
public GameObjectRef defaultSilencerEffect;
    public bool isSilencer;
    [HeaderAttribute("Weapon Basics")]
public Modifier repeatDelay;
    public Modifier projectileVelocity;
    public Modifier projectileDamage;
    public Modifier projectileDistance;
    [HeaderAttribute("Recoil")]
public Modifier aimsway;
    public Modifier aimswaySpeed;
    public Modifier recoil;
    [HeaderAttribute("Aim Cone")]
public Modifier sightAimCone;
    public Modifier hipAimCone;
    [HeaderAttribute("Light Effects")]
public bool isLight;
    [HeaderAttribute("MuzzleBrake")]
public bool isMuzzleBrake;
    [HeaderAttribute("MuzzleBoost")]
public bool isMuzzleBoost;
    [HeaderAttribute("Scope")]
public bool isScope;
    public float zoomAmountDisplayOnly;
    [HeaderAttribute("Magazine")]
public Modifier magazineCapacity;
    public bool needsOnForEffects;
    [HeaderAttribute("Burst")]
public int burstCount;
    public float timeBetweenBursts;
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public static float Mult(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def);
    public static float Sum(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def);
    public static float Average(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def);
    public static float Max(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def);
    public static float Min(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value, float def);
    public static IEnumerable`1<float> GetMods(BaseEntity parentEnt, Func`2<ProjectileWeaponMod, Modifier> selector_modifier, Func`2<Modifier, float> selector_value);
    public static bool HasBrokenWeaponMod(BaseEntity parentEnt);
}
public class PropSway : MonoBehaviour {
    public Transform pivotRotator;
    public float swaySpeed;
    public float swayDistance;
    public float lerpSpeed;
}
[CreateAssetMenuAttribute]
public class ProtectionProperties : ScriptableObject {
    [TextAreaAttribute]
public string comments;
    [RangeAttribute("0", "100")]
public float density;
    [ArrayIndexIsEnumRanged]
public Single[] amounts;
    public void OnValidate();
    public void Clear();
    public void Add(float amount);
    public void Add(DamageType index, float amount);
    public void Add(ProtectionProperties other, float scale);
    public void Add(List`1<Item> items, HitArea area);
    public void Multiply(float multiplier);
    public void Multiply(DamageType index, float multiplier);
    public void Scale(DamageTypeList damageList, float ProtectionAmount);
    public float Get(DamageType damageType);
}
public class ProtectionValue : MonoBehaviour {
    public CanvasGroup group;
    public TextMeshProUGUI text;
    public DamageType damageType;
    public bool selectedItem;
    public bool displayBaseProtection;
}
public class PuzzleReset : FacepunchBehaviour {
    public SpawnGroup[] respawnGroups;
    public IOEntity[] resetEnts;
    public GameObject[] resetObjects;
    public bool playersBlockReset;
    public bool CheckSleepingAIZForPlayers;
    public float playerDetectionRadius;
    public float playerHeightDetectionMinMax;
    public Transform playerDetectionOrigin;
    public float timeBetweenResets;
    public bool scaleWithServerPopulation;
    [HideInInspector]
public Vector3[] resetPositions;
    public bool broadcastResetMessage;
    public Phrase resetPhrase;
    private AIInformationZone zone;
    public float resetTimeElapsed;
    private float resetTickTime;
    public float GetResetSpacing();
    public void Start();
    public void ResetTimer();
    public bool PassesResetCheck();
    private bool AIZSleeping();
    private bool PlayersWithinDistance();
    public static bool AnyPlayersWithinDistance(Transform origin, float radius);
    public void ResetTick();
    public void CleanupSleepers();
    public void DoReset();
    public static void ResetIOEntRecursive(IOEntity target, int resetIndex);
}
public class PVPMissionManager : MonoBehaviour {
    private void Start();
    private void Update();
}
public class QuadDecal : MonoBehaviour {
}
public class QueryVis : BaseMonoBehaviour {
    public Collider checkCollider;
    private Query query;
    public RadiusSpace coverageRadiusSpace;
    public float coverageRadius;
}
public class QuickCraft : SingletonComponent`1<QuickCraft> {
    public GameObjectRef craftButton;
    public GameObject empty;
    public Sprite FavouriteOnSprite;
    public Sprite FavouriteOffSprite;
    public Color FavouriteOnColor;
    public Color FavouriteOffColor;
}
public class QuickCraftButton : MonoBehaviour {
    public Image icon;
    public Image favourite;
    public Tooltip tooltip;
    public Text CraftCount;
    public Image FavouriteIcon;
}
public class RaceWaypointVisual : MonoBehaviour {
    public GameObject RegularCheckpoint;
    public GameObject FinishCheckpoint;
}
[PostProcessAttribute("RadialBlurRenderer", "2", "Custom/RadialBlur", "True")]
public class RadialBlur : PostProcessEffectSettings {
    [HeaderAttribute("Radial Controls")]
public Vector2Parameter center;
    [RangeAttribute("0,1", "2")]
public FloatParameter start;
    [RangeAttribute("0", "2")]
public FloatParameter amount;
    [HeaderAttribute("Blur Quality")]
[RangeAttribute("0", "3")]
public FixedIntParameter downsample;
    [RangeAttribute("1", "4")]
public FixedIntParameter iterations;
}
public class RadialBlurRenderer : PostProcessEffectRenderer`1<RadialBlur> {
    private Shader shader;
    private int rt1ID;
    private int rt2ID;
    private int paramsID;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class RadialSpawnPoint : BaseSpawnPoint {
    [SerializeField]
[TooltipAttribute("Circle to spawn within")]
public float radius;
    public virtual void GetLocation(Vector3& pos, Quaternion& rot);
    public virtual bool HasPlayersIntersecting();
    public virtual void ObjectSpawned(SpawnPointInstance instance);
    public virtual void ObjectRetired(SpawnPointInstance instance);
}
public static class Radiation : object {
    public static float MaterialToRadsRatio;
    private static Radiation();
    public static float GetRadiation(Tier tier);
    public static float GetRadiationAfterProtection(float radiationAmount, float radiationProtection);
}
public class RadiationOverlay : MonoBehaviour {
    public SoundDefinition[] geigerSounds;
    public PostProcessVolume postProcessVolume;
}
public class RadiationSphere : BaseEntity {
    public AnimationCurve RadiationCurve;
    public float InvokeDelay;
    public List`1<IOEntity> RadiationLights;
    private float timeStarted;
    private TriggerRadiation[] radiationTriggers;
    [CompilerGeneratedAttribute]
private static List`1<RadiationSphere> <All>k__BackingField;
    public static List`1<RadiationSphere> All { get; private set; }
    private static RadiationSphere();
    [CompilerGeneratedAttribute]
public static List`1<RadiationSphere> get_All();
    [CompilerGeneratedAttribute]
private static void set_All(List`1<RadiationSphere> value);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void RestartRadiation();
    public void StopRadation();
    public void UpdateRadiation();
    private void SetLights(bool state);
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public void OnPuzzleReset();
}
public class RadioDialog : UIDialog {
    public RustInput IpInput;
    public GameObjectRef FavouritePrefab;
    public Transform FavouritesContainer;
    public GameObject HasCassetteRoot;
    public static RadioDialog Instance;
}
[CreateAssetMenuAttribute]
public class RadioPlaylist : ScriptableObject {
    public string Url;
    public AudioClip[] Playlist;
    public float PlaylistLength;
}
public class RadixSorter : object {
    private UInt32[] histogram;
    private UInt32[] offset;
    public void SortU8(UInt32[] values, UInt32[] remap, UInt32 num);
    public void SortU24(UInt32[] values, UInt32[] remap, UInt32[] remapTemp, UInt32 num);
}
public class Ragdoll : EntityComponent`1<BaseEntity> {
    [TooltipAttribute("If true, ragdoll physics are simulated on the server instead of the client")]
[HeaderAttribute("Ragdoll")]
public bool simOnServer;
    public float lerpToServerSimTime;
    public Transform eyeTransform;
    public Rigidbody primaryBody;
    [ReadOnlyAttribute]
public SpringJoint corpseJoint;
    [SerializeField]
private PhysicMaterial physicMaterial;
    [SerializeField]
private Skeleton skeleton;
    [SerializeField]
private Model model;
    [ReadOnlyAttribute]
public List`1<Rigidbody> rigidbodies;
    [SerializeField]
[ReadOnlyAttribute]
private List`1<Transform> rbTransforms;
    [SerializeField]
[ReadOnlyAttribute]
private List`1<Joint> joints;
    [ReadOnlyAttribute]
[SerializeField]
private List`1<CharacterJoint> characterJoints;
    [ReadOnlyAttribute]
[SerializeField]
private List`1<ConfigurableJoint> configurableJoints;
    [ReadOnlyAttribute]
[SerializeField]
private List`1<Collider> colliders;
    [ReadOnlyAttribute]
[SerializeField]
private Int32[] boneIndex;
    [ReadOnlyAttribute]
[SerializeField]
private Vector3[] genericBonePos;
    [ReadOnlyAttribute]
[SerializeField]
private Quaternion[] genericBoneRot;
    [SerializeField]
private GameObject GibEffect;
    protected bool isSetUp;
    private static float MAX_JOINT_DIST;
    private bool wasSyncingJoints;
    protected bool IsClient { get; }
    protected bool isServer { get; }
    public bool IsSleeping { get; }
    public bool IsKinematic { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    protected bool get_IsClient();
    protected bool get_isServer();
    private void SetUpPhysics(bool isServer);
    public void ParentChanging(BaseCorpse corpse, Transform newParent);
    private void SetInterpolationMode(Transform parent, bool isServer);
    private bool AnyParentMoves(Transform parent);
    private static void SetCollisionMode(Rigidbody rigidBody, bool isServer);
    public void MoveRigidbodiesToRoot();
    public virtual void LoadComponent(LoadInfo info);
    public void GetCurrentBoneState(GameObject[] bones, Vector3[]& bonePos, Quaternion[]& boneRot);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    private void RemoveRootBoneOffset();
    public bool get_IsSleeping();
    public bool get_IsKinematic();
    public virtual void ServerInit();
    public virtual void SaveComponent(SaveInfo info);
    public bool IsFullySleeping();
    private void SyncJointsToClients();
    private bool ShouldSyncJoints();
    private void SetRagdollMessageVals(Ragdoll ragdollMsg);
    public void BecomeActive();
    public void BecomeInactive();
}
public class RagdollEditor : SingletonComponent`1<RagdollEditor> {
    private Vector3 view;
    private Rigidbody grabbedRigid;
    private Vector3 grabPos;
    private Vector3 grabOffset;
    private void OnGUI();
    protected virtual void Awake();
    private void Update();
    private void FixedUpdate();
    private void StartGrab();
    private void UpdateGrab();
    private void StopGrab();
}
public class RainbowEffect : WeatherEffect {
}
public class RainEffect : WeatherEffect {
    public int FadeStartDistance;
    public int FadeEndDistance;
    public int FadeFalloff;
    public bool Stormy;
}
public class RainEffectSting : WeatherEffectSting {
}
public class RainSurfaceAmbience : SingletonComponent`1<RainSurfaceAmbience> {
    public List`1<SurfaceSound> surfaces;
    public GameObjectRef emitterPrefab;
    public Dictionary`2<ParticlePatch, AmbienceEmitter> spawnedEmitters;
}
public class RandomDestroy : MonoBehaviour {
    public UInt32 Seed;
    public float Probability;
    protected void Start();
}
public class RandomDynamicObject : MonoBehaviour {
    public UInt32 Seed;
    public float Distance;
    public float Probability;
    public GameObject[] Candidates;
}
public class RandomDynamicPrefab : MonoBehaviour {
    public UInt32 Seed;
    public float Distance;
    public float Probability;
    public string ResourceFolder;
}
public class RandomItemDispenser : PrefabAttribute {
    public RandomItemChance[] Chances;
    public bool OnlyAwardOne;
    protected virtual Type GetIndexedType();
    public void DistributeItems(BasePlayer forPlayer, Vector3 distributorPosition);
    private bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition);
}
public class RandomObjectEnableOnEnable : MonoBehaviour {
    public GameObject[] objects;
    public void OnEnable();
}
public class RandomParameterNumber : StateMachineBehaviour {
    public string parameterName;
    public int min;
    public int max;
    public bool preventRepetition;
    public bool isFloat;
    private int last;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class RandomParameterNumberFloat : StateMachineBehaviour {
    public string parameterName;
    public int min;
    public int max;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class RandomRendererEnable : MonoBehaviour {
    public Renderer[] randoms;
    [CompilerGeneratedAttribute]
private int <EnabledIndex>k__BackingField;
    public int EnabledIndex { get; private set; }
    [CompilerGeneratedAttribute]
public int get_EnabledIndex();
    [CompilerGeneratedAttribute]
private void set_EnabledIndex(int value);
    public void OnEnable();
}
public class RandomStaticObject : MonoBehaviour {
    public UInt32 Seed;
    public float Probability;
    public GameObject[] Candidates;
    protected void Start();
}
public class RandomStaticPrefab : MonoBehaviour {
    public UInt32 Seed;
    public float Probability;
    public string ResourceFolder;
    protected void Start();
}
public class RANDSwitch : ElectricalBlocker {
    private bool rand;
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
    public virtual void UpdateBlocked();
    public bool RandomRoll();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
}
public static class RawWriter : object {
    public static void Write(IEnumerable`1<byte> data, string path);
    public static void Write(IEnumerable`1<int> data, string path);
    public static void Write(IEnumerable`1<short> data, string path);
    public static void Write(IEnumerable`1<float> data, string path);
}
[ExtensionAttribute]
public static class RaycastHitEx : object {
    [ExtensionAttribute]
public static Transform GetTransform(RaycastHit hit);
    [ExtensionAttribute]
public static Rigidbody GetRigidbody(RaycastHit hit);
    [ExtensionAttribute]
public static Collider GetCollider(RaycastHit hit);
    [ExtensionAttribute]
public static BaseEntity GetEntity(RaycastHit hit);
    [ExtensionAttribute]
public static bool IsOnLayer(RaycastHit hit, Layer rustLayer);
    [ExtensionAttribute]
public static bool IsOnLayer(RaycastHit hit, int layer);
    [ExtensionAttribute]
public static bool IsWaterHit(RaycastHit hit);
    [ExtensionAttribute]
public static WaterBody GetWaterBody(RaycastHit hit);
}
public class RCBookmarkEntry : MonoBehaviour {
    [CompilerGeneratedAttribute]
private string <identifier>k__BackingField;
    private ComputerMenu owner;
    public RectTransform connectButton;
    public RectTransform disconnectButton;
    public RawImage onlineIndicator;
    public RawImage offlineIndicator;
    public GameObject selectedindicator;
    public Image backgroundImage;
    public Color selectedColor;
    public Color activeColor;
    public Color inactiveColor;
    public Text nameLabel;
    [CompilerGeneratedAttribute]
private bool <isSelected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <isControlling>k__BackingField;
    public EventTrigger eventTrigger;
    public string identifier { get; private set; }
    public bool isSelected { get; private set; }
    public bool isControlling { get; private set; }
    [CompilerGeneratedAttribute]
public string get_identifier();
    [CompilerGeneratedAttribute]
private void set_identifier(string value);
    [CompilerGeneratedAttribute]
public bool get_isSelected();
    [CompilerGeneratedAttribute]
private void set_isSelected(bool value);
    [CompilerGeneratedAttribute]
public bool get_isControlling();
    [CompilerGeneratedAttribute]
private void set_isControlling(bool value);
}
public class RCMenu : ComputerMenu {
    public Image backgroundOpaque;
    public InputField newBookmarkEntryField;
    public NeedsCursor needsCursor;
    public float hiddenOffset;
    public RectTransform devicesPanel;
    private Vector3 initialDevicesPosition;
    public static bool isControllingCamera;
    public CanvasGroup overExposure;
    public CanvasGroup interference;
    public float interferenceFadeDuration;
    public float rangeInterferenceScale;
    public Text timeText;
    public Text watchedDurationText;
    public Text deviceNameText;
    public Text noSignalText;
    public Text healthText;
    public GameObject healthBarParent;
    public RectTransform healthBarBackground;
    public RectTransform healthBarFill;
    public SoundDefinition bookmarkPressedSoundDef;
    public GameObject[] hideIfStatic;
    public GameObject readOnlyIndicator;
    [FormerlySerializedAsAttribute("crosshair")]
public GameObject aimCrosshair;
    public GameObject generalCrosshair;
    public float fogOverrideDensity;
    public float autoTurretFogDistance;
    public float autoTurretDotBaseScale;
    public float autoTurretDotGrowScale;
    public PingManager PingManager;
    public ScrollRectSettable scrollRect;
}
public class ReactiveTarget : IOEntity {
    public Animator myAnimator;
    public GameObjectRef bullseyeEffect;
    public GameObjectRef knockdownEffect;
    public float activationPowerTime;
    public int activationPowerAmount;
    private float lastToggleTime;
    public static Flags Flag_KnockedDown;
    public float knockdownHealth;
    private int inputAmountReset;
    private int inputAmountLower;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void OnHitShared(HitInfo info);
    public bool IsKnockedDown();
    public bool IsLowered();
    public virtual void OnAttacked(HitInfo info);
    public bool CanToggle();
    public bool CanLower();
    public bool CanReset();
    public void QueueReset();
    public void ResetTarget();
    private void LowerTarget();
    private void SendPowerBurst();
    public virtual int ConsumptionAmount();
    public virtual bool IsRootEntity();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    [RPC_Server]
public void RPC_Reset(RPCMessage msg);
    [RPC_Server]
public void RPC_Lower(RPCMessage msg);
}
public class RealmedCollider : BasePrefab {
    public Collider ServerCollider;
    public Collider ClientCollider;
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class RealmedNavMeshObstacle : BasePrefab {
    public NavMeshObstacle Obstacle;
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class RealmedRemove : MonoBehaviour {
    public GameObject[] removedFromClient;
    public Component[] removedComponentFromClient;
    public GameObject[] removedFromServer;
    public Component[] removedComponentFromServer;
    public Component[] doNotRemoveFromServer;
    public Component[] doNotRemoveFromClient;
    public sealed virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public bool ShouldDelete(Component comp, bool client, bool server);
}
public class RealTimeSinceEx : ValueType {
    private double time;
    public static double op_Implicit(RealTimeSinceEx ts);
    public static RealTimeSinceEx op_Implicit(double ts);
    public virtual string ToString();
}
[CreateAssetMenuAttribute]
public class Recipe : ScriptableObject {
    [HeaderAttribute("Produced Item")]
public ItemDefinition ProducedItem;
    public int ProducedItemCount;
    public bool CanQueueMultiple;
    [HeaderAttribute("Spawned Item")]
public GameObjectRef SpawnedItem;
    public string SpawnedItemName;
    public string SpawnedItemDescription;
    public Sprite SpawnedItemIcon;
    [HeaderAttribute("Misc")]
public bool RequiresBlueprint;
    public RecipeIngredient[] Ingredients;
    public float MixingDuration;
    public string DisplayName { get; }
    public string DisplayDescription { get; }
    public Sprite DisplayIcon { get; }
    public string get_DisplayName();
    public string get_DisplayDescription();
    public Sprite get_DisplayIcon();
    public bool ContainsItem(Item item);
}
public static class RecipeDictionary : object {
    private static Dictionary`2<UInt32, Dictionary`2<int, List`1<Recipe>>> recipeListsDict;
    private static RecipeDictionary();
    public static void CacheRecipes(RecipeList recipeList);
    public static Recipe GetMatchingRecipeAndQuantity(RecipeList recipeList, List`1<Item> orderedIngredients, Int32& quantity);
    private static List`1<Recipe> GetRecipesByFirstIngredient(RecipeList recipeList, Item firstIngredient);
    public static bool ValidIngredientForARecipe(Item ingredient, RecipeList recipeList);
}
[CreateAssetMenuAttribute]
public class RecipeList : BaseScriptableObject {
    public Recipe[] Recipes;
}
public class ReclaimBackpack : StorageContainer {
    public int reclaimID;
    public ulong playerSteamID;
    public bool onlyOwnerLoot;
    public Collider myCollider;
    public GameObject art;
    private bool isBeingLooted;
    public void InitForPlayer(ulong playerID, int newID);
    public virtual void ServerInit();
    public void RemoveMe();
    public void CheckEmpty();
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ReclaimManager : BaseEntity {
    private static int defaultReclaims;
    private static int reclaimSlotCount;
    private int lastReclaimID;
    [ServerVar]
public static float reclaim_expire_minutes;
    private static ReclaimManager _instance;
    private List`1<PlayerReclaimEntry> entries;
    private float lastTickTime;
    public static ReclaimManager instance { get; }
    private static ReclaimManager();
    public static ReclaimManager get_instance();
    public int AddPlayerReclaim(ulong victimID, List`1<Item> itemList, ulong killerID, string killerString, int reclaimIDToUse);
    public void DoCleanup();
    public void TickEntries();
    public bool HasReclaims(ulong playerID);
    public PlayerReclaimEntry GetReclaimForPlayer(ulong playerID, int reclaimID);
    public bool GetReclaimsForPlayer(ulong playerID, List`1& list);
    public PlayerReclaimEntry NewEntry();
    public void RemoveEntry(PlayerReclaimEntry entry);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
}
public class ReclaimTerminal : StorageContainer {
    public int itemCount;
    public static Phrase DespawnToast;
    private static ReclaimTerminal();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    [RPC_Server]
[CallsPerSecond("1")]
[MaxDistance("3")]
public void RPC_ReloadLoot(RPCMessage msg);
    public void LoadReclaimLoot(BasePlayer player);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
[CreateAssetMenuAttribute]
public class RecoilProperties : ScriptableObject {
    public float recoilYawMin;
    public float recoilYawMax;
    public float recoilPitchMin;
    public float recoilPitchMax;
    public float timeToTakeMin;
    public float timeToTakeMax;
    public float ADSScale;
    public float movementPenalty;
    public float clampPitch;
    public AnimationCurve pitchCurve;
    public AnimationCurve yawCurve;
    public bool useCurves;
    public bool curvesAsScalar;
    public int shotsUntilMax;
    public float maxRecoilRadius;
    [HeaderAttribute("AimCone")]
public bool overrideAimconeWithCurve;
    public float aimconeCurveScale;
    [TooltipAttribute("How much to scale aimcone by based on how far into the shot sequence we are (shots v shotsUntilMax)")]
public AnimationCurve aimconeCurve;
    [TooltipAttribute("Randomly select how much to scale final aimcone by per shot, you can use this to weigh a fraction of shots closer to the center")]
public AnimationCurve aimconeProbabilityCurve;
    [TooltipAttribute("Scale the actual final aimcone produced by the ammunition itself if the ammo contains multiple projectiles")]
public float ammoAimconeScaleMultiProjectile;
    [TooltipAttribute("Scale the actual final aimcone produced by the ammunition itself if the ammo contains only one projectile")]
public float ammoAimconeScaleSingleProjectile;
    public RecoilProperties newRecoilOverride;
    public RecoilProperties GetRecoil();
}
public class RecorderTool : ThrownWeapon {
    [ClientVar]
public static bool debugRecording;
    public AudioSource RecorderAudioSource;
    public SoundDefinition RecordStartSfx;
    public SoundDefinition RewindSfx;
    public SoundDefinition RecordFinishedSfx;
    public SoundDefinition PlayTapeSfx;
    public SoundDefinition StopTapeSfx;
    public float ThrowScale;
    [CompilerGeneratedAttribute]
private Cassette <cachedCassette>k__BackingField;
    public Cassette cachedCassette { get; public set; }
    public Sprite LoadedCassetteIcon { get; }
    public BaseEntity ToBaseEntity { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public Cassette get_cachedCassette();
    [CompilerGeneratedAttribute]
public void set_cachedCassette(Cassette value);
    public Sprite get_LoadedCassetteIcon();
    private bool HasCassette();
    public sealed virtual BaseEntity get_ToBaseEntity();
    [FromOwner]
[RPC_Server]
public void Server_TogglePlaying(RPCMessage msg);
    public sealed virtual void OnCassetteInserted(Cassette c);
    public sealed virtual void OnCassetteRemoved(Cassette c);
    protected virtual void SetUpThrownWeapon(BaseEntity ent);
    public virtual void OnHeldChanged();
}
public class RecordingSaved : SingletonComponent`1<RecordingSaved> {
    public RustText Label;
}
public class RectChangeEvent : UIBehaviour {
    public UnityEvent action;
    protected virtual void OnRectTransformDimensionsChange();
}
public class Recycler : StorageContainer {
    public Animator Animator;
    [TooltipAttribute("Depreciated")]
public float recycleEfficiency;
    public float safezoneRecycleEfficiency;
    public float radtownRecycleEfficiency;
    public SoundDefinition grindingLoopDef;
    public SoundDefinition grindingLoopDef_Slow;
    public GameObjectRef startSound;
    public GameObjectRef stopSound;
    public float scrapRemainder;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    private bool CanBeRecycled(Item item);
    public virtual void ServerInit();
    public bool RecyclerItemFilter(Item item, int targetSlot);
    [MaxDistance("3")]
[RPC_Server]
private void SVSwitch(RPCMessage msg);
    public bool MoveItemToOutput(Item newItem);
    public bool HasRecyclable();
    public void RecycleThink();
    public float GetRecycleThinkDuration();
    public void StartRecycling();
    public void StopRecycling();
    public void UpdateInSafeZone();
    public bool IsSafezoneRecycler();
    public void PlayAnim();
    public void StopAnim();
    private void ToggleAnim(bool toggle);
}
public class ReflectionPlane : DecayEntity {
    private static int _ColorTexID;
    private static int _DepthTexID;
    private static int _ReflectionLerpID;
    [HeaderAttribute("Reflection Plane")]
public LayerMask layerMask;
    public float nearClip;
    public float farClip;
    public Material reflectionMaterial;
    public Renderer reflectionRenderer;
    public float maxDistance;
    public float fadeTime;
    private static ReflectionPlane();
}
[ExecuteInEditMode]
public class ReflectionProbeEx : MonoBehaviour {
    public ReflectionProbeRefreshMode refreshMode;
    public bool timeSlicing;
    public int resolution;
    [InspectorNameAttribute("HDR")]
public bool hdr;
    public float shadowDistance;
    public ReflectionProbeClearFlags clearFlags;
    public Color background;
    public float nearClip;
    public float farClip;
    public Transform attachToTarget;
    public Light directionalLight;
    public float textureMipBias;
    public bool highPrecision;
    public bool enableShadows;
    public ConvolutionQuality convolutionQuality;
    public List`1<RenderListEntry> staticRenderList;
    public Cubemap reflectionCubemap;
    public float reflectionIntensity;
    private Mesh blitMesh;
    private Mesh skyboxMesh;
    private static Single[] octaVerts;
    private static CubemapFaceMatrices[] cubemapFaceMatrices;
    private static CubemapFaceMatrices[] cubemapFaceMatricesD3D11;
    private static CubemapFaceMatrices[] shadowCubemapFaceMatrices;
    private CubemapFaceMatrices[] platformCubemapFaceMatrices;
    private static Int32[] tab32;
    private static ReflectionProbeEx();
    private void CreateMeshes();
    private void DestroyMeshes();
    private static Mesh CreateBlitMesh();
    private static CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2);
    private static void Subdivide(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3);
    private static void SubdivideYOnly(List`1<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3);
    private static Mesh CreateSkyboxMesh();
    private bool InitializeCubemapFaceMatrices();
    private int FastLog2(int value);
    private UInt32 ReverseBits(UInt32 bits);
    private void SafeCreateMaterial(Material& mat, Shader shader);
    private void SafeCreateMaterial(Material& mat, string shaderName);
    private void SafeCreateCubeRT(RenderTexture& rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    private void SafeCreateCB(CommandBuffer& cb, string name);
    private void SafeDestroy(T& obj);
    private void SafeDispose(T& obj);
}
public class RelationshipManager : BaseEntity {
    [ReplicatedVar]
public static bool contacts;
    public static Type MugshotFileFormat;
    private static int MugshotResolution;
    private static int MugshotMaxFileSize;
    private static float MugshotMaxDistance;
    public Dictionary`2<ulong, PlayerRelationships> relationships;
    private int lastReputationUpdateIndex;
    private static int seenReputationSeconds;
    private int startingReputation;
    [ServerVar]
public static int forgetafterminutes;
    [ServerVar]
public static int maxplayerrelationships;
    [ServerVar]
public static float seendistance;
    [ServerVar]
public static float mugshotUpdateInterval;
    private static List`1<BasePlayer> _dirtyRelationshipPlayers;
    public static int maxTeamSize_Internal;
    [CompilerGeneratedAttribute]
private static RelationshipManager <ServerInstance>k__BackingField;
    public Dictionary`2<ulong, BasePlayer> cachedPlayers;
    public Dictionary`2<ulong, PlayerTeam> playerToTeam;
    public Dictionary`2<ulong, PlayerTeam> teams;
    public ulong lastTeamIndex;
    [ServerVar]
public static int maxTeamSize { get; public set; }
    public static RelationshipManager ServerInstance { get; private set; }
    private static RelationshipManager();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[CallsPerSecond("2")]
public void BagQuotaRequest_SERVER();
    public virtual void ServerInit();
    public void UpdateReputations();
    public void UpdateContactsTick();
    public int GetReputationFor(ulong playerID);
    [ServerVar]
public static void wipecontacts(Arg arg);
    [ServerVar]
public static void wipe_all_contacts(Arg arg);
    public float GetAcquaintanceMaxDist();
    public void UpdateAcquaintancesFor(BasePlayer player, float deltaSeconds);
    public void SetSeen(BasePlayer player, BasePlayer otherPlayer);
    public bool CleanupOldContacts(PlayerRelationships ownerRelationships, ulong playerID, RelationshipType relationshipType);
    public void ForceRelationshipByID(BasePlayer player, ulong otherPlayerID, RelationshipType newType, int weight, bool sendImmediate);
    public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight, bool sendImmediate);
    public PlayerRelationships GetRelationshipSaveByID(ulong playerID);
    public void MarkRelationshipsDirtyFor(ulong playerID);
    public static void ForceSendRelationships(BasePlayer player);
    public void MarkRelationshipsDirtyFor(BasePlayer player);
    public void SendRelationshipsFor(BasePlayer player);
    public void SendRelationships();
    public int GetNumberRelationships(ulong player);
    public bool HasRelations(ulong player, ulong otherPlayer);
    public PlayerRelationships GetRelationships(ulong player);
    [RPC_Server]
[CallsPerSecond("1")]
public void SERVER_SendFreshContacts(RPCMessage msg);
    [CallsPerSecond("2")]
[RPC_Server]
public void SERVER_ChangeRelationship(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("10")]
public void SERVER_UpdatePlayerNote(RPCMessage msg);
    [RPC_Server]
[CallsPerSecond("10")]
public void SERVER_ReceiveMugshot(RPCMessage msg);
    private void DeleteMugshot(ulong steamId, ulong targetSteamId, UInt32 crc);
    public static UInt32 GetSteamIdHash(ulong requesterSteamId, ulong targetSteamId);
    public static void set_maxTeamSize(int value);
    public static int get_maxTeamSize();
    public int GetMaxTeamSize();
    [CompilerGeneratedAttribute]
public static RelationshipManager get_ServerInstance();
    [CompilerGeneratedAttribute]
private static void set_ServerInstance(RelationshipManager value);
    public void OnEnable();
    public void OnDestroy();
    public virtual void Save(SaveInfo info);
    public void DisbandTeam(PlayerTeam teamToDisband);
    public static BasePlayer FindByID(ulong userID);
    public PlayerTeam FindTeam(ulong TeamID);
    public PlayerTeam FindPlayersTeam(ulong userID);
    public PlayerTeam CreateTeam();
    private PlayerTeam CreateTeam(ulong customId);
    [ServerUserVar]
public static void trycreateteam(Arg arg);
    [ServerUserVar]
public static void promote(Arg arg);
    [ServerUserVar]
public static void promote_id(Arg arg);
    [ServerUserVar]
public static void leaveteam(Arg arg);
    [ServerUserVar]
public static void acceptinvite(Arg arg);
    [ServerUserVar]
public static void rejectinvite(Arg arg);
    public static BasePlayer GetLookingAtPlayer(BasePlayer source);
    [ServerVar]
public static void sleeptoggle(Arg arg);
    [ServerUserVar]
public static void kickmember(Arg arg);
    [ServerUserVar]
public static void sendinvite(Arg arg);
    [ServerVar]
public static void fakeinvite(Arg arg);
    [ServerVar]
public static void addtoteam(Arg arg);
    [ServerVar]
public static string createAndAddToTeam(Arg arg);
    public static bool TeamsEnabled();
    public virtual void Load(LoadInfo info);
}
public class ReliableEventSender : StateMachineBehaviour {
    [HeaderAttribute("State Enter")]
public string StateEnter;
    [HeaderAttribute("Mid State")]
public string MidStateEvent;
    [RangeAttribute("0", "1")]
public float TargetEventTime;
}
public class ReloadEventUI : BaseEventUI {
}
public class ReloadingAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class RemoteControlEntity : BaseCombatEntity {
    public static List`1<IRemoteControllable> allControllables;
    [HeaderAttribute("RC Entity")]
public string rcIdentifier;
    public Transform viewEyes;
    public GameObjectRef IDPanelPrefab;
    public RemoteControllableControls rcControls;
    [CompilerGeneratedAttribute]
private int <ViewerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CameraViewerId> <ControllingViewerId>k__BackingField;
    public bool CanPing { get; }
    public bool CanAcceptInput { get; }
    public int ViewerCount { get; public set; }
    public Nullable`1<CameraViewerId> ControllingViewerId { get; public set; }
    public bool IsBeingControlled { get; }
    public bool RequiresMouse { get; }
    public float MaxRange { get; }
    public RemoteControllableControls RequiredControls { get; }
    private static RemoteControlEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual bool get_CanPing();
    public sealed virtual Transform GetEyes();
    public sealed virtual float GetFovScale();
    public sealed virtual BaseEntity GetEnt();
    public sealed virtual string GetIdentifier();
    public virtual bool get_CanAcceptInput();
    [CompilerGeneratedAttribute]
public int get_ViewerCount();
    [CompilerGeneratedAttribute]
public void set_ViewerCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<CameraViewerId> get_ControllingViewerId();
    [CompilerGeneratedAttribute]
public void set_ControllingViewerId(Nullable`1<CameraViewerId> value);
    public bool get_IsBeingControlled();
    public virtual bool InitializeControl(CameraViewerId viewerID);
    public virtual void StopControl(CameraViewerId viewerID);
    public virtual void UserInput(InputState inputState, CameraViewerId viewerID);
    public sealed virtual void UpdateIdentifier(string newID, bool clientSend);
    public virtual void RCSetup();
    public virtual void RCShutdown();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public virtual bool CanControl(ulong playerID);
    public virtual bool get_RequiresMouse();
    public virtual float get_MaxRange();
    public sealed virtual RemoteControllableControls get_RequiredControls();
    [RPC_Server]
[MaxDistance("3")]
public void Server_SetID(RPCMessage msg);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual bool CanChangeID(BasePlayer player);
    public static bool IDInUse(string id);
    public static IRemoteControllable FindByID(string id);
    public static bool InstallControllable(IRemoteControllable newControllable);
    public static bool RemoveControllable(IRemoteControllable newControllable);
}
[FlagsAttribute]
public enum RemoteControllableControls : Enum {
    public int value__;
    public static RemoteControllableControls None;
    public static RemoteControllableControls Movement;
    public static RemoteControllableControls Mouse;
    public static RemoteControllableControls SprintAndDuck;
    public static RemoteControllableControls Fire;
    public static RemoteControllableControls Reload;
    public static RemoteControllableControls Crosshair;
}
public class RemoveChildObjectsAlongPath : MonoBehaviour {
    public Transform Node1;
    public Transform Node2;
    public float Distance;
}
public class RenameSleepingBag : UIDialog {
    public InputField input;
    public SleepingBag bag;
}
public class RendererBatch : MonoBehaviour {
}
[ExtensionAttribute]
public static class RendererEx : object {
    private static Memoized`2<Material[], int> ArrayCache;
    private static RendererEx();
    [ExtensionAttribute]
public static void SetSharedMaterials(Renderer renderer, List`1<Material> materials);
}
public class RendererGrid : SingletonComponent`1<RendererGrid> {
    public static bool Paused;
    public GameObjectRef BatchPrefab;
    public float CellSize;
    public float MaxMilliseconds;
    public static float MinTimeBetweenRefreshes;
}
public class RendererInfo : ComponentInfo`1<Renderer> {
    public ShadowCastingMode shadows;
    public Material material;
    public Mesh mesh;
    public MeshFilter meshFilter;
    public virtual void Reset();
    public virtual void Setup();
}
public class RendererLOD : LODComponent {
    public float minDistanceMultiplier;
    public State[] States;
    [ReadOnlyAttribute]
public MeshRenderer collapsedRenderer;
    [ReadOnlyAttribute]
public MeshFilter collapsedFilter;
    public Mesh GetFinalLodMesh(Matrix4x4& localToWorldMatrix);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public static class RendererToggleDynamicEx : object {
}
public enum RenderType : Enum {
    public int value__;
    public static RenderType OPAQUE_DEFERRED;
    public static RenderType OPAQUE_FORWARDBASE;
    public static RenderType TRANSPARENT_FORWARDBASE;
    public static RenderType TRANSPARENT;
    public static RenderType UNDEFINED;
}
public class RepairBench : StorageContainer {
    public float maxConditionLostOnRepair;
    public GameObjectRef skinchangeEffect;
    public static float REPAIR_COST_FRACTION;
    private float nextSkinChangeAudioTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public static float GetRepairFraction(Item itemToRepair);
    public static float RepairCostFraction(Item itemToRepair);
    public static void GetRepairCostList(ItemBlueprint bp, List`1<ItemAmount> allIngredients);
    public static void StripComponentRepairCost(List`1<ItemAmount> allIngredients, float repairCostMultiplier);
    public void debugprint(string toPrint);
    [RPC_Server]
[IsVisible("3")]
public void ChangeSkin(RPCMessage msg);
    private void ApplySkinToItem(Item item, ulong Skin);
    [RPC_Server]
[IsVisible("3")]
public void RepairItem(RPCMessage msg);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint);
}
public class RepairBenchPanel : LootPanel {
    public RustText infoText;
    public GameObject repairButton;
    public GameObject skinLinkButton;
    public Color gotColor;
    public Color notGotColor;
    public Color skinColour;
    public Phrase phraseEmpty;
    public Phrase phraseNotRepairable;
    public Phrase phraseRepairNotNeeded;
    public Phrase phraseNoBlueprint;
    public GameObject skinsPanel;
    public GameObject changeSkinDialog;
    public IconSkinPicker picker;
    public GameObject costIconsParent;
    public List`1<VirtualItemIcon> costIcons;
}
public class RepairCostIndicator : SingletonComponent`1<RepairCostIndicator> {
    public RepairCostIndicatorRow[] Rows;
    public CanvasGroup Fader;
}
public class RepairCostIndicatorRow : MonoBehaviour {
    public RustText ItemName;
    public Image ItemSprite;
    public RustText Amount;
    public RectTransform FillRect;
    public Image BackgroundImage;
    public Color OkColour;
    public Color MissingColour;
}
public class RepeatingFirework : BaseFirework {
    public float timeBetweenRepeats;
    public int maxRepeats;
    public SoundPlayer launchSound;
    private int numFired;
    public virtual void Begin();
    public void SendFire();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class ResearchTable : StorageContainer {
    public float researchFinishedTime;
    public float researchCostFraction;
    public float researchDuration;
    public int requiredPaper;
    public GameObjectRef researchStartEffect;
    public GameObjectRef researchFailEffect;
    public GameObjectRef researchSuccessEffect;
    public ItemDefinition researchResource;
    public BasePlayer user;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public bool IsResearching();
    public int RarityMultiplier(Rarity rarity);
    public int GetBlueprintStacksize(Item sourceItem);
    public static int ScrapForResearch(Item item);
    public static int ScrapForResearch(ItemDefinition info);
    public bool IsItemResearchable(Item item);
    public virtual void ServerInit();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public Item GetTargetItem();
    public Item GetScrapItem();
    public virtual void PostServerLoad();
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    [RPC_Server]
[IsVisible("3")]
public void DoResearch(RPCMessage msg);
    public void ResearchAttemptFinished();
    public void CancelResearch();
    public void EndResearch();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class ResearchTablePanel : LootPanel {
    public Button researchButton;
    public RustText timerText;
    public GameObject itemDescNoItem;
    public GameObject itemDescTooBroken;
    public GameObject itemDescNotResearchable;
    public GameObject itemDescTooMany;
    public GameObject itemTakeBlueprint;
    public GameObject itemDescAlreadyResearched;
    public GameObject itemDescDefaultBlueprint;
    public RustText researchCostText;
    public ItemIcon scrapIcon;
    public bool wasResearching;
    public GameObject[] workbenchReqs;
}
public enum ReservedAIPointSlots : Enum {
    public int value__;
    public static ReservedAIPointSlots CoverPoint;
}
public enum ReservedEntitySlots : Enum {
    public int value__;
    public static ReservedEntitySlots Self;
    public static ReservedEntitySlots OwningPlayer;
    public static ReservedEntitySlots GroupLeader;
    public static ReservedEntitySlots SpecialEntity;
}
public enum ReservedPositionSlots : Enum {
    public int value__;
    public static ReservedPositionSlots HomePoint;
    public static ReservedPositionSlots GroupRoamPoint;
    public static ReservedPositionSlots RaycastTargetPoint;
    public static ReservedPositionSlots Vector3;
}
public class ResetPlacementMap : ProceduralComponent {
    public virtual void Process(UInt32 seed);
}
public class ReskinEffect : MonoBehaviour {
    public ParticleSystem TargetSystem;
}
public enum ResolutionType : Enum {
    public int value__;
    public static ResolutionType Low;
    public static ResolutionType Normal;
    public static ResolutionType High;
}
public class ResolutionTypeParameter : ParameterOverride`1<ResolutionType> {
}
public class ResourceContainer : EntityComponent`1<BaseEntity> {
    public bool lootable;
    public ItemContainer container;
    public float lastAccessTime;
    public int accessedSecondsAgo { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int get_accessedSecondsAgo();
    [RPC_Server]
[IsVisible("3")]
private void StartLootingContainer(RPCMessage msg);
}
public class ResourceDepositManager : BaseEntity {
    public static ResourceDepositManager _manager;
    private static int resolution;
    public Dictionary`2<Vector2i, ResourceDeposit> _deposits;
    public static Vector2i GetIndexFrom(Vector3 pos);
    public static ResourceDepositManager Get();
    public ResourceDeposit CreateFromPosition(Vector3 pos);
    public ResourceDeposit GetFromPosition(Vector3 pos);
    public static ResourceDeposit GetOrCreate(Vector3 pos);
}
public class ResourceDispenser : EntityComponent`1<BaseEntity> {
    public GatherType gatherType;
    public List`1<ItemAmount> containedItems;
    public float maxDestroyFractionForFinishBonus;
    public List`1<ItemAmount> finishBonus;
    public bool forceFullFinishBonus;
    public float fractionRemaining;
    private float categoriesRemaining;
    private float startingItemCounts;
    private static Dictionary`2<GatherType, HashSet`1<int>> cachedResourceItemTypes;
    public void Start();
    public void Initialize();
    private void CacheResourceTypeItems();
    public void DoGather(HitInfo info, BaseCorpse corpse);
    public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon);
    public void OnAttacked(HitInfo info);
    private void GiveResources(BasePlayer entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon);
    public void DestroyFraction(float fraction);
    private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon);
    private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive);
    private bool IsProducedItemOfGatherType(ItemAmount item);
    public virtual bool OverrideOwnership(Item item, AttackEntity weapon);
    private void UpdateVars();
    public void UpdateRemainingCategories();
    public void CountAllItems();
    private void UpdateFraction();
    public bool HasItemToDispense(ItemDefinition def);
}
public class ResourceEntity : BaseEntity {
    [FormerlySerializedAsAttribute("health")]
public float startHealth;
    [FormerlySerializedAsAttribute("protection")]
public ProtectionProperties baseProtection;
    public float health;
    public ResourceDispenser resourceDispenser;
    protected bool isKilled;
    public virtual void Load(LoadInfo info);
    public virtual void InitShared();
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual float MaxHealth();
    public virtual float Health();
    protected virtual void OnHealthChanged();
    public virtual void OnAttacked(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual float BoundsPadding();
}
public class ResourceExtractorFuelStorage : StorageContainer {
}
public class ResourceRef`1 : object {
    public string guid;
    protected T _cachedObject;
    public bool isValid { get; }
    public string resourcePath { get; }
    public UInt32 resourceID { get; }
    public bool get_isValid();
    public virtual T Get();
    public string get_resourcePath();
    public UInt32 get_resourceID();
}
public abstract class RevealTransitionBase : BaseMonoBehaviour {
    public Reveal[] Reveals;
}
public class RevealTransitionOnEnable : RevealTransitionBase {
}
[CreateAssetMenuAttribute]
public class ReverbSettings : ScriptableObject {
    [RangeAttribute("-10000", "0")]
public int room;
    [RangeAttribute("-10000", "0")]
public int roomHF;
    [RangeAttribute("-10000", "0")]
public int roomLF;
    [RangeAttribute("0,1", "20")]
public float decayTime;
    [RangeAttribute("0,1", "2")]
public float decayHFRatio;
    [RangeAttribute("-10000", "1000")]
public int reflections;
    [RangeAttribute("0", "0,3")]
public float reflectionsDelay;
    [RangeAttribute("-10000", "2000")]
public int reverb;
    [RangeAttribute("0", "0,1")]
public float reverbDelay;
    [RangeAttribute("1000", "20000")]
public float HFReference;
    [RangeAttribute("20", "1000")]
public float LFReference;
    [RangeAttribute("0", "100")]
public float diffusion;
    [RangeAttribute("0", "100")]
public float density;
}
public class ReverbZoneTrigger : TriggerBase {
    public Collider trigger;
    public AudioReverbZone reverbZone;
    public float lodDistance;
    public bool inRange;
    public ReverbSettings reverbSettings;
    public virtual void PreClientComponentCull(IPrefabProcessor p);
    public bool IsSyncedToParent();
}
public class RFBroadcaster : IOEntity {
    public int frequency;
    public GameObjectRef frequencyPanelPrefab;
    public static Flags Flag_Broadcasting;
    public bool playerUsable;
    private float nextChangeTime;
    private float nextStopTime;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual int GetFrequency();
    public virtual bool WantsPower(int inputIndex);
    public sealed virtual Vector3 GetPosition();
    public sealed virtual float GetMaxRange();
    public sealed virtual void RFSignalUpdate(bool on);
    [RPC_Server]
[IsVisible("3")]
public void ServerSetFrequency(RPCMessage msg);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public void StopBroadcasting();
    internal virtual void DoServerDestroy();
    public virtual void Load(LoadInfo info);
    private bool CanChangeFrequency(BasePlayer player);
}
public class RFManager : object {
    public static Dictionary`2<int, List`1<IRFObject>> _listeners;
    public static Dictionary`2<int, List`1<IRFObject>> _broadcasters;
    public static int minFreq;
    public static int maxFreq;
    private static int reserveRangeMin;
    private static int reserveRangeMax;
    public static string reserveString;
    private static RFManager();
    public static int ClampFrequency(int freq);
    public static List`1<IRFObject> GetListenList(int frequency);
    public static List`1<IRFObject> GetBroadcasterList(int frequency);
    public static void AddListener(int frequency, IRFObject obj);
    public static void RemoveListener(int frequency, IRFObject obj);
    public static void AddBroadcaster(int frequency, IRFObject obj);
    public static void RemoveBroadcaster(int frequency, IRFObject obj);
    public static bool IsReserved(int frequency);
    public static void ReserveErrorPrint(BasePlayer player);
    public static void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn);
    public static void MarkFrequencyDirty(int frequency);
}
public class RFReceiver : IOEntity {
    public int frequency;
    public GameObjectRef frequencyPanelPrefab;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual int GetFrequency();
    public virtual bool WantsPower(int inputIndex);
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public sealed virtual Vector3 GetPosition();
    public sealed virtual float GetMaxRange();
    public virtual void Init();
    internal virtual void DoServerDestroy();
    public sealed virtual void RFSignalUpdate(bool on);
    [IsVisible("3")]
[RPC_Server]
public void ServerSetFrequency(RPCMessage msg);
    public virtual bool CanUseNetworkCache(Connection connection);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    private bool CanChangeFrequency(BasePlayer player);
}
public class RFTimedExplosive : TimedExplosive {
    public SoundPlayer beepLoop;
    private ulong creatorPlayerID;
    public ItemDefinition pickupDefinition;
    public float minutesUntilDecayed;
    private int RFFrequency;
    private float decayTickDuration;
    private float minutesDecayed;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Vector3 GetPosition();
    public sealed virtual float GetMaxRange();
    public sealed virtual void RFSignalUpdate(bool on);
    public void SetFrequency(int newFreq);
    public sealed virtual int GetFrequency();
    public virtual void SetFuse(float fuseLength);
    public void ArmRF();
    public void DisarmRF();
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public void DecayCheck();
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    public void ChangeFrequency(int newFreq);
    public virtual void SetCreatorEntity(BaseEntity newCreatorEntity);
    [IsVisible("3")]
[RPC_Server]
public void Pickup(RPCMessage msg);
    public bool IsArmed();
    public virtual void Load(LoadInfo info);
    public bool CanPickup(BasePlayer player);
}
public enum RgbColor : Enum {
    public int value__;
    public static RgbColor Default;
    public static RgbColor BuildingPrivilege;
    public static RgbColor Cold;
    public static RgbColor Hot;
    public static RgbColor Hurt;
    public static RgbColor Healed;
    public static RgbColor Irradiated;
    public static RgbColor Comforted;
}
public class RgbEffects : SingletonComponent`1<RgbEffects> {
    [ClientVar]
public static bool Enabled;
    [ClientVar]
public static Vector3 ColorCorrection_SteelSeries;
    [ClientVar]
public static Vector3 ColorCorrection_Razer;
    [ClientVar]
public static float Brightness;
    public Color defaultColor;
    public Color buildingPrivilegeColor;
    public Color coldColor;
    public Color hotColor;
    public Color hurtColor;
    public Color healedColor;
    public Color irradiatedColor;
    public Color comfortedColor;
    private static RgbEffects();
    [ClientVar]
[EditorBrowsableAttribute("1")]
public static void ConVar_Static(Arg args);
    [ClientVar]
[EditorBrowsableAttribute("1")]
public static void ConVar_Pulse(Arg args);
}
public class RHIB : MotorRowboat {
    public Transform steeringWheelLeftHandTarget;
    public Transform steeringWheelRightHandTarget;
    [ServerVar]
public static float rhibpopulation;
    private float targetGasPedal;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [IsVisible("6")]
[RPC_Server]
public void Server_Release(RPCMessage msg);
    public virtual void VehicleFixedUpdate();
    public virtual bool EngineOn();
    public virtual void DriverInput(InputState inputState, BasePlayer player);
    public void AddFuel(int amount);
}
public class RHIBAIController : FacepunchBehaviour {
    public List`1<Vector3> nodes;
    [ContextMenu("Calculate Path")]
public void SetupPatrolPath();
    public float GetWaterDepth(Vector3 pos);
    public void OnDrawGizmosSelected();
}
public class RHIBDriver : BaseVehicleSeat {
}
public class RidableHorse : BaseRidableAnimal {
    public Phrase SwapToSingleTitle;
    public Phrase SwapToSingleDescription;
    public Sprite SwapToSingleIcon;
    public Phrase SwapToDoubleTitle;
    public Phrase SwapToDoubleDescription;
    public Sprite SwapToDoubleIcon;
    public ItemDefinition WildSaddleItem;
    [ServerVar]
public static float Population;
    public string distanceStatName;
    public HorseBreed[] breeds;
    public SkinnedMeshRenderer[] bodyRenderers;
    public SkinnedMeshRenderer[] hairRenderers;
    public int currentBreed;
    public ProtectionProperties riderProtection;
    public ProtectionProperties baseHorseProtection;
    public static Flags Flag_HideHair;
    public static Flags Flag_WoodArmor;
    public static Flags Flag_RoadsignArmor;
    public static Flags Flag_HasSingleSaddle;
    public static Flags Flag_HasDoubleSaddle;
    public float equipmentSpeedMod;
    private int prevBreed;
    private int prevSlots;
    private float distanceRecordingSpacing;
    public HitchTrough currentHitch;
    public float totalDistance;
    public float kmDistance;
    public float tempDistanceTravelled;
    public float RealisticMass { get; }
    protected float PositionTickRate { get; }
    private static RidableHorse();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public int GetStorageSlotCount();
    public virtual float get_RealisticMass();
    public void ApplyBreed(int index);
    protected void ApplyBreedInternal(HorseBreed breed);
    public HorseBreed GetBreed();
    public virtual float GetTrotSpeed();
    public virtual float GetRunSpeed();
    private void SpawnWildSaddle();
    public void SetForSale();
    public virtual bool IsStandCollisionClear();
    public virtual bool IsPlayerSeatSwapValid(BasePlayer player, int fromIndex, int toIndex, bool ignoreRestraint);
    public virtual int NumSwappableSeats();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public virtual void SetupCorpse(BaseCorpse corpse);
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public virtual void OnKilled(HitInfo hitInfo);
    public void SetBreed(int index);
    public virtual void LeadingChanged();
    public virtual void ServerInit();
    protected virtual float get_PositionTickRate();
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public bool IsHitched();
    public void SetHitch(HitchTrough Hitch);
    public virtual float ReplenishRatio();
    public virtual void EatNearbyFood();
    public void TryLeaveHitch();
    public void TryHitch();
    public void RecordDistance();
    public virtual void MarkDistanceTravelled(float amount);
    public virtual void Save(SaveInfo info);
    public virtual void OnClaimedWithToken(Item tokenItem);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual void OnInventoryDirty();
    public virtual bool CanAnimalAcceptItem(Item item, int targetSlot);
    public void EquipmentUpdate();
    private void SetSeatCount(int count);
    public virtual void DoNetworkUpdate();
    public int GetSaddleItemSeatCount(Item item);
    public bool HasSaddle();
    public bool HasSingleSaddle();
    public bool HasDoubleSaddle();
    private bool ItemIsSaddle(Item item);
    public virtual void Load(LoadInfo info);
    public virtual bool HasValidSaddle();
    public virtual bool HasSeatAvailable();
    public int GetSeatCapacity();
    protected virtual bool CanPushNow(BasePlayer pusher);
    [IsVisible("3")]
[RPC_Server]
public void RPC_ReqSwapSaddleType(RPCMessage msg);
    public virtual int MaxMounted();
    [ServerVar]
public static void setHorseBreed(Arg arg);
}
public class RightClickReceiver : MonoBehaviour {
    public UnityEvent ClickReceiver;
    public sealed virtual void OnPointerClick(PointerEventData eventData);
}
public class RigidbodyInfo : PrefabAttribute {
    public float mass;
    public float drag;
    public float angularDrag;
    protected virtual Type GetIndexedType();
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class RigidbodyLOD : LODComponent {
    public float Distance;
}
public class RiverInfo : MonoBehaviour {
    protected void Awake();
}
public class RoadBradleys : TriggeredEvent {
    private List`1<BradleyAPC> spawnedAPCs;
    public static int StaticBradleyCount;
    public int GetNumBradleys();
    public int GetDesiredNumber();
    private void CleanList();
    public virtual void RunEvent();
    public virtual void Kill();
}
public class RoadFlare : TimedExplosive {
    public virtual void ServerInit();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public sealed virtual bool IsValidHomingTarget();
    internal virtual void DoServerDestroy();
}
public class RockingChair : BaseChair {
    [HeaderAttribute("Rocking Settings")]
public float Acceleration;
    public float MaxRockingAngle;
    public float MaxRockVelocity;
    [TooltipAttribute("Preserve and apply some existing velocity when swinging back and forth.")]
public bool ApplyVelocityBetweenSwings;
    [RangeAttribute("0", "2")]
public float AppliedVelocity;
    [RangeAttribute("0", "2")]
public float WeaponFireImpact;
    [HeaderAttribute("Audio")]
public SoundDefinition creakForwardSoundDef;
    public SoundDefinition creakBackwardSoundDef;
    public float creakForwardAngle;
    public float creakBackwardAngle;
    public float creakVelocityThreshold;
    public AnimationCurve creakGainCurve;
    private float initLocalY;
    private Vector3 initLocalRot;
    private float velocity;
    private float oppositePotentialVelocity;
    private TimeSince timeSinceInput;
    private float sineTime;
    private float timeUntilStartSine;
    private float t;
    private float angle;
    private Quaternion max;
    private Quaternion min;
    public virtual void ServerInit();
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    private void SaveBaseLocalPos();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void OnWeaponFired(BaseProjectile weapon);
    public virtual void OnPlayerDismounted(BasePlayer player);
    private void PreventClipping(bool hasInput);
    private void CalculateVelocity(Vector2 currentInput);
    private void ApplyVelocity(float delta, bool hasInput);
    private void ResetChair();
    private Vector2 GetInputVector(InputState inputState);
    private static Vector2 ProcessInputVector(bool leftDown, bool rightDown, bool forwardDown, bool backDown);
    private float EaseOutCubic(float value);
    private float EaseOutCubicOvershoot(float value, float overshoot);
}
public class RotateCameraAroundObject : MonoBehaviour {
    public GameObject m_goObjectToRotateAround;
    public float m_flRotateSpeed;
    private void FixedUpdate();
}
public class RotateObject : MonoBehaviour {
    public float rotateSpeed_X;
    public float rotateSpeed_Y;
    public float rotateSpeed_Z;
    public bool localSpace;
    protected void Update();
}
public class RotateToCamera : MonoBehaviour {
    public float maxDistance;
}
public class rottest : MonoBehaviour {
    public Transform turretBase;
    public Vector3 aimDir;
    private void Start();
    private void Update();
    public void UpdateAiming();
}
public class RottingFlies : MonoBehaviour {
    public GameObjectRef effect;
    public SoundDefinition soundDef;
    public Transform rootBone;
}
public class RpcTarget : ValueType {
    public string Function;
    public SendInfo Connections;
    public bool ToNetworkGroup;
    public bool UsingPooledConnections;
    public static RpcTarget NetworkGroup(string funcName);
    public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity);
    public static RpcTarget NetworkGroup(string funcName, BaseNetworkable entity, SendMethod method, Priority priority);
    public static RpcTarget Player(string funcName, BasePlayer target);
    public static RpcTarget Player(string funcName, Connection connection);
    public static RpcTarget Players(string funcName, List`1<Connection> connections);
    public static RpcTarget Players(string funcName, List`1<Connection> connections, SendMethod method, Priority priority);
    public static RpcTarget SendInfo(string funcName, SendInfo sendInfo);
    public static RpcTarget PlayerAndSpectators(string funcName, BasePlayer player);
}
public class RunConsoleCommand : MonoBehaviour {
    public void ClientRun(string command);
}
public class RuntimeInterestNode : object {
    [CompilerGeneratedAttribute]
private Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private float <NextVisitTime>k__BackingField;
    public Vector3 Position { get; public set; }
    public float NextVisitTime { get; public set; }
    public RuntimeInterestNode(Vector3 position);
    [CompilerGeneratedAttribute]
public sealed virtual Vector3 get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Vector3 value);
    [CompilerGeneratedAttribute]
public sealed virtual float get_NextVisitTime();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NextVisitTime(float value);
}
public class RuntimePath : object {
    [CompilerGeneratedAttribute]
private IAIPathNode[] <Nodes>k__BackingField;
    private List`1<IAIPathSpeedZone> speedZones;
    private List`1<IAIPathInterestNode> interestNodes;
    public IAIPathNode[] Nodes { get; public set; }
    public IEnumerable`1<IAIPathSpeedZone> SpeedZones { get; }
    public IEnumerable`1<IAIPathInterestNode> InterestNodes { get; }
    [CompilerGeneratedAttribute]
public IAIPathNode[] get_Nodes();
    [CompilerGeneratedAttribute]
public void set_Nodes(IAIPathNode[] value);
    public sealed virtual IEnumerable`1<IAIPathSpeedZone> get_SpeedZones();
    public sealed virtual IEnumerable`1<IAIPathInterestNode> get_InterestNodes();
    public sealed virtual IAIPathNode GetClosestToPoint(Vector3 point);
    public sealed virtual void GetNodesNear(Vector3 point, List`1& nearNodes, float dist);
    public sealed virtual IAIPathInterestNode GetRandomInterestNodeAwayFrom(Vector3 from, float dist);
    public sealed virtual void AddInterestNode(IAIPathInterestNode interestNode);
    public sealed virtual void AddSpeedZone(IAIPathSpeedZone speedZone);
}
public class RuntimePathNode : object {
    [CompilerGeneratedAttribute]
private Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Straightaway>k__BackingField;
    private HashSet`1<IAIPathNode> linked;
    public Vector3 Position { get; public set; }
    public bool Straightaway { get; public set; }
    public IEnumerable`1<IAIPathNode> Linked { get; }
    public RuntimePathNode(Vector3 position);
    [CompilerGeneratedAttribute]
public sealed virtual Vector3 get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Vector3 value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Straightaway();
    [CompilerGeneratedAttribute]
public void set_Straightaway(bool value);
    public sealed virtual IEnumerable`1<IAIPathNode> get_Linked();
    public sealed virtual bool IsValid();
    public sealed virtual void AddLink(IAIPathNode link);
}
public class runtimeScript : MonoBehaviour {
    public ERRoadNetwork roadNetwork;
    public ERRoad road;
    public GameObject go;
    public int currentElement;
    public float distance;
    public float speed;
    private void Start();
    private void Update();
    private void OnDestroy();
}
public class RuntimeSpeedZone : object {
    public OBB worldOBBBounds;
    public float maxVelocityPerSec;
    public sealed virtual float GetMaxSpeed();
    public sealed virtual OBB WorldSpaceBounds();
}
public class Rust.Ai.AiLocationManager : FacepunchBehaviour {
    public static List`1<AiLocationManager> Managers;
    [SerializeField]
public AiLocationSpawner MainSpawner;
    [SerializeField]
public SquadSpawnerLocation LocationWhenMainSpawnerIsNull;
    public Transform CoverPointGroup;
    public Transform PatrolPointGroup;
    public CoverPointVolume DynamicCoverPointVolume;
    public bool SnapCoverPointsToGround;
    private List`1<PathInterestNode> patrolPoints;
    public SquadSpawnerLocation LocationType { get; }
    private static AiLocationManager();
    public SquadSpawnerLocation get_LocationType();
    private void Awake();
    private void OnDestroy();
    public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange, float maxRange);
    public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange, float maxRange, PathInterestNode currentPatrolPoint);
}
public class Rust.Ai.AiLocationSpawner : SpawnGroup {
    public SquadSpawnerLocation Location;
    public AiLocationManager Manager;
    public JunkPile Junkpile;
    public bool IsMainSpawner;
    public float chance;
    private int defaultMaxPopulation;
    private int defaultNumToSpawnPerTickMax;
    private int defaultNumToSpawnPerTickMin;
    public virtual void SpawnInitial();
    protected virtual void Spawn(int numToSpawn);
    protected virtual BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot);
}
[DefaultExecutionOrder("-102")]
public class Rust.Ai.AiManagedAgent : FacepunchBehaviour {
    [TooltipAttribute("TODO: Replace with actual agent type id on the NavMeshAgent when we upgrade to 5.6.1 or above.")]
public int AgentTypeIndex;
    [ReadOnlyAttribute]
public Vector2i NavmeshGridCoord;
    private bool isRegistered;
    private void OnEnable();
    private void DelayedRegistration();
    private void OnDisable();
}
[DefaultExecutionOrder("-103")]
public class Rust.Ai.AiManager : SingletonComponent`1<AiManager> {
    [HeaderAttribute("Cover System")]
[SerializeField]
public bool UseCover;
    public float CoverPointVolumeCellSize;
    public float CoverPointVolumeCellHeight;
    public float CoverPointRayLength;
    public CoverPointVolume cpvPrefab;
    [SerializeField]
public LayerMask DynamicCoverPointVolumeLayerMask;
    private WorldSpaceGrid`1<CoverPointVolume> coverPointVolumeGrid;
    [ServerVar]
public static bool nav_wait;
    [ServerVar]
public static bool nav_disable;
    [ServerVar]
public static bool setdestination_navmesh_failsafe;
    [ServerVar]
public static bool ai_dormant;
    [ServerVar]
public static float ai_to_player_distance_wakeup_range;
    [ServerVar]
public static int nav_obstacles_carve_state;
    [ServerVar]
public static int ai_dormant_max_wakeup_per_tick;
    [ServerVar]
public static float ai_htn_player_tick_budget;
    [ServerVar]
public static float ai_htn_player_junkpile_tick_budget;
    [ServerVar]
public static float ai_htn_animal_tick_budget;
    [ServerVar]
public static bool ai_htn_use_agency_tick;
    private BasePlayer[] playerVicinityQuery;
    private Func`2<BasePlayer, bool> filter;
    [ServerVar]
public static int pathfindingIterationsPerFrame { get; public set; }
    public bool repeat { get; }
    private static AiManager();
    internal void OnEnableAgency();
    internal void OnDisableAgency();
    internal void UpdateAgency();
    internal void OnEnableCover();
    internal void OnDisableCover();
    public static CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup);
    public CoverPointVolume GetCoverVolumeContaining(Vector3 point);
    public static void set_pathfindingIterationsPerFrame(int value);
    public static int get_pathfindingIterationsPerFrame();
    public bool get_repeat();
    public void Initialize();
    private void OnDisable();
    public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval);
    private static bool InterestedInPlayersOnly(BaseEntity entity);
}
public class Rust.AI.AStarNode : object {
    public AStarNode Parent;
    public float G;
    public float H;
    public IAIPathNode Node;
    public float F { get; }
    public AStarNode(float g, float h, AStarNode parent, IAIPathNode node);
    public float get_F();
    public void Update(float g, float h, AStarNode parent, IAIPathNode node);
    public bool Satisfies(IAIPathNode node);
    public static bool op_LessThan(AStarNode lhs, AStarNode rhs);
    public static bool op_GreaterThan(AStarNode lhs, AStarNode rhs);
}
public class Rust.AI.AStarNodeList : List`1<AStarNode> {
    private AStarNodeComparer comparer;
    public bool Contains(IAIPathNode n);
    public AStarNode GetAStarNodeOf(IAIPathNode n);
    public void AStarNodeSort();
}
public static class Rust.AI.AStarPath : object {
    private static float Heuristic(IAIPathNode from, IAIPathNode to);
    public static bool FindPath(IAIPathNode start, IAIPathNode goal, Stack`1& path, Single& pathCost);
}
public class Rust.Ai.CoverPoint : object {
    [CompilerGeneratedAttribute]
private CoverPointVolume <Volume>k__BackingField;
    public CoverType NormalCoverType;
    public bool IsDynamic;
    public Transform SourceTransform;
    private Vector3 _staticPosition;
    private Vector3 _staticNormal;
    [CompilerGeneratedAttribute]
private BaseEntity <ReservedFor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompromised>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Score>k__BackingField;
    public CoverPointVolume Volume { get; private set; }
    public Vector3 Position { get; public set; }
    public Vector3 Normal { get; public set; }
    public BaseEntity ReservedFor { get; public set; }
    public bool IsReserved { get; }
    public bool IsCompromised { get; public set; }
    public float Score { get; public set; }
    public CoverPoint(CoverPointVolume volume, float score);
    [CompilerGeneratedAttribute]
public CoverPointVolume get_Volume();
    [CompilerGeneratedAttribute]
private void set_Volume(CoverPointVolume value);
    public Vector3 get_Position();
    public void set_Position(Vector3 value);
    public Vector3 get_Normal();
    public void set_Normal(Vector3 value);
    [CompilerGeneratedAttribute]
public BaseEntity get_ReservedFor();
    [CompilerGeneratedAttribute]
public void set_ReservedFor(BaseEntity value);
    public bool get_IsReserved();
    [CompilerGeneratedAttribute]
public bool get_IsCompromised();
    [CompilerGeneratedAttribute]
public void set_IsCompromised(bool value);
    [CompilerGeneratedAttribute]
public float get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(float value);
    public bool IsValidFor(BaseEntity entity);
    public void CoverIsCompromised(float cooldown);
    [IteratorStateMachineAttribute("Rust.Ai.CoverPoint/<StartCooldown>d__33")]
private IEnumerator StartCooldown(float cooldown);
    public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold);
}
[RequireComponent("UnityEngine.Collider")]
public class Rust.Ai.CoverPointBlockerVolume : MonoBehaviour {
}
public class Rust.Ai.CoverPointVolume : MonoBehaviour {
    public float DefaultCoverPointScore;
    public float CoverPointRayLength;
    public LayerMask CoverLayerMask;
    public Transform BlockerGroup;
    public Transform ManualCoverPointGroup;
    [ServerVar]
public static float cover_point_sample_step_size;
    [ServerVar]
public static float cover_point_sample_step_height;
    public List`1<CoverPoint> CoverPoints;
    private List`1<CoverPointBlockerVolume> _coverPointBlockers;
    private float _dynNavMeshBuildCompletionTime;
    private int _genAttempts;
    private Bounds bounds;
    public bool repeat { get; }
    private static CoverPointVolume();
    public bool get_repeat();
    public Nullable`1<float> ExecuteUpdate(float deltaTime, float nextInterval);
    [ContextMenu("Clear Cover Points")]
private void ClearCoverPoints();
    public Bounds GetBounds();
    [ContextMenu("Pre-Generate Cover Points")]
public void PreGenerateCoverPoints();
    [ContextMenu("Convert to Manual Cover Points")]
public void ConvertToManualCoverPoints();
    public void GenerateCoverPoints(Transform coverPointGroup);
    private CoverPoint CalculateCoverPoint(NavMeshHit info);
    internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, RaycastHit& rayHit);
    public bool Contains(Vector3 point);
}
public class Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileSpawner : MonoBehaviour {
    public GameObjectRef ScientistPrefab;
    public List`1<BaseCombatEntity> Spawned;
    public BaseSpawnPoint[] SpawnPoints;
    public int MaxPopulation;
    public bool InitialSpawn;
    public float MinRespawnTimeMinutes;
    public float MaxRespawnTimeMinutes;
    public float MovementRadius;
    public bool ReducedLongRangeAccuracy;
    public JunkpileType SpawnType;
    [RangeAttribute("0", "1")]
public float SpawnBaseChance;
    private float nextRespawnTime;
    private bool pendingRespawn;
    public int currentPopulation { get; }
    public sealed virtual int get_currentPopulation();
    private void Awake();
    protected void OnDestroy();
    public sealed virtual void Fill();
    public sealed virtual void Clear();
    public sealed virtual void SpawnInitial();
    public sealed virtual void SpawnRepeating();
    public void CheckIfRespawnNeeded();
    private bool IsAllSpawnedDead();
    public void ScheduleRespawn();
    public void DoRespawn();
    public void SpawnScientist();
    private BaseSpawnPoint GetSpawnPoint(Vector3& pos, Quaternion& rot);
}
public class Rust.Ai.ManualCoverPoint : FacepunchBehaviour {
    public bool IsDynamic;
    public float Score;
    public CoverPointVolume Volume;
    public Vector3 Normal;
    public CoverType NormalCoverType;
    public Vector3 Position { get; }
    public float DirectionMagnitude { get; }
    public Vector3 get_Position();
    public float get_DirectionMagnitude();
    private void Awake();
    public CoverPoint ToCoverPoint(CoverPointVolume volume);
}
public class Rust.Ai.Memory : object {
    public List`1<BaseEntity> Visible;
    public List`1<SeenInfo> All;
    public List`1<ExtendedInfo> AllExtended;
    public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo);
    public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, ExtendedInfo& extendedInfo);
    public SeenInfo Update(BaseEntity ent, float danger);
    public SeenInfo Update(BaseEntity ent, Vector3 position, float danger);
    public void AddDanger(Vector3 position, float amount);
    public SeenInfo GetInfo(BaseEntity entity);
    public SeenInfo GetInfo(Vector3 position);
    public ExtendedInfo GetExtendedInfo(BaseEntity entity);
    internal void Forget(float maxSecondsOld);
}
public class Rust.Ai.NavmeshPrefabInstantiator : MonoBehaviour {
    public GameObjectRef NavmeshPrefab;
    private void Start();
}
public class Rust.Ai.ScientistSpawner : SpawnGroup {
    [HeaderAttribute("Scientist Spawner")]
public bool Mobile;
    public bool NeverMove;
    public bool SpawnHostile;
    public bool OnlyAggroMarkedTargets;
    public bool IsPeacekeeper;
    public bool IsBandit;
    public bool IsMilitaryTunnelLab;
    public WaypointSet Waypoints;
    public Transform[] LookAtInterestPointsStationary;
    public Vector2 RadioEffectRepeatRange;
    public Model Model;
    [SerializeField]
private AiLocationManager _mgr;
    private float _nextForcedRespawn;
    private bool _lastSpawnCallHadAliveMembers;
    private bool _lastSpawnCallHadMaxAliveMembers;
    protected virtual void Spawn(int numToSpawn);
    protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint);
    protected virtual void OnDrawGizmos();
}
public class Rust.AI.SimpleAIMemory : object {
    public static HashSet`1<BasePlayer> PlayerIgnoreList;
    public List`1<SeenInfo> All;
    public List`1<BaseEntity> Players;
    public HashSet`1<BaseEntity> LOS;
    public List`1<BaseEntity> Targets;
    public List`1<BaseEntity> Threats;
    public List`1<BaseEntity> Friendlies;
    private static SimpleAIMemory();
    public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses);
    public void SetLOS(BaseEntity ent, bool flag);
    public bool IsLOS(BaseEntity ent);
    public bool IsPlayerKnown(BasePlayer player);
    public void Forget(float secondsOld);
    public static void AddIgnorePlayer(BasePlayer player);
    public static void RemoveIgnorePlayer(BasePlayer player);
    public static void ClearIgnoredPlayers();
    public static string GetIgnoredPlayers();
}
public class Rust.Ai.WaypointSet : MonoBehaviour {
    [SerializeField]
private List`1<Waypoint> _points;
    [SerializeField]
private NavModes navMode;
    public List`1<Waypoint> Points { get; public set; }
    public NavModes NavMode { get; }
    public List`1<Waypoint> get_Points();
    public void set_Points(List`1<Waypoint> value);
    public NavModes get_NavMode();
    private void OnDrawGizmos();
}
public enum Rust.DamageType : Enum {
    public int value__;
    public static DamageType Generic;
    public static DamageType Hunger;
    public static DamageType Thirst;
    public static DamageType Cold;
    public static DamageType Drowned;
    public static DamageType Heat;
    public static DamageType Bleeding;
    public static DamageType Poison;
    public static DamageType Suicide;
    public static DamageType Bullet;
    public static DamageType Slash;
    public static DamageType Blunt;
    public static DamageType Fall;
    public static DamageType Radiation;
    public static DamageType Bite;
    public static DamageType Stab;
    public static DamageType Explosion;
    public static DamageType RadiationExposure;
    public static DamageType ColdExposure;
    public static DamageType Decay;
    public static DamageType ElectricShock;
    public static DamageType Arrow;
    public static DamageType AntiVehicle;
    public static DamageType Collision;
    public static DamageType Fun_Water;
    public static DamageType LAST;
}
public class Rust.DamageTypeEntry : object {
    public DamageType type;
    public float amount;
}
[ExtensionAttribute]
public static class Rust.DamageTypeEx : object {
    [ExtensionAttribute]
public static bool IsMeleeType(DamageType damageType);
    [ExtensionAttribute]
public static bool IsBleedCausing(DamageType damageType);
    [ExtensionAttribute]
public static bool IsConsideredAnAttack(DamageType damageType);
    [ExtensionAttribute]
public static bool InterruptsRestraintMinigame(DamageType damageType);
}
public class Rust.DamageTypeList : object {
    public Single[] types;
    public void Set(DamageType index, float amount);
    public float Get(DamageType index);
    public void Add(DamageType index, float amount);
    public void Scale(DamageType index, float amount);
    public bool Has(DamageType index);
    public float Total();
    public void Clear();
    public void Add(List`1<DamageTypeEntry> entries);
    public void ScaleAll(float amount);
    public DamageType GetMajorityDamageType();
    public bool Contains(DamageType damage);
    public bool IsMeleeType();
    public bool IsBleedCausing();
    public bool IsConsideredAnAttack();
    public DamageTypeList Clone();
}
public static class Rust.Defines : object {
    public static UInt32 appID;
    public static string resourceFolder;
    private static Defines();
}
internal static class Rust.GameInfo : object {
    internal static bool IsOfficialServer { get; }
    internal static bool HasAchievements { get; }
    internal static bool get_IsOfficialServer();
    internal static bool get_HasAchievements();
}
public class Rust.GC : MonoBehaviour {
    public static int gcLowerBounds;
    public static int gcDefaultValue;
    public static int gcEditorDefaultValue;
    public static bool Enabled { get; }
    private static GC();
    public static bool get_Enabled();
    public static void Collect();
    public static int GetSafeGCValue(int val);
    public static long GetTotalMemory();
    public static int CollectionCount();
}
public static class Rust.Generic : object {
    private static Scene _batchingScene;
    public static Scene BatchingScene { get; }
    public static Scene get_BatchingScene();
}
public enum Rust.Instruments.Notes : Enum {
    public int value__;
    public static Notes A;
    public static Notes B;
    public static Notes C;
    public static Notes D;
    public static Notes E;
    public static Notes F;
    public static Notes G;
}
public class Rust.Interpolation.FloatSnapshot : ValueType {
    [CompilerGeneratedAttribute]
private float <Time>k__BackingField;
    public float value;
    public float Time { get; public set; }
    public FloatSnapshot(float time, float value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual float get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(float value);
    public sealed virtual void MatchValuesTo(FloatSnapshot entry);
    public sealed virtual void Lerp(FloatSnapshot prev, FloatSnapshot next, float delta);
    public sealed virtual FloatSnapshot GetNew();
}
public class Rust.Interpolation.GenericLerp`1 : object {
    private Interpolator`1<T> interpolator;
    private IGenericLerpTarget`1<T> target;
    private static T snapshotPrototype;
    private static float timeOffset;
    private float timeOffset0;
    private float timeOffset1;
    private float timeOffset2;
    private float timeOffset3;
    private int timeOffsetCount;
    private int TimeOffsetInterval { get; }
    private float LerpTime { get; }
    public GenericLerp`1(IGenericLerpTarget`1<T> target, int listCount);
    private static GenericLerp`1();
    private int get_TimeOffsetInterval();
    private float get_LerpTime();
    public void Tick();
    public void Snapshot(T snapshot);
    public void SnapTo(T snapshot);
    public void SnapToNow(T snapshot);
    public void SnapToEnd();
    public sealed virtual void Dispose();
    private void Wipe();
}
public interface Rust.Interpolation.IGenericLerpTarget`1 {
    public abstract virtual float GetInterpolationDelay(LerpType lerpType);
    public abstract virtual float GetInterpolationSmoothing();
    public abstract virtual void SetFrom(T snapshot);
    public abstract virtual T GetCurrentState();
    public abstract virtual void DebugInterpolationState(Segment<T> segment, List`1<T> entries);
}
public class Rust.Interpolation.Interpolator`1 : object {
    public List`1<T> list;
    public T last;
    public Interpolator`1(int listCount);
    public void Add(T tick);
    public void Cull(float beforeTime);
    public void Clear();
    public Segment<T> Query(float time, float interpolation, float extrapolation, float smoothing, T& t);
}
public interface Rust.Interpolation.ISnapshot`1 {
    public float Time { get; public set; }
    public abstract virtual float get_Time();
    public abstract virtual void set_Time(float value);
    public abstract virtual void MatchValuesTo(T entry);
    public abstract virtual void Lerp(T prev, T next, float delta);
    public abstract virtual T GetNew();
}
public class Rust.Interpolation.TransformSnapshot : ValueType {
    [CompilerGeneratedAttribute]
private float <Time>k__BackingField;
    public Vector3 pos;
    public Quaternion rot;
    public float Time { get; public set; }
    public TransformSnapshot(float time, Vector3 pos, Quaternion rot);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual float get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(float value);
    public sealed virtual void MatchValuesTo(TransformSnapshot entry);
    public sealed virtual void Lerp(TransformSnapshot prev, TransformSnapshot next, float delta);
    public sealed virtual TransformSnapshot GetNew();
}
public class Rust.Modular.ConditionalObject : object {
    public GameObject gameObject;
    public GameObject ownerGameObject;
    public ConditionalSocketSettings[] socketSettings;
    public bool restrictOnHealth;
    public float healthRestrictionMin;
    public float healthRestrictionMax;
    public bool restrictOnAdjacent;
    public AdjacentCondition adjacentRestriction;
    public AdjacentMatchType adjacentMatch;
    public bool restrictOnLockable;
    public bool lockableRestriction;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsActive>k__BackingField;
    public Nullable`1<bool> IsActive { get; private set; }
    public ConditionalObject(GameObject conditionalGO, GameObject ownerGO, int socketsTaken);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsActive();
    [CompilerGeneratedAttribute]
private void set_IsActive(Nullable`1<bool> value);
    public void SetActive(bool active);
    public void RefreshActive();
}
public class Rust.Modular.ConditionalSocketSettings : object {
    public bool restrictOnLocation;
    public LocationCondition locationRestriction;
    public bool restrictOnWheel;
    public SocketWheelType wheelRestriction;
    public bool HasSocketRestrictions { get; }
    public bool get_HasSocketRestrictions();
}
public class Rust.Modular.EnableDisableEvent : MonoBehaviour {
    [SerializeField]
private UnityEvent enableEvent;
    [SerializeField]
private UnityEvent disableEvent;
    protected void OnEnable();
    protected void OnDisable();
}
[ExtensionAttribute]
public static class Rust.Modular.EngineItemTypeEx : object {
    [ExtensionAttribute]
public static bool BoostsAcceleration(EngineItemTypes engineItemType);
    [ExtensionAttribute]
public static bool BoostsTopSpeed(EngineItemTypes engineItemType);
    [ExtensionAttribute]
public static bool BoostsFuelEconomy(EngineItemTypes engineItemType);
}
public class Rust.Modular.EngineStorage : StorageContainer {
    [HeaderAttribute("Engine Storage")]
public Sprite engineIcon;
    public float internalDamageMultiplier;
    public EngineItemTypes[] slotTypes;
    [SerializeField]
public VehicleModuleEngineItems allEngineItems;
    [SerializeField]
[ReadOnlyAttribute]
public int accelerationBoostSlots;
    [ReadOnlyAttribute]
[SerializeField]
public int topSpeedBoostSlots;
    [ReadOnlyAttribute]
[SerializeField]
public int fuelEconomyBoostSlots;
    [CompilerGeneratedAttribute]
private bool <isUsable>k__BackingField;
    [CompilerGeneratedAttribute]
private float <accelerationBoostPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private float <topSpeedBoostPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private float <fuelEconomyBoostPercent>k__BackingField;
    public bool isUsable { get; public set; }
    public float accelerationBoostPercent { get; public set; }
    public float topSpeedBoostPercent { get; public set; }
    public float fuelEconomyBoostPercent { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_isUsable();
    [CompilerGeneratedAttribute]
public void set_isUsable(bool value);
    [CompilerGeneratedAttribute]
public float get_accelerationBoostPercent();
    [CompilerGeneratedAttribute]
public void set_accelerationBoostPercent(float value);
    [CompilerGeneratedAttribute]
public float get_topSpeedBoostPercent();
    [CompilerGeneratedAttribute]
public void set_topSpeedBoostPercent(float value);
    [CompilerGeneratedAttribute]
public float get_fuelEconomyBoostPercent();
    [CompilerGeneratedAttribute]
public void set_fuelEconomyBoostPercent(float value);
    public VehicleModuleEngine GetEngineModule();
    public float GetAveragedLoadoutPercent();
    public virtual void Load(LoadInfo info);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public int GetValidSlot(Item item);
    public virtual void OnInventoryFirstCreated(ItemContainer container);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public void RefreshLoadoutData();
    public virtual void Save(SaveInfo info);
    public void OnModuleDamaged(float damageTaken);
    public void AdminAddParts(int tier);
    public float GetContainerItemsValueFor(Func`2<EngineItemTypes, bool> boostConditional);
    public float GetTierValue(int tier);
}
public class Rust.Modular.ItemModEngineItem : ItemMod {
    public EngineItemTypes engineItemType;
    [RangeAttribute("1", "3")]
public int tier;
}
public class Rust.Modular.ItemModVehicleChassis : ItemMod {
    public GameObjectRef entityPrefab;
    [RangeAttribute("1", "6")]
public int socketsTaken;
    public int SocketsTaken { get; }
    public sealed virtual int get_SocketsTaken();
}
public class Rust.Modular.ItemModVehicleModule : ItemMod {
    public GameObjectRef entityPrefab;
    [RangeAttribute("1", "2")]
public int socketsTaken;
    public int SocketsTaken { get; }
    public sealed virtual int get_SocketsTaken();
    public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation);
}
public class Rust.Modular.ModularCarAudio : GroundVehicleAudio {
    public bool showDebug;
    [SerializeField]
[HeaderAttribute("Skid")]
private SoundDefinition skidSoundLoop;
    [SerializeField]
private SoundDefinition skidSoundDirtLoop;
    [SerializeField]
private SoundDefinition skidSoundSnowLoop;
    [SerializeField]
private float skidMinSlip;
    [SerializeField]
private float skidMaxSlip;
    [HeaderAttribute("Movement & Suspension")]
[SerializeField]
private SoundDefinition movementStartOneshot;
    [SerializeField]
private SoundDefinition movementStopOneshot;
    [SerializeField]
private float movementStartStopMinTimeBetweenSounds;
    [SerializeField]
private SoundDefinition movementRattleLoop;
    [SerializeField]
private float movementRattleMaxSpeed;
    [SerializeField]
private float movementRattleMaxAngSpeed;
    [SerializeField]
private float movementRattleIdleGain;
    [SerializeField]
private SoundDefinition suspensionLurchSound;
    [SerializeField]
private float suspensionLurchMinExtensionDelta;
    [SerializeField]
private float suspensionLurchMinTimeBetweenSounds;
    [SerializeField]
[HeaderAttribute("Wheels")]
private SoundDefinition tyreRollingSoundDef;
    [SerializeField]
private SoundDefinition tyreRollingWaterSoundDef;
    [SerializeField]
private SoundDefinition tyreRollingGrassSoundDef;
    [SerializeField]
private SoundDefinition tyreRollingSnowSoundDef;
    [SerializeField]
private AnimationCurve tyreRollGainCurve;
}
public class Rust.Modular.ModularVehicleInventory : object {
    private ItemContainer moduleContainer;
    private ItemContainer chassisContainer;
    private BaseModularVehicle vehicle;
    public ItemContainer ModuleContainer { get; }
    public ItemContainer ChassisContainer { get; }
    public ItemContainerId UID { get; }
    private int TotalSockets { get; }
    public ModularVehicleInventory(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID);
    public ItemContainer get_ModuleContainer();
    public ItemContainer get_ChassisContainer();
    public ItemContainerId get_UID();
    private int get_TotalSockets();
    public sealed virtual void Dispose();
    public void GiveUIDs();
    public bool SocketIsFree(int socketIndex, Item moduleItem);
    public bool SocketIsTaken(int socketIndex);
    public bool TryAddModuleItem(Item moduleItem, int socketIndex);
    public bool RemoveAndDestroy(Item itemToRemove);
    public int TryGetFreeSocket(int socketsTaken);
    public int TryGetFreeSocket(Item moduleItem, int socketsTaken);
    public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem);
    public bool TrySyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex);
    private bool SocketIsUsed(Item item, int slotIndex);
    private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID);
    private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID);
    private void OnSocketInventoryAddRemove(Item moduleItem, bool added);
    private void ModuleItemAdded(Item moduleItem, int socketIndex);
    private void ModuleItemRemoved(Item moduleItem);
    private void OnModuleItemChanged(Item moduleItem);
    private bool ItemFilter(Item item, int targetSlot);
}
public class Rust.Modular.ModularVehicleSocket : object {
    [SerializeField]
private Transform socketTransform;
    [SerializeField]
private SocketWheelType wheelType;
    [SerializeField]
private SocketLocationType locationType;
    public Vector3 WorldPosition { get; }
    public Quaternion WorldRotation { get; }
    public SocketWheelType WheelType { get; }
    public SocketLocationType LocationType { get; }
    public Vector3 get_WorldPosition();
    public Quaternion get_WorldRotation();
    public SocketWheelType get_WheelType();
    public SocketLocationType get_LocationType();
    public bool ShouldBeActive(ConditionalSocketSettings modelSettings);
}
[CreateAssetMenuAttribute]
public class Rust.Modular.VehicleModuleEngineItems : ScriptableObject {
    [SerializeField]
private ItemModEngineItem[] engineItems;
    public bool TryGetItem(int tier, EngineItemTypes type, ItemModEngineItem& output);
}
public class Rust.Modular.VehicleModuleSlidingComponent : object {
    public string interactionColliderName;
    public Flags flag_SliderOpen;
    public float moveTime;
    public SlidingPart[] slidingParts;
    public SoundDefinition openSoundDef;
    public SoundDefinition closeSoundDef;
    private float positionPercent;
    public bool WantsOpenPos(BaseEntity parentEntity);
    public void Use(BaseVehicleModule parentModule);
    public void ServerUpdateTick(BaseVehicleModule parentModule);
    private void CheckPosition(BaseEntity parentEntity, float dt);
}
public abstract class Rust.Nexus.Handlers.BaseNexusRequestHandler`1 : object {
    [CompilerGeneratedAttribute]
private NexusZoneDetails <FromZone>k__BackingField;
    [CompilerGeneratedAttribute]
private Uuid <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private Response <Response>k__BackingField;
    private bool _fireAndForget;
    protected NexusZoneDetails FromZone { get; private set; }
    protected Uuid RequestId { get; private set; }
    protected T Request { get; private set; }
    public Response Response { get; private set; }
    [CompilerGeneratedAttribute]
protected NexusZoneDetails get_FromZone();
    [CompilerGeneratedAttribute]
private void set_FromZone(NexusZoneDetails value);
    [CompilerGeneratedAttribute]
protected Uuid get_RequestId();
    [CompilerGeneratedAttribute]
private void set_RequestId(Uuid value);
    [CompilerGeneratedAttribute]
protected T get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(T value);
    [CompilerGeneratedAttribute]
public sealed virtual Response get_Response();
    [CompilerGeneratedAttribute]
private void set_Response(Response value);
    public void Initialize(NexusZoneDetails fromZone, Uuid id, bool fireAndForget, T request);
    public sealed virtual void EnterPool();
    public sealed virtual void LeavePool();
    public sealed virtual void Execute();
    protected abstract virtual void Handle();
    protected virtual void Reset();
    protected void SendSuccess();
    protected void SendSuccess(Response response);
    protected void SendResult(bool success);
    protected void SendResult(bool success, Response response);
    protected void SendError(string message);
    protected static Response NewResponse();
}
public class Rust.Nexus.Handlers.ClanChatBatchHandler : BaseNexusRequestHandler`1<ClanChatBatchRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.DestroyBagHandler : BaseNexusRequestHandler`1<SleepingBagDestroyRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.FerryRetireHandler : BaseNexusRequestHandler`1<FerryRetireRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.FerryStatusHandler : BaseNexusRequestHandler`1<FerryStatusRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.FerryUpdateScheduleHandler : BaseNexusRequestHandler`1<FerryUpdateScheduleRequest> {
    protected virtual void Handle();
}
public interface Rust.Nexus.Handlers.INexusRequestHandler {
    public Response Response { get; }
    public abstract virtual Response get_Response();
    public abstract virtual void Execute();
}
public class Rust.Nexus.Handlers.PingHandler : BaseNexusRequestHandler`1<PingRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.PlayerManifestHandler : BaseNexusRequestHandler`1<PlayerManifestRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.RespawnAtBagHandler : BaseNexusRequestHandler`1<SleepingBagRespawnRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.SpawnOptionsHandler : BaseNexusRequestHandler`1<SpawnOptionsRequest> {
    protected virtual void Handle();
}
public class Rust.Nexus.Handlers.TransferHandler : BaseNexusRequestHandler`1<TransferRequest> {
    private static Dictionary`2<ulong, ulong> UidMapping;
    private static Dictionary`2<NetworkableId, Entity> UidToEntity;
    private static Dictionary`2<BaseEntity, Entity> EntityToSpawn;
    private static Dictionary`2<ulong, BasePlayer> SpawnedPlayers;
    private static List`1<string> PlayerIds;
    private static List`1<NetworkableId> EntitiesToProtect;
    private static Dictionary`2<ulong, PlayerTeam> TeamMapping;
    private static TransferHandler();
    protected virtual void Handle();
    [AsyncStateMachineAttribute("Rust.Nexus.Handlers.TransferHandler/<CompleteTransfers>d__8")]
private static void CompleteTransfers();
    private void RepositionEntitiesFromTransfer();
    private void SpawnEntities(Dictionary`2<ulong, BasePlayer> players);
    [CompilerGeneratedAttribute]
internal static void <Handle>g__UpdateWithNewUid|7_0(UidType type, UInt64& prevUid);
}
public static class Rust.Numlock : object {
    private static byte VK_NUMLOCK;
    private static UInt32 KEYEVENTF_EXTENDEDKEY;
    private static int KEYEVENTF_KEYUP;
    private static int KEYEVENTF_KEYDOWN;
    public static bool IsOn { get; }
    private static short GetKeyState(int keyCode);
    private static void keybd_event(byte bVk, byte bScan, UInt32 dwFlags, int dwExtraInfo);
    public static bool get_IsOn();
    public static void TurnOn();
}
public static class Rust.Server : object {
    public static float UseDistance;
    private static Scene _entityScene;
    public static Scene EntityScene { get; }
    public static Scene get_EntityScene();
}
public class Rust.UI.ClockSlider : RustSlider {
    private bool isUpdatingText;
    public float Value { get; public set; }
    public virtual float get_Value();
    public virtual void set_Value(float value);
    protected virtual void Awake();
    public void OnEndEdit(string text);
    public void TextChanged(string text);
    private void UpdateValue(string text, bool updateText);
    private string FormatText(float value);
    private void UpdateTextNoNotify(string text);
}
public class Rust.UI.MainMenu.Hero : SingletonComponent`1<Hero> {
    public CanvasGroup CanvasGroup;
    public Video VideoPlayer;
    public RustText TitleText;
    public RustText ButtonText;
    public HttpImage TitleImage;
    [HeaderAttribute("Item Store Links")]
public RustButton ItemStoreButton;
    public RustButton LimitedTabButton;
    public RustButton GeneralTabButton;
}
public class Rust.UI.MuteListController : UIDialog {
    public RectTransform ListParent;
    public GameObjectRef UserWidget;
    public SteamFriendsList SearchList;
}
public class Rust.UI.ReportBug : UIDialog {
    public GameObject GetInformation;
    public GameObject Finished;
    public RustInput Subject;
    public RustInput Message;
    public RustButton ReportButton;
    public RustButtonGroup Category;
    public RustIcon ProgressIcon;
    public RustText ProgressText;
    public RawImage ScreenshotImage;
    public GameObject ScreenshotRoot;
    public UIBackgroundBlur BlurController;
    public RustButton SubmitButton;
    public GameObject SubmitErrorRoot;
    public RustText CooldownText;
    public RustText ContentMissingText;
}
public class Rust.UI.ReportPlayer : UIDialog {
    public GameObject FindPlayer;
    public GameObject GetInformation;
    public GameObject Finished;
    public GameObject RecentlyReported;
    public Dropdown ReasonDropdown;
    public RustInput Subject;
    public RustInput Message;
    public RustButton ReportButton;
    public SteamUserButton SteamUserButton;
    public RustIcon ProgressIcon;
    public RustText ProgressText;
    public static Option[] ReportReasons;
    private static ReportPlayer();
}
public class Rust.UI.ServerAdmin.ServerAdminConvarInfo : MonoBehaviour {
    public RustText InfoName;
    public RustText InfoValue;
    public RustInput VariableInput;
    public Tooltip TooltipComponent;
}
public class Rust.UI.ServerAdmin.ServerAdminPlayerEntry : MonoBehaviour {
    public RustText PlayerName;
    public RustText Ping;
    public RustButton Button;
}
public class Rust.UI.ServerAdmin.ServerAdminPlayerId : MonoBehaviour {
    public RustText PlayerName;
    public RustText PlayerId;
}
public class Rust.UI.ServerAdmin.ServerAdminPlayerInfo : MonoBehaviour {
    public RustText PlayerName;
    public RustText SteamID;
    public RustText OwnerSteamID;
    public RustText Ping;
    public RustText Address;
    public RustText ConnectedTime;
    public RustText ViolationLevel;
    public RustText Health;
    public RustInput KickReasonInput;
    public RustInput BanReasonInput;
}
public class Rust.UI.ServerAdmin.ServerAdminServerInfo : MonoBehaviour {
    public RustText InfoName;
    public RustText InfoValue;
}
public class Rust.UI.ServerAdmin.ServerAdminUGCEntry : MonoBehaviour {
}
public class Rust.UI.ServerAdmin.ServerAdminUGCEntryAudio : ServerAdminUGCEntry {
    public AudioSource AudioSpeaker;
    public RustText DurationText;
    public RustSlider ProgressSlider;
    public RustIcon PlayIcon;
}
public class Rust.UI.ServerAdmin.ServerAdminUGCEntryImage : ServerAdminUGCEntry {
    public RawImage Image;
    public RectTransform Backing;
    public GameObject MultiImageRoot;
    public RustText ImageIndex;
    public Vector2 OriginalImageSize;
}
public class Rust.UI.ServerAdmin.ServerAdminUGCEntryPattern : ServerAdminUGCEntry {
    public GameObjectRef StarPrefab;
    public RectTransform StarRoot;
}
public class Rust.UI.ServerAdmin.ServerAdminUGCEntryStub : MonoBehaviour {
    public ServerAdminUGCEntryAudio AudioWidget;
    public ServerAdminUGCEntryImage ImageWidget;
    public ServerAdminUGCEntryPattern PatternWidget;
    public RustText PrefabName;
    public RustButton HistoryButton;
    public ServerAdminPlayerId[] HistoryIds;
}
public class Rust.UI.ServerAdmin.ServerAdminUI : SingletonComponent`1<ServerAdminUI> {
    public GameObjectRef PlayerEntry;
    public RectTransform PlayerInfoParent;
    public RustText PlayerCount;
    public RustInput PlayerNameFilter;
    public GameObjectRef ServerInfoEntry;
    public RectTransform ServerInfoParent;
    public GameObjectRef ConvarInfoEntry;
    public GameObjectRef ConvarInfoLongEntry;
    public RectTransform ConvarInfoParent;
    public ServerAdminPlayerInfo PlayerInfo;
    public RustInput UgcNameFilter;
    public GameObjectRef ImageEntry;
    public GameObjectRef PatternEntry;
    public GameObjectRef SoundEntry;
    public VirtualScroll UgcVirtualScroll;
    public GameObject ExpandedUgcRoot;
    public RawImage ExpandedImage;
    public RectTransform ExpandedImageBacking;
}
public class Rust.UI.SteamInventoryCrafting : MonoBehaviour {
    public GameObject Container;
    public ToggleGroup ToggleGroup;
    public Button ConvertToItem;
    public Button DeleteButton;
    public TextMeshProUGUI WoodAmount;
    public TextMeshProUGUI ClothAmount;
    public TextMeshProUGUI MetalAmount;
    public TextMeshProUGUI InfoText;
    [CompilerGeneratedAttribute]
private IPlayerItemDefinition <ResultItem>k__BackingField;
    [CompilerGeneratedAttribute]
private Coroutine <MarketCoroutine>k__BackingField;
    public SteamInventoryCrateOpen CraftModal;
    public GameObject CraftingContainer;
    public GameObject CraftingButton;
    public SteamInventoryNewItem NewItemModal;
    public IPlayerItemDefinition ResultItem { get; private set; }
    public Coroutine MarketCoroutine { get; private set; }
    [CompilerGeneratedAttribute]
public IPlayerItemDefinition get_ResultItem();
    [CompilerGeneratedAttribute]
private void set_ResultItem(IPlayerItemDefinition value);
    [CompilerGeneratedAttribute]
public Coroutine get_MarketCoroutine();
    [CompilerGeneratedAttribute]
private void set_MarketCoroutine(Coroutine value);
}
public class Rust.UI.SteamInventoryCrateOpen : MonoBehaviour {
    public TextMeshProUGUI Name;
    public TextMeshProUGUI Requirements;
    public TextMeshProUGUI Label;
    public HttpImage IconImage;
    public GameObject ErrorPanel;
    public TextMeshProUGUI ErrorText;
    public GameObject CraftButton;
    public GameObject ProgressPanel;
    public SteamInventoryNewItem NewItemModal;
}
public class Rust.UI.SteamInventoryIcon : MonoBehaviour {
}
public class Rust.UI.SteamInventoryItem : MonoBehaviour {
    public IPlayerItem Item;
    public HttpImage Image;
    public bool Setup(IPlayerItem item);
}
public class Rust.UI.SteamInventoryManager : SingletonComponent`1<SteamInventoryManager> {
    public GameObject inventoryItemPrefab;
    public GameObject inventoryCanvas;
    public GameObject missingItems;
    public SteamInventoryCrafting CraftControl;
    public List`1<GameObject> items;
    public GameObject LoadingOverlay;
}
public class Rust.UI.SteamInventoryNewItem : MonoBehaviour {
    [AsyncStateMachineAttribute("Rust.UI.SteamInventoryNewItem/<Open>d__0")]
public Task Open(IPlayerItem item);
}
[RequireComponent("UnityEngine.UI.Toggle")]
internal class Rust.UI.Utility.ForceWeather : MonoBehaviour {
    private Toggle component;
    public bool Rain;
    public bool Fog;
    public bool Wind;
    public bool Clouds;
    public void OnEnable();
    public void Update();
}
[BurstCompileAttribute]
internal class Rust.Water5.GetHeightBatchedJob : ValueType {
    public NativeArray`1<float3> Positions;
    public int Count;
    public float OneOverOctave0Scale;
    public NativeOceanDisplacementShort3 SimData;
    public int Spectrum0;
    public int Spectrum1;
    public int Frame0;
    public int Frame1;
    public float spectrumBlend;
    public float frameBlend;
    public sealed virtual void Execute();
    private float GetHeightRaw(float3 position);
    private Vector3 GetDisplacement(float3 position);
    private float3 GetDisplacement(float normX, float normZ);
    private float3 GetDisplacementFromSimData(int x, int z);
}
[DefaultMemberAttribute("Item")]
internal class Rust.Water5.NativeOceanDisplacementShort3 : ValueType {
    private NativeArray`1<OceanDisplacementShort3> _arr;
    private int spectrumCount;
    private int frameCount;
    public OceanDisplacementShort3 Item { get; public set; }
    public int Length { get; }
    public static NativeOceanDisplacementShort3 Create(int x, int y, int z);
    public static NativeOceanDisplacementShort3 Create(OceanDisplacementShort3[0...,0...,0...] simData);
    public OceanDisplacementShort3 get_Item(int x, int y, int z);
    public void set_Item(int x, int y, int z, OceanDisplacementShort3 value);
    public OceanDisplacementShort3* GetUnsafePtr();
    public ReadOnly<OceanDisplacementShort3> GetNativeRawReadOnly();
    public NativeArray`1<OceanDisplacementShort3> GetNativeRaw();
    public int get_Length();
    public sealed virtual void Dispose();
}
public class Rust.Water5.OceanDisplacementShort3 : ValueType {
    private static float precision;
    private static float float2short;
    private static float short2float;
    public short x;
    public short y;
    public short z;
    public static Vector3 op_Implicit(OceanDisplacementShort3 v);
    public static OceanDisplacementShort3 op_Implicit(Vector3 v);
    public static OceanDisplacementShort3 op_Implicit(float3 v);
    public static float3 op_Implicit(OceanDisplacementShort3 v);
}
public class Rust.Water5.OceanSimulation : object {
    public static int octaveCount;
    public static int simulationSize;
    public static int physicsSimulationSize;
    public static int physicsFrameRate;
    public static int physicsLooptime;
    public static int physicsFrameCount;
    public static float phsyicsDeltaTime;
    public static float oneOverPhysicsSimulationSize;
    public static int physicsFrameSize;
    public static int physicsSpectrumOffset;
    private OceanSettings oceanSettings;
    private Single[] spectrumRanges;
    private float distanceAttenuationFactor;
    private float depthAttenuationFactor;
    private static float oneOverOctave0Scale;
    private static Single[] beaufortValues;
    private int spectrum0;
    private int spectrum1;
    private float spectrumBlend;
    private int frame0;
    private int frame1;
    private float frameBlend;
    private float currentTime;
    private float prevUpdateComputeTime;
    private float deltaTime;
    private NativeOceanDisplacementShort3 nativeSimData;
    private GetHeightBatchedJob _cachedBatchJob;
    private NativeArray`1<float3> _batchPositionQueryArr;
    public int Spectrum0 { get; }
    public int Spectrum1 { get; }
    public float SpectrumBlend { get; }
    public int Frame0 { get; }
    public int Frame1 { get; }
    public float FrameBlend { get; }
    public OceanSimulation(OceanSettings oceanSettings);
    public int get_Spectrum0();
    public int get_Spectrum1();
    public float get_SpectrumBlend();
    public int get_Frame0();
    public int get_Frame1();
    public float get_FrameBlend();
    public void Update(float time, float dt, float beaufort);
    private static void FindSpectra(float beaufort, Int32& spectrum0, Int32& spectrum1, Single& spectrumT);
    public static void FindFrames(float time, Int32& frame0, Int32& frame1, Single& frameBlend);
    public bool Trace(Ray ray, float maxDist, Vector3& result);
    public float MinLevel();
    public float MaxLevel();
    public static float GetHeight(Vector3[0...,0...,0...] simData, Vector3 position, float time, float beaufort, float distAttenFactor, float depthAttenFactor);
    public static Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, Vector3 position, float time, float beaufort);
    public static Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, Vector3 position, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend);
    public static Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, float normX, float normZ, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend);
    public static Vector3 GetDisplacement(Vector3[0...,0...,0...] simData, int x, int y, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend);
    public sealed virtual void Dispose();
    public void GetHeightBatch(Vector2[] positions, Single[] heights, Single[] shore, Single[] terrainHeight);
    public float GetHeight(Vector3 position);
    private void PopulateBatchNative(Vector3 position);
    private void PopulateBatchNative(Vector2[] positions);
    public float GetHeightAttenuation(float shore, float terrainHeight);
    public float GetHeightAttenuation(Vector3 position);
}
[CreateAssetMenuAttribute]
public class Rust.Water5.OceanSpectrumSettings : ScriptableObject {
    public OceanSettings oceanSettings;
    [HeaderAttribute("Deep Wave Settings")]
public float g;
    public float beaufort;
    public float depth;
    public SpectrumSettings local;
    public SpectrumSettings swell;
    [HeaderAttribute("Material Settings")]
public Color color;
    public Color specColor;
    public float smoothness;
    public Color waterColor;
    public Color waterExtinction;
    public float scatteringCoefficient;
    public Color subSurfaceColor;
    public float subSurfaceFalloff;
    public float subSurfaceBase;
    public float subSurfaceSun;
    public float subSurfaceAmount;
    public float foamAmount;
    public float foamScale;
    public Color foamColor;
    public Color baseFoamColor;
    [ButtonAttribute("Update Spectrum")]
public void UpdateSpectrum();
}
public class Rust.Water5.SpectrumParameters : ValueType {
    public float scale;
    public float angle;
    public float spreadBlend;
    public float swell;
    public float alpha;
    public float peakOmega;
    public float gamma;
    public float shortWavesFade;
}
public class Rust.Water5.SpectrumSettings : ValueType {
    [RangeAttribute("0", "1")]
public float scale;
    public float windSpeed;
    public float fetch;
    [RangeAttribute("0", "1")]
public float spreadBlend;
    [RangeAttribute("0", "1")]
public float swell;
    public float peakEnhancement;
    public float shortWavesFade;
}
public abstract class RustCamera`1 : SingletonComponent`1<T> {
    [SerializeField]
private AmplifyOcclusionEffect ssao;
    [SerializeField]
private SEScreenSpaceShadows contactShadows;
    [SerializeField]
private VisualizeTexelDensity visualizeTexelDensity;
    [SerializeField]
private EnvironmentVolumePropertiesCollection environmentVolumeProperties;
    [SerializeField]
private PostProcessLayer post;
    [SerializeField]
private PostProcessVolume baseEffectVolume;
}
[CreateAssetMenuAttribute]
public class RustEmojiConfig : ScriptableObject {
    public bool Hide;
    public EmojiSource Source;
}
public class RustEmojiLibrary : BaseScriptableObject {
    public static NetworkableId EmojiStorageNetworkId;
    [HideInInspector]
public RustEmojiConfig[] Configs;
    public RenderTextureDescriptor RenderTextureDesc;
    public int InitialPoolSize;
    private List`1<EmojiSource> all;
    private List`1<EmojiSource> conditionalAccessOnly;
    public GameObjectRef VideoPlayerRef;
    private static RustEmojiLibrary _instance;
    private static bool hasPrewarmed;
    private static long MAX_FILE_SIZE_BYTES;
    public static int MAX_TEX_SIZE_PIXELS;
    public static Dictionary`2<string, ServerEmojiConfig> allServerEmoji;
    private static bool hasLoaded;
    public static List`1<string> cachedServerList;
    public static RustEmojiLibrary Instance { get; }
    private static RustEmojiLibrary();
    public static RustEmojiLibrary get_Instance();
    private void Prewarm();
    public bool TryGetEmoji(string key, EmojiSource& er, Int32& skinVariantIndex, Int32& allIndex, bool serverSide);
    public static void FindAllServerEmoji();
    public static void ResetServerEmoji();
    private static bool CheckByteArray(long arrayLength);
    public static bool CheckByteArray(int arrayLength);
}
public class RustigeEgg : BaseCombatEntity {
    public static Flags Flag_Spin;
    public Transform eggRotationTransform;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsSpinning();
    [RPC_Server]
[IsVisible("3")]
public void RPC_Spin(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_Open(RPCMessage msg);
    public void CloseEgg();
}
[Factory("log")]
public class RustLog : ConsoleSystem {
    private static String[] names;
    public static Int32[] Levels;
    private static RustLog();
    [ServerVar]
[ClientVar]
public static void Level(Arg args);
    public static int GetLevel(EntryType type);
    public static void Log(EntryType type, int level, GameObject gameObject, string msg);
    public static void Log(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1);
    public static void Log(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2);
    public static void Log(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3);
    private static void LogImpl(EntryType type, string msg, GameObject gameObject);
}
public class RustPlatformHooks : object {
    public static RustPlatformHooks Instance;
    public UInt32 SteamAppId { get; }
    public Nullable`1<ServerParameters> ServerParameters { get; }
    private static RustPlatformHooks();
    public sealed virtual UInt32 get_SteamAppId();
    public sealed virtual void Abort();
    public sealed virtual void OnItemDefinitionsChanged();
    public sealed virtual Nullable`1<ServerParameters> get_ServerParameters();
    public sealed virtual void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response, string rawResponse);
}
public static class SafeMode : object {
}
public class SamSite : ContainerIOEntity {
    public Animator pitchAnimator;
    public GameObject yaw;
    public GameObject pitch;
    public GameObject gear;
    public Transform eyePoint;
    public float gearEpislonDegrees;
    public float turnSpeed;
    public float clientLerpSpeed;
    public Vector3 currentAimDir;
    public Vector3 targetAimDir;
    public float vehicleScanRadius;
    public float missileScanRadius;
    public GameObjectRef projectileTest;
    public GameObjectRef muzzleFlashTest;
    public bool staticRespawn;
    public ItemDefinition ammoType;
    public Transform[] tubes;
    [ServerVar]
public static float staticrepairseconds;
    public SoundDefinition yawMovementLoopDef;
    public float yawGainLerp;
    public float yawGainMovementSpeedMult;
    public SoundDefinition pitchMovementLoopDef;
    public float pitchGainLerp;
    public float pitchGainMovementSpeedMult;
    public int lowAmmoThreshold;
    public Flags Flag_TargetMode;
    public Flags Flag_ManuallySetMode;
    public static SamTargetType targetTypeUnknown;
    public static SamTargetType targetTypeVehicle;
    public static SamTargetType targetTypeMissile;
    public ISamSiteTarget currentTarget;
    public SamTargetType mostRecentTargetType;
    public Item ammoItem;
    public float lockOnTime;
    public float lastTargetVisibleTime;
    public int lastAmmoCount;
    public int currentTubeIndex;
    public int firedCount;
    public float nextBurstTime;
    private int input1Amount;
    private static SamSite();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool IsPowered();
    public virtual int ConsumptionAmount();
    public bool IsInDefenderMode();
    public virtual void Load(LoadInfo info);
    public void SetTarget(ISamSiteTarget target);
    public void MarkIODirty();
    public void ClearTarget();
    public virtual void ServerInit();
    public void OnItemAddedRemoved(Item arg1, bool arg2);
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public void SelfHeal();
    public virtual void Die(HitInfo info);
    public void FixedUpdate();
    public Vector3 GetAimDir();
    public bool HasValidTarget();
    public virtual bool CanPickup(BasePlayer player);
    private void AddTargetSet(List`1<ISamSiteTarget> allTargets, float scanRadius);
    private void AddMLRSRockets(List`1<ISamSiteTarget> allTargets, float scanRadius);
    public void TargetScan();
    public virtual bool HasAmmo();
    public void Reload();
    public void EnsureReloaded();
    public bool IsReloading();
    public void WeaponTick();
    public void FireProjectile(Vector3 origin, Vector3 direction, float speedMultiplier);
    public virtual int GetPassthroughAmount(int outputSlot);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("1")]
private void ToggleDefenderMode(RPCMessage msg);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
}
public class Sandstorm : MonoBehaviour {
    public ParticleSystem m_psSandStorm;
    public float m_flSpeed;
    public float m_flSwirl;
    public float m_flEmissionRate;
    private void Start();
    private void Update();
}
public class SantaSleigh : BaseEntity {
    public GameObjectRef prefabDrop;
    public SpawnFilter filter;
    public Transform dropOrigin;
    [ServerVar]
public static float altitudeAboveTerrain;
    [ServerVar]
public static float desiredAltitude;
    public Light bigLight;
    public SoundPlayer hohoho;
    public float hohohospacing;
    public float hohoho_additional_spacing;
    public Vector3 swimScale;
    public Vector3 swimSpeed;
    public float appliedSwimScale;
    public float appliedSwimRotation;
    private Vector3 startPos;
    private Vector3 endPos;
    private float secondsToTake;
    private float secondsTaken;
    private bool dropped;
    public Vector3 dropPosition;
    private float swimRandom;
    private static string path;
    private static SantaSleigh();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual float GetNetworkTime();
    public void InitDropPosition(Vector3 newDropPosition);
    public virtual void ServerInit();
    public void SendHoHoHo();
    public Vector3 RandomDropPosition();
    public void UpdateDropPosition(Vector3 newDropPosition);
    private void FixedUpdate();
    [ServerVar]
public static void drop(Arg arg);
}
public class SaveRestore : SingletonComponent`1<SaveRestore> {
    public static bool IsSaving;
    public static DateTime SaveCreatedTime;
    private static RealTimeSince TimeSinceLastSave;
    private static MemoryStream SaveBuffer;
    [CompilerGeneratedAttribute]
private static string <WipeId>k__BackingField;
    public static string WipeId { get; private set; }
    private static SaveRestore();
    [CompilerGeneratedAttribute]
public static string get_WipeId();
    [CompilerGeneratedAttribute]
private static void set_WipeId(string value);
    [IteratorStateMachineAttribute("SaveRestore/<Save>d__8")]
public static IEnumerator Save(string strFilename, bool AndWait);
    private static void ShiftSaveBackups(string fileName);
    private void Start();
    [IteratorStateMachineAttribute("SaveRestore/<SaveRegularly>d__11")]
private IEnumerator SaveRegularly();
    [IteratorStateMachineAttribute("SaveRestore/<DoAutomatedSave>d__12")]
private IEnumerator DoAutomatedSave(bool AndWait);
    public static bool Save(bool AndWait);
    public static List`1<BaseEntity> FindMapEntities();
    public static void ClearMapEntities(List`1<BaseEntity> entities);
    public static void SpawnMapEntities(List`1<BaseEntity> entities);
    public static bool Load(string strFilename, bool allowOutOfDateSaves);
    public static void GetSaveCache();
    public static void InitializeEntityLinks();
    public static void InitializeEntitySupports();
    public static void InitializeEntityConditionals();
    public static void InitializeWipeId();
    [CompilerGeneratedAttribute]
internal static string <ShiftSaveBackups>g__GetBackupName|9_0(int i, <>c__DisplayClass9_0& );
}
public class ScaleByIntensity : MonoBehaviour {
    public Vector3 initialScale;
    public Light intensitySource;
    public float maxIntensity;
    private void Start();
    private void Update();
}
public class ScaleBySpeed : MonoBehaviour {
    public float minScale;
    public float maxScale;
    public float minSpeed;
    public float maxSpeed;
    public MonoBehaviour component;
    public bool toggleComponent;
    public bool onlyWhenSubmerged;
    public float submergedThickness;
    private Vector3 prevPosition;
}
public class ScaleParticleSystem : ScaleRenderer {
    public ParticleSystem pSystem;
    public bool scaleGravity;
    private float startSize;
    private float startLifeTime;
    private float startSpeed;
    private float startGravity;
    public virtual void GatherInitialValues();
    public virtual void SetScale_Internal(float scale);
}
public class ScaleRenderer : MonoBehaviour {
    public bool useRandomScale;
    public float scaleMin;
    public float scaleMax;
    private float lastScale;
    protected bool hasInitialValues;
    public Renderer myRenderer;
    private bool ScaleDifferent(float newScale);
    public void Start();
    public void SetScale(float scale);
    public virtual void SetScale_Internal(float scale);
    public virtual void SetRendererEnabled(bool isEnabled);
    public virtual void GatherInitialValues();
}
public class ScaleTrailRenderer : ScaleRenderer {
    private TrailRenderer trailRenderer;
    private float startWidth;
    private float endWidth;
    private float duration;
    private float startMultiplier;
    public virtual void GatherInitialValues();
    public virtual void SetScale_Internal(float scale);
}
public class ScaleTransform : ScaleRenderer {
    private Vector3 initialScale;
    public virtual void SetScale_Internal(float scale);
    public virtual void GatherInitialValues();
}
public class ScarecrowBrain : BaseAIBrain {
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
}
public class ScarecrowNPC : NPCPlayer {
    [CompilerGeneratedAttribute]
private ScarecrowBrain <Brain>k__BackingField;
    public float BaseAttackRate;
    [HeaderAttribute("Loot")]
public LootSpawnSlot[] LootSpawnSlots;
    public LootSpawnSlot[] bonusLootSlots;
    public static float NextBeanCanAllowedTime;
    public bool BlockClothingOnCorpse;
    public bool RoamAroundHomePoint;
    public GameObjectRef soulReleaseEffect;
    public bool wasSoulReleased;
    public ScarecrowBrain Brain { get; public set; }
    public FamilyEnum Family { get; }
    protected string CorpsePath { get; }
    protected bool ShouldCorpseTakeChildren { get; }
    protected string OverrideCorpseName { get; }
    public virtual float StartHealth();
    public virtual float StartMaxHealth();
    public virtual float MaxHealth();
    [CompilerGeneratedAttribute]
public ScarecrowBrain get_Brain();
    [CompilerGeneratedAttribute]
public void set_Brain(ScarecrowBrain value);
    public virtual FamilyEnum get_Family();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void TryThink();
    public virtual void ServerThink(float delta);
    public virtual string Categorize();
    public virtual void EquipWeapon(bool skipDeployDelay);
    public sealed virtual float EngagementRange();
    public sealed virtual bool IsThreat(BaseEntity entity);
    public sealed virtual bool IsTarget(BaseEntity entity);
    public sealed virtual bool IsFriendly(BaseEntity entity);
    public sealed virtual bool CanAttack(BaseEntity entity);
    public sealed virtual bool IsTargetInRange(BaseEntity entity, Single& dist);
    public sealed virtual bool CanSeeTarget(BaseEntity entity);
    public sealed virtual bool NeedsToReload();
    public sealed virtual bool Reload();
    public sealed virtual float CooldownDuration();
    public sealed virtual bool IsOnCooldown();
    public sealed virtual bool StartAttacking(BaseEntity target);
    private void Attack(BaseCombatEntity target);
    public sealed virtual void StopAttacking();
    public sealed virtual float GetAmmoFraction();
    public sealed virtual BaseEntity GetBestTarget();
    public sealed virtual void AttackTick(float delta, BaseEntity target, bool targetIsLOS);
    public virtual bool ShouldDropActiveItem();
    protected virtual string get_CorpsePath();
    protected virtual bool get_ShouldCorpseTakeChildren();
    protected virtual string get_OverrideCorpseName();
    protected virtual void ApplyLoot(NPCPlayerCorpse corpse);
    public virtual void Hurt(HitInfo info);
    public virtual void AttackerInfo(DeathInfo info);
}
public enum Scene2SceneMode : Enum {
    public int value__;
    public static Scene2SceneMode Client;
    public static Scene2SceneMode Server;
    public static Scene2SceneMode Generic;
}
public class ScenePrefab : MonoBehaviour {
    private static string MarkerGameObjectName;
    public string ServerScene;
    public string ClientScene;
    public string GenericScene;
    public string PrefabPath;
    [CompilerGeneratedAttribute]
private bool <NeedsPreProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private Scene <Scene>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <loadCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <scenePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <sceneName>k__BackingField;
    public bool NeedsPreProcess { get; private set; }
    public Scene Scene { get; private set; }
    private bool loadCanceled { get; private set; }
    private string scenePath { get; private set; }
    private string sceneName { get; private set; }
    public bool IsServer { get; }
    [CompilerGeneratedAttribute]
public bool get_NeedsPreProcess();
    [CompilerGeneratedAttribute]
private void set_NeedsPreProcess(bool value);
    [CompilerGeneratedAttribute]
public Scene get_Scene();
    [CompilerGeneratedAttribute]
private void set_Scene(Scene value);
    [CompilerGeneratedAttribute]
private bool get_loadCanceled();
    [CompilerGeneratedAttribute]
private void set_loadCanceled(bool value);
    [CompilerGeneratedAttribute]
private string get_scenePath();
    [CompilerGeneratedAttribute]
private void set_scenePath(string value);
    [CompilerGeneratedAttribute]
private string get_sceneName();
    [CompilerGeneratedAttribute]
private void set_sceneName(string value);
    public bool get_IsServer();
    private void Start();
    private void OnDestroy();
    private void OnSceneLoaded(AsyncOperation obj);
    private void FindLoadedScene();
    private string GetPrefabPath();
    private void RunPreProcess();
    private void CreateMarkerObjectInScene(Scene scene);
    private bool IsMarkerObject(GameObject go);
    private void RepositionScene();
    private void DeleteEntities();
    private void ActivateSceneRoots();
    private void UnloadScene();
    [CompilerGeneratedAttribute]
private bool <FindLoadedScene>b__30_0(GameObject x);
}
public class SceneToPrefab : MonoBehaviour {
    public bool flattenHierarchy;
    public GameObject outputPrefab;
    [TooltipAttribute("If true the HLOD generation will be skipped and the previous results will be used, good to use if non-visual changes were made (eg.triggers)")]
public bool skipAllHlod;
    [ServerVar]
[ClientVar]
public static bool monument_scenes_enabled;
    private static Dictionary`2<string, string> autospawnToSceneSpawner;
    public static string Label_Scene;
    public static string Label_ClientScene;
    public static string Label_ServerScene;
    public static string Label_GenericScene;
    public static bool TryRemapAutospawnToSceneSpawner(string autospawnPath, String& spawnerPath);
    private static string ConvertAutospawnToRemappedPath(string prefabPath);
    private static string ConvertRemappedToAutospawnPath(string remappedPath);
}
public class SceneToPrefabTag : MonoBehaviour {
    public TagType Type;
    public int SpecificLOD;
}
public class ScientistBrain : BaseAIBrain {
    public static int Count;
    public virtual void AddStates();
    public virtual void InitializeAI();
    public virtual void OnDestroy();
    public HumanNPC GetEntity();
    protected virtual void OnStateChanged();
}
public class ScientistNPC : HumanNPC {
    public GameObjectRef[] RadioChatterEffects;
    public GameObjectRef[] DeathEffects;
    public string deathStatName;
    public static Phrase ScientistName;
    public Vector2 IdleChatterRepeatRange;
    public RadioChatterType radioChatterType;
    public float lastAlertedTime;
    public string displayName { get; }
    private static ScientistNPC();
    public virtual string get_displayName();
    public void SetChatterType(RadioChatterType newType);
    public virtual void ServerInit();
    public void IdleCheck();
    public void QueueRadioChatter();
    public virtual bool ShotTest(float targetDist);
    public void Alert();
    public virtual void OnAttacked(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public void PlayRadioChatter();
    public virtual void EquipWeapon(bool skipDeployDelay);
    public sealed virtual bool IsMounted();
}
public class Scoreboard : MonoBehaviour {
    public static Scoreboard instance;
    public RustText scoreboardTitle;
    public RectTransform scoreboardRootContents;
    public RustText scoreLimitText;
    public GameObject teamPrefab;
    public GameObject columnPrefab;
    public GameObject dividerPrefab;
    public Color localPlayerColor;
    public Color otherPlayerColor;
    public TeamColumn[] teamColumns;
    public GameObject[] TeamPanels;
}
public class ScrapTransportHelicopter : PlayerHelicopter {
    [SerializeField]
private Transform searchlightEye;
    [SerializeField]
private BoxCollider parentTriggerCollider;
    [HeaderAttribute("Damage Effects")]
[SerializeField]
private ParticleSystemContainer tailDamageLight;
    [SerializeField]
private ParticleSystemContainer tailDamageHeavy;
    [SerializeField]
private ParticleSystemContainer mainEngineDamageLight;
    [SerializeField]
private ParticleSystemContainer mainEngineDamageHeavy;
    [SerializeField]
private ParticleSystemContainer cockpitSparks;
    [SerializeField]
private Transform tailDamageLightEffects;
    [SerializeField]
private Transform mainEngineDamageLightEffects;
    [SerializeField]
private SoundDefinition damagedFireSoundDef;
    [SerializeField]
private SoundDefinition damagedFireTailSoundDef;
    [SerializeField]
private SoundDefinition damagedSparksSoundDef;
    [SerializeField]
private float pilotRotorScale;
    [SerializeField]
private float compassOffset;
    [ServerVar]
public static float population;
    public static string PASSENGER_ACHIEVEMENT;
    public static int PASSENGER_ACHIEVEMENT_REQ_COUNT;
    public virtual void ServerInit();
    public virtual void OnHealthChanged(float oldvalue, float newvalue);
    public void DelayedNetworking();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public sealed virtual float GetDamageMultiplier(BaseEntity ent);
    public sealed virtual void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
    protected virtual bool CanPushNow(BasePlayer pusher);
}
public class ScrapTransportHelicopterWheelEffects : MonoBehaviour {
    public WheelCollider wheelCollider;
    public GameObjectRef impactEffect;
    public float minTimeBetweenEffects;
    public float minDistBetweenEffects;
    private bool wasGrounded;
    private float lastEffectPlayed;
    private Vector3 lastCollisionPos;
    public void Update();
    private void DoImpactEffect();
}
public class ScreenBounce : BaseScreenShake {
    public AnimationCurve bounceScale;
    public AnimationCurve bounceSpeed;
    public AnimationCurve bounceViewmodel;
    private float bounceTime;
    private Vector3 bounceVelocity;
    public virtual void Setup();
    public virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
public class ScreenBounceFade : BaseScreenShake {
    public AnimationCurve bounceScale;
    public AnimationCurve bounceSpeed;
    public AnimationCurve bounceViewmodel;
    public AnimationCurve distanceFalloff;
    public AnimationCurve timeFalloff;
    private float bounceTime;
    private Vector3 bounceVelocity;
    public float maxDistance;
    public float scale;
    public virtual void Setup();
    public virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
public class ScreenFov : BaseScreenShake {
    public AnimationCurve FovAdjustment;
    public virtual void Setup();
    public virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
[PostProcessAttribute("ScreenOverlayRenderer", "2", "Custom/ScreenOverlay", "True")]
public class ScreenOverlay : PostProcessEffectSettings {
    public OverlayBlendModeParameter blendMode;
    public FloatParameter intensity;
    public TextureParameter texture;
    public TextureParameter normals;
    public BoolParameter respectUseLightingConvar;
}
public class ScreenOverlayRenderer : PostProcessEffectRenderer`1<ScreenOverlay> {
    private Shader overlayShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class ScreenRotate : BaseScreenShake {
    public AnimationCurve Pitch;
    public AnimationCurve Yaw;
    public AnimationCurve Roll;
    public AnimationCurve ViewmodelEffect;
    public float scale;
    public bool useViewModelEffect;
    public virtual void Setup();
    public virtual void Run(float delta, CachedTransform`1& cam, CachedTransform`1& vm);
}
public class Screenshot : SingletonComponent`1<Screenshot> {
    public string screenshotPath;
    public int sizeMultiplier;
}
public class ScreenshotCamera : RustCamera`1<ScreenshotCamera> {
    public static List`1<ScreenshotCamera> activeScreenshotCameras;
    private static ScreenshotCamera();
}
public class ScreenSpaceRefractionParams : ValueType {
    [RangeAttribute("0,001", "1")]
public float screenWeightDistance;
    public static ScreenSpaceRefractionParams Default;
    private static ScreenSpaceRefractionParams();
}
public class ScriptableObjectRef : ResourceRef`1<ScriptableObject> {
}
public class ScrollRectDisable : ListComponent`1<ScrollRectDisable> {
}
public class ScrollRectZoom : MonoBehaviour {
    public ScrollRectEx scrollRect;
    public float zoom;
    public float max;
    public float min;
    public bool mouseWheelZoom;
    public float scrollAmount;
    public RectTransform rectTransform { get; }
    public RectTransform get_rectTransform();
    private void OnEnable();
    public sealed virtual void OnScroll(PointerEventData data);
    public void SetZoom(float z, bool expZoom);
}
public class SearchFilterInput : MonoBehaviour {
    public GameObject OpenRoot;
    public GameObject ClosedRoot;
    public RustInput InputField;
}
public class SearchLight : IOEntity {
    public GameObject pitchObject;
    public GameObject yawObject;
    public GameObject eyePoint;
    public SoundPlayer turnLoop;
    public bool needsBuildingPrivilegeToUse;
    public Vector3 aimDir;
    public BasePlayer mountedPlayer;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual int ConsumptionAmount();
    public bool IsMounted();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public void PlayerEnter(BasePlayer player);
    public void PlayerExit();
    public void MountedUpdate();
    public void SetTargetAimpoint(Vector3 worldPos);
    public virtual int GetCurrentEnergy();
    [RPC_Server]
[MaxDistance("3")]
public void RPC_UseLight(RPCMessage msg);
    public virtual void OnKilled(HitInfo info);
    public void Update();
}
public class SeasonalTimedExplosive : TimedExplosive {
    public RandomRendererEnable randomRenderer;
}
public class sedanAnimation : MonoBehaviour {
    public Transform[] frontAxles;
    public Transform FL_shock;
    public Transform FL_wheel;
    public Transform FR_shock;
    public Transform FR_wheel;
    public Transform RL_shock;
    public Transform RL_wheel;
    public Transform RR_shock;
    public Transform RR_wheel;
    public WheelCollider FL_wheelCollider;
    public WheelCollider FR_wheelCollider;
    public WheelCollider RL_wheelCollider;
    public WheelCollider RR_wheelCollider;
    public Transform steeringWheel;
    public float motorForceConstant;
    public float brakeForceConstant;
    public float brakePedal;
    public float gasPedal;
    public float steering;
    private Rigidbody myRigidbody;
    public float GasLerpTime;
    public float SteeringLerpTime;
    private float wheelSpinConstant;
    private float shockRestingPosY;
    private float shockDistance;
    private float traceDistanceNeutralPoint;
    private void Start();
    private void Update();
    private void InputPlayer();
    private void DoSteering();
    private void ApplyForceAtWheels();
    private void UpdateTireAnimation();
    private float GetShockHeightDelta(WheelCollider wheel);
}
public class SedanWheelSmoke : MonoBehaviour {
    public ParticleSystem[] tireSmoke;
    public ParticleSystem[] tireWaterSplash;
    public ParticleSystem[] tireWaterSplash_Extra;
    public Boolean[] wheelTouching;
}
public class SeedInformationPanel : ItemInformationPanel {
    public ItemTextValue maxHarvestsDisplay;
    public UIGenesDisplay GeneticsDisplay;
    public Text TextUnknownGenetics;
    public GameObject GeneticsGameObject;
    public ItemStatValue WaterResilience;
    public ItemStatValue GroundResilience;
    public ItemStatValue LightResilience;
    public ItemStatValue TemperatureResilience;
}
public class SeedPosInfo : MonoBehaviour {
    public CanvasGroup Canvas;
    public Text WorldPos;
    public Text LevelName;
    public Text WorldSize;
    public Text Seed;
}
public class SeekerTarget : object {
    public SeekerStrength strength;
    public ISeekerTargetOwner owner;
    private static Dictionary`2<ISeekerTargetOwner, SeekerTarget> seekerTargets;
    private static SeekerTarget();
    public bool IsValidTarget();
    public bool TryGetPosition(Vector3& result);
    public void SendOwnerMessage(BaseEntity from, string message);
    public static SeekerTarget GetBestForPoint(Vector3 from, Vector3 forward, float maxCone, float maxDist, SeekerStrength minStrength);
    public static void SetSeekerTarget(ISeekerTargetOwner toAdd, SeekerStrength strength);
}
public class SeekerTest : BaseEntity {
    public GameObjectRef roadFlare;
    public bool useRoadFlares;
    public int numFlares;
    public int maxFlares;
    public float flareRegenTime;
    public float timeBetweenFlares;
    public Transform flareSpawnPoint;
    public float flareDuration;
    private float nextFlareRegenTime;
    public virtual void ServerInit();
    public void Update();
    public void DoFlare();
    public void ClearFlares();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public void ClearWarning();
    public virtual void DestroyShared();
    public sealed virtual bool IsValidHomingTarget();
}
public class SeekingServerProjectile : ServerProjectile {
    public float courseAdjustRate;
    public float maxTrackDistance;
    public float minLockDot;
    public float flareLockDot;
    public bool autoSeek;
    public float swimAfter;
    public float launchingDuration;
    public float armingDuration;
    public float velocityRampUpTime;
    public Vector3 armingFinalDir;
    public AnimationCurve airmingDirCurve;
    public AnimationCurve armingVelocityCurve;
    public float armingVelocity;
    public AnimationCurve velocityCurve;
    public float orphanedVectorChangeRate;
    public SeekerTarget lockedTarget;
    private float nextTargetUpdateTime;
    private Vector3 seekingDestination;
    private float launchTime;
    private Vector3 initialDir;
    private bool orphanedProjectile;
    private Vector3 orphanedTargetVector;
    private Vector3 orphanedRotationAxis;
    public float totalArmingPhaseDuration { get; }
    public float get_totalArmingPhaseDuration();
    public void NotifyOrphaned();
    public virtual void UpdateTarget();
    public Vector3 GetSeekingDestination();
    public virtual bool DoMovement();
    public float TimeSinceArmed();
    public float TimeSinceLaunch();
    public void EnableBoosters();
    public void DisableBoosters();
    public virtual void InitializeVelocity(Vector3 overrideVel);
    private void PickNewRotationAxis();
}
public class SegmentMaskPositioning : MonoBehaviour {
    public PlayerModel source;
    public GameObject headMask;
    public GameObject chestMask;
    public GameObject legsMask;
    public float xOffset;
}
public class SeismicSensor : IOEntity {
    public static int MinRange;
    public static int MaxRange;
    public int range;
    public GameObjectRef sensorPanelPrefab;
    private int vibrationLevel;
    private static int holdTime;
    private static BaseEntity[] resultBuffer;
    private static SeismicSensor();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public void SetVibrationLevel(int value);
    private void SetOff();
    public void SetRange(int value);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("5")]
public void RPC_SetRange(RPCMessage msg);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void ResetIOState();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public static void Notify(Vector3 position, int value);
    private static bool FilterOutSensors(BaseEntity entity);
}
public class SeismicSensorConfig : IOConfig`1<SeismicSensor> {
}
public class SelectedBlueprint : SingletonComponent`1<SelectedBlueprint> {
    public ItemBlueprint blueprint;
    public InputField craftAmountText;
    public GameObject ingredientGrid;
    public IconSkinPicker skinPicker;
    public Image iconImage;
    public RustText titleText;
    public RustText descriptionText;
    public CanvasGroup CraftArea;
    public Button CraftButton;
    public RustText CraftingTime;
    public RustText CraftingAmount;
    public GameObject TutorialCraftButtonHighlight;
    public Sprite FavouriteOnSprite;
    public Sprite FavouriteOffSprite;
    public Image FavouriteButtonStatusMarker;
    public GameObject[] workbenchReqs;
    private ItemInformationPanel[] informationPanels;
    public static bool isOpen { get; }
    public static bool get_isOpen();
}
public class SelectedContact : SingletonComponent`1<SelectedContact> {
    public RustText nameText;
    public RustText seenText;
    public RawImage mugshotImage;
    public Texture2D unknownMugshot;
    public InputField noteInput;
    public GameObject[] relationshipTypeTags;
    public Phrase lastSeenPrefix;
    public Phrase nowPhrase;
    public Phrase agoSuffix;
    public RustButton FriendlyButton;
    public RustButton SeenButton;
    public RustButton EnemyButton;
    public RustButton chatMute;
}
public class SelectedItem : SingletonComponent`1<SelectedItem> {
    public static Phrase DropTitle;
    public static Phrase DropDesc;
    public Image icon;
    public Image iconSplitter;
    public RustText title;
    public RustText description;
    public GameObject splitPanel;
    public GameObject itemProtection;
    public GameObject menuOption;
    public GameObject optionsParent;
    public GameObject innerPanelContainer;
    private static SelectedItem();
}
public static class SelfCheck : object {
    public static bool Run();
    private static bool Failed(string Message);
    private static bool TestRustNative();
    private static bool RustNative_VersionCheck(int version);
}
public class SellOrderEntry : MonoBehaviour {
    public VirtualItemIcon MerchandiseIcon;
    public VirtualItemIcon CurrencyIcon;
    private ItemDefinition merchandiseInfo;
    private ItemDefinition currencyInfo;
    public GameObject buyButton;
    public GameObject cantaffordNotification;
    public GameObject outOfStockNotification;
    private IVendingMachineInterface vendingPanel;
    public UIIntegerEntry intEntry;
    public VendingPriceMultiplierWidget priceMultiplier;
}
public class SendMessageToEntityOnAnimationFinish : StateMachineBehaviour {
    public string messageToSendToEntity;
    public float repeatRate;
    private static float lastMessageSent;
    public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class SeparableSSS : object {
    private static Vector3 Gaussian(float variance, float r, Color falloffColor);
    private static Vector3 Profile(float r, Color falloffColor);
    public static void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor);
}
public class ServerBrowser : MonoBehaviour {
    public string orderBy;
    public RustButton cacheBrowserToggle;
    public RustButton filterTutorialButton;
    public GameObject pingEstimationButton;
}
public class ServerBrowserCategory : MonoBehaviour {
    public RustText serverCountText;
}
[ExtensionAttribute]
public static class ServerBrowserEx : object {
    [ExtensionAttribute]
public static string GetPingString(ServerInfo server);
}
public class ServerBrowserInfo : SingletonComponent`1<ServerBrowserInfo> {
    public bool isMain;
    public RustText serverName;
    public RustText serverMeta;
    public Text serverText;
    public Button viewWebpage;
    public Button refresh;
    public Nullable`1<ServerInfo> currentServer;
    public HttpImage headerImage;
    public HttpImage logoImage;
}
public class ServerBrowserInfoNexus : SingletonComponent`1<ServerBrowserInfoNexus> {
    public GameObject loadingIndicator;
    public GameObject errorIndicator;
    public GameObject errorGenericText;
    public GameObject errorSteamAuthNullText;
    public RustText serverName;
    public RustText serverDesc;
    public RustText playerCount;
    public RustText zoneCount;
    public RustText lastWiped;
    public HttpImage coverImage;
    public HttpImage logoImage;
    public UINexusMapWidget mapWidget;
    public FlexTransition zoneListReveal;
    public RectTransform zoneListParent;
    public GameObjectRef zoneListItem;
    public RustButton joinServer;
    public RustButton viewWebpage;
}
public class ServerBrowserInfoNexusZone : MonoBehaviour {
    public RustButton button;
    public GameObject checkbox;
    public GameObject checkboxIndicator;
    public RectTransform currentServerIndicator;
    public RustText zoneName;
    public RustText ping;
    public RustText playerCount;
}
public class ServerBrowserItem : MonoBehaviour {
    public TextMeshProUGUI serverName;
    public RustFlexText mapName;
    public TextMeshProUGUI playerCount;
    public TextMeshProUGUI ping;
    public TextMeshProUGUI pendingPing;
    public Toggle favourited;
    public ServerBrowserTagList serverTagList;
    public Color pingColor;
    public Color pingWarningColor;
    public Tooltip pingWarningTooltip;
}
public class ServerBrowserItemNexus : MonoBehaviour {
    public TextMeshProUGUI serverName;
    public RustFlexText mapName;
    public TextMeshProUGUI playerCount;
    public Toggle favourited;
    public ServerBrowserTagList serverTagList;
    public TextMeshProUGUI changeset;
}
public class ServerBrowserList : ServerBrowserListBase {
    public bool startActive;
    public Transform listTransform;
    public int refreshOrder;
    public bool UseOfficialServers;
    public VirtualScroll VirtualScroll;
    public Rules[] rules;
    public bool hideOfficialServers;
    public bool excludeEmptyServersUsingQuery;
    public bool alwaysIncludeEmptyServers;
    public bool clampPlayerCountsToTrustedValues;
    private static String[] pingStrings;
    public QueryType queryType;
    public static string VersionTag;
    public ServerKeyvalues[] keyValues;
    private static ServerBrowserList();
    public sealed virtual int GetItemCount();
    public sealed virtual void OnVisualUpdate(int i, GameObject obj);
    public sealed virtual void SetItemData(int i, GameObject obj);
}
public abstract class ServerBrowserListBase : BaseMonoBehaviour {
    public ServerBrowserCategory categoryButton;
    public string sortOrder;
}
public class ServerBrowserListNexus : ServerBrowserListBase {
    public VirtualScroll VirtualScroll;
}
public class ServerBrowserTag : MonoBehaviour {
    public string serverTag;
    private string _tag;
    public RustButton button;
    public string CompactTag { get; }
    public bool IsActive { get; }
    public string get_CompactTag();
    public bool get_IsActive();
    public bool ContainsTag(HashSet`1<StringView> tags);
}
public class ServerBrowserTagFilters : MonoBehaviour {
    public UnityEvent TagFiltersChanged;
    private ServerBrowserTagGroup[] _groups;
    private List`1<bool> _previousState;
    public void Start();
    public void DeselectAll();
    public void GetTags(List`1& searchTagGroups, HashSet`1& excludeTags);
    [CompilerGeneratedAttribute]
private void <Start>b__3_0();
}
public class ServerBrowserTagGroup : MonoBehaviour {
    [TooltipAttribute("If set then queries will filter out servers matching unselected tags in the group")]
public bool isExclusive;
    public ServerBrowserTag[] tags;
    private void Initialize();
    public void Awake();
    public bool AnyActive();
    public void Refresh(HashSet`1<StringView> serverTags, Int32& tagsEnabled, int maxTags);
}
public class ServerBrowserTagList : MonoBehaviour {
    public int maxTagsToShow;
    private ServerBrowserTagGroup[] _groups;
    private void Initialize();
    public void Awake();
    public bool Refresh(HashSet`1<StringView> serverTags);
}
public class ServerBuildingManager : BuildingManager {
    private int decayTickBuildingIndex;
    private int decayTickEntityIndex;
    private int decayTickWorldIndex;
    private int navmeshCarveTickBuildingIndex;
    private UInt32 maxBuildingID;
    public void CheckSplit(DecayEntity ent);
    private bool ShouldSplit(Building building);
    private void Split(Building building);
    public void CheckMerge(DecayEntity ent);
    private void Merge(Building building1, Building building2);
    public void Cycle();
    public void UpdateNavMeshCarver(Building building, Int32& ticks, int i);
    public UInt32 NewBuildingID();
    public void LoadBuildingID(UInt32 id);
    protected virtual Building CreateBuilding(UInt32 id);
    protected virtual void DisposeBuilding(Building& building);
}
public class ServerConsole : SingletonComponent`1<ServerConsole> {
    private ConsoleWindow console;
    private ConsoleInput input;
    private float nextUpdate;
    private static bool consoleEnabled { get; }
    private DateTime currentGameTime { get; }
    private int currentPlayerCount { get; }
    private int maxPlayerCount { get; }
    private int currentEntityCount { get; }
    private int currentSleeperCount { get; }
    private static bool get_consoleEnabled();
    public void OnEnable();
    private void OnDisable();
    private void OnInputText(string obj);
    public static void PrintColoured(Object[] objects);
    private void HandleLog(string message, string stackTrace, LogType type);
    private void Update();
    private void UpdateStatus();
    private DateTime get_currentGameTime();
    private int get_currentPlayerCount();
    private int get_maxPlayerCount();
    private int get_currentEntityCount();
    private int get_currentSleeperCount();
}
public class ServerGib : BaseCombatEntity {
    public GameObject _gibSource;
    public string _gibName;
    public PhysicMaterial physicsMaterial;
    public bool useContinuousCollision;
    private MeshCollider meshCollider;
    private Rigidbody rigidBody;
    public virtual float BoundsPadding();
    public static List`1<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity);
    public virtual void Save(SaveInfo info);
    public MeshCollider GetCollider();
    public virtual void ServerInit();
    public void RemoveMe();
    public virtual void PhysicsInit(Mesh physicsMesh);
}
public class ServerHistory : MonoBehaviour {
    public ServerHistoryItem prefab;
    public GameObject panelList;
    internal IServerQuery Request;
}
public class ServerHistoryItem : MonoBehaviour {
    private ServerInfo serverInfo;
    public Text serverName;
    public Text players;
    public Text lastJoinDate;
    public UInt32 order;
}
public class ServerMgr : SingletonComponent`1<ServerMgr> {
    public static string BYPASS_PROCEDURAL_SPAWN_PREF;
    private ConnectionAuth auth;
    [CompilerGeneratedAttribute]
private bool <runFrameUpdate>k__BackingField;
    public UserPersistance persistance;
    public PlayerStateManager playerStateManager;
    private QueueType aiTick;
    private Stopwatch methodTimer;
    private Stopwatch updateTimer;
    private List`1<ulong> bannedPlayerNotices;
    private string _AssemblyHash;
    public IEnumerator restartCoroutine;
    public ConnectionQueue connectionQueue;
    public TimeAverageValueLookup`1<Type> packetHistory;
    public TimeAverageValueLookup`1<UInt32> rpcHistory;
    private Stopwatch timer;
    public bool runFrameUpdate { get; private set; }
    public int AvailableSlots { get; }
    private string AssemblyHash { get; }
    public bool Restarting { get; }
    [CompilerGeneratedAttribute]
public bool get_runFrameUpdate();
    [CompilerGeneratedAttribute]
private void set_runFrameUpdate(bool value);
    public bool Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn);
    public void OpenConnection(bool useSteamServer);
    public void CloseConnection();
    private void OnDisable();
    private void OnApplicationQuit();
    private void CreateImportantEntities();
    public void CreateImportantEntity(string prefabName);
    private void StartSteamServer();
    private void UpdateItemDefinitions();
    internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status);
    public int get_AvailableSlots();
    private void Update();
    private void LateUpdate();
    private void FixedUpdate();
    private void DoTick();
    private void DoHeartbeat();
    private string get_AssemblyHash();
    private static BaseGameMode Gamemode();
    public static string GamemodeName();
    public static string GamemodeTitle();
    private void UpdateServerInformation();
    public sealed virtual void OnDisconnected(string strReason, Connection connection);
    public static void OnEnterVisibility(Connection connection, Group group);
    public static void OnLeaveVisibility(Connection connection, Group group);
    public static SpawnPoint FindSpawnPoint(BasePlayer forPlayer);
    public void JoinGame(Connection connection);
    public bool get_Restarting();
    internal void Shutdown();
    [IteratorStateMachineAttribute("ServerMgr/<ServerRestartWarning>d__45")]
private IEnumerator ServerRestartWarning(string info, int iSeconds);
    public static void RestartServer(string strNotice, int iSeconds);
    public static void SendReplicatedVars(string filter);
    public static void SendReplicatedVars(Connection connection);
    private static void OnReplicatedVarChanged(string fullName, string value);
    private void Log(Exception e);
    public sealed virtual void OnNetworkMessage(Message packet);
    public void ProcessUnhandledPacket(Message packet);
    public void ReadDisconnectReason(Message packet);
    private BasePlayer SpawnPlayerSleeping(Connection connection);
    public BasePlayer SpawnNewPlayer(Connection connection);
    private void ClientReady(Message packet);
    private void OnRPCMessage(Message packet);
    private void OnPlayerTick(Message packet);
    private void OnPlayerVoice(Message packet);
    private void OnGiveUserInformation(Message packet);
}
public static class ServerOcclusion : object {
    public static float MaxY;
    public static int ChunkCountX;
    public static int ChunkCountY;
    public static int ChunkCountZ;
    public static int SubChunkCountX;
    public static int SubChunkCountY;
    public static int SubChunkCountZ;
    public static LimitDictionary`2<ValueTuple`2<SubGrid, SubGrid>, bool> OcclusionCache;
    public static BitArray[] OcclusionSubGridBlocked;
    [CompilerGeneratedAttribute]
private static bool <OcclusionEnabled>k__BackingField;
    public static int OcclusionChunkSize;
    public static int OcclusionChunkResolution;
    public static ValueTuple`3[] neighbours;
    public static ValueTuple`3[] neighboursAndOrigin;
    private static Queue`1<SubGrid> floodFillQueue;
    private static Dictionary`2<SubGrid, bool> visited;
    public static HashSet`1<SubGrid> gridArea;
    public static bool OcclusionEnabled { get; public set; }
    public static float OcclusionFade { get; }
    public static float OcclusionPollRate { get; }
    public static float MinOcclusionDistance { get; }
    public static int OcclusionMaxBFSIterations { get; }
    private static ServerOcclusion();
    [CompilerGeneratedAttribute]
public static bool get_OcclusionEnabled();
    [CompilerGeneratedAttribute]
public static void set_OcclusionEnabled(bool value);
    public static float get_OcclusionFade();
    public static float get_OcclusionPollRate();
    public static float get_MinOcclusionDistance();
    public static int get_OcclusionMaxBFSIterations();
    public static int GetGridIndex(int x, int y, int z);
    public static int GetSubGridIndex(int x, int y, int z);
    public static int GetGrid(float position, float axis);
    public static Grid GetGrid(Vector3 position);
    public static int GetSubGrid(float position, float axis);
    public static SubGrid GetSubGrid(Vector3 position);
    public static bool IsBlocked(int x, int y, int z);
    public static bool IsBlocked(SubGrid sub);
    public static bool IsValidGrid(int x, int y, int z);
    public static bool IsValidSubGrid(int x, int y, int z);
    public static bool PathBetweenFloodFill(SubGrid start, SubGrid end);
    public static bool PathBetweenDirect(SubGrid start, SubGrid end);
    public static bool PathBetweenDirectBresenham(SubGrid start, SubGrid end);
    public static void SetFromGrids(SubGrid grid1, SubGrid grid2, int power);
    public static void SetupGrid();
    [CompilerGeneratedAttribute]
internal static void <SetupGrid>g__PopulateSubGrid|44_0(Grid cell);
}
public class ServerPerformance : BaseMonoBehaviour {
    public static ulong deaths;
    public static ulong spawns;
    public static ulong position_changes;
    private string fileName;
    private int lastFrame;
    private void Start();
    private void WriteLine();
    public static void DoReport();
    public static string WorkoutPrefabName(GameObject obj);
    public static void ComponentReport(string filename, string Title, Object[] objects);
}
public static class ServerPlayers : object {
    private static HashSet`1<ulong> OnlineUserIdSet;
    private static int _currentFrame;
    private static ServerPlayers();
    public static bool IsOnline(ulong userId);
    public static void GetAll(List`1<ulong> userIds);
    private static void RebuildIfNecessary();
}
public class ServerProjectile : EntityComponent`1<BaseEntity> {
    public Vector3 initialVelocity;
    public float drag;
    public float gravityModifier;
    public float speed;
    public float scanRange;
    public Vector3 swimScale;
    public Vector3 swimSpeed;
    public float radius;
    public bool IgnoreAI;
    public bool impacted;
    public float swimRandom;
    [CompilerGeneratedAttribute]
private Vector3 <CurrentVelocity>k__BackingField;
    public bool HasRangeLimit { get; }
    protected int mask { get; }
    public Vector3 CurrentVelocity { get; public set; }
    public virtual bool get_HasRangeLimit();
    public float GetMaxRange(float maxFuseTime);
    protected virtual int get_mask();
    [CompilerGeneratedAttribute]
public Vector3 get_CurrentVelocity();
    [CompilerGeneratedAttribute]
public void set_CurrentVelocity(Vector3 value);
    protected void FixedUpdate();
    public virtual bool ShouldSwim();
    public virtual bool DoMovement();
    protected virtual bool IsAValidHit(BaseEntity hitEnt);
    protected virtual bool IsAnIgnoredAI(BaseEntity hitEnt);
    public virtual void InitializeVelocity(Vector3 overrideVel);
}
public class ServerStatistics : object {
    private BasePlayer player;
    private Storage storage;
    private static Dictionary`2<ulong, Storage> players;
    public ServerStatistics(BasePlayer player);
    private static ServerStatistics();
    public void Init();
    public void Save();
    public void Add(string name, int val);
    public static Storage Get(ulong id);
}
public class ServerStatus : ValueType {
    public bool IsOnline;
    public RealTimeSince LastSeen;
    public int Players;
    public int MaxPlayers;
    public int QueuedPlayers;
    public bool IsFull { get; }
    public bool get_IsFull();
}
public static class ServerUsers : object {
    public static Dictionary`2<ulong, User> users;
    private static ServerUsers();
    public static void Remove(ulong uid);
    public static void Set(ulong uid, UserGroup group, string username, string notes, long expiry);
    public static User Get(ulong uid);
    public static bool Is(ulong uid, UserGroup group);
    public static IEnumerable`1<User> GetAll(UserGroup group);
    public static void Clear();
    public static void Load();
    public static void Save();
    public static string BanListString(bool bHeader);
    public static string BanListStringEx();
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Sonic Ether/SE Screen-Space Shadows")]
[RequireComponent("UnityEngine.Camera")]
public class SEScreenSpaceShadows : SingletonComponent`1<SEScreenSpaceShadows> {
    private CommandBuffer blendShadowsCommandBuffer;
    private CommandBuffer renderShadowsCommandBuffer;
    private Camera attachedCamera;
    public Light sun;
    [RangeAttribute("0", "1")]
public float blendStrength;
    [RangeAttribute("0", "1")]
public float accumulation;
    [RangeAttribute("0,1", "5")]
public float lengthFade;
    [RangeAttribute("0,01", "5")]
public float range;
    [RangeAttribute("0", "1")]
public float zThickness;
    [RangeAttribute("2", "92")]
public int samples;
    [RangeAttribute("0,5", "4")]
public float nearSampleQuality;
    [RangeAttribute("0", "1")]
public float traceBias;
    public bool stochasticSampling;
    public bool leverageTemporalAA;
    public bool bilateralBlur;
    [RangeAttribute("1", "2")]
public int blurPasses;
    [RangeAttribute("0,01", "0,5")]
public float blurDepthTolerance;
}
public class SetMemorySlider : MonoBehaviour {
    private void Awake();
}
public class SetParameterAnimatorBehaviour : StateMachineBehaviour {
    public string ParameterName;
    public ParamType ParameterType;
    public float FloatValue;
    public bool BoolValue;
    public int IntValue;
    public Timing SetParameterTiming;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Normalised time of animation")]
public float ThresholdTiming;
    private float lastNormalisedTime;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
    public virtual void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
    public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
    private void SetParameter(Animator animator);
}
public class SetParameterCurveAnimatorBehaviour : StateMachineBehaviour {
    public string FloatParameterName;
    public AnimationCurve ParameterCurve;
    public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class SetupAppNotification : UIDialog {
    public RustInput titleInput;
    public RustInput bodyInput;
}
public class Shaker : MonoBehaviour {
    public float Frequency;
    public Vector3 PositionMagnitude;
    public Vector3 RotationMagnitude;
    public float GlobalMultiplier;
}
[PostProcessAttribute("SharpenAndVignetteRenderer", "2", "Custom/SharpenAndVignette", "True")]
public class SharpenAndVignette : PostProcessEffectSettings {
    [HeaderAttribute("Sharpen")]
public BoolParameter applySharpen;
    [RangeAttribute("0", "5")]
public FloatParameter strength;
    [RangeAttribute("0", "1")]
public FloatParameter clamp;
    [HeaderAttribute("Vignette")]
public BoolParameter applyVignette;
    [RangeAttribute("-100", "100")]
public FloatParameter sharpness;
    [RangeAttribute("0", "100")]
public FloatParameter darkness;
}
public class SharpenAndVignetteOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
public class SharpenAndVignetteRenderer : PostProcessEffectRenderer`1<SharpenAndVignette> {
    private Shader sharpenAndVigenetteShader;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class ShopFront : StorageContainer {
    public float maxUseAngle;
    public BasePlayer vendorPlayer;
    public BasePlayer customerPlayer;
    public GameObjectRef transactionCompleteEffect;
    public ItemContainer customerInventory;
    private bool swappingItems;
    private float AngleDotProduct { get; }
    public ItemContainer vendorInventory { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private float get_AngleDotProduct();
    public ItemContainer get_vendorInventory();
    public bool TradeLocked();
    public bool IsTradingPlayer(BasePlayer player);
    public bool IsPlayerCustomer(BasePlayer player);
    public bool IsPlayerVendor(BasePlayer player);
    public bool PlayerInVendorPos(BasePlayer player);
    public bool PlayerInCustomerPos(BasePlayer player);
    public bool LootEligable(BasePlayer player);
    public void ResetTrade();
    public void CompleteTrade();
    [RPC_Server]
[IsVisible("3")]
public void AcceptClicked(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void CancelClicked(RPCMessage msg);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    private bool CanAcceptVendorItem(Item item, int targetSlot);
    private bool CanAcceptCustomerItem(Item item, int targetSlot);
    public virtual bool CanMoveFrom(BasePlayer player, Item item);
    public virtual bool CanOpenLootPanel(BasePlayer player, string panelName);
    public void ReturnPlayerItems(BasePlayer player);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public void UpdatePlayers();
}
public class ShopFrontLootPanel : LootPanel {
    public Text playerLabelA;
    public Text playerLabelB;
    public GameObject confirmButton;
    public GameObject confirmHelp;
    public GameObject denyButton;
    public GameObject denyHelp;
    public GameObject waitingText;
    public GameObject exchangeInProgressImage;
    public Phrase acceptedPhrase;
    public Phrase noOnePhrase;
}
public class ShoutcastStreamer : MonoBehaviour {
    public string Host;
    public AudioSource Source;
    public RadioPlaylist[] BuiltinRadios;
}
public class Shovel : BaseMelee {
}
public class ShowIfConvarEnabled : MonoBehaviour {
    public string Convar;
}
public class SidecarBikeChassisVisuals : BikeChassisVisuals {
    [SerializeField]
private SidecarSuspensionSettings sidecarSuspension;
}
public class Signage : IOEntity {
    public ItemDefinition RequiredHeldEntity;
    private List`1<ulong> editHistory;
    private static float TextureRequestTimeout;
    public GameObjectRef changeTextDialog;
    public MeshPaintableSource[] paintableSources;
    public UInt32[] textureIDs;
    public NetworkableId NetworkID { get; }
    public Type FileType { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    public UInt32[] GetContentCRCs { get; }
    public bool ShouldTransferAssociatedFiles { get; }
    public Vector2i TextureSize { get; }
    public int TextureCount { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool CanUpdateSign(BasePlayer player);
    public bool CanUnlockSign(BasePlayer player);
    public bool CanLockSign(BasePlayer player);
    public virtual void Load(LoadInfo info);
    private bool HeldEntityCheck(BasePlayer player);
    public sealed virtual UInt32[] GetTextureCRCs();
    public sealed virtual NetworkableId get_NetworkID();
    public sealed virtual Type get_FileType();
    public sealed virtual UGCType get_ContentType();
    [MaxDistance("3")]
[RPC_Server]
public void LockSign(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void UnLockSign(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual bool ShouldNetworkOwnerInfo();
    public sealed virtual void SetTextureCRCs(UInt32[] crcs);
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public void LogEdit(BasePlayer byPlayer);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public virtual string Admin_Who();
    public virtual bool get_ShouldTransferAssociatedFiles();
    public virtual int ConsumptionAmount();
    public virtual string Categorize();
    public sealed virtual Vector2i get_TextureSize();
    public sealed virtual int get_TextureCount();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    [RPC_Server]
[CallsPerSecond("5")]
[MaxDistance("5")]
public void UpdateSign(RPCMessage msg);
    public void EnsureInitialized();
    [ConditionalAttribute("SIGN_DEBUG")]
private static void SignDebugLog(string str);
}
public class SignContent : ImageStorageEntity {
    public UInt32[] textureIDs;
    private List`1<ulong> editHistory;
    protected UInt32 CrcToLoad { get; }
    protected Type StorageType { get; }
    public UGCType ContentType { get; }
    public UInt32[] GetContentCRCs { get; }
    public Type FileType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    protected virtual UInt32 get_CrcToLoad();
    protected virtual Type get_StorageType();
    public sealed virtual UGCType get_ContentType();
    public void CopyInfoFromSign(ISignage s, IUGCBrowserEntity b);
    public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b);
    public virtual void Save(SaveInfo info);
    internal virtual void DoServerDestroy();
    public virtual void Load(LoadInfo info);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public Type get_FileType();
    public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
}
public class SignPanel : MonoBehaviour {
    public RawImage Image;
    public RectTransform ImageContainer;
    public RustText DisabledSignsMessage;
}
public class SimpleBuildingBlock : StabilityEntity {
}
public class SimpleLight : IOEntity {
    public virtual void ResetIOState();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
}
public class SimplePrivilege : BaseEntity {
    public List`1<PlayerNameID> authorizedPlayers;
    public static Flags Flag_MaxAuths;
    public virtual void ResetState();
    public bool IsAuthed(BasePlayer player);
    public bool IsAuthed(ulong userID);
    public bool AnyAuthed();
    public virtual void Save(SaveInfo info);
    public virtual void PostSave(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public bool AtMaxAuthCapacity();
    public void UpdateMaxAuthCapacity();
}
public class SimpleShark : BaseCombatEntity {
    public Vector3 destination;
    public float minSpeed;
    public float maxSpeed;
    public float idealDepth;
    public float minTurnSpeed;
    public float maxTurnSpeed;
    public float attackCooldown;
    public float aggroRange;
    public float obstacleDetectionRadius;
    public Animator animator;
    public GameObjectRef bloodCloud;
    public GameObjectRef corpsePrefab;
    private static string SPEARGUN_KILL_STAT;
    [ServerVar]
public static float forceSurfaceAmount;
    [ServerVar]
public static bool disable;
    private Vector3 spawnPos;
    private float stoppingDistance;
    private float currentSpeed;
    private float lastStartleTime;
    private float startleDuration;
    private SimpleState[] states;
    private SimpleState _currentState;
    private bool sleeping;
    private List`1<Vector3> patrolPath;
    private BasePlayer target;
    private float lastSeenTargetTime;
    private float nextTargetSearchTime;
    private static BasePlayer[] playerQueryResults;
    private float minFloorDist;
    private float minSurfaceDist;
    private float lastTimeAttacked;
    public float nextAttackTime;
    private Vector3 cachedObstacleNormal;
    private float cachedObstacleDistance;
    private float obstacleAvoidanceScale;
    private float obstacleDetectionRange;
    private float timeSinceLastObstacleCheck;
    public bool IsNpc { get; }
    private static SimpleShark();
    public virtual bool get_IsNpc();
    private void GenerateIdlePoints(Vector3 center, float radius, float heightOffset, float staggerOffset);
    private void GenerateIdlePoints_Shrinkwrap(Vector3 center, float radius, float heightOffset, float staggerOffset);
    public virtual void ServerInit();
    public void CheckSleepState();
    public void Init();
    private void Think(float delta);
    public Vector3 WaterClamp(Vector3 point);
    public bool ValidTarget(BasePlayer newTarget);
    public void ClearTarget();
    public virtual void OnKilled(HitInfo hitInfo);
    public void UpdateTarget(float delta);
    public float TimeSinceAttacked();
    public virtual void OnAttacked(HitInfo info);
    public bool HasTarget();
    public BasePlayer GetTarget();
    public virtual string Categorize();
    public bool CanAttack();
    public void DoAttack();
    public void Startle();
    public bool IsStartled();
    private float GetDesiredSpeed();
    public float GetTurnSpeed();
    private float GetCurrentSpeed();
    private void UpdateObstacleAvoidance(float delta);
    private void UpdateDirection(float delta);
    private void UpdatePosition(float delta);
    private void UpdateSpeed(float delta);
    public void Update();
}
public class SimpleSplineTranslator : object {
    private WorldSpline spline;
    private WorldSplineData splineData;
    private float currentDistance;
    private float speed;
    private bool loop;
    private Vector3 offset;
    private int direction;
    public int Direction;
    public float Speed { get; }
    public Vector3 Offset { get; }
    public float CurrentDistance { get; }
    public bool Loop { get; }
    public SimpleSplineTranslator(WorldSpline spline, float speed, int direction, bool loop);
    public float get_Speed();
    public Vector3 get_Offset();
    public float get_CurrentDistance();
    public bool get_Loop();
    public void Update(float deltaTime);
    public Vector3 PeekNextPosition(float delta, int dir, bool getLocal);
    public Vector3 PeekNextPositionFollowingDirection(float delta, bool getLocal);
    public void GetCurrentPositionAndTangent(Vector3& position, Vector3& tangent, bool getLocal);
    private float CalculateNextDistance(float currentDistance, float delta, float dir);
    public float GetEnd();
    public float GetStart();
    public Vector3 GetPositionAtDistance(float distance, Vector3& tangent);
    public SimpleSplineTranslator SetSpeed(float newSpeed);
    public SimpleSplineTranslator SetOffset(Vector3 offset);
    public SimpleSplineTranslator SetCurrentDistance(float distance);
    public SimpleSplineTranslator CalculateStartingDistance();
    public SimpleSplineTranslator Reset();
    public SimpleSplineTranslator SetSpline(WorldSpline spline);
    public SimpleSplineTranslator SetDirection(int direction);
    public float GetCurrentDistance();
}
public class SingleSpawn : SpawnGroup {
    public virtual bool WantsInitialSpawn();
    public void FillDelay(float delay);
}
public class SingleVendor : FacepunchBehaviour {
    public RustText VendorName;
    public TmProEmojiRedirector emojiRedirector;
    public Transform ListingsParent;
    public Transform AccordionRow;
    public Transform AccordionChevron;
    public Image[] AccordionImages;
    public GameObjectRef VendorListingPrefab;
    [HeaderAttribute("References")]
public GameObject NoListings;
    public FlexTransition VendorListingsTransition;
    public Image OwnerImage;
    public RustText OwnerName;
    public SellOrderContainer SellOrdersContainer;
    private List`1<VendorListing> listings;
    public static int COUNT_FOR_ACCORDION;
    public sealed virtual int CompareTo(SingleVendor other);
}
public class SirenLight : IOEntity {
    public EmissionToggle toggler;
    public GameObject lightObj;
    public float speed;
    public virtual void ResetState();
}
[CreateAssetMenuAttribute]
public class SkeletonProperties : ScriptableObject {
    public GameObject boneReference;
    [BonePropertyAttribute]
public BoneProperty[] bones;
    private Dictionary`2<UInt32, BoneProperty> quickLookup;
    public void OnValidate();
    private void BuildDictionary();
    public BoneProperty FindBone(UInt32 id);
}
public static class SkinHelpers : object {
    public static void SetSkin(GameObject itemModel, ItemDefinition itemDef, ulong skinID);
}
public class SkinnedMultiMesh : MonoBehaviour {
    public bool shadowOnly;
    internal bool IsVisible;
    public bool eyesView;
    public Skeleton skeleton;
    public SkeletonSkinLod skeletonSkinLod;
    public List`1<Part> parts;
    public List`1<Part> createdParts;
    public long lastBuildHash;
    public MaterialPropertyBlock sharedPropertyBlock;
    public MaterialPropertyBlock hairPropertyBlock;
    public float skinNumber;
    public float meshNumber;
    public float hairNumber;
    public int skinType;
    public SkinSetCollection SkinCollection;
    [CompilerGeneratedAttribute]
private List`1<Renderer> <Renderers>k__BackingField;
    public List`1<Renderer> Renderers { get; }
    [CompilerGeneratedAttribute]
public List`1<Renderer> get_Renderers();
}
public class SkinReplacement : object {
    public SkinType skinReplacementType;
    public GameObjectRef targetReplacement;
}
[CreateAssetMenuAttribute]
public class SkinSet : ScriptableObject {
    public string Label;
    public Gradient SkinColour;
    public HairSetCollection HairCollection;
    [HeaderAttribute("Models")]
public GameObjectRef Head;
    public GameObjectRef Torso;
    public GameObjectRef Legs;
    public GameObjectRef Feet;
    public GameObjectRef Hands;
    [HeaderAttribute("Censored Variants")]
public GameObjectRef CensoredTorso;
    public GameObjectRef CensoredLegs;
    [HeaderAttribute("Materials")]
public Material HeadMaterial;
    public Material BodyMaterial;
    public Material EyeMaterial;
    internal Color GetSkinColor(float skinNumber);
}
[CreateAssetMenuAttribute]
public class SkinSetCollection : ScriptableObject {
    public SkinSet[] Skins;
    public int GetIndex(float MeshNumber);
    public SkinSet Get(float MeshNumber);
}
public class SkinViewer : FacepunchBehaviour {
    [SerializeField]
private Camera cam;
    [SerializeField]
private Transform positionParent;
    [SerializeField]
private Transform modelParent;
    [SerializeField]
private GameObject[] lights;
    [SerializeField]
private SkinSetCollection skin;
    [SerializeField]
private float rotateResetSpeed;
    [SerializeField]
private float dragSpeed;
    [SerializeField]
private bool autoSpin;
    [SerializeField]
private float timeoutSeconds;
    [SerializeField]
private Skeleton skinViewerSkeleton;
}
public class SkinViewerTesting : FacepunchBehaviour {
    [SerializeField]
private GameObjectRef skinViewerPrefab;
    [SerializeField]
private SkinViewItem[] panels;
}
public class SksViewmodel : MonoBehaviour {
    public GameObject ShellRoot;
    public Animator TargetAnimator;
}
public class SkullTrophy : StorageContainer {
    public RustText NameText;
    public TextProOnACircle CircleModifier;
    public int AngleModifierMinCharCount;
    public int AngleModifierMaxCharCount;
    public int AngleModifierMinArcAngle;
    public int AngleModifierMaxArcAngle;
    public float SunsetTime;
    public float SunriseTime;
    public RendererLOD SkullRenderer;
    public Material[] DaySkull;
    public Material[] NightSkull;
    public Material[] NoSkull;
    public static Flags HasSkull;
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual void Save(SaveInfo info);
}
public class SkyLantern : StorageContainer {
    public float gravityScale;
    public float travelSpeed;
    public float collisionRadius;
    public float rotationSpeed;
    public float randOffset;
    public float lifeTime;
    public float hoverHeight;
    public Transform collisionCheckPoint;
    private float idealAltitude;
    private Vector3 travelVec;
    private float takeOffY;
    public virtual float GetNetworkTime();
    public virtual void ServerInit();
    public sealed virtual void Ignite(Vector3 fromPos);
    public virtual void OnAttacked(HitInfo info);
    public void SelfDestroy();
    public sealed virtual bool CanIgnite();
    public void UpdateIdealAltitude();
    public void StartSinking();
    public void FixedUpdate();
}
public class Sled : BaseVehicle {
    public static Flags BrakeOn;
    public static Flags OnSnow;
    public static Flags IsGrounded;
    public static Flags OnSand;
    public PhysicMaterial BrakeMaterial;
    public PhysicMaterial SnowMaterial;
    public PhysicMaterial NonSnowMaterial;
    public Transform CentreOfMassTransform;
    public Collider[] PhysicsMaterialTargets;
    public float InitialForceCutoff;
    public float InitialForceIncreaseRate;
    public float TurnForce;
    public float DirectionMatchForce;
    public float VerticalAdjustmentForce;
    public float VerticalAdjustmentAngleThreshold;
    public float NudgeCooldown;
    public float NudgeForce;
    public float MaxNudgeVelocity;
    public static float DecayFrequency;
    public float DecayAmount;
    public ParticleSystemContainer TrailEffects;
    public SoundDefinition enterSnowSoundDef;
    public SoundDefinition snowSlideLoopSoundDef;
    public SoundDefinition dirtSlideLoopSoundDef;
    public AnimationCurve movementLoopGainCurve;
    public AnimationCurve movementLoopPitchCurve;
    public VehicleTerrainHandler terrainHandler;
    public PhysicMaterial cachedMaterial;
    public float initialForceScale;
    public TimeSince leftIce;
    public TimeSince lastNudge;
    public bool BlocksDoors { get; }
    public virtual void ServerInit();
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void VehicleFixedUpdate();
    public void UpdatePhysicsMaterial();
    public void UpdateGroundedFlag();
    public PhysicMaterial GetPhysicMaterial();
    public virtual void PlayerMounted(BasePlayer player, BaseMountable seat);
    public void ApplyInitialForce();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void DecayOverTime();
    public virtual bool CanPickup(BasePlayer player);
    public sealed virtual void OnObjects(TriggerNotify trigger);
    public sealed virtual void OnEmpty();
    public virtual bool get_BlocksDoors();
}
public class SledSeat : BaseVehicleSeat {
    public Transform LeftHand;
    public Transform RightHand;
    public Transform LeftFoot;
    public Transform RightFoot;
    public float MountedAnimationSpeed;
}
public class SleepingBag : DecayEntity {
    public ulong deployerUserID;
    public GameObject renameDialog;
    public GameObject assignDialog;
    public float secondsBetweenReuses;
    public string niceName;
    public Vector3 spawnOffset;
    public RespawnType RespawnType;
    public bool isStatic;
    public bool canBePublic;
    public static Flags IsPublicFlag;
    public static Phrase bagLimitPhrase;
    public static Phrase bagLimitReachedPhrase;
    public Phrase assignOtherBagPhrase;
    public Phrase assignedBagPhrase;
    public Phrase cannotAssignBedNoPlayerPhrase;
    public Phrase cannotAssignBedPhrase;
    public Phrase cannotMakeBedPhrase;
    public Phrase bedAssigningBlocked;
    public static Phrase tutorialPhrase;
    public float unlockTime;
    public static List`1<SleepingBag> sleepingBags;
    private bool notifyPlayerOnServerInit;
    private static Dictionary`2<ulong, List`1<SleepingBag>> bagsPerPlayer;
    public float unlockSeconds { get; }
    public bool IsTutorialBag { get; }
    private static SleepingBag();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsPublic();
    public virtual float get_unlockSeconds();
    public virtual float GetUnlockSeconds(ulong playerID);
    public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers);
    public static Nullable`1<CanAssignBedResult> CanAssignBed(BasePlayer player, SleepingBag newBag, ulong targetPlayer, int countOffset, int maxOffset, SleepingBag ignore);
    public static Nullable`1<CanBuildResult> CanBuildBed(BasePlayer player, Construction construction);
    public static SleepingBag[] FindForPlayer(ulong playerID, bool ignoreTimers);
    public static void FindForPlayer(ulong playerID, bool ignoreTimers, List`1<SleepingBag> result);
    public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag);
    public static void AddBagForPlayer(SleepingBag bag, ulong user, bool networkUpdate);
    public static void RemoveBagForPlayer(SleepingBag bag, ulong user);
    public static void OnBagChangedOwnership(SleepingBag bag, ulong oldUser);
    public static void ClearTutorialBagsForPlayer(ulong userId);
    public static int GetSleepingBagCount(ulong userId);
    public static bool TrySpawnPlayer(BasePlayer player, NetworkableId sleepingBag, String& errorMessage);
    public bool get_IsTutorialBag();
    public virtual void SetUnlockTime(float newTime);
    public static bool DestroyBag(ulong userID, NetworkableId sleepingBag);
    public static void ResetTimersForPlayer(BasePlayer player);
    public virtual void GetSpawnPos(Vector3& pos, Quaternion& rot);
    public void SetPublic(bool isPublic);
    public void SetDeployedBy(BasePlayer player);
    public static void OnPlayerDeath(BasePlayer player);
    public static void SetBagTimer(SleepingBag bag, Vector3 position, SleepingBagResetReason reason, BasePlayer forPlayer);
    public virtual void ServerInit();
    public virtual void OnPlaced(BasePlayer player);
    public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent);
    private void DelayedPlayerNotify();
    public virtual void PostServerLoad();
    private void NotifyPlayer(ulong id);
    public virtual void DoServerDestroy();
    public virtual void Save(SaveInfo info);
    public virtual bool CanUseNetworkCache(Connection connection);
    [RPC_Server]
[IsVisible("3")]
public void Rename(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void AssignToFriend(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public virtual void RPC_MakePublic(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_MakeBed(RPCMessage msg);
    protected virtual void PostPlayerSpawn(BasePlayer p);
    public virtual RespawnState GetRespawnState(ulong userID);
    public virtual bool IsMobile();
    public virtual string Admin_Who();
    public virtual void Load(LoadInfo info);
    public virtual bool CanPickup(BasePlayer player);
    [CompilerGeneratedAttribute]
private bool <DoServerDestroy>b__60_0(SleepingBag x);
}
public class SleepingBagButton : MonoBehaviour {
    public GameObject TimeLockRoot;
    public GameObject LockRoot;
    public GameObject UnavailableRoot;
    public Tooltip unavailableTooltip;
    public Phrase occupied;
    public Phrase underwater;
    public Phrase noRespawnZone;
    public Button ClickButton;
    public TextMeshProUGUI BagName;
    public TextMeshProUGUI ZoneName;
    public TextMeshProUGUI LockTime;
    public Image Icon;
    public Sprite SleepingBagSprite;
    public Sprite BedSprite;
    public Sprite BeachTowelSprite;
    public Sprite CamperSprite;
    public Image CircleRim;
    public Image CircleFill;
    public Image Background;
    public RustButton DeleteButton;
    public Image ConfirmSlider;
    public static Phrase toastHoldToUnclaimBag;
    private static SleepingBagButton();
}
public class SleepingBagCamper : SleepingBag {
    public EntityRef`1<BaseVehicleSeat> AssociatedSeat;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    protected virtual void PostPlayerSpawn(BasePlayer p);
    public void SetSeat(BaseVehicleSeat seat, bool sendNetworkUpdate);
    public virtual void Save(SaveInfo info);
    public virtual RespawnState GetRespawnState(ulong userID);
    [RPC_Server]
[MaxDistance("3")]
public void ServerClearBed(RPCMessage msg);
}
public class SleepingBagClusterMapMarker : MonoBehaviour {
    public TextMeshProUGUI CountText;
    public List`1<SleepingBagButton> SleepingBagButtons;
    public GameObject OpenRoot;
    public Tooltip SummaryTooltip;
    public Image RimImage;
}
public class SleepingBagMapMarker : MonoBehaviour {
    public Image MapIcon;
    public Image SleepingBagIcon;
    public Sprite SleepingBagSprite;
    public Sprite BedSprite;
    public Sprite BeachTowelSprite;
    public Sprite CamperSprite;
    public Tooltip MarkerTooltip;
    public GameObject LockRoot;
    public TextMeshProUGUI LockTime;
    public GameObject OccupiedRoot;
    public Image CircleRim;
    public Image CircleFill;
    public RustButton DeleteButton;
    public Image ConfirmSlider;
}
public class SlicedGranularAudioClip : MonoBehaviour {
    public AudioSource source;
    public AudioClip sourceClip;
    public AudioClip granularClip;
    public int sampleRate;
    public float grainAttack;
    public float grainSustain;
    public float grainRelease;
    public float grainFrequency;
    public int grainAttackSamples;
    public int grainSustainSamples;
    public int grainReleaseSamples;
    public int grainFrequencySamples;
    public int samplesUntilNextGrain;
    public List`1<Grain> grains;
    public List`1<int> startPositions;
    public int lastStartPositionIdx;
    public bool playOnAwake;
}
public class SliderCookie : MonoBehaviour {
    public void OnEnable();
    public void OnDisable();
    private void OnSliderChanged(float v);
}
public class SlidingProgressDoor : ProgressDoor {
    public Vector3 openPosition;
    public Vector3 closedPosition;
    public GameObject doorObject;
    public TriggerVehiclePush vehiclePhysBox;
    private float lastEnergyTime;
    private float lastServerUpdateTime;
    public virtual void Spawn();
    public virtual void NoEnergy();
    public virtual void AddEnergy(float amount);
    public void ServerUpdate();
    public virtual void UpdateProgress();
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
}
public class SlotMachine : BaseMountable {
    [ServerVar]
public static int ForcePayoutIndex;
    [HeaderAttribute("Slot Machine")]
public Transform Reel1;
    public Transform Reel2;
    public Transform Reel3;
    public Transform Arm;
    public AnimationCurve Curve;
    public int Reel1Spins;
    public int Reel2Spins;
    public int Reel3Spins;
    public int MaxReelSpins;
    public float SpinDuration;
    private int SpinResult1;
    private int SpinResult2;
    private int SpinResult3;
    private int SpinResultPrevious1;
    private int SpinResultPrevious2;
    private int SpinResultPrevious3;
    private float SpinTime;
    public GameObjectRef StoragePrefab;
    public EntityRef StorageInstance;
    public SoundDefinition SpinSound;
    public SlotMachinePayoutDisplay PayoutDisplay;
    public SlotMachinePayoutSettings PayoutSettings;
    public Transform HandIkTarget;
    private static Flags HasScrapForSpin;
    private static Flags IsSpinningFlag;
    public Material PayoutIconMaterial;
    public bool UseTimeOfDayAdjustedSprite;
    public MeshRenderer[] PulseRenderers;
    public float PulseSpeed;
    [ColorUsageAttribute("True", "True")]
public Color PulseFrom;
    [ColorUsageAttribute("True", "True")]
public Color PulseTo;
    [CompilerGeneratedAttribute]
private int <CurrentMultiplier>k__BackingField;
    private BasePlayer CurrentSpinPlayer;
    private bool IsSpinning { get; }
    public int CurrentMultiplier { get; private set; }
    private static SlotMachine();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool get_IsSpinning();
    [CompilerGeneratedAttribute]
public int get_CurrentMultiplier();
    [CompilerGeneratedAttribute]
private void set_CurrentMultiplier(int value);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual float GetComfort();
    public virtual void Spawn();
    internal virtual void DoServerDestroy();
    private int GetBettingAmount();
    [RPC_Server]
[MaxDistance("3")]
private void RPC_Spin(RPCMessage rpc);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Deposit(RPCMessage rpc);
    private void CheckPayout();
    private void DelayedSpinningReset();
    private void CalculateSpinResults();
    private int RandomSpinResult();
    public virtual void OnPlayerDismounted(BasePlayer player);
    [MaxDistance("3")]
[RPC_Server]
[CallsPerSecond("5")]
private void Server_RequestMultiplierChange(RPCMessage msg);
    public void OnBettingScrapUpdated(int amount);
    private bool CalculatePayout(PayoutInfo& info, Int32& bonus);
}
public class SlotMachineLootPanel : LootPanel {
    public Text spinsRemainingText;
    public Text multiplierText;
    public LocalizeText ScrapCostText;
}
public class SlotMachinePayoutDisplay : MonoBehaviour {
    public GameObjectRef PayoutWidget;
    public RectTransform WidgetRoot;
    public Sprite[] FaceSprites;
}
[CreateAssetMenuAttribute]
public class SlotMachinePayoutSettings : ScriptableObject {
    public ItemAmount SpinCost;
    public PayoutInfo[] Payouts;
    public Int32[] VirtualFaces;
    public IndividualPayouts[] FacePayouts;
    public int TotalStops;
    public GameObjectRef DefaultWinEffect;
}
public class SlotMachinePayoutWidget : MonoBehaviour {
    public RustText PayoutAmount;
    public GameObject AnyText;
    public Image[] Faces;
}
public class SlotMachineStorage : StorageContainer {
    public int Amount;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsPlayerValid(BasePlayer player);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    protected virtual void OnInventoryDirty();
    public void UpdateAmount(int amount);
    public virtual bool CanBeLooted(BasePlayer player);
}
public enum Smaa.DebugPass : Enum {
    public int value__;
    public static DebugPass Off;
    public static DebugPass Edges;
    public static DebugPass Weights;
}
public enum Smaa.EdgeDetectionMethod : Enum {
    public int value__;
    public static EdgeDetectionMethod Luma;
    public static EdgeDetectionMethod Color;
    public static EdgeDetectionMethod Depth;
}
public class Smaa.MinAttribute : PropertyAttribute {
    public float min;
    public MinAttribute(float min);
}
public class Smaa.PredicationPreset : object {
    [MinAttribute("0,0001")]
public float Threshold;
    [RangeAttribute("1", "5")]
public float Scale;
    [RangeAttribute("0", "1")]
public float Strength;
}
public class Smaa.Preset : object {
    public bool DiagDetection;
    public bool CornerDetection;
    [RangeAttribute("0", "0,5")]
public float Threshold;
    [MinAttribute("0,0001")]
public float DepthThreshold;
    [RangeAttribute("0", "112")]
public int MaxSearchSteps;
    [RangeAttribute("0", "20")]
public int MaxSearchStepsDiag;
    [RangeAttribute("0", "100")]
public int CornerRounding;
    [MinAttribute("0")]
public float LocalContrastAdaptationFactor;
}
public enum Smaa.QualityPreset : Enum {
    public int value__;
    public static QualityPreset Low;
    public static QualityPreset Medium;
    public static QualityPreset High;
    public static QualityPreset Ultra;
    public static QualityPreset Custom;
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Subpixel Morphological Antialiasing")]
[RequireComponent("UnityEngine.Camera")]
public class Smaa.SMAA : MonoBehaviour {
    public DebugPass DebugPass;
    public QualityPreset Quality;
    public EdgeDetectionMethod DetectionMethod;
    public bool UsePredication;
    public Preset CustomPreset;
    public PredicationPreset CustomPredicationPreset;
    public Shader Shader;
    public Texture2D AreaTex;
    public Texture2D SearchTex;
    protected Camera m_Camera;
    protected Preset m_LowPreset;
    protected Preset m_MediumPreset;
    protected Preset m_HighPreset;
    protected Preset m_UltraPreset;
    protected Material m_Material;
    public Material Material { get; }
    public Material get_Material();
}
public class SmartAlarm : AppIOEntity {
    public static Flags Flag_HasCustomMessage;
    public static Phrase DefaultNotificationTitle;
    public static Phrase DefaultNotificationBody;
    [HeaderAttribute("Smart Alarm")]
public GameObjectRef SetupNotificationDialog;
    public Animator Animator;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public NotificationList _subscriptions;
    public string _notificationTitle;
    public string _notificationBody;
    public float _lastSentTime;
    public AppEntityType Type { get; }
    public bool Value { get; public set; }
    private static SmartAlarm();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual AppEntityType get_Type();
    [CompilerGeneratedAttribute]
public virtual bool get_Value();
    [CompilerGeneratedAttribute]
public virtual void set_Value(bool value);
    public sealed virtual bool AddSubscription(ulong steamId);
    public sealed virtual bool RemoveSubscription(ulong steamId);
    public sealed virtual bool HasSubscription(ulong steamId);
    public virtual void InitShared();
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    protected virtual void OnPairedWithPlayer(BasePlayer player);
    [CallsPerSecond("5")]
[IsVisible("3")]
[RPC_Server]
private void StartSetupNotification(RPCMessage rpc);
    [CallsPerSecond("5")]
[IsVisible("3")]
[RPC_Server]
private void SetNotificationTextImpl(RPCMessage rpc);
}
public class SmartSwitch : AppIOEntity {
    [HeaderAttribute("Smart Switch")]
public Animator ReceiverAnimator;
    public AppEntityType Type { get; }
    public bool Value { get; public set; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool WantsPower(int inputIndex);
    public virtual int ConsumptionAmount();
    public virtual AppEntityType get_Type();
    public virtual void ServerInit();
    public virtual void ResetIOState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public void SetSwitch(bool wantsOn);
    [CallsPerSecond("3")]
[RPC_Server]
[IsVisible("3")]
public void ToggleSwitch(RPCMessage msg);
    public virtual bool get_Value();
    public virtual void set_Value(bool value);
    public void Unbusy();
    private static bool PlayerCanToggle(BasePlayer player);
}
public class SmokeBomb : TimedExplosive {
}
public class SmokeGrenade : TimedExplosive {
    public float smokeDuration;
    public GameObjectRef smokeEffectPrefab;
    public GameObjectRef igniteSound;
    public SoundPlayer soundLoop;
    private GameObject smokeEffectInstance;
    public static List`1<SmokeGrenade> activeGrenades;
    public float fieldMin;
    public float fieldMax;
    protected bool killing;
    private static SmokeGrenade();
    public virtual void ServerInit();
    public virtual void Explode();
    public void CheckForWater();
    public void FinishUp();
    public virtual void DestroyShared();
}
public class SnowballGun : BaseProjectile {
    public ItemDefinition OverrideProjectile;
    private static ItemDefinition _snowballInventoryItem;
    private static ItemDefinition _snowballAmmoItem;
    public static ItemDefinition SnowballInventoryItem { get; }
    public static ItemDefinition SnowballAmmoItem { get; }
    protected ItemDefinition PrimaryMagazineAmmo { get; }
    protected bool CanRefundAmmo { get; }
    public static ItemDefinition get_SnowballInventoryItem();
    public static ItemDefinition get_SnowballAmmoItem();
    public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount);
    protected virtual ItemDefinition get_PrimaryMagazineAmmo();
    protected virtual bool get_CanRefundAmmo();
}
public class SnowballGunProjectile : Projectile {
    public float OverrideEffectScale;
    public GameObjectRef SnowballImpactEffect;
}
public class SnowEffect : WeatherEffect {
    public int FadeStartDistance;
    public int FadeEndDistance;
    public int FadeFalloff;
    public bool Stormy;
}
public class SnowMachine : FogMachine {
    public AdaptMeshToTerrain snowMesh;
    public TriggerTemperature tempTrigger;
    public virtual bool MotionModeEnabled();
    public virtual void EnableFogField();
    public virtual void FinishFogging();
}
public class Snowmobile : GroundVehicle {
    [HeaderAttribute("Snowmobile")]
[SerializeField]
private Transform centreOfMassTransform;
    [SerializeField]
private GameObjectRef itemStoragePrefab;
    [SerializeField]
private VisualCarWheel wheelSkiFL;
    [SerializeField]
private VisualCarWheel wheelSkiFR;
    [SerializeField]
private VisualCarWheel wheelTreadFL;
    [SerializeField]
private VisualCarWheel wheelTreadFR;
    [SerializeField]
private VisualCarWheel wheelTreadRL;
    [SerializeField]
private VisualCarWheel wheelTreadRR;
    [SerializeField]
public CarSettings carSettings;
    [SerializeField]
public int engineKW;
    [SerializeField]
public float idleFuelPerSec;
    [SerializeField]
public float maxFuelPerSec;
    [SerializeField]
public float airControlStability;
    [SerializeField]
public float airControlPower;
    [SerializeField]
public float badTerrainDrag;
    [SerializeField]
public ProtectionProperties riderProtection;
    [SerializeField]
public float hurtTriggerMinSpeed;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerFront;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerRear;
    [HeaderAttribute("Snowmobile Visuals")]
public float minGroundFXSpeed;
    [SerializeField]
private SnowmobileChassisVisuals chassisVisuals;
    [SerializeField]
private VehicleLight[] lights;
    [SerializeField]
private Transform steeringLeftIK;
    [SerializeField]
private Transform steeringRightIK;
    [SerializeField]
private Transform leftFootIK;
    [SerializeField]
private Transform rightFootIK;
    [SerializeField]
private Transform starterKey;
    [SerializeField]
private Vector3 engineOffKeyRot;
    [SerializeField]
private Vector3 engineOnKeyRot;
    [ServerVar]
public static float outsideDecayMinutes;
    [ServerVar]
public static bool allowPassengerOnly;
    [ServerVar]
public static bool allTerrain;
    private float _throttle;
    private float _brake;
    private float _mass;
    public static Flags Flag_Slowmode;
    private EntityRef`1<StorageContainer> itemStorageInstance;
    private float cachedFuelFraction;
    private static float FORCE_MULTIPLIER;
    private float _steer;
    public CarPhysics`1<Snowmobile> carPhysics;
    public VehicleTerrainHandler serverTerrainHandler;
    private CarWheel[] wheels;
    public TimeSince timeSinceLastUsed;
    private static float DECAY_TICK_TIME;
    public float prevTerrainModDrag;
    public TimeSince timeSinceTerrainModCheck;
    public float ThrottleInput { get; protected set; }
    public float BrakeInput { get; protected set; }
    public bool IsBraking { get; }
    public float SteerAngle { get; }
    public float DriveWheelVelocity { get; }
    public float DriveWheelSlip { get; }
    public float MaxSteerAngle { get; }
    public bool InSlowMode { get; private set; }
    private float Mass { get; }
    public float SteerInput { get; protected set; }
    public Surface OnSurface { get; }
    private static Snowmobile();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public float get_ThrottleInput();
    protected void set_ThrottleInput(float value);
    public float get_BrakeInput();
    protected void set_BrakeInput(float value);
    public bool get_IsBraking();
    public sealed virtual float get_SteerAngle();
    public virtual float get_DriveWheelVelocity();
    public float get_DriveWheelSlip();
    public sealed virtual float get_MaxSteerAngle();
    public bool get_InSlowMode();
    private void set_InSlowMode(bool value);
    private float get_Mass();
    public virtual void Load(LoadInfo info);
    public sealed virtual float GetMaxDriveForce();
    public virtual float GetMaxForwardSpeed();
    public virtual float GetThrottleInput();
    public virtual float GetBrakeInput();
    public sealed virtual bool GetSteerSpeedMod(float speed);
    public virtual float GetSteerMaxMult(float speed);
    public float GetPerformanceFraction();
    public float GetFuelFraction();
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public float get_SteerInput();
    protected void set_SteerInput(float value);
    public sealed virtual Surface get_OnSurface();
    public sealed virtual float GetSteerInput();
    public virtual void ServerInit();
    public virtual void VehicleFixedUpdate();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public sealed virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public virtual float GetModifiedDrag();
    public virtual float MaxVelocity();
    public sealed virtual CarWheel[] GetWheels();
    public sealed virtual float GetWheelsMidPos();
    public virtual void Save(SaveInfo info);
    public virtual int StartingFuelUnits();
    protected virtual void OnChildAdded(BaseEntity child);
    internal virtual void DoServerDestroy();
    public virtual bool MeetsEngineRequirements();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    public void SnowmobileDecay();
    public StorageContainer GetItemContainer();
    private void UpdateClients();
    public virtual void OnEngineStartFailed();
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void RPC_OpenItemStorage(RPCMessage msg);
}
public class SnowmobileAudio : GroundVehicleAudio {
    [HeaderAttribute("Engine")]
[SerializeField]
private EngineAudioSet engineAudioSet;
    [HeaderAttribute("Skis")]
[SerializeField]
private AnimationCurve skiGainCurve;
    [SerializeField]
private SoundDefinition skiSlideSoundDef;
    [SerializeField]
private SoundDefinition skiSlideSnowSoundDef;
    [SerializeField]
private SoundDefinition skiSlideSandSoundDef;
    [SerializeField]
private SoundDefinition skiSlideGrassSoundDef;
    [SerializeField]
private SoundDefinition skiSlideWaterSoundDef;
    [SerializeField]
[HeaderAttribute("Movement")]
private AnimationCurve movementGainCurve;
    [SerializeField]
private SoundDefinition movementLoopDef;
    [SerializeField]
private SoundDefinition suspensionLurchSoundDef;
    [SerializeField]
private float suspensionLurchMinExtensionDelta;
    [SerializeField]
private float suspensionLurchMinTimeBetweenSounds;
}
public class SnowmobileChassisVisuals : VehicleChassisVisuals`1<Snowmobile> {
    [SerializeField]
private Animator animator;
    [SerializeField]
private SnowmobileAudio audioScript;
    [SerializeField]
private TreadRenderer[] treadRenderers;
    [SerializeField]
private float treadSpeedMultiplier;
    [SerializeField]
private bool flipRightSkiExtension;
    [SerializeField]
private Transform leftSki;
    [SerializeField]
private Transform leftSkiPistonIn;
    [SerializeField]
private Transform leftSkiPistonOut;
    [SerializeField]
private Transform rightSki;
    [SerializeField]
private Transform rightSkiPistonIn;
    [SerializeField]
private Transform rightSkiPistonOut;
    [SerializeField]
private float skiVisualAdjust;
    [SerializeField]
private float treadVisualAdjust;
    [SerializeField]
private float skiVisualMaxExtension;
    [SerializeField]
private float treadVisualMaxExtension;
    [SerializeField]
private float wheelSizeVisualMultiplier;
}
public class SoccerBall : BaseCombatEntity {
    [HeaderAttribute("Soccer Ball")]
[SerializeField]
private Rigidbody rigidBody;
    [SerializeField]
private float additionalForceMultiplier;
    [SerializeField]
private float upForceMultiplier;
    [SerializeField]
private DamageRenderer damageRenderer;
    [SerializeField]
private float explosionForceMultiplier;
    [SerializeField]
private float otherForceMultiplier;
    protected void OnCollisionEnter(Collision collision);
    public virtual void Hurt(HitInfo info);
}
public class Socket_Base : PrefabAttribute {
    public bool male;
    public bool maleDummy;
    public bool female;
    public bool femaleDummy;
    public bool femaleNoStability;
    public bool monogamous;
    public Vector3 position;
    public Quaternion rotation;
    private Type cachedType;
    public Vector3 selectSize;
    public Vector3 selectCenter;
    [ReadOnlyAttribute]
public string socketName;
    public SocketMod[] socketMods;
    public OccupiedSocketCheck[] checkOccupiedSockets;
    public Vector3 GetSelectPivot(Vector3 position, Quaternion rotation);
    public virtual OBB GetSelectBounds(Vector3 position, Quaternion rotation);
    protected virtual Type GetIndexedType();
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual bool TestTarget(Target target);
    public virtual bool IsCompatible(Socket_Base socket);
    public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation);
    public virtual Placement DoPlacement(Target target);
    public virtual bool CheckSocketMods(Placement& placement);
}
public class Socket_Free : Socket_Base {
    public Vector3 idealPlacementNormal;
    public bool useTargetNormal;
    public bool blendAimAngle;
    private void OnDrawGizmosSelected();
    public virtual bool TestTarget(Target target);
    public virtual Placement DoPlacement(Target target);
}
public class Socket_Specific : Socket_Base {
    public bool useFemaleRotation;
    public string targetSocketName;
    public bool blockPlacementOnChildEntities;
    private void OnDrawGizmos();
    public virtual bool TestTarget(Target target);
    public virtual Placement DoPlacement(Target target);
}
public class Socket_Specific_Female : Socket_Base {
    public int rotationDegrees;
    public int rotationOffset;
    public String[] allowedMaleSockets;
    public bool parentToBone;
    public string boneName;
    private void OnDrawGizmos();
    private void OnDrawGizmosSelected();
    public bool CanAccept(Socket_Specific socket);
    public virtual Placement DoPlacement(Target target);
}
public class Socket_Terrain : Socket_Base {
    public float placementHeight;
    public bool alignToNormal;
    private void OnDrawGizmos();
    public virtual bool TestTarget(Target target);
    public virtual Placement DoPlacement(Target target);
}
public class SocketHandle : PrefabAttribute {
    protected virtual Type GetIndexedType();
    internal void AdjustTarget(Target& target, float maxplaceDistance);
}
public abstract class SocketMod : PrefabAttribute {
    public Socket_Base baseSocket;
    [CompilerGeneratedAttribute]
private SocketMod_Grouping <SocketGrouping>k__BackingField;
    public Phrase FailedPhrase;
    public SocketMod_Grouping SocketGrouping { get; private set; }
    protected Phrase ErrorPhrase { get; }
    [CompilerGeneratedAttribute]
public SocketMod_Grouping get_SocketGrouping();
    [CompilerGeneratedAttribute]
private void set_SocketGrouping(SocketMod_Grouping value);
    protected virtual Phrase get_ErrorPhrase();
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual Phrase GetTranslatedErrorMessage();
    public virtual string GetDebugErrorMessage();
    public virtual bool DoCheck(Placement place);
    public virtual void ModifyPlacement(Placement& place);
    protected virtual Type GetIndexedType();
}
public class SocketMod_AngleCheck : SocketMod {
    public bool wantsAngle;
    public Vector3 worldNormal;
    public float withinDegrees;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_AreaCheck : SocketMod {
    public Bounds bounds;
    public LayerMask layerMask;
    public bool wantsInside;
    private Phrase lastError;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public static bool IsInArea(Vector3 position, Quaternion rotation, Bounds bounds, LayerMask layerMask, BaseEntity entity);
    public bool DoCheck(Vector3 position, Quaternion rotation, BaseEntity entity);
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_Attraction : SocketMod {
    public float outerRadius;
    public float innerRadius;
    public string groupName;
    public bool lockRotation;
    public bool ignoreRotationForRadiusCheck;
    public bool shiftDisableSnap;
    private void OnDrawGizmosSelected();
    public virtual bool DoCheck(Placement place);
    public virtual void ModifyPlacement(Placement& place);
}
public class SocketMod_BuildingBlock : SocketMod {
    public float sphereRadius;
    public LayerMask layerMask;
    public QueryTriggerInteraction queryTriggers;
    public bool wantsCollide;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_EntityCheck : SocketMod {
    public float sphereRadius;
    public LayerMask layerMask;
    public QueryTriggerInteraction queryTriggers;
    public BaseEntity[] entityTypes;
    public bool wantsCollide;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_EntityType : SocketMod {
    public float sphereRadius;
    public LayerMask layerMask;
    public QueryTriggerInteraction queryTriggers;
    public BaseEntity searchType;
    public bool wantsCollide;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual string GetDebugErrorMessage();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_EnvironmentVolume : SocketMod {
    [InspectorFlagsAttribute]
public EnvironmentType environmentNone;
    public virtual bool DoCheck(Placement place);
    private string GetErrorMessage(EnvironmentType blockedTypes);
}
public class SocketMod_Grouping : SocketMod {
    private List`1<SocketMod> SocketMods;
    protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_HotSpot : SocketMod {
    public float spotSize;
    private void OnDrawGizmos();
    public virtual void ModifyPlacement(Placement& place);
}
public class SocketMod_Inside : SocketMod {
    public bool wantsInside;
    private static Vector3[] outsideLookupDirs;
    protected Phrase ErrorPhrase { get; }
    private static SocketMod_Inside();
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
    public static bool IsOutside(Vector3 pos, Transform tr);
}
public class SocketMod_InWater : SocketMod {
    public bool wantsInWater;
    public bool excludeArtificialWater;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_PhysicMaterial : SocketMod {
    public PhysicMaterial[] ValidMaterials;
    private PhysicMaterial foundMaterial;
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_PlantCheck : SocketMod {
    public float sphereRadius;
    public LayerMask layerMask;
    public QueryTriggerInteraction queryTriggers;
    public bool wantsCollide;
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_RoadCheck : SocketMod {
    public float sphereRadius;
    public bool wantsCollide;
    public LayerMask layerMask;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_SphereCheck : SocketMod {
    public float sphereRadius;
    public LayerMask layerMask;
    public bool wantsCollide;
    public bool requireMonument;
    private Phrase lastError;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_TerrainCheck : SocketMod {
    public bool wantsInTerrain;
    public bool preventWorldLayerInMonuments;
    private static Phrase lastError;
    protected Phrase ErrorPhrase { get; }
    private static SocketMod_TerrainCheck();
    protected virtual Phrase get_ErrorPhrase();
    public static bool IsInTerrain(Vector3 vPoint, bool worldLayerInMonuments);
    public virtual bool DoCheck(Placement place);
}
public class SocketMod_WaterDepth : SocketMod {
    public float MinimumWaterDepth;
    public float MaximumWaterDepth;
    public bool BlockArtificialWaterVolumes;
    private Phrase lastError;
    private float lastDepth;
    protected Phrase ErrorPhrase { get; }
    protected virtual Phrase get_ErrorPhrase();
    public virtual string GetDebugErrorMessage();
    public virtual bool DoCheck(Placement place);
}
public class SolarPanel : IOEntity {
    public Transform sunSampler;
    private static int tickrateSeconds;
    public int maximalPowerOutput;
    public float dot_minimum;
    public float dot_maximum;
    public virtual bool IsRootEntity();
    public virtual int MaximalPowerOutput();
    public virtual int ConsumptionAmount();
    public virtual void ServerInit();
    public void SunUpdate();
    public virtual int GetPassthroughAmount(int outputSlot);
}
public class Sonar.SonarObject : MonoBehaviour {
    [SerializeField]
private SType sonarType;
}
public class Sonar.SonarSystem : FacepunchBehaviour {
    [SerializeField]
private float range;
    [SerializeField]
private float maxDepth;
    [SerializeField]
private ParticleSystem sonarPS;
    [SerializeField]
private ParticleSystem blipPS;
    [SerializeField]
private SonarObject us;
    [SerializeField]
private Color greenBlip;
    [SerializeField]
private Color redBlip;
    [SerializeField]
private Color whiteBlip;
    [SerializeField]
private SoundDefinition sonarBlipSound;
    [SerializeField]
private GameObject sonarSoundParent;
}
public class Sound : MonoBehaviour {
    public static float volumeExponent;
    public SoundDefinition definition;
    public SoundModifier[] modifiers;
    public SoundSource soundSource;
    public AudioSource[] audioSources;
    [SerializeField]
private SoundFade _fade;
    [SerializeField]
private SoundModulation _modulation;
    [SerializeField]
private SoundOcclusion _occlusion;
    public SoundFade fade { get; }
    public SoundModulation modulation { get; }
    public SoundOcclusion occlusion { get; }
    private static Sound();
    public SoundFade get_fade();
    public SoundModulation get_modulation();
    public SoundOcclusion get_occlusion();
}
[CreateAssetMenuAttribute]
public class SoundClass : ScriptableObject {
    [HeaderAttribute("Mixer Settings")]
public AudioMixerGroup output;
    public AudioMixerGroup firstPersonOutput;
    [HeaderAttribute("Occlusion Settings")]
public bool enableOcclusion;
    public bool playIfOccluded;
    public float occlusionGain;
    [TooltipAttribute("Use this mixer group when the sound is occluded to save DSP CPU usage. Only works for non-looping sounds.")]
public AudioMixerGroup occludedOutput;
    [HeaderAttribute("Voice Limiting")]
public int globalVoiceMaxCount;
    public int priority;
    public List`1<SoundDefinition> definitions;
}
public class SoundClassTest : MonoBehaviour {
    public SoundClass soundClass;
    public float soundInterval;
}
public class SoundDefinition : ScriptableObject {
    public GameObjectRef template;
    [HorizontalAttribute("2", "-1")]
public List`1<WeightedAudioClip> weightedAudioClips;
    public List`1<DistanceAudioClipList> distanceAudioClips;
    public SoundClass soundClass;
    public bool defaultToFirstPerson;
    public bool loop;
    public bool randomizeStartPosition;
    public bool useHighQualityFades;
    [RangeAttribute("0", "1")]
public float volume;
    [RangeAttribute("0", "1")]
public float volumeVariation;
    [RangeAttribute("-3", "3")]
public float pitch;
    [RangeAttribute("0", "1")]
public float pitchVariation;
    [HeaderAttribute("Voice limiting")]
public bool dontVoiceLimit;
    public int globalVoiceMaxCount;
    public int localVoiceMaxCount;
    public float localVoiceRange;
    public float voiceLimitFadeOutTime;
    public float localVoiceDebounceTime;
    [HeaderAttribute("Occlusion Settings")]
public bool forceOccludedPlayback;
    [HeaderAttribute("Doppler")]
public bool enableDoppler;
    public float dopplerAmount;
    public float dopplerScale;
    public float dopplerAdjustmentRate;
    [HeaderAttribute("Custom curves")]
public AnimationCurve falloffCurve;
    public bool useCustomFalloffCurve;
    public AnimationCurve spatialBlendCurve;
    public bool useCustomSpatialBlendCurve;
    public AnimationCurve spreadCurve;
    public bool useCustomSpreadCurve;
    public float maxDistance { get; }
    public float get_maxDistance();
    public float GetLength();
    public Sound Play();
    public Sound Play(GameObject forGameObject);
}
public class SoundFade : MonoBehaviour {
    public SoundFadeHQAudioFilter hqFadeFilter;
    public float currentGain;
    public float startingGain;
    public float finalGain;
    public int sampleRate;
    public bool highQualityFadeCompleted;
    public float length;
    public Direction currentDirection;
}
public class SoundFadeHQAudioFilter : MonoBehaviour {
}
public class SoundFollowCollider : MonoBehaviour {
    public SoundDefinition soundDefinition;
    public Sound sound;
    public Bounds soundFollowBounds;
    public bool startImmediately;
}
public class SoundLightDialog : UIDialog {
    public RustOption ColourOption;
    public RustOption VolumeOption;
    public RustOption SpeedOption;
    public RustOption PatternOption;
    public RustOption GradientOption;
}
public class SoundManager : SingletonComponent`1<SoundManager> {
    public SoundClass defaultSoundClass;
}
public class SoundModifier : MonoBehaviour {
    [HideInInspector]
public Sound sound;
}
public class SoundModulation : MonoBehaviour {
    private static int parameterCount;
}
public class SoundOcclusion : MonoBehaviour {
    public LayerMask occlusionLayerMask;
}
public class SoundPlayer : BaseMonoBehaviour {
    public SoundDefinition soundDefinition;
    public bool playImmediately;
    public float minStartDelay;
    public float maxStartDelay;
    public bool debugRepeat;
    public bool pending;
    public Vector3 soundOffset;
}
public class SoundPlayerCull : MonoBehaviour {
    public SoundPlayer soundPlayer;
    public float cullDistance;
}
public class SoundPlayerCullLODComponent : LODComponent {
    public float Distance;
    public SoundPlayer TargetSoundPlayer;
    private void OnValidate();
}
public class SoundRandomizer : object {
}
[RequireComponent("SoundPlayer")]
public class SoundRepeater : MonoBehaviour {
    public float interval;
    public SoundPlayer player;
}
public class SoundSource : MonoBehaviour {
    [HeaderAttribute("Occlusion")]
public bool handleOcclusionChecks;
    public LayerMask occlusionLayerMask;
    public List`1<OcclusionPoint> occlusionPoints;
    public bool isOccluded;
    public float occlusionAmount;
    public float lodDistance;
    public bool inRange;
    public virtual void PreClientComponentCull(IPrefabProcessor p);
    public bool IsSyncedToParent();
}
public class SoundVoiceLimiter : MonoBehaviour {
    public int maxSimultaneousSounds;
}
public class SpaceCheckingSpawnPoint : GenericSpawnPoint {
    public bool useCustomBoundsCheckMask;
    public LayerMask customBoundsCheckMask;
    public float customBoundsCheckScale;
    public virtual bool IsAvailableTo(GameObject prefab);
}
public class Spawnable : MonoBehaviour {
    [ReadOnlyAttribute]
public SpawnPopulationBase Population;
    [SerializeField]
private bool ForceSpawnOnly;
    [SerializeField]
private string ForceSpawnInfoMessage;
    internal UInt32 PrefabID;
    internal bool SpawnIndividual;
    internal Vector3 SpawnPosition;
    internal Quaternion SpawnRotation;
    protected void OnEnable();
    protected void OnDisable();
    private void Add();
    private void Remove();
    internal void Save(SaveInfo info);
    internal void Load(LoadInfo info);
    protected void OnValidate();
}
public class SpawnableBoundsBlocker : MonoBehaviour {
    public BlockType BlockType;
    public BoxCollider BoxCollider;
    [ButtonAttribute("Clear Trees")]
public void ClearTrees();
}
public class SpawnDistribution : object {
    internal SpawnHandler Handler;
    public float Density;
    public int Count;
    private WorldSpaceGrid`1<int> grid;
    private Dictionary`2<UInt32, int> dict;
    private ByteQuadtree quadtree;
    private Vector3 origin;
    private Vector3 area;
    public SpawnDistribution(SpawnHandler handler, Byte[] baseValues, Vector3 origin, Vector3 area);
    public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, bool alignToNormal, float dithering, float radius);
    public bool Sample(Vector3& spawnPos, Quaternion& spawnRot, Element node, bool alignToNormal, float dithering, float radius);
    public Element SampleNode();
    public void AddInstance(Spawnable spawnable);
    public void RemoveInstance(Spawnable spawnable);
    private void UpdateCount(Spawnable spawnable, int delta);
    public int GetCount(UInt32 prefabID);
    public int GetCount(Vector3 position);
    public float GetGridCellArea();
}
public class SpawnFilter : object {
    [InspectorFlagsAttribute]
public Enum SplatType;
    [InspectorFlagsAttribute]
public Enum BiomeType;
    [InspectorFlagsAttribute]
public Enum TopologyAny;
    [InspectorFlagsAttribute]
public Enum TopologyAll;
    [InspectorFlagsAttribute]
public Enum TopologyNot;
    public bool Test(Vector3 worldPos);
    public bool Test(float normX, float normZ);
    public float GetFactor(Vector3 worldPos, bool checkPlacementMap, float checkTopologyRadius);
    public float GetFactor(float normX, float normZ, bool checkPlacementMap, float checkTopologyRadius);
}
public enum SpawnFilterMode : Enum {
    public int value__;
    public static SpawnFilterMode PivotPoint;
    public static SpawnFilterMode TerrainAnchorPoints;
    public static SpawnFilterMode TerrainCheckPoints;
}
public class SpawnGroup : BaseMonoBehaviour {
    [InspectorFlagsAttribute]
public MonumentTier Tier;
    public List`1<SpawnEntry> prefabs;
    public int maxPopulation;
    public int numToSpawnPerTickMin;
    public int numToSpawnPerTickMax;
    public float respawnDelayMin;
    public float respawnDelayMax;
    public bool wantsInitialSpawn;
    public bool temporary;
    public bool forceInitialSpawn;
    public bool preventDuplicates;
    public bool isSpawnerActive;
    public BoxCollider setFreeIfMovedBeyond;
    public string category;
    public MonumentInfo Monument;
    public bool fillOnSpawn;
    public BaseSpawnPoint[] spawnPoints;
    public List`1<SpawnPointInstance> spawnInstances;
    public LocalClock spawnClock;
    public int currentPopulation { get; }
    public sealed virtual int get_currentPopulation();
    public virtual bool WantsInitialSpawn();
    public virtual bool WantsTimedSpawn();
    public float GetSpawnDelta();
    public float GetSpawnVariance();
    protected void Awake();
    protected void OnDestroy();
    public sealed virtual void Fill();
    public sealed virtual void Clear();
    public bool HasSpawned(UInt32 prefabID);
    public virtual void SpawnInitial();
    public sealed virtual void SpawnRepeating();
    public sealed virtual void ObjectSpawned(SpawnPointInstance instance);
    public sealed virtual void ObjectRetired(SpawnPointInstance instance);
    public void DelayedSpawn();
    public void Spawn();
    protected virtual void Spawn(int numToSpawn);
    protected virtual void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint);
    protected GameObjectRef GetPrefab();
    protected virtual BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, Vector3& pos, Quaternion& rot);
    private MonumentInfo FindMonument();
    protected virtual void OnDrawGizmos();
    [CompilerGeneratedAttribute]
private int <GetPrefab>b__39_0(SpawnEntry x);
}
public class SpawnHandler : SingletonComponent`1<SpawnHandler> {
    public float TickInterval;
    public int MinSpawnsPerTick;
    public int MaxSpawnsPerTick;
    public LayerMask PlacementMask;
    public LayerMask PlacementCheckMask;
    public float PlacementCheckHeight;
    public LayerMask RadiusCheckMask;
    public float RadiusCheckDistance;
    public LayerMask BoundsCheckMask;
    public SpawnFilter CharacterSpawn;
    public float CharacterSpawnCutoff;
    public SpawnPopulationBase[] SpawnPopulations;
    public SpawnDistribution[] SpawnDistributions;
    public SpawnDistribution CharDistribution;
    public ListHashSet`1<ISpawnGroup> SpawnGroups;
    internal List`1<SpawnIndividual> SpawnIndividuals;
    [ReadOnlyAttribute]
public SpawnPopulationBase[] ConvarSpawnPopulations;
    public Dictionary`2<SpawnPopulationBase, SpawnDistribution> population2distribution;
    private bool spawnTick;
    public SpawnPopulationBase[] AllSpawnPopulations;
    protected void OnEnable();
    public static SpawnPoint GetSpawnPoint();
    private static bool GetSpawnPointStandard(SpawnPoint spawnPoint);
    public void UpdateDistributions();
    public void FillPopulations();
    public void FillGroups();
    public void FillIndividuals();
    public void InitialSpawn();
    public void StartSpawnTick();
    [IteratorStateMachineAttribute("SpawnHandler/<SpawnTick>d__29")]
private IEnumerator SpawnTick();
    [IteratorStateMachineAttribute("SpawnHandler/<SpawnGroupTick>d__30")]
private IEnumerator SpawnGroupTick();
    [IteratorStateMachineAttribute("SpawnHandler/<SpawnIndividualTick>d__31")]
private IEnumerator SpawnIndividualTick();
    public void SpawnInitial(SpawnPopulationBase population, SpawnDistribution distribution);
    public void SpawnRepeating(SpawnPopulationBase population, SpawnDistribution distribution);
    public GameObject Spawn(SpawnPopulationBase population, Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot);
    private GameObject Spawn(Prefab`1<Spawnable> prefab, Vector3 pos, Quaternion rot);
    public bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale);
    public static bool CheckBounds(GameObject gameObject, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask mask);
    public void EnforceLimits(bool forceAll);
    public void EnforceLimits(SpawnPopulationBase population, SpawnDistribution distribution);
    public Spawnable[] FindAll(SpawnPopulationBase population);
    public void AddRespawn(SpawnIndividual individual);
    public void AddInstance(Spawnable spawnable);
    public void RemoveInstance(Spawnable spawnable);
    public static float PlayerFraction();
    public static float PlayerLerp(float min, float max);
    public static float PlayerExcess();
    public static float PlayerScale(float scalar);
    public void DumpReport(string filename);
    public string GetReport(bool detailed);
}
public class SpawnIndividual : ValueType {
    public UInt32 PrefabID;
    public Vector3 Position;
    public Quaternion Rotation;
    public SpawnIndividual(UInt32 prefabID, Vector3 position, Quaternion rotation);
}
public class SpawnPointInstance : MonoBehaviour {
    public ISpawnPointUser parentSpawnPointUser;
    public BaseSpawnPoint parentSpawnPoint;
    public void Notify();
    public void Retire();
    protected void OnDestroy();
}
[CreateAssetMenuAttribute]
public class SpawnPointSpawnPopulation : SpawnPopulationBase {
    [SerializeField]
private SpawnPointType spawnPointType;
    private SpawnFilter Filter;
    public virtual void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);
    public virtual Byte[] GetBaseMapValues(int populationRes);
    public virtual SpawnFilter GetSpawnFilter();
    public virtual int GetTargetCount(SpawnDistribution distribution);
    private bool TryGetSpawnPoints(List`1& result);
}
public abstract class SpawnPopulationBase : BaseScriptableObject {
    public string ResourceFolder;
    public GameObjectRef[] ResourceList;
    public bool EnforcePopulationLimits;
    public float SpawnRate;
    public bool ScaleWithServerPopulation;
    public Prefab`1[] Prefabs;
    public Int32[] numToSpawn;
    protected bool haveInitialized;
    public virtual bool Initialize();
    public float GetCurrentSpawnRate();
    public void Fill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);
    public abstract virtual void SubFill(SpawnHandler spawnHandler, SpawnDistribution distribution, int numToFill, bool initialSpawn);
    public abstract virtual Byte[] GetBaseMapValues(int populationRes);
    public abstract virtual int GetTargetCount(SpawnDistribution distribution);
    public abstract virtual SpawnFilter GetSpawnFilter();
    public void GetReportString(StringBuilder sb, bool detailed);
}
public class Speargun : CrossbowWeapon {
    public GameObject worldAmmoModel;
    public virtual bool ForceSendMagazine(SaveInfo saveInfo);
    protected virtual bool VerifyClientAttack(BasePlayer player);
    public virtual bool CanBeUsedInWater();
}
public class SphereEntity : BaseEntity {
    public float currentRadius;
    public float lerpRadius;
    public float lerpSpeed;
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public void LerpRadiusTo(float radius, float speed);
    public void UpdateScale();
    public void Update();
}
public class SpiderWeb : BaseCombatEntity {
    public bool Fresh();
    public virtual void ServerInit();
}
public class SpinnerWheel : Signage {
    public Transform wheel;
    public float velocity;
    public Quaternion targetRotation;
    [HeaderAttribute("Sound")]
public SoundDefinition spinLoopSoundDef;
    public SoundDefinition spinStartSoundDef;
    public SoundDefinition spinAccentSoundDef;
    public SoundDefinition spinStopSoundDef;
    public float minTimeBetweenSpinAccentSounds;
    public float spinAccentAngleDelta;
    private Sound spinSound;
    private Modulator spinSoundGain;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool AllowPlayerSpins();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual float GetMaxSpinSpeed();
    public virtual void Update_Server();
    public void Update_Client();
    public void Update();
    [MaxDistance("3")]
[RPC_Server]
private void RPC_Spin(RPCMessage rpc);
    private void ToggleChildEntityColliders(bool state);
    [MaxDistance("3")]
[RPC_Server]
private void RPC_AnyoneSpin(RPCMessage rpc);
    public bool AnyoneSpin();
}
public class SpinUpWeapon : BaseProjectile {
    public float timeBetweenSpinToggle;
    public float spinUpTime;
    public GameObjectRef bulletEffect;
    public float projectileThicknessOverride;
    public bool showSpinProgress;
    public float spinningMoveSpeedScale;
    public float conditionLossPerSecondSpinning;
    public ItemModWearable BackpackWearable;
    public static Flags FullySpunFlag;
    public static Flags SpinningFlag;
    public static Flags ShootingFlag;
    private static float bulletSpeed;
    private float lastSpinToggleTime;
    public ItemModWearable WearableWhileEquipped { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual ItemModWearable get_WearableWhileEquipped();
    public virtual float GetOverrideProjectileThickness(Projectile projectile);
    public bool IsSpinning();
    public bool IsFullySpun();
    public virtual void ServerUse();
    public virtual void ServerReload();
    public virtual void ServerUse(float damageModifier, Transform originOverride, bool useBulletThickness);
    public virtual void ServerUseBase(float damageModifier, Transform originOverride);
    public virtual void SetGenericVisible(bool visible);
    public virtual void OnHeldChanged();
    public void UpdateConditionLoss();
    public void FireFakeBulletServer(float aimconeToUse);
    protected virtual void OnReceivedSignalServer(Signal signal, string arg);
    public void StopMainTrigger();
    public virtual void DidAttackServerside();
    [IsActiveItem]
[CallsPerSecond("8")]
[RPC_Server]
private void Server_SetSpinButton(RPCMessage msg);
    public void SetFullySpun();
    private void DoFakeBullets();
    private void FakeBullet();
    private void FakeBullet1();
    private void FakeBullet2();
    private void FakeBullet3();
    private void CancelFakeBullets();
}
public class SpinUpWeaponSounds : MonoBehaviour {
    public SoundDefinition spinStartDef;
    public SoundDefinition spinReleaseDef;
    public SoundDefinition spinStopDef;
    public SoundDefinition spinLoopUnpitchedDef;
    public SoundDefinition spinLoopPitchedDef;
    public AnimationCurve spinUnpitchedGainCurve;
    public AnimationCurve spinPitchedGainCurve;
    public AnimationCurve spinPitchCurve;
    public AnimationCurve spinPitchedGainCurveDown;
    public AnimationCurve spinPitchCurveDown;
    public List`1<GunshotLayer> gunshotLayers;
}
public class Splitter : IOEntity {
    public bool BlockFluidDraining { get; }
    public virtual int ConsumptionAmount();
    public virtual bool get_BlockFluidDraining();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool IsRootEntity();
    public virtual void OnCircuitChanged(bool forceUpdate);
}
public class SpookySpeaker : IOEntity {
    public SoundPlayer soundPlayer;
    public float soundSpacing;
    public float soundSpacingRand;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void PostServerLoad();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual int ConsumptionAmount();
    private void SetTargetState(bool state);
    [IsVisible("3")]
[RPC_Server]
public void SetWantsOn(RPCMessage msg);
    public void UpdateInvokes();
    public void SendPlaySound();
    public void DelayedOff();
}
public class SprayCan : HeldEntity {
    public static float MaxFreeSprayDistanceFromStart;
    public static float MaxFreeSprayStartingDistance;
    private SprayCanSpray_Freehand paintingLine;
    public static Flags IsFreeSpraying;
    public SoundDefinition SpraySound;
    public GameObjectRef SkinSelectPanel;
    public float SprayCooldown;
    public float ConditionLossPerSpray;
    public float ConditionLossPerReskin;
    public GameObjectRef LinePrefab;
    public Color[] SprayColours;
    public Single[] SprayWidths;
    public ParticleSystem worldSpaceSprayFx;
    public GameObjectRef ReskinEffect;
    public ItemDefinition SprayDecalItem;
    public GameObjectRef SprayDecalEntityRef;
    public SteamInventoryItem FreeSprayUnlockItem;
    public MinMaxGradient DecalSprayGradient;
    public SoundDefinition SprayLoopDef;
    public static Phrase FreeSprayNamePhrase;
    public static Phrase FreeSprayDescPhrase;
    public static Phrase BuildingSkinColourPhrase;
    public static Phrase BuildingSkinColourDescPhrase;
    public static Phrase DoorMustBeClosed;
    public static Phrase NeedDoorAccess;
    public static Phrase CannotReskinThatDoor;
    [FormerlySerializedAsAttribute("ShippingCOntainerColourLookup")]
public ConstructionSkin_ColourLookup ShippingContainerColourLookup;
    public static string ENEMY_BASE_STAT;
    private static SprayCan();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[IsActiveItem]
private void BeginFreehandSpray(RPCMessage msg);
    public void ClearPaintingLine(bool allowNewSprayImmediately);
    public bool CanSprayFreehand(BasePlayer player);
    private bool IsSprayBlockedByTrigger(Vector3 pos);
    private bool ValidateEntityAndSkin(BasePlayer player, BaseNetworkable targetEnt, int targetSkin);
    private void SprayFailResponse(SprayFailReason reason);
    [IsActiveItem]
[RPC_Server]
[CallsPerSecond("2")]
private void ChangeItemSkin(RPCMessage msg);
    [RPC_Server]
[IsActiveItem]
[CallsPerSecond("2")]
[MaxDistance("5")]
private void ChangeWallpaper(RPCMessage msg);
    private bool GetEntityPrefabPath(ItemDefinition def, String& resourcePath);
    [RPC_Server]
[IsActiveItem]
private void CreateSpray(RPCMessage msg);
    private void CheckAchievementPosition(Vector3 pos);
    private void LoseCondition(float amount);
    public void ClearBusy();
    public virtual void OnHeldChanged();
    [RPC_Server]
[CallsPerSecond("3")]
[IsActiveItem]
private void Server_SetBlockColourId(RPCMessage msg);
    private bool CanEntityBeRespawned(BaseEntity targetEntity, SprayFailReason& reason);
    public static bool GetItemDefinitionForEntity(BaseEntity be, ItemDefinition& def, bool useRedirect);
    [CompilerGeneratedAttribute]
internal static void <ChangeItemSkin>g__SaveEntityStorage|37_0(BaseEntity baseEntity, Dictionary`2<ContainerSet, List`1<Item>> dictionary, int index);
    [CompilerGeneratedAttribute]
internal static void <ChangeItemSkin>g__RestoreEntityStorage|37_1(BaseEntity baseEntity, int index, Dictionary`2<ContainerSet, List`1<Item>> copy);
}
public class SprayCanSkinSelect : UIDialog {
    public IconSkinPicker skinPicker;
}
public class SprayCanSpray : DecayEntity {
    private DateTime sprayTimestamp;
    public ulong sprayedByPlayer;
    public static ListHashSet`1<SprayCanSpray> AllSprays;
    public int splashThreshold;
    public bool BypassInsideDecayMultiplier { get; }
    private static SprayCanSpray();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public void ApplyOutOfAuthConditionPenalty();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public void RainCheck();
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    [RPC_Server]
private void Server_RequestWaterClear(RPCMessage msg);
    public virtual bool get_BypassInsideDecayMultiplier();
    public bool Menu_WaterClear_ShowIf(BasePlayer player);
}
public class SprayCanSpray_Decal : SprayCanSpray {
    public DeferredDecal DecalComponent;
    public GameObject IconPreviewRoot;
    public Material DefaultMaterial;
}
public class SprayCanSpray_Freehand : SprayCanSpray {
    public AlignedLineDrawer LineDrawer;
    public List`1<LinePoint> LinePoints;
    public Color colour;
    public float width;
    public EntityRef`1<BasePlayer> editingPlayer;
    public GroundWatch groundWatch;
    public MeshCollider meshCollider;
    public static int MaxLinePointLength;
    public static float SimplifyTolerance;
    private bool AcceptingChanges { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool get_AcceptingChanges();
    public virtual bool ShouldNetworkOwnerInfo();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public void SetColour(Color newColour);
    public void SetWidth(float lineWidth);
    [RPC_Server]
private void Server_AddPointMidSpray(RPCMessage msg);
    public void EnableChanges(BasePlayer byPlayer);
    public void TimeoutEditing();
    [RPC_Server]
private void Server_FinishEditing(RPCMessage msg);
    public void AddInitialPoint(Vector3 atNormal);
    private void UpdateGroundWatch();
    public virtual void Load(LoadInfo info);
    public void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to);
    public void CopyPoints(List`1<LinePoint> from, List`1<Vector3> to);
    public void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to);
    public static void CopyPoints(List`1<LinePoint> from, List`1<LinePoint> to);
    public virtual void ResetState();
}
public class SprayCanViewmodel : MonoBehaviour {
    public ParticleSystem Particles;
    public SoundDefinition sprayLoopDef;
}
public class SprayDecay : Decay {
    public virtual bool ShouldDecay(BaseEntity entity);
    public virtual float GetDecayDelay(BaseEntity entity);
    public virtual float GetDecayDuration(BaseEntity entity);
}
public class Sprinkler : IOEntity {
    public float SplashFrequency;
    public Transform Eyes;
    public int WaterPerSplash;
    public float DecayPerSplash;
    public static Flags Flag_Radiation;
    public ItemDefinition currentFuelType;
    private IOEntity currentFuelSource;
    private HashSet`1<ISplashable> cachedSplashables;
    private TimeSince updateSplashableCache;
    private bool forceUpdateSplashables;
    public bool BlockFluidDraining { get; }
    public virtual bool get_BlockFluidDraining();
    public virtual int ConsumptionAmount();
    public virtual int DesiredPower(int inputIndex);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot);
    private void DoSplash();
    public void SetSprinklerState(bool wantsOn);
    public void TurnOn();
    public void TurnOff();
    public virtual void SetFuelType(ItemDefinition def, IOEntity source);
    public virtual void Load(LoadInfo info);
}
public class SpriteArcadeEntity : ArcadeEntity {
    public SpriteRenderer spriteRenderer;
}
public class SquareBorder : MonoBehaviour {
    public float Size;
    public Color Color;
    public RectTransform Top;
    public RectTransform Bottom;
    public RectTransform Left;
    public RectTransform Right;
    public Image TopImage;
    public Image BottomImage;
    public Image LeftImage;
    public Image RightImage;
    private float _lastSize;
    private Color _lastColor;
    private void Update();
}
public class sRGB : object {
    public static Byte[] to_linear;
    public static Byte[] to_srgb;
    private static sRGB();
    public static float linear_to_srgb(float linear);
    public static float srgb_to_linear(float srgb);
}
public class StabilityEntity : DecayEntity {
    public static Phrase CancelTitle;
    public static Phrase CancelDesc;
    public bool grounded;
    public float cachedStability;
    public int cachedDistanceFromGround;
    private List`1<Support> supports;
    private int stabilityStrikes;
    private bool dirty;
    public static Phrase DemolishTitle;
    public static Phrase DemolishDesc;
    [ServerVar]
public static int demolish_seconds;
    public static Flags DemolishFlag;
    public bool canBeDemolished;
    public static StabilityCheckWorkQueue stabilityCheckQueue;
    public static UpdateSurroundingsQueue updateSurroundingsQueue;
    public bool CanBeDemolished { get; }
    private static StabilityEntity();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public void InitializeSupports();
    public int DistanceFromGround(StabilityEntity ignoreEntity);
    public float SupportValue(StabilityEntity ignoreEntity);
    public int CachedDistanceFromGround(StabilityEntity ignoreEntity);
    public float CachedSupportValue(StabilityEntity ignoreEntity);
    public virtual void StabilityCheck();
    public void UpdateStability();
    public void UpdateSurroundingEntities();
    public void UpdateConnectedEntities();
    protected void OnPhysicsNeighbourChanged();
    protected void DebugNudge();
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public virtual bool get_CanBeDemolished();
    public bool CanDemolish(BasePlayer player);
    public bool IsDemolishable();
    public bool HasDemolishPrivilege(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
public void DoDemolish(RPCMessage msg);
    [MaxDistance("3")]
[RPC_Server]
public void DoImmediateDemolish(RPCMessage msg);
    public void StopBeingDemolishable();
    public void StartBeingDemolishable();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class StabilitySocket : Socket_Base {
    [RangeAttribute("0", "1")]
public float support;
    private void OnDrawGizmosSelected();
    public virtual bool TestTarget(Target target);
    public virtual bool CanConnect(Vector3 position, Quaternion rotation, Socket_Base socket, Vector3 socketPosition, Quaternion socketRotation);
}
public class Stag : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Stag();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public class StagedResourceBreakEffect : MonoBehaviour {
}
public class StagedResourceEntity : ResourceEntity {
    public List`1<ResourceStage> stages;
    public int stage;
    public GameObjectRef changeStageEffect;
    public GameObject gibSourceTest;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
    protected virtual void OnHealthChanged();
    public virtual void UpdateNetworkStage();
    private int FindBestStage();
    public T GetStageComponent();
    private void UpdateStage();
}
public class StampClanLogo : MonoBehaviour {
    public GameObject UiElement;
    public RawImage LogoPreview;
    public MeshPaintController Controller;
}
[Factory("stash")]
public class StashContainer : StorageContainer {
    public Transform visuals;
    public float burriedOffset;
    public float raisedOffset;
    public GameObjectRef buryEffect;
    public float uncoverRange;
    public float uncoverTime;
    [ServerVar]
public static float PlayerDetectionTickRate;
    private float lastToggleTime;
    private static StashContainer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool PlayerInRange(BasePlayer ply);
    public virtual void InitShared();
    public void DoOccludedCheck();
    public void OnPhysicsNeighbourChanged();
    private void RemoveFromNetworkRange();
    private void ReturnToNetworkRange();
    public void SetHidden(bool isHidden);
    public void DisableNetworking();
    public void Decay();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public void ToggleHidden();
    [RPC_Server]
[IsVisible("3")]
public void RPC_HideStash(RPCMessage rpc);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public bool IsHidden();
}
public class StateErrorAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class StateErrorEventUI : BaseEventUI {
}
public class StateFinishedAIEvent : BaseAIEvent {
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class StateFinishedEventUI : BaseEventUI {
}
public class StateLayerController : StateMachineBehaviour {
    public int TargetLayer;
}
public enum StateStatus : Enum {
    public int value__;
    public static StateStatus Running;
    public static StateStatus Finished;
    public static StateStatus Error;
}
public class StateTimer : ValueType {
    public float ReleaseTime;
    public Action OnFinished;
    public bool IsActive { get; }
    public void Activate(float seconds, Action onFinished);
    public bool get_IsActive();
}
public class StaticInstrument : BaseMountable {
    public AnimatorOverrideController AnimatorOverride;
    public bool ShowDeployAnimation;
    public InstrumentKeyController KeyController;
    public bool ShouldSuppressHandsAnimationLayer;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
private void Server_PlayNote(RPCMessage msg);
    [RPC_Server]
private void Server_StopNote(RPCMessage msg);
    public virtual bool IsInstrument();
}
public class StaticMapMarker : MapMarker {
    private GameObject createdMarker;
}
public class StaticRespawnArea : SleepingBag {
    public Transform[] spawnAreas;
    public bool allowHostileSpawns;
    public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers);
    public virtual void GetSpawnPos(Vector3& pos, Quaternion& rot);
    public virtual void SetUnlockTime(float newTime);
    public virtual float GetUnlockSeconds(ulong playerID);
}
public enum Stats : Enum {
    public int value__;
    public static Stats Steam;
    public static Stats Server;
    public static Stats Life;
    public static Stats All;
}
public class StatusLightRenderer : MonoBehaviour {
    public Material offMaterial;
    public Material onMaterial;
    private MaterialPropertyBlock propertyBlock;
    private Renderer targetRenderer;
    private Color lightColor;
    private Light targetLight;
    private int colorID;
    private int emissionID;
    protected void Awake();
    public void SetOff();
    public void SetOn();
    public void SetRed();
    public void SetGreen();
    private Color GetColor(byte r, byte g, byte b, byte a);
    private Color GetColor(byte r, byte g, byte b, byte a, float intensity);
}
public class SteamClientWrapper : SingletonComponent`1<SteamClientWrapper> {
}
[CreateAssetMenuAttribute]
public class SteamDLCItem : ScriptableObject {
    public Phrase dlcName;
    public int dlcAppID;
    public bool bypassLicenseCheck;
    public bool HasLicense(ulong steamid);
    public bool CanUse(BasePlayer player);
}
public class SteamFriendsList : MonoBehaviour {
    public RectTransform targetPanel;
    public SteamUserButton userButton;
    public bool IncludeFriendsList;
    public bool IncludeRecentlySeen;
    public bool IncludeLastAttacker;
    public bool IncludeRecentlyPlayedWith;
    public bool ShowTeamFirst;
    public bool HideSteamIdsInStreamerMode;
    public bool IncludeContacts;
    public bool RefreshOnEnable;
    public onFriendSelectedEvent onFriendSelected;
    public Func`2<ulong, bool> shouldShowPlayer;
}
public class SteamInventory : EntityComponent`1<BasePlayer> {
    private IPlayerItem[] Items;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool HasItem(int itemid);
    [AsyncStateMachineAttribute("SteamInventory/<UpdateSteamInventory>d__3")]
[RPC_Server]
[FromOwner]
private Task UpdateSteamInventory(RPCMessage msg);
}
[CreateAssetMenuAttribute]
public class SteamInventoryCategory : ScriptableObject {
    [HeaderAttribute("Steam Inventory")]
public bool canBeSoldToOtherUsers;
    public bool canBeTradedWithOtherUsers;
    public bool isCommodity;
    public Price price;
    public DropChance dropChance;
    public bool CanBeInCrates;
}
public class SteamInventoryGen : MonoBehaviour {
}
[CreateAssetMenuAttribute]
public class SteamInventoryItem : ScriptableObject {
    public int id;
    public Sprite icon;
    public Phrase displayName;
    public Phrase displayDescription;
    [HeaderAttribute("Steam Inventory")]
public Category category;
    public SubCategory subcategory;
    public SteamInventoryCategory steamCategory;
    public bool isLimitedTimeOffer;
    [TooltipAttribute("Stop this item being broken down into cloth etc")]
public bool PreventBreakingDown;
    public bool IsTwitchDrop;
    [HeaderAttribute("Meta")]
public string itemname;
    public ulong workshopID;
    public SteamDLCItem DlcItem;
    [TooltipAttribute("Does nothing currently")]
public bool forceCraftableItemDesc;
    public ItemDefinition itemDefinition { get; }
    public ItemDefinition get_itemDefinition();
    public virtual bool HasUnlocked(ulong playerId);
}
public static class SteamNewsSource : object {
    public static Story[] Stories;
    [IteratorStateMachineAttribute("SteamNewsSource/<GetStories>d__2")]
public static IEnumerator GetStories();
}
public class SteamStatistics : object {
    private BasePlayer player;
    public Dictionary`2<string, int> intStats;
    private Task refresh;
    public SteamStatistics(BasePlayer p);
    public void Init();
    public void Save();
    public void Add(string name, int var);
    public int Get(string name);
}
public class SteamUserButton : MonoBehaviour {
    public RustText steamName;
    public RustText steamInfo;
    public RawImage avatar;
    public Color colorTeamOnline;
    public Color colorTeamOffline;
    public Color colorFriendOnline;
    public Color colorFriendOffline;
    public Color colorOnline;
    public Color colorOffline;
    [CompilerGeneratedAttribute]
private ulong <SteamId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    public ulong SteamId { get; private set; }
    public string Username { get; private set; }
    [CompilerGeneratedAttribute]
public ulong get_SteamId();
    [CompilerGeneratedAttribute]
private void set_SteamId(ulong value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
private void set_Username(string value);
}
public class Stocking : LootContainer {
    public static ListHashSet`1<Stocking> stockings;
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    public bool IsEmpty();
    public virtual void SpawnLoot();
    public virtual void PlayerStoppedLooting(BasePlayer player);
}
public class StorageContainer : DecayEntity {
    [HeaderAttribute("Storage Container")]
public static Phrase LockedMessage;
    public static Phrase InUseMessage;
    public int inventorySlots;
    public bool dropsLoot;
    public float dropLootDestroyPercent;
    public bool dropFloats;
    public bool isLootable;
    public bool isLockable;
    public bool isMonitorable;
    public string panelName;
    public Phrase panelTitle;
    public ContentsType allowedContents;
    public ItemDefinition allowedItem;
    public ItemDefinition allowedItem2;
    public ItemDefinition[] blockedItems;
    public int maxStackSize;
    public bool needsBuildingPrivilegeToUse;
    public bool mustBeMountedToUse;
    public SoundDefinition openSound;
    public SoundDefinition closeSound;
    [HeaderAttribute("Item Dropping")]
public Vector3 dropPosition;
    public Vector3 dropVelocity;
    public ItemCategory onlyAcceptCategory;
    public bool onlyOneUser;
    public ItemContainer _inventory;
    [CompilerGeneratedAttribute]
private ulong <LastLootedBy>k__BackingField;
    public Phrase LootPanelTitle { get; }
    public ItemContainer inventory { get; }
    public Transform Transform { get; }
    public bool DropsLoot { get; }
    public bool DropFloats { get; }
    public float DestroyLootPercent { get; }
    public ulong LastLootedBy { get; public set; }
    private static StorageContainer();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Phrase get_LootPanelTitle();
    public virtual void OnDrawGizmos();
    public sealed virtual ItemContainer get_inventory();
    public sealed virtual Transform get_Transform();
    public sealed virtual bool get_DropsLoot();
    public sealed virtual bool get_DropFloats();
    public sealed virtual float get_DestroyLootPercent();
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_LastLootedBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastLootedBy(ulong value);
    public bool MoveAllInventoryItems(ItemContainer from);
    public static bool MoveAllInventoryItems(ItemContainer source, ItemContainer dest);
    public virtual void ReceiveInventoryFromItem(Item item);
    public virtual bool CanPickup(BasePlayer player);
    public virtual void OnPickedUp(Item createdItem, BasePlayer player);
    public virtual void ServerInit();
    public virtual void OnInventoryFirstCreated(ItemContainer container);
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual bool ItemFilter(Item item, int targetSlot);
    public void CreateInventory(bool giveUID);
    public virtual void PreServerLoad();
    protected virtual void OnInventoryDirty();
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    [IsVisible("3")]
[RPC_Server]
private void RPC_OpenLoot(RPCMessage rpc);
    public virtual string GetPanelName();
    public virtual bool CanMoveFrom(BasePlayer player, Item item);
    public virtual bool CanOpenLootPanel(BasePlayer player, string panelName);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual void AddContainers(PlayerLoot loot);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public virtual void OnKilled(HitInfo info);
    public sealed virtual void DropItems(BaseEntity initiator);
    public static void DropItems(IItemContainerEntity containerEntity, BaseEntity initiator);
    public virtual void DropBonusItems(BaseEntity initiator, ItemContainer container);
    public virtual Vector3 GetDropPosition();
    public virtual Vector3 GetDropVelocity();
    public virtual bool ShouldDropItemsIndividually();
    public virtual void Load(LoadInfo info);
    public virtual int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);
    public virtual ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier);
    public virtual bool HasSlot(Slot slot);
    public bool OccupiedCheck(BasePlayer player);
    protected bool HasAttachedStorageAdaptor();
}
public class StorageMonitor : AppIOEntity {
    public Action`2<Item, bool> _onItemAddedRemoved;
    private Action`2<Item, int> _onItemAddedToStack;
    private Action`2<Item, int> _onItemRemovedFromStack;
    private Action _resetSwitchHandler;
    private double _lastPowerOnUpdate;
    public AppEntityType Type { get; }
    public bool Value { get; public set; }
    public virtual AppEntityType get_Type();
    public virtual bool get_Value();
    public virtual void set_Value(bool value);
    internal virtual void FillEntityPayload(AppEntityPayload payload);
    public virtual void Init();
    public virtual void DestroyShared();
    private StorageContainer GetStorageContainer();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    private void OnItemAddedRemoved(Item item, bool added);
    private void OnItemAddedToStack(Item item, int amount);
    private void OnItemRemovedFromStack(Item item, int amount);
    public void OnContainerChanged();
    private void ResetSwitch();
}
[ExtensionAttribute]
public static class StreamEx : object {
    private static Byte[] StaticBuffer;
    private static StreamEx();
    [ExtensionAttribute]
public static void WriteToOtherStream(Stream self, Stream target);
}
public class StringFirecracker : TimedExplosive {
    public Rigidbody serverRigidBody;
    public Rigidbody clientMiddleBody;
    public Rigidbody[] clientParts;
    public SpringJoint serverClientJoint;
    public Transform clientFirecrackerTransform;
    public virtual void InitShared();
    public void CreatePinJoint();
}
public static class StringFormatCache : object {
    private static Dictionary`2<Key1, string> dict1;
    private static Dictionary`2<Key2, string> dict2;
    private static Dictionary`2<Key3, string> dict3;
    private static Dictionary`2<Key4, string> dict4;
    private static StringFormatCache();
    public static string Get(string format, string value1);
    public static string Get(string format, string value1, string value2);
    public static string Get(string format, string value1, string value2, string value3);
    public static string Get(string format, string value1, string value2, string value3, string value4);
}
public class StringPool : object {
    public static Dictionary`2<UInt32, string> toString;
    public static Dictionary`2<string, UInt32> toNumber;
    private static bool initialized;
    public static UInt32 closest;
    private static void Init();
    public static string Get(UInt32 i);
    public static UInt32 Get(string str);
    public static UInt32 Add(string str);
}
[DisallowMultipleComponent]
public class StripEmptyChildren : PrefabAttribute {
    protected virtual Type GetIndexedType();
}
public class StripRig : MonoBehaviour {
    public Transform root;
    public bool fromClient;
    public bool fromServer;
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void Strip(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer);
}
public class StrobeLight : IOEntity {
    public float frequency;
    public MeshRenderer lightMesh;
    public Light strobeLight;
    private float speedSlow;
    private float speedMed;
    private float speedFast;
    public float burnRate;
    public float lifeTimeSeconds;
    public static Flags Flag_Slow;
    public static Flags Flag_Med;
    public static Flags Flag_Fast;
    private int currentSpeed;
    public float GetFrequency();
    [IsVisible("3")]
[RPC_Server]
public void SetStrobe(RPCMessage msg);
    private void SetStrobe(bool wantsOn);
    [RPC_Server]
[IsVisible("3")]
public void SetStrobeSpeed(RPCMessage msg);
    public void UpdateSpeedFlags();
    public void ServerEnableStrobing(bool wantsOn);
    public void SelfDamage();
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual int ConsumptionAmount();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class SubmarineAudio : MonoBehaviour {
    [HeaderAttribute("Engine")]
[SerializeField]
private SoundDefinition engineStartSound;
    [SerializeField]
private SoundDefinition engineStopSound;
    [SerializeField]
private SoundDefinition engineStartFailSound;
    [SerializeField]
private SoundDefinition engineLoopSound;
    [SerializeField]
private AnimationCurve engineLoopPitchCurve;
    [SerializeField]
[HeaderAttribute("Water")]
private SoundDefinition underwaterLoopDef;
    [SerializeField]
private SoundDefinition underwaterMovementLoopDef;
    [SerializeField]
private BlendedSoundLoops surfaceWaterLoops;
    [SerializeField]
private float surfaceWaterSoundsMaxSpeed;
    [SerializeField]
private SoundDefinition waterEmergeSoundDef;
    [SerializeField]
private SoundDefinition waterSubmergeSoundDef;
    [SerializeField]
[HeaderAttribute("Interior")]
private SoundDefinition activeLoopDef;
    [SerializeField]
private SoundDefinition footPedalSoundDef;
    [SerializeField]
private Transform footPedalSoundPos;
    [SerializeField]
private SoundDefinition steeringWheelSoundDef;
    [SerializeField]
private Transform steeringWheelSoundPos;
    [SerializeField]
private SoundDefinition heavyDamageSparksDef;
    [SerializeField]
private Transform heavyDamageSparksPos;
    [SerializeField]
private SoundDefinition flagRaise;
    [SerializeField]
private SoundDefinition flagLower;
    [SerializeField]
private GameObject dashboardAudioPoint;
    [HeaderAttribute("Other")]
[SerializeField]
private SoundDefinition climbOrDiveLoopSound;
    [SerializeField]
private SoundDefinition torpedoFailedSound;
}
public class SubmarineDuo : BaseSubmarine {
    [SerializeField]
[HeaderAttribute("Duo Sub Seating & Controls")]
private Transform steeringWheel;
    [SerializeField]
private Transform steeringWheelLeftGrip;
    [SerializeField]
private Transform steeringWheelRightGrip;
    [SerializeField]
private Transform leftPedal;
    [SerializeField]
private Transform rightPedal;
    [SerializeField]
private Transform driverLeftFoot;
    [SerializeField]
private Transform driverRightFoot;
    [SerializeField]
private Transform mphNeedle;
    [SerializeField]
private Transform fuelNeedle;
    [SerializeField]
private Transform waterDepthNeedle;
    [SerializeField]
private Transform ammoFlag;
    [SerializeField]
private SonarSystem sonar;
    [SerializeField]
private Transform torpedoTubeHatch;
}
public class SubmarineOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
}
public class SubsurfaceProfile : ScriptableObject {
    private static SubsurfaceProfileTexture profileTexture;
    public SubsurfaceProfileData Data;
    private int id;
    public static Texture2D Texture { get; }
    public static Vector4[] TransmissionTints { get; }
    public int Id { get; public set; }
    private static SubsurfaceProfile();
    public static Texture2D get_Texture();
    public static Vector4[] get_TransmissionTints();
    public int get_Id();
    public void set_Id(int value);
    private void OnEnable();
}
public class SubsurfaceProfileData : ValueType {
    [RangeAttribute("0,1", "100")]
public float ScatterRadius;
    [ColorUsageAttribute("False", "False")]
public Color SubsurfaceColor;
    [ColorUsageAttribute("False", "False")]
public Color FalloffColor;
    [ColorUsageAttribute("False", "True")]
public Color TransmissionTint;
    public static SubsurfaceProfileData Default { get; }
    public static SubsurfaceProfileData Invalid { get; }
    public static SubsurfaceProfileData get_Default();
    public static SubsurfaceProfileData get_Invalid();
}
public class SubsurfaceProfileTexture : object {
    public static int SUBSURFACE_PROFILE_COUNT;
    public static int MAX_SUBSURFACE_PROFILES;
    public static int SUBSURFACE_RADIUS_SCALE;
    public static int SUBSURFACE_KERNEL_SIZE;
    private HashSet`1<SubsurfaceProfile> entries;
    private Texture2D texture;
    private Vector4[] transmissionTints;
    private static int KernelSize0;
    private static int KernelSize1;
    private static int KernelSize2;
    private static int KernelTotalSize;
    private static int Width;
    public Texture2D Texture { get; }
    public Vector4[] TransmissionTints { get; }
    public Texture2D get_Texture();
    public Vector4[] get_TransmissionTints();
    public void AddProfile(SubsurfaceProfile profile);
    public static Color Clamp(Color color, float min, float max);
    private void WriteKernel(Color[]& pixels, Color[]& kernel, int id, int y, SubsurfaceProfileData& data);
    private void CreateResources();
    public void ReleaseResources();
}
public class SubsurfaceScatteringParams : ValueType {
    public bool enabled;
    public bool halfResolution;
    public float radiusScale;
    public static SubsurfaceScatteringParams Default;
    private static SubsurfaceScatteringParams();
}
public class SunSettings : MonoBehaviour {
    private Light light;
    private void OnEnable();
    private void Update();
}
public class SupplyDrop : LootContainer {
    public static Flags FlagNightLight;
    private static Flags ShowParachute;
    public GameObject ParachuteRoot;
    public virtual void ServerInit();
    public void RemoveParachute();
    public void MakeLootable();
    private void OnCollisionEnter(Collision collision);
    public void CheckNightLight();
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class SupplySignal : TimedExplosive {
    public GameObjectRef smokeEffectPrefab;
    public GameObjectRef EntityToCreate;
    public GameObject smokeEffect;
    public virtual void Explode();
    public void FinishUp();
}
public class SuppressEyeMovement : StateMachineBehaviour {
}
public class SurveyCharge : TimedExplosive {
    public GameObjectRef craterPrefab;
    public GameObjectRef craterPrefab_Oil;
    public virtual void Explode();
}
public class SurveyCrater : BaseCombatEntity {
    private ResourceDispenser resourceDispenser;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void OnAttacked(HitInfo info);
    public void RemoveMe();
    [RPC_Server]
public void AnalysisComplete(RPCMessage msg);
    public virtual float BoundsPadding();
}
public class SurvivalFishTrap : WildlifeTrap {
    private WaterBody cachedWaterBody;
    private bool bypassItemFilter;
    public virtual void ServerInit();
    public virtual bool HasBait();
    public virtual void TrapThink();
    public virtual bool ItemFilter(Item item, int targetSlot);
    protected virtual bool CanAcceptItem(Item item, int slot);
}
public class SwapAmmo : MonoBehaviour {
    public AmmoSetup[] Setups;
    public bool EventDriven;
}
public class SwapAmmoParticle : MonoBehaviour {
    public ParticleSystem Target;
    public Override[] Overrides;
}
public class SwapArrows : MonoBehaviour {
    public GameObject[] arrowModels;
    private string curAmmoType;
    private bool wasHidden;
    public void SelectArrowType(int iType);
    public void HideAllArrowHeads();
    public void UpdateAmmoType(ItemDefinition ammoType, bool hidden);
    private void Cleanup();
    public void OnDisable();
    public void OnEnable();
}
public class SwapKeycard : MonoBehaviour {
    public GameObject[] accessLevels;
    public void UpdateAccessLevel(int level);
    public void SetRootActive(int index);
}
public class SwapRPG : MonoBehaviour {
    public GameObject[] rpgModels;
    private string curAmmoType;
    public void SelectRPGType(int iType);
    public void UpdateAmmoType(ItemDefinition ammoType);
    private void Start();
}
public class SwitchLODMaterials : MonoBehaviour {
    public Material[] materialSet1;
    public Material[] materialSet2;
}
public class SynchronizedClock : object {
    public List`1<TimedEvent> events;
    private static float CurrentTime { get; }
    private static float get_CurrentTime();
    public void Add(float delta, float variance, Action`1<UInt32> action);
    public void Tick();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class SystemInfoEx : object {
    private static Boolean[] supportedRenderTextureFormats;
    public static int systemMemoryUsed { get; }
    private static ulong System_GetMemoryUsage();
    public static int get_systemMemoryUsed();
    public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
}
public class SystemInfoGeneralText : MonoBehaviour {
    public TextMeshProUGUI text;
    public static string currentInfo { get; }
    public static string get_currentInfo();
    protected void Update();
    private static long MB(long bytes);
    private static long MB(ulong bytes);
    private static int KM2(float meters);
}
public class TabToggle : MonoBehaviour {
    public Transform TabHolder;
    public Transform ContentHolder;
    public bool FadeIn;
    public bool FadeOut;
    public void Awake();
    public void SwitchTo(Button sourceTab);
    private void Hide(GameObject go);
    private void Show(GameObject go);
}
public class TagComponent : MonoBehaviour {
    public GameObjectTag Tag;
    public bool HasTag(GameObjectTag tag);
    public void AddTag(GameObjectTag tag);
    public void RemoveTag(GameObjectTag tag);
    public void SetTag(GameObjectTag tag, bool state);
}
[ExtensionAttribute]
public static class TagComponentEx : object {
    private static Dictionary`2<GameObjectTag, string> strings;
    private static TagComponentEx();
    [ExtensionAttribute]
public static bool HasCustomTag(GameObject gameObject, GameObjectTag tag);
    [ExtensionAttribute]
public static bool SetCustomTag(GameObject gameObject, GameObjectTag tag, bool apply);
}
[RequireComponent("UnityEngine.Collider")]
public class TakeCollisionDamage : FacepunchBehaviour {
    [SerializeField]
private BaseCombatEntity entity;
    [SerializeField]
private float minDamage;
    [SerializeField]
private float maxDamage;
    [SerializeField]
private float forceForAnyDamage;
    [SerializeField]
private float forceForMaxDamage;
    [SerializeField]
private float velocityRestorePercent;
    private float pendingDamage;
    private bool IsServer { get; }
    private bool IsClient { get; }
    private bool get_IsServer();
    private bool get_IsClient();
    protected void OnCollisionEnter(Collision collision);
    protected void OnDestroy();
    private void DoDamage();
}
public class TargetDetectedAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class TargetDetectedEventUI : BaseEventUI {
}
public class TargetLostAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class TargetLostEventUI : BaseEventUI {
}
public class TargetTrigger : TriggerBase {
    [TooltipAttribute("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
public Transform losEyes;
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class TeamMemberElement : MonoBehaviour {
    public RustText nameText;
    public RawImage icon;
    public Color onlineColor;
    public Color offlineColor;
    public Color deadColor;
    public Color woundedColor;
    public RawImage memberIcon;
    public RawImage leaderIcon;
    public RawImage deadIcon;
    public RawImage woundedIcon;
    public int teamIndex;
    public CanvasGroup EditButton;
}
public class TeamMemberMapMarker : MonoBehaviour {
    public RectTransform rectTransform;
    public Text nameTagText;
    public Tooltip toolTip;
    public Image innerImage;
}
public class TeamUI : MonoBehaviour {
    public static Phrase invitePhrase;
    public RectTransform MemberPanel;
    public GameObject memberEntryPrefab;
    public TeamMemberElement[] elements;
    public GameObject NoTeamPanel;
    public GameObject TeamPanel;
    public GameObject LeaveTeamButton;
    public GameObject InviteAcceptPanel;
    public RustText inviteText;
    public static bool dirty;
    public static ulong pendingTeamID;
    public static string pendingTeamLeaderName;
    public GameObject teamMemberDetailsPanel;
    public RustText selectedTeamMemberNameText;
    private static TeamUI();
}
[CreateAssetMenuAttribute]
public class TechTreeData : ScriptableObject {
    public string shortname;
    public int nextID;
    public int techTreeLevel;
    public SoundDefinition openSound;
    public SoundDefinition closeSound;
    private Dictionary`2<int, NodeInstance> _idToNode;
    private NodeInstance _entryNode;
    public List`1<NodeInstance> nodes;
    public NodeInstance GetByID(int id);
    public NodeInstance GetEntryNode();
    public void ClearInputs(NodeInstance node);
    public void SetupInputs(NodeInstance node);
    public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node);
    public bool CheckChainRecursive(BasePlayer player, NodeInstance start, NodeInstance target);
    public bool PlayerCanUnlock(BasePlayer player, NodeInstance node);
    public bool HasPlayerUnlocked(BasePlayer player, NodeInstance node);
    public void GetNodesRequiredToUnlock(BasePlayer player, NodeInstance node, List`1<NodeInstance> foundNodes);
}
public class TechTreeDialog : UIDialog {
    private static string techTreeLevelPrefKey;
    private TechTreeData[] dataOptions;
    public float graphScale;
    public RustButton[] tierButtons;
    public GameObjectRef entryPrefab;
    public GameObjectRef groupPrefab;
    public GameObjectRef linePrefab;
    public RectTransform contents;
    public RectTransform contentParent;
    public TechTreeSelectedNodeUI selectedNodeUI;
    public float nodeSize;
    public float gridSize;
    public GameObjectRef unlockEffect;
    public RustText scrapCount;
    private Vector2 startPos;
    public ScrollRectZoom zoom;
    public TechTreeData data { get; }
    private int selectedDataIndex { get; private set; }
    public TechTreeData get_data();
    private int get_selectedDataIndex();
    private void set_selectedDataIndex(int value);
}
public class TechTreeEntry : TechTreeWidget {
    public RawImage icon;
    public GameObject ableToUnlockBackground;
    public GameObject unlockedBackground;
    public GameObject lockedBackground;
    public GameObject lockOverlay;
    public GameObject selectedBackground;
    public Image radialUnlock;
    public float holdTime;
}
public class TechTreeGroup : TechTreeWidget {
}
public class TechTreeLine : TechTreeWidget {
    public RawImage center;
    public RawImage topLeft;
    public RawImage topRight;
    public RawImage bottomLeft;
    public RawImage bottomRight;
    public RawImage centerDotted;
    public RawImage topLeftDotted;
    public RawImage topRightDotted;
    public RawImage bottomLeftDotted;
    public RawImage bottomRightDotted;
    public int from;
    public int to;
}
public class TechTreeSelectedNodeUI : MonoBehaviour {
    public RustText selectedTitle;
    public RawImage selectedIcon;
    public RustText selectedDescription;
    public RustText costText;
    public RustText craftingCostText;
    public GameObject costObject;
    public GameObject cantAffordObject;
    public GameObject unlockedObject;
    public GameObject unlockButton;
    public GameObject noPathObject;
    public TechTreeDialog dialog;
    public Color ColorAfford;
    public Color ColorCantAfford;
    public GameObject totalRequiredRoot;
    public RustText totalRequiredText;
    public ItemInformationPanel[] informationPanels;
    public GameObject workbenchTaxRoot;
    public RustText workbenchTaxText;
    public Tooltip workbenchTaxTooltip;
}
public class TechTreeWidget : BaseMonoBehaviour {
    public int id;
    public RectTransform rectTransform { get; }
    public RectTransform get_rectTransform();
}
public class Telephone : ContainerIOEntity {
    public static int MaxPhoneNameLength;
    public static int MaxSavedNumbers;
    public Transform PhoneHotspot;
    public Transform AnsweringMachineHotspot;
    public Transform[] HandsetRoots;
    public ItemDefinition[] ValidCassettes;
    public Transform ParentedHandsetTransform;
    public LineRenderer CableLineRenderer;
    public Transform CableStartPoint;
    public Transform CableEndPoint;
    public float LineDroopAmount;
    [CompilerGeneratedAttribute]
private Cassette <cachedCassette>k__BackingField;
    public PhoneController Controller;
    public Cassette cachedCassette { get; private set; }
    public BaseEntity ToBaseEntity { get; }
    public UInt32 AnsweringMessageId { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [CompilerGeneratedAttribute]
public Cassette get_cachedCassette();
    [CompilerGeneratedAttribute]
private void set_cachedCassette(Cassette value);
    public virtual void Load(LoadInfo info);
    public virtual bool CanPickup(BasePlayer player);
    public sealed virtual BaseEntity get_ToBaseEntity();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public UInt32 get_AnsweringMessageId();
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    [RPC_Server]
[MaxDistance("9")]
public void ClearCurrentUser(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void SetCurrentUser(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void InitiateCall(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void AnswerPhone(RPCMessage msg);
    [RPC_Server]
private void ServerHangUp(RPCMessage msg);
    public sealed virtual void OnCassetteInserted(Cassette c);
    public sealed virtual void OnCassetteRemoved(Cassette c);
    private bool CanAcceptItem(Item item, int targetSlot);
    public virtual void DestroyShared();
    [MaxDistance("3")]
[RPC_Server]
[CallsPerSecond("5")]
public void UpdatePhoneName(RPCMessage msg);
    [MaxDistance("3")]
[CallsPerSecond("5")]
[RPC_Server]
public void Server_RequestPhoneDirectory(RPCMessage msg);
    [CallsPerSecond("5")]
[MaxDistance("3")]
[RPC_Server]
public void Server_AddSavedNumber(RPCMessage msg);
    [CallsPerSecond("5")]
[MaxDistance("3")]
[RPC_Server]
public void Server_RemoveSavedNumber(RPCMessage msg);
    [CallsPerSecond("5")]
[RPC_Server]
public void ServerSendVoicemail(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
[CallsPerSecond("5")]
public void ServerPlayVoicemail(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
[CallsPerSecond("5")]
public void ServerStopVoicemail(RPCMessage msg);
    [CallsPerSecond("5")]
[RPC_Server]
[IsVisible("3")]
public void ServerDeleteVoicemail(RPCMessage msg);
    public virtual int GetPassthroughAmount(int outputSlot);
}
public static class TelephoneManager : object {
    public static int MaxPhoneNumber;
    public static int MinPhoneNumber;
    [ServerVar]
public static int MaxConcurrentCalls;
    [ServerVar]
public static int MaxCallLength;
    public static Dictionary`2<int, PhoneController> allTelephones;
    public static int maxAssignedPhoneNumber;
    private static TelephoneManager();
    public static int GetUnusedTelephoneNumber();
    public static void RegisterTelephone(PhoneController t, bool checkPhoneNumber);
    public static void DeregisterTelephone(PhoneController t);
    public static PhoneController GetTelephone(int number);
    public static PhoneController GetRandomTelephone(int ignoreNumber);
    public static int GetCurrentActiveCalls();
    public static void GetPhoneDirectory(int ignoreNumber, int page, int perPage, PhoneDirectory directory);
    [ServerVar]
public static void PrintAllPhones(Arg arg);
}
public class TennisArcadeGame : BaseArcadeGame {
    public ArcadeEntity paddle1;
    public ArcadeEntity paddle2;
    public ArcadeEntity ball;
    public Transform paddle1Origin;
    public Transform paddle2Origin;
    public Transform paddle1Goal;
    public Transform paddle2Goal;
    public Transform ballSpawn;
    public float maxScore;
    public ArcadeEntity[] paddle1ScoreNodes;
    public ArcadeEntity[] paddle2ScoreNodes;
    public int paddle1Score;
    public int paddle2Score;
    public float sensitivity;
    public ArcadeEntity logo;
    public bool OnMainMenu;
    public bool GameActive;
}
public class TennisBall : SpriteArcadeEntity {
    public float speed;
    public float maxSpeed;
}
public class TerrainAlphaMap : TerrainMap`1<byte> {
    [FormerlySerializedAsAttribute("ColorTexture")]
public Texture2D AlphaTexture;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public float GetAlpha(Vector3 worldPos);
    public float GetAlpha(float normX, float normZ);
    public float GetAlpha(int x, int z);
    public void SetAlpha(Vector3 worldPos, float a);
    public void SetAlpha(float normX, float normZ, float a);
    public void SetAlpha(int x, int z, float a);
    public void SetAlpha(int x, int z, float a, float opacity);
    public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade);
    public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade);
}
public class TerrainAnchor : PrefabAttribute {
    public float Extents;
    public float Offset;
    public float Radius;
    public float SlopeScale;
    public void Apply(Single& height, Single& min, Single& max, Vector3 pos, Vector3 scale, Quaternion rotation);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class TerrainAnchorEx : object {
    [ExtensionAttribute]
public static bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, SpawnFilter filter);
    [ExtensionAttribute]
public static bool ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors, Vector3& pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter);
    [ExtensionAttribute]
public static void ApplyTerrainAnchors(Transform transform, TerrainAnchor[] anchors);
}
public class TerrainAnchorGenerator : MonoBehaviour {
    public float PlacementRadius;
    public float PlacementPadding;
    public float PlacementFade;
    public float PlacementDistance;
    public float AnchorExtentsMin;
    public float AnchorExtentsMax;
    public float AnchorOffsetMin;
    public float AnchorOffsetMax;
}
public enum TerrainAnchorMode : Enum {
    public int value__;
    public static TerrainAnchorMode MinimizeError;
    public static TerrainAnchorMode MinimizeMovement;
    public static TerrainAnchorMode MaximizeHeight;
}
[CreateAssetMenuAttribute]
public class TerrainAtlasSet : ScriptableObject {
    public static int SplatCount;
    public static int SplatSize;
    public static int MaxSplatSize;
    public static int SplatPadding;
    public static int AtlasSize;
    public static int RegionSize;
    public static int SplatsPerLine;
    public static int SourceTypeCount;
    public static int AtlasMipCount;
    public static String[] sourceTypeNames;
    public static String[] sourceTypeNamesExt;
    public static String[] sourceTypePostfix;
    public String[] splatNames;
    public Boolean[] albedoHighpass;
    public String[] albedoPaths;
    public Color[] defaultValues;
    public SourceMapSet[] sourceMaps;
    public bool highQualityCompression;
    public bool generateTextureAtlases;
    public bool generateTextureArrays;
    public string splatSearchPrefix;
    public string splatSearchFolder;
    public string albedoAtlasSavePath;
    public string normalAtlasSavePath;
    public string albedoArraySavePath;
    public string normalArraySavePath;
    private static TerrainAtlasSet();
    public void CheckReset();
}
public class TerrainBenchmarkScene : BenchmarkScene {
    public Terrain terrain;
    private TerrainMeta terrainMeta;
    public Transform viewpointA;
    public Transform viewpointB;
}
public class TerrainBiomeMap : TerrainMap`1<byte> {
    public Texture2D BiomeTexture;
    internal int num;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public float GetBiomeMax(Vector3 worldPos, int mask);
    public float GetBiomeMax(float normX, float normZ, int mask);
    public float GetBiomeMax(int x, int z, int mask);
    public int GetBiomeMaxIndex(Vector3 worldPos, int mask);
    public int GetBiomeMaxIndex(float normX, float normZ, int mask);
    public int GetBiomeMaxIndex(int x, int z, int mask);
    public int GetBiomeMaxType(Vector3 worldPos, int mask);
    public int GetBiomeMaxType(float normX, float normZ, int mask);
    public int GetBiomeMaxType(int x, int z, int mask);
    public float GetBiome(Vector3 worldPos, int mask);
    public float GetBiome(float normX, float normZ, int mask);
    public float GetBiome(int x, int z, int mask);
    public void SetBiome(Vector3 worldPos, int id);
    public void SetBiome(float normX, float normZ, int id);
    public void SetBiome(int x, int z, int id);
    public void SetBiome(Vector3 worldPos, int id, float v);
    public void SetBiome(float normX, float normZ, int id, float v);
    public void SetBiome(int x, int z, int id, float v);
    public void SetBiomeRaw(int x, int z, Vector4 v, float opacity);
    private void SetBiome(int x, int z, int id, float old_val, float new_val);
}
public class TerrainBlendMap : TerrainMap`1<byte> {
    public Texture2D BlendTexture;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public float GetAlpha(Vector3 worldPos);
    public float GetAlpha(float normX, float normZ);
    public float GetAlpha(int x, int z);
    public void SetAlpha(Vector3 worldPos, float a);
    public void SetAlpha(float normX, float normZ, float a);
    public void SetAlpha(int x, int z, float a);
    public void SetAlpha(int x, int z, float a, float opacity);
    public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade);
    public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade);
}
public class TerrainCarve : TerrainModifier {
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public class TerrainCheck : PrefabAttribute {
    public bool Rotate;
    public float Extents;
    public bool Check(Vector3 pos);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class TerrainCheckEx : object {
    [ExtensionAttribute]
public static bool ApplyTerrainChecks(Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter);
}
public class TerrainCheckGenerator : MonoBehaviour {
    public float PlacementRadius;
    public float PlacementPadding;
    public float PlacementFade;
    public float PlacementDistance;
    public float CheckExtentsMin;
    public float CheckExtentsMax;
    public bool CheckRotate;
}
public class TerrainCheckGeneratorVolumes : MonoBehaviour {
    public float PlacementRadius;
    public float PlacementOffset;
    protected void OnDrawGizmosSelected();
}
public class TerrainCollision : TerrainExtension {
    public ListDictionary`2<Collider, List`1<Collider>> ignoredColliders;
    public TerrainCollider terrainCollider;
    public virtual void Setup();
    public void Clear();
    public void Reset(Collider collider);
    public bool GetIgnore(Vector3 pos, float radius);
    public bool GetIgnore(RaycastHit hit);
    public bool GetIgnore(Collider collider);
    public void SetIgnore(Collider collider, Collider trigger, bool ignore);
    protected void LateUpdate();
}
public class TerrainCollisionProxy : MonoBehaviour {
    public WheelCollider[] colliders;
}
public class TerrainCollisionTrigger : EnvironmentVolumeTrigger {
    protected void OnTriggerEnter(Collider other);
    protected void OnTriggerExit(Collider other);
    private void UpdateCollider(Collider other, bool state);
}
public class TerrainColors : TerrainExtension {
    private TerrainSplatMap splatMap;
    private TerrainBiomeMap biomeMap;
    public virtual void Setup();
    public Color GetColor(Vector3 worldPos, int mask);
    public Color GetColor(float normX, float normZ, int mask);
}
[CreateAssetMenuAttribute]
public class TerrainConfig : ScriptableObject {
    public bool CastShadows;
    public LayerMask GroundMask;
    public LayerMask WaterMask;
    public PhysicMaterial GenericMaterial;
    public PhysicMaterial WaterMaterial;
    public Material Material;
    public Material MarginMaterial;
    public Texture[] AlbedoArrays;
    public Texture[] NormalArrays;
    public float HeightMapErrorMin;
    public float HeightMapErrorMax;
    public float BaseMapDistanceMin;
    public float BaseMapDistanceMax;
    public float ShaderLodMin;
    public float ShaderLodMax;
    public SplatType[] Splats;
    private string snowMatName;
    private string grassMatName;
    private string sandMatName;
    private List`1<string> dirtMatNames;
    private List`1<string> stoneyMatNames;
    public Texture AlbedoArray { get; }
    public Texture NormalArray { get; }
    public Texture get_AlbedoArray();
    public Texture get_NormalArray();
    public PhysicMaterial[] GetPhysicMaterials();
    public Color[] GetAridColors();
    public void GetAridOverlayConstants(Color[]& color, Vector4[]& param);
    public Color[] GetTemperateColors();
    public void GetTemperateOverlayConstants(Color[]& color, Vector4[]& param);
    public Color[] GetTundraColors();
    public void GetTundraOverlayConstants(Color[]& color, Vector4[]& param);
    public Color[] GetArcticColors();
    public void GetArcticOverlayConstants(Color[]& color, Vector4[]& param);
    public Single[] GetSplatTiling();
    public float GetMaxSplatTiling();
    public float GetMinSplatTiling();
    public Vector3[] GetPackedUVMIX();
    public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit);
}
public class TerrainDistanceMap : TerrainMap`1<byte> {
    public Texture2D DistanceTexture;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public Vector2i GetDistance(Vector3 worldPos);
    public Vector2i GetDistance(float normX, float normZ);
    public Vector2i GetDistance(int x, int z);
    public void SetDistance(int x, int z, Vector2i v);
}
[RequireComponent("TerrainMeta")]
public abstract class TerrainExtension : MonoBehaviour {
    public bool isInitialized;
    internal Terrain terrain;
    internal TerrainConfig config;
    public void Init(Terrain terrain, TerrainConfig config);
    public virtual void Setup();
    public virtual void PostSetup();
    public void LogSize(object obj, ulong size);
}
public class TerrainFilter : PrefabAttribute {
    public SpawnFilter Filter;
    public bool CheckPlacementMap;
    public bool CheckTerrainBounds;
    public float CheckTopologyRadius;
    public bool Check(Vector3 pos);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class TerrainFilterEx : object {
    [ExtensionAttribute]
public static bool ApplyTerrainFilters(Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter);
}
public class TerrainFilterGenerator : MonoBehaviour {
    public float PlacementRadius;
    public float PlacementDistance;
    public SpawnFilter Filter;
    public bool CheckPlacementMap;
}
public class TerrainGenerator : SingletonComponent`1<TerrainGenerator> {
    public TerrainConfig config;
    private static float HeightMapRes;
    private static float SplatMapRes;
    private static float BaseMapRes;
    public static int GetHeightMapRes();
    public static int GetSplatMapRes();
    public static int GetBaseMapRes();
    public GameObject CreateTerrain();
    public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution);
}
public class TerrainHeightAdd : TerrainModifier {
    public float Delta;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public class TerrainHeightMap : TerrainMap`1<short> {
    public Texture2D HeightTexture;
    public Texture2D NormalTexture;
    private float normY;
    public virtual void Setup();
    public void ApplyToTerrain();
    public void GenerateTextures(bool heightTexture, bool normalTexture);
    public void ApplyTextures();
    public float GetHeight(Vector3 worldPos);
    public float GetHeight(float normX, float normZ);
    public float GetHeightFast(Vector2 uv);
    public float GetHeight(int x, int z);
    public float GetHeight01(Vector3 worldPos);
    public float GetHeight01(float normX, float normZ);
    public float GetTriangulatedHeight01(float normX, float normZ);
    public float GetHeight01(int x, int z);
    private float GetSrcHeight01(int x, int z);
    private float GetDstHeight01(int x, int z);
    public Vector3 GetNormal(Vector3 worldPos);
    public Vector3 GetNormal(float normX, float normZ);
    public Vector3 GetNormal(int x, int z);
    private Vector3 GetNormalSobel(int x, int z);
    public float GetSlope(Vector3 worldPos);
    public float GetSlope(float normX, float normZ);
    public float GetSlope(int x, int z);
    public float GetSlope01(Vector3 worldPos);
    public float GetSlope01(float normX, float normZ);
    public float GetSlope01(int x, int z);
    public void SetHeight(Vector3 worldPos, float height);
    public void SetHeight(float normX, float normZ, float height);
    public void SetHeight(int x, int z, float height);
    public void SetHeight(Vector3 worldPos, float height, float opacity);
    public void SetHeight(float normX, float normZ, float height, float opacity);
    public void SetHeight(int x, int z, float height, float opacity);
    public void AddHeight(Vector3 worldPos, float delta);
    public void AddHeight(float normX, float normZ, float delta);
    public void AddHeight(int x, int z, float delta);
    public void LowerHeight(Vector3 worldPos, float height, float opacity);
    public void LowerHeight(float normX, float normZ, float height, float opacity);
    public void LowerHeight(int x, int z, float height, float opacity);
    public void RaiseHeight(Vector3 worldPos, float height, float opacity);
    public void RaiseHeight(float normX, float normZ, float height, float opacity);
    public void RaiseHeight(int x, int z, float height, float opacity);
    public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade);
    public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade);
    public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade);
    public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade);
    public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade);
    public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade);
    public void AddHeight(Vector3 worldPos, float delta, float radius, float fade);
    public void AddHeight(float normX, float normZ, float delta, float radius, float fade);
}
public class TerrainHeightSet : TerrainModifier {
    public Mode HeightMode;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public abstract class TerrainMap : TerrainExtension {
    internal int res;
    public void ApplyFilter(float normX, float normZ, float radius, float fade, Action`3<int, int, float> action);
    public void ForEach(Vector3 worldPos, float radius, Action`2<int, int> action);
    public void ForEach(float normX, float normZ, float normRadius, Action`2<int, int> action);
    public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action);
    public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action);
    public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action`2<int, int> action);
    public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action);
    private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action`2<int, int> action, Vector2i min, Vector2i max);
    public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action);
    public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action);
    public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action`2<int, int> action);
    public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action);
    private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action`2<int, int> action, Vector2i min, Vector2i max);
    public void ForEach(int x_min, int x_max, int z_min, int z_max, Action`2<int, int> action);
    public void ForEach(Action`2<int, int> action);
    public int Index(float normalized);
    public float Coordinate(int index);
}
public abstract class TerrainMap`1 : TerrainMap {
    internal T[] src;
    internal T[] dst;
    public void Push();
    public void Pop();
    public IEnumerable`1<T> ToEnumerable();
    public int BytesPerElement();
    public long GetMemoryUsage();
    public Byte[] ToByteArray();
    public void FromByteArray(Byte[] dat);
}
public class TerrainMargin : object {
    private static MaterialPropertyBlock materialPropertyBlock;
    public static void Create();
    private static void Create(Vector3 position, Vector3 size, Material material);
}
[ExecuteInEditMode]
public class TerrainMeta : MonoBehaviour {
    public Terrain terrain;
    public TerrainConfig config;
    public PaintMode paint;
    [HideInInspector]
public PaintMode currentPaintMode;
    [CompilerGeneratedAttribute]
private static TerrainConfig <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private static Terrain <Terrain>k__BackingField;
    [CompilerGeneratedAttribute]
private static Transform <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private static Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private static Vector3 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private static Vector3 <OneOverSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static Vector3 <HighestPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private static Vector3 <LowestPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private static float <LootAxisAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private static float <BiomeAxisAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainCollider <Collider>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainCollision <Collision>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainPhysics <Physics>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainColors <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainQuality <Quality>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainBiomeMap <BiomeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainAlphaMap <AlphaMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainBlendMap <BlendMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainHeightMap <HeightMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainSplatMap <SplatMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainTopologyMap <TopologyMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainWaterMap <WaterMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainDistanceMap <DistanceMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainPlacementMap <PlacementMap>k__BackingField;
    [CompilerGeneratedAttribute]
private static TerrainTexturing <Texturing>k__BackingField;
    public static TerrainConfig Config { get; private set; }
    public static Terrain Terrain { get; private set; }
    public static Transform Transform { get; private set; }
    public static Vector3 Position { get; private set; }
    public static Vector3 Size { get; private set; }
    public static Vector3 Center { get; }
    public static Vector3 OneOverSize { get; private set; }
    public static Vector3 HighestPoint { get; public set; }
    public static Vector3 LowestPoint { get; public set; }
    public static float LootAxisAngle { get; private set; }
    public static float BiomeAxisAngle { get; private set; }
    public static TerrainData Data { get; private set; }
    public static TerrainCollider Collider { get; private set; }
    public static TerrainCollision Collision { get; private set; }
    public static TerrainPhysics Physics { get; private set; }
    public static TerrainColors Colors { get; private set; }
    public static TerrainQuality Quality { get; private set; }
    public static TerrainPath Path { get; private set; }
    public static TerrainBiomeMap BiomeMap { get; private set; }
    public static TerrainAlphaMap AlphaMap { get; private set; }
    public static TerrainBlendMap BlendMap { get; private set; }
    public static TerrainHeightMap HeightMap { get; private set; }
    public static TerrainSplatMap SplatMap { get; private set; }
    public static TerrainTopologyMap TopologyMap { get; private set; }
    public static TerrainWaterMap WaterMap { get; private set; }
    public static TerrainDistanceMap DistanceMap { get; private set; }
    public static TerrainPlacementMap PlacementMap { get; private set; }
    public static TerrainTexturing Texturing { get; private set; }
    [CompilerGeneratedAttribute]
public static TerrainConfig get_Config();
    [CompilerGeneratedAttribute]
private static void set_Config(TerrainConfig value);
    [CompilerGeneratedAttribute]
public static Terrain get_Terrain();
    [CompilerGeneratedAttribute]
private static void set_Terrain(Terrain value);
    [CompilerGeneratedAttribute]
public static Transform get_Transform();
    [CompilerGeneratedAttribute]
private static void set_Transform(Transform value);
    [CompilerGeneratedAttribute]
public static Vector3 get_Position();
    [CompilerGeneratedAttribute]
private static void set_Position(Vector3 value);
    [CompilerGeneratedAttribute]
public static Vector3 get_Size();
    [CompilerGeneratedAttribute]
private static void set_Size(Vector3 value);
    public static Vector3 get_Center();
    [CompilerGeneratedAttribute]
public static Vector3 get_OneOverSize();
    [CompilerGeneratedAttribute]
private static void set_OneOverSize(Vector3 value);
    [CompilerGeneratedAttribute]
public static Vector3 get_HighestPoint();
    [CompilerGeneratedAttribute]
public static void set_HighestPoint(Vector3 value);
    [CompilerGeneratedAttribute]
public static Vector3 get_LowestPoint();
    [CompilerGeneratedAttribute]
public static void set_LowestPoint(Vector3 value);
    [CompilerGeneratedAttribute]
public static float get_LootAxisAngle();
    [CompilerGeneratedAttribute]
private static void set_LootAxisAngle(float value);
    [CompilerGeneratedAttribute]
public static float get_BiomeAxisAngle();
    [CompilerGeneratedAttribute]
private static void set_BiomeAxisAngle(float value);
    [CompilerGeneratedAttribute]
public static TerrainData get_Data();
    [CompilerGeneratedAttribute]
private static void set_Data(TerrainData value);
    [CompilerGeneratedAttribute]
public static TerrainCollider get_Collider();
    [CompilerGeneratedAttribute]
private static void set_Collider(TerrainCollider value);
    [CompilerGeneratedAttribute]
public static TerrainCollision get_Collision();
    [CompilerGeneratedAttribute]
private static void set_Collision(TerrainCollision value);
    [CompilerGeneratedAttribute]
public static TerrainPhysics get_Physics();
    [CompilerGeneratedAttribute]
private static void set_Physics(TerrainPhysics value);
    [CompilerGeneratedAttribute]
public static TerrainColors get_Colors();
    [CompilerGeneratedAttribute]
private static void set_Colors(TerrainColors value);
    [CompilerGeneratedAttribute]
public static TerrainQuality get_Quality();
    [CompilerGeneratedAttribute]
private static void set_Quality(TerrainQuality value);
    [CompilerGeneratedAttribute]
public static TerrainPath get_Path();
    [CompilerGeneratedAttribute]
private static void set_Path(TerrainPath value);
    [CompilerGeneratedAttribute]
public static TerrainBiomeMap get_BiomeMap();
    [CompilerGeneratedAttribute]
private static void set_BiomeMap(TerrainBiomeMap value);
    [CompilerGeneratedAttribute]
public static TerrainAlphaMap get_AlphaMap();
    [CompilerGeneratedAttribute]
private static void set_AlphaMap(TerrainAlphaMap value);
    [CompilerGeneratedAttribute]
public static TerrainBlendMap get_BlendMap();
    [CompilerGeneratedAttribute]
private static void set_BlendMap(TerrainBlendMap value);
    [CompilerGeneratedAttribute]
public static TerrainHeightMap get_HeightMap();
    [CompilerGeneratedAttribute]
private static void set_HeightMap(TerrainHeightMap value);
    [CompilerGeneratedAttribute]
public static TerrainSplatMap get_SplatMap();
    [CompilerGeneratedAttribute]
private static void set_SplatMap(TerrainSplatMap value);
    [CompilerGeneratedAttribute]
public static TerrainTopologyMap get_TopologyMap();
    [CompilerGeneratedAttribute]
private static void set_TopologyMap(TerrainTopologyMap value);
    [CompilerGeneratedAttribute]
public static TerrainWaterMap get_WaterMap();
    [CompilerGeneratedAttribute]
private static void set_WaterMap(TerrainWaterMap value);
    [CompilerGeneratedAttribute]
public static TerrainDistanceMap get_DistanceMap();
    [CompilerGeneratedAttribute]
private static void set_DistanceMap(TerrainDistanceMap value);
    [CompilerGeneratedAttribute]
public static TerrainPlacementMap get_PlacementMap();
    [CompilerGeneratedAttribute]
private static void set_PlacementMap(TerrainPlacementMap value);
    [CompilerGeneratedAttribute]
public static TerrainTexturing get_Texturing();
    [CompilerGeneratedAttribute]
private static void set_Texturing(TerrainTexturing value);
    public static bool OutOfBounds(Vector3 worldPos);
    public static bool OutOfMargin(Vector3 worldPos);
    public static bool OutOfMarginPlusTutorialBounds(Vector3 worldPos);
    public static float InnerDistToEdge2D(Vector3 worldPos);
    public static bool IsPointWithinTutorialBounds(Vector3 worldPos);
    public static bool RandomWaterPointInAnnulus(Vector3 centre, float minRadius, float maxRadius, Vector3& randomPoint);
    public static Vector3 RandomPointOffshore();
    public static Vector3 Normalize(Vector3 worldPos);
    public static float NormalizeX(float x);
    public static float NormalizeY(float y);
    public static float NormalizeZ(float z);
    public static Vector3 Denormalize(Vector3 normPos);
    public static float DenormalizeX(float normX);
    public static float DenormalizeY(float normY);
    public static float DenormalizeZ(float normZ);
    protected void Awake();
    public void Init(Terrain terrainOverride, TerrainConfig configOverride);
    public static void InitNoTerrain(bool createPath);
    public void SetupComponents();
    public void PostSetupComponents();
    public void BindShaderProperties();
}
public abstract class TerrainModifier : PrefabAttribute {
    public float Opacity;
    public float Radius;
    public float Fade;
    public void Apply(Vector3 pos, float scale);
    protected abstract virtual void Apply(Vector3 position, float opacity, float radius, float fade);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class TerrainModifierEx : object {
    [ExtensionAttribute]
public static void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale);
    [ExtensionAttribute]
public static void ApplyTerrainModifiers(Transform transform, TerrainModifier[] modifiers);
}
[ExecuteInEditMode]
public class TerrainPaint : MonoBehaviour {
}
public class TerrainPath : TerrainExtension {
    public List`1<PathList> Roads;
    public List`1<PathList> MainRoads;
    public List`1<PathList> SideRoads;
    public List`1<PathList> TrailRoads;
    public List`1<PathList> Rails;
    public List`1<PathList> Rivers;
    public List`1<PathList> Powerlines;
    public List`1<LandmarkInfo> Landmarks;
    public List`1<MonumentInfo> Monuments;
    public List`1<RiverInfo> RiverObjs;
    public List`1<LakeInfo> LakeObjs;
    public GameObject DungeonGridRoot;
    public List`1<DungeonGridInfo> DungeonGridEntrances;
    public List`1<DungeonGridCell> DungeonGridCells;
    public GameObject DungeonBaseRoot;
    public List`1<DungeonBaseInfo> DungeonBaseEntrances;
    public List`1<DungeonBaseLink> DungeonBaseLinks;
    public List`1<Vector3> OceanPatrolClose;
    public List`1<Vector3> OceanPatrolFar;
    public Dictionary`2<string, List`1<PowerlineNode>> wires;
    public virtual void PostSetup();
    public void Clear();
    public T FindClosest(List`1<T> list, Vector3 pos);
    public static Int32[0...,0...] CreatePowerlineCostmap(UInt32& seed);
    public static Int32[0...,0...] CreateRoadCostmap(UInt32& seed, bool trail);
    public static Int32[0...,0...] CreateRailCostmap(UInt32& seed);
    public static Int32[0...,0...] CreateBoatCostmap(float depth);
    public void AddWire(PowerlineNode node);
    public void CreateWires();
    private void CreateWire(string name, List`1<GameObject> objects, GameObjectRef wirePrefab);
    public MonumentInfo FindMonumentWithBoundsOverlap(Vector3 position, MonumentType[] types);
    public void AddRoad(List`1<PathList> newRoadList, bool addToMaster);
    public void AddRoad(PathList newRoad, bool addToMaster);
}
public class TerrainPathChildObjects : MonoBehaviour {
    public bool Spline;
    public float Width;
    public float Offset;
    public float Fade;
    [InspectorFlagsAttribute]
public Enum Splat;
    [InspectorFlagsAttribute]
public Enum Topology;
    public InfrastructureType Type;
    protected void Awake();
    protected void OnDrawGizmos();
}
public class TerrainPathConnect : MonoBehaviour {
    public InfrastructureType Type;
    public Point GetPathFinderPoint(int res);
}
public class TerrainPhysics : TerrainExtension {
    private TerrainSplatMap splat;
    private PhysicMaterial[] materials;
    public virtual void Setup();
    public PhysicMaterial GetMaterial(Vector3 worldPos);
}
public abstract class TerrainPlacement : PrefabAttribute {
    [ReadOnlyAttribute]
public Vector3 size;
    [ReadOnlyAttribute]
public Vector3 extents;
    [ReadOnlyAttribute]
public Vector3 offset;
    public bool HeightMap;
    public bool AlphaMap;
    public bool WaterMap;
    [InspectorFlagsAttribute]
public Enum SplatMask;
    [InspectorFlagsAttribute]
public Enum BiomeMask;
    [InspectorFlagsAttribute]
public Enum TopologyMask;
    [HideInInspector]
public Texture2DRef heightmap;
    [HideInInspector]
public Texture2DRef splatmap0;
    [HideInInspector]
public Texture2DRef splatmap1;
    [HideInInspector]
public Texture2DRef alphamap;
    [HideInInspector]
public Texture2DRef biomemap;
    [HideInInspector]
public Texture2DRef topologymap;
    [HideInInspector]
public Texture2DRef watermap;
    [HideInInspector]
public Texture2DRef blendmap;
    public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected bool ShouldHeight();
    protected bool ShouldSplat(int id);
    protected bool ShouldAlpha();
    protected bool ShouldBiome(int id);
    protected bool ShouldTopology(int id);
    protected bool ShouldWater();
    protected abstract virtual void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected abstract virtual void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected abstract virtual void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected abstract virtual void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected abstract virtual void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected abstract virtual void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);
    protected virtual Type GetIndexedType();
}
public class TerrainPlacementBlocked : TerrainModifier {
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
[ExtensionAttribute]
public static class TerrainPlacementEx : object {
    [ExtensionAttribute]
public static void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale);
    [ExtensionAttribute]
public static void ApplyTerrainPlacements(Transform transform, TerrainPlacement[] placements);
}
public class TerrainPlacementMap : TerrainMap`1<bool> {
    private bool isEnabled;
    public virtual void Setup();
    public virtual void PostSetup();
    public void Enable();
    public void Disable();
    public void Reset();
    public bool GetBlocked(Vector3 worldPos);
    public bool GetBlocked(float normX, float normZ);
    public bool GetBlocked(int x, int z);
    public void SetBlocked(Vector3 worldPos);
    public void SetBlocked(float normX, float normZ);
    public void SetBlocked(int x, int z);
    public bool GetBlocked(Vector3 worldPos, float radius);
    public bool GetBlocked(float normX, float normZ, float radius);
    public void SetBlocked(Vector3 worldPos, float radius, float fade);
    public void SetBlocked(float normX, float normZ, float radius, float fade);
    [CompilerGeneratedAttribute]
private void <SetBlocked>b__15_0(int x, int z, float lerp);
}
public class TerrainQuality : TerrainExtension {
}
public class TerrainSplatMap : TerrainMap`1<byte> {
    public Texture2D SplatTexture0;
    public Texture2D SplatTexture1;
    internal int num;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public float GetSplatMax(Vector3 worldPos, int mask);
    public float GetSplatMax(float normX, float normZ, int mask);
    public float GetSplatMax(int x, int z, int mask);
    public int GetSplatMaxIndex(Vector3 worldPos, int mask);
    public int GetSplatMaxIndex(float normX, float normZ, int mask);
    public int GetSplatMaxIndex(int x, int z, int mask);
    public int GetSplatMaxType(Vector3 worldPos, int mask);
    public int GetSplatMaxType(float normX, float normZ, int mask);
    public int GetSplatMaxType(int x, int z, int mask);
    public float GetSplat(Vector3 worldPos, int mask);
    public float GetSplat(float normX, float normZ, int mask);
    public float GetSplat(int x, int z, int mask);
    public void SetSplat(Vector3 worldPos, int id);
    public void SetSplat(float normX, float normZ, int id);
    public void SetSplat(int x, int z, int id);
    public void SetSplat(Vector3 worldPos, int id, float v);
    public void SetSplat(float normX, float normZ, int id, float v);
    public void SetSplat(int x, int z, int id, float v);
    public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity);
    public void AddSplat(Vector3 worldPos, int id, float d);
    public void AddSplat(float normX, float normZ, int id, float d);
    public void AddSplat(int x, int z, int id, float d);
    public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade);
    public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade);
    public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade);
    public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade);
    public void RemoveSplat(Vector3 worldPos, int id, float opacity, float radius, float fade);
    public void RemoveSplat(float normX, float normZ, int id, float opacity, float radius, float fade);
    private void SetSplat(int x, int z, int id, float old_val, float new_val);
}
public class TerrainSplatRemove : TerrainModifier {
    public Enum SplatType;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public class TerrainSplatSet : TerrainModifier {
    public Enum SplatType;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
[ExecuteInEditMode]
public class TerrainTexturing : TerrainExtension {
    public bool debugFoliageDisplacement;
    private bool initialized;
    private static TerrainTexturing instance;
    private static int ShoreVectorDownscale;
    private static int ShoreVectorBlurPasses;
    private float terrainSize;
    private int shoreMapSize;
    private float shoreDistanceScale;
    private Single[] shoreDistances;
    private Vector4[] shoreVectors;
    public static TerrainTexturing Instance { get; }
    public int ShoreMapSize { get; }
    public Vector4[] ShoreMap { get; }
    private void ReleaseBasePyramid();
    private void UpdateBasePyramid();
    private void InitializeCoarseHeightSlope();
    private void ReleaseCoarseHeightSlope();
    private void UpdateCoarseHeightSlope();
    public static TerrainTexturing get_Instance();
    private void CheckInstance();
    private void Awake();
    public virtual void Setup();
    public virtual void PostSetup();
    private void Shutdown();
    private void OnEnable();
    private void OnDisable();
    private void Update();
    public int get_ShoreMapSize();
    public Vector4[] get_ShoreMap();
    private void InitializeShoreVector();
    private void GenerateShoreVector();
    private void ReleaseShoreVector();
    private void GenerateShoreVector(Single[]& distances, Vector4[]& vectors);
    public float GetCoarseDistanceToShore(Vector3 pos);
    public float GetCoarseDistanceToShore(Vector2 uv);
    public Vector3 GetCoarseVectorToShore(Vector3 pos);
    public Vector3 GetCoarseVectorToShore(Vector2 uv);
    public Vector3 GetCoarseVectorToShore(float normX, float normY);
    public Vector4 GetRawShoreVector(Vector3 pos);
    public Vector4 GetRawShoreVector(Vector2 uv);
}
public class TerrainTopologyAdd : TerrainModifier {
    [InspectorFlagsAttribute]
public Enum TopologyType;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public class TerrainTopologyMap : TerrainMap`1<int> {
    public Texture2D TopologyTexture;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public bool GetTopology(Vector3 worldPos, int mask);
    public bool GetTopology(float normX, float normZ, int mask);
    public bool GetTopology(int x, int z, int mask);
    public int GetTopology(Vector3 worldPos);
    public int GetTopology(float normX, float normZ);
    public int GetTopologyFast(Vector2 uv);
    public int GetTopology(int x, int z);
    public void SetTopology(Vector3 worldPos, int mask);
    public void SetTopology(float normX, float normZ, int mask);
    public void SetTopology(int x, int z, int mask);
    public void AddTopology(Vector3 worldPos, int mask);
    public void AddTopology(float normX, float normZ, int mask);
    public void AddTopology(int x, int z, int mask);
    public void RemoveTopology(Vector3 worldPos, int mask);
    public void RemoveTopology(float normX, float normZ, int mask);
    public void RemoveTopology(int x, int z, int mask);
    public int GetTopology(Vector3 worldPos, float radius);
    public int GetTopology(float normX, float normZ, float radius);
    public void SetTopology(Vector3 worldPos, int mask, float radius, float fade);
    public void SetTopology(float normX, float normZ, int mask, float radius, float fade);
    public void AddTopology(Vector3 worldPos, int mask, float radius, float fade);
    public void AddTopology(float normX, float normZ, int mask, float radius, float fade);
}
public class TerrainTopologySet : TerrainModifier {
    [InspectorFlagsAttribute]
public Enum TopologyType;
    protected virtual void Apply(Vector3 position, float opacity, float radius, float fade);
}
public class TerrainTreeBatch : MonoBehaviour {
}
public class TerrainWaterMap : TerrainMap`1<short> {
    public Texture2D WaterTexture;
    private float normY;
    public virtual void Setup();
    public void GenerateTextures();
    public void ApplyTextures();
    public float GetHeight(Vector3 worldPos);
    public float GetHeight(float normX, float normZ);
    public float GetHeightFast(Vector2 uv);
    public float GetHeight(int x, int z);
    public float GetHeight01(Vector3 worldPos);
    public float GetHeight01(float normX, float normZ);
    public float GetHeight01(int x, int z);
    public Vector3 GetNormal(Vector3 worldPos);
    public Vector3 GetNormal(float normX, float normZ);
    public Vector3 GetNormalFast(Vector2 uv);
    public Vector3 GetNormal(int x, int z);
    public float GetSlope(Vector3 worldPos);
    public float GetSlope(float normX, float normZ);
    public float GetSlope(int x, int z);
    public float GetSlope01(Vector3 worldPos);
    public float GetSlope01(float normX, float normZ);
    public float GetSlope01(int x, int z);
    public float GetDepth(Vector3 worldPos);
    public float GetDepth(float normX, float normZ);
    public void SetHeight(Vector3 worldPos, float height);
    public void SetHeight(float normX, float normZ, float height);
    public void SetHeight(int x, int z, float height);
}
public class TeslaCoil : IOEntity {
    public TargetTrigger targetTrigger;
    public TriggerMovement movementTrigger;
    public float powerToDamageRatio;
    public float dischargeTickRate;
    public float maxDischargeSelfDamageSeconds;
    public float maxDamageOutput;
    public Transform damageEyes;
    public static Flags Flag_WeakShorting;
    public static Flags Flag_StrongShorting;
    public int powerForHeavyShorting;
    private float lastDischargeTime;
    public virtual int ConsumptionAmount();
    public virtual int DesiredPower(int inputIndex);
    public bool CanDischarge();
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    public void Discharge();
    public virtual void OnRepair();
}
public class TexasHoldEmUI : MonoBehaviour {
    [SerializeField]
private Image[] holeCardImages;
    [SerializeField]
private Image[] holeCardBackings;
    [SerializeField]
[FormerlySerializedAsAttribute("flopCardImages")]
private Image[] communityCardImages;
    [SerializeField]
private Image[] communityCardBackings;
    [SerializeField]
private RustText potText;
    [SerializeField]
private CardGamePlayerWidget[] playerWidgets;
    [SerializeField]
private Phrase phraseWinningHand;
    [SerializeField]
private Phrase foldPhrase;
    [SerializeField]
private Phrase raisePhrase;
    [SerializeField]
private Phrase checkPhrase;
    [SerializeField]
private Phrase callPhrase;
    [SerializeField]
private Phrase phraseRoyalFlush;
    [SerializeField]
private Phrase phraseStraightFlush;
    [SerializeField]
private Phrase phraseFourOfAKind;
    [SerializeField]
private Phrase phraseFullHouse;
    [SerializeField]
private Phrase phraseFlush;
    [SerializeField]
private Phrase phraseStraight;
    [SerializeField]
private Phrase phraseThreeOfAKind;
    [SerializeField]
private Phrase phraseTwoPair;
    [SerializeField]
private Phrase phrasePair;
    [SerializeField]
private Phrase phraseHighCard;
    [SerializeField]
private Phrase phraseRaiseAmount;
    [SerializeField]
private Sprite dealerChip;
    [SerializeField]
private Sprite smallBlindChip;
    [SerializeField]
private Sprite bigBlindChip;
    [SerializeField]
private Sprite noIcon;
}
public class TextArcadeEntity : ArcadeEntity {
    public TextMeshProUGUI text;
}
public class TextEntryCookie : MonoBehaviour {
    public InputField control { get; }
    public InputField get_control();
    private void OnEnable();
    private void OnDisable();
}
public class Texture2DRef : ResourceRef`1<Texture2D> {
}
internal enum TextureCacheState : Enum {
    public int value__;
    public static TextureCacheState Initializing;
    public static TextureCacheState Uncached;
    public static TextureCacheState CachedRaw;
    public static TextureCacheState CachedCompressed;
}
public class TextureColorPicker : MonoBehaviour {
    public Texture2D texture;
    public onColorSelectedEvent onColorSelected;
    public virtual void OnPointerDown(PointerEventData eventData);
    public virtual void OnDrag(PointerEventData eventData);
}
public class TextureData : ValueType {
    public int width;
    public int height;
    public Color32[] colors;
    public TextureData(Texture2D tex);
    public Color32 GetColor(int x, int y);
    public int GetShort(int x, int y);
    public int GetInt(int x, int y);
    public float GetFloat(int x, int y);
    public float GetHalf(int x, int y);
    public Vector4 GetVector(int x, int y);
    public Vector3 GetNormal(int x, int y);
    public Color32 GetInterpolatedColor(float x, float y);
    public int GetInterpolatedInt(float x, float y);
    public int GetInterpolatedShort(float x, float y);
    public float GetInterpolatedFloat(float x, float y);
    public float GetInterpolatedHalf(float x, float y);
    public Vector4 GetInterpolatedVector(float x, float y);
    public Vector3 GetInterpolatedNormal(float x, float y);
}
public class TextureStreaming : SingletonComponent`1<MonoBehaviour> {
}
public class ThreatDetectedAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Range>k__BackingField;
    public float Range { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class ThreatDetectedEventUI : BaseEventUI {
}
public class ThrownWeapon : AttackEntity {
    [HeaderAttribute("Throw Weapon")]
public GameObjectRef prefabToThrow;
    public float maxThrowVelocity;
    public float tumbleVelocity;
    public Vector3 overrideAngle;
    public bool canStick;
    public bool canThrowUnderwater;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction);
    public void ServerThrow(Vector3 targetPosition);
    private float GetThrowVelocity(Vector3 throwPos, Vector3 targetPos, Vector3 aimDir);
    [RPC_Server]
[IsActiveItem]
private void DoThrow(RPCMessage msg);
    [IsActiveItem]
[RPC_Server]
private void DoDrop(RPCMessage msg);
    protected virtual void SetUpThrownWeapon(BaseEntity ent);
}
public class TickHistory : object {
    private Deque`1<Vector3> points;
    public int Count { get; }
    public int get_Count();
    public void Reset();
    public void Reset(Vector3 point);
    public float Distance(BasePlayer player, Vector3 point);
    public void AddPoint(Vector3 point, int limit);
    public void TransformEntries(Matrix4x4 matrix);
}
public class TickInterpolator : object {
    private List`1<Segment> points;
    private int index;
    public float Length;
    public Vector3 CurrentPoint;
    public Vector3 StartPoint;
    public Vector3 EndPoint;
    public int Count { get; }
    public int get_Count();
    public void Reset();
    public void Reset(Vector3 point);
    public void AddPoint(Vector3 point);
    public bool MoveNext(float distance);
    public bool HasNext();
    public void TransformEntries(Matrix4x4 matrix);
}
public class TimeBasedSoundSpread : SoundModifier {
    public AnimationCurve spreadCurve;
    public AnimationCurve wanderIntensityCurve;
}
public class TimeCachedValue`1 : object {
    public float refreshCooldown;
    public float refreshRandomRange;
    public Func`1<T> updateValue;
    private T cachedValue;
    private TimeSince cooldown;
    private bool hasRun;
    private bool forceNextRun;
    public T Get(bool force);
    public void ForceNextRun();
}
public class TimedExplosive : BaseEntity {
    public float timerAmountMin;
    public float timerAmountMax;
    public float minExplosionRadius;
    public float explosionRadius;
    public bool explodeOnContact;
    public bool canStick;
    public bool onlyDamageParent;
    public bool IgnoreAI;
    public bool BlindAI;
    public float aiBlindDuration;
    public float aiBlindRange;
    public GameObjectRef explosionEffect;
    public ExplosionEffectOffsetMode explosionOffsetMode;
    public Vector3 explosionEffectOffset;
    [TooltipAttribute("Optional: Will fall back to watersurfaceExplosionEffect or explosionEffect if not assigned.")]
public GameObjectRef underwaterExplosionEffect;
    [MinAttribute("0")]
public float underwaterExplosionDepth;
    [TooltipAttribute("Optional: Will fall back to underwaterExplosionEffect or explosionEffect if not assigned.")]
public GameObjectRef watersurfaceExplosionEffect;
    [MinMaxAttribute("0", "100")]
public MinMax watersurfaceExplosionDepth;
    public GameObjectRef stickEffect;
    public GameObjectRef bounceEffect;
    public bool explosionUsesForward;
    public bool explosionMatchesOrientation;
    public bool waterCausesExplosion;
    public int vibrationLevel;
    public List`1<DamageTypeEntry> damageTypes;
    private float lastBounceTime;
    private bool hadRB;
    private float rbMass;
    private float rbDrag;
    private float rbAngularDrag;
    private CollisionDetectionMode rbCollisionMode;
    private static int parentOnlySplashDamage;
    private static int fullSplashDamage;
    private static BaseEntity[] queryResults;
    private Vector3 lastPosition;
    protected bool PositionTickFixedTime { get; }
    protected bool AlwaysRunWaterCheck { get; }
    private static TimedExplosive();
    protected virtual bool get_PositionTickFixedTime();
    public void SetDamageScale(float scale);
    public virtual float GetNetworkTime();
    public virtual void ServerInit();
    protected virtual bool get_AlwaysRunWaterCheck();
    public virtual void WaterCheck();
    public virtual void SetFuse(float fuseLength);
    public virtual float GetRandomTimerTime();
    public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin);
    public void ForceExplode();
    public virtual void Explode();
    private Vector3 GetExplosionNormal();
    public virtual void Explode(Vector3 explosionFxPos);
    private Vector3 ExplosionCenter();
    private void BlindAnyAI();
    public void FixedUpdate();
    private void CheckClippingThroughWalls();
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    public virtual bool CanStickTo(BaseEntity entity);
    private void DoBounceEffect();
    private void DoCollisionStick(Collision collision, BaseEntity ent);
    public virtual void SetMotionEnabled(bool wantsMotion);
    public bool IsStuck(bool bypassColliderCheck);
    public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider);
    private void UnStick();
    internal virtual void OnParentRemoved();
    public virtual void Save(SaveInfo info);
    public virtual void PostServerLoad();
    public virtual void Load(LoadInfo info);
    public virtual void SetCollisionEnabled(bool wantsCollision);
}
public class TimedRemoval : MonoBehaviour {
    public Object objectToDestroy;
    public float removeDelay;
    private void OnEnable();
}
public class TimedUnlootableCrate : LootContainer {
    public bool unlootableOnSpawn;
    public float unlootableDuration;
    public virtual void ServerInit();
    public void SetUnlootableFor(float duration);
    public void MakeLootable();
}
public class TimelineConvarController : PlayableAsset {
    public string convarName;
    public TimelineConvarPlayable template;
    public ClipCaps clipCaps { get; }
    public virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    public sealed virtual ClipCaps get_clipCaps();
}
public class TimelineConvarPlayable : PlayableBehaviour {
    public string convar;
    public float ConvarValue;
    public virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
}
public class TimerAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <DurationMin>k__BackingField;
    [CompilerGeneratedAttribute]
private float <DurationMax>k__BackingField;
    protected float currentDuration;
    protected float elapsedDuration;
    public float DurationMin { get; public set; }
    public float DurationMax { get; public set; }
    [CompilerGeneratedAttribute]
public float get_DurationMin();
    [CompilerGeneratedAttribute]
public void set_DurationMin(float value);
    [CompilerGeneratedAttribute]
public float get_DurationMax();
    [CompilerGeneratedAttribute]
public void set_DurationMax(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Reset();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class TimerConfig : IOConfig`1<CustomTimerSwitch> {
}
public class TimerEventUI : BaseEventUI {
}
public class TimerSwitch : IOEntity {
    public float timerLength;
    public Transform timerDrum;
    private float timePassed;
    private float input1Amount;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual int ConsumptionAmount();
    public virtual void ResetIOState();
    public virtual bool WantsPassthroughPower();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual bool WantsPower(int inputIndex);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int inputSlot);
    [RPC_Server]
[IsVisible("3")]
public void SVSwitch(RPCMessage msg);
    public void SwitchPressed();
    public void AdvanceTime();
    public void EndTimer();
    public float GetPassedTime();
    public virtual void PostServerLoad();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
}
public class TimeSinceThreatAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; private set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class TimeSinceThreatEventUI : BaseEventUI {
}
public class TimeSlider : MonoBehaviour {
    private Slider slider;
    private void Start();
    private void Update();
    public void OnValue(float f);
}
[ExtensionAttribute]
public static class TimeSpanEx : object {
    [ExtensionAttribute]
public static string ToShortString(TimeSpan timeSpan);
    [ExtensionAttribute]
public static string ToShortStringNoHours(TimeSpan timeSpan);
}
public class Timing : ValueType {
    private Stopwatch sw;
    private string name;
    public Timing(string name);
    public static Timing Start(string name);
    public void End();
}
public class TinCanAlarm : DecayEntity {
    [SpaceAttribute]
public LineRenderer lineRenderer;
    public Transform wireOrigin;
    public Transform wireOriginClient;
    public PlayerDetectionTrigger trigger;
    public Transform wireEndCollider;
    public GroundWatch groundWatch;
    public GroundWatch wireGroundWatch;
    public Animator animator;
    [SpaceAttribute]
public SoundDefinition alarmSoundDef;
    public SoundDefinition armSoundDef;
    public Vector3 endPoint;
    private static Flags Flag_Used;
    public BaseEntity lastTriggerEntity;
    public float lastTriggerTime;
    private BasePlayer usingPlayer;
    [SpaceAttribute]
public float maxWireLength;
    private static int WIRE_PLACEMENT_LAYER;
    public Transform WireOrigin { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public Transform get_WireOrigin();
    public bool IsUsed();
    private bool IsArmed();
    public virtual bool CanPickup(BasePlayer player);
    public sealed virtual bool ShouldTrigger();
    public sealed virtual void OnObjects();
    public sealed virtual void OnObjectAdded(GameObject obj, Collider col);
    public sealed virtual void OnEmpty();
    public void TriggerAlarm();
    public void ServerOnWireDeploying();
    [RPC_Server]
[MaxDistance("3")]
public void SERVER_StartArming(RPCMessage msg);
    [RPC_Server]
public void SERVER_StopArming(RPCMessage msg);
    public void PlayerStartsArming(BasePlayer player);
    public void PlayerStopsArming(BasePlayer player);
    public void CutWire();
    private void UpdateWireTip();
    private void OnGroundMissing();
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void OnAttacked(HitInfo info);
    private void UpdateTrigger();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    [RPC_Server]
public void RPC_SetEndPoint(RPCMessage msg);
    private bool IsGoingThroughWalls(Vector3 position);
    private bool IsInValidVolume(Vector3 position);
    private bool IsOnValidEntities(Vector3 position);
}
[AttributeUsageAttribute("64")]
public class TinyJSON.AfterDecode : Attribute {
}
[AttributeUsageAttribute("64")]
public class TinyJSON.BeforeEncode : Attribute {
}
[AttributeUsageAttribute("384")]
public class TinyJSON.DecodeAlias : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    public String[] Names { get; private set; }
    public DecodeAlias(String[] names);
    [CompilerGeneratedAttribute]
public String[] get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(String[] value);
    public bool Contains(string name);
}
public class TinyJSON.DecodeException : Exception {
    public DecodeException(string message);
    public DecodeException(string message, Exception innerException);
}
public class TinyJSON.Decoder : object {
    private static string whiteSpace;
    private static string wordBreak;
    private StringReader json;
    private char PeekChar { get; }
    private char NextChar { get; }
    private string NextWord { get; }
    private Token NextToken { get; }
    private Decoder(string jsonString);
    public static Variant Decode(string jsonString);
    public sealed virtual void Dispose();
    private ProxyObject DecodeObject();
    private ProxyArray DecodeArray();
    private Variant DecodeValue();
    private Variant DecodeByToken(Token token);
    private Variant DecodeString();
    private Variant DecodeNumber();
    private void ConsumeWhiteSpace();
    private char get_PeekChar();
    private char get_NextChar();
    private string get_NextWord();
    private Token get_NextToken();
}
[FlagsAttribute]
public enum TinyJSON.EncodeOptions : Enum {
    public int value__;
    public static EncodeOptions None;
    public static EncodeOptions PrettyPrint;
    public static EncodeOptions NoTypeHints;
    public static EncodeOptions IncludePublicProperties;
    public static EncodeOptions EnforceHierarchyOrder;
    [ObsoleteAttribute("Use EncodeOptions.EnforceHierarchyOrder instead.")]
public static EncodeOptions EnforceHeirarchyOrder;
}
public class TinyJSON.Encoder : object {
    private static Type includeAttrType;
    private static Type excludeAttrType;
    private static Type typeHintAttrType;
    private StringBuilder builder;
    private EncodeOptions options;
    private int indent;
    private bool PrettyPrintEnabled { get; }
    private bool TypeHintsEnabled { get; }
    private bool IncludePublicPropertiesEnabled { get; }
    private bool EnforceHierarchyOrderEnabled { get; }
    private Encoder(EncodeOptions options);
    private static Encoder();
    public static string Encode(object obj);
    public static string Encode(object obj, EncodeOptions options);
    private bool get_PrettyPrintEnabled();
    private bool get_TypeHintsEnabled();
    private bool get_IncludePublicPropertiesEnabled();
    private bool get_EnforceHierarchyOrderEnabled();
    private void EncodeValue(object value, bool forceTypeHint);
    private IEnumerable`1<FieldInfo> GetFieldsForType(Type type);
    private IEnumerable`1<PropertyInfo> GetPropertiesForType(Type type);
    private void EncodeObject(object value, bool forceTypeHint);
    private void EncodeProxyArray(ProxyArray value);
    private void EncodeProxyObject(ProxyObject value);
    private void EncodeDictionary(IDictionary value, bool forceTypeHint);
    private void EncodeList(IList value, bool forceTypeHint);
    private void EncodeArray(Array value, bool forceTypeHint);
    private void EncodeArrayRank(Array value, int rank, Int32[] indices, bool forceTypeHint);
    private void EncodeString(string value);
    private void AppendIndent();
    private void AppendOpenBrace();
    private void AppendCloseBrace();
    private void AppendOpenBracket();
    private void AppendCloseBracket();
    private void AppendComma(bool firstItem);
    private void AppendColon();
}
[AttributeUsageAttribute("384")]
public class TinyJSON.Exclude : Attribute {
}
[ExtensionAttribute]
public static class TinyJSON.Extensions : object {
    [ExtensionAttribute]
public static bool AnyOfType(IEnumerable`1<TSource> source, Type expectedType);
}
[AttributeUsageAttribute("384")]
public class TinyJSON.Include : Attribute {
}
public static class TinyJSON.JSON : object {
    private static Type includeAttrType;
    private static Type excludeAttrType;
    private static Type decodeAliasAttrType;
    private static Dictionary`2<string, Type> typeCache;
    private static BindingFlags instanceBindingFlags;
    private static BindingFlags staticBindingFlags;
    private static MethodInfo decodeTypeMethod;
    private static MethodInfo decodeListMethod;
    private static MethodInfo decodeDictionaryMethod;
    private static MethodInfo decodeArrayMethod;
    private static MethodInfo decodeMultiRankArrayMethod;
    private static JSON();
    public static Variant Load(string json);
    public static string Dump(object data);
    public static string Dump(object data, EncodeOptions options);
    public static void MakeInto(Variant data, T& item);
    private static Type FindType(string fullName);
    private static T DecodeType(Variant data);
    private static List`1<T> DecodeList(Variant data);
    private static Dictionary`2<TKey, TValue> DecodeDictionary(Variant data);
    private static T[] DecodeArray(Variant data);
    private static void DecodeMultiRankArray(ProxyArray arrayData, Array array, int arrayRank, Int32[] indices);
    public static void SupportTypeForAOT();
    private static void SupportValueTypesForAOT();
}
[ObsoleteAttribute("Use the AfterDecode attribute instead.")]
public class TinyJSON.Load : AfterDecode {
}
[DefaultMemberAttribute("Item")]
public class TinyJSON.ProxyArray : Variant {
    private List`1<Variant> list;
    public Variant Item { get; public set; }
    public int Count { get; }
    private sealed virtual override IEnumerator`1<Variant> System.Collections.Generic.IEnumerable<TinyJSON.Variant>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(Variant item);
    public virtual Variant get_Item(int index);
    public virtual void set_Item(int index, Variant value);
    public int get_Count();
    internal bool CanBeMultiRankArray(Int32[] rankLengths);
    private bool CanBeMultiRankArray(int rank, Int32[] rankLengths);
}
public class TinyJSON.ProxyBoolean : Variant {
    private bool value;
    public ProxyBoolean(bool value);
    public virtual bool ToBoolean(IFormatProvider provider);
    public virtual string ToString(IFormatProvider provider);
}
public class TinyJSON.ProxyNumber : Variant {
    private static Char[] floatingPointCharacters;
    private IConvertible value;
    public ProxyNumber(IConvertible value);
    private static ProxyNumber();
    private static IConvertible Parse(string value);
    public virtual bool ToBoolean(IFormatProvider provider);
    public virtual byte ToByte(IFormatProvider provider);
    public virtual char ToChar(IFormatProvider provider);
    public virtual decimal ToDecimal(IFormatProvider provider);
    public virtual double ToDouble(IFormatProvider provider);
    public virtual short ToInt16(IFormatProvider provider);
    public virtual int ToInt32(IFormatProvider provider);
    public virtual long ToInt64(IFormatProvider provider);
    public virtual sbyte ToSByte(IFormatProvider provider);
    public virtual float ToSingle(IFormatProvider provider);
    public virtual string ToString(IFormatProvider provider);
    public virtual ushort ToUInt16(IFormatProvider provider);
    public virtual UInt32 ToUInt32(IFormatProvider provider);
    public virtual ulong ToUInt64(IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class TinyJSON.ProxyObject : Variant {
    public static string TypeHintKey;
    private Dictionary`2<string, Variant> dict;
    public string TypeHint { get; }
    public Variant Item { get; public set; }
    public int Count { get; }
    public KeyCollection<string, Variant> Keys { get; }
    public ValueCollection<string, Variant> Values { get; }
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, Variant>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,TinyJSON.Variant>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(string key, Variant item);
    public bool TryGetValue(string key, Variant& item);
    public string get_TypeHint();
    public virtual Variant get_Item(string key);
    public virtual void set_Item(string key, Variant value);
    public int get_Count();
    public KeyCollection<string, Variant> get_Keys();
    public ValueCollection<string, Variant> get_Values();
}
public class TinyJSON.ProxyString : Variant {
    private string value;
    public ProxyString(string value);
    public virtual string ToString(IFormatProvider provider);
}
[ObsoleteAttribute("Use the Exclude attribute instead.")]
public class TinyJSON.Skip : Exclude {
}
[AttributeUsageAttribute("384")]
public class TinyJSON.TypeHint : Attribute {
}
[DefaultMemberAttribute("Item")]
public abstract class TinyJSON.Variant : object {
    protected static IFormatProvider FormatProvider;
    public Variant Item { get; public set; }
    public Variant Item { get; public set; }
    private static Variant();
    public void Make(T& item);
    public T Make();
    public string ToJSON();
    public virtual TypeCode GetTypeCode();
    public virtual object ToType(Type conversionType, IFormatProvider provider);
    public virtual DateTime ToDateTime(IFormatProvider provider);
    public virtual bool ToBoolean(IFormatProvider provider);
    public virtual byte ToByte(IFormatProvider provider);
    public virtual char ToChar(IFormatProvider provider);
    public virtual decimal ToDecimal(IFormatProvider provider);
    public virtual double ToDouble(IFormatProvider provider);
    public virtual short ToInt16(IFormatProvider provider);
    public virtual int ToInt32(IFormatProvider provider);
    public virtual long ToInt64(IFormatProvider provider);
    public virtual sbyte ToSByte(IFormatProvider provider);
    public virtual float ToSingle(IFormatProvider provider);
    public virtual string ToString(IFormatProvider provider);
    public virtual ushort ToUInt16(IFormatProvider provider);
    public virtual UInt32 ToUInt32(IFormatProvider provider);
    public virtual ulong ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public virtual Variant get_Item(string key);
    public virtual void set_Item(string key, Variant value);
    public virtual Variant get_Item(int index);
    public virtual void set_Item(int index, Variant value);
    public static bool op_Implicit(Variant variant);
    public static float op_Implicit(Variant variant);
    public static double op_Implicit(Variant variant);
    public static ushort op_Implicit(Variant variant);
    public static short op_Implicit(Variant variant);
    public static UInt32 op_Implicit(Variant variant);
    public static int op_Implicit(Variant variant);
    public static ulong op_Implicit(Variant variant);
    public static long op_Implicit(Variant variant);
    public static decimal op_Implicit(Variant variant);
    public static string op_Implicit(Variant variant);
    public static Guid op_Implicit(Variant variant);
}
public class TirednessAboveAIEvent : BaseAIEvent {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; private set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(float value);
    public virtual void Init(AIEventData data, BaseEntity owner);
    public virtual AIEventData ToProto();
    public virtual void Execute(AIMemory memory, AIBrainSenses senses, StateStatus stateStatus);
}
public class TirednessAboveEventUI : BaseEventUI {
}
public class TmProEmojiInputField : TMP_InputField {
    public TmProEmojiRedirector Redirector;
    public EmojiAutocomplete Autocomplete;
}
public class TmProEmojiRedirector : MonoBehaviour {
    public GameObjectRef SpritePrefab;
    public float EmojiScale;
    public bool NonDestructiveChange;
    public bool CanTextHaveLegitimateRichText;
    public static void FindEmojiSubstitutions(string text, RustEmojiLibrary library, List`1<ValueTuple`2<EmojiSub, int>> foundSubs, bool richText, bool isServer, int messageLength);
}
public class ToggleCookie : MonoBehaviour {
    public void OnEnable();
    public void OnDisable();
    private void OnPressed();
    private void OnReleased();
    private void OnChanged(bool v);
}
public class ToggleGroupCookie : MonoBehaviour {
    public ToggleGroup group { get; }
    public ToggleGroup get_group();
    private void OnEnable();
    private void OnDisable();
    private void SetupListeners();
    private void OnToggleChanged(bool b);
    private static Transform FindChild(Transform parent, string name);
}
public class ToggleHUDLayer : MonoBehaviour {
    public Toggle toggleControl;
    public TextMeshProUGUI textControl;
    public string hudComponentName;
    protected void OnEnable();
    public void OnToggleChanged();
}
public class ToggleLayer : MonoBehaviour {
    public Toggle toggleControl;
    public TextMeshProUGUI textControl;
    public LayerSelect layer;
    protected void OnEnable();
    public void OnToggleChanged();
    protected void OnValidate();
}
public class ToggleResolution : MonoBehaviour {
    public TweakUIDropdown Dropdown;
}
public class ToggleTerrainRenderer : MonoBehaviour {
    public Toggle toggleControl;
    public Text textControl;
    protected void OnEnable();
    public void OnToggleChanged();
    protected void OnValidate();
}
public class ToggleTerrainTrees : MonoBehaviour {
    public Toggle toggleControl;
    public Text textControl;
    protected void OnEnable();
    public void OnToggleChanged();
    protected void OnValidate();
}
public class TokenisedPhrase : Phrase {
    public static Phrase LeftMouse;
    public static Phrase RightMouse;
    public static Phrase MiddleMouse;
    public string translated { get; }
    public TokenisedPhrase(string t, string eng);
    private static TokenisedPhrase();
    public virtual string get_translated();
    public static string ReplaceTokens(string str);
    public static string TranslateMouseButton(string mouseButton);
    private static string GetButtonWithBind(string s);
}
public class TonemappingOverlay : ImageEffectLayer {
    public TonemappingColorGrading tonemapping;
}
public class Toolgun : Hammer {
    public GameObjectRef attackEffect;
    public GameObjectRef beamEffect;
    public GameObjectRef beamImpactEffect;
    public GameObjectRef errorEffect;
    public GameObjectRef beamEffectClassic;
    public GameObjectRef beamImpactEffectClassic;
    public Transform muzzlePoint;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void DoAttackShared(HitInfo info);
}
public class ToolgunBeam : MonoBehaviour {
    public LineRenderer electricalBeam;
    public float scrollSpeed;
    private Color fadeColor;
    public float fadeSpeed;
    public void Update();
}
public class ToolgunScreen : MonoBehaviour {
    public Text blockInfoText;
    public Text noBlockText;
    public void SetScreenText(string newText);
}
public class ToolsHUDUI : MonoBehaviour {
    [SerializeField]
private GameObject prefab;
    [SerializeField]
private Transform parent;
    private bool initialised;
    protected void OnEnable();
    private void Init();
    private void AddToggleObj(string trName, string labelText);
    public void SelectAll();
    public void SelectNone();
}
public class Tooltip : BaseMonoBehaviour {
    public static TooltipContainer Current;
    [TextAreaAttribute]
public string Text;
    public GameObject TooltipObject;
    public string token;
    private Object[] localizationArguments;
    public string english { get; }
    public string get_english();
}
public class TooltipContainer : MonoBehaviour {
    public Transform ScaleRoot;
    public RustText TooltipText;
    public RectTransform OverrideLayoutRoot;
}
public class TooltipContainer_Emoji : TooltipContainer {
    public TmProEmojiRedirector EmojiRedirector;
}
public class TopBunnies : MonoBehaviour {
    public BunnyEntry[] topBunnyEntries;
    public Text timerText;
    public CanvasGroup group;
    public Color endingColor;
}
public class TorchDeployableLightSource : StorageContainer {
    public ItemDefinition[] AllowedTorches;
    public Transform TorchRoot;
    public static Flags HasTorch;
    public static Flags UseBuiltInFx;
    public ItemDefinition[] BuiltInFxItems;
    private EntityRef`1<TorchWeapon> spawnedTorch;
    private ItemDefinition spawnedTorchDef;
    private Item CurrentTorch { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool ItemFilter(Item item, int targetSlot);
    private bool ShouldUseBuiltInFx(ItemDefinition def);
    private void UpdateTorch();
    private void TickTorchDurability();
    public virtual void PostServerLoad();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    private Item get_CurrentTorch();
    [IsVisible("3")]
[RPC_Server]
private void RequestTurnOnOff(RPCMessage msg);
    private void TryToggle(bool wantsOn);
    public sealed virtual bool WantsSplash(ItemDefinition splashType, int amount);
    public sealed virtual int DoSplash(ItemDefinition splashType, int amount);
    public sealed virtual void Ignite(Vector3 fromPos);
    public sealed virtual bool CanIgnite();
}
public class TorchWeapon : BaseMelee {
    public static float FuelTickAmount;
    [HeaderAttribute("TorchWeapon")]
public AnimatorOverrideController LitHoldAnimationOverride;
    public bool ExtinguishUnderwater;
    public bool UseTurnOnOffAnimations;
    public GameObjectRef litStrikeFX;
    public static Flags IsInHolder;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void GetAttackStats(HitInfo info);
    public virtual float GetConditionLoss();
    public void SetIsOn(bool isOn);
    [IsActiveItem]
[RPC_Server]
private void Ignite(RPCMessage msg);
    [IsActiveItem]
[RPC_Server]
private void Extinguish(RPCMessage msg);
    public void UseFuel();
    public virtual void OnHeldChanged();
    public virtual string GetStrikeEffectPath(string materialName);
}
public class TorpedoServerProjectile : ServerProjectile {
    [TooltipAttribute("Make sure to leave some allowance for waves, which affect the true depth.")]
[SerializeField]
private float minWaterDepth;
    [SerializeField]
private float shallowWaterInaccuracy;
    [SerializeField]
private float deepWaterInaccuracy;
    [SerializeField]
private float shallowWaterCutoff;
    public bool HasRangeLimit { get; }
    protected int mask { get; }
    public virtual bool get_HasRangeLimit();
    protected virtual int get_mask();
    public virtual bool DoMovement();
    public virtual void InitializeVelocity(Vector3 overrideVel);
}
public class TrainCar : BaseVehicle {
    [HeaderAttribute("Train Car")]
[SerializeField]
public float corpseSeconds;
    [SerializeField]
public TriggerTrainCollisions frontCollisionTrigger;
    [SerializeField]
public TriggerTrainCollisions rearCollisionTrigger;
    [SerializeField]
public float collisionDamageDivide;
    [SerializeField]
public float derailCollisionForce;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerFront;
    [SerializeField]
public TriggerHurtNotChild hurtTriggerRear;
    [SerializeField]
private GameObject[] hurtOrRepelTriggersInternal;
    [SerializeField]
public float hurtTriggerMinSpeed;
    [SerializeField]
public Transform centreOfMassTransform;
    [SerializeField]
public Transform frontBogiePivot;
    [SerializeField]
public bool frontBogieCanRotate;
    [SerializeField]
public Transform rearBogiePivot;
    [SerializeField]
public bool rearBogieCanRotate;
    [SerializeField]
private Transform[] wheelVisuals;
    [SerializeField]
public float wheelRadius;
    [SerializeField]
[FormerlySerializedAsAttribute("fxFinalExplosion")]
public GameObjectRef fxDestroyed;
    [SerializeField]
public TriggerParent platformParentTrigger;
    public GameObjectRef collisionEffect;
    public Transform frontCoupling;
    public Transform frontCouplingPivot;
    public Transform rearCoupling;
    public Transform rearCouplingPivot;
    [SerializeField]
public SoundDefinition coupleSound;
    [SerializeField]
private SoundDefinition uncoupleSound;
    [SerializeField]
private TrainCarAudio trainCarAudio;
    [FormerlySerializedAsAttribute("frontCoupleFx")]
[SerializeField]
public ParticleSystem frontCouplingChangedFx;
    [FormerlySerializedAsAttribute("rearCoupleFx")]
[SerializeField]
public ParticleSystem rearCouplingChangedFx;
    [SerializeField]
[FormerlySerializedAsAttribute("fxCoupling")]
public ParticleSystem newCouplingFX;
    [SerializeField]
private float decayTimeMultiplier;
    [SerializeField]
[ReadOnlyAttribute]
public Vector3 frontBogieLocalOffset;
    [SerializeField]
[ReadOnlyAttribute]
public Vector3 rearBogieLocalOffset;
    [ServerVar]
public static float population;
    [ServerVar]
public static int wagons_per_engine;
    [ServerVar]
public static float decayminutes;
    [ReadOnlyAttribute]
public float DistFrontWheelToFrontCoupling;
    [ReadOnlyAttribute]
public float DistFrontWheelToBackCoupling;
    public TrainCouplingController coupling;
    public TrackSelection localTrackSelection;
    public static Flags Flag_LinedUpToUnload;
    [CompilerGeneratedAttribute]
private float <FrontWheelSplineDist>k__BackingField;
    public static float TRAINCAR_MAX_SPEED;
    protected bool trainDebug;
    public CompleteTrain completeTrain;
    public float savedTrackSpeed;
    private bool frontAtEndOfLine;
    private bool rearAtEndOfLine;
    public float frontBogieYRot;
    public float rearBogieYRot;
    public Vector3 spawnOrigin;
    private bool coupledBackwards;
    public TrainTrackSpline _frontTrackSection;
    [CompilerGeneratedAttribute]
private TrainTrackSpline <RearTrackSection>k__BackingField;
    public float distFrontToBackWheel;
    public float initialSpawnTime;
    public float decayingFor;
    public float decayTickSpacing;
    public float lastDecayTick;
    public TriggerTrainCollisions FrontCollisionTrigger { get; }
    public TriggerTrainCollisions RearCollisionTrigger { get; }
    public TrainCarType CarType { get; }
    public bool LinedUpToUnload { get; }
    public Vector3 Position { get; }
    public float FrontWheelSplineDist { get; public set; }
    public bool FrontAtEndOfLine { get; }
    public bool RearAtEndOfLine { get; }
    public bool networkUpdateOnCompleteTrainChange { get; }
    public TrainTrackSpline FrontTrackSection { get; public set; }
    public TrainTrackSpline RearTrackSection { get; public set; }
    public bool IsAtAStation { get; }
    public bool IsOnAboveGroundSpawnRail { get; }
    public bool RecentlySpawned { get; }
    private static TrainCar();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public TriggerTrainCollisions get_FrontCollisionTrigger();
    public TriggerTrainCollisions get_RearCollisionTrigger();
    public virtual TrainCarType get_CarType();
    public bool get_LinedUpToUnload();
    public virtual void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public sealed virtual bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);
    public virtual float InheritedVelocityScale();
    public virtual void SetTrackSelection(TrackSelection trackSelection);
    public bool PlayerIsOnPlatform(BasePlayer player);
    public sealed virtual Vector3 get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual float get_FrontWheelSplineDist();
    [CompilerGeneratedAttribute]
public void set_FrontWheelSplineDist(float value);
    public bool get_FrontAtEndOfLine();
    public bool get_RearAtEndOfLine();
    public virtual bool get_networkUpdateOnCompleteTrainChange();
    public TrainTrackSpline get_FrontTrackSection();
    public void set_FrontTrackSection(TrainTrackSpline value);
    [CompilerGeneratedAttribute]
public TrainTrackSpline get_RearTrackSection();
    [CompilerGeneratedAttribute]
public void set_RearTrackSection(TrainTrackSpline value);
    public bool get_IsAtAStation();
    public bool get_IsOnAboveGroundSpawnRail();
    public bool get_RecentlySpawned();
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    public virtual void Spawn();
    public virtual void Save(SaveInfo info);
    public virtual void ServerFlagsChanged(Flags old, Flags next);
    public void UpdateCompleteTrain();
    public void SetNewCompleteTrain(CompleteTrain ct);
    public virtual void Hurt(HitInfo info);
    public virtual void OnKilled(HitInfo info);
    public virtual Vector3 GetExplosionPos();
    public void ActualDeath();
    public virtual void DoRepair(BasePlayer player);
    public sealed virtual float GetDamageMultiplier(BaseEntity ent);
    public sealed virtual void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal);
    public virtual void DoServerDestroy();
    public void RemoveFromCompleteTrain();
    public virtual bool MountEligable(BasePlayer player);
    public virtual float MaxVelocity();
    public float GetTrackSpeed();
    public bool IsCoupledBackwards();
    public float GetPrevTrackSpeed();
    public virtual Vector3 GetLocalVelocityServer();
    public bool AnyPlayersOnTrainCar();
    public virtual void VehicleFixedUpdate();
    public virtual void PostVehicleFixedUpdate();
    public Vector3 GetCentreOfTrainPos();
    public Vector3 GetFrontOfTrainPos();
    public Vector3 GetRearOfTrainPos();
    public void FrontTrainCarTick(TrackSelection trackSelection, float dt);
    public void OtherTrainCarTick(TrainTrackSpline theirTrackSpline, float prevSplineDist, float distanceOffset);
    public bool TryGetNextTrainCar(Vector3 forwardDir, TrainCar& result);
    public bool TryGetPrevTrainCar(Vector3 forwardDir, TrainCar& result);
    public bool TryGetTrainCar(bool next, Vector3 forwardDir, TrainCar& result);
    public void MoveFrontWheelsAlongTrackSpline(TrainTrackSpline trackSpline, float prevSplineDist, float distToMove, TrainTrackSpline preferredAltTrack, TrackSelection trackSelection);
    public Vector3 GetFrontWheelPos();
    public Vector3 GetRearWheelPos();
    public void SetTheRestFromFrontWheelData(TrainTrackSpline& frontTS, Vector3 targetFrontWheelPos, Vector3 targetFrontWheelTangent, TrackSelection trackSelection, TrainTrackSpline additionalAlt, bool instantMove);
    public float GetForces();
    protected virtual float GetThrottleForce();
    public virtual bool HasThrottleInput();
    public float ApplyCollisionDamage(float forceMagnitude);
    public bool SpaceIsClear();
    public bool ColliderIsPartOfTrain(Collider collider);
    public void UpdateClients();
    public void DecayTick();
    public virtual float GetDecayMinutes(bool hasPassengers);
    public virtual bool CanDieFromDecayNow();
    public bool AnyPlayersNearby(float maxDist);
    [RPC_Server]
public void RPC_WantsUncouple(RPCMessage msg);
}
public class TrainCarAudio : MonoBehaviour {
    [SerializeField]
[HeaderAttribute("Train Car Audio")]
private TrainCar trainCar;
    [SerializeField]
private SoundDefinition movementStartDef;
    [SerializeField]
private SoundDefinition movementStopDef;
    [SerializeField]
private SoundDefinition movementLoopDef;
    [SerializeField]
private AnimationCurve movementLoopGainCurve;
    [SerializeField]
private float movementChangeOneshotDebounce;
    private Sound movementLoop;
    private Modulator movementLoopGain;
    [SerializeField]
private SoundDefinition turnLoopDef;
    private Sound turnLoop;
    [SerializeField]
private SoundDefinition trackClatterLoopDef;
    [SerializeField]
private AnimationCurve trackClatterGainCurve;
    [SerializeField]
private AnimationCurve trackClatterPitchCurve;
    private Sound trackClatterLoop;
    private Modulator trackClatterGain;
    private Modulator trackClatterPitch;
}
public class TrainCarFuelHatches : MonoBehaviour {
    [SerializeField]
private TrainCar owner;
    [SerializeField]
private float animSpeed;
    [SerializeField]
private Transform hatch1Col;
    [SerializeField]
private Transform hatch1Vis;
    [SerializeField]
private Transform hatch2Col;
    [SerializeField]
private Transform hatch2Vis;
    [SerializeField]
private Transform hatch3Col;
    [SerializeField]
private Transform hatch3Vis;
    private static float closedXAngle;
    private static float openXAngle;
    [SerializeField]
private SoundDefinition hatchOpenSoundDef;
    [SerializeField]
private SoundDefinition hatchCloseSoundDef;
    private Vector3 _angles;
    private float _hatchLerp;
    private bool opening;
    private bool openingQueued;
    private bool isMoving;
    public void LinedUpStateChanged(bool linedUp);
    private void MoveTick();
    private void EndMove();
    private void SetAngleOnAll(float lerpT, bool closing);
    private void SetAngle(Transform transform, float angle);
}
public class TrainCarUnloadable : TrainCar {
    [HeaderAttribute("Train Car Unloadable")]
[SerializeField]
private GameObjectRef storagePrefab;
    [SerializeField]
private BoxCollider[] unloadingAreas;
    [SerializeField]
private TrainCarFuelHatches fuelHatches;
    [SerializeField]
private Transform orePlaneVisuals;
    [SerializeField]
private Transform orePlaneColliderDetailed;
    [SerializeField]
private Transform orePlaneColliderWorld;
    [RangeAttribute("0", "1")]
[SerializeField]
public float vacuumStretchPercent;
    [SerializeField]
private ParticleSystemContainer unloadingFXContainer;
    [SerializeField]
private ParticleSystem unloadingFX;
    public WagonType wagonType;
    private int lootTypeIndex;
    private List`1<EntityRef`1<LootContainer>> lootContainers;
    private Vector3 _oreScale;
    private float animPercent;
    private float prevAnimTime;
    [ServerVar]
public static float decayminutesafterunload;
    private EntityRef`1<StorageContainer> storageInstance;
    private static TrainCarUnloadable();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void OnFlagsChanged(Flags old, Flags next);
    protected virtual void OnChildAdded(BaseEntity child);
    public virtual void Load(LoadInfo info);
    public bool IsEmpty();
    public bool TryGetLootType(LootOption& lootOption);
    public virtual bool CanBeLooted(BasePlayer player);
    public int GetFilledLootAmount();
    public void SetVisualOreLevel(float percent);
    private void AnimateUnload(float startPercent);
    private void UnloadAnimTick();
    private void EndUnloadAnim();
    public float GetOrePercent();
    public virtual void Save(SaveInfo info);
    internal virtual void DoServerDestroy();
    public bool IsLinedUpToUnload(BoxCollider unloaderBounds);
    public void FillWithLoot(StorageContainer sc);
    public void EmptyOutLoot(StorageContainer sc);
    public void BeginUnloadAnimation();
    public void EndEmptyProcess();
    public StorageContainer GetStorageContainer();
    protected virtual float GetDecayMinutes(bool hasPassengers);
    protected virtual bool CanDieFromDecayNow();
    public virtual bool AdminFixUp(int tier);
    public float MinDistToUnloadingArea(Vector3 point);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Open(RPCMessage msg);
}
public class TrainCarUnloadableLoot : TrainCarUnloadable {
    [SerializeField]
private LootCrateSet[] lootLayouts;
    [SerializeField]
private Transform[] lootPositions;
    public virtual void Spawn();
}
public class TrainCoupling : object {
    public TrainCar owner;
    public bool isFrontCoupling;
    public TrainCouplingController controller;
    public Transform couplingPoint;
    public Transform couplingPivot;
    public Flags flag;
    public bool isValid;
    [CompilerGeneratedAttribute]
private TrainCoupling <CoupledTo>k__BackingField;
    public TimeSince timeSinceCouplingBlock;
    public bool IsCoupled { get; }
    public bool IsUncoupled { get; }
    public TrainCoupling CoupledTo { get; private set; }
    public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller);
    public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller, Transform couplingPoint, Transform couplingPivot, Flags flag);
    public bool get_IsCoupled();
    public bool get_IsUncoupled();
    [CompilerGeneratedAttribute]
public TrainCoupling get_CoupledTo();
    [CompilerGeneratedAttribute]
private void set_CoupledTo(TrainCoupling value);
    public bool IsCoupledTo(TrainCar them);
    public bool IsCoupledTo(TrainCoupling them);
    public bool TryCouple(TrainCoupling theirCoupling, bool reflect);
    public void Uncouple(bool reflect);
    public TrainCoupling GetOppositeCoupling();
    public bool TryGetCoupledToID(NetworkableId& id);
}
public class TrainCouplingController : object {
    public static Flags Flag_CouplingFront;
    public static Flags Flag_CouplingRear;
    public TrainCoupling frontCoupling;
    public TrainCoupling rearCoupling;
    private TrainCar owner;
    [ServerVar]
public static float max_couple_speed;
    public bool IsCoupled { get; }
    public bool IsFrontCoupled { get; }
    public bool IsRearCoupled { get; }
    public TrainCouplingController(TrainCar owner);
    private static TrainCouplingController();
    public bool get_IsCoupled();
    public bool get_IsFrontCoupled();
    public bool get_IsRearCoupled();
    public bool IsCoupledTo(TrainCar them);
    public bool TryCouple(TrainCar them, Location ourLocation);
    public void Uncouple(bool front);
    public void GetAll(List`1& result);
}
public class TrainEngine : TrainCar {
    [HeaderAttribute("Train Engine")]
[SerializeField]
public Transform leftHandLever;
    [SerializeField]
public Transform rightHandLever;
    [SerializeField]
public Transform leftHandGrip;
    [SerializeField]
public Transform rightHandGrip;
    [SerializeField]
private LeverStyle leverStyle;
    [SerializeField]
public Canvas monitorCanvas;
    [SerializeField]
public RustText monitorText;
    [SerializeField]
private LocomotiveExtraVisuals gauges;
    [SerializeField]
public float engineForce;
    [SerializeField]
public float maxSpeed;
    [SerializeField]
public float engineStartupTime;
    [SerializeField]
public GameObjectRef fuelStoragePrefab;
    [SerializeField]
public float idleFuelPerSec;
    [SerializeField]
public float maxFuelPerSec;
    [SerializeField]
public ProtectionProperties driverProtection;
    [SerializeField]
public bool lootablesAreOnPlatform;
    [SerializeField]
private bool mustMountFromPlatform;
    [SerializeField]
private VehicleLight[] onLights;
    [SerializeField]
public VehicleLight[] headlights;
    [SerializeField]
private VehicleLight[] notMovingLights;
    [SerializeField]
private VehicleLight[] movingForwardLights;
    [SerializeField]
[FormerlySerializedAsAttribute("movingBackwardsLights")]
private VehicleLight[] movingBackwardLights;
    [SerializeField]
public ParticleSystemContainer fxEngineOn;
    [SerializeField]
public ParticleSystemContainer fxLightDamage;
    [SerializeField]
public ParticleSystemContainer fxMediumDamage;
    [SerializeField]
public ParticleSystemContainer fxHeavyDamage;
    [SerializeField]
public ParticleSystemContainer fxEngineTrouble;
    [SerializeField]
public BoxCollider engineWorldCol;
    [SerializeField]
public float engineDamageToSlow;
    [SerializeField]
public float engineDamageTimeframe;
    [SerializeField]
public float engineSlowedTime;
    [SerializeField]
public float engineSlowedMaxVel;
    [SerializeField]
private ParticleSystemContainer[] sparks;
    [FormerlySerializedAsAttribute("brakeSparkLights")]
[SerializeField]
private Light[] sparkLights;
    [SerializeField]
private TrainEngineAudio trainAudio;
    public static Flags Flag_HazardAhead;
    public static Flags Flag_Horn;
    public static Flags Flag_AltColor;
    public static Flags Flag_EngineSlowed;
    public VehicleEngineController`1<TrainEngine> engineController;
    [CompilerGeneratedAttribute]
private EngineSpeeds <CurThrottleSetting>k__BackingField;
    public static float HAZARD_CHECK_EVERY;
    public static float HAZARD_DIST_MAX;
    public static float HAZARD_DIST_MIN;
    public static float HAZARD_SPEED_MIN;
    public float buttonHoldTime;
    public static EngineSpeeds MaxThrottle;
    public static EngineSpeeds MinThrottle;
    public EngineDamageOverTime engineDamage;
    public Vector3 engineLocalOffset;
    public int lastSentLinedUpToUnload;
    public bool LightsAreOn { get; }
    public bool CloseToHazard { get; }
    public bool EngineIsSlowed { get; }
    public EngineSpeeds CurThrottleSetting { get; public set; }
    public TrainCarType CarType { get; }
    public bool networkUpdateOnCompleteTrainChange { get; }
    private static TrainEngine();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_LightsAreOn();
    public bool get_CloseToHazard();
    public bool get_EngineIsSlowed();
    [CompilerGeneratedAttribute]
public EngineSpeeds get_CurThrottleSetting();
    [CompilerGeneratedAttribute]
public void set_CurThrottleSetting(EngineSpeeds value);
    public virtual TrainCarType get_CarType();
    public virtual void InitShared();
    public virtual void Load(LoadInfo info);
    public virtual bool CanBeLooted(BasePlayer player);
    public float GetEnginePowerMultiplier(float minPercent);
    public float GetThrottleFraction();
    public bool IsNearDesiredSpeed(float leeway);
    public virtual void SetTrackSelection(TrackSelection trackSelection);
    public void SetThrottle(EngineSpeeds throttle);
    public int GetFuelAmount();
    public bool CanMount(BasePlayer player);
    public virtual bool get_networkUpdateOnCompleteTrainChange();
    public virtual void ServerInit();
    public virtual void OnChildAdded(BaseEntity child);
    public virtual void VehicleFixedUpdate();
    public virtual void Save(SaveInfo info);
    public virtual IFuelSystem GetFuelSystem();
    public virtual void LightToggle(BasePlayer player);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat);
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public sealed virtual bool MeetsEngineRequirements();
    public sealed virtual void OnEngineStartFailed();
    public virtual void AttemptMount(BasePlayer player, bool doMountChecks);
    protected virtual float GetThrottleForce();
    public virtual bool HasThrottleInput();
    public virtual void Hurt(HitInfo info);
    public void StopEngine();
    public virtual Vector3 GetExplosionPos();
    public void IncreaseThrottle();
    public void DecreaseThrottle();
    public void SetZeroThrottle();
    public virtual void ServerFlagsChanged(Flags old, Flags next);
    public void CheckForHazards();
    public void OnEngineTookHeavyDamage();
    public void ResetEngineToNormal();
    public float GetCurTopSpeed();
    public float GetCurEngineForce();
    [RPC_Server]
public void RPC_OpenFuel(RPCMessage msg);
    private sealed virtual override void IEngineControllerUser.Invoke(Action action, float time);
    private sealed virtual override void IEngineControllerUser.CancelInvoke(Action action);
    [CompilerGeneratedAttribute]
private bool <PlayerServerInput>g__ProcessThrottleInput|83_0(BUTTON button, Action action, <>c__DisplayClass83_0& );
}
public class TrainEngineAudio : TrainCarAudio {
    [SerializeField]
private TrainEngine trainEngine;
    [SerializeField]
private Transform cockpitSoundPosition;
    [SerializeField]
private Transform hornSoundPosition;
    [HeaderAttribute("Engine")]
[SerializeField]
private SoundDefinition engineStartSound;
    [SerializeField]
private SoundDefinition engineStopSound;
    [SerializeField]
private SoundDefinition engineActiveLoopDef;
    [SerializeField]
private AnimationCurve engineActiveLoopPitchCurve;
    [SerializeField]
private float engineActiveLoopChangeSpeed;
    private Sound engineActiveLoop;
    private Modulator engineActiveLoopPitch;
    [SerializeField]
private BlendedLoopEngineSound engineLoops;
    [SerializeField]
private EngineReflection[] engineReflections;
    [SerializeField]
private LayerMask reflectionLayerMask;
    [SerializeField]
private float reflectionMaxDistance;
    [SerializeField]
private float reflectionGainChangeSpeed;
    [SerializeField]
private float reflectionPositionChangeSpeed;
    [SerializeField]
private float reflectionRayOffset;
    [SerializeField]
[HeaderAttribute("Horn")]
private SoundDefinition hornLoop;
    [SerializeField]
private SoundDefinition hornStart;
    [HeaderAttribute("Other")]
[SerializeField]
private SoundDefinition lightsToggleSound;
    [SerializeField]
private SoundDefinition proximityAlertDef;
    private Sound proximityAlertSound;
    [SerializeField]
private SoundDefinition damagedLoopDef;
    private Sound damagedLoop;
    [SerializeField]
private SoundDefinition changeThrottleDef;
    [SerializeField]
private SoundDefinition changeCouplingDef;
    [SerializeField]
private SoundDefinition unloadableStartDef;
    [SerializeField]
private SoundDefinition unloadableEndDef;
    [SerializeField]
private GameObject bellObject;
    [SerializeField]
private SoundDefinition bellRingDef;
    [SerializeField]
private SoundPlayer brakeSound;
}
public class TrainSignal : BaseEntity {
    [SerializeField]
private bool testFX;
    [SerializeField]
private VehicleLight redLight;
    [SerializeField]
private VehicleLight yellowLight;
    [SerializeField]
private VehicleLight greenLight;
    private static Flags Flag_Red;
    private static Flags Flag_Yellow;
    private static Flags Flag_Green;
    private LightState lightState;
    public TrainSignal nextSignal;
    private TrainTrackSpline ourSpline;
    private float ourSplineDist;
    private List`1<SplineSection> ourSplines;
    private LightState prevTargetLightState;
    public float SplineDist { get; }
    public bool HasNextSignal { get; }
    public virtual void OnFlagsChanged(Flags old, Flags next);
    private void SetLightState(LightState newState);
    public float get_SplineDist();
    public bool get_HasNextSignal();
    public virtual void ServerInit();
    private void SetUpSignal();
    internal virtual void DoServerDestroy();
    public void RefreshLightState();
    private bool HasOccupant();
    public bool IsForward();
    private void TestLights();
    private MoveResult ProcessSplineSection(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);
}
public class TrainTrackSpline : WorldSpline {
    [TooltipAttribute("Is this track spline part of a train station?")]
public bool isStation;
    [TooltipAttribute("Can above-ground trains spawn here?")]
public bool aboveGroundSpawn;
    public int hierarchy;
    public static List`1<TrainTrackSpline> SidingSplines;
    public List`1<ConnectedTrackInfo> nextTracks;
    public int straightestNextIndex;
    public List`1<ConnectedTrackInfo> prevTracks;
    public int straightestPrevIndex;
    public HashSet`1<ITrainTrackUser> trackUsers;
    public HashSet`1<TrainSignal> signals;
    public bool HasNextTrack { get; }
    public bool HasPrevTrack { get; }
    private static TrainTrackSpline();
    public bool get_HasNextTrack();
    public bool get_HasPrevTrack();
    public void SetAll(Vector3[] points, Vector3[] tangents, TrainTrackSpline sourceSpline);
    public MoveResult MoveAlongSpline(float prevSplineDist, Vector3 askerForward, float distMoved, TrackRequest tReq, SplineAction onSpline);
    private MoveResult MoveAlongSpline(MoveRequest request, bool facingForward, float prevDistMoved);
    private MoveResult MoveToNextSpline(MoveResult result, MoveRequest request, bool facingForward, float splineLength);
    private MoveResult MoveToPrevSpline(MoveResult result, MoveRequest request, bool facingForward);
    public float GetDistance(Vector3 position, float maxError, Single& minSplineDist);
    public float GetLength();
    public Vector3 GetPosition(float distance);
    public Vector3 GetPositionAndTangent(float distance, Vector3 askerForward, Vector3& tangent);
    public void AddTrackConnection(TrainTrackSpline track, TrackPosition p, TrackOrientation o);
    public void RegisterTrackUser(ITrainTrackUser user);
    public void DeregisterTrackUser(ITrainTrackUser user);
    public void RegisterSignal(TrainSignal signal);
    public void DeregisterSignal(TrainSignal signal);
    public bool IsForward(Vector3 askerForward, float askerSplineDist);
    public bool HasValidHazardWithin(TrainCar asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, float trackSpeed, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB);
    public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB);
    public bool HasAnyUsers();
    public bool HasAnyUsersOfType(TrainCarType carType);
    public bool HasConnectedTrack(TrainTrackSpline tts);
    public bool HasConnectedNextTrack(TrainTrackSpline tts);
    public bool HasConnectedPrevTrack(TrainTrackSpline tts);
    public static Vector3 GetInitialVector(TrainTrackSpline track, TrackPosition p, TrackOrientation o);
    protected virtual void OnDrawGizmosSelected();
    public ConnectedTrackInfo GetTrackSelection(List`1<ConnectedTrackInfo> trackOptions, int straightestIndex, bool nextTrack, bool trainForward, TrackRequest request);
    public static bool TryFindTrackNear(Vector3 pos, float maxDist, TrainTrackSpline& splineResult, Single& distResult);
}
[CreateAssetMenuAttribute]
public class TrainWagonLootData : ScriptableObject {
    [SerializeField]
private LootOption[] oreOptions;
    [ReadOnlyAttribute]
[SerializeField]
private LootOption lootWagonContent;
    [SerializeField]
private LootOption fuelWagonContent;
    private static TrainWagonLootData _instance;
    private static int LOOT_WAGON_INDEX;
    private static int FUEL_WAGON_INDEX;
    public static TrainWagonLootData instance { get; }
    public static TrainWagonLootData get_instance();
    public LootOption GetLootOption(WagonType wagonType, Int32& index);
    public bool TryGetLootFromIndex(int index, LootOption& lootOption);
    public bool TryGetIndexFromLoot(LootOption lootOption, Int32& index);
    public static float GetOrePercent(int lootTypeIndex, StorageContainer sc);
    public static float GetOrePercent(LootOption lootOption, StorageContainer sc);
}
public class TransformLineRenderer : MonoBehaviour {
    public Transform[] TransformSequence;
    public LineRenderer TargetRenderer;
}
public static class TransformUtil : object {
    public static bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, Transform ignoreTransform);
    public static bool GetGroundInfo(Vector3 startPos, RaycastHit& hit, float range, Transform ignoreTransform);
    public static bool GetGroundInfo(Vector3 startPos, RaycastHit& hitOut, float range, LayerMask mask, Transform ignoreTransform);
    public static bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, Transform ignoreTransform);
    public static bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, Transform ignoreTransform);
    public static bool GetGroundInfo(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask, Transform ignoreTransform);
    public static bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal);
    public static bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range);
    public static bool GetGroundInfoTerrainOnly(Vector3 startPos, Vector3& pos, Vector3& normal, float range, LayerMask mask);
    public static Transform[] GetRootObjects();
}
[CreateAssetMenuAttribute]
public class TrappableWildlife : ScriptableObject {
    public GameObjectRef worldObject;
    public ItemDefinition inventoryObject;
    public int minToCatch;
    public int maxToCatch;
    public List`1<BaitType> baitTypes;
    public int caloriesForInterest;
    public float successRate;
    public float xpScale;
}
public class TravellingVendor : BaseEntity {
    [HeaderAttribute("Visuals")]
public TravellingVendorVisuals visuals;
    [HeaderAttribute("Sounds")]
public TravellingVendorSounds sounds;
    public SoundPlayer BuySound;
    [HeaderAttribute("References")]
[SerializeField]
private VisualCarWheel wheelFL;
    [SerializeField]
private VisualCarWheel wheelFR;
    [SerializeField]
private VisualCarWheel wheelRL;
    [SerializeField]
private VisualCarWheel wheelRR;
    public float client_steering_left;
    public float client_steering_right;
    public Vector3 client_velocity;
    private WheelIsGroundedFlags client_wheel_flags;
    public TimeSince timeSinceLastUpdate;
    public VehicleLight headlight;
    public VehicleLight rearLights;
    public VehicleLight rearLeftIndicator;
    public VehicleLight rearRightIndicator;
    private static Collider[] spawncheckColliders;
    private static string prefabPath;
    [HeaderAttribute("General")]
public bool DoAI;
    public float ObstacleCheckTime;
    public float MarkerUpdateTime;
    public float TimeBetweenPullovers;
    [HeaderAttribute("Engine Config")]
public float motorForceConstant;
    public float brakeForceConstant;
    public float acceleration;
    [HeaderAttribute("Steer Config")]
public float wheelbase;
    public float rearTrack;
    public float steeringSmoothing;
    public float downforceCoefficient;
    public float maxSteerAngle;
    [HeaderAttribute("Trade")]
public GameObjectRef vendingMachineRef;
    public GameObjectRef vendingMachineFrontRef;
    [HeaderAttribute("Pullover")]
public float maxPulloverAngleDifference;
    [HeaderAttribute("Other")]
public static int obstacleMask;
    [HeaderAttribute("References")]
public GameObjectRef mapMarkerEntityPrefab;
    public GameObjectRef preventBuildingPrefab;
    public GameObjectRef backfireEffect;
    public Transform backfirePosition;
    private TriggerVehiclePush pusher;
    private TriggerPlayerForce forcer;
    public NPCVendingMachine vendingMachine;
    [HeaderAttribute("Spline")]
public float splineMovementSpeed;
    public Vector3 splineOffset;
    [ServerVar]
public static bool should_spawn;
    [ServerVar]
public static bool attempt_pullovers;
    [ServerVar]
public static float alive_time_seconds;
    [ServerVar]
public static bool should_destroy_buildings;
    [ReplicatedVar]
public static float max_speed;
    private float smoothedSteering;
    private float brakes;
    private float throttle;
    private float targetThrottle;
    private bool handbrake;
    private float steeringAngle;
    private float currentMaxSpeed;
    private Rigidbody myRigidbody;
    private List`1<RaycastHit> obstacleHits;
    private List`1<RaycastHit> pulloverHits;
    private Vector3 destination;
    private bool instantLeave;
    private float waitTimeAccumulator;
    private float aliveTimer;
    private TimeSince timeSinceBackfire;
    private bool pullingOver;
    private Vector3 pulloverPosition;
    private float pullOverTimer;
    private Vector3 pulloverTangent;
    private bool overrideSteering;
    private BaseEntity preventBuildingInstance;
    private RaycastHit hit;
    private TravellingVendorState internalState;
    private WheelIsGroundedFlags wheelFlags;
    private SimpleSplineTranslator splineTranslator;
    private MapMarker mapMarkerInstance;
    private bool globaIndicatorLeft;
    private TimeSince timeSincePlayerDetected;
    private float slowdownStartSpeed;
    private List`1<Vector3> currentPath;
    private int currentPathIndex;
    private float atDestinationDistance;
    private bool followingSpine;
    private int splineId;
    private WorldSpline spline;
    private ListDictionary`2<BasePlayer, VendorTargetInfo> playerRecords;
    private List`1<BasePlayer> localPlayers;
    private int searchRange;
    private float allowedVendorBlockTime;
    public Vector3 Velocity { get; }
    public float DriveWheelVelocity { get; }
    public float SteerAngle { get; }
    public float MaxSteerAngle { get; }
    protected bool PositionTickFixedTime { get; }
    private static TravellingVendor();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public sealed virtual Vector3 get_Velocity();
    public sealed virtual float get_DriveWheelVelocity();
    public sealed virtual float get_SteerAngle();
    public sealed virtual float get_MaxSteerAngle();
    public sealed virtual float GetThrottleInput();
    [ServerVar]
public static string svspawntravellingvendor(Arg args);
    [ServerVar]
public static string svspawntravellingvendorevent(Arg args);
    public static TravellingVendor SpawnTravellingVendor(Vector3 position);
    private static ValueTuple`2<Vector3, int> FindFarthestPointFromPlayers(Vector3[] points, List`1<BasePlayer> players);
    private static int FindRandomPointIndexBeyondThreshold(Vector3[] points, List`1<BasePlayer> players, float distanceThreshold, List`1<int> validIndices);
    public static TravellingVendor SpawnTravellingVendorForEvent();
    private static bool CheckSpawnPosition(Vector3 testPosition);
    protected virtual void OnChildAdded(BaseEntity child);
    [IsVisible("3")]
[RPC_Server]
public void SV_OpenMenu(RPCMessage msg);
    public virtual float GetNetworkTime();
    protected virtual bool get_PositionTickFixedTime();
    public virtual bool IsDebugging();
    public virtual void OnAttacked(HitInfo info);
    public void CreateMapMarker();
    public void CreatePreventBuilding();
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    internal virtual void DoServerDestroy();
    private void StartBackfire();
    private void StartHorn();
    private void FixedUpdate();
    private void ProcessHandbrake();
    private void SetGlobalIndicator();
    private void TurnOffIndicators();
    private void UpdateMarker();
    private void NightCheck();
    private void ProcessLifetime();
    private void ProcessState();
    private void HandlePullover();
    private void SetPulloverWaiting();
    private bool FindPullingOverSpot();
    private Vector3 GetAdjustedPulloverPoint(bool onLeft);
    private bool TryFindClearPulloverPoint(bool onLeft, Vector3& testedPosition);
    private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront);
    private bool IsPositionClear(Vector3 position, float radiusCheck);
    private bool IsDirectionClear(Vector3 direction, Vector3 point);
    private Vector3 GetTerrainNormal(Vector3 testPos);
    private void SetWaiting();
    private void SetTravelling();
    private void AdvancePath();
    private int GetPathIndexAhead(int ahead);
    private void ResetPullover();
    private float GetWaitAccumulator();
    public void ScaleSidewaysFriction(float scale);
    private void ApplyDownforce();
    private void UpdateWheelFlags();
    private void BuildingCheck();
    private bool CheckForObstacle();
    private void UpdateObstacles();
    private void UpdateObstacleList(List`1<RaycastHit> hits, Vector3 forward, float checkRadius);
    private void DoSteering();
    private void ApplyForceAtWheels();
    private void ApplyBrakesAtWheels();
    private float CalculateSteeringAngle(float radius);
    private void HandleSplineMovement();
    private void TravelOnSpline();
    private void SlowOnSpline();
    private void StopSplineMovement();
    public sealed virtual void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction);
    public sealed virtual void OnBasePathTrigger(int pathId, BasePath path);
    private void CheckForSplineStart();
    public void InstallPath(RuntimePath path, int initialDestination);
    private bool HasPath();
    private bool IsFollowingSpline();
    private void ClearPath();
    private bool IndexValid(int index);
    private Vector3 GetCurrentPathDestination();
    private bool PathComplete();
    public void SetDestination(Vector3 dest, float destinationDistance);
    public bool AtDestination();
    private int FindClosestNode();
    private void FetchTargets();
    private void FetchCycle(List`1<BaseEntity> foundEntities);
    private bool IsInvalidPlayer(BasePlayer player);
    private void IgnorePlayer(BasePlayer player);
    private bool IsValidPatrons();
    private bool IsPlayerIgnored(BasePlayer player);
}
public class TravellingVendorEvent : TriggeredEvent {
    public Phrase spawnPhrase;
    public static TravellingVendor currentVendor;
    public static float dontSpawnHoursBeforeWipe;
    private static TravellingVendorEvent();
    public virtual void RunEvent();
    private bool HoursCheck();
}
public class TravellingVendorSounds : MonoBehaviour {
    [HeaderAttribute("Engine")]
[SerializeField]
private EngineAudioSet EngineAudioSet;
    [SerializeField]
private BlendedLoopEngineSound blendedEngineLoops;
    [SerializeField]
private float engineRPMThrottleWeight;
    [SerializeField]
private float engineRPMThrottleSpeedWeight;
    [SerializeField]
private float engineRPMSpeedWeight;
    [SerializeField]
private float wheelRatioMultiplier;
    [SerializeField]
private SoundDefinition missGearSoundDef;
    [SerializeField]
private float gearMissCooldown;
    [HeaderAttribute("Suspension")]
[SerializeField]
private SoundDefinition suspensionDef;
    [SerializeField]
private float suspensionMinTimeBetweenSounds;
    [SerializeField]
private float suspensionUpAngleDeltaThreshold;
    [SerializeField]
private AnimationCurve suspensionDeltaSpeedGain;
    [SerializeField]
private AnimationCurve suspensionUpAngleDeltaGain;
    [HeaderAttribute("Tires")]
[SerializeField]
private SoundDefinition tireDirtSoundDef;
    [SerializeField]
private SoundDefinition tireGrassSoundDef;
    [SerializeField]
private SoundDefinition tireSnowSoundDef;
    [SerializeField]
private SoundDefinition tireWaterSoundDef;
    [SerializeField]
private AnimationCurve tireGainCurve;
    [HeaderAttribute("Movement")]
[SerializeField]
private SoundDefinition movementLoopDef;
    [SerializeField]
private AnimationCurve movementLoopGainCurve;
    [HeaderAttribute("Brakes")]
[SerializeField]
private SoundDefinition brakeLoopDef;
    [SerializeField]
private SoundDefinition brakeHissDef;
    [SerializeField]
private float brakeHissCooldown;
    [SerializeField]
[HeaderAttribute("Misc")]
private SoundDefinition angryHornSoundDef;
    [SerializeField]
private SoundDefinition musicLoopSoundDef;
}
public class TravellingVendorVisuals : VehicleChassisVisuals`1<TravellingVendor> {
    [HeaderAttribute("References")]
public Transform frontAxle;
    public Steering steering;
    public LookAtTarget transmission;
    [HeaderAttribute("Settings")]
public float wheelTurnLerpSpeed;
}
public class TreadAnimator : MonoBehaviour {
    public Animator mainBodyAnimator;
    public Transform[] wheelBones;
    public Vector3[] vecShocksOffsetPosition;
    public Vector3[] wheelBoneOrigin;
    public float wheelBoneDistMax;
    public Material leftTread;
    public Material rightTread;
    public TreadEffects treadEffects;
    public float traceThickness;
    public float heightFudge;
    public bool useWheelYOrigin;
    public Vector2 treadTextureDirection;
    public bool isMetallic;
    public float angularTreadConstant;
    public float treadConstant;
    public float wheelSpinConstant;
    public float traceLineMin;
    public float traceLineMax;
    public float maxShockDist;
}
public class TreadEffects : MonoBehaviour {
    public ParticleSystem[] rearTreadDirt;
    public ParticleSystem[] rearTreadSmoke;
    public ParticleSystem[] middleTreadSmoke;
}
[ExecuteInEditMode]
public class TreeEntity : ResourceEntity {
    [HeaderAttribute("Falling")]
public bool fallOnKilled;
    public float fallDuration;
    public GameObjectRef fallStartSound;
    public GameObjectRef fallImpactSound;
    public GameObjectRef fallImpactParticles;
    public SoundDefinition fallLeavesLoopDef;
    public Boolean[] usedHeights;
    public bool impactSoundPlayed;
    private float treeDistanceUponFalling;
    public GameObjectRef prefab;
    public bool hasBonusGame;
    public GameObjectRef bonusHitEffect;
    public GameObjectRef bonusHitSound;
    public Collider serverCollider;
    public Collider clientCollider;
    public SoundDefinition smallCrackSoundDef;
    public SoundDefinition medCrackSoundDef;
    private float lastAttackDamage;
    public BaseEntity xMarker;
    private int currentBonusLevel;
    private float lastDirection;
    private float lastHitTime;
    private int lastHitMarkerIndex;
    private float nextBirdTime;
    private UInt32 birdCycleIndex;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual float BoundsPadding();
    public virtual void OnAttacked(HitInfo info);
    public virtual void ServerInit();
    public virtual void ServerInitPostNetworkGroupAssign();
    internal virtual void DoServerDestroy();
    public bool DidHitMarker(HitInfo info);
    public void StartBonusGame();
    public void StopBonusGame();
    public bool BonusActive();
    private void DoBirds();
    public void CleanupMarker();
    public virtual void OnKilled(HitInfo info);
    public void DelayedKill();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class TreeLOD : LODComponent {
    [HorizontalAttribute("1", "0")]
public State[] States;
}
public class TreeManager : BaseEntity {
    public static ListHashSet`1<BaseEntity> entities;
    public static TreeManager server;
    private static TreeManager();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public static Vector3 ProtoHalf3ToVec3(Half3 half3);
    public static Half3 Vec3ToProtoHalf3(Vector3 vec3);
    public int GetTreeCount();
    public virtual void ServerInit();
    public static void OnTreeDestroyed(BaseEntity billboardEntity);
    public static void OnTreeSpawned(BaseEntity billboardEntity);
    private static void ExtractTreeNetworkData(BaseEntity billboardEntity, Tree tree);
    public static void SendSnapshot(BasePlayer player);
    [CallsPerSecond("0")]
[RPC_Server]
private void SERVER_RequestTrees(RPCMessage msg);
}
public class TreeMarker : BaseEntity {
    public GameObjectRef hitEffect;
    public SoundDefinition hitEffectSound;
    public GameObjectRef spawnEffect;
    private Vector3 initialPosition;
    public bool SpherecastOnInit;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
}
public class TreeMarkerData : PrefabAttribute {
    public GenerationArc[] GenerationArcs;
    public MarkerLocation[] Markers;
    public Vector3 GenerationStartPoint;
    public float GenerationRadius;
    public float MaxY;
    public float MinY;
    public bool ProcessAngleChecks;
    protected virtual Type GetIndexedType();
    public Vector3 GetNearbyPoint(Vector3 point, Int32& ignoreIndex, Vector3& normal);
}
public class TreeMesh : MonoBehaviour {
}
public class TriangleIdentifier : MonoBehaviour {
    public int TriangleID;
    public int SubmeshID;
    public float LineLength;
    private void OnDrawGizmosSelected();
}
public class TriggerAchievement : TriggerBase {
    public string statToIncrease;
    public string achievementOnEnter;
    public string requiredVehicleName;
    [TooltipAttribute("Always set to true, clientside does not work, currently")]
public bool serverSide;
    public bool allowDuringTutorial;
    private List`1<ulong> triggeredPlayers;
    public void OnPuzzleReset();
    public void Reset();
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnEntityEnter(BaseEntity ent);
}
public class TriggerAnalytic : TriggerBase {
    public string AnalyticMessage;
    public float Timeout;
    private List`1<RecentPlayerEntrance> recentEntrances;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
    private void CheckTimeouts();
    private bool IsPlayerValid(BasePlayer p);
}
public class TriggerBanditZone : TriggerBase {
    public float GetBanditZoneLevel(Vector3 pos);
}
public class TriggerBase : BaseMonoBehaviour {
    public LayerMask interestLayers;
    public HashSet`1<GameObject> contents;
    public HashSet`1<BaseEntity> entityContents;
    public Action`1<BaseNetworkable> OnEntityEnterTrigger;
    public Action`1<BaseNetworkable> OnEntityLeaveTrigger;
    public bool HasAnyContents { get; }
    public bool HasAnyEntityContents { get; }
    public bool get_HasAnyContents();
    public bool get_HasAnyEntityContents();
    public virtual GameObject InterestedInObject(GameObject obj);
    protected virtual void OnDisable();
    public virtual void OnEntityEnter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
    public virtual void OnObjectAdded(GameObject obj, Collider col);
    public virtual void OnObjectRemoved(GameObject obj);
    public void RemoveInvalidEntities();
    public bool CheckEntity(BaseEntity ent);
    public virtual void OnObjects();
    public virtual void OnEmpty();
    public void RemoveObject(GameObject obj);
    public void RemoveEntity(BaseEntity ent);
    public void OnTriggerEnter(Collider collider);
    internal virtual bool SkipOnTriggerExit(Collider collider);
    public void OnTriggerExit(Collider collider);
    public void OnTriggerExitImpl(GameObject targetObj);
}
public class TriggerClanModify : TriggerBase {
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerComfort : TriggerBase {
    public float triggerSize;
    public float baseComfort;
    public float minComfortRange;
    private static float perPlayerComfortBonus;
    private static float bonusComfort;
    private List`1<BasePlayer> _players;
    private void OnValidate();
    public virtual GameObject InterestedInObject(GameObject obj);
    public float CalculateComfort(Vector3 position, BasePlayer forPlayer);
    public virtual void OnEntityEnter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
}
public class TriggerDanceAchievement : TriggerBase {
    public int RequiredPlayerCount;
    public string AchievementName;
    private List`1<NetworkableId> triggeredPlayers;
    public void OnPuzzleReset();
    public void Reset();
    internal virtual GameObject InterestedInObject(GameObject obj);
    public void NotifyDanceStarted();
}
public class TriggeredEvent : MonoBehaviour {
    public virtual void RunEvent();
    public virtual void Kill();
}
public class TriggeredEventPrefab : TriggeredEvent {
    public GameObjectRef targetPrefab;
    public bool shouldBroadcastSpawn;
    public Phrase spawnPhrase;
    public BaseEntity spawnedEntity;
    public virtual void RunEvent();
    public virtual void Kill();
}
public class TriggerEnsnare : TriggerBase {
    public bool blockHands;
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerForce : TriggerBase {
    public static float GravityMultiplier;
    public static float VelocityLerp;
    public static float AngularDrag;
    public Vector3 velocity;
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnEntityEnter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
    protected void FixedUpdate();
}
public class TriggerHurt : TriggerBase {
    public float DamagePerSecond;
    public float DamageTickRate;
    public DamageType damageType;
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnObjects();
    public virtual void OnEmpty();
    private void OnTick();
    protected virtual bool CanHurt(BaseCombatEntity ent);
}
public class TriggerHurtEx : TriggerBase {
    public float repeatRate;
    [HeaderAttribute("On Enter")]
public List`1<DamageTypeEntry> damageOnEnter;
    public GameObjectRef effectOnEnter;
    public HurtType hurtTypeOnEnter;
    [HeaderAttribute("On Timer (damage per second)")]
public List`1<DamageTypeEntry> damageOnTimer;
    public GameObjectRef effectOnTimer;
    public HurtType hurtTypeOnTimer;
    [HeaderAttribute("On Move (damage per meter)")]
public List`1<DamageTypeEntry> damageOnMove;
    public GameObjectRef effectOnMove;
    public HurtType hurtTypeOnMove;
    [HeaderAttribute("On Leave")]
public List`1<DamageTypeEntry> damageOnLeave;
    public GameObjectRef effectOnLeave;
    public HurtType hurtTypeOnLeave;
    public bool damageEnabled;
    internal Dictionary`2<BaseEntity, EntityTriggerInfo> entityInfo;
    internal List`1<BaseEntity> entityAddList;
    internal List`1<BaseEntity> entityLeaveList;
    public virtual GameObject InterestedInObject(GameObject obj);
    internal void DoDamage(BaseEntity ent, HurtType type, List`1<DamageTypeEntry> damage, GameObjectRef effect, float multiply);
    public virtual void OnEntityEnter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
    public virtual void OnObjects();
    public virtual void OnEmpty();
    private void OnTick();
    private void ProcessQueues();
}
public class TriggerHurtNotChild : TriggerBase {
    public float DamagePerSecond;
    public float DamageTickRate;
    public float DamageDelay;
    public DamageType damageType;
    public bool ignoreNPC;
    public float npcMultiplier;
    public float resourceMultiplier;
    public bool triggerHitImpacts;
    public bool RequireUpAxis;
    public BaseEntity SourceEntity;
    public bool UseSourceEntityDamageMultiplier;
    public bool ignoreAllVehicleMounted;
    public float activationDelay;
    private Dictionary`2<BaseEntity, float> entryTimes;
    private TimeSince timeSinceAcivation;
    private IHurtTriggerUser hurtTiggerUser;
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnObjects();
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
    public virtual void OnEmpty();
    protected void OnEnable();
    public void OnDisable();
    private bool IsInterested(BaseEntity ent);
    private void OnTick();
}
public class TriggerLadder : TriggerBase {
    public LadderType Type;
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerMagnet : TriggerBase {
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerMission : TriggerBase {
    private BasePlayer cachedPlayer;
    internal virtual void OnEntityEnter(BaseEntity ent);
    private void DelayedEntityCallback();
}
public class TriggerMount : TriggerBase {
    private static float MOUNT_DELAY;
    private static float MAX_MOVE;
    private Dictionary`2<BaseEntity, EntryInfo> entryInfo;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
    private void CheckForMount();
}
public class TriggerMovement : TriggerBase {
    [TooltipAttribute("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
public Transform losEyes;
    public MovementModify movementModify;
}
[RequireComponent("UnityEngine.SphereCollider")]
public class TriggerNoRespawnZone : TriggerBase {
    public static List`1<TriggerNoRespawnZone> allNRZones;
    public float maxDepth;
    public float maxAltitude;
    private SphereCollider sphereCollider;
    private float radiusSqr;
    private static TriggerNoRespawnZone();
    protected void Awake();
    protected void OnEnable();
    protected virtual void OnDisable();
    internal virtual GameObject InterestedInObject(GameObject obj);
    public static bool InAnyNoRespawnZone(Vector3 theirPos);
    public bool InNoRespawnZone(Vector3 theirPos, bool checkRadius);
}
public class TriggerNoSpray : TriggerBase {
    public BoxCollider TriggerCollider;
    private OBB cachedBounds;
    private Transform cachedTransform;
    private void OnEnable();
    internal virtual GameObject InterestedInObject(GameObject obj);
    public bool IsPositionValid(Vector3 worldPosition);
}
public class TriggerNotify : TriggerBase {
    public GameObject notifyTarget;
    private INotifyTrigger toNotify;
    public bool runClientside;
    public bool runServerside;
    public bool HasContents { get; }
    public bool get_HasContents();
    internal virtual void OnObjects();
    internal virtual void OnEmpty();
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
public class TriggerNotifyEntity : TriggerBase {
    public GameObject notifyTarget;
    private INotifyEntityTrigger toNotify;
    public bool runClientside;
    public bool runServerside;
    public bool HasContents { get; }
    public bool get_HasContents();
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
    public sealed virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
}
[RequireComponent("UnityEngine.Collider")]
public class TriggerParent : TriggerBase {
    [SerializeField]
[TooltipAttribute("Deparent if the parented entity clips into an obstacle")]
public bool doClippingCheck;
    [TooltipAttribute("If deparenting via clipping, this will be used (if assigned) to also move the entity to a valid dismount position")]
public BaseMountable associatedMountable;
    [TooltipAttribute("Needed if the player might dismount inside the trigger and the trigger might be moving. Being mounting inside the trigger lets them dismount in local trigger-space, which means client and server will sync up.Otherwise the client/server delay can have them dismounting into invalid space.")]
public bool parentMountedPlayers;
    [TooltipAttribute("Sleepers don't have all the checks (e.g. clipping) that awake players get. If that might be a problem,sleeper parenting can be disabled. You'll need an associatedMountable though so that the sleeper can be dismounted.")]
public bool parentSleepers;
    public bool ParentNPCPlayers;
    [TooltipAttribute("If the player is already parented to something else, they'll switch over to another parent only if this is true")]
public bool overrideOtherTriggers;
    [TooltipAttribute("Requires associatedMountable to be set. Prevents players entering the trigger if there's something between their feet and the bottom of the parent trigger")]
public bool checkForObjUnderFeet;
    public static int CLIP_CHECK_MASK;
    protected float triggerHeight;
    private BasePlayer killPlayerTemp;
    protected void Awake();
    public virtual GameObject InterestedInObject(GameObject obj);
    public virtual void OnEntityEnter(BaseEntity ent);
    public virtual void OnEntityLeave(BaseEntity ent);
    public virtual bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck);
    public void ForceParentEarly(BaseEntity ent);
    private void CheckAllParenting();
    protected void Parent(BaseEntity ent);
    protected void Unparent(BaseEntity ent);
    private bool IsParentedToUs(BaseEntity ent);
    private void KillPlayerDelayed();
    private void OnTick();
    protected virtual bool IsClipping(BaseEntity ent);
    private bool HasObjUnderFeet(BaseEntity ent);
}
public class TriggerParentElevator : TriggerParentEnclosed {
    public bool AllowHorsesToBypassClippingChecks;
    public bool AllowBikesToBypassClippingChecks;
    public bool IgnoreParentEntityColliders;
    protected virtual bool IsClipping(BaseEntity ent);
}
public class TriggerParentEnclosed : TriggerParent {
    public float Padding;
    [TooltipAttribute("AnyIntersect: Look for any intersection with the trigger. OriginIntersect: Only consider objects in the trigger if their origin is inside")]
public TriggerMode intersectionMode;
    public bool CheckBoundsOnUnparent;
    public BoxCollider boxCollider;
    protected void OnEnable();
    public virtual bool ShouldParent(BaseEntity ent, bool bypassOtherTriggerCheck);
    internal virtual bool SkipOnTriggerExit(Collider collider);
    public bool IsInside(BaseEntity ent, float padding);
}
public class TriggerParentExclusion : TriggerBase {
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerPath : TriggerBase {
    public int pathTriggerId;
    [HeaderAttribute("Path")]
public BasePath path;
    [HeaderAttribute("Spline")]
public WorldSpline spline;
    public int splineDirection;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
}
public class TriggerPlayerForce : TriggerBase {
    public BoxCollider triggerCollider;
    public float pushVelocity;
    public bool requireUpAxis;
    private static float HACK_DISABLE_TIME;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnObjects();
    internal virtual void OnEmpty();
    protected virtual void OnDisable();
    internal virtual void OnEntityLeave(BaseEntity ent);
    private void HackDisableTick();
    protected void FixedUpdate();
    private Vector3 GetPushVelocity(GameObject obj);
    private bool IsInterested(BaseEntity entity);
}
public class TriggerPlayerTimer : TriggerBase {
    public BaseEntity TargetEntity;
    public float DamageAmount;
    public float TimeToDamage;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnObjects();
    internal virtual void OnEmpty();
    private void DamageTarget();
}
public class TriggerRadiation : TriggerBase {
    public Tier radiationTier;
    public bool BypassArmor;
    public float RadiationAmountOverride;
    public float falloff;
    public bool UseColliderRadius;
    public bool UseLOSCheck;
    public bool ApplyLocalHeightCheck;
    public float MinLocalHeight;
    private SphereCollider sphereCollider;
    private float GetRadiationSize();
    private float GetTriggerRadiation();
    public float GetRadiation(Vector3 position, float radProtection);
    public virtual GameObject InterestedInObject(GameObject obj);
    public void OnDrawGizmosSelected();
}
public class TriggerRagdollRelocate : TriggerBase {
    public Transform targetLocation;
    internal virtual void OnObjectAdded(GameObject obj, Collider col);
    private void RepositionTransform(Transform t);
}
public class TriggerResetter : StateMachineBehaviour {
    public string triggerName;
    public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
}
public class TriggerSafeZone : TriggerBase {
    public static List`1<TriggerSafeZone> allSafeZones;
    public float maxDepth;
    public float maxAltitude;
    [CompilerGeneratedAttribute]
private Collider <triggerCollider>k__BackingField;
    public Collider triggerCollider { get; private set; }
    private static TriggerSafeZone();
    [CompilerGeneratedAttribute]
public Collider get_triggerCollider();
    [CompilerGeneratedAttribute]
private void set_triggerCollider(Collider value);
    protected void Awake();
    protected void OnEnable();
    protected virtual void OnDisable();
    internal virtual GameObject InterestedInObject(GameObject obj);
    public bool PassesHeightChecks(Vector3 entPos);
    public float GetSafeLevel(Vector3 pos);
}
public class TriggerSnowmobileAchievement : TriggerBase {
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerStashPlayer : TriggerBase {
    public StashContainer Stash;
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
}
public class TriggerSubmarineMoonpool : TriggerBase {
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
}
public class TriggerTemperature : TriggerBase {
    public float Temperature;
    public float triggerSize;
    public float minSize;
    public bool sunlightBlocker;
    public float sunlightBlockAmount;
    [RangeAttribute("0", "24")]
public float blockMinHour;
    [RangeAttribute("0", "24")]
public float blockMaxHour;
    private void OnValidate();
    public float WorkoutTemperature(Vector3 position, float oldTemperature);
    public virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerTrainCollisions : TriggerBase {
    public Collider triggerCollider;
    public Location location;
    public TrainCar owner;
    public HashSet`1<GameObject> staticContents;
    public HashSet`1<TrainCar> trainContents;
    public HashSet`1<Rigidbody> otherRigidbodyContents;
    public HashSet`1<Collider> colliderContents;
    private static float TICK_RATE;
    public bool HasAnyStaticContents { get; }
    public bool HasAnyTrainContents { get; }
    public bool HasAnyOtherRigidbodyContents { get; }
    public bool HasAnyNonStaticContents { get; }
    public bool get_HasAnyStaticContents();
    public bool get_HasAnyTrainContents();
    public bool get_HasAnyOtherRigidbodyContents();
    public bool get_HasAnyNonStaticContents();
    internal virtual void OnObjectAdded(GameObject obj, Collider col);
    internal virtual void OnObjectRemoved(GameObject obj);
    private void TrainContentsTick();
    [CompilerGeneratedAttribute]
private bool <OnObjectRemoved>g__HasAnotherColliderFor|18_0(T component);
}
public class TriggerTutorialPrompt : TriggerBase {
    public TutorialFullScreenHelpInfo ToDisplay;
    public BaseMission RequiredMission;
    public int RequiredMissionStageActive;
    public bool OnlyShowOnce;
    public CustomCloseAction CloseAction;
    public bool DebugConditions;
    public bool DeathDisplay;
}
public class TriggerVehicleDrag : TriggerBase {
    [TooltipAttribute("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
public Transform losEyes;
    public float vehicleDrag;
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerVehiclePush : TriggerBase {
    public BaseEntity thisEntity;
    public float maxPushVelocity;
    public float minRadius;
    public float maxRadius;
    public bool snapToAxis;
    public Vector3 axisToSnapTo;
    public bool allowParentRigidbody;
    public bool useRigidbodyPosition;
    public bool useCentreOfMass;
    public int ContentsCount { get; }
    public virtual GameObject InterestedInObject(GameObject obj);
    public int get_ContentsCount();
    public void FixedUpdate();
    public void OnDrawGizmosSelected();
}
public class TriggerWakeAIZ : TriggerBase {
    public float SleepDelaySeconds;
    public List`1<AIInformationZone> zones;
    private AIInformationZone aiz;
    public void Init(AIInformationZone zone);
    private void Awake();
    private void SetZonesSleeping(bool flag);
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
    private void DelayedSleepAI();
    private void SleepAI();
}
public class TriggerWetness : TriggerBase {
    public float Wetness;
    public SphereCollider TargetCollider;
    public Transform OriginTransform;
    public bool ApplyLocalHeightCheck;
    public float MinLocalHeight;
    public float WorkoutWetness(Vector3 position);
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class TriggerWorkbench : TriggerBase {
    public Workbench parentBench;
    public virtual GameObject InterestedInObject(GameObject obj);
    public float WorkbenchLevel();
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
}
public class trisPerSubmesh : object {
    public Int32[] triangles;
}
public class Tugboat : MotorRowboat {
    [HeaderAttribute("Tugboat")]
[SerializeField]
private Canvas monitorCanvas;
    [SerializeField]
private RustText fuelText;
    [SerializeField]
private RustText speedText;
    [SerializeField]
private ParticleSystemContainer exhaustEffect;
    [SerializeField]
private SoundDefinition lightsToggleSound;
    [SerializeField]
private Transform steeringWheelLeftHandTarget;
    [SerializeField]
private Transform steeringWheelRightHandTarget;
    [SerializeField]
private SonarSystem sonar;
    [SerializeField]
private TugboatSounds tugboatSounds;
    [SerializeField]
private CanvasGroup canvasGroup;
    [SerializeField]
private EmissionToggle emissionToggle;
    [SerializeField]
private AnimationCurve emissionCurve;
    [SerializeField]
private ParticleSystemContainer fxLightDamage;
    [SerializeField]
private ParticleSystemContainer fxMediumDamage;
    [SerializeField]
private ParticleSystemContainer fxHeavyDamage;
    [SerializeField]
private GameObject heavyDamageLights;
    [SerializeField]
private TriggerParent parentTrigger;
    [ServerVar]
[HelpAttribute("how long until boat corpses despawn (excluding tugboat)")]
public static float tugcorpseseconds;
    [ServerVar]
public static float tugdecayminutes;
    [ServerVar]
public static float tugdecaystartdelayminutes;
    public bool LightsAreOn { get; }
    protected bool AllowKinematicDrift { get; }
    private static Tugboat();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool get_LightsAreOn();
    public virtual void Load(LoadInfo info);
    public virtual float MaxVelocity();
    protected virtual bool get_AllowKinematicDrift();
    public virtual void VehicleFixedUpdate();
    public virtual void Save(SaveInfo info);
    public virtual void BoatDecay();
    public virtual int StartingFuelUnits();
    public virtual void LightToggle(BasePlayer player);
    protected virtual void EnterCorpseState();
    public virtual bool AnyPlayersOnBoat();
    public virtual bool BuoyancySleep(bool inWater);
    public virtual bool BuoyancyWake();
    public virtual bool SupportsChildDeployables();
    public virtual bool ForceDeployableSetParent();
    protected virtual bool CanPushNow(BasePlayer pusher);
}
public class TugboatInteriorSoundTrigger : MonoBehaviour {
    public TugboatSounds tugboatSounds;
    public bool bridge;
}
public class TugboatSounds : MonoBehaviour {
    [SerializeField]
private Tugboat tugboat;
    [SerializeField]
private float roughHalfWidth;
    [SerializeField]
private float roughHalfLength;
    private float soundCullDistanceSq;
    [HeaderAttribute("Engine")]
[SerializeField]
private SoundDefinition engineLoopDef;
    private Sound engineLoop;
    private Modulator engineGainMod;
    private Modulator enginePitchMod;
    [SerializeField]
private SoundDefinition engineStartDef;
    [SerializeField]
private SoundDefinition engineStartBridgeDef;
    [SerializeField]
private SoundDefinition engineStopDef;
    [SerializeField]
private SoundDefinition engineStopBridgeDef;
    [SerializeField]
private float engineGainChangeRate;
    [SerializeField]
private float enginePitchChangeRate;
    [SerializeField]
private Transform engineTransform;
    [SerializeField]
private Transform bridgeControlsTransform;
    [HeaderAttribute("Water")]
[SerializeField]
private SoundDefinition waterIdleDef;
    [SerializeField]
private SoundDefinition waterSideMovementSlowDef;
    [SerializeField]
private SoundDefinition waterSideMovementFastDef;
    [SerializeField]
private SoundDefinition waterSternMovementDef;
    [SerializeField]
private SoundDefinition waterInteriorIdleDef;
    [SerializeField]
private SoundDefinition waterInteriorDef;
    [SerializeField]
private AnimationCurve waterMovementGainCurve;
    [SerializeField]
private float waterMovementGainChangeRate;
    [SerializeField]
private AnimationCurve waterDistanceGainCurve;
    private Sound leftWaterSound;
    private Modulator leftWaterGainMod;
    private Sound rightWaterSound;
    private Modulator rightWaterGainMod;
    private Sound sternWaterSound;
    private Modulator sternWaterGainMod;
    [SerializeField]
private Transform wakeTransform;
    [SerializeField]
private Vector3 sideSoundLineStern;
    [SerializeField]
private Vector3 sideSoundLineBow;
    [HeaderAttribute("Ambient")]
private Sound ambientIdleSound;
    [SerializeField]
private SoundDefinition ambientActiveLoopDef;
    private Sound ambientActiveSound;
    [SerializeField]
private SoundDefinition hullGroanDef;
    [SerializeField]
private float hullGroanCooldown;
    private float lastHullGroan;
    [SerializeField]
private SoundDefinition chainRattleDef;
    [SerializeField]
private float chainRattleCooldown;
    [SerializeField]
private Transform[] chainRattleLocations;
    [SerializeField]
private float chainRattleAngleDeltaThreshold;
    private float lastChainRattle;
    private Line leftSoundLine;
    private Line rightSoundLine;
    [HeaderAttribute("Runtime")]
public bool engineOn;
    public bool throttleOn;
    public bool inWater;
}
public class TunnelDweller : HumanNPC {
    public static Phrase TunnelDwellerName;
    private static string DWELLER_KILL_STAT;
    public string displayName { get; }
    private static TunnelDweller();
    public virtual string get_displayName();
    protected virtual void OnKilledByPlayer(BasePlayer p);
}
public class TutorialBuildTarget : MonoBehaviour {
    public BaseEntityRef TargetPrefab;
    public ItemDefinition TargetItemDef;
    public GameObject VisualObject;
    public Vector3 PhysCheckOffset;
    public bool Snap;
    public float MaxDistance;
    public BaseMission RequiredMission;
    public int RequiredMissionStage;
    public float MaxValidAngle;
    public bool IsValid(Construction toConstruct, Target target, Placement placement);
    public bool IsValid(BasePlayer player, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation);
    public void UpdateActive(BasePlayer p);
    private bool HasTargetBeenBuilt();
}
public class TutorialContainer : StorageContainer {
    private bool acceptingItems;
    public void LoadStorage(ItemAmount[] toLoad);
    public virtual void ServerInit();
    private bool CanAcceptItem(Item item, int targetSlot);
}
[CreateAssetMenuAttribute]
public class TutorialFullScreenHelpInfo : ScriptableObject {
    public static Phrase MovementPhrase;
    public static Phrase CraftingPhrase;
    public static Phrase CombatPhrase;
    public static Phrase BuildingPhrase;
    public static Dictionary`2<MenuCategory, Phrase> CategoryPhraseLookup;
    public MenuCategory Category;
    public int Priority;
    public TokenisedPhrase TextToDisplay;
    public Sprite StaticImage;
    public VideoClip VideoClip;
    private static TutorialFullScreenHelpInfo();
}
public class TutorialHelpPopup : ListComponent`1<TutorialHelpPopup> {
    public RustText HelpText;
    public Image HelpImage;
    public VideoPlayer HelpVideo;
    public RawImage HelpVideoTexture;
    public CanvasGroup Group;
    public Canvas Canvas;
}
public class TutorialIsland : BaseEntity {
    public EntityRef`1<BasePlayer> ForPlayer;
    public Transform InitialSpawnPoint;
    public Transform MidMissionSpawnPoint;
    public int SpawnLocationIndex;
    public TutorialNPC StartTutorialNPC;
    public TutorialContainer TutorialContainer;
    public MonumentNavMesh MonumentNavMesh;
    public FoliageGridBaked FoliageGrid;
    public MeshTerrainRoot MeshTerrain;
    public Transform KayakPoint;
    public BaseMission FinalMission;
    [RangeAttribute("0", "24")]
public float TimeOfDay;
    public ItemDefinition rockDefinition;
    public WeatherPreset Weather;
    [HeaderAttribute("Debugging")]
public BaseMission TestMission;
    private TutorialBuildTarget[] buildTargets;
    public static Phrase NoTutorialIslandsAvailablePhrase;
    public static Phrase TutorialIslandStartCooldown;
    public static ListHashSet`1<IslandBounds> BoundsListServer;
    public static float TutorialBoundsSize;
    [ServerVar]
public static bool SpawnTutorialIslandForNewPlayer;
    private static ListHashSet`1<TutorialIsland> ActiveIslandsServer;
    [ServerVar]
public static bool EnforceTrespassChecks;
    [ServerVar]
public static Vector3 OverrideTutorialLocation;
    private static string TutorialIslandAssetPath;
    private static float _tutorialWorldStart;
    public static Bounds WorldBoundsMinusTutorialIslands;
    private static List`1<Vector3> islandSpawnLocations;
    private static List`1<int> freeIslandLocations;
    private float tutorialDuration;
    private float disconnectedDuration;
    private bool readyToStartConversation;
    private float tickRate;
    private Vector3 kayakAnchorPoint;
    private Kayak kayakToAnchor;
    private TimeSince rockCheck;
    public static float TutorialWorldStart { get; }
    public static float TutorialWorldNetworkThreshold { get; }
    public static int MaxTutorialIslandCount { get; }
    public TimeSpan TutorialDuration { get; }
    public float DisconnectTimeOutDuration { get; }
    public static bool HasAvailableTutorialIsland { get; }
    private static TutorialIsland();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public static ListHashSet`1<TutorialIsland> GetTutorialList(bool isServer);
    public static UInt32 GetTutorialGroupId(int index);
    public static bool IsTutorialNetworkGroup(UInt32 grp);
    public static float get_TutorialWorldStart();
    public static float get_TutorialWorldNetworkThreshold();
    public static int get_MaxTutorialIslandCount();
    public TimeSpan get_TutorialDuration();
    public float get_DisconnectTimeOutDuration();
    public static void GenerateIslandSpawnPoints(bool loadingSave);
    public static Group GetTutorialGroup(int index);
    public static int AvailableIslandCount();
    public static bool ShouldPlayerResumeTutorial(BasePlayer player);
    public static bool ShouldPlayerBeAskedToStartTutorial(BasePlayer player);
    public static TutorialIsland RestoreOrCreateIslandForPlayer(BasePlayer player, bool triggerAnalytics);
    public static bool get_HasAvailableTutorialIsland();
    private static TutorialIsland CreateIslandForPlayer(BasePlayer player);
    private static Group SetupGroup(int spawnLocationIndex, Vector3 worldPos, Quaternion worldRot);
    private static int GetUnusedTutorialIslandLocationRotation(Vector3& worldPos, Quaternion& worldRot);
    public static void AddIslandFromSave(TutorialIsland island);
    public void GenerateNavMesh();
    [IteratorStateMachineAttribute("TutorialIsland/<UpdateNavMesh>d__59")]
public IEnumerator UpdateNavMesh();
    private void StartInitialConversation();
    public virtual void ServerInit();
    private void InitSpawnGroups();
    public void OnPlayerBuiltConstruction(BasePlayer player);
    public virtual void Save(SaveInfo info);
    public void GetBuildTargets(List`1<TutorialBuildTarget> targetList, UInt32 targetPrefab);
    public Vector3 GetWorldPosOfBuildTarget(int index);
    public void StartEndingCinematic(BasePlayer player);
    private void AnchorKayak();
    public void OnPlayerCompletedTutorial(BasePlayer player, bool isQuit, bool triggerAnalytics);
    private void KillPlayerAtEndOfTutorial();
    private void DelayedCompleteTutorial();
    public void Return();
    private static void ReturnIsland(TutorialIsland island);
    public void Tick();
    private void TickPlayerConnectionStatus();
    public sealed virtual bool IsPingValid(MapNote note);
    public static TutorialIsland GetClosestTutorialIsland(Vector3 position, float maxRange);
    public void OnPlayerStartedMission(BasePlayer player);
    public virtual void Load(LoadInfo info);
    public bool CheckPlacement(Construction toConstruct, Target target, Placement placement);
    public bool CheckPlacement(BasePlayer forPlayer, Deployable deployable, Vector3 worldPosition, Quaternion worldRotation);
    public virtual void InitShared();
    public virtual void DestroyShared();
    private static void AddIslandBounds(OBB worldBounds, UInt32 netId, bool isServer);
    private static void RemoveIslandBounds(UInt32 netId, bool isServer);
    public virtual bool SupportsChildDeployables();
    public virtual bool ForceDeployableSetParent();
}
public class TutorialIsland_MapMarker : MapMarker {
}
public static class TutorialIslandSpawner : object {
    public static List`1<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int loopCount, Bounds& worldBoundsMinusTutorialIslands);
    public static List`1<Vector3> GetEdgeSpawnPoints(Vector3 start, Vector3 bounds, Vector3 cellSize, int curLoop);
}
[CreateAssetMenuAttribute]
public class TutorialMissionHelpSet : ScriptableObject {
    public TutorialFullScreenHelpInfo[] Infos;
}
public class TutorialNPC : NPCMissionProvider {
    public ConversationData StartConversation;
    public ConversationData MissionInProgressConversation;
    public ConversationData ForageCompleteConversation;
    public ConversationData FirstBuildCompleteConversation;
    public ConversationData SecondBuildCompleteConversation;
    public ConversationData PrepareForCombatConversation;
    public ConversationData BuildKayakConversation;
    public ConversationData SetSailConversation;
    public ConversationData PostBearAttackConversation;
    public BaseMission PostBearAttackMission;
    public GameObjectRef BearRoarSfx;
    public Transform BearRoarSpawnPos;
    [RangeAttribute("0", "1")]
public float TalkingHeadIkWeight;
    public RuntimeAnimatorController CustomAnimator;
    private static int IsTalking;
    private static UInt32 FORAGE_MISSION;
    private static UInt32 BUILD1_MISSION;
    private static UInt32 BUILD2_MISSION;
    private static UInt32 COOK_MISSION;
    private static UInt32 KILL_BEAR_MISSION;
    private static UInt32 CRAFT_KAYAK_MISSION;
    public static UInt32 BEAR_ATTACK_RESPAWN_MISSION;
    private BasePlayer playerToKill;
    private static TutorialNPC();
    protected virtual bool CanTalkTo(BasePlayer bp);
    public virtual ConversationData GetConversationFor(BasePlayer player);
    public virtual void OnConversationAction(BasePlayer player, string action);
    private void WaitAndKill();
    public virtual void PostServerLoad();
    public virtual void GreetPlayer(BasePlayer player);
    public virtual void Greeting();
    public virtual void OnConversationStarted(BasePlayer speakingTo);
    public virtual void OnConversationEnded(BasePlayer player);
}
public class TutorialOptionsPrompt : MonoBehaviour {
    public CanvasGroup Group;
    public GameObject NotConnectedToValidServerRoot;
    public GameObject ServerValidRoot;
    public GameObject TutorialInProcessRoot;
}
public class TutorialStartModal : UIDialog {
}
public class TweakUI : SingletonComponent`1<TweakUI> {
    public static bool isOpen;
    private void Update();
    protected bool CanToggle();
    public void SetVisible(bool b);
}
public class TweakUIBase : MonoBehaviour {
    public string convarName;
    public bool ApplyImmediatelyOnChange;
    internal Command conVar;
    private void Awake();
    protected virtual void Init();
    public virtual void OnApplyClicked();
    public virtual void UnapplyChanges();
    protected virtual void OnConVarChanged(Command obj);
    public virtual void ResetToConvar();
    protected virtual void SetConvarValue();
    public int GetCurrentValueAsInt();
    private void OnDestroy();
}
public class TweakUIDropdown : TweakUIBase {
    public RustText Current;
    public Image BackgroundImage;
    public RustButton Opener;
    public RectTransform Dropdown;
    public RectTransform DropdownContainer;
    public GameObject DropdownItemPrefab;
    public NameValue[] nameValues;
    public bool assignImageColor;
    public bool forceEnglish;
    public UnityEvent onValueChanged;
    public int currentValue;
    protected virtual void Init();
    protected void OnEnable();
    public void UpdateDropdownOptions();
    public void OnValueChanged();
    public void OnDropdownOpen();
    public void ChangeValue(int index);
    protected virtual void SetConvarValue();
    public virtual void ResetToConvar();
    protected void ShowValue(string value);
}
public class TweakUIDropdownColour : TweakUIBase {
    public Image BackgroundImage;
    public RustButton Opener;
    public RectTransform Dropdown;
    public RectTransform DropdownContainer;
    public GameObject DropdownItemPrefab;
    public AccessibilityColourCollection forColourCollection;
    public AccessibilityMaterialCollection forMaterialCollection;
    public UnityEvent onValueChanged;
    public int currentValue;
}
public class TweakUIMultiSelect : TweakUIBase {
    public ToggleGroup toggleGroup;
    protected virtual void Init();
    protected void OnEnable();
    public void OnChanged();
    private void UpdateToggleGroup();
    private void UpdateConVar();
}
public class TweakUIPresetSelect : TweakUIDropdown {
    public TweakUIBase[] TargetOptions;
    public Presets[] PresetsArray;
    public int CustomIndex;
    private bool blockChange;
    private void Start();
    protected virtual void SetConvarValue();
    public void UpdateCurrentOption();
    private bool MatchesOption(Presets preset);
}
public class TweakUISlider : TweakUIBase {
    public Slider sliderControl;
    public TextMeshProUGUI textControl;
    public static string lastConVarChanged;
    public static TimeSince timeSinceLastConVarChange;
    protected virtual void Init();
    protected void OnEnable();
    public void OnChanged();
    protected virtual void SetConvarValue();
    public virtual void ResetToConvar();
    private void RefreshSliderDisplay(float value);
}
public class TweakUIToggle : TweakUIBase {
    public Toggle toggleControl;
    public bool inverse;
    public static string lastConVarChanged;
    public static TimeSince timeSinceLastConVarChange;
    protected virtual void Init();
    protected void OnEnable();
    public void OnToggleChanged();
    protected virtual void SetConvarValue();
    public virtual void ResetToConvar();
}
public class TwitchBus : CH47Helicopter {
    public LineRenderer[] LineRenderers;
    public Transform[] LineRendererBusPoints;
    public Transform[] HelicopterPoints;
}
public class TwitchTrophy : BaseCombatEntity {
    [HeaderAttribute("Trophy")]
public GameObjectRef DialogPrefab;
}
public class TypeThroughButton : Button {
    public InputField typingTarget;
    private Event _processingEvent;
    public sealed virtual void OnUpdateSelected(BaseEventData eventData);
    [IteratorStateMachineAttribute("TypeThroughButton/<DelayedActivateTextField>d__3")]
private IEnumerator DelayedActivateTextField(Event e);
}
public enum UGCType : Enum {
    public int value__;
    public static UGCType ImageJpg;
    public static UGCType ImagePng;
    public static UGCType AudioOgg;
    public static UGCType PatternBoomer;
}
public class UI_LocalVoice : PriorityListComponent`1<UI_LocalVoice> {
    public CanvasGroup voiceCanvas;
    public CanvasGroup levelImage;
}
public class UIAIDesignerScreen : SingletonComponent`1<UIAIDesignerScreen> {
    public GameObject SaveEntityButton;
    public GameObject SaveServerButton;
    public GameObject SaveDefaultButton;
    public RustInput InputAIDescription;
    public RustText TextDefaultStateContainer;
    public Transform PrefabAddNewStateButton;
    public Transform StateContainer;
    public Transform PrefabState;
    public EnumListUI PopupList;
    public static EnumListUI EnumList;
    public NeedsCursor needsCursor;
    protected CanvasGroup canvasGroup;
    public GameObject RootPanel;
}
public class UIAutoPanelCloser : MonoBehaviour {
    public UIDialog Dialog;
}
public class UIBackgroundBlur : ListComponent`1<UIBackgroundBlur> {
    public float amount;
    public static float currentMax { get; }
    public static float get_currentMax();
}
public class UIBelt : SingletonComponent`1<UIBelt> {
    public List`1<ItemIcon> ItemIcons;
    protected virtual void Awake();
    public ItemIcon GetItemIconAtSlot(int slot);
}
public class UIBlackoutDeathOverlay : UIBlackoutOverlay {
}
public class UIBlackoutOverlay : MonoBehaviour {
    public CanvasGroup group;
    public static Dictionary`2<blackoutType, UIBlackoutOverlay> instances;
    public blackoutType overlayType;
    public bool overrideCanvasScaling;
    public float referenceScale;
}
public class UIBlueprints : ListComponent`1<UIBlueprints> {
    public GameObjectRef buttonPrefab;
    public ScrollRect scrollRect;
    public CanvasGroup ScrollRectCanvasGroup;
    public InputField searchField;
    public GameObject searchFieldPlaceholder;
    public GameObject listAvailable;
    public GameObject listLocked;
    public GameObject Categories;
    public VerticalLayoutGroup CategoryVerticalLayoutGroup;
    public BlueprintCategoryButton FavouriteCategoryButton;
}
public class UIBuffs : SingletonComponent`1<UIBuffs> {
    public bool Enabled;
    public Transform PrefabBuffIcon;
    public void Refresh(PlayerModifiers modifiers);
    private void RemoveAll();
}
public class UIBuffsIcon : SingletonComponent`1<UIBuffsIcon> {
    public TextMeshProUGUI Text;
    public Tooltip ToolTip;
    public CanvasGroup Group;
}
public class UICameraOverlay : SingletonComponent`1<UICameraOverlay> {
    public static Phrase FocusOffText;
    public static Phrase FocusAutoText;
    public static Phrase FocusManualText;
    public CanvasGroup CanvasGroup;
    public RustText FocusModeLabel;
    private static UICameraOverlay();
    public void Show();
    public void Hide();
    public void SetFocusMode(CameraFocusMode mode);
}
public class UIChat : PriorityListComponent`1<UIChat> {
    public GameObject inputArea;
    public GameObject chatArea;
    public TMP_InputField inputField;
    public TextMeshProUGUI channelLabel;
    public ScrollRect scrollRect;
    public CanvasGroup canvasGroup;
    public bool allowOpeningWhileCursorVisible;
    public GameObjectRef chatItemPlayer;
    public GameObject userPopup;
    public EmojiGallery emojiGallery;
    public static bool isOpen;
}
public class UIChatPopup : MonoBehaviour {
    public TextMeshProUGUI TextToggleMute;
    public TextMeshProUGUI TextToggleGlobalMute;
    public Button MuteButton;
    public Button ReportButton;
    public GameObject InviteToTeamButton;
}
public class UIClanConfirmation : BaseMonoBehaviour {
    public RustText Text;
    public RustText TryAgainText;
}
public class UIClanCreator : BaseMonoBehaviour {
    public static Phrase CreateNameBlank;
    public static Phrase CreateNameInvalid;
    public static Phrase CreateAlreadyInClan;
    public static Phrase CreateDuplicateName;
    public static Phrase CreateFailure;
    public UIClans UiClans;
    public RustInput ClanName;
    private static UIClanCreator();
}
public class UIClanInvitation : BaseMonoBehaviour {
    public static Phrase AcceptInvitationFailure;
    public static Phrase AcceptInvitationFull;
    public static Phrase DeclineInvitationFailure;
    public RustText ClanName;
    public RustText ClanMembers;
    public Image ClanBanner;
    public RawImage RecruiterAvatar;
    public RustText RecruiterName;
    public GameObject ActionsContainer;
    private static UIClanInvitation();
}
public class UIClanInvitations : BaseMonoBehaviour {
    public UIClans UiClans;
    public RectTransform InvitationList;
    public GameObjectRef InvitationPrefab;
}
public class UIClanInvite : BaseMonoBehaviour {
    public static Phrase CancelInviteFailure;
    public RawImage Avatar;
    public RustText Name;
    public RustText Recruiter;
    public RustText Created;
    public RustButton CancelButton;
    private static UIClanInvite();
}
public class UIClanInvites : BaseMonoBehaviour {
    public UIClans UiClans;
    public RectTransform InviteList;
    public GameObjectRef InvitePrefab;
}
public class UIClanLeaderboard : BaseMonoBehaviour {
    public UIClans UiClans;
    public GameObject LoadingIndicator;
    public GameObject Content;
    public RectTransform EntryList;
    public GameObjectRef EntryPrefab;
}
public class UIClanLeaderboardEntry : MonoBehaviour {
    public RustText ClanName;
    public RustText Score;
}
public class UIClanLog : BaseMonoBehaviour {
    public static Phrase RefreshFailure;
    public UIClans UiClans;
    public RectTransform EntryList;
    public GameObjectRef EntryPrefab;
    private static UIClanLog();
}
public class UIClanLogEntry : BaseMonoBehaviour {
    public static Phrase FoundedEvent;
    public static Phrase SetMotdEvent;
    public static Phrase SetLogoEvent;
    public static Phrase SetColorEvent;
    public static Phrase InviteEvent;
    public static Phrase LeaveEvent;
    public static Phrase KickEvent;
    public static Phrase AcceptInviteEvent;
    public static Phrase DeclineInviteEvent;
    public static Phrase CancelInviteEvent;
    public static Phrase CreateRoleEvent;
    public static Phrase UpdateRoleEvent;
    public static Phrase UpdateRoleRenamedEvent;
    public static Phrase SwapRolesEvent;
    public static Phrase DeleteRoleEvent;
    public static Phrase ChangeRoleEvent;
    public static Phrase SetNotesEvent;
    public RustText Event;
    public RustText Time;
    private static UIClanLogEntry();
}
public class UIClanMember : BaseMonoBehaviour {
    public static Phrase OnlinePhrase;
    public Image Highlight;
    public Color HighlightColor;
    public Color SelectedColor;
    public RawImage Avatar;
    public RustText Name;
    public RustText Rank;
    public RustText LastSeen;
    private static UIClanMember();
}
public class UIClanMemberDetails : UIClanMember {
    public static Phrase KickConfirmation;
    public static Phrase SaveNotesFailure;
    public static Phrase ChangeRankCannotDemoteLeader;
    public static Phrase ChangeRankFailure;
    public static Phrase KickFailure;
    public UIClans UiClans;
    public RustInput NoteEditor;
    public RustButton SaveNoteButton;
    public GameObject ChangeRankSection;
    public Dropdown ChangeRankDropdown;
    public GameObject KickSection;
    public RustButton KickButton;
    private static UIClanMemberDetails();
}
public class UIClanMembers : BaseMonoBehaviour {
    public UIClans UiClans;
    public RectTransform MemberList;
    public GameObjectRef MemberPrefab;
    public UIClanMemberDetails MemberDetails;
}
public class UIClanOverview : BaseMonoBehaviour {
    public static Phrase SetMotdFailure;
    public UIClans UiClans;
    public RawImage MotdAuthorAvatar;
    public RustText MotdAuthorName;
    public RustText MotdTime;
    public RustInput MotdInput;
    public RustButton MotdSaveButton;
    public RustButton MotdCancelButton;
    private static UIClanOverview();
}
public class UIClanRank : BaseMonoBehaviour {
    public static Phrase MoveUpFailure;
    public static Phrase MoveDownFailure;
    public static Phrase DeleteRankFailure;
    public static Phrase DeleteRankNotEmpty;
    private static Memoized`2<string, int> IndexToString;
    public Image Highlight;
    public RustText IndexLabel;
    public RustText Name;
    public RustButton MoveUpButton;
    public RustButton MoveDownButton;
    public RustButton DeleteButton;
    private static UIClanRank();
}
public class UIClanRankCreator : BaseMonoBehaviour {
    public static Phrase CreateRankFailure;
    public static Phrase CreateRankDuplicate;
    public static Phrase CreateRankNameInvalid;
    public UIClans UiClans;
    public RustInput RankName;
    public RustButton Submit;
    private static UIClanRankCreator();
}
public class UIClanRankEditor : BaseMonoBehaviour {
    public static Phrase SaveRankFailure;
    public static Phrase SaveRankDuplicate;
    public UIClans UiClans;
    public RustInput NameEditor;
    public RustButton SetMotd;
    public RustButton SetLogo;
    public RustButton Invite;
    public RustButton Kick;
    public RustButton Promote;
    public RustButton Demote;
    public RustButton SetPlayerNotes;
    public RustButton AccessLogs;
    public RustButton AccessScoreEvents;
    public RustButton CancelButton;
    public RustButton SubmitButton;
    private static UIClanRankEditor();
}
public class UIClanRanks : BaseMonoBehaviour {
    public UIClans UiClans;
    public RectTransform RankContainer;
    public GameObjectRef RankPrefab;
    public UIClanRankCreator RankCreator;
    [HeaderAttribute("Sections")]
public RectTransform RankListing;
    public UIClanRankEditor RankEditor;
}
public class UIClans : SingletonComponent`1<UIClans> {
    public static Phrase LeaveConfirmation;
    public static Phrase GetInvitationsFailure;
    public static Phrase GetClanFailure;
    public static Phrase LeaveFailure;
    public static Phrase LeaveNoOtherLeader;
    public CanvasGroup CanvasGroup;
    public UIEscapeCapture EscapeCapture;
    public NeedsCursor NeedsCursor;
    public NeedsKeyboard NeedsKeyboard;
    public GameObject ClanTableRequired;
    [HeaderAttribute("States")]
public GameObject EmptyState;
    public GameObject CreateState;
    public GameObject InvitesState;
    public GameObject MainState;
    [HeaderAttribute("General")]
public RustText ClanName;
    public Image ClanBanner;
    public RawImage ClanLogo;
    public RustText ClanMembers;
    public RustText ClanScore;
    public RustButton LeaveButton;
    public Texture2D DefaultLogo;
    public RustButton OverviewButton;
    public RustButton ScoreEventsButton;
    public RustButton LogsButton;
    public RustButton SettingsButton;
    public RustButton CreatePrompt;
    public CanvasGroup LoadingIndicator;
    public UIClanLeaderboard Leaderboard;
    public UIClanConfirmation Confirmation;
    public UIClanConfirmation Error;
    [HeaderAttribute("Tabs")]
public UIClanInvitations Invitations;
    public UIClanOverview Overview;
    public UIClanMembers Members;
    public UIClanInvites Invites;
    public UIClanRanks Ranks;
    public UIClanScoreEvents ScoreEvents;
    public UIClanLog Logs;
    public UIClanSettings Settings;
    private static UIClans();
}
public class UIClanScoreEvents : BaseMonoBehaviour {
    public static Phrase RefreshFailure;
    public UIClans UiClans;
    public RectTransform EntryList;
    public GameObjectRef EntryPrefab;
    private static UIClanScoreEvents();
}
public class UIClanScoreEventsEntry : BaseMonoBehaviour {
    public static Phrase ClanPlayerKilledEvent;
    public static Phrase ClanPlayerDiedEvent;
    public static Phrase KilledUnarmedEvent;
    public static Phrase DestroyedToolCupboardEvent;
    public static Phrase HackedCrateEvent;
    public static Phrase OpenedHackedCrateEvent;
    public static Phrase DestroyedBradleyEvent;
    public static Phrase RanExcavatorEvent;
    public static Phrase ReachedCargoShipEvent;
    public static Phrase LootedEliteCrateEvent;
    public static Phrase UnknownEvent;
    public RustText Event;
    public RustText Score;
    public RustText Multiplier;
    public RustText Time;
    private static UIClanScoreEventsEntry();
}
public class UIClanSettings : BaseMonoBehaviour {
    public static Phrase SetLogoFailure;
    public static Phrase SetColorFailure;
    public UIClans UiClans;
    [HeaderAttribute("Logo Editing")]
public RustButton EditLogoButton;
    public GameObjectRef ChangeSignDialog;
    public MeshPaintableSource[] PaintableSources;
    [HeaderAttribute("Banner Colors")]
public RectTransform ColorsContainer;
    private static UIClanSettings();
}
public class UIColorPickerButton : MonoBehaviour {
    public Image Image;
    public Color Color;
}
public class UICompass : MonoBehaviour {
    public RawImage compassStrip;
    public CanvasGroup compassGroup;
    public List`1<CompassMapMarker> CompassMarkers;
    public List`1<CompassMapMarker> TeamCompassMarkers;
    public List`1<CompassMissionMarker> MissionMarkers;
    public CompassMapMarker DeathMarker;
    public static Phrase IslandInfoPhrase;
    public RectTransform IslandInfoContainer;
    public RustText IslandInfoText;
    public float IslandInfoDistanceThreshold;
    public float IslandLookThreshold;
    public RectTransform IslandInfoFullContainer;
    public List`1<CompassMapMarker> LocalPings;
    public List`1<CompassMapMarker> TeamPings;
    public Image LeftPingPulse;
    public Image RightPingPulse;
    private static UICompass();
}
public class UIConfirmationPopup : MonoBehaviour {
    [SerializeField]
private Transform buttonsParent;
    [SerializeField]
private RustText messageText;
    [SerializeField]
private RustButton buttonTemplate;
    public RustButton[] buttons;
}
public class UIContacts : SingletonComponent`1<UIContacts> {
    public static bool isOpen;
    public static float LastOpened;
    public ContactsPanel contactsPanel;
}
public class UIConversationScreen : SingletonComponent`1<UIConversationScreen> {
    public NeedsCursor needsCursor;
    public RectTransform conversationPanel;
    public RustText conversationSpeechBody;
    public RustText conversationProviderName;
    public Image conversationProviderImage;
    public RustButton[] responseButtons;
    public RectTransform letterBoxTop;
    public RectTransform letterBoxBottom;
    public GameObject cancelButton;
    protected CanvasGroup canvasGroup;
    public UIMissionInfoConversation missionInfo;
    public UIEscapeCapture escapeCapture;
}
public class UICrafting : SingletonComponent`1<UICrafting> {
    public GameObject skinViewerPrefab;
    public static bool isOpen;
    public static float LastOpened;
}
public class UIDeathScreen : SingletonComponent`1<UIDeathScreen> {
    public LifeInfographic previousLifeInfographic;
    public Animator screenAnimator;
    public bool fadeIn;
    public Button ReportCheatButton;
    public MapView View;
    public List`1<SleepingBagButton> sleepingBagButtons;
    public GameObject loadingIndicator;
    public RespawnColourScheme[] RespawnColourSchemes;
    public GameObject RespawnScrollGradient;
    public ScrollRect RespawnScrollRect;
    public ExpandedLifeStats ExpandedStats;
    public GameObject OpenStatsButton;
    public CanvasGroup StreamerModeContainer;
    public GameObject SafeZoneInfo;
    public Image FadeImage;
}
public class UIDialog : ListComponent`1<UIDialog> {
    public SoundDefinition openSoundDef;
    public SoundDefinition closeSoundDef;
}
public class UIEscapeCapture : ListComponent`1<UIEscapeCapture> {
    public UnityEvent onEscape;
    public static bool EscapePressed();
}
public class UIFadeOut : MonoBehaviour {
    public float secondsToFadeOut;
    public bool destroyOnFaded;
    public CanvasGroup targetGroup;
    public float fadeDelay;
}
public class UIFireworkDesigner : UIDialog {
    public RustInput Title;
    public RustText StarsPlaced;
    public RectTransform Canvas;
    public RectTransform InnerCanvas;
    public GameObject StarPrefab;
}
public class UIFireworkDesignItem : MonoBehaviour {
    public static Phrase EmptyPhrase;
    public static Phrase UntitledPhrase;
    public RustText Title;
    public RustButton LoadButton;
    public RustButton SaveButton;
    public RustButton EraseButton;
    public UIFireworkDesigner Designer;
    public int Index;
    private static UIFireworkDesignItem();
}
public class UIFireworkStar : EventTrigger {
    public Image Image;
    public RustText Text;
}
public class UIFishing : SingletonComponent`1<UIFishing> {
    public Slider TensionLine;
    public Image FillImage;
    public Gradient FillGradient;
    private void Start();
}
public class UIFogOverlay : MonoBehaviour {
    public static UIFogOverlay Instance;
    public CanvasGroup group;
    public Color baseColor;
    public Image overlayImage;
}
public class UIGene : MonoBehaviour {
    public GameObject Child;
    public Color PositiveColour;
    public Color NegativeColour;
    public Color PositiveTextColour;
    public Color NegativeTextColour;
    public Image ImageBG;
    public Text TextGene;
    public void Init(GrowableGene gene);
    public void InitPrevious(GrowableGene gene);
    public void Hide();
    public void Show();
}
public class UIGenesDisplay : MonoBehaviour {
    public UIGene[] GeneUI;
    public Text[] TextLinks;
    public Text[] TextDiagLinks;
    public void Init(GrowableGenes genes);
    public void InitDualRow(GrowableGenes genes, bool firstRow);
    private void InitFirstRow(GrowableGenes genes);
    private void InitSecondRow(GrowableGenes genes);
    private void ShowDiagLink(int index, float rotation, GrowableGene nextGene);
}
public class UIHUD : SingletonComponent`1<UIHUD> {
    public UIChat chatPanel;
    public HudElement Hunger;
    public HudElement Thirst;
    public HudElement Health;
    public HudElement PendingHealth;
    public HudElement VehicleHealth;
    public HudElement AnimalStamina;
    public HudElement AnimalStaminaMax;
    public RectTransform vitalsRect;
    public Canvas healthCanvas;
    public UICompass CompassWidget;
    public GameObject KeyboardCaptureMode;
}
public class UIIngame : SingletonComponent`1<UIIngame> {
}
public class UIIntegerEntry : MonoBehaviour {
    public InputField textEntry;
    [CompilerGeneratedAttribute]
private Action textChanged;
    [CompilerGeneratedAttribute]
public void add_textChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_textChanged(Action value);
    public void OnAmountTextChanged();
    public void SetAmount(int amount);
    public int GetIntAmount();
    public void PlusMinus(int delta);
}
public class UIInventory : SingletonComponent`1<UIInventory> {
    public TextMeshProUGUI PlayerName;
    public static bool isOpen;
    public static float LastOpened;
    public VerticalLayoutGroup rightContents;
    public GameObject QuickCraft;
    public Transform InventoryIconContainer;
    public ChangelogPanel ChangelogPanel;
    public ContactsPanel contactsPanel;
    public GameObject backpackSlot;
    public UnderwearSkinPicker underwearSkinPicker;
}
public class UIInvertedMaskImage : Image {
    private Material cachedMaterial;
    public Material materialForRendering { get; }
    public virtual Material get_materialForRendering();
}
public class UIMapExplosion : MonoBehaviour {
}
public class UIMapGenericRadius : MonoBehaviour {
    public Image radialImage;
    public Image outlineImage;
    public float radius;
    public CanvasGroup fade;
    public RectTransform rect;
}
public class UIMapMissionProvider : MonoBehaviour {
    public Tooltip TargetTooltip;
    public RustText CountText;
}
public class UIMapVendingMachineMarker : MonoBehaviour {
    public Color inStock;
    public Color outOfStock;
    public Image colorBackground;
    public string displayName;
    public Tooltip toolTip;
    public RustButton button;
}
public class UIMapVendingMachineMarkerCluster : MonoBehaviour {
    public GameObject OpenRoot;
    public TextMeshProUGUI CountText;
    public GameObjectRef MarkerPrefab;
    public Transform MarkerParent;
}
public class UIMarketSearch : MonoBehaviour {
    public GameObjectRef StoreEntryRef;
    public RectTransform StoreRoot;
    public UIMarketTerminal Terminal;
}
public class UIMarketSearchOrderEntry : MonoBehaviour {
    public RustText ItemName;
    public GameObject OutOfStockRoot;
    public GameObject BpRoot;
}
public class UIMarketSearchStore : MonoBehaviour {
    public RustText StoreName;
    public List`1<UIMarketSearchOrderEntry> Entries;
}
public class UIMarketTerminal : UIDialog {
    public static Phrase PendingDeliveryPluralPhrase;
    public static Phrase PendingDeliverySingularPhrase;
    public Canvas canvas;
    public MapView mapView;
    public RectTransform shopDetailsPanel;
    public float shopDetailsMargin;
    public float easeDuration;
    public LeanTweenType easeType;
    public TmProEmojiRedirector shopName;
    public GameObject shopOrderingPanel;
    public RectTransform sellOrderContainer;
    public GameObjectRef sellOrderPrefab;
    public VirtualItemIcon deliveryFeeIcon;
    public GameObject deliveryFeeCantAffordIndicator;
    public GameObject inventoryFullIndicator;
    public GameObject notEligiblePanel;
    public GameObject pendingDeliveryPanel;
    public RustText pendingDeliveryLabel;
    public RectTransform itemNoticesContainer;
    public GameObjectRef itemRemovedPrefab;
    public GameObjectRef itemPendingPrefab;
    public GameObjectRef itemAddedPrefab;
    public CanvasGroup gettingStartedTip;
    public SoundDefinition buyItemSoundDef;
    public SoundDefinition buttonPressSoundDef;
    private static UIMarketTerminal();
}
public class UIMissionInfoConversation : MonoBehaviour {
    public RustText MissionName;
    public RustText[] MissionObjectives;
    public GameObject TimerRoot;
    public RustText TimerText;
    public VirtualItemIcon[] RewardIcons;
}
public class UIMixingTableItem : MonoBehaviour {
    public Image ItemIcon;
    public Tooltip ItemTooltip;
    public RustText TextItemNameAndQuantity;
    public UIMixingTableItemIngredient[] Ingredients;
    public void Init(Recipe recipe);
}
public class UIMixingTableItemIngredient : MonoBehaviour {
    public Image ItemIcon;
    public Text ItemCount;
    public Tooltip ToolTip;
    public void Init(RecipeIngredient ingredient);
    public void InitBlank();
}
public class UINexusMap : UINexusMapBase {
}
public abstract class UINexusMapBase : BaseMonoBehaviour {
    private static Memoized`2<string, int> IntMemoized;
    public RawImage BackgroundImage;
    public RawImage BackgroundFillImage;
    public RectTransform LoadingView;
    public RectTransform MissingView;
    public ScrollRectEx MapScrollRect;
    public ScrollRectZoom MapScrollZoom;
    public RectTransform CameraPositon;
    public CanvasGroup ZoneNameCanvasGroup;
    public RectTransform ZoneNameContainer;
    public GameObjectRef ZoneNameMarkerPrefab;
    [HeaderAttribute("Zone Details")]
public CanvasGroup ZoneDetails;
    public RustText ZoneName;
    public RustText OnlineCount;
    public RustText MaxCount;
    public GameObjectRef ZoneNameLabelPrefab;
    public GameObject InboundFerriesSection;
    public RectTransform InboundFerriesList;
    public GameObject OutboundFerriesSection;
    public RectTransform OutboundFerriesList;
    public GameObject ConnectionsSection;
    public RectTransform ConnectionsList;
    [HeaderAttribute("Behavior")]
public bool ShowLocalPlayer;
    public float OutOfBoundsScaleFactor;
    public float ZoneNameAlphaPower;
    public UnityEvent OnMapLoaded;
    public UnityEvent OnClicked;
    private static UINexusMapBase();
    public sealed virtual void OnPointerDown(PointerEventData eventData);
}
public class UINexusMapWidget : UINexusMapBase {
    public RustButton FocusButton;
    public FlexTransition RevealTransition;
}
public class UIPaintableImage : MonoBehaviour {
    public RawImage image;
    public int texSize;
    public Color clearColor;
    public FilterMode filterMode;
    public bool mipmaps;
    public RectTransform rectTransform { get; }
    public RectTransform get_rectTransform();
}
public class UIPaintBox : MonoBehaviour {
    public OnBrushChanged onBrushChanged;
    public Brush brush;
    public void UpdateBrushSize(int size);
    public void UpdateBrushTexture(Texture2D tex);
    public void UpdateBrushColor(Color col);
    public void UpdateBrushAlpha(float a);
    public void UpdateBrushEraser(bool b);
    private void OnChanged();
}
public class UIParticle : BaseMonoBehaviour {
    public Vector2 LifeTime;
    public Vector2 Gravity;
    public Vector2 InitialX;
    public Vector2 InitialY;
    public Vector2 InitialScale;
    public Vector2 InitialDelay;
    public Vector2 ScaleVelocity;
    public Gradient InitialColor;
    private float lifetime;
    private float gravity;
    private Vector2 velocity;
    private float scaleVelocity;
    public static void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas);
    private void Start();
    private void Update();
    private void Die();
}
public class UIPixelDownscale : MonoBehaviour {
    public CanvasScaler CanvasScaler;
    private void Awake();
    private void Update();
}
public class uiPlayerPreview : SingletonComponent`1<uiPlayerPreview> {
    public Camera previewCamera;
    public PlayerModel playermodel;
    public GameObject wantedSnapshotEffectPosterRoot;
    public GameObject wantedSnapshotEffectPolaroidRoot;
    public SegmentMaskPositioning segmentMask;
}
public class UIPlayerPreviewControls : SingletonComponent`1<UIPlayerPreviewControls> {
    public float RotationSpeed;
    public float RotationLerpSpeed;
    public float RotationStopLerpSpeed;
}
public class UIPrefab : MonoBehaviour {
    public GameObject prefabSource;
    internal GameObject createdGameObject;
    private void Awake();
    public void SetVisible(bool visible);
}
public class UIPrisonerHoodOverlay : UIBlackoutOverlay {
}
public class UIRecordingInfo : SingletonComponent`1<UIRecordingInfo> {
    public RustText CountdownText;
    public Slider TapeProgressSlider;
    public GameObject CountdownRoot;
    public GameObject RecordingRoot;
    public Transform Spinner;
    public float SpinSpeed;
    public Image CassetteImage;
    private void Start();
}
public class UIRestrained : SingletonComponent`1<UIRestrained> {
    public Image Fill;
    private void Start();
    public void SetActive(bool state);
    public void SetProgress(Item handcuffItem);
    public void SetProgress(float progress);
}
public abstract class UIRoot : MonoBehaviour {
    private GraphicRaycaster[] graphicRaycasters;
    public Canvas overlayCanvas;
    private void ToggleRaycasters(bool state);
    protected virtual void Awake();
    protected virtual void Start();
    protected void Update();
    protected abstract virtual void Refresh();
}
public class UIRootPixel : UIRoot {
    protected virtual void Refresh();
}
public class UIRootScaled : UIRoot {
    private static UIRootScaled Instance;
    public bool OverrideReference;
    public Vector2 TargetReference;
    public CanvasScaler scaler;
    public static Canvas DragOverlayCanvas { get; }
    public static Canvas get_DragOverlayCanvas();
    protected virtual void Awake();
    protected virtual void Refresh();
}
public class UISafeModeWarning : MonoBehaviour {
    public RustButton ApplyButton;
    public RustSlider TimeSlider;
    public float TimeToWait;
}
public class UISafeZoneWarning : MonoBehaviour {
    [SerializeField]
private Transform buttonsParent;
    [SerializeField]
private RustText messageText;
    [SerializeField]
private Button buttonTemplate;
}
public class UIScale : MonoBehaviour {
    public CanvasScaler scaler;
}
public class UIScalerOverride : MonoBehaviour {
    public AnimationCurve scaleCurve;
}
public class UIScopeOverlay : MonoBehaviour {
    public CanvasGroup group;
    public static UIScopeOverlay instance;
    public Image scopeImage;
}
public class UISleepingScreen : SingletonComponent`1<UISleepingScreen> {
    protected CanvasGroup canvasGroup;
    private bool visible;
    protected virtual void Awake();
    public void SetVisible(bool b);
}
public static class UISound : object {
    private static AudioSource source;
    private static AudioSource GetAudioSource();
    public static void Play(AudioClip clip, float volume);
}
public class UISoundPlayer : MonoBehaviour {
}
public class UITwitchTrophy : UIDialog {
    public HttpImage EventImage;
    public RustText EventName;
    public RustText WinningTeamName;
    public RectTransform TeamMembersRoot;
    public GameObject TeamMemberNamePrefab;
    public GameObject MissingDataOverlay;
}
public class UIUnderlay : SingletonComponent`1<UIUnderlay> {
    public GameObjectRef damageDirectional;
    public GameObjectRef waterDirectional;
}
public class UIVideoPlayer : UIDialog {
    public AspectRatioFitter aspectRatioFitter;
    public GameObject closeButton;
    public VideoPlayer videoPlayer;
    public RawImage videoCanvas;
    public RectTransform videoProgressBar;
    public GameObject loadingIndicator;
    public float audioDuckingAmount;
    public float timeoutAfter;
}
public class UIVoiceIcon : MonoBehaviour {
    public Text nameText;
    public RawImage avatar;
}
public class UIWounded : MonoBehaviour {
    public CanvasGroup group;
    public Image chanceFill;
    public RustText chanceText;
    public Image timeRemainingFill;
    public RustText timeRemainingText;
}
public class UndergroundLODSwitcher : MonoBehaviour {
    public LODComponent TargetComponent;
}
public class UnderwaterDweller : HumanNPC {
    public static Phrase UnderwaterDwellerName;
    public string displayName { get; }
    private static UnderwaterDweller();
    public virtual string get_displayName();
}
public class UnderwaterEffect : WeatherEffect {
}
public class UnderWaterEffectRenderer : PostProcessEffectRenderer`1<UnderwaterPostEffect> {
    public virtual void Render(PostProcessRenderContext context);
}
public class UnderwaterPathFinder : BasePathFinder {
    private BaseEntity npc;
    public void Init(BaseEntity npc);
    public virtual Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 anchorPos, Vector3 fallbackPos, float minRange, float maxRange);
    public virtual bool GetBestFleePosition(BaseNavigator navigator, AIBrainSenses senses, BaseEntity fleeFrom, Vector3 fallbackPos, float minRange, float maxRange, Vector3& result);
}
[PostProcessAttribute("UnderWaterEffectRenderer", "2", "Custom/UnderWaterEffect", "False")]
public class UnderwaterPostEffect : PostProcessEffectSettings {
    [HeaderAttribute("Wiggle")]
public BoolParameter wiggle;
    public FloatParameter speed;
    public FloatParameter scale;
    [HeaderAttribute("Water Line")]
public ColorParameter waterLineColor;
    [RangeAttribute("1", "4")]
public FixedIntParameter waterLineBlurIterations;
    [RangeAttribute("0", "10")]
public FloatParameter waterLineBlurSize;
    [RangeAttribute("0", "2")]
[HeaderAttribute("Blur")]
public FixedIntParameter downsample;
    [RangeAttribute("1", "4")]
public FixedIntParameter blurIterations;
    [RangeAttribute("0", "10")]
public FloatParameter blurSize;
    public FloatParameter fadeToBlurDistance;
}
[CreateAssetMenuAttribute]
public class Underwear : ScriptableObject {
    public string shortname;
    public Phrase displayName;
    public Sprite icon;
    public Sprite iconFemale;
    public SkinReplacement[] replacementsMale;
    public SkinReplacement[] replacementsFemale;
    [TooltipAttribute("User can craft this item on any server if they have this steam item")]
public SteamInventoryItem steamItem;
    [TooltipAttribute("User can craft this item if they have this DLC purchased")]
public SteamDLCItem steamDLC;
    public bool adminOnly;
    public UInt32 GetID();
    public bool HasMaleParts();
    public bool HasFemaleParts();
    public bool ValidForPlayer(BasePlayer player);
    public static bool IsFemale(BasePlayer player);
    public static bool Validate(Underwear underwear, BasePlayer player);
}
public class UnderwearIcon : MonoBehaviour {
    public Image icon;
}
[CreateAssetMenuAttribute]
public class UnderwearManifest : ScriptableObject {
    public static UnderwearManifest instance;
    public List`1<Underwear> underwears;
    public static UnderwearManifest Get();
    public void PrintManifest();
    public Underwear GetUnderwear(UInt32 id);
}
public class UnderwearSkinPicker : MonoBehaviour {
    public GameObjectRef pickerIcon;
    public GameObject container;
    public Action skinChangedEvent;
    public Sprite defaultNudeIcon;
    public Sprite defaultIconMale;
    public Sprite defaultIconFemale;
}
[ExtensionAttribute]
public static class Unity.Collections.NativeArrayEx : object {
    [ExtensionAttribute]
public static void Add(NativeArray`1& array, T item, Int32& size);
    [ExtensionAttribute]
public static void RemoveUnordered(NativeArray`1& array, int index, Int32& count);
    [ExtensionAttribute]
public static void Expand(NativeArray`1& array, int newCapacity);
    [ExtensionAttribute]
public static void SafeDispose(NativeArray`1& array);
}
[ExtensionAttribute]
public static class UnityEngine.AniamtorEx : object {
    [ExtensionAttribute]
public static void SetFloatFixed(Animator animator, int id, float value, float dampTime, float deltaTime);
    [ExtensionAttribute]
public static void SetBoolChecked(Animator animator, int id, bool value);
}
[ExtensionAttribute]
public static class UnityEngine.ArgEx : object {
    [ExtensionAttribute]
public static BasePlayer Player(Arg arg);
    [ExtensionAttribute]
public static BasePlayer GetPlayer(Arg arg, int iArgNum);
    [ExtensionAttribute]
public static BasePlayer GetSleeper(Arg arg, int iArgNum);
    [ExtensionAttribute]
public static BasePlayer GetPlayerOrSleeper(Arg arg, int iArgNum);
    [ExtensionAttribute]
public static BasePlayer GetPlayerOrSleeperOrBot(Arg arg, int iArgNum);
    [ExtensionAttribute]
public static NetworkableId GetEntityID(Arg arg, int iArg, NetworkableId def);
    [ExtensionAttribute]
public static ItemId GetItemID(Arg arg, int iArg, ItemId def);
}
public class UnityEngine.CachedMonumentComponent : MonoBehaviour {
    public MonumentInfo Monument;
    public Vector3 LastPosition;
    public void UpdateMonument(MonumentInfo info, Collider collider);
}
[ExtensionAttribute]
public static class UnityEngine.ColliderEx : object {
    [ExtensionAttribute]
public static PhysicMaterial GetMaterialAt(Collider obj, Vector3 pos);
    [ExtensionAttribute]
public static float EstimateVolume(Collider collider);
    [ExtensionAttribute]
public static bool IsOnLayer(Collider col, Layer rustLayer);
    [ExtensionAttribute]
public static bool IsOnLayer(Collider col, int layer);
    [ExtensionAttribute]
public static float GetRadius(Collider col, Vector3 transformScale);
    [ExtensionAttribute]
public static MonumentInfo GetMonument(Collider collider, bool ignoreEntity);
}
[ExtensionAttribute]
public static class UnityEngine.CollisionEx : object {
    [ExtensionAttribute]
public static BaseEntity GetEntity(Collision col);
}
[ExtensionAttribute]
public static class UnityEngine.ComponentEx : object {
    [ExtensionAttribute]
public static T Instantiate(T component);
    [ExtensionAttribute]
public static bool HasComponent(Component component);
    [ExtensionAttribute]
public static Nullable`1<bool> IsEnabled(Component component);
}
public static class UnityEngine.CoroutineEx : object {
    public static WaitForEndOfFrame waitForEndOfFrame;
    public static WaitForFixedUpdate waitForFixedUpdate;
    private static Dictionary`2<float, WaitForSeconds> waitForSecondsBuffer;
    private static CoroutineEx();
    public static WaitForSeconds waitForSeconds(float seconds);
    public static WaitForSecondsRealtimeEx waitForSecondsRealtime(float seconds);
    [IteratorStateMachineAttribute("UnityEngine.CoroutineEx/<Combine>d__5")]
public static IEnumerator Combine(IEnumerator[] coroutines);
}
public class UnityEngine.DDraw : MonoBehaviour {
}
[ExtensionAttribute]
public static class UnityEngine.GameObjectEx : object {
    [ExtensionAttribute]
public static BaseEntity ToBaseEntity(GameObject go, bool allowDestroyed);
    [ExtensionAttribute]
public static BaseEntity ToBaseEntity(Collider collider, bool allowDestroyed);
    [ExtensionAttribute]
public static BaseEntity ToBaseEntity(Transform transform, bool allowDestroyed);
    [ExtensionAttribute]
public static bool IsOnLayer(GameObject go, Layer rustLayer);
    [ExtensionAttribute]
public static bool IsOnLayer(GameObject go, int layer);
    private static IEntity GetEntityFromRegistry(Transform transform, bool allowDestroyed);
    private static IEntity GetEntityFromComponent(Transform transform);
    [ExtensionAttribute]
public static void SetHierarchyGroup(GameObject obj, string strRoot, bool groupActive, bool persistant);
    [ExtensionAttribute]
public static bool HasComponent(GameObject obj);
    [ExtensionAttribute]
public static bool HasComponentInParent(GameObject obj);
    [ExtensionAttribute]
public static void SetChildComponentsEnabled(GameObject gameObject, bool enabled);
    [ExtensionAttribute]
public static GameObject FindInChildren(GameObject parent, string name);
}
public static class UnityEngine.NetworkNetworkable : object {
}
[ExtensionAttribute]
public static class UnityEngine.NetworkPacketEx : object {
    [ExtensionAttribute]
public static BasePlayer Player(Message v);
}
public static class UnityEngine.ObjectEffectsEx : object {
}
[ExtensionAttribute]
public static class UnityEngine.QuaternionEx : object {
    [ExtensionAttribute]
public static Quaternion AlignToNormal(Quaternion rot, Vector3 normal);
    public static Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up);
    public static Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up);
    public static Quaternion LookRotationGradient(Vector3 normal, Vector3 up);
    public static Quaternion LookRotationNormal(Vector3 normal, Vector3 up);
    [ExtensionAttribute]
public static Quaternion EnsureValid(Quaternion rot, float epsilon);
}
[ExtensionAttribute]
public static class UnityEngine.RayEx : object {
    [ExtensionAttribute]
public static Vector3 ClosestPoint(Ray ray, Vector3 pos);
    [ExtensionAttribute]
public static float Distance(Ray ray, Vector3 pos);
    [ExtensionAttribute]
public static float SqrDistance(Ray ray, Vector3 pos);
    [ExtensionAttribute]
public static bool IsNaNOrInfinity(Ray r);
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.AmbientOcclusionRenderer", "Unity/Ambient Occlusion", "True")]
public class UnityEngine.Rendering.PostProcessing.AmbientOcclusion : PostProcessEffectSettings {
    [TooltipAttribute("The ambient occlusion method to use. "Multi Scale Volumetric Obscurance" is higher quality and faster on desktop & console platforms but requires compute shader support.")]
public AmbientOcclusionModeParameter mode;
    [RangeAttribute("0", "4")]
[TooltipAttribute("The degree of darkness added by ambient occlusion. Higher values produce darker areas.")]
public FloatParameter intensity;
    [TooltipAttribute("The custom color to use for the ambient occlusion. The default is black.")]
[ColorUsageAttribute("False")]
public ColorParameter color;
    [TooltipAttribute("Check this box to mark this Volume as to only affect ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering. Objects rendered with the Forward rendering path won't get any ambient occlusion.")]
public BoolParameter ambientOnly;
    [RangeAttribute("-8", "0")]
public FloatParameter noiseFilterTolerance;
    [RangeAttribute("-8", "-1")]
public FloatParameter blurTolerance;
    [RangeAttribute("-12", "-1")]
public FloatParameter upsampleTolerance;
    [RangeAttribute("1", "10")]
[TooltipAttribute("This modifies the thickness of occluders. It increases the size of dark areas and also introduces a dark halo around objects.")]
public FloatParameter thicknessModifier;
    [TooltipAttribute("Modifies the influence of direct lighting on ambient occlusion.")]
[RangeAttribute("0", "1")]
public FloatParameter directLightingStrength;
    [TooltipAttribute("The radius of sample points. This affects the size of darkened areas.")]
public FloatParameter radius;
    [TooltipAttribute("The number of sample points. This affects both quality and performance. For "Lowest", "Low", and "Medium", passes are downsampled. For "High" and "Ultra", they are not and therefore you should only "High" and "Ultra" on high-end hardware.")]
public AmbientOcclusionQualityParameter quality;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
public enum UnityEngine.Rendering.PostProcessing.AmbientOcclusionMode : Enum {
    public int value__;
    public static AmbientOcclusionMode ScalableAmbientObscurance;
    public static AmbientOcclusionMode MultiScaleVolumetricObscurance;
}
public class UnityEngine.Rendering.PostProcessing.AmbientOcclusionModeParameter : ParameterOverride`1<AmbientOcclusionMode> {
}
public enum UnityEngine.Rendering.PostProcessing.AmbientOcclusionQuality : Enum {
    public int value__;
    public static AmbientOcclusionQuality Lowest;
    public static AmbientOcclusionQuality Low;
    public static AmbientOcclusionQuality Medium;
    public static AmbientOcclusionQuality High;
    public static AmbientOcclusionQuality Ultra;
}
public class UnityEngine.Rendering.PostProcessing.AmbientOcclusionQualityParameter : ParameterOverride`1<AmbientOcclusionQuality> {
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.AmbientOcclusionRenderer : PostProcessEffectRenderer`1<AmbientOcclusion> {
    private IAmbientOcclusionMethod[] m_Methods;
    public virtual void Init();
    public bool IsAmbientOnly(PostProcessRenderContext context);
    public IAmbientOcclusionMethod Get();
    public virtual DepthTextureMode GetCameraFlags();
    public virtual void Release();
    public ScalableAO GetScalableAO();
    public MultiScaleVO GetMultiScaleVO();
    public virtual void Render(PostProcessRenderContext context);
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.AutoExposureRenderer", "Unity/Auto Exposure", "True")]
public class UnityEngine.Rendering.PostProcessing.AutoExposure : PostProcessEffectSettings {
    [TooltipAttribute("Filters the bright and dark parts of the histogram when computing the average luminance. This is to avoid very dark pixels and very bright pixels from contributing to the auto exposure. Unit is in percent.")]
[DisplayNameAttribute("Filtering (%)")]
[MinMaxAttribute("1", "99")]
public Vector2Parameter filtering;
    [RangeAttribute("-9", "9")]
[DisplayNameAttribute("Minimum (EV)")]
[TooltipAttribute("Minimum average luminance to consider for auto exposure. Unit is EV.")]
public FloatParameter minLuminance;
    [RangeAttribute("-9", "9")]
[DisplayNameAttribute("Maximum (EV)")]
[TooltipAttribute("Maximum average luminance to consider for auto exposure. Unit is EV.")]
public FloatParameter maxLuminance;
    [MinAttribute("0")]
[DisplayNameAttribute("Exposure Compensation")]
[TooltipAttribute("Use this to scale the global exposure of the scene.")]
public FloatParameter keyValue;
    [DisplayNameAttribute("Type")]
[TooltipAttribute("Use "Progressive" if you want auto exposure to be animated. Use "Fixed" otherwise.")]
public EyeAdaptationParameter eyeAdaptation;
    [TooltipAttribute("Adaptation speed from a dark to a light environment.")]
[MinAttribute("0")]
public FloatParameter speedUp;
    [MinAttribute("0")]
[TooltipAttribute("Adaptation speed from a light to a dark environment.")]
public FloatParameter speedDown;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.AutoExposureRenderer : PostProcessEffectRenderer`1<AutoExposure> {
    private static int k_NumEyes;
    private static int k_NumAutoExposureTextures;
    private RenderTexture[][] m_AutoExposurePool;
    private Int32[] m_AutoExposurePingPong;
    private RenderTexture m_CurrentAutoExposure;
    private void CheckTexture(int eye, int id);
    public virtual void Render(PostProcessRenderContext context);
    public virtual void Release();
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.BloomRenderer", "Unity/Bloom", "True")]
public class UnityEngine.Rendering.PostProcessing.Bloom : PostProcessEffectSettings {
    [MinAttribute("0")]
[TooltipAttribute("Strength of the bloom filter. Values higher than 1 will make bloom contribute more energy to the final render.")]
public FloatParameter intensity;
    [MinAttribute("0")]
[TooltipAttribute("Filters out pixels under this level of brightness. Value is in gamma-space.")]
public FloatParameter threshold;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Makes transitions between under/over-threshold gradual. 0 for a hard threshold, 1 for a soft threshold).")]
public FloatParameter softKnee;
    [TooltipAttribute("Clamps pixels to control the bloom amount. Value is in gamma-space.")]
public FloatParameter clamp;
    [TooltipAttribute("Changes the extent of veiling effects. For maximum quality, use integer values. Because this value changes the internal iteration count, You should not animating it as it may introduce issues with the perceived radius.")]
[RangeAttribute("1", "10")]
public FloatParameter diffusion;
    [RangeAttribute("-1", "1")]
[TooltipAttribute("Distorts the bloom to give an anamorphic look. Negative values distort vertically, positive values distort horizontally.")]
public FloatParameter anamorphicRatio;
    [ColorUsageAttribute("False", "True")]
[TooltipAttribute("Global tint of the bloom filter.")]
public ColorParameter color;
    [FormerlySerializedAsAttribute("mobileOptimized")]
[TooltipAttribute("Boost performance by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
public BoolParameter fastMode;
    [DisplayNameAttribute("Texture")]
[TooltipAttribute("The lens dirt texture used to add smudges or dust to the bloom effect.")]
public TextureParameter dirtTexture;
    [MinAttribute("0")]
[DisplayNameAttribute("Intensity")]
[TooltipAttribute("The intensity of the lens dirtiness.")]
public FloatParameter dirtIntensity;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.BloomRenderer : PostProcessEffectRenderer`1<Bloom> {
    private Level[] m_Pyramid;
    private static int k_MaxPyramidSize;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class UnityEngine.Rendering.PostProcessing.BoolParameter : ParameterOverride`1<bool> {
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.ChromaticAberrationRenderer", "Unity/Chromatic Aberration", "True")]
public class UnityEngine.Rendering.PostProcessing.ChromaticAberration : PostProcessEffectSettings {
    [TooltipAttribute("Shifts the hue of chromatic aberrations.")]
public TextureParameter spectralLut;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Amount of tangential distortion.")]
public FloatParameter intensity;
    [TooltipAttribute("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
[FormerlySerializedAsAttribute("mobileOptimized")]
public BoolParameter fastMode;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.ChromaticAberrationRenderer : PostProcessEffectRenderer`1<ChromaticAberration> {
    private Texture2D m_InternalSpectralLut;
    public virtual void Render(PostProcessRenderContext context);
    public virtual void Release();
}
public enum UnityEngine.Rendering.PostProcessing.ColorBlindnessType : Enum {
    public int value__;
    public static ColorBlindnessType Deuteranopia;
    public static ColorBlindnessType Protanopia;
    public static ColorBlindnessType Tritanopia;
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.ColorGradingRenderer", "Unity/Color Grading", "True")]
public class UnityEngine.Rendering.PostProcessing.ColorGrading : PostProcessEffectSettings {
    [DisplayNameAttribute("Mode")]
[TooltipAttribute("Select a color grading mode that fits your dynamic range and workflow. Use HDR if your camera is set to render in HDR and your target platform supports it. Use LDR for low-end mobiles or devices that don't support HDR. Use External if you prefer authoring a Log LUT in an external software.")]
public GradingModeParameter gradingMode;
    [DisplayNameAttribute("Lookup Texture")]
[TooltipAttribute("A custom 3D log-encoded texture.")]
public TextureParameter externalLut;
    [DisplayNameAttribute("Mode")]
[TooltipAttribute("Select a tonemapping algorithm to use at the end of the color grading process.")]
public TonemapperParameter tonemapper;
    [DisplayNameAttribute("Toe Strength")]
[RangeAttribute("0", "1")]
[TooltipAttribute("Affects the transition between the toe and the mid section of the curve. A value of 0 means no toe, a value of 1 means a very hard transition.")]
public FloatParameter toneCurveToeStrength;
    [DisplayNameAttribute("Toe Length")]
[RangeAttribute("0", "1")]
[TooltipAttribute("Affects how much of the dynamic range is in the toe. With a small value, the toe will be very short and quickly transition into the linear section, with a larger value, the toe will be longer.")]
public FloatParameter toneCurveToeLength;
    [DisplayNameAttribute("Shoulder Strength")]
[TooltipAttribute("Affects the transition between the mid section and the shoulder of the curve. A value of 0 means no shoulder, a value of 1 means a very hard transition.")]
[RangeAttribute("0", "1")]
public FloatParameter toneCurveShoulderStrength;
    [MinAttribute("0")]
[TooltipAttribute("Affects how many F-stops (EV) to add to the dynamic range of the curve.")]
[DisplayNameAttribute("Shoulder Length")]
public FloatParameter toneCurveShoulderLength;
    [DisplayNameAttribute("Shoulder Angle")]
[RangeAttribute("0", "1")]
[TooltipAttribute("Affects how much overshoot to add to the shoulder.")]
public FloatParameter toneCurveShoulderAngle;
    [DisplayNameAttribute("Gamma")]
[MinAttribute("0,001")]
[TooltipAttribute("Applies a gamma function to the curve.")]
public FloatParameter toneCurveGamma;
    [DisplayNameAttribute("Lookup Texture")]
[TooltipAttribute("Custom lookup texture (strip format, for example 256x16) to apply before the rest of the color grading operators. If none is provided, a neutral one will be generated internally.")]
public TextureParameter ldrLut;
    [DisplayNameAttribute("Contribution")]
[RangeAttribute("0", "1")]
[TooltipAttribute("How much of the lookup texture will contribute to the color grading effect.")]
public FloatParameter ldrLutContribution;
    [TooltipAttribute("Sets the white balance to a custom color temperature.")]
[RangeAttribute("-100", "100")]
[DisplayNameAttribute("Temperature")]
public FloatParameter temperature;
    [DisplayNameAttribute("Tint")]
[RangeAttribute("-100", "100")]
[TooltipAttribute("Sets the white balance to compensate for a green or magenta tint.")]
public FloatParameter tint;
    [DisplayNameAttribute("Color Filter")]
[ColorUsageAttribute("False", "True")]
[TooltipAttribute("Tint the render by multiplying a color.")]
public ColorParameter colorFilter;
    [DisplayNameAttribute("Hue Shift")]
[RangeAttribute("-180", "180")]
[TooltipAttribute("Shift the hue of all colors.")]
public FloatParameter hueShift;
    [DisplayNameAttribute("Saturation")]
[RangeAttribute("-100", "100")]
[TooltipAttribute("Pushes the intensity of all colors.")]
public FloatParameter saturation;
    [TooltipAttribute("Makes the image brighter or darker.")]
[DisplayNameAttribute("Brightness")]
[RangeAttribute("-100", "100")]
public FloatParameter brightness;
    [DisplayNameAttribute("Post-exposure (EV)")]
[TooltipAttribute("Adjusts the overall exposure of the scene in EV units. This is applied after the HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
public FloatParameter postExposure;
    [DisplayNameAttribute("Contrast")]
[RangeAttribute("-100", "100")]
[TooltipAttribute("Expands or shrinks the overall range of tonal values.")]
public FloatParameter contrast;
    [DisplayNameAttribute("Mode")]
[TooltipAttribute("Select masking type to avoid applying grading to certain areas.")]
public MaskingModeParameter maskMode;
    [DisplayNameAttribute("Intensity")]
[RangeAttribute("0", "10")]
[TooltipAttribute("Mask intensity.")]
public FloatParameter maskIntensity;
    [DisplayNameAttribute("Red")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the red channel in the overall mix.")]
public FloatParameter mixerRedOutRedIn;
    [TooltipAttribute("Modify influence of the green channel in the overall mix.")]
[DisplayNameAttribute("Green")]
[RangeAttribute("-200", "200")]
public FloatParameter mixerRedOutGreenIn;
    [DisplayNameAttribute("Blue")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the blue channel in the overall mix.")]
public FloatParameter mixerRedOutBlueIn;
    [DisplayNameAttribute("Red")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the red channel in the overall mix.")]
public FloatParameter mixerGreenOutRedIn;
    [DisplayNameAttribute("Green")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the green channel in the overall mix.")]
public FloatParameter mixerGreenOutGreenIn;
    [TooltipAttribute("Modify influence of the blue channel in the overall mix.")]
[DisplayNameAttribute("Blue")]
[RangeAttribute("-200", "200")]
public FloatParameter mixerGreenOutBlueIn;
    [TooltipAttribute("Modify influence of the red channel in the overall mix.")]
[DisplayNameAttribute("Red")]
[RangeAttribute("-200", "200")]
public FloatParameter mixerBlueOutRedIn;
    [DisplayNameAttribute("Green")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the green channel in the overall mix.")]
public FloatParameter mixerBlueOutGreenIn;
    [DisplayNameAttribute("Blue")]
[RangeAttribute("-200", "200")]
[TooltipAttribute("Modify influence of the blue channel in the overall mix.")]
public FloatParameter mixerBlueOutBlueIn;
    [DisplayNameAttribute("Lift")]
[TooltipAttribute("Controls the darkest portions of the render.")]
[TrackballAttribute("1")]
public Vector4Parameter lift;
    [TrackballAttribute("2")]
[DisplayNameAttribute("Gamma")]
[TooltipAttribute("Power function that controls mid-range tones.")]
public Vector4Parameter gamma;
    [DisplayNameAttribute("Gain")]
[TooltipAttribute("Controls the lightest portions of the render.")]
[TrackballAttribute("3")]
public Vector4Parameter gain;
    public SplineParameter masterCurve;
    public SplineParameter redCurve;
    public SplineParameter greenCurve;
    public SplineParameter blueCurve;
    public SplineParameter hueVsHueCurve;
    public SplineParameter hueVsSatCurve;
    public SplineParameter satVsSatCurve;
    public SplineParameter lumVsSatCurve;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.ColorGradingRenderer : PostProcessEffectRenderer`1<ColorGrading> {
    private Texture2D m_GradingCurves;
    private Color[] m_Pixels;
    private RenderTexture m_InternalLdrLut;
    private RenderTexture m_InternalLogLut;
    private static int k_Lut2DSize;
    private static int k_Lut3DSize;
    private HableCurve m_HableCurve;
    public virtual void Render(PostProcessRenderContext context);
    private void RenderExternalPipeline3D(PostProcessRenderContext context);
    private void RenderHDRPipeline3D(PostProcessRenderContext context);
    private void RenderHDRPipeline2D(PostProcessRenderContext context);
    private void RenderLDRPipeline2D(PostProcessRenderContext context);
    private void CheckInternalLogLut();
    private void CheckInternalStripLut();
    private Texture2D GetCurveTexture(bool hdr);
    private static bool IsRenderTextureFormatSupportedForLinearFiltering(RenderTextureFormat format);
    private static RenderTextureFormat GetLutFormat();
    private static TextureFormat GetCurveFormat();
    public virtual void Release();
}
public class UnityEngine.Rendering.PostProcessing.ColorParameter : ParameterOverride`1<Color> {
    public virtual void Interp(Color from, Color to, float t);
    public static Vector4 op_Implicit(ColorParameter prop);
}
public static class UnityEngine.Rendering.PostProcessing.ColorUtilities : object {
    private static float logC_cut;
    private static float logC_a;
    private static float logC_b;
    private static float logC_c;
    private static float logC_d;
    private static float logC_e;
    private static float logC_f;
    public static float StandardIlluminantY(float x);
    public static Vector3 CIExyToLMS(float x, float y);
    public static Vector3 ComputeColorBalance(float temperature, float tint);
    public static Vector3 ColorToLift(Vector4 color);
    public static Vector3 ColorToInverseGamma(Vector4 color);
    public static Vector3 ColorToGain(Vector4 color);
    public static float LogCToLinear(float x);
    public static float LinearToLogC(float x);
    public static UInt32 ToHex(Color c);
    public static Color ToRGBA(UInt32 hex);
}
public enum UnityEngine.Rendering.PostProcessing.DebugOverlay : Enum {
    public int value__;
    public static DebugOverlay None;
    public static DebugOverlay Depth;
    public static DebugOverlay Normals;
    public static DebugOverlay MotionVectors;
    public static DebugOverlay NANTracker;
    public static DebugOverlay ColorBlindnessSimulation;
    public static DebugOverlay _;
    public static DebugOverlay AmbientOcclusion;
    public static DebugOverlay BloomBuffer;
    public static DebugOverlay BloomThreshold;
    public static DebugOverlay DepthOfField;
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.DepthOfFieldRenderer", "Unity/Depth of Field", "False")]
public class UnityEngine.Rendering.PostProcessing.DepthOfField : PostProcessEffectSettings {
    [MinAttribute("0,1")]
[TooltipAttribute("Distance to the point of focus.")]
public FloatParameter focusDistance;
    [RangeAttribute("0,05", "32")]
[TooltipAttribute("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
public FloatParameter aperture;
    [RangeAttribute("1", "300")]
[TooltipAttribute("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
public FloatParameter focalLength;
    [DisplayNameAttribute("Max Blur Size")]
[TooltipAttribute("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects performances (the larger the kernel is, the longer the GPU time is required).")]
public KernelSizeParameter kernelSize;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.DepthOfFieldRenderer : PostProcessEffectRenderer`1<DepthOfField> {
    private static int k_NumEyes;
    private static int k_NumCoCHistoryTextures;
    private RenderTexture[][] m_CoCHistoryTextures;
    private Int32[] m_HistoryPingPong;
    private static float k_FilmHeight;
    public virtual DepthTextureMode GetCameraFlags();
    private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary);
    private float CalculateMaxCoCRadius(int screenHeight);
    private RenderTexture CheckHistory(int eye, int id, PostProcessRenderContext context, RenderTextureFormat format);
    public virtual void Render(PostProcessRenderContext context);
    public virtual void Release();
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Rendering.PostProcessing.DisplayNameAttribute : Attribute {
    public string displayName;
    public DisplayNameAttribute(string displayName);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.Dithering : object {
    private int m_NoiseTextureIndex;
    internal void Render(PostProcessRenderContext context);
}
public enum UnityEngine.Rendering.PostProcessing.EyeAdaptation : Enum {
    public int value__;
    public static EyeAdaptation Progressive;
    public static EyeAdaptation Fixed;
}
public class UnityEngine.Rendering.PostProcessing.EyeAdaptationParameter : ParameterOverride`1<EyeAdaptation> {
}
[PreserveAttribute]
public class UnityEngine.Rendering.PostProcessing.FastApproximateAntialiasing : object {
    [TooltipAttribute("Boost performances by lowering the effect quality. This setting is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
[FormerlySerializedAsAttribute("mobileOptimized")]
public bool fastMode;
    [TooltipAttribute("Keep alpha channel. This will slightly lower the effect quality but allows rendering against a transparent background.")]
public bool keepAlpha;
}
public class UnityEngine.Rendering.PostProcessing.FloatParameter : ParameterOverride`1<float> {
    public virtual void Interp(float from, float to, float t);
}
[PreserveAttribute]
public class UnityEngine.Rendering.PostProcessing.Fog : object {
    [TooltipAttribute("Enables the internal deferred fog pass. Actual fog settings should be set in the Lighting panel.")]
public bool enabled;
    [TooltipAttribute("Mark true for the fog to ignore the skybox")]
public bool excludeSkybox;
    internal DepthTextureMode GetCameraFlags();
    internal bool IsEnabledAndSupported(PostProcessRenderContext context);
    internal void Render(PostProcessRenderContext context);
}
public enum UnityEngine.Rendering.PostProcessing.GradingMode : Enum {
    public int value__;
    public static GradingMode LowDefinitionRange;
    public static GradingMode HighDefinitionRange;
    public static GradingMode External;
}
public class UnityEngine.Rendering.PostProcessing.GradingModeParameter : ParameterOverride`1<GradingMode> {
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.GrainRenderer", "Unity/Grain", "True")]
public class UnityEngine.Rendering.PostProcessing.Grain : PostProcessEffectSettings {
    [TooltipAttribute("Enable the use of colored grain.")]
public BoolParameter colored;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Grain strength. Higher values mean more visible grain.")]
public FloatParameter intensity;
    [RangeAttribute("0,3", "3")]
[TooltipAttribute("Grain particle size.")]
public FloatParameter size;
    [DisplayNameAttribute("Luminance Contribution")]
[TooltipAttribute("Controls the noise response curve based on scene luminance. Lower values mean less noise in dark areas.")]
[RangeAttribute("0", "1")]
public FloatParameter lumContrib;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.GrainRenderer : PostProcessEffectRenderer`1<Grain> {
    private RenderTexture m_GrainLookupRT;
    private static int k_SampleCount;
    private int m_SampleIndex;
    public virtual void Render(PostProcessRenderContext context);
    private RenderTextureFormat GetLookupFormat();
    public virtual void Release();
}
public class UnityEngine.Rendering.PostProcessing.HableCurve : object {
    [CompilerGeneratedAttribute]
private float <whitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private float <inverseWhitePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private float <x0>k__BackingField;
    [CompilerGeneratedAttribute]
private float <x1>k__BackingField;
    private Segment[] m_Segments;
    public Uniforms uniforms;
    public float whitePoint { get; private set; }
    public float inverseWhitePoint { get; private set; }
    internal float x0 { get; private set; }
    internal float x1 { get; private set; }
    [CompilerGeneratedAttribute]
public float get_whitePoint();
    [CompilerGeneratedAttribute]
private void set_whitePoint(float value);
    [CompilerGeneratedAttribute]
public float get_inverseWhitePoint();
    [CompilerGeneratedAttribute]
private void set_inverseWhitePoint(float value);
    [CompilerGeneratedAttribute]
internal float get_x0();
    [CompilerGeneratedAttribute]
private void set_x0(float value);
    [CompilerGeneratedAttribute]
internal float get_x1();
    [CompilerGeneratedAttribute]
private void set_x1(float value);
    public float Eval(float x);
    public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma);
    private void InitSegments(DirectParams srcParams);
    private void SolveAB(Single& lnA, Single& B, float x0, float y0, float m);
    private void AsSlopeIntercept(Single& m, Single& b, float x0, float x1, float y0, float y1);
    private float EvalDerivativeLinearGamma(float m, float b, float g, float x);
}
public static class UnityEngine.Rendering.PostProcessing.HaltonSeq : object {
    public static float Get(int index, int radix);
}
public class UnityEngine.Rendering.PostProcessing.HistogramMonitor : Monitor {
    public int width;
    public int height;
    public Channel channel;
    private ComputeBuffer m_Data;
    private static int k_NumBins;
    private static int k_ThreadGroupSizeX;
    private static int k_ThreadGroupSizeY;
    internal virtual void OnDisable();
    internal virtual bool NeedsHalfRes();
    internal virtual bool ShaderResourcesAvailable(PostProcessRenderContext context);
    internal virtual void Render(PostProcessRenderContext context);
}
internal interface UnityEngine.Rendering.PostProcessing.IAmbientOcclusionMethod {
    public abstract virtual DepthTextureMode GetCameraFlags();
    public abstract virtual void RenderAfterOpaque(PostProcessRenderContext context);
    public abstract virtual void RenderAmbientOnly(PostProcessRenderContext context);
    public abstract virtual void CompositeAmbientOnly(PostProcessRenderContext context);
    public abstract virtual void Release();
}
public class UnityEngine.Rendering.PostProcessing.IntParameter : ParameterOverride`1<int> {
    public virtual void Interp(int from, int to, float t);
}
public enum UnityEngine.Rendering.PostProcessing.KernelSize : Enum {
    public int value__;
    public static KernelSize Small;
    public static KernelSize Medium;
    public static KernelSize Large;
    public static KernelSize VeryLarge;
}
public class UnityEngine.Rendering.PostProcessing.KernelSizeParameter : ParameterOverride`1<KernelSize> {
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.LensDistortionRenderer", "Unity/Lens Distortion", "True")]
public class UnityEngine.Rendering.PostProcessing.LensDistortion : PostProcessEffectSettings {
    [RangeAttribute("-100", "100")]
[TooltipAttribute("Total distortion amount.")]
public FloatParameter intensity;
    [RangeAttribute("0", "1")]
[DisplayNameAttribute("X Multiplier")]
[TooltipAttribute("Intensity multiplier on the x-axis. Set it to 0 to disable distortion on this axis.")]
public FloatParameter intensityX;
    [RangeAttribute("0", "1")]
[DisplayNameAttribute("Y Multiplier")]
[TooltipAttribute("Intensity multiplier on the y-axis. Set it to 0 to disable distortion on this axis.")]
public FloatParameter intensityY;
    [SpaceAttribute]
[RangeAttribute("-1", "1")]
[TooltipAttribute("Distortion center point (x-axis).")]
public FloatParameter centerX;
    [TooltipAttribute("Distortion center point (y-axis).")]
[RangeAttribute("-1", "1")]
public FloatParameter centerY;
    [SpaceAttribute]
[TooltipAttribute("Global screen scaling.")]
[RangeAttribute("0,01", "5")]
public FloatParameter scale;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.LensDistortionRenderer : PostProcessEffectRenderer`1<LensDistortion> {
    public virtual void Render(PostProcessRenderContext context);
}
public class UnityEngine.Rendering.PostProcessing.LightMeterMonitor : Monitor {
    public int width;
    public int height;
    public bool showCurves;
    internal virtual bool ShaderResourcesAvailable(PostProcessRenderContext context);
    internal virtual void Render(PostProcessRenderContext context);
}
internal class UnityEngine.Rendering.PostProcessing.LogHistogram : object {
    public static int rangeMin;
    public static int rangeMax;
    private static int k_Bins;
    [CompilerGeneratedAttribute]
private ComputeBuffer <data>k__BackingField;
    public ComputeBuffer data { get; private set; }
    [CompilerGeneratedAttribute]
public ComputeBuffer get_data();
    [CompilerGeneratedAttribute]
private void set_data(ComputeBuffer value);
    public void Generate(PostProcessRenderContext context);
    public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context);
    public void Release();
}
public enum UnityEngine.Rendering.PostProcessing.MaskingMode : Enum {
    public int value__;
    public static MaskingMode None;
    public static MaskingMode SourceAlpha;
    public static MaskingMode SourceOneMinusAlpha;
}
public class UnityEngine.Rendering.PostProcessing.MaskingModeParameter : ParameterOverride`1<MaskingMode> {
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Rendering.PostProcessing.MaxAttribute : Attribute {
    public float max;
    public MaxAttribute(float max);
}
internal static class UnityEngine.Rendering.PostProcessing.MeshUtilities : object {
    private static Dictionary`2<PrimitiveType, Mesh> s_Primitives;
    private static Dictionary`2<Type, PrimitiveType> s_ColliderPrimitives;
    private static MeshUtilities();
    internal static Mesh GetColliderMesh(Collider collider);
    internal static Mesh GetPrimitive(PrimitiveType primitiveType);
    private static Mesh GetBuiltinMesh(PrimitiveType primitiveType);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Rendering.PostProcessing.MinAttribute : Attribute {
    public float min;
    public MinAttribute(float min);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Rendering.PostProcessing.MinMaxAttribute : Attribute {
    public float min;
    public float max;
    public MinMaxAttribute(float min, float max);
}
public abstract class UnityEngine.Rendering.PostProcessing.Monitor : object {
    [CompilerGeneratedAttribute]
private RenderTexture <output>k__BackingField;
    internal bool requested;
    public RenderTexture output { get; protected set; }
    [CompilerGeneratedAttribute]
public RenderTexture get_output();
    [CompilerGeneratedAttribute]
protected void set_output(RenderTexture value);
    public bool IsRequestedAndSupported(PostProcessRenderContext context);
    internal abstract virtual bool ShaderResourcesAvailable(PostProcessRenderContext context);
    internal virtual bool NeedsHalfRes();
    protected void CheckOutput(int width, int height);
    internal virtual void OnEnable();
    internal virtual void OnDisable();
    internal abstract virtual void Render(PostProcessRenderContext context);
}
public enum UnityEngine.Rendering.PostProcessing.MonitorType : Enum {
    public int value__;
    public static MonitorType LightMeter;
    public static MonitorType Histogram;
    public static MonitorType Waveform;
    public static MonitorType Vectorscope;
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.MotionBlurRenderer", "Unity/Motion Blur", "False")]
public class UnityEngine.Rendering.PostProcessing.MotionBlur : PostProcessEffectSettings {
    [TooltipAttribute("The angle of rotary shutter. Larger values give longer exposure.")]
[RangeAttribute("0", "360")]
public FloatParameter shutterAngle;
    [TooltipAttribute("The amount of sample points. This affects quality and performance.")]
[RangeAttribute("4", "32")]
public IntParameter sampleCount;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.MotionBlurRenderer : PostProcessEffectRenderer`1<MotionBlur> {
    public virtual DepthTextureMode GetCameraFlags();
    public virtual void Render(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.MultiScaleVO : object {
    private Single[] m_SampleThickness;
    private Single[] m_InvThicknessTable;
    private Single[] m_SampleWeightTable;
    private Int32[] m_Widths;
    private Int32[] m_Heights;
    private AmbientOcclusion m_Settings;
    private PropertySheet m_PropertySheet;
    private PostProcessResources m_Resources;
    private RenderTexture m_AmbientOnlyAO;
    private RenderTargetIdentifier[] m_MRT;
    public MultiScaleVO(AmbientOcclusion settings);
    public sealed virtual DepthTextureMode GetCameraFlags();
    public void SetResources(PostProcessResources resources);
    private void Alloc(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav);
    private void AllocArray(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav);
    private void Release(CommandBuffer cmd, int id);
    private Vector4 CalculateZBufferParams(Camera camera);
    private float CalculateTanHalfFovHeight(Camera camera);
    private Vector2 GetSize(MipLevel mip);
    private Vector3 GetSizeArray(MipLevel mip);
    public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, Nullable`1<RenderTargetIdentifier> depthMap, bool invert, bool isMSAA);
    private void PushAllocCommands(CommandBuffer cmd, bool isMSAA);
    private void PushDownsampleCommands(CommandBuffer cmd, Camera camera, Nullable`1<RenderTargetIdentifier> depthMap, bool isMSAA);
    private void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH, bool isMSAA);
    private void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, Nullable`1<int> highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool isMSAA, bool invert);
    private void PushReleaseCommands(CommandBuffer cmd);
    private void PreparePropertySheet(PostProcessRenderContext context);
    private void CheckAOTexture(PostProcessRenderContext context);
    private void PushDebug(PostProcessRenderContext context);
    public sealed virtual void RenderAfterOpaque(PostProcessRenderContext context);
    public sealed virtual void RenderAmbientOnly(PostProcessRenderContext context);
    public sealed virtual void CompositeAmbientOnly(PostProcessRenderContext context);
    public sealed virtual void Release();
}
public abstract class UnityEngine.Rendering.PostProcessing.ParameterOverride : object {
    public bool overrideState;
    internal abstract virtual void Interp(ParameterOverride from, ParameterOverride to, float t);
    public abstract virtual int GetHash();
    public T GetValue();
    protected internal virtual void OnEnable();
    protected internal virtual void OnDisable();
    internal abstract virtual void SetValue(ParameterOverride parameter);
}
public class UnityEngine.Rendering.PostProcessing.ParameterOverride`1 : ParameterOverride {
    public T value;
    public ParameterOverride`1(T value);
    public ParameterOverride`1(T value, bool overrideState);
    internal virtual void Interp(ParameterOverride from, ParameterOverride to, float t);
    public virtual void Interp(T from, T to, float t);
    public void Override(T x);
    internal virtual void SetValue(ParameterOverride parameter);
    public virtual int GetHash();
    public static T op_Implicit(ParameterOverride`1<T> prop);
}
[AttributeUsageAttribute("4")]
public class UnityEngine.Rendering.PostProcessing.PostProcessAttribute : Attribute {
    public Type renderer;
    public PostProcessEvent eventType;
    public string menuItem;
    public bool allowInSceneView;
    internal bool builtinEffect;
    public PostProcessAttribute(Type renderer, PostProcessEvent eventType, string menuItem, bool allowInSceneView);
    internal PostProcessAttribute(Type renderer, string menuItem, bool allowInSceneView);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessBundle : object {
    [CompilerGeneratedAttribute]
private PostProcessAttribute <attribute>k__BackingField;
    [CompilerGeneratedAttribute]
private PostProcessEffectSettings <settings>k__BackingField;
    private PostProcessEffectRenderer m_Renderer;
    public PostProcessAttribute attribute { get; private set; }
    public PostProcessEffectSettings settings { get; private set; }
    internal PostProcessEffectRenderer renderer { get; }
    internal PostProcessBundle(PostProcessEffectSettings settings);
    [CompilerGeneratedAttribute]
public PostProcessAttribute get_attribute();
    [CompilerGeneratedAttribute]
private void set_attribute(PostProcessAttribute value);
    [CompilerGeneratedAttribute]
public PostProcessEffectSettings get_settings();
    [CompilerGeneratedAttribute]
private void set_settings(PostProcessEffectSettings value);
    internal PostProcessEffectRenderer get_renderer();
    internal void Release();
    internal void ResetHistory();
    internal T CastSettings();
    internal T CastRenderer();
}
[AddComponentMenu("Rendering/Post-process Debug", "1002")]
[ExecuteAlways]
public class UnityEngine.Rendering.PostProcessing.PostProcessDebug : MonoBehaviour {
    public PostProcessLayer postProcessLayer;
    private PostProcessLayer m_PreviousPostProcessLayer;
    public bool lightMeter;
    public bool histogram;
    public bool waveform;
    public bool vectorscope;
    public DebugOverlay debugOverlay;
    private Camera m_CurrentCamera;
    private CommandBuffer m_CmdAfterEverything;
    private void OnEnable();
    private void OnDisable();
    private void Update();
    private void Reset();
    private void UpdateStates();
    private void OnPostRender();
    private void OnGUI();
    private void DrawMonitor(Rect& rect, Monitor monitor, bool enabled);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessDebugLayer : object {
    public LightMeterMonitor lightMeter;
    public HistogramMonitor histogram;
    public WaveformMonitor waveform;
    public VectorscopeMonitor vectorscope;
    private Dictionary`2<MonitorType, Monitor> m_Monitors;
    private int frameWidth;
    private int frameHeight;
    [CompilerGeneratedAttribute]
private RenderTexture <debugOverlayTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <debugOverlayActive>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugOverlay <debugOverlay>k__BackingField;
    public OverlaySettings overlaySettings;
    public RenderTexture debugOverlayTarget { get; private set; }
    public bool debugOverlayActive { get; private set; }
    public DebugOverlay debugOverlay { get; private set; }
    [CompilerGeneratedAttribute]
public RenderTexture get_debugOverlayTarget();
    [CompilerGeneratedAttribute]
private void set_debugOverlayTarget(RenderTexture value);
    [CompilerGeneratedAttribute]
public bool get_debugOverlayActive();
    [CompilerGeneratedAttribute]
private void set_debugOverlayActive(bool value);
    [CompilerGeneratedAttribute]
public DebugOverlay get_debugOverlay();
    [CompilerGeneratedAttribute]
private void set_debugOverlay(DebugOverlay value);
    internal void OnEnable();
    internal void OnDisable();
    private void DestroyDebugOverlayTarget();
    public void RequestMonitorPass(MonitorType monitor);
    public void RequestDebugOverlay(DebugOverlay mode);
    internal void SetFrameSize(int width, int height);
    public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass);
    internal DepthTextureMode GetCameraFlags();
    internal void RenderMonitors(PostProcessRenderContext context);
    internal void RenderSpecialOverlays(PostProcessRenderContext context);
    internal void EndFrame();
}
public abstract class UnityEngine.Rendering.PostProcessing.PostProcessEffectRenderer : object {
    protected bool m_ResetHistory;
    public virtual void Init();
    public virtual DepthTextureMode GetCameraFlags();
    public virtual void ResetHistory();
    public virtual void Release();
    public abstract virtual void Render(PostProcessRenderContext context);
    internal abstract virtual void SetSettings(PostProcessEffectSettings settings);
}
public abstract class UnityEngine.Rendering.PostProcessing.PostProcessEffectRenderer`1 : PostProcessEffectRenderer {
    [CompilerGeneratedAttribute]
private T <settings>k__BackingField;
    public T settings { get; internal set; }
    [CompilerGeneratedAttribute]
public T get_settings();
    [CompilerGeneratedAttribute]
internal void set_settings(T value);
    internal virtual void SetSettings(PostProcessEffectSettings settings);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessEffectSettings : ScriptableObject {
    public bool active;
    public BoolParameter enabled;
    internal ReadOnlyCollection`1<ParameterOverride> parameters;
    private void OnEnable();
    private void OnDisable();
    public void SetAllOverridesTo(bool state, bool excludeEnabled);
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
    public int GetHash();
    [CompilerGeneratedAttribute]
private ParameterOverride <OnEnable>b__3_2(FieldInfo t);
}
public enum UnityEngine.Rendering.PostProcessing.PostProcessEvent : Enum {
    public int value__;
    public static PostProcessEvent BeforeTransparent;
    public static PostProcessEvent BeforeStack;
    public static PostProcessEvent AfterStack;
}
internal class UnityEngine.Rendering.PostProcessing.PostProcessEventComparer : ValueType {
    public sealed virtual bool Equals(PostProcessEvent x, PostProcessEvent y);
    public sealed virtual int GetHashCode(PostProcessEvent obj);
}
[AddComponentMenu("Rendering/Post-process Layer", "1000")]
[RequireComponent("UnityEngine.Camera")]
[DisallowMultipleComponent]
[ExecuteAlways]
[ImageEffectAllowedInSceneView]
public class UnityEngine.Rendering.PostProcessing.PostProcessLayer : MonoBehaviour {
    public Transform volumeTrigger;
    public LayerMask volumeLayer;
    public bool stopNaNPropagation;
    public bool finalBlitToCameraTarget;
    public Antialiasing antialiasingMode;
    public TemporalAntialiasing temporalAntialiasing;
    public SubpixelMorphologicalAntialiasing subpixelMorphologicalAntialiasing;
    public FastApproximateAntialiasing fastApproximateAntialiasing;
    public Fog fog;
    private Dithering dithering;
    public PostProcessDebugLayer debugLayer;
    public RenderTextureFormat intermediateFormat;
    private RenderTextureFormat prevIntermediateFormat;
    private bool supportsIntermediateFormat;
    [SerializeField]
private PostProcessResources m_Resources;
    [PreserveAttribute]
[SerializeField]
private bool m_ShowToolkit;
    [PreserveAttribute]
[SerializeField]
private bool m_ShowCustomSorter;
    public bool breakBeforeColorGrading;
    [SerializeField]
private List`1<SerializedBundleRef> m_BeforeTransparentBundles;
    [SerializeField]
private List`1<SerializedBundleRef> m_BeforeStackBundles;
    [SerializeField]
private List`1<SerializedBundleRef> m_AfterStackBundles;
    [CompilerGeneratedAttribute]
private Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> <sortedBundles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <haveBundlesBeenInited>k__BackingField;
    private Dictionary`2<Type, PostProcessBundle> m_Bundles;
    private PropertySheetFactory m_PropertySheetFactory;
    private CommandBuffer m_LegacyCmdBufferBeforeReflections;
    private CommandBuffer m_LegacyCmdBufferBeforeLighting;
    private CommandBuffer m_LegacyCmdBufferOpaque;
    private CommandBuffer m_LegacyCmdBuffer;
    private Camera m_Camera;
    private PostProcessRenderContext m_CurrentContext;
    private LogHistogram m_LogHistogram;
    private bool m_SettingsUpdateNeeded;
    private bool m_IsRenderingInSceneView;
    private TargetPool m_TargetPool;
    private bool m_NaNKilled;
    private List`1<PostProcessEffectRenderer> m_ActiveEffects;
    private List`1<RenderTargetIdentifier> m_Targets;
    public Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> sortedBundles { get; private set; }
    public bool haveBundlesBeenInited { get; private set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> get_sortedBundles();
    [CompilerGeneratedAttribute]
private void set_sortedBundles(Dictionary`2<PostProcessEvent, List`1<SerializedBundleRef>> value);
    [CompilerGeneratedAttribute]
public bool get_haveBundlesBeenInited();
    [CompilerGeneratedAttribute]
private void set_haveBundlesBeenInited(bool value);
    private void OnEnable();
    private void InitLegacy();
    [ImageEffectUsesCommandBuffer]
private void OnRenderImage(RenderTexture src, RenderTexture dst);
    public void Init(PostProcessResources resources);
    public void InitBundles();
    private void UpdateBundleSortList(List`1<SerializedBundleRef> sortedList, PostProcessEvent evt);
    private void OnDisable();
    private void Reset();
    private void OnPreCull();
    private void OnPreRender();
    private RenderTextureFormat GetIntermediateFormat();
    private static bool RequiresInitialBlit(Camera camera, PostProcessRenderContext context);
    private void UpdateSrcDstForOpaqueOnly(Int32& src, Int32& dst, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget, int opaqueOnlyEffectsRemaining);
    private void BuildCommandBuffers();
    private void BuildPostEffectsOld(RenderTextureFormat sourceFormat, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget);
    private void OnPostRender();
    public PostProcessBundle GetBundle();
    public PostProcessBundle GetBundle(Type settingsType);
    public T GetSettings();
    public void BakeMSVOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, Nullable`1<RenderTargetIdentifier> depthMap, bool invert, bool isMSAA);
    internal void OverrideSettings(List`1<PostProcessEffectSettings> baseSettings, float interpFactor);
    private void SetLegacyCameraFlags(PostProcessRenderContext context);
    public void ResetHistory();
    public bool HasOpaqueOnlyEffects(PostProcessRenderContext context);
    public bool HasActiveEffects(PostProcessEvent evt, PostProcessRenderContext context);
    private void SetupContext(PostProcessRenderContext context);
    public void UpdateVolumeSystem(Camera cam, CommandBuffer cmd);
    public void RenderOpaqueOnly(PostProcessRenderContext context);
    public void Render(PostProcessRenderContext context);
    private int RenderInjectionPoint(PostProcessEvent evt, PostProcessRenderContext context, string marker, int releaseTargetAfterUse);
    private void RenderList(List`1<SerializedBundleRef> list, PostProcessRenderContext context, string marker);
    private void ApplyFlip(PostProcessRenderContext context, MaterialPropertyBlock properties);
    private void ApplyDefaultFlip(MaterialPropertyBlock properties);
    private int RenderBuiltins(PostProcessRenderContext context, bool isFinalPass, int releaseTargetAfterUse, int eye);
    private void RenderFinalPass(PostProcessRenderContext context, int releaseTargetAfterUse, int eye);
    private int RenderEffect(PostProcessRenderContext context, bool useTempTarget);
    private bool ShouldGenerateLogHistogram(PostProcessRenderContext context);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessManager : object {
    private static PostProcessManager s_Instance;
    private static int k_MaxLayerCount;
    private Dictionary`2<int, List`1<PostProcessVolume>> m_SortedVolumes;
    private List`1<PostProcessVolume> m_Volumes;
    private Dictionary`2<int, bool> m_SortNeeded;
    private List`1<PostProcessEffectSettings> m_BaseSettings;
    public Dictionary`2<Type, PostProcessAttribute> settingsTypes;
    public static PostProcessManager instance { get; }
    public static PostProcessManager get_instance();
    private void CleanBaseTypes();
    private void ReloadBaseTypes();
    public void GetActiveVolumes(PostProcessLayer layer, List`1<PostProcessVolume> results, bool skipDisabled, bool skipZeroWeight);
    public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer);
    public PostProcessVolume GetHighestPriorityVolume(LayerMask mask);
    public PostProcessVolume QuickVolume(int layer, float priority, PostProcessEffectSettings[] settings);
    internal void SetLayerDirty(int layer);
    internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer);
    private void Register(PostProcessVolume volume, int layer);
    internal void Register(PostProcessVolume volume);
    private void Unregister(PostProcessVolume volume, int layer);
    internal void Unregister(PostProcessVolume volume);
    private void ReplaceData(PostProcessLayer postProcessLayer);
    internal void UpdateSettings(PostProcessLayer postProcessLayer, Camera camera);
    private List`1<PostProcessVolume> GrabVolumes(LayerMask mask);
    private static void SortByPriority(List`1<PostProcessVolume> volumes);
    private static bool IsVolumeRenderedByCamera(PostProcessVolume volume, Camera camera);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessProfile : ScriptableObject {
    [TooltipAttribute("A list of all settings currently stored in this profile.")]
public List`1<PostProcessEffectSettings> settings;
    public bool isDirty;
    private void OnEnable();
    public T AddSettings();
    public PostProcessEffectSettings AddSettings(Type type);
    public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect);
    public void RemoveSettings();
    public void RemoveSettings(Type type);
    public bool HasSettings();
    public bool HasSettings(Type type);
    public T GetSetting();
    public bool TryGetSettings(T& outSetting);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessRenderContext : object {
    public bool dlssEnabled;
    private Camera m_Camera;
    [CompilerGeneratedAttribute]
private CommandBuffer <command>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderTargetIdentifier <source>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderTargetIdentifier <destination>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderTextureFormat <sourceFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <flip>k__BackingField;
    [CompilerGeneratedAttribute]
private PostProcessResources <resources>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySheetFactory <propertySheets>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <userData>k__BackingField;
    [CompilerGeneratedAttribute]
private PostProcessDebugLayer <debugLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <height>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <stereoActive>k__BackingField;
    [CompilerGeneratedAttribute]
private int <xrActiveEye>k__BackingField;
    [CompilerGeneratedAttribute]
private int <numberOfEyes>k__BackingField;
    [CompilerGeneratedAttribute]
private StereoRenderingMode <stereoRenderingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <screenWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <screenHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <isSceneView>k__BackingField;
    [CompilerGeneratedAttribute]
private Antialiasing <antialiasing>k__BackingField;
    [CompilerGeneratedAttribute]
private TemporalAntialiasing <temporalAntialiasing>k__BackingField;
    internal PropertySheet uberSheet;
    internal Texture autoExposureTexture;
    internal LogHistogram logHistogram;
    internal Texture logLut;
    internal AutoExposure autoExposure;
    internal int bloomBufferNameID;
    internal bool physicalCamera;
    private RenderTextureDescriptor m_sourceDescriptor;
    public Camera camera { get; public set; }
    public CommandBuffer command { get; public set; }
    public RenderTargetIdentifier source { get; public set; }
    public RenderTargetIdentifier destination { get; public set; }
    public RenderTextureFormat sourceFormat { get; public set; }
    public bool flip { get; public set; }
    public PostProcessResources resources { get; internal set; }
    public PropertySheetFactory propertySheets { get; internal set; }
    public Dictionary`2<string, object> userData { get; private set; }
    public PostProcessDebugLayer debugLayer { get; internal set; }
    public int width { get; public set; }
    public int height { get; public set; }
    public bool stereoActive { get; private set; }
    public int xrActiveEye { get; private set; }
    public int numberOfEyes { get; private set; }
    public StereoRenderingMode stereoRenderingMode { get; private set; }
    public int screenWidth { get; public set; }
    public int screenHeight { get; public set; }
    public bool isSceneView { get; internal set; }
    public Antialiasing antialiasing { get; internal set; }
    public TemporalAntialiasing temporalAntialiasing { get; internal set; }
    public void Resize(int width, int height, bool dlssEnabled);
    public Camera get_camera();
    public void set_camera(Camera value);
    [CompilerGeneratedAttribute]
public CommandBuffer get_command();
    [CompilerGeneratedAttribute]
public void set_command(CommandBuffer value);
    [CompilerGeneratedAttribute]
public RenderTargetIdentifier get_source();
    [CompilerGeneratedAttribute]
public void set_source(RenderTargetIdentifier value);
    [CompilerGeneratedAttribute]
public RenderTargetIdentifier get_destination();
    [CompilerGeneratedAttribute]
public void set_destination(RenderTargetIdentifier value);
    [CompilerGeneratedAttribute]
public RenderTextureFormat get_sourceFormat();
    [CompilerGeneratedAttribute]
public void set_sourceFormat(RenderTextureFormat value);
    [CompilerGeneratedAttribute]
public bool get_flip();
    [CompilerGeneratedAttribute]
public void set_flip(bool value);
    [CompilerGeneratedAttribute]
public PostProcessResources get_resources();
    [CompilerGeneratedAttribute]
internal void set_resources(PostProcessResources value);
    [CompilerGeneratedAttribute]
public PropertySheetFactory get_propertySheets();
    [CompilerGeneratedAttribute]
internal void set_propertySheets(PropertySheetFactory value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_userData();
    [CompilerGeneratedAttribute]
private void set_userData(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public PostProcessDebugLayer get_debugLayer();
    [CompilerGeneratedAttribute]
internal void set_debugLayer(PostProcessDebugLayer value);
    [CompilerGeneratedAttribute]
public int get_width();
    [CompilerGeneratedAttribute]
public void set_width(int value);
    [CompilerGeneratedAttribute]
public int get_height();
    [CompilerGeneratedAttribute]
public void set_height(int value);
    [CompilerGeneratedAttribute]
public bool get_stereoActive();
    [CompilerGeneratedAttribute]
private void set_stereoActive(bool value);
    [CompilerGeneratedAttribute]
public int get_xrActiveEye();
    [CompilerGeneratedAttribute]
private void set_xrActiveEye(int value);
    [CompilerGeneratedAttribute]
public int get_numberOfEyes();
    [CompilerGeneratedAttribute]
private void set_numberOfEyes(int value);
    [CompilerGeneratedAttribute]
public StereoRenderingMode get_stereoRenderingMode();
    [CompilerGeneratedAttribute]
private void set_stereoRenderingMode(StereoRenderingMode value);
    [CompilerGeneratedAttribute]
public int get_screenWidth();
    [CompilerGeneratedAttribute]
public void set_screenWidth(int value);
    [CompilerGeneratedAttribute]
public int get_screenHeight();
    [CompilerGeneratedAttribute]
public void set_screenHeight(int value);
    [CompilerGeneratedAttribute]
public bool get_isSceneView();
    [CompilerGeneratedAttribute]
internal void set_isSceneView(bool value);
    [CompilerGeneratedAttribute]
public Antialiasing get_antialiasing();
    [CompilerGeneratedAttribute]
internal void set_antialiasing(Antialiasing value);
    [CompilerGeneratedAttribute]
public TemporalAntialiasing get_temporalAntialiasing();
    [CompilerGeneratedAttribute]
internal void set_temporalAntialiasing(TemporalAntialiasing value);
    public void Reset();
    public bool IsTemporalAntialiasingActive();
    public bool IsDebugOverlayEnabled(DebugOverlay overlay);
    public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass);
    private RenderTextureDescriptor GetDescriptor(int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite);
    public void GetScreenSpaceTemporaryRT(CommandBuffer cmd, int nameID, int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite, FilterMode filter, int widthOverride, int heightOverride);
    public RenderTexture GetScreenSpaceTemporaryRT(int depthBufferBits, RenderTextureFormat colorFormat, RenderTextureReadWrite readWrite, int widthOverride, int heightOverride);
}
public class UnityEngine.Rendering.PostProcessing.PostProcessResources : ScriptableObject {
    public Texture2D[] blueNoise64;
    public Texture2D[] blueNoise256;
    public SMAALuts smaaLuts;
    public Shaders shaders;
    public ComputeShaders computeShaders;
}
[ExecuteAlways]
[AddComponentMenu("Rendering/Post-process Volume", "1001")]
public class UnityEngine.Rendering.PostProcessing.PostProcessVolume : MonoBehaviour {
    public PostProcessProfile sharedProfile;
    [TooltipAttribute("Check this box to mark this volume as global. This volume's Profile will be applied to the whole Scene.")]
public bool isGlobal;
    public Bounds bounds;
    [TooltipAttribute("The distance (from the attached Collider) to start blending from. A value of 0 means there will be no blending and the Volume overrides will be applied immediatly upon entry to the attached Collider.")]
[MinAttribute("0")]
public float blendDistance;
    [TooltipAttribute("The total weight of this Volume in the Scene. A value of 0 signifies that it will have no effect, 1 signifies full effect.")]
[RangeAttribute("0", "1")]
public float weight;
    [TooltipAttribute("The volume priority in the stack. A higher value means higher priority. Negative values are supported.")]
public float priority;
    private int m_PreviousLayer;
    private float m_PreviousPriority;
    private PostProcessProfile m_InternalProfile;
    public PostProcessProfile profile { get; public set; }
    internal PostProcessProfile profileRef { get; }
    public PostProcessProfile get_profile();
    public void set_profile(PostProcessProfile value);
    internal PostProcessProfile get_profileRef();
    public bool HasInstantiatedProfile();
    private void OnEnable();
    private void OnDisable();
    private void Update();
    private void OnDrawGizmos();
}
public class UnityEngine.Rendering.PostProcessing.PropertySheet : object {
    [CompilerGeneratedAttribute]
private MaterialPropertyBlock <properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Material <material>k__BackingField;
    public MaterialPropertyBlock properties { get; private set; }
    internal Material material { get; private set; }
    internal PropertySheet(Material material);
    [CompilerGeneratedAttribute]
public MaterialPropertyBlock get_properties();
    [CompilerGeneratedAttribute]
private void set_properties(MaterialPropertyBlock value);
    [CompilerGeneratedAttribute]
internal Material get_material();
    [CompilerGeneratedAttribute]
private void set_material(Material value);
    public void ClearKeywords();
    public void EnableKeyword(string keyword);
    public void DisableKeyword(string keyword);
    internal void Release();
}
public class UnityEngine.Rendering.PostProcessing.PropertySheetFactory : object {
    private Dictionary`2<Shader, PropertySheet> m_Sheets;
    [ObsoleteAttribute("Use PropertySheet.Get(Shader) with a direct reference to the Shader instead.")]
public PropertySheet Get(string shaderName);
    public PropertySheet Get(Shader shader);
    public void Release();
}
[ExtensionAttribute]
public static class UnityEngine.Rendering.PostProcessing.RuntimeUtilities : object {
    private static Texture2D m_WhiteTexture;
    private static Texture3D m_WhiteTexture3D;
    private static Texture2D m_BlackTexture;
    private static Texture3D m_BlackTexture3D;
    private static Texture2D m_TransparentTexture;
    private static Texture3D m_TransparentTexture3D;
    private static Dictionary`2<int, Texture2D> m_LutStrips;
    internal static PostProcessResources s_Resources;
    private static Mesh s_FullscreenTriangle;
    private static Material s_CopyStdMaterial;
    private static Material s_CopyStdFromDoubleWideMaterial;
    private static Material s_CopyMaterial;
    private static Material s_CopyFromTexArrayMaterial;
    private static PropertySheet s_CopySheet;
    private static PropertySheet s_CopyFromTexArraySheet;
    private static IEnumerable`1<Type> m_AssemblyTypes;
    public static Texture2D whiteTexture { get; }
    public static Texture3D whiteTexture3D { get; }
    public static Texture2D blackTexture { get; }
    public static Texture3D blackTexture3D { get; }
    public static Texture2D transparentTexture { get; }
    public static Texture3D transparentTexture3D { get; }
    public static Mesh fullscreenTriangle { get; }
    public static Material copyStdMaterial { get; }
    public static Material copyStdFromDoubleWideMaterial { get; }
    public static Material copyMaterial { get; }
    public static Material copyFromTexArrayMaterial { get; }
    public static PropertySheet copySheet { get; }
    public static PropertySheet copyFromTexArraySheet { get; }
    public static bool scriptableRenderPipelineActive { get; }
    public static bool supportsDeferredShading { get; }
    public static bool supportsDepthNormals { get; }
    public static bool isSinglePassStereoEnabled { get; }
    public static bool isVREnabled { get; }
    public static bool isAndroidOpenGL { get; }
    public static RenderTextureFormat defaultHDRRenderTextureFormat { get; }
    public static bool isLinearColorSpace { get; }
    private static RuntimeUtilities();
    public static Texture2D get_whiteTexture();
    public static Texture3D get_whiteTexture3D();
    public static Texture2D get_blackTexture();
    public static Texture3D get_blackTexture3D();
    public static Texture2D get_transparentTexture();
    public static Texture3D get_transparentTexture3D();
    public static Texture2D GetLutStrip(int size);
    public static Mesh get_fullscreenTriangle();
    public static Material get_copyStdMaterial();
    public static Material get_copyStdFromDoubleWideMaterial();
    public static Material get_copyMaterial();
    public static Material get_copyFromTexArrayMaterial();
    public static PropertySheet get_copySheet();
    public static PropertySheet get_copyFromTexArraySheet();
    [ExtensionAttribute]
public static void SetRenderTargetWithLoadStoreAction(CommandBuffer cmd, RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction);
    [ExtensionAttribute]
public static void SetRenderTargetWithLoadStoreAction(CommandBuffer cmd, RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    [ExtensionAttribute]
public static void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear, Nullable`1<Rect> viewport);
    [ExtensionAttribute]
public static void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, RenderBufferLoadAction loadAction, Nullable`1<Rect> viewport);
    [ExtensionAttribute]
public static void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport);
    [ExtensionAttribute]
public static void BlitFullscreenTriangleFromDoubleWide(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass, int eye);
    [ExtensionAttribute]
public static void BlitFullscreenTriangleToDoubleWide(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, int eye);
    [ExtensionAttribute]
public static void BlitFullscreenTriangleFromTexArray(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, int depthSlice);
    [ExtensionAttribute]
public static void BlitFullscreenTriangleToTexArray(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear, int depthSlice);
    [ExtensionAttribute]
public static void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport);
    [ExtensionAttribute]
public static void BlitFullscreenTriangle(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear, Nullable`1<Rect> viewport);
    [ExtensionAttribute]
public static void BuiltinBlit(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination);
    [ExtensionAttribute]
public static void BuiltinBlit(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material mat, int pass);
    public static void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination);
    public static bool get_scriptableRenderPipelineActive();
    public static bool get_supportsDeferredShading();
    public static bool get_supportsDepthNormals();
    public static bool get_isSinglePassStereoEnabled();
    public static bool get_isVREnabled();
    public static bool get_isAndroidOpenGL();
    public static RenderTextureFormat get_defaultHDRRenderTextureFormat();
    public static bool isFloatingPointFormat(RenderTextureFormat format);
    public static void Destroy(Object obj);
    public static bool get_isLinearColorSpace();
    public static bool IsResolvedDepthAvailable(Camera camera);
    public static void DestroyProfile(PostProcessProfile profile, bool destroyEffects);
    public static void DestroyVolume(PostProcessVolume volume, bool destroyProfile, bool destroyGameObject);
    public static bool IsPostProcessingActive(PostProcessLayer layer);
    public static bool IsTemporalAntialiasingActive(PostProcessLayer layer);
    [IteratorStateMachineAttribute("UnityEngine.Rendering.PostProcessing.RuntimeUtilities/<GetAllSceneObjects>d__79`1")]
public static IEnumerable`1<T> GetAllSceneObjects();
    public static void CreateIfNull(T& obj);
    public static float Exp2(float x);
    public static Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset);
    public static Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset);
    public static Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter);
    public static IEnumerable`1<Type> GetAllAssemblyTypes();
    [ExtensionAttribute]
public static T GetAttribute(Type type);
    public static Attribute[] GetMemberAttributes(Expression`1<Func`2<TType, TValue>> expr);
    public static string GetFieldPath(Expression`1<Func`2<TType, TValue>> expr);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.ScalableAO : object {
    private RenderTexture m_Result;
    private PropertySheet m_PropertySheet;
    private AmbientOcclusion m_Settings;
    private RenderTargetIdentifier[] m_MRT;
    private Int32[] m_SampleCount;
    public ScalableAO(AmbientOcclusion settings);
    public sealed virtual DepthTextureMode GetCameraFlags();
    private void DoLazyInitialization(PostProcessRenderContext context);
    private void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource);
    public sealed virtual void RenderAfterOpaque(PostProcessRenderContext context);
    public sealed virtual void RenderAmbientOnly(PostProcessRenderContext context);
    public sealed virtual void CompositeAmbientOnly(PostProcessRenderContext context);
    public sealed virtual void Release();
}
public enum UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionPreset : Enum {
    public int value__;
    public static ScreenSpaceReflectionPreset Lower;
    public static ScreenSpaceReflectionPreset Low;
    public static ScreenSpaceReflectionPreset Medium;
    public static ScreenSpaceReflectionPreset High;
    public static ScreenSpaceReflectionPreset Higher;
    public static ScreenSpaceReflectionPreset Ultra;
    public static ScreenSpaceReflectionPreset Overkill;
    public static ScreenSpaceReflectionPreset Custom;
}
public class UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionPresetParameter : ParameterOverride`1<ScreenSpaceReflectionPreset> {
}
public enum UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionResolution : Enum {
    public int value__;
    public static ScreenSpaceReflectionResolution Downsampled;
    public static ScreenSpaceReflectionResolution FullSize;
    public static ScreenSpaceReflectionResolution Supersampled;
}
public class UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionResolutionParameter : ParameterOverride`1<ScreenSpaceReflectionResolution> {
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionsRenderer", "Unity/Screen-space reflections", "True")]
public class UnityEngine.Rendering.PostProcessing.ScreenSpaceReflections : PostProcessEffectSettings {
    [TooltipAttribute("Choose a quality preset, or use "Custom" to create your own custom preset. Don't use a preset higher than "Medium" if you desire good performance on consoles.")]
public ScreenSpaceReflectionPresetParameter preset;
    [RangeAttribute("0", "256")]
[TooltipAttribute("Maximum number of steps in the raymarching pass. Higher values mean more reflections.")]
public IntParameter maximumIterationCount;
    [TooltipAttribute("Changes the size of the SSR buffer. Downsample it to maximize performances or supersample it for higher quality results with reduced performance.")]
public ScreenSpaceReflectionResolutionParameter resolution;
    [TooltipAttribute("Ray thickness. Lower values are more expensive but allow the effect to detect smaller details.")]
[RangeAttribute("1", "64")]
public FloatParameter thickness;
    [TooltipAttribute("Maximum distance to traverse after which it will stop drawing reflections.")]
public FloatParameter maximumMarchDistance;
    [TooltipAttribute("Fades reflections close to the near planes.")]
[RangeAttribute("0", "1")]
public FloatParameter distanceFade;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Fades reflections close to the screen edges.")]
public FloatParameter vignette;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer`1<ScreenSpaceReflections> {
    private RenderTexture m_Resolve;
    private RenderTexture m_History;
    private Int32[] m_MipIDs;
    private QualityPreset[] m_Presets;
    public virtual DepthTextureMode GetCameraFlags();
    internal void CheckRT(RenderTexture& rt, int width, int height, FilterMode filterMode, bool useMipMap);
    public virtual void Render(PostProcessRenderContext context);
    public virtual void Release();
}
internal static class UnityEngine.Rendering.PostProcessing.ShaderIDs : object {
    internal static int MainTex;
    internal static int Jitter;
    internal static int Sharpness;
    internal static int FinalBlendParameters;
    internal static int HistoryTex;
    internal static int SMAA_Flip;
    internal static int SMAA_Flop;
    internal static int AOParams;
    internal static int AOColor;
    internal static int OcclusionTexture1;
    internal static int OcclusionTexture2;
    internal static int SAOcclusionTexture;
    internal static int MSVOcclusionTexture;
    internal static int DepthCopy;
    internal static int LinearDepth;
    internal static int LowDepth1;
    internal static int LowDepth2;
    internal static int LowDepth3;
    internal static int LowDepth4;
    internal static int TiledDepth1;
    internal static int TiledDepth2;
    internal static int TiledDepth3;
    internal static int TiledDepth4;
    internal static int Occlusion1;
    internal static int Occlusion2;
    internal static int Occlusion3;
    internal static int Occlusion4;
    internal static int Combined1;
    internal static int Combined2;
    internal static int Combined3;
    internal static int SSRResolveTemp;
    internal static int Noise;
    internal static int Test;
    internal static int Resolve;
    internal static int History;
    internal static int ViewMatrix;
    internal static int InverseViewMatrix;
    internal static int InverseProjectionMatrix;
    internal static int ScreenSpaceProjectionMatrix;
    internal static int Params2;
    internal static int FogColor;
    internal static int FogParams;
    internal static int VelocityScale;
    internal static int MaxBlurRadius;
    internal static int RcpMaxBlurRadius;
    internal static int VelocityTex;
    internal static int Tile2RT;
    internal static int Tile4RT;
    internal static int Tile8RT;
    internal static int TileMaxOffs;
    internal static int TileMaxLoop;
    internal static int TileVRT;
    internal static int NeighborMaxTex;
    internal static int LoopCount;
    internal static int DepthOfFieldTemp;
    internal static int DepthOfFieldTex;
    internal static int Distance;
    internal static int LensCoeff;
    internal static int MaxCoC;
    internal static int RcpMaxCoC;
    internal static int RcpAspect;
    internal static int CoCTex;
    internal static int TaaParams;
    internal static int AutoExposureTex;
    internal static int HistogramBuffer;
    internal static int Params;
    internal static int ScaleOffsetRes;
    internal static int BloomTex;
    internal static int SampleScale;
    internal static int Threshold;
    internal static int ColorIntensity;
    internal static int Bloom_DirtTex;
    internal static int Bloom_Settings;
    internal static int Bloom_Color;
    internal static int Bloom_DirtTileOffset;
    internal static int ChromaticAberration_Amount;
    internal static int ChromaticAberration_SpectralLut;
    internal static int Distortion_CenterScale;
    internal static int Distortion_Amount;
    internal static int Lut2D;
    internal static int Lut3D;
    internal static int Lut3D_Params;
    internal static int Lut2D_Params;
    internal static int UserLut2D_Params;
    internal static int PostExposure;
    internal static int ColorBalance;
    internal static int ColorFilter;
    internal static int HueSatCon;
    internal static int Brightness;
    internal static int ChannelMixerRed;
    internal static int ChannelMixerGreen;
    internal static int ChannelMixerBlue;
    internal static int Lift;
    internal static int InvGamma;
    internal static int Gain;
    internal static int Curves;
    internal static int CustomToneCurve;
    internal static int ToeSegmentA;
    internal static int ToeSegmentB;
    internal static int MidSegmentA;
    internal static int MidSegmentB;
    internal static int ShoSegmentA;
    internal static int ShoSegmentB;
    internal static int MaskMode;
    internal static int MaskIntensity;
    internal static int Vignette_Color;
    internal static int Vignette_Center;
    internal static int Vignette_Settings;
    internal static int Vignette_Mask;
    internal static int Vignette_Opacity;
    internal static int Vignette_Mode;
    internal static int Grain_Params1;
    internal static int Grain_Params2;
    internal static int GrainTex;
    internal static int Phase;
    internal static int GrainNoiseParameters;
    internal static int LumaInAlpha;
    internal static int DitheringTex;
    internal static int Dithering_Coords;
    internal static int From;
    internal static int To;
    internal static int Interp;
    internal static int TargetColor;
    internal static int HalfResFinalCopy;
    internal static int WaveformSource;
    internal static int WaveformBuffer;
    internal static int VectorscopeBuffer;
    internal static int RenderViewportScaleFactor;
    internal static int UVTransform;
    internal static int DepthSlice;
    internal static int UVScaleOffset;
    internal static int PosScaleOffset;
    private static ShaderIDs();
}
public class UnityEngine.Rendering.PostProcessing.Spline : object {
    public static int k_Precision;
    public static float k_Step;
    public AnimationCurve curve;
    [SerializeField]
private bool m_Loop;
    [SerializeField]
private float m_ZeroValue;
    [SerializeField]
private float m_Range;
    private AnimationCurve m_InternalLoopingCurve;
    private int frameCount;
    public Single[] cachedData;
    public Spline(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds);
    public void Cache(int frame);
    public float Evaluate(float t, int length);
    public float Evaluate(float t);
    public virtual int GetHashCode();
}
public class UnityEngine.Rendering.PostProcessing.SplineParameter : ParameterOverride`1<Spline> {
    protected internal virtual void OnEnable();
    internal virtual void SetValue(ParameterOverride parameter);
    public virtual void Interp(Spline from, Spline to, float t);
}
[PreserveAttribute]
public class UnityEngine.Rendering.PostProcessing.SubpixelMorphologicalAntialiasing : object {
    [TooltipAttribute("Lower quality is faster at the expense of visual quality (Low = ~60%, Medium = ~80%).")]
public Quality quality;
    public bool IsSupported();
    internal void Render(PostProcessRenderContext context);
}
internal class UnityEngine.Rendering.PostProcessing.TargetPool : object {
    private List`1<int> m_Pool;
    private int m_Current;
    internal int Get();
    private int Get(int i);
    internal void Reset();
}
[PreserveAttribute]
public class UnityEngine.Rendering.PostProcessing.TemporalAntialiasing : object {
    [RangeAttribute("0,1", "1")]
[TooltipAttribute("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable, but blurrier, output.")]
public float jitterSpread;
    [TooltipAttribute("Controls the amount of sharpening applied to the color buffer. High values may introduce dark-border artifacts.")]
[RangeAttribute("0", "3")]
public float sharpness;
    [TooltipAttribute("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
[RangeAttribute("0", "0,99")]
public float stationaryBlending;
    [RangeAttribute("0", "0,99")]
[TooltipAttribute("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
public float motionBlending;
    public Func`3<Camera, Vector2, Matrix4x4> jitteredMatrixFunc;
    [CompilerGeneratedAttribute]
private Vector2 <jitter>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector2 <jitterRaw>k__BackingField;
    private RenderTargetIdentifier[] m_Mrt;
    private bool m_ResetHistory;
    [CompilerGeneratedAttribute]
private int <sampleIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <sampleCount>k__BackingField;
    private static int k_NumEyes;
    private static int k_NumHistoryTextures;
    private RenderTexture[][] m_HistoryTextures;
    private Int32[] m_HistoryPingPong;
    public Vector2 jitter { get; private set; }
    public Vector2 jitterRaw { get; private set; }
    public int sampleIndex { get; private set; }
    public int sampleCount { get; public set; }
    [CompilerGeneratedAttribute]
public Vector2 get_jitter();
    [CompilerGeneratedAttribute]
private void set_jitter(Vector2 value);
    [CompilerGeneratedAttribute]
public Vector2 get_jitterRaw();
    [CompilerGeneratedAttribute]
private void set_jitterRaw(Vector2 value);
    [CompilerGeneratedAttribute]
public int get_sampleIndex();
    [CompilerGeneratedAttribute]
private void set_sampleIndex(int value);
    [CompilerGeneratedAttribute]
public int get_sampleCount();
    [CompilerGeneratedAttribute]
public void set_sampleCount(int value);
    public bool IsSupported();
    internal DepthTextureMode GetCameraFlags();
    internal void ResetHistory();
    private Vector2 GenerateRandomOffset();
    public Matrix4x4 GetJitteredProjectionMatrix(Camera camera);
    public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context);
    public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context);
    private void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context);
    private RenderTexture CheckHistory(int id, PostProcessRenderContext context);
    internal void Render(PostProcessRenderContext context);
    internal void Release();
}
[ExtensionAttribute]
public static class UnityEngine.Rendering.PostProcessing.TextureFormatUtilities : object {
    private static Dictionary`2<int, RenderTextureFormat> s_FormatAliasMap;
    private static Dictionary`2<int, bool> s_SupportedRenderTextureFormats;
    private static Dictionary`2<int, bool> s_SupportedTextureFormats;
    private static TextureFormatUtilities();
    private static bool IsObsolete(object value);
    public static RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture);
    [ExtensionAttribute]
internal static bool IsSupported(RenderTextureFormat format);
    [ExtensionAttribute]
internal static bool IsSupported(TextureFormat format);
}
internal class UnityEngine.Rendering.PostProcessing.TextureLerper : object {
    private static TextureLerper m_Instance;
    private CommandBuffer m_Command;
    private PropertySheetFactory m_PropertySheets;
    private PostProcessResources m_Resources;
    private List`1<RenderTexture> m_Recycled;
    private List`1<RenderTexture> m_Actives;
    internal static TextureLerper instance { get; }
    internal static TextureLerper get_instance();
    internal void BeginFrame(PostProcessRenderContext context);
    internal void EndFrame();
    private RenderTexture Get(RenderTextureFormat format, int w, int h, int d, bool enableRandomWrite, bool force3D);
    internal Texture Lerp(Texture from, Texture to, float t);
    internal Texture Lerp(Texture from, Color to, float t);
    internal void Clear();
}
public class UnityEngine.Rendering.PostProcessing.TextureParameter : ParameterOverride`1<Texture> {
    public TextureParameterDefault defaultState;
    public virtual void Interp(Texture from, Texture to, float t);
}
public enum UnityEngine.Rendering.PostProcessing.TextureParameterDefault : Enum {
    public int value__;
    public static TextureParameterDefault None;
    public static TextureParameterDefault Black;
    public static TextureParameterDefault White;
    public static TextureParameterDefault Transparent;
    public static TextureParameterDefault Lut2D;
}
public enum UnityEngine.Rendering.PostProcessing.Tonemapper : Enum {
    public int value__;
    public static Tonemapper None;
    public static Tonemapper Neutral;
    public static Tonemapper ACES;
    public static Tonemapper Custom;
}
public class UnityEngine.Rendering.PostProcessing.TonemapperParameter : ParameterOverride`1<Tonemapper> {
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Rendering.PostProcessing.TrackballAttribute : Attribute {
    public Mode mode;
    public TrackballAttribute(Mode mode);
}
public class UnityEngine.Rendering.PostProcessing.Vector2Parameter : ParameterOverride`1<Vector2> {
    public virtual void Interp(Vector2 from, Vector2 to, float t);
    public static Vector3 op_Implicit(Vector2Parameter prop);
    public static Vector4 op_Implicit(Vector2Parameter prop);
}
public class UnityEngine.Rendering.PostProcessing.Vector3Parameter : ParameterOverride`1<Vector3> {
    public virtual void Interp(Vector3 from, Vector3 to, float t);
    public static Vector2 op_Implicit(Vector3Parameter prop);
    public static Vector4 op_Implicit(Vector3Parameter prop);
}
public class UnityEngine.Rendering.PostProcessing.Vector4Parameter : ParameterOverride`1<Vector4> {
    public virtual void Interp(Vector4 from, Vector4 to, float t);
    public static Vector2 op_Implicit(Vector4Parameter prop);
    public static Vector3 op_Implicit(Vector4Parameter prop);
}
public class UnityEngine.Rendering.PostProcessing.VectorscopeMonitor : Monitor {
    public int size;
    public float exposure;
    private ComputeBuffer m_Data;
    private static int k_ThreadGroupSizeX;
    private static int k_ThreadGroupSizeY;
    internal virtual void OnDisable();
    internal virtual bool NeedsHalfRes();
    internal virtual bool ShaderResourcesAvailable(PostProcessRenderContext context);
    internal virtual void Render(PostProcessRenderContext context);
}
[PostProcessAttribute("UnityEngine.Rendering.PostProcessing.VignetteRenderer", "Unity/Vignette", "True")]
public class UnityEngine.Rendering.PostProcessing.Vignette : PostProcessEffectSettings {
    [TooltipAttribute("Use the "Classic" mode for parametric controls. Use the "Masked" mode to use your own texture mask.")]
public VignetteModeParameter mode;
    [TooltipAttribute("Vignette color.")]
public ColorParameter color;
    [TooltipAttribute("Sets the vignette center point (screen center is [0.5, 0.5]).")]
public Vector2Parameter center;
    [TooltipAttribute("Amount of vignetting on screen.")]
[RangeAttribute("0", "1")]
public FloatParameter intensity;
    [TooltipAttribute("Smoothness of the vignette borders.")]
[RangeAttribute("0,01", "1")]
public FloatParameter smoothness;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Lower values will make a square-ish vignette.")]
public FloatParameter roundness;
    [TooltipAttribute("Set to true to mark the vignette to be perfectly round. False will make its shape dependent on the current aspect ratio.")]
public BoolParameter rounded;
    [TooltipAttribute("A black and white mask to use as a vignette.")]
public TextureParameter mask;
    [RangeAttribute("0", "1")]
[TooltipAttribute("Mask opacity.")]
public FloatParameter opacity;
    public virtual bool IsEnabledAndSupported(PostProcessRenderContext context);
}
public enum UnityEngine.Rendering.PostProcessing.VignetteMode : Enum {
    public int value__;
    public static VignetteMode Classic;
    public static VignetteMode Masked;
}
public class UnityEngine.Rendering.PostProcessing.VignetteModeParameter : ParameterOverride`1<VignetteMode> {
}
[PreserveAttribute]
internal class UnityEngine.Rendering.PostProcessing.VignetteRenderer : PostProcessEffectRenderer`1<Vignette> {
    public virtual void Render(PostProcessRenderContext context);
}
public class UnityEngine.Rendering.PostProcessing.WaveformMonitor : Monitor {
    public float exposure;
    public int height;
    private ComputeBuffer m_Data;
    private static int k_ThreadGroupSize;
    private static int k_ThreadGroupSizeX;
    private static int k_ThreadGroupSizeY;
    internal virtual void OnDisable();
    internal virtual bool NeedsHalfRes();
    internal virtual bool ShaderResourcesAvailable(PostProcessRenderContext context);
    internal virtual void Render(PostProcessRenderContext context);
}
[ExtensionAttribute]
public static class UnityEngine.SkinnedMeshRendererEx : object {
    [ExtensionAttribute]
public static Transform FindRig(SkinnedMeshRenderer renderer);
}
[ExtensionAttribute]
public static class UnityEngine.TransformEx : object {
    [ExtensionAttribute]
public static string GetRecursiveName(Transform transform, string strEndName);
    [ExtensionAttribute]
public static void RemoveComponent(Transform transform);
    [ExtensionAttribute]
public static void RetireAllChildren(Transform transform, GameManager gameManager);
    [ExtensionAttribute]
public static List`1<Transform> GetChildren(Transform transform);
    [ExtensionAttribute]
public static void OrderChildren(Transform tx, Func`2<Transform, object> selector);
    [ExtensionAttribute]
public static List`1<Transform> GetAllChildren(Transform transform);
    [ExtensionAttribute]
public static void AddAllChildren(Transform transform, List`1<Transform> list);
    [ExtensionAttribute]
public static Transform[] GetChildrenWithTag(Transform transform, string strTag);
    [ExtensionAttribute]
public static Matrix4x4 LocalToPrefabRoot(Transform transform);
    [ExtensionAttribute]
public static void Identity(GameObject go);
    [ExtensionAttribute]
public static GameObject CreateChild(GameObject go);
    [ExtensionAttribute]
public static GameObject InstantiateChild(GameObject go, GameObject prefab);
    [ExtensionAttribute]
public static void SetLayerRecursive(GameObject go, int Layer);
    [ExtensionAttribute]
public static bool DropToGround(Transform transform, bool alignToNormal, float fRange);
    [ExtensionAttribute]
public static bool GetGroundInfo(Transform transform, Vector3& pos, Vector3& normal, float range);
    [ExtensionAttribute]
public static bool GetGroundInfoTerrainOnly(Transform transform, Vector3& pos, Vector3& normal, float range);
    [ExtensionAttribute]
public static Bounds WorkoutRenderBounds(Transform tx);
    [ExtensionAttribute]
public static List`1<T> GetSiblings(Transform transform, bool includeSelf);
    [ExtensionAttribute]
public static void DestroyChildren(Transform transform);
    [ExtensionAttribute]
public static void SetChildrenActive(Transform transform, bool b);
    [ExtensionAttribute]
public static Transform ActiveChild(Transform transform, string name, bool bDisableOthers);
    [ExtensionAttribute]
public static T GetComponentInChildrenIncludeDisabled(Transform transform);
    [ExtensionAttribute]
public static bool HasComponentInChildrenIncludeDisabled(Transform transform);
    [ExtensionAttribute]
public static void SetHierarchyGroup(Transform transform, string strRoot, bool groupActive, bool persistant);
    [ExtensionAttribute]
public static Bounds GetBounds(Transform transform, bool includeRenderers, bool includeColliders, bool includeInactive);
}
public class UnityEngine.UI.Extensions.BezierPath : object {
    public int SegmentsPerCurve;
    public float MINIMUM_SQR_DISTANCE;
    public float DIVISION_THRESHOLD;
    private List`1<Vector2> controlPoints;
    private int curveCount;
    public void SetControlPoints(List`1<Vector2> newControlPoints);
    public void SetControlPoints(Vector2[] newControlPoints);
    public List`1<Vector2> GetControlPoints();
    public void Interpolate(List`1<Vector2> segmentPoints, float scale);
    public void SamplePoints(List`1<Vector2> sourcePoints, float minSqrDistance, float maxSqrDistance, float scale);
    public Vector2 CalculateBezierPoint(int curveIndex, float t);
    public List`1<Vector2> GetDrawingPoints0();
    public List`1<Vector2> GetDrawingPoints1();
    public List`1<Vector2> GetDrawingPoints2();
    private List`1<Vector2> FindDrawingPoints(int curveIndex);
    private int FindDrawingPoints(int curveIndex, float t0, float t1, List`1<Vector2> pointList, int insertionIndex);
    private Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3);
}
public class UnityEngine.UI.Extensions.CableCurve : object {
    [SerializeField]
private Vector2 m_start;
    [SerializeField]
private Vector2 m_end;
    [SerializeField]
private float m_slack;
    [SerializeField]
private int m_steps;
    [SerializeField]
private bool m_regen;
    private static Vector2[] emptyCurve;
    [SerializeField]
private Vector2[] points;
    public bool regenPoints { get; public set; }
    public Vector2 start { get; public set; }
    public Vector2 end { get; public set; }
    public float slack { get; public set; }
    public int steps { get; public set; }
    public Vector2 midPoint { get; }
    public CableCurve(Vector2[] inputPoints);
    public CableCurve(List`1<Vector2> inputPoints);
    public CableCurve(CableCurve v);
    private static CableCurve();
    public bool get_regenPoints();
    public void set_regenPoints(bool value);
    public Vector2 get_start();
    public void set_start(Vector2 value);
    public Vector2 get_end();
    public void set_end(Vector2 value);
    public float get_slack();
    public void set_slack(float value);
    public int get_steps();
    public void set_steps(int value);
    public Vector2 get_midPoint();
    public Vector2[] Points();
}
[AddComponentMenu("UI/Extensions/Primitives/Diamond Graph")]
public class UnityEngine.UI.Extensions.DiamondGraph : UIPrimitiveBase {
    [SerializeField]
private float m_a;
    [SerializeField]
private float m_b;
    [SerializeField]
private float m_c;
    [SerializeField]
private float m_d;
    public float A { get; public set; }
    public float B { get; public set; }
    public float C { get; public set; }
    public float D { get; public set; }
    public float get_A();
    public void set_A(float value);
    public float get_B();
    public void set_B(float value);
    public float get_C();
    public void set_C(float value);
    public float get_D();
    public void set_D(float value);
    protected virtual void OnPopulateMesh(VertexHelper vh);
}
public enum UnityEngine.UI.Extensions.ResolutionMode : Enum {
    public int value__;
    public static ResolutionMode None;
    public static ResolutionMode PerSegment;
    public static ResolutionMode PerLine;
}
internal static class UnityEngine.UI.Extensions.SetPropertyUtility : object {
    public static bool SetColor(Color& currentValue, Color newValue);
    public static bool SetEquatableStruct(T& currentValue, T newValue);
    public static bool SetStruct(T& currentValue, T newValue);
    public static bool SetClass(T& currentValue, T newValue);
}
[AddComponentMenu("UI/Extensions/Primitives/UI Circle")]
public class UnityEngine.UI.Extensions.UICircle : UIPrimitiveBase {
    [TooltipAttribute("The Arc Invert property will invert the construction of the Arc.")]
public bool ArcInvert;
    [RangeAttribute("0", "1")]
[TooltipAttribute("The Arc property is a percentage of the entire circumference of the circle.")]
public float Arc;
    [TooltipAttribute("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
[RangeAttribute("0", "1000")]
public int ArcSteps;
    [TooltipAttribute("The Arc Rotation property permits adjusting the geometry orientation around the Z axis.")]
[RangeAttribute("0", "360")]
public int ArcRotation;
    [TooltipAttribute("The Progress property allows the primitive to be used as a progression indicator.")]
[RangeAttribute("0", "1")]
public float Progress;
    private float _progress;
    public Color ProgressColor;
    public bool Fill;
    public float Thickness;
    public int Padding;
    private List`1<int> indices;
    private List`1<UIVertex> vertices;
    private Vector2 uvCenter;
    protected virtual void OnPopulateMesh(VertexHelper vh);
    public void SetProgress(float progress);
    public void SetArcSteps(int steps);
    public void SetInvertArc(bool invert);
    public void SetArcRotation(int rotation);
    public void SetFill(bool fill);
    public void SetBaseColor(Color color);
    public void UpdateBaseAlpha(float value);
    public void SetProgressColor(Color color);
    public void UpdateProgressAlpha(float value);
    public void SetPadding(int padding);
    public void SetThickness(int thickness);
}
[AddComponentMenu("UI/Extensions/Primitives/UI Circle Simple")]
public class UnityEngine.UI.Extensions.UICircleSimple : UIPrimitiveBase {
    [RangeAttribute("0", "1000")]
[TooltipAttribute("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
public int ArcSteps;
    public bool Fill;
    public float Thickness;
    public bool ThicknessIsOutside;
    private List`1<int> indices;
    private List`1<UIVertex> vertices;
    private Vector2 uvCenter;
    protected virtual void OnPopulateMesh(VertexHelper vh);
    public void SetArcSteps(int steps);
    public void SetFill(bool fill);
    public void SetBaseColor(Color color);
    public void UpdateBaseAlpha(float value);
    public void SetThickness(int thickness);
}
[AddComponentMenu("UI/Extensions/Primitives/Cut Corners")]
public class UnityEngine.UI.Extensions.UICornerCut : UIPrimitiveBase {
    public Vector2 cornerSize;
    [HeaderAttribute("Corners to cut")]
[SerializeField]
private bool m_cutUL;
    [SerializeField]
private bool m_cutUR;
    [SerializeField]
private bool m_cutLL;
    [SerializeField]
private bool m_cutLR;
    [SerializeField]
[TooltipAttribute("Up-Down colors become Left-Right colors")]
private bool m_makeColumns;
    [SerializeField]
[HeaderAttribute("Color the cut bars differently")]
private bool m_useColorUp;
    [SerializeField]
private Color32 m_colorUp;
    [SerializeField]
private bool m_useColorDown;
    [SerializeField]
private Color32 m_colorDown;
    public bool CutUL { get; public set; }
    public bool CutUR { get; public set; }
    public bool CutLL { get; public set; }
    public bool CutLR { get; public set; }
    public bool MakeColumns { get; public set; }
    public bool UseColorUp { get; public set; }
    public Color32 ColorUp { get; public set; }
    public bool UseColorDown { get; public set; }
    public Color32 ColorDown { get; public set; }
    public bool get_CutUL();
    public void set_CutUL(bool value);
    public bool get_CutUR();
    public void set_CutUR(bool value);
    public bool get_CutLL();
    public void set_CutLL(bool value);
    public bool get_CutLR();
    public void set_CutLR(bool value);
    public bool get_MakeColumns();
    public void set_MakeColumns(bool value);
    public bool get_UseColorUp();
    public void set_UseColorUp(bool value);
    public Color32 get_ColorUp();
    public void set_ColorUp(Color32 value);
    public bool get_UseColorDown();
    public void set_UseColorDown(bool value);
    public Color32 get_ColorDown();
    public void set_ColorDown(Color32 value);
    protected virtual void OnPopulateMesh(VertexHelper vh);
    private static void AddSquare(Rect rect, Rect rectUV, Color32 color32, VertexHelper vh);
    private static void AddSquare(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Rect rectUV, Color32 color32, VertexHelper vh);
    private static int AddVert(float x, float y, Rect area, Color32 color32, VertexHelper vh);
}
public class UnityEngine.UI.Extensions.UIGoldenRatioRenderer : UILineRenderer {
    private List`1<Vector2> _points;
    private List`1<Rect> _rects;
    private int canvasWidth;
    private int canvasHeight;
    public float lineThickness2;
    private void DrawSpiral(VertexHelper vh);
    private void DrawPhiRectangles(VertexHelper vh, List`1<Vector2> points, float x, float y, float width, float height, Orientations orientation);
    protected virtual void OnPopulateMesh(VertexHelper vh);
    private void DrawRect(VertexHelper vh, Rect rect);
}
[AddComponentMenu("UI/Extensions/Primitives/UIGridRenderer")]
public class UnityEngine.UI.Extensions.UIGridRenderer : UILineRenderer {
    [SerializeField]
private int m_GridColumns;
    [SerializeField]
private int m_GridRows;
    public int GridColumns { get; public set; }
    public int GridRows { get; public set; }
    public int get_GridColumns();
    public void set_GridColumns(int value);
    public int get_GridRows();
    public void set_GridRows(int value);
    protected virtual void OnPopulateMesh(VertexHelper vh);
}
[AddComponentMenu("UI/Extensions/Primitives/UILineRenderer")]
[RequireComponent("UnityEngine.RectTransform")]
public class UnityEngine.UI.Extensions.UILineRenderer : UIPrimitiveBase {
    private static float MIN_MITER_JOIN;
    private static float MIN_BEVEL_NICE_JOIN;
    private static Vector2 UV_TOP_LEFT;
    private static Vector2 UV_BOTTOM_LEFT;
    private static Vector2 UV_TOP_CENTER_LEFT;
    private static Vector2 UV_TOP_CENTER_RIGHT;
    private static Vector2 UV_BOTTOM_CENTER_LEFT;
    private static Vector2 UV_BOTTOM_CENTER_RIGHT;
    private static Vector2 UV_TOP_RIGHT;
    private static Vector2 UV_BOTTOM_RIGHT;
    private static Vector2[] startUvs;
    private static Vector2[] middleUvs;
    private static Vector2[] endUvs;
    private static Vector2[] fullUvs;
    [SerializeField]
[TooltipAttribute("Points to draw lines between
 Can be improved using the Resolution Option")]
internal Vector2[] m_points;
    [TooltipAttribute("Segments to be drawn
 This is a list of arrays of points")]
[SerializeField]
internal List`1<Vector2[]> m_segments;
    [TooltipAttribute("Thickness of the line")]
[SerializeField]
internal float lineThickness;
    [TooltipAttribute("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
[SerializeField]
internal bool relativeSize;
    [TooltipAttribute("Do the points identify a single line or split pairs of lines")]
[SerializeField]
internal bool lineList;
    [TooltipAttribute("Add end caps to each line
Multiple caps when used with Line List")]
[SerializeField]
internal bool lineCaps;
    [SerializeField]
[TooltipAttribute("Resolution of the Bezier curve, different to line Resolution")]
internal int bezierSegmentsPerCurve;
    [TooltipAttribute("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
public JoinType LineJoins;
    [TooltipAttribute("Bezier method to apply to line, see docs for options
Can't be used in conjunction with Resolution as Bezier already changes the resolution")]
public BezierType BezierMode;
    [HideInInspector]
public bool drivenExternally;
    public float LineThickness { get; public set; }
    public bool RelativeSize { get; public set; }
    public bool LineList { get; public set; }
    public bool LineCaps { get; public set; }
    public int BezierSegmentsPerCurve { get; public set; }
    public Vector2[] Points { get; public set; }
    public List`1<Vector2[]> Segments { get; public set; }
    public float get_LineThickness();
    public void set_LineThickness(float value);
    public bool get_RelativeSize();
    public void set_RelativeSize(bool value);
    public bool get_LineList();
    public void set_LineList(bool value);
    public bool get_LineCaps();
    public void set_LineCaps(bool value);
    public int get_BezierSegmentsPerCurve();
    public void set_BezierSegmentsPerCurve(int value);
    public Vector2[] get_Points();
    public void set_Points(Vector2[] value);
    public List`1<Vector2[]> get_Segments();
    public void set_Segments(List`1<Vector2[]> value);
    private void PopulateMesh(VertexHelper vh, Vector2[] pointsToDraw);
    protected virtual void OnPopulateMesh(VertexHelper vh);
    private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type);
    private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type, UIVertex[] previousVert);
    protected virtual void GeneratedUVs();
    protected virtual void ResolutionToNativeSize(float distance);
    private int GetSegmentPointCount();
    public Vector2 GetPosition(int index, int segmentIndex);
    public Vector2 GetPositionBySegment(int index, int segment);
    public Vector2 GetClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3);
}
[RequireComponent("UnityEngine.RectTransform")]
[AddComponentMenu("UI/Extensions/Primitives/UILineRendererList")]
public class UnityEngine.UI.Extensions.UILineRendererList : UIPrimitiveBase {
    private static float MIN_MITER_JOIN;
    private static float MIN_BEVEL_NICE_JOIN;
    private static Vector2 UV_TOP_LEFT;
    private static Vector2 UV_BOTTOM_LEFT;
    private static Vector2 UV_TOP_CENTER_LEFT;
    private static Vector2 UV_TOP_CENTER_RIGHT;
    private static Vector2 UV_BOTTOM_CENTER_LEFT;
    private static Vector2 UV_BOTTOM_CENTER_RIGHT;
    private static Vector2 UV_TOP_RIGHT;
    private static Vector2 UV_BOTTOM_RIGHT;
    private static Vector2[] startUvs;
    private static Vector2[] middleUvs;
    private static Vector2[] endUvs;
    private static Vector2[] fullUvs;
    [TooltipAttribute("Points to draw lines between
 Can be improved using the Resolution Option")]
[SerializeField]
internal List`1<Vector2> m_points;
    [TooltipAttribute("Thickness of the line")]
[SerializeField]
internal float lineThickness;
    [TooltipAttribute("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
[SerializeField]
internal bool relativeSize;
    [SerializeField]
[TooltipAttribute("Do the points identify a single line or split pairs of lines")]
internal bool lineList;
    [SerializeField]
[TooltipAttribute("Add end caps to each line
Multiple caps when used with Line List")]
internal bool lineCaps;
    [TooltipAttribute("Resolution of the Bezier curve, different to line Resolution")]
[SerializeField]
internal int bezierSegmentsPerCurve;
    [TooltipAttribute("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
public JoinType LineJoins;
    [TooltipAttribute("Bezier method to apply to line, see docs for options
Can't be used in conjunction with Resolution as Bezier already changes the resolution")]
public BezierType BezierMode;
    [HideInInspector]
public bool drivenExternally;
    public float LineThickness { get; public set; }
    public bool RelativeSize { get; public set; }
    public bool LineList { get; public set; }
    public bool LineCaps { get; public set; }
    public int BezierSegmentsPerCurve { get; public set; }
    public List`1<Vector2> Points { get; public set; }
    public float get_LineThickness();
    public void set_LineThickness(float value);
    public bool get_RelativeSize();
    public void set_RelativeSize(bool value);
    public bool get_LineList();
    public void set_LineList(bool value);
    public bool get_LineCaps();
    public void set_LineCaps(bool value);
    public int get_BezierSegmentsPerCurve();
    public void set_BezierSegmentsPerCurve(int value);
    public List`1<Vector2> get_Points();
    public void set_Points(List`1<Vector2> value);
    public void AddPoint(Vector2 pointToAdd);
    public void RemovePoint(Vector2 pointToRemove);
    public void ClearPoints();
    private void PopulateMesh(VertexHelper vh, List`1<Vector2> pointsToDraw);
    protected virtual void OnPopulateMesh(VertexHelper vh);
    private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type);
    private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type);
    protected virtual void GeneratedUVs();
    protected virtual void ResolutionToNativeSize(float distance);
}
[AddComponentMenu("UI/Extensions/Primitives/UILineTextureRenderer")]
public class UnityEngine.UI.Extensions.UILineTextureRenderer : UIPrimitiveBase {
    [SerializeField]
private Rect m_UVRect;
    [SerializeField]
private Vector2[] m_points;
    public float LineThickness;
    public bool UseMargins;
    public Vector2 Margin;
    public bool relativeSize;
    public Rect uvRect { get; public set; }
    public Vector2[] Points { get; public set; }
    public Rect get_uvRect();
    public void set_uvRect(Rect value);
    public Vector2[] get_Points();
    public void set_Points(Vector2[] value);
    protected virtual void OnPopulateMesh(VertexHelper vh);
    public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles);
}
[AddComponentMenu("UI/Extensions/Primitives/UI Polygon")]
public class UnityEngine.UI.Extensions.UIPolygon : UIPrimitiveBase {
    public bool fill;
    public float thickness;
    [RangeAttribute("3", "360")]
public int sides;
    [RangeAttribute("0", "360")]
public float rotation;
    [RangeAttribute("0", "1")]
public Single[] VerticesDistances;
    private float size;
    public void DrawPolygon(int _sides);
    public void DrawPolygon(int _sides, Single[] _VerticesDistances);
    public void DrawPolygon(int _sides, Single[] _VerticesDistances, float _rotation);
    private void Update();
    protected virtual void OnPopulateMesh(VertexHelper vh);
}
public class UnityEngine.UI.Extensions.UIPrimitiveBase : MaskableGraphic {
    protected static Material s_ETC1DefaultUI;
    private List`1<Vector2> outputList;
    [SerializeField]
private Sprite m_Sprite;
    private Sprite m_OverrideSprite;
    internal float m_EventAlphaThreshold;
    [SerializeField]
private ResolutionMode m_improveResolution;
    [SerializeField]
protected float m_Resolution;
    [SerializeField]
private bool m_useNativeSize;
    public Sprite sprite { get; public set; }
    public Sprite overrideSprite { get; public set; }
    protected Sprite activeSprite { get; }
    public float eventAlphaThreshold { get; public set; }
    public ResolutionMode ImproveResolution { get; public set; }
    public float Resoloution { get; public set; }
    public bool UseNativeSize { get; public set; }
    public static Material defaultETC1GraphicMaterial { get; }
    public Texture mainTexture { get; }
    public bool hasBorder { get; }
    public float pixelsPerUnit { get; }
    public Material material { get; public set; }
    public float minWidth { get; }
    public float preferredWidth { get; }
    public float flexibleWidth { get; }
    public float minHeight { get; }
    public float preferredHeight { get; }
    public float flexibleHeight { get; }
    public int layoutPriority { get; }
    public Sprite get_sprite();
    public void set_sprite(Sprite value);
    public Sprite get_overrideSprite();
    public void set_overrideSprite(Sprite value);
    protected Sprite get_activeSprite();
    public float get_eventAlphaThreshold();
    public void set_eventAlphaThreshold(float value);
    public ResolutionMode get_ImproveResolution();
    public void set_ImproveResolution(ResolutionMode value);
    public float get_Resoloution();
    public void set_Resoloution(float value);
    public bool get_UseNativeSize();
    public void set_UseNativeSize(bool value);
    public static Material get_defaultETC1GraphicMaterial();
    public virtual Texture get_mainTexture();
    public bool get_hasBorder();
    public float get_pixelsPerUnit();
    public virtual Material get_material();
    public virtual void set_material(Material value);
    protected UIVertex[] SetVbo(Vector2[] vertices, Vector2[] uvs);
    protected Vector2[] IncreaseResolution(Vector2[] input);
    protected List`1<Vector2> IncreaseResolution(List`1<Vector2> input);
    protected virtual void GeneratedUVs();
    protected virtual void ResolutionToNativeSize(float distance);
    public virtual void CalculateLayoutInputHorizontal();
    public virtual void CalculateLayoutInputVertical();
    public virtual float get_minWidth();
    public virtual float get_preferredWidth();
    public virtual float get_flexibleWidth();
    public virtual float get_minHeight();
    public virtual float get_preferredHeight();
    public virtual float get_flexibleHeight();
    public virtual int get_layoutPriority();
    public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera);
    private Vector2 MapCoordinate(Vector2 local, Rect rect);
    private Vector4 GetAdjustedBorders(Vector4 border, Rect rect);
    protected virtual void OnEnable();
}
[AddComponentMenu("UI/Extensions/Primitives/UI Ring")]
public class UnityEngine.UI.Extensions.UIRing : UIPrimitiveBase {
    public float innerRadius;
    public float outerRadius;
    [RangeAttribute("0", "1000")]
[TooltipAttribute("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
public int ArcSteps;
    private List`1<int> indices;
    private List`1<UIVertex> vertices;
    protected virtual void OnPopulateMesh(VertexHelper vh);
    public void SetArcSteps(int steps);
    public void SetBaseColor(Color color);
    public void UpdateBaseAlpha(float value);
}
[AddComponentMenu("UI/Scroll Rect Ex", "37")]
[SelectionBaseAttribute]
[ExecuteInEditMode]
[RequireComponent("UnityEngine.RectTransform")]
public class UnityEngine.UI.ScrollRectEx : UIBehaviour {
    public InputButton scrollButton;
    public InputButton altScrollButton;
    [SerializeField]
private RectTransform m_Content;
    [SerializeField]
private bool m_Horizontal;
    [SerializeField]
private bool m_Vertical;
    [SerializeField]
private MovementType m_MovementType;
    [SerializeField]
private float m_Elasticity;
    [SerializeField]
private bool m_Inertia;
    [SerializeField]
private float m_DecelerationRate;
    [SerializeField]
private float m_ScrollSensitivity;
    [SerializeField]
private RectTransform m_Viewport;
    [SerializeField]
private Scrollbar m_HorizontalScrollbar;
    [SerializeField]
private Scrollbar m_VerticalScrollbar;
    [SerializeField]
private ScrollbarVisibility m_HorizontalScrollbarVisibility;
    [SerializeField]
private ScrollbarVisibility m_VerticalScrollbarVisibility;
    [SerializeField]
private float m_HorizontalScrollbarSpacing;
    [SerializeField]
private float m_VerticalScrollbarSpacing;
    [SerializeField]
private ScrollRectEvent m_OnValueChanged;
    private Vector2 m_PointerStartLocalCursor;
    private Vector2 m_ContentStartPosition;
    private RectTransform m_ViewRect;
    private Bounds m_ContentBounds;
    private Bounds m_ViewBounds;
    private Vector2 m_Velocity;
    private bool m_Dragging;
    private Vector2 m_PrevPosition;
    private Bounds m_PrevContentBounds;
    private Bounds m_PrevViewBounds;
    private bool m_HasRebuiltLayout;
    private bool m_HSliderExpand;
    private bool m_VSliderExpand;
    private float m_HSliderHeight;
    private float m_VSliderWidth;
    private RectTransform m_Rect;
    private RectTransform m_HorizontalScrollbarRect;
    private RectTransform m_VerticalScrollbarRect;
    private DrivenRectTransformTracker m_Tracker;
    private Vector3[] m_Corners;
    public RectTransform content { get; public set; }
    public bool horizontal { get; public set; }
    public bool vertical { get; public set; }
    public MovementType movementType { get; public set; }
    public float elasticity { get; public set; }
    public bool inertia { get; public set; }
    public float decelerationRate { get; public set; }
    public float scrollSensitivity { get; public set; }
    public RectTransform viewport { get; public set; }
    public Scrollbar horizontalScrollbar { get; public set; }
    public Scrollbar verticalScrollbar { get; public set; }
    public ScrollbarVisibility horizontalScrollbarVisibility { get; public set; }
    public ScrollbarVisibility verticalScrollbarVisibility { get; public set; }
    public float horizontalScrollbarSpacing { get; public set; }
    public float verticalScrollbarSpacing { get; public set; }
    public ScrollRectEvent onValueChanged { get; public set; }
    protected RectTransform viewRect { get; }
    public Vector2 velocity { get; public set; }
    private RectTransform rectTransform { get; }
    public Vector2 normalizedPosition { get; public set; }
    public float horizontalNormalizedPosition { get; public set; }
    public float verticalNormalizedPosition { get; public set; }
    private bool hScrollingNeeded { get; }
    private bool vScrollingNeeded { get; }
    public Rect normalizedViewRect { get; }
    public RectTransform get_content();
    public void set_content(RectTransform value);
    public bool get_horizontal();
    public void set_horizontal(bool value);
    public bool get_vertical();
    public void set_vertical(bool value);
    public MovementType get_movementType();
    public void set_movementType(MovementType value);
    public float get_elasticity();
    public void set_elasticity(float value);
    public bool get_inertia();
    public void set_inertia(bool value);
    public float get_decelerationRate();
    public void set_decelerationRate(float value);
    public float get_scrollSensitivity();
    public void set_scrollSensitivity(float value);
    public RectTransform get_viewport();
    public void set_viewport(RectTransform value);
    public Scrollbar get_horizontalScrollbar();
    public void set_horizontalScrollbar(Scrollbar value);
    public Scrollbar get_verticalScrollbar();
    public void set_verticalScrollbar(Scrollbar value);
    public ScrollbarVisibility get_horizontalScrollbarVisibility();
    public void set_horizontalScrollbarVisibility(ScrollbarVisibility value);
    public ScrollbarVisibility get_verticalScrollbarVisibility();
    public void set_verticalScrollbarVisibility(ScrollbarVisibility value);
    public float get_horizontalScrollbarSpacing();
    public void set_horizontalScrollbarSpacing(float value);
    public float get_verticalScrollbarSpacing();
    public void set_verticalScrollbarSpacing(float value);
    public ScrollRectEvent get_onValueChanged();
    public void set_onValueChanged(ScrollRectEvent value);
    protected RectTransform get_viewRect();
    public Vector2 get_velocity();
    public void set_velocity(Vector2 value);
    private RectTransform get_rectTransform();
    public virtual void Rebuild(CanvasUpdate executing);
    private void UpdateCachedData();
    protected virtual void OnEnable();
    protected virtual void OnDisable();
    public virtual bool IsActive();
    private void EnsureLayoutHasRebuilt();
    public virtual void StopMovement();
    public virtual void OnScroll(PointerEventData data);
    public virtual void OnInitializePotentialDrag(PointerEventData eventData);
    public virtual void OnBeginDrag(PointerEventData eventData);
    public virtual void OnEndDrag(PointerEventData eventData);
    public virtual void OnDrag(PointerEventData eventData);
    protected virtual void SetContentAnchoredPosition(Vector2 position);
    protected virtual void LateUpdate();
    private void UpdatePrevData();
    private void UpdateScrollbars(Vector2 offset);
    public Vector2 get_normalizedPosition();
    public void set_normalizedPosition(Vector2 value);
    public float get_horizontalNormalizedPosition();
    public void set_horizontalNormalizedPosition(float value);
    public float get_verticalNormalizedPosition();
    public void set_verticalNormalizedPosition(float value);
    private void SetHorizontalNormalizedPosition(float value);
    private void SetVerticalNormalizedPosition(float value);
    private void SetNormalizedPosition(float value, int axis);
    private static float RubberDelta(float overStretching, float viewSize);
    protected virtual void OnRectTransformDimensionsChange();
    private bool get_hScrollingNeeded();
    private bool get_vScrollingNeeded();
    public virtual void SetLayoutHorizontal();
    public virtual void SetLayoutVertical();
    private void UpdateScrollbarVisibility();
    private void UpdateScrollbarLayout();
    private void UpdateBounds();
    private Bounds GetBounds();
    private Vector2 CalculateOffset(Vector2 delta);
    protected void SetDirty();
    protected void SetDirtyCaching();
    public void CenterOnPosition(Vector2 pos);
    public Rect get_normalizedViewRect();
    public sealed virtual void LayoutComplete();
    public sealed virtual void GraphicUpdateComplete();
    private sealed virtual override Transform UnityEngine.UI.ICanvasElement.get_transform();
}
public class UnityEngine.UI.ScrollRectSettable : ScrollRect {
    public void SetHorizNormalizedPosition(float value);
    public void SetVertNormalizedPosition(float value);
}
[ExtensionAttribute]
public static class UnityEngine.UIEx : object {
    [ExtensionAttribute]
public static Vector2 Unpivot(RectTransform rect, Vector2 localPos);
    [ExtensionAttribute]
public static void CenterOnPosition(ScrollRect scrollrect, Vector2 pos);
    [ExtensionAttribute]
public static void RebuildHackUnity2019(Image image);
}
public class UnityHookHandler : SingletonComponent`1<UnityHookHandler> {
    public static void EnsureCreated();
    private static void CreateInstance();
}
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", "")]
[EditorBrowsableAttribute("1")]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1 : object {
    private static MonoScriptData Get();
}
public static class UnityStandardAssets.CinematicEffects.ImageEffectHelper : object {
    public static bool supportsDX11 { get; }
    public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect);
    public static Material CheckShaderAndCreateMaterial(Shader s);
    public static bool get_supportsDX11();
}
public class UnityStandardAssets.CinematicEffects.MinAttribute : PropertyAttribute {
    public float min;
    public MinAttribute(float min);
}
public class UnityStandardAssets.CinematicEffects.RenderTextureUtility : object {
    private List`1<RenderTexture> m_TemporaryRTs;
    public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer, RenderTextureFormat format, FilterMode filterMode);
    public void ReleaseTemporaryRenderTexture(RenderTexture rt);
    public void ReleaseAllTemporaryRenderTextures();
}
[ImageEffectAllowedInSceneView]
[AddComponentMenu("Image Effects/Cinematic/Tonemapping and Color Grading")]
[ExecuteInEditMode]
public class UnityStandardAssets.CinematicEffects.TonemappingColorGrading : MonoBehaviour {
    [SerializeField]
[SettingsGroup]
private EyeAdaptationSettings m_EyeAdaptation;
    [SerializeField]
[SettingsGroup]
private TonemappingSettings m_Tonemapping;
    [SerializeField]
[SettingsGroup]
private ColorGradingSettings m_ColorGrading;
    [SerializeField]
[SettingsGroup]
private LUTSettings m_Lut;
    [SerializeField]
private Shader m_Shader;
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Other/Scope Overlay")]
public class UnityStandardAssets.ImageEffects.ScopeEffect : PostEffectsBase {
    public Material overlayMaterial;
    public virtual bool CheckResources();
    public sealed virtual bool IsActive();
    public sealed virtual void OnRenderImage(RenderTexture source, RenderTexture destination);
}
public class UnparentOnDestroy : MonoBehaviour {
    public float destroyAfterSeconds;
    public sealed virtual void OnParentDestroying();
    protected void OnValidate();
}
public class UnreadMessages : SingletonComponent`1<UnreadMessages> {
    public StyleAsset AllRead;
    public StyleAsset Unread;
    public RustButton Button;
    public GameObject UnreadTextObject;
    public RustText UnreadText;
    public GameObject MessageList;
    public GameObject MessageListContainer;
    public GameObject MessageListEmpty;
}
public abstract class UpdateBehaviour : MonoBehaviour {
}
public class UpdateHandler : SingletonComponent`1<UpdateHandler> {
}
public class Upkeep : PrefabAttribute {
    public float upkeepMultiplier;
    protected virtual Type GetIndexedType();
}
public class UserPersistance : object {
    public static Database blueprints;
    public static Database deaths;
    public static Database identities;
    public static Database tokens;
    public static Database playerState;
    public static Dictionary`2<ulong, string> nameCache;
    private static Dictionary`2<ulong, string> wipeIdCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MruDictionary`2<ulong, ValueTuple`2<int, bool>> tokenCache;
    public UserPersistance(string strFolder);
    public virtual void Dispose();
    public PersistantPlayer GetPlayerInfo(ulong playerID);
    private PersistantPlayer FetchFromDatabase(ulong playerID);
    public void SetPlayerInfo(ulong playerID, PersistantPlayer info);
    public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory);
    public PlayerLifeStory GetLastLifeStory(ulong playerID);
    public string GetPlayerName(ulong playerID);
    public void SetPlayerName(ulong playerID, string name);
    public int GetOrGenerateAppToken(ulong playerID, Boolean& locked);
    public void RegenerateAppToken(ulong playerID);
    private static int GenerateAppToken();
    public bool SetAppTokenLocked(ulong playerID, bool locked);
    public Byte[] GetPlayerState(ulong playerID);
    public void SetPlayerState(ulong playerID, Byte[] state);
    public string GetUserWipeId(ulong playerID);
    public void ResetPlayerState(ulong playerID);
}
internal class UVTextureAnimator : MonoBehaviour {
    public int Rows;
    public int Columns;
    public float Fps;
    public int OffsetMat;
    public bool IsLoop;
    public float StartDelay;
    private bool isInizialised;
    private int index;
    private int count;
    private int allCount;
    private float deltaFps;
    private bool isVisible;
    private bool isCorutineStarted;
    private Renderer currentRenderer;
    private Material instanceMaterial;
    private void Start();
    private void InitDefaultVariables();
    private void Play();
    private void PlayDelay();
    private void OnEnable();
    private void OnDisable();
    [IteratorStateMachineAttribute("UVTextureAnimator/<UpdateCorutine>d__21")]
private IEnumerator UpdateCorutine();
    private void UpdateCorutineFrame();
    private void OnDestroy();
}
public class v_chainsaw : MonoBehaviour {
    public bool bAttacking;
    public bool bHitMetal;
    public bool bHitWood;
    public bool bHitFlesh;
    public bool bEngineOn;
    public ParticleSystem[] hitMetalFX;
    public ParticleSystem[] hitWoodFX;
    public ParticleSystem[] hitFleshFX;
    public SoundDefinition hitMetalSoundDef;
    public SoundDefinition hitWoodSoundDef;
    public SoundDefinition hitFleshSoundDef;
    public Sound hitSound;
    public GameObject hitSoundTarget;
    public float hitSoundFadeTime;
    public ParticleSystem smokeEffect;
    public Animator chainsawAnimator;
    public Renderer chainRenderer;
    public Material chainlink;
    private MaterialPropertyBlock block;
    private Vector2 saveST;
    private float chainSpeed;
    private float chainAmount;
    public float temp1;
    public float temp2;
    public void OnEnable();
    private void Awake();
    private void Start();
    private void ScrollChainTexture();
    private void Update();
    private void DoHitSound(SoundDefinition soundDef);
}
public class VacuumBreather.PidController : object {
    private static float MaxOutput;
    private float _integralMax;
    private float _integral;
    private float _kp;
    private float _ki;
    private float _kd;
    public float Kp { get; public set; }
    public float Ki { get; public set; }
    public float Kd { get; public set; }
    public PidController(float kp, float ki, float kd);
    public float get_Kp();
    public void set_Kp(float value);
    public float get_Ki();
    public void set_Ki(float value);
    public float get_Kd();
    public void set_Kd(float value);
    public float ComputeOutput(float error, float delta, float deltaTime);
}
public class VacuumBreather.PidQuaternionController : object {
    private PidController[] _internalController;
    public float Kp { get; public set; }
    public float Ki { get; public set; }
    public float Kd { get; public set; }
    public PidQuaternionController(float kp, float ki, float kd);
    public float get_Kp();
    public void set_Kp(float value);
    public float get_Ki();
    public void set_Ki(float value);
    public float get_Kd();
    public void set_Kd(float value);
    public static Quaternion MultiplyAsVector(Matrix4x4 matrix, Quaternion quaternion);
    public static Quaternion ToEulerAngleQuaternion(Vector3 eulerAngles);
    public Vector3 ComputeRequiredAngularAcceleration(Quaternion currentOrientation, Quaternion desiredOrientation, Vector3 currentAngularVelocity, float deltaTime);
    private Quaternion ComputeOutput(Quaternion error, Quaternion delta, float deltaTime);
}
[ExtensionAttribute]
public static class VacuumBreather.QuaternionExtensions : object {
    [ExtensionAttribute]
public static Quaternion Multiply(Quaternion quaternion, float scalar);
    public static Quaternion RequiredRotation(Quaternion from, Quaternion to);
    [ExtensionAttribute]
public static Quaternion Subtract(Quaternion lhs, Quaternion rhs);
}
public class ValidBounds : SingletonComponent`1<ValidBounds> {
    public Bounds worldBounds;
    public static bool Test(BaseEntity entity, Vector3 vPos);
    public static float TestDist(BaseEntity entity, Vector3 vPos);
    public static bool TestInnerBounds(Vector3 vPos);
    public static bool TestOuterBounds(Vector3 vPos);
    internal bool IsInsideInnerBounds(Vector3 vPos);
    internal bool IsInsideOuterBounds(Vector3 vPos);
    public static float GetMaximumPointTutorial();
    public static float GetMaximumPoint();
    internal float DistToWorldEdge2D(Vector3 vPos);
}
public abstract class VehicleChassisVisuals`1 : MonoBehaviour {
}
[RequireComponent("ItemIcon")]
public class VehicleEditingItemIcon : MonoBehaviour {
    [SerializeField]
private Image foregroundImage;
    [SerializeField]
private Image linkImage;
}
public class VehicleEditingPanel : LootPanel {
    [RangeAttribute("0", "1")]
[SerializeField]
private float disabledAlpha;
    [SerializeField]
[HeaderAttribute("Edit Vehicle")]
private CanvasGroup editGroup;
    [SerializeField]
private GameObject moduleInternalItemsGroup;
    [SerializeField]
private GameObject moduleInternalLiquidsGroup;
    [SerializeField]
private GameObject destroyChassisGroup;
    [SerializeField]
private Button itemTakeButton;
    [SerializeField]
private Button liquidTakeButton;
    [SerializeField]
private GameObject liquidHelp;
    [SerializeField]
private GameObject liquidButton;
    [SerializeField]
private Color gotColor;
    [SerializeField]
private Color notGotColor;
    [SerializeField]
private Text generalInfoText;
    [SerializeField]
private Text generalWarningText;
    [SerializeField]
private Image generalWarningImage;
    [SerializeField]
private Text repairInfoText;
    [SerializeField]
private Button repairButton;
    [SerializeField]
private Text destroyChassisButtonText;
    [SerializeField]
private Text destroyChassisCountdown;
    [SerializeField]
private Phrase phraseEditingInfo;
    [SerializeField]
private Phrase phraseNoOccupant;
    [SerializeField]
private Phrase phraseBadOccupant;
    [SerializeField]
private Phrase phrasePlayerObstructing;
    [SerializeField]
private Phrase phraseNotDriveable;
    [SerializeField]
private Phrase phraseNotRepairable;
    [SerializeField]
private Phrase phraseRepairNotNeeded;
    [SerializeField]
private Phrase phraseRepairSelectInfo;
    [SerializeField]
private Phrase phraseRepairEnactInfo;
    [SerializeField]
private Phrase phraseHasLock;
    [SerializeField]
private Phrase phraseHasNoLock;
    [SerializeField]
private Phrase phraseAddLock;
    [SerializeField]
private Phrase phraseAddLockButton;
    [SerializeField]
private Phrase phraseChangeLockCodeButton;
    [SerializeField]
private Text carLockInfoText;
    [SerializeField]
private RustText carLockButtonText;
    [SerializeField]
private Button actionLockButton;
    [SerializeField]
private Button removeLockButton;
    [SerializeField]
private GameObjectRef keyEnterDialog;
    [SerializeField]
private Phrase phraseEmptyStorage;
    [HeaderAttribute("Create Chassis")]
[SerializeField]
private CreateChassisEntry[] chassisOptions;
}
public class VehicleEngineController`1 : object {
    [CompilerGeneratedAttribute]
private IFuelSystem <FuelSystem>k__BackingField;
    public TOwner owner;
    private bool isServer;
    public float engineStartupTime;
    public Transform waterloggedPoint;
    public Flags engineStartingFlag;
    public EngineState<TOwner> CurEngineState { get; }
    public bool IsOn { get; }
    public bool IsOff { get; }
    public bool IsStarting { get; }
    public bool IsStartingOrOn { get; }
    public IFuelSystem FuelSystem { get; private set; }
    public VehicleEngineController`1(TOwner owner, IFuelSystem fuelSystem, bool isServer, float engineStartupTime, Transform waterloggedPoint, Flags engineStartingFlag);
    public EngineState<TOwner> get_CurEngineState();
    public bool get_IsOn();
    public bool get_IsOff();
    public bool get_IsStarting();
    public bool get_IsStartingOrOn();
    [CompilerGeneratedAttribute]
public IFuelSystem get_FuelSystem();
    [CompilerGeneratedAttribute]
private void set_FuelSystem(IFuelSystem value);
    public EngineState<TOwner> EngineStateFrom(Flags flags);
    public void TryStartEngine(BasePlayer player);
    public void FinishStartingEngine();
    public void StopEngine();
    public void CheckEngineState();
    public bool CanRunEngine();
    public bool IsWaterlogged();
    public int TickFuel(float fuelPerSecond);
    public void CancelEngineStart();
}
public class VehicleLiftOccupantTrigger : TriggerBase {
    [CompilerGeneratedAttribute]
private ModularCar <carOccupant>k__BackingField;
    public ModularCar carOccupant { get; private set; }
    [CompilerGeneratedAttribute]
public ModularCar get_carOccupant();
    [CompilerGeneratedAttribute]
private void set_carOccupant(ModularCar value);
    protected virtual void OnDisable();
    internal virtual GameObject InterestedInObject(GameObject obj);
    internal virtual void OnEntityEnter(BaseEntity ent);
    internal virtual void OnEntityLeave(BaseEntity ent);
}
public class VehicleLight : MonoBehaviour {
    public bool IsBrake;
    public GameObject toggleObject;
    public LightRenderer[] renderers;
    [ColorUsageAttribute("True", "True")]
public Color lightOnColour;
    [ColorUsageAttribute("True", "True")]
public Color brakesOnColour;
    public bool applyToTransmittance;
    public bool useLightOnColourForBrake;
}
public abstract class VehicleModuleButtonComponent : MonoBehaviour {
    public string interactionColliderName;
    public SoundDefinition pressSoundDef;
    public abstract virtual void ServerUse(BasePlayer player, BaseVehicleModule parentModule);
}
public class VehicleModuleCamper : VehicleModuleSeating {
    public GameObjectRef SleepingBagEntity;
    public Transform[] SleepingBagPoints;
    public GameObjectRef LockerEntity;
    public Transform LockerPoint;
    public GameObjectRef BbqEntity;
    public Transform BbqPoint;
    public GameObjectRef StorageEntity;
    public Transform StoragePoint;
    public EntityRef`1<BaseOven> activeBbq;
    public EntityRef`1<Locker> activeLocker;
    public EntityRef`1<StorageContainer> activeStorage;
    private bool wasLoaded;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex);
    protected virtual Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos);
    public virtual void PostServerLoad();
    public virtual void Spawn();
    private void OnItemAddedRemoved(Item item, bool add);
    protected virtual bool CanBeMovedNowOnVehicle();
    protected virtual void PostConditionalRefresh();
    private CamperSeatConfig GetSeatConfig();
    public virtual void Save(SaveInfo info);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_OpenLocker(RPCMessage msg);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_OpenStorage(RPCMessage msg);
    internal virtual void DoServerDestroy();
    public IItemContainerEntity GetContainer();
    public virtual string Admin_Who();
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual bool IsOnThisModule(BasePlayer player);
    public virtual void Load(LoadInfo info);
}
public class VehicleModuleEngine : VehicleModuleStorage {
    [SerializeField]
public Engine engine;
    [CompilerGeneratedAttribute]
private bool <IsUsable>k__BackingField;
    [CompilerGeneratedAttribute]
private float <PerformanceFractionAcceleration>k__BackingField;
    [CompilerGeneratedAttribute]
private float <PerformanceFractionTopSpeed>k__BackingField;
    [CompilerGeneratedAttribute]
private float <PerformanceFractionFuelEconomy>k__BackingField;
    [CompilerGeneratedAttribute]
private float <OverallPerformanceFraction>k__BackingField;
    private static float FORCE_MULTIPLIER;
    private static float HEALTH_PERFORMANCE_FRACTION;
    private static float LOW_PERFORMANCE_THRESHOLD;
    private Sound badPerformanceLoop;
    private Modulator badPerformancePitchModulator;
    private float prevSmokePercent;
    private static float MIN_FORCE_BIAS;
    private static float MAX_FORCE_BIAS;
    public bool HasAnEngine { get; }
    public bool IsUsable { get; public set; }
    public float PerformanceFractionAcceleration { get; public set; }
    public float PerformanceFractionTopSpeed { get; public set; }
    public float PerformanceFractionFuelEconomy { get; public set; }
    public float OverallPerformanceFraction { get; public set; }
    public bool AtLowPerformance { get; }
    public bool AtPeakPerformance { get; }
    public int KW { get; }
    public EngineAudioSet AudioSet { get; }
    private bool EngineIsOn { get; }
    public virtual bool get_HasAnEngine();
    [CompilerGeneratedAttribute]
public bool get_IsUsable();
    [CompilerGeneratedAttribute]
public void set_IsUsable(bool value);
    [CompilerGeneratedAttribute]
public float get_PerformanceFractionAcceleration();
    [CompilerGeneratedAttribute]
public void set_PerformanceFractionAcceleration(float value);
    [CompilerGeneratedAttribute]
public float get_PerformanceFractionTopSpeed();
    [CompilerGeneratedAttribute]
public void set_PerformanceFractionTopSpeed(float value);
    [CompilerGeneratedAttribute]
public float get_PerformanceFractionFuelEconomy();
    [CompilerGeneratedAttribute]
public void set_PerformanceFractionFuelEconomy(float value);
    [CompilerGeneratedAttribute]
public float get_OverallPerformanceFraction();
    [CompilerGeneratedAttribute]
public void set_OverallPerformanceFraction(float value);
    public bool get_AtLowPerformance();
    public bool get_AtPeakPerformance();
    public int get_KW();
    public EngineAudioSet get_AudioSet();
    private bool get_EngineIsOn();
    public virtual void InitShared();
    public virtual void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState);
    public virtual float GetMaxDriveForce();
    public void RefreshPerformanceStats(EngineStorage engineStorage);
    public float GetPerformanceFraction(float statBoostPercent);
    public virtual void Load(LoadInfo info);
    public virtual bool CanBeLooted(BasePlayer player);
    public virtual void VehicleFixedUpdate();
    public virtual float GetAdjustedDriveForce(float absSpeed, float topSpeed);
    public virtual void Hurt(HitInfo info);
    public virtual void OnHealthChanged(float oldValue, float newValue);
    public virtual bool AdminFixUp(int tier);
}
public class VehicleModuleInformationPanel : ItemInformationPanel {
    public ItemStatValue socketsDisplay;
    public ItemStatValue hpDisplay;
}
public class VehicleModuleSeating : BaseVehicleModule {
    [SerializeField]
private ProtectionProperties passengerProtection;
    [SerializeField]
private ModularCarCodeLockVisuals codeLockVisuals;
    [SerializeField]
private Seating seating;
    [HideInInspector]
[SerializeField]
private Vector3 steerAngle;
    [HideInInspector]
[SerializeField]
private Vector3 accelAngle;
    [HideInInspector]
[SerializeField]
private Vector3 brakeAngle;
    [SerializeField]
[HideInInspector]
private Vector3 speedometerAngle;
    [HideInInspector]
[SerializeField]
private Vector3 fuelAngle;
    [SerializeField]
[HeaderAttribute("Horn")]
private SoundDefinition hornLoop;
    [SerializeField]
private SoundDefinition hornStart;
    private static Flags FLAG_HORN;
    private float steerPercent;
    private float throttlePercent;
    private float brakePercent;
    private Nullable`1<bool> checkEngineLightOn;
    private Nullable`1<bool> fuelLightOn;
    [CompilerGeneratedAttribute]
private ModularCar <Car>k__BackingField;
    protected IVehicleLockUser VehicleLockUser;
    private MaterialPropertyBlock dashboardLightPB;
    private static int emissionColorID;
    private BasePlayer hornPlayer;
    public bool HasSeating { get; }
    public ModularCar Car { get; private set; }
    protected bool IsOnACar { get; }
    protected bool IsOnAVehicleLockUser { get; }
    public bool DoorsAreLockable { get; }
    private static VehicleModuleSeating();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual bool get_HasSeating();
    [CompilerGeneratedAttribute]
public ModularCar get_Car();
    [CompilerGeneratedAttribute]
private void set_Car(ModularCar value);
    protected bool get_IsOnACar();
    protected bool get_IsOnAVehicleLockUser();
    public bool get_DoorsAreLockable();
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public virtual bool IsOnThisModule(BasePlayer player);
    public bool HasADriverSeat();
    public virtual void ModuleAdded(BaseModularVehicle vehicle, int firstSocketIndex);
    public virtual void ModuleRemoved();
    public bool PlayerCanDestroyLock(BasePlayer player);
    protected BaseVehicleSeat GetSeatAtIndex(int index);
    public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info);
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public virtual void OnPlayerDismountedVehicle(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_DestroyLock(RPCMessage msg);
    protected virtual Vector3 ModifySeatPositionLocalSpace(int index, Vector3 desiredPos);
    public virtual void OnEngineStateChanged(EngineState<GroundVehicle> oldState, EngineState<GroundVehicle> newState);
}
public class VehicleModuleStorage : VehicleModuleSeating {
    [SerializeField]
private Storage storage;
    private EntityRef storageUnitInstance;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public IItemContainerEntity GetContainer();
    public virtual void Load(LoadInfo info);
    public virtual void Spawn();
    public virtual void PostServerLoad();
    private void OnItemAddedRemoved(Item item, bool add);
    internal virtual void DoServerDestroy();
    public virtual void Save(SaveInfo info);
    public void CreateStorageEntity();
    public void DestroyStorageEntity();
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Open(RPCMessage msg);
    private bool TryOpen(BasePlayer player);
    protected virtual bool CanBeMovedNowOnVehicle();
    [RPC_Server]
[MaxDistance("3")]
public void RPC_TryOpenWithKeycode(RPCMessage msg);
}
public class VehicleModuleTaxi : VehicleModuleStorage {
    [HeaderAttribute("Taxi")]
[SerializeField]
private SoundDefinition kickButtonSound;
    [SerializeField]
private SphereCollider kickButtonCollider;
    [SerializeField]
private float maxKickVelocity;
    private Vector3 KickButtonPos { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private Vector3 get_KickButtonPos();
    private bool CanKickPassengers(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
public void RPC_KickPassengers(RPCMessage msg);
    private void KickPassengers();
}
public class VehiclePrivilege : SimplePrivilege {
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public bool IsDriver(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
private void AddSelfAuthorize(RPCMessage rpc);
    public void AddPlayer(BasePlayer player);
    [RPC_Server]
[MaxDistance("3")]
private void RemoveSelfAuthorize(RPCMessage rpc);
    [RPC_Server]
[MaxDistance("3")]
private void ClearList(RPCMessage rpc);
}
public class VehicleSpawner : BaseEntity {
    public float spawnNudgeRadius;
    public float cleanupRadius;
    public float occupyRadius;
    public SpawnPair[] objectsToSpawn;
    public Transform spawnOffset;
    public float safeRadius;
    protected bool LogAnalytics { get; }
    public virtual int GetOccupyLayer();
    public IVehicleSpawnUser GetVehicleOccupying();
    public bool IsPadOccupied();
    public virtual void OnEntityMessage(BaseEntity from, string msg);
    public IVehicleSpawnUser SpawnVehicle(string prefabToSpawn, BasePlayer newOwner);
    protected virtual bool get_LogAnalytics();
    public void CleanupArea(float radius);
    public void NudgePlayersInRadius(float radius);
}
public class VehicleSpawnPoint : SpaceCheckingSpawnPoint {
    public virtual void ObjectSpawned(SpawnPointInstance instance);
    public static void AddStartingFuel(IVehicleSpawnUser vehicle);
}
public class VehicleTerrainHandler : object {
    public string CurGroundPhysicsMatName;
    public Surface OnSurface;
    public bool IsGrounded;
    public float RayLength;
    private String[] TerrainRoad;
    private static float SECONDS_BETWEEN_TERRAIN_SAMPLE;
    private TimeSince timeSinceTerrainCheck;
    private BaseVehicle vehicle;
    public bool IsOnSnowOrIce { get; }
    public VehicleTerrainHandler(BaseVehicle vehicle);
    public bool get_IsOnSnowOrIce();
    public void FixedUpdate();
    private void DoTerrainCheck();
    private bool GetOnRoad(string physicMat);
}
public class VehicleVendor : NPCTalking {
    public EntityRef spawnerRef;
    public VehicleSpawner vehicleSpawner;
    public virtual string GetConversationStartSpeech(BasePlayer player);
    public VehicleSpawner GetVehicleSpawner();
    public virtual void UpdateFlags();
    public virtual void ServerInit();
    public virtual void Save(SaveInfo info);
    public virtual ConversationData GetConversationFor(BasePlayer player);
    public virtual void Load(LoadInfo info);
}
public class VendingMachine : StorageContainer {
    [HeaderAttribute("VendingMachine")]
public static Phrase WaitForVendingMessage;
    public GameObjectRef adminMenuPrefab;
    public string customerPanel;
    public SellOrderContainer sellOrders;
    public SoundPlayer buySound;
    public string shopName;
    public int maxCurrencyVolume;
    public GameObjectRef mapMarkerPrefab;
    public bool IsLocalized;
    private Action fullUpdateCached;
    protected BasePlayer vend_Player;
    private int vend_sellOrderID;
    private int vend_numberOfTransactions;
    public bool transactionActive;
    private VendingMachineMapMarker myMarker;
    private bool industrialItemIncoming;
    public static Phrase TooManySellOrders;
    public ItemDefinition blueprintBaseDef { get; }
    private static VendingMachine();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void Load(LoadInfo info);
    public static int GetTotalPriceForOrder(SellOrder order);
    public static int GetTotalPriceForOrder(int currencyAmountPerItem, float multiplier);
    public ItemDefinition get_blueprintBaseDef();
    public virtual void Save(SaveInfo info);
    public virtual void ServerInit();
    public virtual void DestroyShared();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public void FullUpdate();
    protected virtual void OnInventoryDirty();
    public void RefreshSellOrderStockLevel(ItemDefinition itemDef);
    protected virtual float GetDiscountForSlot(int sellOrderSlot, SellOrder forOrder);
    public bool OutOfStock();
    public virtual void PostServerLoad();
    public void UpdateEmptyFlag();
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual void InstallDefaultSellOrders();
    public virtual bool HasVendingSounds();
    public virtual float GetBuyDuration();
    public void SetPendingOrder(BasePlayer buyer, int sellOrderId, int numberOfTransactions);
    public void ClearPendingOrder();
    [IsVisible("3")]
[RPC_Server]
[CallsPerSecond("5")]
public void BuyItem(RPCMessage rpc);
    public virtual void CompletePendingOrder();
    [IsVisible("3")]
[RPC_Server]
public void TransactionStart(RPCMessage rpc);
    private void GetItemsToSell(SellOrder sellOrder, List`1<Item> items);
    public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action`2<BasePlayer, Item> onCurrencyRemoved, Action`2<BasePlayer, Item> onItemPurchased, MarketTerminal droneMarketTerminal);
    protected virtual void RecordSaleAnalytics(Item itemSold, int orderId);
    public virtual void TakeCurrencyItem(Item takenCurrencyItem);
    public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer);
    public void SendSellOrders(BasePlayer player);
    [RPC_Server]
[IsVisible("3")]
public void RPC_Broadcast(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_UpdateShopName(RPCMessage msg);
    public void UpdateMapMarkerPosition();
    public void UpdateMapMarker(bool updatePosition);
    public void OpenShop(BasePlayer ply);
    [MaxDistance("3")]
[RPC_Server]
public void RPC_OpenShopNoLOS(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_OpenShop(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_OpenAdmin(RPCMessage msg);
    public void OnIndustrialItemTransferBegins();
    public void OnIndustrialItemTransferEnds();
    public bool CanAcceptItem(Item item, int targetSlot);
    public virtual bool CanMoveFrom(BasePlayer player, Item item);
    public virtual bool CanOpenLootPanel(BasePlayer player, string panelName);
    [IsVisible("3")]
[RPC_Server]
public void RPC_DeleteSellOrder(RPCMessage msg);
    [RPC_Server]
[IsVisible("3")]
public void RPC_RotateVM(RPCMessage msg);
    [IsVisible("3")]
[RPC_Server]
public void RPC_AddSellOrder(RPCMessage msg);
    public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState);
    public void RefreshAndSendNetworkUpdate();
    public void UpdateOrCreateSalesSheet();
    protected virtual bool CanShop(BasePlayer bp);
    protected virtual bool CanRotate();
    public bool IsBroadcasting();
    public bool IsInventoryEmpty();
    public bool IsVending();
    public bool PlayerBehind(BasePlayer player);
    public bool PlayerInfront(BasePlayer player);
    public virtual bool CanPlayerAdmin(BasePlayer player);
    public virtual bool SupportsChildDeployables();
    public virtual string GetTranslationToken();
}
public class VendingMachineFront : BaseEntity {
    public VendingMachine vendingMachine;
}
public class VendingMachineMapMarker : MapMarker {
    public string markerShopName;
    public VendingMachine server_vendingMachine;
    public VendingMachine client_vendingMachine;
    public NetworkableId client_vendingMachineNetworkID;
    public GameObjectRef clusterMarkerObj;
    private UIMapVendingMachineMarker myUIMarker;
    private RectTransform markerTransform;
    public void SetVendingMachine(VendingMachine vm, string shopName);
    public void TryUpdatePosition();
    public virtual void Save(SaveInfo info);
    public virtual AppMarker GetAppMarkerData();
}
public class VendingMachineScreen : MonoBehaviour {
    public RawImage largeIcon;
    public RawImage blueprintIcon;
    public Text mainText;
    public Text lowerText;
    public Text centerText;
    public RawImage smallIcon;
    public VendingMachine vendingMachine;
    public Sprite outOfStockSprite;
    public Renderer fadeoutMesh;
    public CanvasGroup screenCanvas;
    public Renderer light1;
    public Renderer light2;
    public bool isUpdatedWithNotifySystem;
}
public class VendingPanelAdmin : UIDialog {
    public GameObject sellOrderAdminContainer;
    public GameObject sellOrderAdminPrefab;
    public TMP_InputField storeNameInputField;
    public EmojiGallery emojiGallery;
}
public class VendingPriceMultiplierWidget : MonoBehaviour {
    public GameObject SurchargeRoot;
    public RustText SurchargeText;
    public GameObject DiscountRoot;
    public RustText DiscountText;
    public Tooltip SurchargeTooltip;
    public Tooltip DiscountTooltip;
    public GameObject RegularTooltip;
    public GameObject AlwaysOnTopTooltip;
}
public class VendorList : MonoBehaviour {
    public GameObject singleHeader;
    public GameObject multiHeader;
    public Transform ListParent;
    public GameObjectRef SingleVendorPrefab;
    public ScrollRect scrollRect;
}
public class VendorListing : FacepunchBehaviour {
    public Image panelBacking;
    [HeaderAttribute("Text")]
public RustText AvailableText;
    public RustText CostText;
    public RustText AvailableAmount;
    public RustText CostAmount;
    public RustText InStockAmount;
    public RustText InStockText;
    public VendingPriceMultiplierWidget PriceMultiplier;
    [HeaderAttribute("Icons")]
public Image AvaliableIcon;
    public Image CostIcon;
    [HeaderAttribute("BP Icons")]
public Image AvaliableBPIcon;
    public Image CostBPIcon;
    [HeaderAttribute("Backing")]
public Image AvaliableBPBacking;
    public Image CostBPBacking;
    [HeaderAttribute("Tooltips")]
public Tooltip avaliableIconTooltip;
    public Tooltip costIconTooltip;
    [HeaderAttribute("Condition")]
public CanvasGroup availableConditionGroup;
    public Image availableCondition;
    public Image availableMaxCondition;
    public GameObject brokenIcon;
    [HeaderAttribute("Slots")]
public GameObject slots;
    public Image[] slotImages;
    [SerializeField]
private FlexTransition transition;
    public static Phrase inStockPhrase;
    public static Phrase outOfStockPhrase;
    public static Phrase attachmentsPhrase;
    public static Phrase ammoPhrase;
    private static VendorListing();
}
public class VertexColorAnimator : MonoBehaviour {
    public List`1<MeshHolder> animationMeshes;
    public List`1<float> animationKeyframes;
    public float timeScale;
    public int mode;
    private float elapsedTime;
    public void initLists();
    public void addMesh(Mesh mesh, float atPosition);
    private void Start();
    public void replaceKeyframe(int frameIndex, Mesh mesh);
    public void deleteKeyframe(int frameIndex);
    public void scrobble(float scrobblePos);
    private void Update();
}
[ExecuteInEditMode]
public class VertexColorStream : MonoBehaviour {
    [HideInInspector]
public Mesh originalMesh;
    [HideInInspector]
public Mesh paintedMesh;
    [HideInInspector]
public MeshHolder meshHold;
    [HideInInspector]
public Vector3[] _vertices;
    [HideInInspector]
public Vector3[] _normals;
    [HideInInspector]
public Int32[] _triangles;
    [HideInInspector]
public Int32[][] _Subtriangles;
    [HideInInspector]
public Matrix4x4[] _bindPoses;
    [HideInInspector]
public BoneWeight[] _boneWeights;
    [HideInInspector]
public Bounds _bounds;
    [HideInInspector]
public int _subMeshCount;
    [HideInInspector]
public Vector4[] _tangents;
    [HideInInspector]
public Vector2[] _uv;
    [HideInInspector]
public Vector2[] _uv2;
    [HideInInspector]
public Vector2[] _uv3;
    [HideInInspector]
public Color[] _colors;
    [HideInInspector]
public Vector2[] _uv4;
    private void OnDidApplyAnimationProperties();
    public void init(Mesh origMesh, bool destroyOld);
    public void setWholeMesh(Mesh tmpMesh);
    public Vector3[] setVertices(Vector3[] _deformedVertices);
    public Vector3[] getVertices();
    public Vector3[] getNormals();
    public Int32[] getTriangles();
    public void setTangents(Vector4[] _meshTangents);
    public Vector4[] getTangents();
    public void setColors(Color[] _vertexColors);
    public Color[] getColors();
    public Vector2[] getUVs();
    public void setUV4s(Vector2[] _uv4s);
    public Vector2[] getUV4s();
    public void unlink();
    public void rebuild();
    private void Start();
}
[ExecuteInEditMode]
public class VertexStreamChildrenRebuilder : MonoBehaviour {
}
public class ViewModel : MonoBehaviour {
    public GameObjectRef viewModelPrefab;
}
public class ViewmodelAspectOffset : MonoBehaviour {
    public Vector3 OffsetAmount;
    [TooltipAttribute("What aspect ratio should we start moving the viewmodel? 16:9 = 1.7, 21:9 = 2.3")]
public float aspectCutoff;
}
public class ViewmodelAttachment : EntityComponent`1<BaseEntity> {
    public GameObjectRef modelObject;
    public string targetBone;
    public bool hideViewModelIronSights;
    public AttachmentType attachmentType;
}
public class ViewmodelAttachmentOverride : MonoBehaviour {
    public Override[] Overrides;
}
public class ViewmodelBob : MonoBehaviour {
    public float bobSpeedWalk;
    public float bobSpeedRun;
    public float bobAmountWalk;
    public float bobAmountRun;
    public float leftOffsetRun;
}
public class ViewModelCamera : MonoBehaviour {
}
public class ViewmodelCameraAnimation : MonoBehaviour {
    public Transform CameraModifyBone;
    public bool ShouldSuppressLeftHandScreenShake;
    public float FadeInTime;
    public Vector3 PositionOffset;
    public Vector3 RotationOffset;
}
public class ViewmodelClothing : MonoBehaviour {
    public SkeletonSkin[] SkeletonSkins;
    public bool DisableHandsEntirely;
}
public class ViewModelDrawEvent : ValueType {
    public ViewModelRenderer viewModelRenderer;
    public Renderer renderer;
    public bool skipDepthPrePass;
    public Material material;
    public int subMesh;
    public int pass;
    public sealed virtual bool Equals(ViewModelDrawEvent other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ViewmodelEditor : SingletonComponent`1<ViewmodelEditor> {
}
public class ViewmodelIgniteToggle : MonoBehaviour {
    public void Start();
}
public class ViewmodelIk : MonoBehaviour {
}
public class ViewmodelItem : MonoBehaviour {
}
public class ViewmodelLower : MonoBehaviour {
    public bool lowerOnSprint;
    public bool lowerWhenCantAttack;
    public bool forceLower;
    public float lowerScale;
    public void SetShouldLower(bool shouldLower);
}
public class ViewmodelMountedAnchor : MonoBehaviour {
    public ViewmodelIk IkController;
}
public class ViewmodelPunch : MonoBehaviour {
    public AnimationCurve punchScale;
    public Vector3 punchDirection;
    public float punchDuration;
    public float punchMagnitude;
}
public class ViewModelRenderer : MonoBehaviour {
    public List`1<Texture2D> cachedTextureRefs;
    public List`1<ViewModelDrawEvent> opaqueEvents;
    public List`1<ViewModelDrawEvent> transparentEvents;
    public Matrix4x4 prevModelMatrix;
    private Renderer viewModelRenderer;
}
public class ViewmodelScope : MonoBehaviour {
    public float smoothSpeed;
    public Material scopeMaterialOverride;
}
public class ViewmodelSway : MonoBehaviour {
    public float positionalSwaySpeed;
    public float positionalSwayAmount;
    public float rotationSwaySpeed;
    public float rotationSwayAmount;
    public float rotateAmountTest;
}
public class ViewShake : object {
    [CompilerGeneratedAttribute]
private Vector3 <PositionOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector3 <AnglesOffset>k__BackingField;
    protected List`1<ShakeParameters> Entries;
    public Vector3 PositionOffset { get; protected set; }
    public Vector3 AnglesOffset { get; protected set; }
    [CompilerGeneratedAttribute]
public Vector3 get_PositionOffset();
    [CompilerGeneratedAttribute]
protected void set_PositionOffset(Vector3 value);
    [CompilerGeneratedAttribute]
public Vector3 get_AnglesOffset();
    [CompilerGeneratedAttribute]
protected void set_AnglesOffset(Vector3 value);
    public void AddShake(float amplitude, float frequency, float duration);
    public void Update();
    public void Stop();
}
public class VirtualEntityScheduler : object {
    [CompilerGeneratedAttribute]
private static VirtualEntityScheduler <Instance>k__BackingField;
    public static VirtualEntityScheduler Instance { get; private set; }
    private static VirtualEntityScheduler();
    [CompilerGeneratedAttribute]
public static VirtualEntityScheduler get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(VirtualEntityScheduler value);
}
public class VirtualItemIcon : MonoBehaviour {
    public ItemDefinition itemDef;
    public int itemAmount;
    public bool asBlueprint;
    public Image iconImage;
    public Image bpUnderlay;
    public Text amountText;
    public Text hoverText;
    public CanvasGroup iconContents;
    public Tooltip ToolTip;
    public CanvasGroup conditionObject;
    public Image conditionFill;
    public Image maxConditionFill;
    public Image cornerIcon;
    [HeaderAttribute("Slots")]
public GameObject slots;
    public Image[] slotImages;
    public static Phrase attachmentsPhrase;
    public static Phrase ammoPhrase;
    private static VirtualItemIcon();
}
public static class Vis : object {
    private static int colCount;
    public static Collider[] colBuffer;
    private static HashSet`1<object> hashSet;
    private static Vis();
    private static void Buffer(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static bool AnyColliders(Vector3 position, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Colliders(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Components(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Entities(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void EntityComponents(Vector3 position, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    private static void Buffer(OBB bounds, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Colliders(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Components(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Entities(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void EntityComponents(OBB bounds, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    private static void Buffer(Vector3 startPosition, Vector3 endPosition, float radius, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Colliders(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Components(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void Entities(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public static void EntityComponents(Vector3 startPosition, Vector3 endPosition, float radius, List`1<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
}
public class VisualCarWheel : CarWheel {
    public Transform visualWheel;
    public Transform visualWheelSteering;
    public bool visualPowerWheel;
    public ParticleSystem snowFX;
    public ParticleSystem sandFX;
    public ParticleSystem dirtFX;
    public ParticleSystem asphaltFX;
    public ParticleSystem waterFX;
    public ParticleSystem snowSpinFX;
    public ParticleSystem sandSpinFX;
    public ParticleSystem dirtSpinFX;
    public ParticleSystem asphaltSpinFX;
}
public class VisualiseTrigger : MonoBehaviour {
    [SerializeField]
private Color colour;
}
[AddComponentMenu("Rendering/Visualize Texture Density")]
[ImageEffectAllowedInSceneView]
[ExecuteInEditMode]
public class VisualizeTexelDensity : MonoBehaviour {
    public Shader shader;
    public string shaderTag;
    [RangeAttribute("1", "1024")]
public int texelsPerMeter;
    [RangeAttribute("0", "1")]
public float overlayOpacity;
    public bool showHUD;
    private Camera mainCamera;
    private bool initialized;
    private int screenWidth;
    private int screenHeight;
    private Camera texelDensityCamera;
    private RenderTexture texelDensityRT;
    private Texture texelDensityGradTex;
    private Material texelDensityOverlayMat;
    private static VisualizeTexelDensity instance;
    public static VisualizeTexelDensity Instance { get; }
    public static VisualizeTexelDensity get_Instance();
    private void Awake();
    private void OnEnable();
    private void OnDisable();
    private void LoadResources();
    private void SafeDestroyViewTexelDensity();
    private void SafeDestroyViewTexelDensityRT();
    private void UpdateViewTexelDensity(bool screenResized);
    private bool CheckScreenResized(int width, int height);
    private void OnPreCull();
    private void OnRenderImage(RenderTexture source, RenderTexture destination);
    private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle);
    private void OnGUI();
}
public class VisualStorageContainer : LootContainer {
    public VisualStorageContainerNode[] displayNodes;
    public DisplayModel[] displayModels;
    public Transform nodeParent;
    public GameObject defaultDisplayModel;
    public virtual void ServerInit();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public virtual void PopulateLoot();
    public void ClearRigidBodies();
    public void SetItemsVisible(bool vis);
    public void ItemUpdateComplete();
    public void UpdateVisibleItems(ItemContainer msg);
}
public class VisualStorageContainerNode : MonoBehaviour {
    private void Start();
    private void Update();
}
public class VitalInfo : MonoBehaviour {
    public HudElement Element;
    public Image InfoImage;
    public Vital VitalType;
    public RustText text;
    public static Phrase BoostActive;
    public static Phrase BoostsActive;
    private static VitalInfo();
}
public class VitalLevel : ValueType {
    public float Level;
    private float lastUsedTime;
    public float TimeSinceUsed { get; }
    internal void Add(float f);
    public float get_TimeSinceUsed();
    internal void Use(float f);
}
public class VitalNote : MonoBehaviour {
    public Vital VitalType;
    public FloatConditions showIf;
    public TextMeshProUGUI valueText;
}
public class VitalNoteOxygen : MonoBehaviour {
    [SerializeField]
private float refreshTime;
    [SerializeField]
private TextMeshProUGUI valueText;
    [SerializeField]
private Animator animator;
    [SerializeField]
private Image airIcon;
    [SerializeField]
private RectTransform airIconTr;
    [SerializeField]
private Image backgroundImage;
    [SerializeField]
private Color baseColour;
    [SerializeField]
private Color badColour;
    [SerializeField]
private Image iconImage;
    [SerializeField]
private Color iconBaseColour;
    [SerializeField]
private Color iconBadColour;
    protected bool show;
}
public class VitalRadial : MonoBehaviour {
    private void Awake();
}
public enum VLB.AttenuationEquation : Enum {
    public int value__;
    public static AttenuationEquation Linear;
    public static AttenuationEquation Quadratic;
    public static AttenuationEquation Blend;
}
[ExecuteInEditMode]
[HelpURLAttribute("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
[AddComponentMenu("")]
public class VLB.BeamGeometry : MonoBehaviour {
    private VolumetricLightBeam m_Master;
    private Matrix4x4 m_ColorGradientMatrix;
    private MeshType m_CurrentMeshType;
    [CompilerGeneratedAttribute]
private MeshRenderer <meshRenderer>k__BackingField;
    [CompilerGeneratedAttribute]
private MeshFilter <meshFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private Material <material>k__BackingField;
    [CompilerGeneratedAttribute]
private Mesh <coneMesh>k__BackingField;
    public MeshRenderer meshRenderer { get; private set; }
    public MeshFilter meshFilter { get; private set; }
    public Material material { get; private set; }
    public Mesh coneMesh { get; private set; }
    public bool visible { get; public set; }
    public int sortingLayerID { get; public set; }
    public int sortingOrder { get; public set; }
    [CompilerGeneratedAttribute]
public MeshRenderer get_meshRenderer();
    [CompilerGeneratedAttribute]
private void set_meshRenderer(MeshRenderer value);
    [CompilerGeneratedAttribute]
public MeshFilter get_meshFilter();
    [CompilerGeneratedAttribute]
private void set_meshFilter(MeshFilter value);
    [CompilerGeneratedAttribute]
public Material get_material();
    [CompilerGeneratedAttribute]
private void set_material(Material value);
    [CompilerGeneratedAttribute]
public Mesh get_coneMesh();
    [CompilerGeneratedAttribute]
private void set_coneMesh(Mesh value);
    public bool get_visible();
    public void set_visible(bool value);
    public int get_sortingLayerID();
    public void set_sortingLayerID(int value);
    public int get_sortingOrder();
    public void set_sortingOrder(int value);
    private void Start();
    private void OnDestroy();
    private static bool IsUsingCustomRenderPipeline();
    private void OnEnable();
    private void OnDisable();
    public void Initialize(VolumetricLightBeam master, Shader shader);
    public void RegenerateMesh();
    private void ComputeLocalMatrix();
    public void UpdateMaterialAndBounds();
    public void SetClippingPlane(Plane planeWS);
    public void SetClippingPlaneOff();
    private void OnBeginCameraRendering(ScriptableRenderContext context, Camera cam);
    private void OnWillRenderObject();
    private void UpdateCameraRelatedProperties(Camera cam);
}
public enum VLB.BlendingMode : Enum {
    public int value__;
    public static BlendingMode Additive;
    public static BlendingMode SoftAdditive;
    public static BlendingMode TraditionalTransparency;
}
public enum VLB.ColorMode : Enum {
    public int value__;
    public static ColorMode Flat;
    public static ColorMode Gradient;
}
[HelpURLAttribute("http://saladgamer.com/vlb-doc/config/")]
public class VLB.Config : ScriptableObject {
    public int geometryLayerID;
    public string geometryTag;
    public int geometryRenderQueue;
    public bool forceSinglePass;
    [HighlightNullAttribute]
[SerializeField]
private Shader beamShader1Pass;
    [FormerlySerializedAsAttribute("beamShader")]
[SerializeField]
[FormerlySerializedAsAttribute("BeamShader")]
[HighlightNullAttribute]
private Shader beamShader2Pass;
    public int sharedMeshSides;
    public int sharedMeshSegments;
    [RangeAttribute("0,01", "2")]
public float globalNoiseScale;
    public Vector3 globalNoiseVelocity;
    [HighlightNullAttribute]
public TextAsset noise3DData;
    public int noise3DSize;
    [HighlightNullAttribute]
public ParticleSystem dustParticlesPrefab;
    private static Config m_Instance;
    public Shader beamShader { get; }
    public Vector4 globalNoiseParam { get; }
    public static Config Instance { get; }
    public Shader get_beamShader();
    public Vector4 get_globalNoiseParam();
    public void Reset();
    public ParticleSystem NewVolumetricDustParticles();
    public static Config get_Instance();
}
public static class VLB.Consts : object {
    private static string HelpUrlBase;
    public static string HelpUrlBeam;
    public static string HelpUrlDustParticles;
    public static string HelpUrlDynamicOcclusion;
    public static string HelpUrlTriggerZone;
    public static string HelpUrlConfig;
    public static bool ProceduralObjectsVisibleInEditor;
    public static Color FlatColor;
    public static ColorMode ColorModeDefault;
    public static float Alpha;
    public static float SpotAngleDefault;
    public static float SpotAngleMin;
    public static float SpotAngleMax;
    public static float ConeRadiusStart;
    public static MeshType GeomMeshType;
    public static int GeomSidesDefault;
    public static int GeomSidesMin;
    public static int GeomSidesMax;
    public static int GeomSegmentsDefault;
    public static int GeomSegmentsMin;
    public static int GeomSegmentsMax;
    public static bool GeomCap;
    public static AttenuationEquation AttenuationEquationDefault;
    public static float AttenuationCustomBlending;
    public static float FadeStart;
    public static float FadeEnd;
    public static float FadeMinThreshold;
    public static float DepthBlendDistance;
    public static float CameraClippingDistance;
    public static float FresnelPowMaxValue;
    public static float FresnelPow;
    public static float GlareFrontal;
    public static float GlareBehind;
    public static float NoiseIntensityMin;
    public static float NoiseIntensityMax;
    public static float NoiseIntensityDefault;
    public static float NoiseScaleMin;
    public static float NoiseScaleMax;
    public static float NoiseScaleDefault;
    public static Vector3 NoiseVelocityDefault;
    public static BlendingMode BlendingModeDefault;
    public static BlendMode[] BlendingMode_SrcFactor;
    public static BlendMode[] BlendingMode_DstFactor;
    public static Boolean[] BlendingMode_AlphaAsBlack;
    public static float DynOcclusionMinSurfaceRatioDefault;
    public static float DynOcclusionMinSurfaceRatioMin;
    public static float DynOcclusionMinSurfaceRatioMax;
    public static float DynOcclusionMaxSurfaceDotDefault;
    public static float DynOcclusionMaxSurfaceAngleMin;
    public static float DynOcclusionMaxSurfaceAngleMax;
    public static int ConfigGeometryLayerIDDefault;
    public static string ConfigGeometryTagDefault;
    public static RenderQueue ConfigGeometryRenderQueueDefault;
    public static bool ConfigGeometryForceSinglePassDefault;
    public static int ConfigNoise3DSizeDefault;
    public static int ConfigSharedMeshSides;
    public static int ConfigSharedMeshSegments;
    public static HideFlags ProceduralObjectsHideFlags { get; }
    private static Consts();
    public static HideFlags get_ProceduralObjectsHideFlags();
}
[HelpURLAttribute("http://saladgamer.com/vlb-doc/comp-dynocclusion/")]
[DisallowMultipleComponent]
[ExecuteInEditMode]
[RequireComponent("VLB.VolumetricLightBeam")]
public class VLB.DynamicOcclusion : MonoBehaviour {
    public LayerMask layerMask;
    public float minOccluderArea;
    public int waitFrameCount;
    public float minSurfaceRatio;
    public float maxSurfaceDot;
    public PlaneAlignment planeAlignment;
    public float planeOffset;
    private VolumetricLightBeam m_Master;
    private int m_FrameCountToWait;
    private float m_RangeMultiplier;
    private UInt32 m_PrevNonSubHitDirectionId;
    private void OnValidate();
    private void OnEnable();
    private void OnDisable();
    private void Start();
    private void LateUpdate();
    private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff);
    private RaycastHit GetBestHit(Vector3 rayPos, Vector3 rayDir);
    private Vector3 GetDirection(UInt32 dirInt);
    private bool IsHitValid(RaycastHit hit);
    private void ProcessRaycasts();
    private void SetHit(RaycastHit hit);
    private void SetHitNull();
    private void SetClippingPlane(Plane planeWS);
    private void SetClippingPlaneOff();
}
public static class VLB.GlobalMesh : object {
    private static Mesh ms_Mesh;
    public static Mesh mesh { get; }
    public static Mesh get_mesh();
}
public class VLB.HighlightNullAttribute : PropertyAttribute {
}
public static class VLB.MeshGenerator : object {
    private static float kMinTruncatedRadius;
    private static bool duplicateBackFaces { get; }
    private static bool get_duplicateBackFaces();
    public static Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap);
    public static Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap);
    public static Mesh GenerateConeZ_Radius(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap);
    public static int GetVertexCount(int numSides, int numSegments, bool geomCap);
    public static int GetIndicesCount(int numSides, int numSegments, bool geomCap);
    public static int GetSharedMeshVertexCount();
    public static int GetSharedMeshIndicesCount();
}
public enum VLB.MeshType : Enum {
    public int value__;
    public static MeshType Shared;
    public static MeshType Custom;
}
public static class VLB.Noise3D : object {
    private static bool ms_IsSupportedChecked;
    private static bool ms_IsSupported;
    private static Texture3D ms_NoiseTexture;
    private static HideFlags kHideFlags;
    private static int kMinShaderLevel;
    public static bool isSupported { get; }
    public static bool isProperlyLoaded { get; }
    public static string isNotSupportedString { get; }
    public static bool get_isSupported();
    public static bool get_isProperlyLoaded();
    public static string get_isNotSupportedString();
    [RuntimeInitializeOnLoadMethodAttribute]
private static void OnStartUp();
    public static void LoadIfNeeded();
    private static Texture3D LoadTexture3D(TextAsset textData, int size);
}
public enum VLB.PlaneAlignment : Enum {
    public int value__;
    public static PlaneAlignment Surface;
    public static PlaneAlignment Beam;
}
public enum VLB.RenderQueue : Enum {
    public int value__;
    public static RenderQueue Custom;
    public static RenderQueue Background;
    public static RenderQueue Geometry;
    public static RenderQueue AlphaTest;
    public static RenderQueue GeometryLast;
    public static RenderQueue Transparent;
    public static RenderQueue Overlay;
}
[HelpURLAttribute("http://saladgamer.com/vlb-doc/comp-triggerzone/")]
[RequireComponent("VLB.VolumetricLightBeam")]
[DisallowMultipleComponent]
public class VLB.TriggerZone : MonoBehaviour {
    public bool setIsTrigger;
    public float rangeMultiplier;
    private static int kMeshColliderNumSides;
    private Mesh m_Mesh;
    private void Update();
}
[ExtensionAttribute]
public static class VLB.Utils : object {
    private static FloatPackingPrecision ms_FloatPackingPrecision;
    private static int kFloatPackingHighMinShaderLevel;
    public static string GetPath(Transform current);
    public static T NewWithComponent(string name);
    [ExtensionAttribute]
public static T GetOrAddComponent(GameObject self);
    [ExtensionAttribute]
public static T GetOrAddComponent(MonoBehaviour self);
    [ExtensionAttribute]
public static bool HasFlag(Enum mask, Enum flags);
    [ExtensionAttribute]
public static Vector2 xy(Vector3 aVector);
    [ExtensionAttribute]
public static Vector2 xz(Vector3 aVector);
    [ExtensionAttribute]
public static Vector2 yz(Vector3 aVector);
    [ExtensionAttribute]
public static Vector2 yx(Vector3 aVector);
    [ExtensionAttribute]
public static Vector2 zx(Vector3 aVector);
    [ExtensionAttribute]
public static Vector2 zy(Vector3 aVector);
    [ExtensionAttribute]
public static float GetVolumeCubic(Bounds self);
    [ExtensionAttribute]
public static float GetMaxArea2D(Bounds self);
    [ExtensionAttribute]
public static Color Opaque(Color self);
    public static void GizmosDrawPlane(Vector3 normal, Vector3 position, Color color, float size);
    [ExtensionAttribute]
public static Plane TranslateCustom(Plane plane, Vector3 translation);
    [ExtensionAttribute]
public static bool IsValid(Plane plane);
    [ExtensionAttribute]
public static Matrix4x4 SampleInMatrix(Gradient self, int floatPackingPrecision);
    [ExtensionAttribute]
public static Color[] SampleInArray(Gradient self, int samplesCount);
    private static Vector4 Vector4_Floor(Vector4 vec);
    [ExtensionAttribute]
public static float4 ToFloat4(Color color);
    [ExtensionAttribute]
public static float PackToFloat(Color color, int floatPackingPrecision);
    public static FloatPackingPrecision GetFloatPackingPrecision();
    public static void MarkCurrentSceneDirty();
}
public static class VLB.Version : object {
    public static int Current;
}
[ExecuteInEditMode]
[RequireComponent("VLB.VolumetricLightBeam")]
[HelpURLAttribute("http://saladgamer.com/vlb-doc/comp-dustparticles/")]
[DisallowMultipleComponent]
public class VLB.VolumetricDustParticles : MonoBehaviour {
    [RangeAttribute("0", "1")]
public float alpha;
    [RangeAttribute("0,0001", "0,1")]
public float size;
    public Direction direction;
    public float speed;
    public float density;
    [RangeAttribute("0", "1")]
public float spawnMaxDistance;
    public bool cullingEnabled;
    public float cullingMaxDistance;
    [CompilerGeneratedAttribute]
private bool <isCulled>k__BackingField;
    public static bool isFeatureSupported;
    private ParticleSystem m_Particles;
    private ParticleSystemRenderer m_Renderer;
    private static bool ms_NoMainCameraLogged;
    private static Camera ms_MainCamera;
    private VolumetricLightBeam m_Master;
    public bool isCulled { get; private set; }
    public bool particlesAreInstantiated { get; }
    public int particlesCurrentCount { get; }
    public int particlesMaxCount { get; }
    public Camera mainCamera { get; }
    private static VolumetricDustParticles();
    [CompilerGeneratedAttribute]
public bool get_isCulled();
    [CompilerGeneratedAttribute]
private void set_isCulled(bool value);
    public bool get_particlesAreInstantiated();
    public int get_particlesCurrentCount();
    public int get_particlesMaxCount();
    public Camera get_mainCamera();
    private void Start();
    private void InstantiateParticleSystem();
    private void OnEnable();
    private void SetActiveAndPlay();
    private void OnDisable();
    private void OnDestroy();
    private void Update();
    private void SetParticleProperties();
    private void UpdateCulling();
}
[HelpURLAttribute("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
[DisallowMultipleComponent]
[SelectionBaseAttribute]
[ExecuteInEditMode]
public class VLB.VolumetricLightBeam : MonoBehaviour {
    public bool colorFromLight;
    public ColorMode colorMode;
    [FormerlySerializedAsAttribute("colorValue")]
[ColorUsageAttribute("True", "True")]
public Color color;
    public Gradient colorGradient;
    [RangeAttribute("0", "1")]
public float alphaInside;
    [FormerlySerializedAsAttribute("alpha")]
[RangeAttribute("0", "1")]
public float alphaOutside;
    public BlendingMode blendingMode;
    [FormerlySerializedAsAttribute("angleFromLight")]
public bool spotAngleFromLight;
    [RangeAttribute("0,1", "179,9")]
public float spotAngle;
    [FormerlySerializedAsAttribute("radiusStart")]
public float coneRadiusStart;
    public MeshType geomMeshType;
    [FormerlySerializedAsAttribute("geomSides")]
public int geomCustomSides;
    public int geomCustomSegments;
    public bool geomCap;
    public bool fadeEndFromLight;
    public AttenuationEquation attenuationEquation;
    [RangeAttribute("0", "1")]
public float attenuationCustomBlending;
    public float fadeStart;
    public float fadeEnd;
    public float depthBlendDistance;
    public float cameraClippingDistance;
    [RangeAttribute("0", "1")]
public float glareFrontal;
    [RangeAttribute("0", "1")]
public float glareBehind;
    [ObsoleteAttribute("Use 'glareFrontal' instead")]
public float boostDistanceInside;
    [ObsoleteAttribute("This property has been merged with 'fresnelPow'")]
public float fresnelPowInside;
    [FormerlySerializedAsAttribute("fresnelPowOutside")]
public float fresnelPow;
    public bool noiseEnabled;
    [RangeAttribute("0", "1")]
public float noiseIntensity;
    public bool noiseScaleUseGlobal;
    [RangeAttribute("0,01", "2")]
public float noiseScaleLocal;
    public bool noiseVelocityUseGlobal;
    public Vector3 noiseVelocityLocal;
    private Plane m_PlaneWS;
    [SerializeField]
private int pluginVersion;
    [FormerlySerializedAsAttribute("trackChangesDuringPlaytime")]
[SerializeField]
private bool _TrackChangesDuringPlaytime;
    [SerializeField]
private int _SortingLayerID;
    [SerializeField]
private int _SortingOrder;
    private BeamGeometry m_BeamGeom;
    private Coroutine m_CoPlaytimeUpdate;
    private Light _CachedLight;
    public float coneAngle { get; }
    public float coneRadiusEnd { get; }
    public float coneVolume { get; }
    public float coneApexOffsetZ { get; }
    public int geomSides { get; public set; }
    public int geomSegments { get; public set; }
    public float attenuationLerpLinearQuad { get; }
    public int sortingLayerID { get; public set; }
    public string sortingLayerName { get; public set; }
    public int sortingOrder { get; public set; }
    public bool trackChangesDuringPlaytime { get; public set; }
    public bool isCurrentlyTrackingChanges { get; }
    public bool hasGeometry { get; }
    public Bounds bounds { get; }
    public int blendingModeAsInt { get; }
    public MeshRenderer Renderer { get; }
    public string meshStats { get; }
    public int meshVerticesCount { get; }
    public int meshTrianglesCount { get; }
    private Light lightSpotAttached { get; }
    public float get_coneAngle();
    public float get_coneRadiusEnd();
    public float get_coneVolume();
    public float get_coneApexOffsetZ();
    public int get_geomSides();
    public void set_geomSides(int value);
    public int get_geomSegments();
    public void set_geomSegments(int value);
    public float get_attenuationLerpLinearQuad();
    public int get_sortingLayerID();
    public void set_sortingLayerID(int value);
    public string get_sortingLayerName();
    public void set_sortingLayerName(string value);
    public int get_sortingOrder();
    public void set_sortingOrder(int value);
    public bool get_trackChangesDuringPlaytime();
    public void set_trackChangesDuringPlaytime(bool value);
    public bool get_isCurrentlyTrackingChanges();
    public bool get_hasGeometry();
    public Bounds get_bounds();
    public void SetClippingPlane(Plane planeWS);
    public void SetClippingPlaneOff();
    public bool IsColliderHiddenByDynamicOccluder(Collider collider);
    public int get_blendingModeAsInt();
    public MeshRenderer get_Renderer();
    public string get_meshStats();
    public int get_meshVerticesCount();
    public int get_meshTrianglesCount();
    private Light get_lightSpotAttached();
    public float GetInsideBeamFactor(Vector3 posWS);
    public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS);
    [ObsoleteAttribute("Use 'GenerateGeometry()' instead")]
public void Generate();
    public virtual void GenerateGeometry();
    public virtual void UpdateAfterManualPropertyChange();
    private void Start();
    private void OnEnable();
    private void OnDisable();
    private void StartPlaytimeUpdateIfNeeded();
    [IteratorStateMachineAttribute("VLB.VolumetricLightBeam/<CoPlaytimeUpdate>d__98")]
private IEnumerator CoPlaytimeUpdate();
    private void OnDestroy();
    private void DestroyBeam();
    private void AssignPropertiesFromSpotLight(Light lightSpot);
    private void ClampProperties();
    private void ValidateProperties();
    private void HandleBackwardCompatibility(int serializedVersion, int newVersion);
}
public class VoicemailDialog : MonoBehaviour {
    public GameObject RecordingRoot;
    public RustSlider RecordingProgress;
    public GameObject BrowsingRoot;
    public PhoneDialler ParentDialler;
    public GameObjectRef VoicemailEntry;
    public Transform VoicemailEntriesRoot;
    public GameObject NoVoicemailRoot;
    public GameObject NoCassetteRoot;
}
public class VoicemailEntry : MonoBehaviour {
    public GameObject PlayingRoot;
    public RustText DisplayName;
    public RustIcon PlayIcon;
    public RustSlider ProgressSlider;
}
public class VoiceProcessor : EntityComponentBase {
    public AudioSource mouthSpeaker;
    public PlayerVoiceSpeaker playerSpeaker;
    public float volumeMultiplier;
}
public class VTP : MonoBehaviour {
    public static Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit);
    public static Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit);
    public static void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength);
    public static void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength);
    public static void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow);
    public static void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow);
    private static void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents);
    private static Vector4[] calculateMeshTangents(Int32[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals);
    public static Color VertexColorLerp(Color colorA, Color colorB, float value);
}
public class WallpaperModelRenderer : MonoBehaviour {
    public Renderer rend;
    public Material baseMaterial;
    public bool autoLoad;
    public Material targetMaterial;
}
public class WallpaperPlanner : Planner {
    private static ItemDefinition _wallpaperItem;
    private static WallpaperSettings _settings;
    public static ItemDefinition WallpaperItemDef { get; }
    public static WallpaperSettings Settings { get; }
    public bool isTypeDeployable { get; }
    public static ItemDefinition get_WallpaperItemDef();
    public static WallpaperSettings get_Settings();
    public virtual bool get_isTypeDeployable();
    public virtual Deployable GetDeployable(NetworkableId entityId);
    public virtual BaseEntity DoBuild(Target target, Construction component);
}
[CreateAssetMenuAttribute]
public class WallpaperSettings : BaseScriptableObject {
    public GameObjectRef[] WallpaperPrefabs;
    public BuildingBlock[] BuildingBlocks;
    public GameObjectRef GetWallpaperPrefab(BuildingBlock buildingBlock);
    public Construction GetConstruction(BuildingBlock buildingBlock);
    public Deployable GetDeployable(BuildingBlock buildingBlock);
}
public class WantedPoster : DecayEntity {
    public UInt32 imageCrc;
    public ulong playerId;
    public string playerName;
    public MeshRenderer PhotoImage;
    public RustText WantedName;
    public GameObjectRef AssignDialog;
    public static Flags HasTarget;
    public EffectMode EffectMode;
    [CompilerGeneratedAttribute]
private List`1<ulong> <EditingHistory>k__BackingField;
    public UInt32[] GetContentCRCs { get; }
    public UGCType ContentType { get; }
    public List`1<ulong> EditingHistory { get; }
    public BaseNetworkable UgcEntity { get; }
    public Vector2i TextureSize { get; }
    public int TextureCount { get; }
    public NetworkableId NetworkID { get; }
    public Type FileType { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    [RPC_Server]
[CallsPerSecond("5")]
[IsVisible("3")]
private void UpdatePoster(RPCMessage msg);
    [IsVisible("3")]
[CallsPerSecond("5")]
[RPC_Server]
private void ClearPlayer(RPCMessage msg);
    public sealed virtual void SetTextureCRCs(UInt32[] crcs);
    public sealed virtual UInt32[] get_GetContentCRCs();
    public sealed virtual void ClearContent();
    public sealed virtual UGCType get_ContentType();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ulong> get_EditingHistory();
    public sealed virtual BaseNetworkable get_UgcEntity();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public sealed virtual bool CanUpdateSign(BasePlayer player);
    public sealed virtual Vector2i get_TextureSize();
    public sealed virtual int get_TextureCount();
    public sealed virtual UInt32[] GetTextureCRCs();
    public sealed virtual NetworkableId get_NetworkID();
    public sealed virtual Type get_FileType();
}
public class WaterBall : BaseEntity {
    public ItemDefinition liquidType;
    public int waterAmount;
    public GameObjectRef waterExplosion;
    public Collider waterCollider;
    public Rigidbody myRigidBody;
    public virtual void ServerInit();
    public void Extinguish();
    public void FixedUpdate();
    public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount);
    private void OnCollisionEnter(Collision collision);
}
public class WaterBaseNavGenTest : MonoBehaviour {
    private IEnumerator co;
    [ContextMenu("Nav Gen")]
public void NavGen();
}
[ExecuteInEditMode]
public class WaterBody : MonoBehaviour {
    public WaterBodyType Type;
    public Renderer Renderer;
    public Collider[] Triggers;
    public bool IsOcean;
    [CompilerGeneratedAttribute]
private Transform <Transform>k__BackingField;
    public FishingTag FishingType;
    public Transform Transform { get; private set; }
    [CompilerGeneratedAttribute]
private void set_Transform(Transform value);
    [CompilerGeneratedAttribute]
public Transform get_Transform();
    private void Awake();
    private void OnEnable();
    private void OnDisable();
    public void OnOceanLevelChanged(float newLevel);
    public float MinWaterLevel();
    public float SqrDistance(Vector3 point);
    public int GetTopologyMask();
}
public enum WaterBodyType : Enum {
    public int value__;
    public static WaterBodyType Ocean;
    public static WaterBodyType River;
    public static WaterBodyType Lake;
    public static WaterBodyType Pool;
    public static WaterBodyType Moonpool;
    public static WaterBodyType Radioactive;
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.Camera")]
[RequireComponent("CommandBufferManager")]
[RequireComponent("PostOpaqueDepth")]
public class WaterCamera : MonoBehaviour {
}
public class WaterCatcher : LiquidContainer {
    [HeaderAttribute("Water Catcher")]
public ItemDefinition itemToCreate;
    public WaterCatcherCollectRate collectionRates;
    public float maxItemToCreate;
    [HeaderAttribute("Outside Test")]
public Vector3 rainTestPosition;
    public float rainTestSize;
    public static float collectInterval;
    public virtual void ServerInit();
    public void CollectWater();
    public bool IsFull();
    public bool TestIsOutside();
    public void AddResource(int iAmount);
    private IOEntity CheckPushLiquid(IOEntity connected, int amount, IOEntity fromSource, int depth);
}
[CreateAssetMenuAttribute]
public class WaterCatcherCollectRate : ScriptableObject {
    [TooltipAttribute("Base collection rate that happens at all times")]
public float baseRate;
    [TooltipAttribute("Additional rate during rain")]
public float rainRate;
    [TooltipAttribute("Additional rate during snow")]
public float snowRate;
    [TooltipAttribute("Additional rate during fog. Fog water is also collected indoors")]
public float fogRate;
}
public class WaterCheck : PrefabAttribute {
    public bool Rotate;
    protected void OnDrawGizmosSelected();
    public bool Check(Vector3 pos);
    protected virtual Type GetIndexedType();
}
[ExtensionAttribute]
public static class WaterCheckEx : object {
    [ExtensionAttribute]
public static bool ApplyWaterChecks(Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale);
}
public class WaterCheckGenerator : MonoBehaviour {
    public float PlacementRadius;
    public float PlacementDistance;
    public bool CheckRotate;
}
public class WaterCollision : MonoBehaviour {
    private ListDictionary`2<Collider, List`1<Collider>> ignoredColliders;
    private HashSet`1<Collider> waterColliders;
    private WaterVisibilityGrid visibilityGrid;
    public WaterVisibilityGrid VisibilityGrid { get; }
    public WaterVisibilityGrid get_VisibilityGrid();
    private void Awake();
    public void Clear();
    public void Reset(Collider collider);
    public bool GetIgnore(Vector3 pos, float radius);
    public bool GetIgnore(Bounds bounds);
    public bool GetIgnore(Vector3 start, Vector3 end, float radius);
    public bool GetIgnore(RaycastHit hit);
    public bool GetIgnore(Collider collider);
    public void SetIgnore(Collider collider, Collider trigger, bool ignore);
    protected void LateUpdate();
}
[ExecuteInEditMode]
public class WaterCullingVolume : MonoBehaviour {
    public bool isDynamic;
}
public class WaterDepthMask : MonoBehaviour {
}
public class WaterDepthTester : MonoBehaviour {
    private void Update();
}
public class WaterInflatable : BaseMountable {
    public Transform centerOfMass;
    public float forwardPushForce;
    public float rearPushForce;
    public float rotationForce;
    public float maxSpeed;
    public float maxPaddleFrequency;
    public SoundDefinition paddleSfx;
    public SoundDefinition smallPlayerMovementSound;
    public SoundDefinition largePlayerMovementSound;
    public BlendedSoundLoops waterLoops;
    public float waterSoundSpeedDivisor;
    public float additiveDownhillVelocity;
    public GameObjectRef handSplashForwardEffect;
    public GameObjectRef handSplashBackEffect;
    public GameObjectRef footSplashEffect;
    public float animationLerpSpeed;
    public Transform smoothedEyePosition;
    public float smoothedEyeSpeed;
    public Buoyancy buoyancy;
    public bool driftTowardsIsland;
    public GameObjectRef mountEffect;
    [RangeAttribute("0", "1")]
public float handSplashOffset;
    public float velocitySplashMultiplier;
    public Vector3 modifyEyeOffset;
    [RangeAttribute("0", "1")]
public float inheritVelocityMultiplier;
    private TimeSince lastPaddle;
    public ParticleSystem[] movingParticleSystems;
    public float movingParticlesThreshold;
    public Transform headSpaceCheckPosition;
    public float headSpaceCheckRadius;
    private TimeSince landFacingCheck;
    private bool isFacingLand;
    private float landPushAcceleration;
    private TimeSince inPoolCheck;
    private bool isInPool;
    private Vector3 lastPos;
    private Vector3 lastClipCheckPosition;
    private bool forceClippingCheck;
    private bool prevSleeping;
    public bool IsSummerDlcVehicle { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem);
    public virtual void VehicleFixedUpdate();
    public virtual void OnPlayerMounted();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    private void PaddleTurn(PaddleDirection direction);
    public virtual float WaterFactorForPlayer(BasePlayer player);
    public virtual void OnCollision(Collision collision, BaseEntity hitEntity);
    private bool IsOutOfWaterServer();
    public sealed virtual void OnPoolDestroyed();
    public sealed virtual void WakeUp();
    public virtual bool get_IsSummerDlcVehicle();
    public sealed virtual void OnObjects(TriggerNotify trigger);
    public sealed virtual void OnEmpty();
}
[ExecuteInEditMode]
public class WaterInteraction : MonoBehaviour {
    [SerializeField]
private Texture2D texture;
    [RangeAttribute("0", "1")]
public float Displacement;
    [RangeAttribute("0", "1")]
public float Disturbance;
}
public static class WaterLevel : object {
    public static float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity);
    public static float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity);
    public static bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static ValueTuple`2<float, float> GetWaterAndTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static float GetWaterOrTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static float GetWaterSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static Vector3 GetWaterNormal(Vector3 pos);
    public static WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity);
    public static WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity);
    public static WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity);
    public static WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity);
    public static WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity);
    private static float GetWaterLevel(Vector3 pos, bool waves);
    private static WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity);
    private static WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity);
    private static WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity);
}
public class WaterOverlay : MonoBehaviour {
    public PostProcessVolume postProcessVolume;
    public PostProcessVolume blurPostProcessVolume;
    public EffectParams defaultParams;
    public EffectParams adminParams;
    public EffectParams gogglesParams;
    public EffectParams submarineParams;
    public EffectParams underwaterLabParams;
    public EffectParams cinematicParams;
    public Material[] UnderwaterFogMaterials;
}
public class WaterPump : LiquidContainer {
    public Transform WaterResourceLocation;
    public float PumpInterval;
    public int AmountPerPump;
    public int PowerConsumption;
    public bool IsGravitySource { get; }
    public virtual int ConsumptionAmount();
    public void CreateWater();
    public virtual void OnFlagsChanged(Flags old, Flags next);
    public virtual int GetPassthroughAmount(int outputSlot);
    public bool IsFull();
    public virtual bool get_IsGravitySource();
}
public class WaterPurifier : LiquidContainer {
    public GameObjectRef storagePrefab;
    public Transform storagePrefabAnchor;
    public ItemDefinition freshWater;
    public int waterToProcessPerMinute;
    public int freshWaterRatio;
    public bool stopWhenOutputFull;
    public LiquidContainer waterStorage;
    public float dirtyWaterProcssed;
    public float pendingFreshWater;
    public virtual void ServerInit();
    public virtual void PostServerLoad();
    internal virtual void DoServerDestroy();
    protected virtual void SpawnStorageEnt(bool load);
    internal virtual void OnParentRemoved();
    public virtual void OnKilled(HitInfo info);
    public void ParentTemperatureUpdate(float temp);
    public void CheckCoolDown();
    public bool HasDirtyWater();
    public void Cook(float timeCooked);
    protected void ConvertWater(float timeCooked);
    public virtual void Load(LoadInfo info);
    public virtual bool CanPickup(BasePlayer player);
    public bool IsBoiling();
}
public enum WaterQuality : Enum {
    public int value__;
    public static WaterQuality Low;
    public static WaterQuality Medium;
    public static WaterQuality High;
}
public class WaterResource : object {
    public static ItemDefinition SV_GetAtPoint(Vector3 pos);
    public static WaterBody FindWaterBodyAtPos(Vector3 pos);
    public static bool IsRadioactive(WaterBody body);
    public static bool IsRadioactive(Vector3 pos);
    public static bool IsFreshWater(Vector3 pos);
    public static ItemDefinition Merge(ItemDefinition first, ItemDefinition second);
}
[ExecuteInEditMode]
public class WaterSystem : MonoBehaviour {
    private static float oceanLevel;
    [CompilerGeneratedAttribute]
private static WaterSystem <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static WaterCollision <Collision>k__BackingField;
    [CompilerGeneratedAttribute]
private static WaterBody <Ocean>k__BackingField;
    [CompilerGeneratedAttribute]
private static ListHashSet`1<WaterCamera> <WaterCameras>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<WaterBody> <WaterBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private static HashSet`1<WaterDepthMask> <DepthMasks>k__BackingField;
    [CompilerGeneratedAttribute]
private static float <WaveTime>k__BackingField;
    [HeaderAttribute("Ocean Settings")]
public OceanSettings oceanSettings;
    public OceanSimulation oceanSimulation;
    public WaterQuality Quality;
    public Material oceanMaterial;
    public RenderingSettings Rendering;
    public int patchSize;
    public int patchCount;
    public float patchScale;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public static WaterSystem Instance { get; private set; }
    public static WaterCollision Collision { get; private set; }
    public static WaterBody Ocean { get; private set; }
    public static Material OceanMaterial { get; }
    public static ListHashSet`1<WaterCamera> WaterCameras { get; }
    public static HashSet`1<WaterBody> WaterBodies { get; }
    public static HashSet`1<WaterDepthMask> DepthMasks { get; }
    public static float WaveTime { get; private set; }
    public static float OceanLevel { get; public set; }
    public bool IsInitialized { get; private set; }
    public int Layer { get; }
    public int Reflections { get; }
    public float WindowDirection { get; }
    public Single[] OctaveScales { get; }
    private static WaterSystem();
    [CompilerGeneratedAttribute]
public static WaterSystem get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(WaterSystem value);
    [CompilerGeneratedAttribute]
public static WaterCollision get_Collision();
    [CompilerGeneratedAttribute]
private static void set_Collision(WaterCollision value);
    [CompilerGeneratedAttribute]
public static WaterBody get_Ocean();
    [CompilerGeneratedAttribute]
private static void set_Ocean(WaterBody value);
    public static Material get_OceanMaterial();
    [CompilerGeneratedAttribute]
public static ListHashSet`1<WaterCamera> get_WaterCameras();
    [CompilerGeneratedAttribute]
public static HashSet`1<WaterBody> get_WaterBodies();
    [CompilerGeneratedAttribute]
public static HashSet`1<WaterDepthMask> get_DepthMasks();
    [CompilerGeneratedAttribute]
public static float get_WaveTime();
    [CompilerGeneratedAttribute]
private static void set_WaveTime(float value);
    public static float get_OceanLevel();
    public static void set_OceanLevel(float value);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public int get_Layer();
    public int get_Reflections();
    public float get_WindowDirection();
    public Single[] get_OctaveScales();
    private void CheckInstance();
    private void Awake();
    private void OnEnable();
    private void OnDisable();
    private void Update();
    public static bool Trace(Ray ray, Vector3& position, float maxDist);
    public static bool Trace(Ray ray, Vector3& position, Vector3& normal, float maxDist);
    public static void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, Single[] shore, Single[] terrainHeight, Single[] waterHeight);
    public static void GetHeightArray(Vector2[] pos, Vector2[] posUV, Single[] shore, Single[] terrainHeight, Single[] waterHeight);
    public static void RegisterBody(WaterBody body);
    public static void UnregisterBody(WaterBody body);
    private static void UpdateOceanLevel();
    private void UpdateOceanSimulation();
    public void Refresh();
    private void EditorInitialize();
    private void EditorShutdown();
}
public static class WaterTypes : object {
    private static ItemDefinition _waterItemDef;
    private static ItemDefinition _saltWaterItemDef;
    private static ItemDefinition _radioactiveWaterItemDef;
    public static ItemDefinition WaterItemDef { get; }
    public static ItemDefinition SaltWaterItemDef { get; }
    public static ItemDefinition RadioactiveWaterItemDef { get; }
    public static ItemDefinition get_WaterItemDef();
    public static ItemDefinition get_SaltWaterItemDef();
    public static ItemDefinition get_RadioactiveWaterItemDef();
}
public class WaterVisibilityGrid : object {
    private static int CellSize;
    private static int MaxWorldSizeXZ;
    private static float StaticBoundsInflation;
    private static ProfilerMarker p_QueryWorldPosition;
    private static ProfilerMarker p_QueryBounds;
    private RefCountedSpatialArray _staticTriggerGrid;
    private int _cellXZDimensionCount;
    private Vector2 _gridCentre;
    private ListHashSet`1<WaterVisibilityTrigger> _dynamicListSet;
    private static WaterVisibilityGrid();
    public void Add(WaterVisibilityTrigger trigger);
    public void CheckIndices(Bounds bounds, List`1<int> toPopulate);
    public void Remove(WaterVisibilityTrigger trigger);
    private void AddStatic(WaterVisibilityTrigger trigger);
    private void RemoveStatic(WaterVisibilityTrigger trigger);
    private void AddDynamic(WaterVisibilityTrigger trigger);
    private void RemoveDynamic(WaterVisibilityTrigger trigger);
    public bool Check(Bounds bounds);
    public bool Check(Vector3 worldPosition, float radius);
    public bool Check(Vector3 start, Vector3 end, float radius);
    private Vector2i WorldPosToStaticGrid(Vector3 worldPosition);
    private int GridToStaticIndex(Vector2i gridPosition);
}
public class WaterVisibilityTrigger : EnvironmentVolumeTrigger {
    public bool togglePhysics;
    public bool toggleVisuals;
    public bool IsDynamic;
    private long enteredTick;
    private static long ticks;
    private static SortedList`2<long, WaterVisibilityTrigger> tracker;
    private static WaterVisibilityTrigger();
    public static void Reset();
    protected virtual void OnVolumeTriggerUpdate();
    private void OnDisable();
    protected void OnDestroy();
    private void ToggleVisibility();
    private void ResetVisibility();
    private void ToggleCollision(Collider other);
    private void ResetCollision(Collider other);
    protected void OnTriggerEnter(Collider other);
    protected void OnTriggerExit(Collider other);
}
public class WaterVolume : TriggerBase {
    public Bounds WaterBounds;
    private OBB cachedBounds;
    private Transform cachedTransform;
    public Transform[] cutOffPlanes;
    [TooltipAttribute("Allows filling bota bags, jugs, etc. Don't turn this on if the player is responsible for filling this water volume as that will allow water duplication")]
public bool naturalSource;
    public bool waterEnabled;
    private void OnEnable();
    private Plane GetWaterPlane();
    public bool Test(Vector3 pos, WaterInfo& info);
    public bool Test(Bounds bounds, WaterInfo& info);
    public bool Test(Vector3 start, Vector3 end, float radius, WaterInfo& info);
    private bool CheckCutOffPlanes(Vector3 pos, Single& bottomCutY);
    private void UpdateCachedTransform();
    internal virtual GameObject InterestedInObject(GameObject obj);
}
public class WaterWell : LiquidContainer {
    public Animator animator;
    private static Flags Pumping;
    private static Flags WaterFlow;
    public float caloriesPerPump;
    public float pressurePerPump;
    public float pressureForProduction;
    public float currentPressure;
    public int waterPerPump;
    public GameObject waterLevelObj;
    public float waterLevelObjFullOffset;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ServerInit();
    [RPC_Server]
[MaxDistance("3")]
public void RPC_Pump(RPCMessage msg);
    public void StopPump();
    public virtual void OnItemAddedOrRemoved(Item item, bool added);
    public void Produce();
    public void ScheduleTapOff();
    private void TapOff();
    public void ReducePressure();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public float GetWaterAmount();
}
public class WaypointRace : BaseEntity {
    public float WaypointRadius;
    public RaceWaypointVisual TargetWaypointVisual;
    public RaceWaypointVisual NextWaypointVisual;
    private List`1<Vector3> racePoints;
    private EntityRef`1<BaseVehicle> racingVehicle;
    private int currentWaypoint;
    public static Phrase stageNotifyPhrase;
    public static Phrase raceCompletePhrase;
    private PendingRaceResults raceResults;
    private TimeSince startTime;
    [ServerVar]
public static float raceTimeout;
    private static WaypointRace();
    [ServerVar]
public static void startRace(Arg arg);
    private void Setup(List`1<Transform> waypoints, BaseVehicle participant, PendingRaceResults results);
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    private void Update();
}
public class WaypointRaceTarget : MonoBehaviour {
    private static Dictionary`2<string, Transform> allPoints;
    private static WaypointRaceTarget();
    private void Start();
    public static void GetWaypoints(string filter, List`1<Transform> found, int max);
}
public class WeakpointProperties : PrefabAttribute {
    public bool BlockWhenRoofAttached;
    protected virtual Type GetIndexedType();
}
public class WeaponRack : StorageContainer {
    [HeaderAttribute("Text")]
public Phrase textLoadAmmos;
    public RackType Type;
    public float GridCellSize;
    public bool SetGridCellSizeFromCollision;
    public int Capacity;
    public bool UseColliders;
    public int GridCellCountX;
    public int GridCellCountY;
    public BoxCollider Collision;
    public Transform Anchor;
    public Transform SmallPegPrefab;
    public Transform LargePegPrefab;
    [HeaderAttribute("Lights")]
public GameObjectRef LightPrefab;
    public Transform[] LightPoints;
    public WeaponRackSlot[] gridSlots;
    private WeaponRackSlot[] gridCellSlotReferences;
    public int ForceItemRotation;
    public bool CreatePegs;
    [HeaderAttribute("Custom Rack")]
public SpecialRackType CustomRackType;
    public Transform CustomCenter;
    private static HashSet`1<int> usedSlots;
    private static WeaponRack();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void InitShared();
    private void ClearGridCellContentsRefs();
    private void SetupSlot(WeaponRackSlot slot);
    private void ClearSlot(WeaponRackSlot slot);
    public void SetGridCellContents(WeaponRackSlot slot, bool clear);
    public virtual void Load(LoadInfo info);
    public WeaponRackSlot GetWeaponAtIndex(int gridIndex);
    public Vector2Int GetXYForIndex(int index);
    private Vector2Int GetWeaponSize(WorldModelRackMountConfig config, int rotation);
    private Vector2Int GetWeaponStart(Vector2Int targetXY, Vector2Int size, bool clamp);
    public bool CanAcceptWeaponType(WorldModelRackMountConfig weaponConfig);
    public int GetBestPlacementCellIndex(Vector2Int targetXY, WorldModelRackMountConfig config, int rotation, WeaponRackSlot ignoreSlot);
    public int GetGridIndexAtPosition(Vector3 pos);
    private bool GridCellsFree(WorldModelRackMountConfig config, int gridIndex, int rotation, WeaponRackSlot ignoreGridSlot);
    private int GetGridCellIndex(int x, int y);
    private bool GridCellFree(int index, WeaponRackSlot ignoreSlot);
    private static bool ItemIsRackMountable(Item item);
    public virtual void ServerInit();
    private void SpawnLightSubEntities();
    private bool InventoryItemFilter(Item item, int targetSlot);
    public virtual void Save(SaveInfo info);
    [RPC_Server]
[IsVisible("3")]
[MaxDistance("2")]
private void ReqSwapWeapon(RPCMessage msg);
    private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation);
    [RPC_Server]
[IsVisible("3")]
[MaxDistance("2")]
private void ReqTakeWeapon(RPCMessage msg);
    private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex, bool tryHold, bool sendUpdate);
    [RPC_Server]
[IsVisible("3")]
[MaxDistance("2")]
private void ReqTakeAll(RPCMessage msg);
    private void GivePlayerAllWeapons(BasePlayer player, int mountSlotIndex);
    [RPC_Server]
[IsVisible("3")]
[MaxDistance("2")]
private void ReqUnloadWeapon(RPCMessage msg);
    private void UnloadWeapon(BasePlayer player, int mountSlotIndex);
    [MaxDistance("2")]
[RPC_Server]
[IsVisible("3")]
private void ReqMountWeapon(RPCMessage msg);
    private void MountWeapon(BasePlayer player, int gridCellIndex, int rotation);
    private void SetSlotItem(WeaponRackSlot slot, Item item, int gridCellIndex, int rotation);
    private void SetSlotAmmoDetails(WeaponRackSlot slot, Item item);
    private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate);
    private void PlayMountSound(int itemID);
    [RPC_Server]
private void LoadWeaponAmmo(RPCMessage msg);
}
public class WeaponRackBatchAutoSet : MonoBehaviour {
    public Transform Anchor;
    public Object MountConfigScript;
}
public static class WeaponRackGhost : object {
}
public class WeaponRackSlot : object {
    [CompilerGeneratedAttribute]
private bool <Used>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemDefinition <ItemDef>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClientItemID>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ClientItemSkinID>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemDefinition <AmmoItemDef>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AmmoItemID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AmmoCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AmmoMax>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InventoryIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GridSlotIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rotation>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ReloadTime>k__BackingField;
    [InspectorFlagsAttribute]
public AmmoTypes AmmoTypes;
    public bool Used { get; private set; }
    public ItemDefinition ItemDef { get; private set; }
    public int ClientItemID { get; private set; }
    public ulong ClientItemSkinID { get; private set; }
    public ItemDefinition AmmoItemDef { get; private set; }
    public int AmmoItemID { get; private set; }
    public int AmmoCount { get; private set; }
    public int AmmoMax { get; private set; }
    public float Condition { get; private set; }
    public int InventoryIndex { get; private set; }
    public int GridSlotIndex { get; private set; }
    public int Rotation { get; private set; }
    public float ReloadTime { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Used();
    [CompilerGeneratedAttribute]
private void set_Used(bool value);
    [CompilerGeneratedAttribute]
public ItemDefinition get_ItemDef();
    [CompilerGeneratedAttribute]
private void set_ItemDef(ItemDefinition value);
    [CompilerGeneratedAttribute]
public int get_ClientItemID();
    [CompilerGeneratedAttribute]
private void set_ClientItemID(int value);
    [CompilerGeneratedAttribute]
public ulong get_ClientItemSkinID();
    [CompilerGeneratedAttribute]
private void set_ClientItemSkinID(ulong value);
    [CompilerGeneratedAttribute]
public ItemDefinition get_AmmoItemDef();
    [CompilerGeneratedAttribute]
private void set_AmmoItemDef(ItemDefinition value);
    [CompilerGeneratedAttribute]
public int get_AmmoItemID();
    [CompilerGeneratedAttribute]
private void set_AmmoItemID(int value);
    [CompilerGeneratedAttribute]
public int get_AmmoCount();
    [CompilerGeneratedAttribute]
private void set_AmmoCount(int value);
    [CompilerGeneratedAttribute]
public int get_AmmoMax();
    [CompilerGeneratedAttribute]
private void set_AmmoMax(int value);
    [CompilerGeneratedAttribute]
public float get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(float value);
    [CompilerGeneratedAttribute]
public int get_InventoryIndex();
    [CompilerGeneratedAttribute]
private void set_InventoryIndex(int value);
    [CompilerGeneratedAttribute]
public int get_GridSlotIndex();
    [CompilerGeneratedAttribute]
private void set_GridSlotIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Rotation();
    [CompilerGeneratedAttribute]
private void set_Rotation(int value);
    [CompilerGeneratedAttribute]
public float get_ReloadTime();
    [CompilerGeneratedAttribute]
private void set_ReloadTime(float value);
    public void SetUsed(bool flag);
    public WeaponRackItem SaveToProto(Item item, WeaponRackItem proto);
    public void InitFromProto(WeaponRackItem item);
    public void SetItem(Item item, ItemDefinition updatedItemDef, int gridCellIndex, int rotation);
    public void SetAmmoDetails(Item item);
    private void ClearAmmoDetails();
    public bool CanBeReloadedAtWeaponRack();
}
public class Wearable : MonoBehaviour {
    [InspectorFlagsAttribute]
public RemoveSkin removeSkin;
    [InspectorFlagsAttribute]
public RemoveSkin removeSkinFirstPerson;
    [InspectorFlagsAttribute]
public RemoveHair removeHair;
    [InspectorFlagsAttribute]
public DeformHair deformHair;
    [InspectorFlagsAttribute]
public OccupationSlots occupationUnder;
    [InspectorFlagsAttribute]
public OccupationSlots occupationOver;
    public bool IsBackpack;
    public bool HideInPlayerPreview;
    public bool showCensorshipCube;
    public bool showCensorshipCubeBreasts;
    public bool forceHideCensorshipBreasts;
    public string followBone;
    public bool disableRigStripping;
    public bool overrideDownLimit;
    public float downLimit;
    [RangeAttribute("0", "1")]
public float handcuffsSize;
    [HideInInspector]
public PlayerModelHair playerModelHair;
    [HideInInspector]
public PlayerModelHairCap playerModelHairCap;
    [HideInInspector]
public WearableReplacementByRace wearableReplacementByRace;
    [HideInInspector]
public WearableShadowLod wearableShadowLod;
    [HideInInspector]
public List`1<Renderer> renderers;
    [HideInInspector]
public List`1<PlayerModelSkin> playerModelSkins;
    [HideInInspector]
public List`1<BoneRetarget> boneRetargets;
    [HideInInspector]
public List`1<SkinnedMeshRenderer> skinnedRenderers;
    [HideInInspector]
public List`1<SkeletonSkin> skeletonSkins;
    [HideInInspector]
public List`1<ComponentInfo> componentInfos;
    [HideInInspector]
public List`1<WearableNotify> notifies;
    public bool HideInEyesView;
    [HeaderAttribute("First Person Legs")]
[TooltipAttribute("If this is true, we'll hide this item in the first person view. Usually done for items that you definitely won't see in first person view, like facemasks and hats.")]
public bool HideInFirstPerson;
    [TooltipAttribute("Use this if the clothing item clips into the player view. It'll push the chest legs model backwards.")]
[RangeAttribute("0", "5")]
public float ExtraLeanBack;
    [TooltipAttribute("Enable this to check for BoneRetargets which need to be preserved in first person view")]
public bool PreserveBones;
    public bool LegFade;
    public Renderer[] RenderersLod0;
    public Renderer[] RenderersLod1;
    public Renderer[] RenderersLod2;
    public Renderer[] RenderersLod3;
    public Renderer[] RenderersLod4;
    public Renderer[] SkipInFirstPersonLegs;
    private static LOD[] emptyLOD;
    public PartRandomizer[] randomParts;
    private static Wearable();
    public sealed virtual void OnItemSetup(Item item);
    public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling);
    public void CacheComponents();
    public void StripRig(IPrefabProcessor preProcess, SkinnedMeshRenderer skinnedMeshRenderer);
    public void SetupRendererCache(IPrefabProcessor preProcess);
}
public class WearableEyeViewAdjustment : MonoBehaviour {
}
public class WearableEyeViewAdjustment_Submesh : WearableEyeViewAdjustment {
    public int TargetSubmesh;
    public Material HideMaterial;
    public Material DefaultMaterial;
}
public class WearableFadeToggle : MonoBehaviour {
}
[RequireComponent("ItemIcon")]
public class WearableFeedbackItemIcon : FacepunchBehaviour {
}
[RequireComponent("Wearable")]
public class WearableHairCap : MonoBehaviour {
    public HairType Type;
    [ColorUsageAttribute("False", "True")]
public Color BaseColor;
    public Texture Mask;
    private static MaterialPropertyBlock block;
    private static int _HairBaseColorUV1;
    private static int _HairBaseColorUV2;
    private static int _HairPackedMapUV1;
    private static int _HairPackedMapUV2;
    private static WearableHairCap();
    public void ApplyHairCap(MaterialPropertyBlock block);
}
public class WearableHolsterOffset : MonoBehaviour {
    public offsetInfo[] Offsets;
}
public class WearableNotify : MonoBehaviour {
}
public class WearableNotifyHasBackpack : WearableNotify {
    public GameObject[] ObjectsToHide;
}
public class WearableNotifyLifestate : WearableNotify {
    public LifeState TargetState;
    public UnityEvent OnTargetState;
    public UnityEvent OnTargetStateFailed;
}
public class WearableNotifyTrophyMounted : WearableNotify {
    public UnityEvent OnMounted;
    public Renderer[] EmissionToggles;
}
public class WearableReplacementByRace : MonoBehaviour {
    public GameObjectRef[] replacements;
    public GameObjectRef GetReplacement(int meshIndex);
}
public class WearableShadowLod : MonoBehaviour {
    public Renderer[] DisableShadows;
}
public abstract class WeatherEffect : BaseMonoBehaviour {
    public ParticleSystem[] emitOnStart;
    public ParticleSystem[] emitOnStop;
    public ParticleSystem[] emitOnLoop;
}
public abstract class WeatherEffectSting : BaseMonoBehaviour {
    public float frequency;
    public float variance;
    public GameObjectRef[] effects;
}
[CreateAssetMenuAttribute]
public class WeatherPreset : ScriptableObject {
    public WeatherPresetType Type;
    public float Wind;
    public float Rain;
    public float Thunder;
    public float Rainbow;
    public TOD_AtmosphereParameters Atmosphere;
    public TOD_CloudParameters Clouds;
    [RangeAttribute("0", "1")]
public float AmbientLightMultiplier;
    [RangeAttribute("0", "1")]
public float DirectionalLightMultiplier;
    [RangeAttribute("0", "1")]
public float ReflectionMultiplier;
    [RangeAttribute("0", "1")]
public float SunMeshBrightnessMultiplier;
    [RangeAttribute("0", "1")]
public float MoonMeshBrightnessMultiplier;
    [RangeAttribute("0", "10")]
public float OceanScale;
    public void Apply(TOD_Sky sky);
    public void Copy(TOD_Sky sky);
    public void Reset();
    public void Set(WeatherPreset other);
    public virtual string ToString();
    public void Fade(WeatherPreset a, WeatherPreset b, float t);
    public void Override(WeatherPreset other);
    public void Max(WeatherPreset other);
    public void Min(WeatherPreset other);
    private void Fade(Single& x, float a, float b, float t);
    private void Override(Single& x, float other);
    private void Max(Single& x, float other);
    private void Min(Single& x, float other);
}
public enum WeatherPresetType : Enum {
    public int value__;
    public static WeatherPresetType Clear;
    public static WeatherPresetType Overcast;
    public static WeatherPresetType Storm;
    public static WeatherPresetType Dust;
    public static WeatherPresetType Fog;
    public static WeatherPresetType Rain;
    public static WeatherPresetType Cinematic;
}
public class WeightedAnimationRandomiser : StateMachineBehaviour {
    public int LoopRangeMin;
    public int LoopRangeMax;
    public float NormalizedTransitionDuration;
    public IdleChance[] IdleTransitions;
    public bool AllowRepeats;
}
public class WeightedAudioClip : object {
    public AudioClip audioClip;
    public int weight;
}
public class WheelSwitch : IOEntity {
    public Transform wheelObj;
    public float rotateSpeed;
    public Flags BeingRotated;
    public Flags RotatingLeft;
    public Flags RotatingRight;
    public float rotateProgress;
    public Animator animator;
    public float kineticEnergyPerSec;
    private BasePlayer rotatorPlayer;
    private float progressTickRate;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetIOState();
    [RPC_Server]
[IsVisible("3")]
public void BeginRotate(RPCMessage msg);
    public void CancelPlayerRotation();
    public void RotateProgress();
    public void SetRotateProgress(float newValue);
    public void StoppedRotatingCheck();
    [RPC_Server]
[IsVisible("3")]
public void CancelRotate(RPCMessage msg);
    public void Powered();
    public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot);
    public bool IsBeingRotated();
    public virtual void Load(LoadInfo info);
    public virtual void Save(SaveInfo info);
}
public class WhitelistLootContainer : LootContainer {
    public static Phrase CantLootToast;
    public List`1<ulong> whitelist;
    private static WhitelistLootContainer();
    public virtual void Save(SaveInfo info);
    public virtual void Load(LoadInfo info);
    public void MissionSetupPlayer(BasePlayer player);
    public void AddToWhitelist(ulong userid);
    public void RemoveFromWhitelist(ulong userid);
    public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks);
}
[PostProcessAttribute("WiggleRenderer", "2", "Custom/Wiggle", "True")]
public class Wiggle : PostProcessEffectSettings {
    public FloatParameter speed;
    public FloatParameter scale;
}
public class WiggleRenderer : PostProcessEffectRenderer`1<Wiggle> {
    private int timerProperty;
    private int scaleProperty;
    private Shader wiggleShader;
    private float timer;
    public virtual void Init();
    public virtual void Render(PostProcessRenderContext context);
}
public class WildlifeTrap : StorageContainer {
    public float tickRate;
    public GameObjectRef trappedEffect;
    public float trappedEffectRepeatRate;
    public float trapSuccessRate;
    public List`1<ItemDefinition> ignoreBait;
    public List`1<WildlifeWeight> targetWildlife;
    public virtual void ResetState();
    public void SetTrapActive(bool trapOn);
    private int CalculateBaitCalories(Item bait);
    public int GetBaitCalories();
    public void DestroyRandomFoodItem();
    public void UseBaitCalories(int numToUse);
    public int GetItemCalories(Item item);
    public virtual void TrapThink();
    public void TrapWildlife(TrappableWildlife trapped);
    protected void OnTrappedWildlife(bool setFlag);
    public void ClearTrap();
    public virtual bool HasBait();
    public virtual void PlayerStoppedLooting(BasePlayer player);
    public virtual bool OnStartBeingLooted(BasePlayer baseEntity);
    public TrappableWildlife GetRandomWildlife();
    public virtual void ServerInit();
    protected virtual bool CanAcceptItem(Item item, int slot);
    public bool HasCatch();
    public bool IsTrapActive();
}
public class Windows.ConsoleInput : object {
    [CompilerGeneratedAttribute]
private Action`1<string> OnInputText;
    public string inputString;
    public String[] statusText;
    internal float nextUpdate;
    public bool valid { get; }
    public int lineWidth { get; }
    [CompilerGeneratedAttribute]
public void add_OnInputText(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnInputText(Action`1<string> value);
    public bool get_valid();
    public int get_lineWidth();
    public void ClearLine(int numLines);
    public void RedrawInputLine();
    internal void OnBackspace();
    internal void OnEscape();
    internal void OnEnter();
    public void Update();
}
[SuppressUnmanagedCodeSecurityAttribute]
public class Windows.ConsoleWindow : object {
    private TextWriter oldOutput;
    private static int STD_INPUT_HANDLE;
    private static int STD_OUTPUT_HANDLE;
    public void Initialize();
    public void Shutdown();
    public void SetTitle(string strName);
    private static bool AttachConsole(UInt32 dwProcessId);
    private static bool AllocConsole();
    private static bool FreeConsole();
    private static IntPtr GetStdHandle(int nStdHandle);
    private static bool SetConsoleTitleA(string lpConsoleTitle);
}
public static class WindowsAffinityShim : object {
    public static bool SetProcessAffinityMask(IntPtr process, IntPtr mask);
    public static bool SetPriorityClass(IntPtr process, UInt32 mask);
}
[RequireComponent("UnityEngine.WindZone")]
[ExecuteInEditMode]
public class WindZoneEx : MonoBehaviour {
}
[ExecuteInEditMode]
[RequireComponent("UnityEngine.WindZone")]
public class WindZoneExManager : MonoBehaviour {
    public float maxAccumMain;
    public float maxAccumTurbulence;
    public float globalMainScale;
    public float globalTurbulenceScale;
    public Transform testPosition;
}
public class WipeTimer : BaseEntity {
    [ServerVar]
public static int wipeDayOfWeek;
    [ServerVar]
public static float wipeHourOfDay;
    [ServerVar]
public static string wipeTimezone;
    [ServerVar]
public static long wipeUnixTimestampOverride;
    [ServerVar]
public static string wipeCronOverride;
    public bool useWipeDayOverride;
    public DayOfWeek wipeDayOfWeekOverride;
    public WipeFrequency wipeFrequency;
    [ServerVar]
public static int daysToAddTest;
    [ServerVar]
public static float hoursToAddTest;
    public static WipeTimer serverinstance;
    public static WipeTimer clientinstance;
    private string oldTags;
    private static string cronExprCacheKey;
    private static CronExpression cronExprCache;
    private static Nullable`1<ValueTuple`3<WipeFrequency, int, float>> cronCacheKey;
    private static string cronCache;
    private static string timezoneCacheKey;
    private static TimeZoneInfo timezoneCache;
    private static WipeTimer();
    public virtual void InitShared();
    public virtual void DestroyShared();
    public virtual void ServerInit();
    public void RecalculateWipeFrequency();
    public void TryAndUpdate();
    public virtual void Save(SaveInfo info);
    public TimeSpan GetTimeSpanUntilWipe();
    public long GetTicksUntilWipe();
    [ServerVar]
public static void PrintWipe(Arg arg);
    [ServerVar]
public static void PrintTimeZones(Arg arg);
    public DateTimeOffset GetWipeTime(DateTimeOffset nowTime);
    private bool HoursUntilWipe(float hours);
    private static CronExpression GetCronExpression(WipeFrequency frequency, int dayOfWeek, float hourOfDay);
    private static string GetCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay);
    private static string BuildCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay);
    private static TimeZoneInfo GetTimeZone();
}
public class WipeTimerScreen : MonoBehaviour {
    public Text timerText;
}
[CreateAssetMenuAttribute]
public class WireColorSettings : BaseScriptableObject {
    private static List`1<WireColorSettings> settings;
    public IOType ioType;
    public WireColor[] WireColors;
    private static WireColorSettings();
    public static WireColorSettings Get(IOType type);
    public GameObjectRef GetPrefabRef(WireColour wireColor);
}
public class WireTool : HeldEntity {
    private static int maxLineNodes;
    private static float industrialWallOffset;
    public IOType wireType;
    public WireColour DefaultColor;
    public float radialMenuHoldTime;
    public float disconnectDelay;
    public float clearDelay;
    private bool justCleared;
    public GameObjectRef plugEffect;
    public SoundDefinition clearStartSoundDef;
    public SoundDefinition clearSoundDef;
    public PendingPlug pendingPlug;
    private static float IndustrialThickness;
    private bool CanChangeColours { get; }
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    private bool get_CanChangeColours();
    public float GetMaxWireLength(BasePlayer forPlayer);
    [IsActiveItem]
[FromOwner]
[RPC_Server]
[CallsPerSecond("5")]
public void RPC_MakeConnection(RPCMessage rpc);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("5")]
[IsActiveItem]
public void RPC_RequestClear(RPCMessage msg);
    [RPC_Server]
[FromOwner]
[CallsPerSecond("5")]
[IsActiveItem]
public void RPC_RequestChangeColor(RPCMessage msg);
    public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput);
    public WireColour IntToColour(int i);
    public bool ValidateLine(List`1<Vector3> lineList, IOEntity inputEntity, IOEntity outputEntity, BasePlayer byPlayer, int outputIndex);
    public bool VerifyLineOfSight(List`1<Vector3> positions, Matrix4x4 localToWorldSpace);
    public bool VerifyLineOfSight(Vector3 worldSpaceA, Vector3 worldSpaceB);
    public bool HasPendingPlug();
    public bool PendingPlugIsInput();
    public bool PendingPlugIsType(IOType type);
    public bool PendingPlugIsOutput();
    public bool PendingPlugIsRoot();
    private void ResetPendingPlug();
    public static bool CanPlayerUseWires(BasePlayer player);
    private static bool CanModifyEntity(BasePlayer player, IOEntity ent);
}
public class Wolf : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public float RealisticMass { get; }
    public TraitFlag Traits { get; }
    private static Wolf();
    public virtual float get_RealisticMass();
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    public virtual string Categorize();
}
public static class WordFilter : object {
    public static string Filter(string str);
}
public class Workbench : StorageContainer {
    public static int blueprintSlot;
    public static int experimentSlot;
    public bool Static;
    public int Workbenchlevel;
    public LootSpawn experimentalItems;
    public GameObjectRef experimentStartEffect;
    public GameObjectRef experimentSuccessEffect;
    public ItemDefinition experimentResource;
    public TechTreeData[] techTrees;
    public static ItemDefinition blueprintBaseDef;
    private ItemDefinition pendingBlueprint;
    private bool creatingBlueprint;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public TechTreeData GetTechTreeForLevel(int level);
    public int GetScrapForExperiment();
    public bool IsWorking();
    public virtual bool CanPickup(BasePlayer player);
    [RPC_Server]
[IsVisible("3")]
public void RPC_TechTreeUnlock(RPCMessage msg);
    public static ItemDefinition GetBlueprintTemplate();
    [IsVisible("3")]
[RPC_Server]
public void RPC_BeginExperiment(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    public virtual void OnKilled(HitInfo info);
    public int GetAvailableExperimentResources();
    public Item GetExperimentResourceItem();
    public void ExperimentComplete();
    public virtual void PostServerLoad();
    public virtual void ServerInit();
    public virtual bool ItemFilter(Item item, int targetSlot);
    public static int ScrapForResearch(ItemDefinition info, int workbenchLevel, Int32& tax);
    public virtual bool SupportsChildDeployables();
}
public class WorkbenchPanel : LootPanel {
    public GameObject openTechTreeButton;
    public Text timerText;
    public Text costText;
    public GameObject expermentCostParent;
    public GameObject controlsParent;
    public GameObject allUnlockedNotification;
    public GameObject informationParent;
    public GameObject cycleIcon;
    public TechTreeDialog techTreeDialog;
}
public class WorkshopIconRender : MonoBehaviour {
    public int MinimumId;
    public int MaximumId;
}
public class WorkshopMainMenu : SingletonComponent`1<WorkshopMainMenu> {
    public static Phrase loading_workshop;
    public static Phrase loading_workshop_setup;
    public static Phrase loading_workshop_skinnables;
    public static Phrase loading_workshop_item;
    private static WorkshopMainMenu();
}
public class WorkshopSkin : WorkshopSkinBase {
}
public static class World : object {
    [CompilerGeneratedAttribute]
private static UInt32 <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
private static UInt32 <Salt>k__BackingField;
    private static UInt32 _size;
    [CompilerGeneratedAttribute]
private static string <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Procedural>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Networked>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Receiving>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Transfer>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <LoadedFromSave>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <SpawnIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private static WorldSerialization <Serialization>k__BackingField;
    [CompilerGeneratedAttribute]
private static WorldConfig <Config>k__BackingField;
    private static Stopwatch spawnTimer;
    private static List`1<SpawnTiming> spawnTimings;
    public static UInt32 Seed { get; public set; }
    public static UInt32 Salt { get; public set; }
    public static UInt32 Size { get; public set; }
    public static string Checksum { get; public set; }
    public static string Url { get; public set; }
    public static bool Procedural { get; public set; }
    public static bool Cached { get; public set; }
    public static bool Networked { get; public set; }
    public static bool Receiving { get; public set; }
    public static bool Transfer { get; public set; }
    public static bool Nexus { get; }
    public static bool LoadedFromSave { get; public set; }
    public static int SpawnIndex { get; public set; }
    public static WorldSerialization Serialization { get; public set; }
    public static WorldConfig Config { get; public set; }
    public static string Name { get; }
    public static string MapFileName { get; }
    public static string MapFolderName { get; }
    public static string SaveFileName { get; }
    public static string SaveFolderName { get; }
    private static World();
    [CompilerGeneratedAttribute]
public static UInt32 get_Seed();
    [CompilerGeneratedAttribute]
public static void set_Seed(UInt32 value);
    [CompilerGeneratedAttribute]
public static UInt32 get_Salt();
    [CompilerGeneratedAttribute]
public static void set_Salt(UInt32 value);
    public static UInt32 get_Size();
    public static void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public static string get_Checksum();
    [CompilerGeneratedAttribute]
public static void set_Checksum(string value);
    [CompilerGeneratedAttribute]
public static string get_Url();
    [CompilerGeneratedAttribute]
public static void set_Url(string value);
    [CompilerGeneratedAttribute]
public static bool get_Procedural();
    [CompilerGeneratedAttribute]
public static void set_Procedural(bool value);
    [CompilerGeneratedAttribute]
public static bool get_Cached();
    [CompilerGeneratedAttribute]
public static void set_Cached(bool value);
    [CompilerGeneratedAttribute]
public static bool get_Networked();
    [CompilerGeneratedAttribute]
public static void set_Networked(bool value);
    [CompilerGeneratedAttribute]
public static bool get_Receiving();
    [CompilerGeneratedAttribute]
public static void set_Receiving(bool value);
    [CompilerGeneratedAttribute]
public static bool get_Transfer();
    [CompilerGeneratedAttribute]
public static void set_Transfer(bool value);
    public static bool get_Nexus();
    [CompilerGeneratedAttribute]
public static bool get_LoadedFromSave();
    [CompilerGeneratedAttribute]
public static void set_LoadedFromSave(bool value);
    [CompilerGeneratedAttribute]
public static int get_SpawnIndex();
    [CompilerGeneratedAttribute]
public static void set_SpawnIndex(int value);
    [CompilerGeneratedAttribute]
public static WorldSerialization get_Serialization();
    [CompilerGeneratedAttribute]
public static void set_Serialization(WorldSerialization value);
    [CompilerGeneratedAttribute]
public static WorldConfig get_Config();
    [CompilerGeneratedAttribute]
public static void set_Config(WorldConfig value);
    public static string get_Name();
    public static string GetServerBrowserMapName();
    public static bool CanLoadFromUrl();
    public static bool CanLoadFromDisk();
    public static void CleanupOldFiles();
    public static string get_MapFileName();
    public static string get_MapFolderName();
    public static string get_SaveFileName();
    public static string get_SaveFolderName();
    public static void InitSeed(int seed);
    public static void InitSeed(UInt32 seed);
    private static string SeedIdentifier();
    public static void InitSalt(int salt);
    public static void InitSalt(UInt32 salt);
    private static string SaltIdentifier();
    public static void InitSize(int size);
    public static void InitSize(UInt32 size);
    public static Byte[] GetMap(string name);
    public static int GetCachedHeightMapResolution();
    public static int GetCachedSplatMapResolution();
    public static void AddMap(string name, Byte[] data);
    public static void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale);
    public static PathData PathListToPathData(PathList src);
    public static PathList PathDataToPathList(PathData src);
    public static Vector3[] VectorListToArray(List`1<VectorData> src);
    public static List`1<VectorData> VectorArrayToList(Vector3[] src);
    public static IEnumerable`1<PathList> GetPaths(string name);
    public static void AddPaths(IEnumerable`1<PathList> paths);
    public static void AddPath(PathList path);
    [IteratorStateMachineAttribute("World/<SpawnAsync>d__92")]
public static IEnumerator SpawnAsync(float deltaTime, Action`1<string> statusFunction);
    [IteratorStateMachineAttribute("World/<Spawn>d__93")]
public static IEnumerator Spawn(float deltaTime, Action`1<string> statusFunction);
    public static void Spawn();
    public static void Spawn(string category, string folder);
    public static void Spawn(string category, String[] folders);
    private static void SpawnPrefabData(PrefabData prefab);
    private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale);
    private static void Status(Action`1<string> statusFunction, string status, object obj1);
    private static void Status(Action`1<string> statusFunction, string status, object obj1, object obj2);
    private static void Status(Action`1<string> statusFunction, string status, object obj1, object obj2, object obj3);
    private static void Status(Action`1<string> statusFunction, string status, Object[] objs);
    public static IEnumerable`1<SpawnTiming> GetSpawnTimings();
    public static void ResetTiming();
}
[JsonModelAttribute]
public class WorldConfig : object {
    public string JsonString;
    public float PercentageTier0;
    public float PercentageTier1;
    public float PercentageTier2;
    public float PercentageBiomeArid;
    public float PercentageBiomeTemperate;
    public float PercentageBiomeTundra;
    public float PercentageBiomeArctic;
    public bool MainRoads;
    public bool SideRoads;
    public bool Trails;
    public bool Rivers;
    public bool Powerlines;
    public bool AboveGroundRails;
    public bool BelowGroundRails;
    public bool UnderwaterLabs;
    public List`1<string> PrefabBlacklist;
    public List`1<string> PrefabWhitelist;
    public bool IsPrefabAllowed(string name);
    public void LoadFromJsonFile(string fileName);
    public void LoadFromJsonString(string data);
    public void LoadFromWorldConfig(WorldConfig data);
}
public class WorldGrid : SingletonComponent`1<WorldGrid> {
    public static bool Paused;
    public float CellSize;
    public float MaxMilliseconds;
    public static float MaxRefreshDistance;
    public static float MinTimeBetweenRefreshes;
}
public class WorldItem : BaseEntity {
    public static Phrase OpenLootTitle;
    public static Phrase PickUpTitle;
    public static Phrase HoldToPickupPhrase;
    [HeaderAttribute("WorldItem")]
public bool allowPickup;
    public Item item;
    private bool _isInvokingSendItemUpdate;
    protected float eatSeconds;
    protected float caloriesPerSecond;
    public TraitFlag Traits { get; }
    private static WorldItem();
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual Item GetItem();
    public void InitializeItem(Item in_item);
    public void RemoveItem();
    public void DestroyItem();
    protected virtual void OnItemDirty(Item in_item);
    public virtual void Load(LoadInfo info);
    public virtual TraitFlag get_Traits();
    public virtual string ToString();
    public sealed virtual bool CanMoveFrom(BasePlayer player, Item item);
    public virtual void ServerInit();
    private void DoItemNetworking();
    private void SendItemUpdate();
    [IsVisible("3")]
[RPC_Server]
public void Pickup(RPCMessage msg);
    public virtual void Save(SaveInfo info);
    internal virtual void DoServerDestroy();
    public virtual void SwitchParent(BaseEntity ent);
    public virtual void Eat(BaseNpc baseNpc, float timeSpent);
    private bool CanOpenInSafeZone(BasePlayer looter);
    [IsVisible("3")]
[RPC_Server]
private void RPC_OpenLoot(RPCMessage rpc);
}
public class WorldModel : MonoBehaviour {
    public float mass;
}
public class WorldModelOutline : OutlineObject {
    public bool AlwaysRender;
}
public class WorldModelRackMountConfig : MonoBehaviour {
    public List`1<RackType> ExcludedRackTypes;
    public Vector3 CenterOffsfet;
    public Vector3 LeftOffset;
    public Vector3 VerticalMountLocalRotation;
    public Vector3 VerticalMountLocalOffset;
    public int XSize;
    public int YSize;
    public int ZSize;
    public List`1<PegConfig> Pegs;
    public List`1<PegConfig> VerticalPegs;
    public bool OverrideScale;
    public Vector3 Scale;
    public bool UseManualRenderBounds;
    public Bounds ManualRenderBounds;
    public bool CanReloadOnWeaponRack;
    [HeaderAttribute("Special Rack Types")]
public List`1<CustomPosition> CustomPositions;
    public static WorldModelRackMountConfig GetForItemDef(ItemDefinition itemDef);
    public void ApplyTransformDefaults(Transform displayItem);
    public CustomPosition FindCustomRackPosition(SpecialRackType rackType);
}
public class WorldModelRandomiser : MonoBehaviour {
    public PartRandomizer[] randomParts;
}
public class WorldNetworking : object {
    private static int prefabsPerPacket;
    private static int pathsPerPacket;
    public static void OnMessageReceived(Message message);
    private static void SendWorldData(Connection connection);
    private static void SendWorldData(Connection connection, WorldMessage& data);
}
[CreateAssetMenuAttribute]
public class WorldPositionGenerator : ScriptableObject {
    public SpawnFilter Filter;
    public float FilterCutoff;
    public bool aboveWater;
    public float MaxSlopeRadius;
    public float MaxSlopeDegrees;
    public float CheckSphereRadius;
    public LayerMask CheckSphereMask;
    private Vector3 _origin;
    private Vector3 _area;
    private ByteQuadtree _quadtree;
    public bool TrySample(Vector3 origin, float minDist, float maxDist, Vector3& position, List`1<Vector3> blocked);
    public void PrecalculatePositions();
    [CompilerGeneratedAttribute]
private void <TrySample>g__EvaluateCandidate|10_0(Element child, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
private Rect <TrySample>g__GetElementRect|10_1(Element element, <>c__DisplayClass10_0& );
}
public class WorldSetup : SingletonComponent`1<WorldSetup> {
    public bool AutomaticallySetup;
    public bool BypassProceduralSpawn;
    public bool ForceGenerateOceanPatrols;
    public GameObject terrain;
    public GameObject decorPrefab;
    public GameObject grassPrefab;
    public GameObject spawnPrefab;
    private TerrainMeta terrainMeta;
    public UInt32 EditorSeed;
    public UInt32 EditorSalt;
    public UInt32 EditorSize;
    public string EditorUrl;
    public string EditorConfigFile;
    [TextAreaAttribute]
public string EditorConfigString;
    public List`1<ProceduralObject> ProceduralObjects;
    internal List`1<MonumentNode> MonumentNodes;
    public void OnValidate();
    protected virtual void Awake();
    public void CreateObject(GameObject prefab);
    [IteratorStateMachineAttribute("WorldSetup/<InitCoroutine>d__19")]
public IEnumerator InitCoroutine();
    private void CancelSetup(string msg);
}
public class WorldSpline : MonoBehaviour {
    public int dataIndex;
    public Vector3[] points;
    public Vector3[] tangents;
    [RangeAttribute("0,05", "100")]
public float lutInterval;
    [SerializeField]
private bool showGizmos;
    private static List`1<Vector3> visualSplineList;
    private WorldSplineData privateData;
    private static WorldSpline();
    public WorldSplineData GetData();
    public void SetAll(Vector3[] points, Vector3[] tangents, float lutInterval);
    public void CheckValidity();
    protected virtual void OnDrawGizmosSelected();
    protected static void DrawSplineGizmo(WorldSpline ws, Color splineColour);
    private static Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints);
    public Vector3 GetStartPointWorld();
    public Vector3 GetEndPointWorld();
    public Vector3 GetStartTangentWorld();
    public Vector3 GetEndTangentWorld();
    public Vector3 GetTangentCubicHermiteWorld(float distance);
    public Vector3 GetTangentCubicHermiteWorld(float distance, WorldSplineData data);
    public Vector3 GetPointCubicHermiteWorld(float distance);
    public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data);
    public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, Vector3& tangent);
    public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, WorldSplineData data, Vector3& tangent);
    public Vector3[] GetPointsWorld();
    public Vector3[] GetTangentsWorld();
    private static Vector3[] PointsToWorld(Vector3[] points, Transform tr);
    private static Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr);
}
public class WorldSplineData : object {
    public Vector3[] inputPoints;
    public Vector3[] inputTangents;
    public float inputLUTInterval;
    public List`1<LUTEntry> LUTValues;
    public float Length;
    [SerializeField]
private int maxPointsIndex;
    public WorldSplineData(WorldSpline worldSpline);
    public bool IsSameAs(WorldSpline worldSpline);
    public bool IsDifferentTo(WorldSpline worldSpline);
    public Vector3 GetStartPoint();
    public Vector3 GetEndPoint();
    public Vector3 GetStartTangent();
    public Vector3 GetEndTangent();
    public Vector3 GetPointCubicHermite(float distance);
    public Vector3 GetTangentCubicHermite(float distance);
    public Vector3 GetPointAndTangentCubicHermite(float distance, Vector3& tangent);
    public void SetDefaultTangents(WorldSpline worldSpline);
    public bool DetectSplineProblems(WorldSpline worldSpline);
    private void CreateLookupTable(WorldSpline worldSpline);
    private void AddEntry(float distance, Vector3 pos);
}
[CreateAssetMenuAttribute]
public class WorldSplineSharedData : ScriptableObject {
    [SerializeField]
private List`1<WorldSplineData> dataList;
    public static WorldSplineSharedData _instance;
    private static String[] worldSplineFolders;
    public static WorldSplineSharedData instance { get; }
    private static WorldSplineSharedData();
    public static WorldSplineSharedData get_instance();
    public static bool TryGetDataFor(WorldSpline worldSpline, WorldSplineData& data);
}
public class XmasDungeon : HalloweenDungeon {
    public static Flags HasPlayerOutside;
    public static Flags HasPlayerInside;
    [ServerVar]
public static float xmaspopulation;
    [ServerVar]
public static float xmaslifetime;
    [ServerVar]
public static float playerdetectrange;
    private static XmasDungeon();
    public virtual float GetLifetime();
    public virtual void ServerInit();
    public void PlayerChecks();
}
public class XMasRefill : BaseEntity {
    public GameObjectRef[] giftPrefabs;
    public List`1<BasePlayer> goodKids;
    public List`1<Stocking> stockings;
    public AudioSource bells;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public float GiftRadius();
    public int GiftsPerPlayer();
    public int GiftSpawnAttempts();
    public virtual void ServerInit();
    public void SendBells();
    public void RemoveMe();
    public void DistributeLoot();
    protected bool DropToGround(Vector3& pos);
    public bool DistributeGiftsForPlayer(BasePlayer player);
}
public class XORSwitch : IOEntity {
    private int input1Amount;
    private int input2Amount;
    private bool firstRun;
    public virtual int ConsumptionAmount();
    public virtual bool WantsPower(int inputIndex);
    public virtual void ResetState();
    public virtual int GetPassthroughAmount(int outputSlot);
    public virtual void UpdateHasPower(int inputAmount, int inputSlot);
    public virtual void IOStateChanged(int inputAmount, int inputSlot);
    public virtual void UpdateFromInput(int inputAmount, int slot);
    private void UpdateFlags();
}
public class ZiplineArrivalPoint : BaseEntity {
    public LineRenderer Line;
    private Vector3[] linePositions;
    public virtual void Save(SaveInfo info);
    public void SetPositions(List`1<Vector3> points);
    public virtual void Load(LoadInfo info);
    public virtual void ResetState();
}
public class ZiplineAudio : MonoBehaviour {
    public ZiplineMountable zipline;
    public SoundDefinition movementLoopDef;
    public SoundDefinition frictionLoopDef;
    public SoundDefinition sparksLoopDef;
    public AnimationCurve movementGainCurve;
    public AnimationCurve movementPitchCurve;
    public AnimationCurve frictionGainCurve;
    public AnimationCurve sparksGainCurve;
}
public class ZiplineLaunchPoint : BaseEntity {
    public Transform LineDeparturePoint;
    public LineRenderer ZiplineRenderer;
    public Collider MountCollider;
    public BoxCollider[] BuildingBlocks;
    public BoxCollider[] PointBuildingBlocks;
    public SpawnableBoundsBlocker[] SpawnableBoundsBlockers;
    public GameObjectRef MountableRef;
    public float LineSlackAmount;
    public bool RegenLine;
    public List`1<Vector3> ziplineTargets;
    private List`1<Vector3> linePoints;
    public GameObjectRef ArrivalPointRef;
    private static float MaxZiplineLength;
    public virtual bool OnRpcMessage(BasePlayer player, UInt32 rpc, Message msg);
    public virtual void ResetState();
    public virtual void PostMapEntitySpawn();
    public void FindZiplineTarget(List`1& foundPositions);
    public bool CheckLineOfSight(Vector3 from, Vector3 to);
    [CallsPerSecond("2")]
[IsVisible("3")]
[RPC_Server]
public void MountPlayer(RPCMessage msg);
    public void ClearBusy();
    public virtual void Save(SaveInfo info);
    [ServerVar]
public static void report(Arg arg);
    [ServerVar]
public static void highlight(Arg arg);
    public virtual void Load(LoadInfo info);
    public void CalculateZiplinePoints(List`1<Vector3> targets, List`1& points);
    public Vector3 CalculateLineMidPoint(Vector3 start, Vector3 endPoint);
    public void UpdateBuildingBlocks();
    public bool IsPlayerFacingValidDirection(BasePlayer ply);
    public float GetLineLength();
    [CompilerGeneratedAttribute]
private void <UpdateBuildingBlocks>g__SetUpBuildingBlock|26_0(BoxCollider longCollider, BoxCollider pointCollider, SpawnableBoundsBlocker spawnBlocker, int startIndex, int endIndex);
}
public class ZiplineMountable : BaseMountable {
    public float MoveSpeed;
    public float ForwardAdditive;
    public CapsuleCollider ZipCollider;
    public Transform ZiplineGrabRoot;
    public Transform LeftHandIkPoint;
    public Transform RightHandIkPoint;
    public float SpeedUpTime;
    public bool EditorHoldInPlace;
    private List`1<Vector3> linePoints;
    public static Flags PushForward;
    public AnimationCurve MountPositionCurve;
    public AnimationCurve MountRotationCurve;
    public float MountEaseInTime;
    public static Flags ShowHandle;
    public float additiveValue;
    public float currentTravelDistance;
    public TimeSince mountTime;
    private bool hasEnded;
    public List`1<Collider> ignoreColliders;
    private Vector3 lastSafePosition;
    public Vector3 startPosition;
    public Vector3 endPosition;
    public Quaternion startRotation;
    public Quaternion endRotation;
    public float elapsedMoveTime;
    public bool isAnimatingIn;
    public Vector3 ProcessBezierMovement(float distanceToTravel);
    public Vector3 GetLineEndPoint(bool applyDismountOffset);
    public Vector3 GetNextLinePoint(Transform forTransform);
    public virtual void ResetState();
    public virtual float MaxVelocity();
    public void SetDestination(List`1<Vector3> targetLinePoints, Vector3 lineStartPos, Quaternion lineStartRot);
    private void Update();
    public virtual void PlayerServerInput(InputState inputState, BasePlayer player);
    public void EndZipline();
    public virtual void OnPlayerDismounted(BasePlayer player);
    public virtual bool ValidDismountPosition(BasePlayer player, Vector3 disPos);
    public virtual void Save(SaveInfo info);
    public void MovePlayerToPosition();
    public virtual void OnFlagsChanged(Flags old, Flags next);
}
public class ZiplineTarget : MonoBehaviour {
    public Transform Target;
    public bool IsChainPoint;
    public float MonumentConnectionDotMin;
    public float MonumentConnectionDotMax;
    public bool IsValidPosition(Vector3 position);
    public bool IsValidChainPoint(Vector3 from, Vector3 to);
}
public class Zombie : BaseAnimalNPC {
    [ServerVar]
public static float Population;
    public TraitFlag Traits { get; }
    public virtual TraitFlag get_Traits();
    public virtual bool WantsToEat(BaseEntity best);
    protected virtual void TickSleep();
    public virtual string Categorize();
}
public abstract class ZoneController : object {
    [CompilerGeneratedAttribute]
private static ZoneController <Instance>k__BackingField;
    protected NexusZoneClient ZoneClient;
    public static ZoneController Instance { get; public set; }
    protected ZoneController(NexusZoneClient zoneClient);
    [CompilerGeneratedAttribute]
public static ZoneController get_Instance();
    [CompilerGeneratedAttribute]
public static void set_Instance(ZoneController value);
    public abstract virtual string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone);
    public virtual ValueTuple`3<Vector3, Quaternion, bool> ChooseTransferDestination(string sourceZone, string method, string from, string to, Vector3 position, Quaternion rotation);
    protected virtual ValueTuple`3<Vector3, Quaternion, bool> ChooseConsoleTransferDestination(string sourceZone);
    protected virtual ValueTuple`3<Vector3, Quaternion, bool> ChooseFerryTransferDestination(string sourceZone);
    protected virtual ValueTuple`3<Vector3, Quaternion, bool> ChooseOceanTransferDestination(string sourceZone);
    protected virtual ValueTuple`3<Vector3, Quaternion, bool> ChooseTransferFallbackDestination(string sourceZone);
    public virtual bool CanRespawnAcrossZones(BasePlayer player);
}
public class ZoomImage : MonoBehaviour {
    [SerializeField]
private float _minimumScale;
    [SerializeField]
private float _initialScale;
    [SerializeField]
private float _maximumScale;
    [SerializeField]
private float _scaleIncrement;
    [HideInInspector]
private Vector3 _scale;
    private RectTransform _thisTransform;
    private void Awake();
    public sealed virtual void OnScroll(PointerEventData eventData);
}
