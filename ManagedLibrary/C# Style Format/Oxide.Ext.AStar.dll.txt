public Oxide.Ext.AStar.AStarExtension : Extension {
public string Name
public string Author
public VersionNumber Version
public bool SupportsReloading
public string get_Name()
public string get_Author()
public VersionNumber get_Version()
public void .ctor(ExtensionManager manager)
public void Load()
public void OnModLoad()
public void Unload()
public void OnShutdown()
public bool get_SupportsReloading()
}
internal Oxide.Ext.AStar.AStarPlugin : CSPlugin {
private string _filename
private bool ReloadExtensionCommand(Arg arg)
private bool UnloadExtensionCommand(Arg arg)
private bool LoadExtensionCommand(Arg arg)
private void OnPluginUnloaded(Plugin plugin)
}
internal Oxide.Ext.AStar.AStarPluginLoader : RustPluginLoader {
public Type[] CorePlugins
public Type[] get_CorePlugins()
}
public Oxide.Ext.AStar.GridNode : object {
private GridNode <Parent>k__BackingField
private int <G_Cost>k__BackingField
private int <H_Cost>k__BackingField
private int <C_Cost>k__BackingField
private int <X>k__BackingField
private int <Z>k__BackingField
private float <CellSize>k__BackingField
private Vector3 <Position>k__BackingField
private bool <IsBlocked>k__BackingField
private int _heapIndex
internal GridNode Parent
internal int G_Cost
internal int H_Cost
public int C_Cost
internal int F_Cost
public int X
public int Z
public float CellSize
public Vector3 Position
public bool IsBlocked
public int HeapIndex
internal GridNode get_Parent()
internal void set_Parent(GridNode value)
internal int get_G_Cost()
internal void set_G_Cost(int value)
internal int get_H_Cost()
internal void set_H_Cost(int value)
public int get_C_Cost()
public void set_C_Cost(int value)
internal int get_F_Cost()
public int get_X()
private void set_X(int value)
public int get_Z()
private void set_Z(int value)
public float get_CellSize()
private void set_CellSize(float value)
public Vector3 get_Position()
public void set_Position(Vector3 value)
public bool get_IsBlocked()
public void set_IsBlocked(bool value)
public int get_HeapIndex()
public void set_HeapIndex(int value)
internal void .ctor(Action`2<GridNode, Vector3> nodeEvaluator, Vector3 position, Vector2Int coordinates, float cellSize)
internal void Reset()
public int CompareTo(GridNode other)
}
public Oxide.Ext.AStar.Heap`1 : object {
private T[] _items
private int _count
internal int Count
internal void .ctor(int maxHeapSize)
internal void Add(T item)
internal T RemoveFirst()
internal bool Contains(T item)
internal int get_Count()
internal void Clear()
internal void UpdateItem(T item)
private void SortUp(T item)
private void SortDown(T item)
private void Swap(T a, T b)
}
public Oxide.Ext.AStar.IHeapItem`1 {
public int HeapIndex
public int get_HeapIndex()
public void set_HeapIndex(int value)
}
public Oxide.Ext.AStar.IPathFinder {
public string Name
public bool DebugMode
public string get_Name()
public bool get_DebugMode()
public void EvaluateNode(GridNode gridNode, Vector3 position)
public void OnGridProcessed()
public IEnumerator OnCostMapGenerated()
}
public Oxide.Ext.AStar.ListPool : object {
public Dictionary`2<Type, object> directory
public void CreateCollection(int capacity)
public ListCollection`1<T> FindCollection()
public List`1<T> Get()
public List`1<T> Get(int capacity)
private T GetList()
public void Free(List`1& list)
private void FreeList(T& t)
public void ClearPool()
}
public Oxide.Ext.AStar.MathEx : object {
public bool Approximately(float a, float range, float threshold)
public int Clamp(int v, int min, int max)
}
internal Oxide.Ext.AStar.Parallel : object {
public void For(int fromInclusive, int toExclusive, Action`1<int> action)
}
public Oxide.Ext.AStar.PathCompletedResult : ValueType {
public BasePlayer Requester
public List`1<Vector3> Results
public void .ctor(BasePlayer requester, List`1<Vector3> results)
}
public Oxide.Ext.AStar.PathFailedResult : ValueType {
public BasePlayer Requester
public string Reason
public void .ctor(BasePlayer requester, string reason)
}
public Oxide.Ext.AStar.PathFinder : MonoBehaviour {
private WorldGrid`1<GridNode> <Grid>k__BackingField
private bool <IsCalculating>k__BackingField
private IPathFinder _plugin
private PathFinderConfig _config
private Stopwatch _stopwatch
private double _totalElapsedMs
private Heap`1<GridNode> _openSet
private HashSet`1<GridNode> _closedSet
private List`1<GridNode> _neighbours
private Queue`1<PathRequest> _requestQueue
private PathRequest _currentRequest
private Coroutine _currentTask
private float MAX_MS
public WorldGrid`1<GridNode> Grid
public bool IsCalculating
public WorldGrid`1<GridNode> get_Grid()
public void set_Grid(WorldGrid`1<GridNode> value)
public bool get_IsCalculating()
private void set_IsCalculating(bool value)
internal void Initialize(IPathFinder plugin, PathFinderConfig config)
private IEnumerator CreateCostMap()
private IEnumerator BlurCostMap()
internal void Destroy()
public void EvaluateGrid(PathRequest pathRequest)
private void ProcessRequest(PathRequest pathRequest)
private IEnumerator EvaluateGrid_Internal()
public GridNode FindOrCreateCell(Vector3 position)
public GridNode FindOrCreateCell(Vector2Int coordinates)
public GridNode FindOrCreateCell(int x, int z)
public void GetNodesInRadius(Vector3 position, float radius, List`1& list)
private void GetNeighbours(GridNode node, List`1& list)
private int Heuristic(GridNode a, GridNode b)
private void Reset()
private void <Reset>b__32_0(int z)
}
public Oxide.Ext.AStar.PathFinderConfig : object {
public float WorldSize
public float CellSize
public float PathInterval
public int BlurRate
public Action`2<GridNode, Vector3> NodeEvaluator
}
public Oxide.Ext.AStar.PathManager : object {
private Hash`2<IPathFinder, PathFinder> _pathFinders
public PathFinder RegisterPathFinder(IPathFinder plugin, PathFinderConfig config)
public void Unload(IPathFinder iPathFinder)
internal void OnShutdown()
}
public Oxide.Ext.AStar.PathRequest : ValueType {
internal Vector3 from
internal Vector3 to
internal BasePlayer requester
internal Action`1<PathCompletedResult> pathComplete
internal Action`1<PathFailedResult> pathFailed
public void .ctor(Vector3 from, Vector3 to, BasePlayer requester, Action`1<PathCompletedResult> pathComplete, Action`1<PathFailedResult> pathFailed)
public void OnPathGenerated(List`1<Vector3> list)
public void OnPathFailed(string reason)
}
public Oxide.Ext.AStar.TopologyEx : object {
public bool ContainsTopology(int topology, Enum mask)
}
public Oxide.Ext.AStar.Vector3ListEx : object {
private Vector3[] _chaikinSmooth
public void ChaikinSmooth(List`1<Vector3> list, int passes)
}
public Oxide.Ext.AStar.WorldGrid`1 : object {
internal T[] Cells
internal float CellSize
internal float CellSizeHalf
internal float CellSizeInverse
internal int CellCount
internal int CellCountHalf
public T Item
public T Item
public T Item
public T get_Item(Vector3 worldPos)
public void set_Item(Vector3 worldPos, T value)
public T get_Item(Vector2Int cellCoords)
public void set_Item(Vector2Int cellCoords, T value)
public T get_Item(int x, int y)
public void set_Item(int x, int y, T value)
public void .ctor(int cellCount, float cellSize)
public Vector3 GridToWorldCoords(Vector2Int cellPos)
public Vector2Int WorldToGridCoords(Vector3 worldPos)
}
