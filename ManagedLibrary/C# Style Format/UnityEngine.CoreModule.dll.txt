[AttributeUsageAttribute("64")]
public class AOT.MonoPInvokeCallbackAttribute : Attribute {
    public MonoPInvokeCallbackAttribute(Type type);
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
}
public enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
public class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
}
[AttributeUsageAttribute("24516")]
public class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
public class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
}
[FlagsAttribute]
public enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; }
    public bool ForceFullStates { get; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
}
[FlagsAttribute]
public enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
public enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
public class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
public class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Required>k__BackingField;
    public bool Required { get; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
}
[AttributeUsageAttribute("2112")]
public class JetBrains.Annotations.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Expression>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Target>k__BackingField;
    [CanBeNullAttribute]
public string Expression { get; public set; }
    public int Editable { get; public set; }
    [CanBeNullAttribute]
public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("18436")]
public class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
public class JetBrains.Annotations.NoReorderAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("24516")]
public class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
}
[AttributeUsageAttribute("19916")]
public class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("32767")]
public class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
public class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
public class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; }
    public ImplicitUseTargetFlags TargetFlags { get; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
}
[AttributeUsageAttribute("2432")]
public class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
internal class Unity.Baselib.BaselibException : Exception {
    private ErrorState errorState;
    public Baselib_ErrorCode ErrorCode { get; }
    internal BaselibException(ErrorState errorState);
    public Baselib_ErrorCode get_ErrorCode();
}
internal static class Unity.Baselib.BaselibNativeLibrary : object {
}
internal class Unity.Baselib.ErrorState : ValueType {
    private Baselib_ErrorState nativeErrorState;
    public Baselib_ErrorCode ErrorCode { get; }
    public Baselib_ErrorState* NativeErrorStatePtr { get; }
    public void ThrowIfFailed();
    public Baselib_ErrorCode get_ErrorCode();
    public Baselib_ErrorState* get_NativeErrorStatePtr();
    public string Explain(Baselib_ErrorState_ExplainVerbosity verbosity);
}
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_SourceLocation.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_Socket.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_NetworkAddress.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_ThreadLocalStorage.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_FileIO.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_ErrorState.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_ErrorCode.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_DynamicLibrary.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_Timer.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_Memory.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_Thread.gen.binding.h")]
[NativeHeaderAttribute("External/baselib/builds/CSharp/BindingsUnity/Baselib_RegisteredNetwork.gen.binding.h")]
internal static class Unity.Baselib.LowLevel.Binding : object {
    public static UIntPtr Baselib_Memory_MaxAlignment;
    public static UIntPtr Baselib_Memory_MinGuaranteedAlignment;
    public static UInt32 Baselib_NetworkAddress_IpMaxStringLength;
    public static IntPtr Baselib_RegisteredNetwork_Buffer_Id_Invalid;
    public static UInt32 Baselib_RegisteredNetwork_Endpoint_MaxSize;
    public static IntPtr Baselib_Thread_InvalidId;
    public static UIntPtr Baselib_Thread_MaxThreadNameLength;
    public static UInt32 Baselib_TLS_MinimumGuaranteedSlots;
    public static ulong Baselib_SecondsPerMinute;
    public static ulong Baselib_MillisecondsPerSecond;
    public static ulong Baselib_MillisecondsPerMinute;
    public static ulong Baselib_MicrosecondsPerMillisecond;
    public static ulong Baselib_MicrosecondsPerSecond;
    public static ulong Baselib_MicrosecondsPerMinute;
    public static ulong Baselib_NanosecondsPerMicrosecond;
    public static ulong Baselib_NanosecondsPerMillisecond;
    public static ulong Baselib_NanosecondsPerSecond;
    public static ulong Baselib_NanosecondsPerMinute;
    public static ulong Baselib_Timer_MaxNumberOfNanosecondsPerTick;
    public static double Baselib_Timer_MinNumberOfNanosecondsPerTick;
    public static double Baselib_Timer_HighPrecisionTimerCrossThreadMontotonyTolerance_InNanoseconds;
    public static Baselib_Memory_PageAllocation Baselib_Memory_PageAllocation_Invalid;
    public static Baselib_RegisteredNetwork_Socket_UDP Baselib_RegisteredNetwork_Socket_UDP_Invalid;
    public static Baselib_Socket_Handle Baselib_Socket_Handle_Invalid;
    public static Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_Handle_Invalid;
    public static Baselib_FileIO_EventQueue Baselib_FileIO_EventQueue_Invalid;
    public static Baselib_FileIO_AsyncFile Baselib_FileIO_AsyncFile_Invalid;
    public static Baselib_FileIO_SyncFile Baselib_FileIO_SyncFile_Invalid;
    private static Binding();
    [FreeFunctionAttribute]
public static Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenUtf8(Byte* pathnameUtf8, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenUtf16(Char* pathnameUtf16, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenProgramHandle(Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_FromNativeHandle(ulong handle, UInt32 type, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static IntPtr Baselib_DynamicLibrary_GetFunction(Baselib_DynamicLibrary_Handle handle, Byte* functionName, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_DynamicLibrary_Close(Baselib_DynamicLibrary_Handle handle);
    [FreeFunctionAttribute]
public static UInt32 Baselib_ErrorState_Explain(Baselib_ErrorState* errorState, Byte* buffer, UInt32 bufferLen, Baselib_ErrorState_ExplainVerbosity verbosity);
    [FreeFunctionAttribute]
public static Baselib_FileIO_EventQueue Baselib_FileIO_EventQueue_Create();
    [FreeFunctionAttribute]
public static void Baselib_FileIO_EventQueue_Free(Baselib_FileIO_EventQueue eq);
    [FreeFunctionAttribute]
public static ulong Baselib_FileIO_EventQueue_Dequeue(Baselib_FileIO_EventQueue eq, Baselib_FileIO_EventQueue_Result* results, ulong count, UInt32 timeoutInMilliseconds);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_EventQueue_Shutdown(Baselib_FileIO_EventQueue eq, UInt32 threadCount);
    [FreeFunctionAttribute]
public static Baselib_FileIO_AsyncFile Baselib_FileIO_AsyncOpen(Baselib_FileIO_EventQueue eq, Byte* pathname, ulong userdata, Baselib_FileIO_Priority priority);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_AsyncRead(Baselib_FileIO_AsyncFile file, Baselib_FileIO_ReadRequest* requests, ulong count, ulong userdata, Baselib_FileIO_Priority priority);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_AsyncClose(Baselib_FileIO_AsyncFile file);
    [FreeFunctionAttribute]
public static Baselib_FileIO_SyncFile Baselib_FileIO_SyncOpen(Byte* pathname, Baselib_FileIO_OpenFlags openFlags, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_FileIO_SyncFile Baselib_FileIO_SyncFileFromNativeHandle(ulong handle, UInt32 type);
    [FreeFunctionAttribute]
public static ulong Baselib_FileIO_SyncRead(Baselib_FileIO_SyncFile file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static ulong Baselib_FileIO_SyncWrite(Baselib_FileIO_SyncFile file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_SyncFlush(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_SyncSetFileSize(Baselib_FileIO_SyncFile file, ulong size, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static ulong Baselib_FileIO_SyncGetFileSize(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_FileIO_SyncClose(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Memory_GetPageSizeInfo(Baselib_Memory_PageSizeInfo* outPagesSizeInfo);
    [FreeFunctionAttribute]
public static IntPtr Baselib_Memory_Allocate(UIntPtr size);
    [FreeFunctionAttribute]
public static IntPtr Baselib_Memory_Reallocate(IntPtr ptr, UIntPtr newSize);
    [FreeFunctionAttribute]
public static void Baselib_Memory_Free(IntPtr ptr);
    [FreeFunctionAttribute]
public static IntPtr Baselib_Memory_AlignedAllocate(UIntPtr size, UIntPtr alignment);
    [FreeFunctionAttribute]
public static IntPtr Baselib_Memory_AlignedReallocate(IntPtr ptr, UIntPtr newSize, UIntPtr alignment);
    [FreeFunctionAttribute]
public static void Baselib_Memory_AlignedFree(IntPtr ptr);
    [FreeFunctionAttribute]
public static Baselib_Memory_PageAllocation Baselib_Memory_AllocatePages(ulong pageSize, ulong pageCount, ulong alignmentInMultipleOfPageSize, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Memory_ReleasePages(Baselib_Memory_PageAllocation pageAllocation, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Memory_SetPageState(IntPtr addressOfFirstPage, ulong pageSize, ulong pageCount, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_NetworkAddress_Encode(Baselib_NetworkAddress* dstAddress, Baselib_NetworkAddress_Family family, Byte* ip, ushort port, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_NetworkAddress_Decode(Baselib_NetworkAddress* srcAddress, Baselib_NetworkAddress_Family* family, Byte* ipAddressBuffer, UInt32 ipAddressBufferLen, UInt16* port, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_Buffer Baselib_RegisteredNetwork_Buffer_Register(Baselib_Memory_PageAllocation pageAllocation, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_RegisteredNetwork_Buffer_Deregister(Baselib_RegisteredNetwork_Buffer buffer);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_BufferSlice Baselib_RegisteredNetwork_BufferSlice_Create(Baselib_RegisteredNetwork_Buffer buffer, UInt32 offset, UInt32 size);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_BufferSlice Baselib_RegisteredNetwork_BufferSlice_Empty();
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_Endpoint Baselib_RegisteredNetwork_Endpoint_Create(Baselib_NetworkAddress* srcAddress, Baselib_RegisteredNetwork_BufferSlice dstSlice, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_Endpoint Baselib_RegisteredNetwork_Endpoint_Empty();
    [FreeFunctionAttribute]
public static void Baselib_RegisteredNetwork_Endpoint_GetNetworkAddress(Baselib_RegisteredNetwork_Endpoint endpoint, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_Socket_UDP Baselib_RegisteredNetwork_Socket_UDP_Create(Baselib_NetworkAddress* bindAddress, Baselib_NetworkAddress_AddressReuse endpointReuse, UInt32 sendQueueSize, UInt32 recvQueueSize, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedRecv(Baselib_RegisteredNetwork_Socket_UDP socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedSend(Baselib_RegisteredNetwork_Socket_UDP socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_RegisteredNetwork_Socket_UDP_GetNetworkAddress(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_RegisteredNetwork_Socket_UDP_Close(Baselib_RegisteredNetwork_Socket_UDP socket);
    [FreeFunctionAttribute]
public static Baselib_Socket_Handle Baselib_Socket_Create(Baselib_NetworkAddress_Family family, Baselib_Socket_Protocol protocol, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_Bind(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_TCP_Connect(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_Poll(Baselib_Socket_PollFd* sockets, UInt32 socketsCount, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_GetAddress(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_TCP_Listen(Baselib_Socket_Handle socket, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static Baselib_Socket_Handle Baselib_Socket_TCP_Accept(Baselib_Socket_Handle socket, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_Socket_UDP_Send(Baselib_Socket_Handle socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_Socket_TCP_Send(Baselib_Socket_Handle socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_Socket_UDP_Recv(Baselib_Socket_Handle socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static UInt32 Baselib_Socket_TCP_Recv(Baselib_Socket_Handle socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState);
    [FreeFunctionAttribute]
public static void Baselib_Socket_Close(Baselib_Socket_Handle socket);
    [FreeFunctionAttribute]
public static void Baselib_Thread_YieldExecution();
    [FreeFunctionAttribute]
public static IntPtr Baselib_Thread_GetCurrentThreadId();
    [FreeFunctionAttribute]
public static UIntPtr Baselib_TLS_Alloc();
    [FreeFunctionAttribute]
public static void Baselib_TLS_Free(UIntPtr handle);
    [FreeFunctionAttribute]
public static void Baselib_TLS_Set(UIntPtr handle, UIntPtr value);
    [FreeFunctionAttribute]
public static UIntPtr Baselib_TLS_Get(UIntPtr handle);
    [FreeFunctionAttribute]
public static Baselib_Timer_TickToNanosecondConversionRatio Baselib_Timer_GetTicksToNanosecondsConversionRatio();
    [FreeFunctionAttribute]
public static ulong Baselib_Timer_GetHighPrecisionTimerTicks();
    [FreeFunctionAttribute]
public static void Baselib_Timer_WaitForAtLeast(UInt32 timeInMilliseconds);
    [FreeFunctionAttribute]
public static double Baselib_Timer_GetTimeSinceStartupInSeconds();
    private static void Baselib_DynamicLibrary_OpenUtf8_Injected(Byte* pathnameUtf8, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret);
    private static void Baselib_DynamicLibrary_OpenUtf16_Injected(Char* pathnameUtf16, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret);
    private static void Baselib_DynamicLibrary_OpenProgramHandle_Injected(Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret);
    private static void Baselib_DynamicLibrary_FromNativeHandle_Injected(ulong handle, UInt32 type, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret);
    private static IntPtr Baselib_DynamicLibrary_GetFunction_Injected(Baselib_DynamicLibrary_Handle& handle, Byte* functionName, Baselib_ErrorState* errorState);
    private static void Baselib_DynamicLibrary_Close_Injected(Baselib_DynamicLibrary_Handle& handle);
    private static void Baselib_FileIO_EventQueue_Create_Injected(Baselib_FileIO_EventQueue& ret);
    private static void Baselib_FileIO_EventQueue_Free_Injected(Baselib_FileIO_EventQueue& eq);
    private static ulong Baselib_FileIO_EventQueue_Dequeue_Injected(Baselib_FileIO_EventQueue& eq, Baselib_FileIO_EventQueue_Result* results, ulong count, UInt32 timeoutInMilliseconds);
    private static void Baselib_FileIO_EventQueue_Shutdown_Injected(Baselib_FileIO_EventQueue& eq, UInt32 threadCount);
    private static void Baselib_FileIO_AsyncOpen_Injected(Baselib_FileIO_EventQueue& eq, Byte* pathname, ulong userdata, Baselib_FileIO_Priority priority, Baselib_FileIO_AsyncFile& ret);
    private static void Baselib_FileIO_AsyncRead_Injected(Baselib_FileIO_AsyncFile& file, Baselib_FileIO_ReadRequest* requests, ulong count, ulong userdata, Baselib_FileIO_Priority priority);
    private static void Baselib_FileIO_AsyncClose_Injected(Baselib_FileIO_AsyncFile& file);
    private static void Baselib_FileIO_SyncOpen_Injected(Byte* pathname, Baselib_FileIO_OpenFlags openFlags, Baselib_ErrorState* errorState, Baselib_FileIO_SyncFile& ret);
    private static void Baselib_FileIO_SyncFileFromNativeHandle_Injected(ulong handle, UInt32 type, Baselib_FileIO_SyncFile& ret);
    private static ulong Baselib_FileIO_SyncRead_Injected(Baselib_FileIO_SyncFile& file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState);
    private static ulong Baselib_FileIO_SyncWrite_Injected(Baselib_FileIO_SyncFile& file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState);
    private static void Baselib_FileIO_SyncFlush_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState);
    private static void Baselib_FileIO_SyncSetFileSize_Injected(Baselib_FileIO_SyncFile& file, ulong size, Baselib_ErrorState* errorState);
    private static ulong Baselib_FileIO_SyncGetFileSize_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState);
    private static void Baselib_FileIO_SyncClose_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState);
    private static void Baselib_Memory_AllocatePages_Injected(ulong pageSize, ulong pageCount, ulong alignmentInMultipleOfPageSize, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState, Baselib_Memory_PageAllocation& ret);
    private static void Baselib_Memory_ReleasePages_Injected(Baselib_Memory_PageAllocation& pageAllocation, Baselib_ErrorState* errorState);
    private static void Baselib_RegisteredNetwork_Buffer_Register_Injected(Baselib_Memory_PageAllocation& pageAllocation, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Buffer& ret);
    private static void Baselib_RegisteredNetwork_Buffer_Deregister_Injected(Baselib_RegisteredNetwork_Buffer& buffer);
    private static void Baselib_RegisteredNetwork_BufferSlice_Create_Injected(Baselib_RegisteredNetwork_Buffer& buffer, UInt32 offset, UInt32 size, Baselib_RegisteredNetwork_BufferSlice& ret);
    private static void Baselib_RegisteredNetwork_BufferSlice_Empty_Injected(Baselib_RegisteredNetwork_BufferSlice& ret);
    private static void Baselib_RegisteredNetwork_Endpoint_Create_Injected(Baselib_NetworkAddress* srcAddress, Baselib_RegisteredNetwork_BufferSlice& dstSlice, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Endpoint& ret);
    private static void Baselib_RegisteredNetwork_Endpoint_Empty_Injected(Baselib_RegisteredNetwork_Endpoint& ret);
    private static void Baselib_RegisteredNetwork_Endpoint_GetNetworkAddress_Injected(Baselib_RegisteredNetwork_Endpoint& endpoint, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState);
    private static void Baselib_RegisteredNetwork_Socket_UDP_Create_Injected(Baselib_NetworkAddress* bindAddress, Baselib_NetworkAddress_AddressReuse endpointReuse, UInt32 sendQueueSize, UInt32 recvQueueSize, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Socket_UDP& ret);
    private static UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState);
    private static Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_ErrorState* errorState);
    private static Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_ErrorState* errorState);
    private static Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState);
    private static Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState);
    private static void Baselib_RegisteredNetwork_Socket_UDP_GetNetworkAddress_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState);
    private static void Baselib_RegisteredNetwork_Socket_UDP_Close_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket);
    private static void Baselib_Socket_Create_Injected(Baselib_NetworkAddress_Family family, Baselib_Socket_Protocol protocol, Baselib_ErrorState* errorState, Baselib_Socket_Handle& ret);
    private static void Baselib_Socket_Bind_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState);
    private static void Baselib_Socket_TCP_Connect_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState);
    private static void Baselib_Socket_GetAddress_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_ErrorState* errorState);
    private static void Baselib_Socket_TCP_Listen_Injected(Baselib_Socket_Handle& socket, Baselib_ErrorState* errorState);
    private static void Baselib_Socket_TCP_Accept_Injected(Baselib_Socket_Handle& socket, Baselib_ErrorState* errorState, Baselib_Socket_Handle& ret);
    private static UInt32 Baselib_Socket_UDP_Send_Injected(Baselib_Socket_Handle& socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_Socket_TCP_Send_Injected(Baselib_Socket_Handle& socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_Socket_UDP_Recv_Injected(Baselib_Socket_Handle& socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState);
    private static UInt32 Baselib_Socket_TCP_Recv_Injected(Baselib_Socket_Handle& socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState);
    private static void Baselib_Socket_Close_Injected(Baselib_Socket_Handle& socket);
    private static void Baselib_Timer_GetTicksToNanosecondsConversionRatio_Injected(Baselib_Timer_TickToNanosecondConversionRatio& ret);
}
[RequireAttributeUsagesAttribute]
[AttributeUsageAttribute("64")]
public class Unity.Burst.BurstAuthorizedExternalMethodAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
public class Unity.Burst.BurstDiscardAttribute : Attribute {
}
[NativeHeaderAttribute("Runtime/Burst/BurstDelegateCache.h")]
[StaticAccessorAttribute("BurstCompilerService::Get()", "1")]
[NativeHeaderAttribute("Runtime/Burst/Burst.h")]
internal static class Unity.Burst.LowLevel.BurstCompilerService : object {
    public static bool IsInitialized { get; }
    [NativeMethodAttribute("Initialize")]
private static string InitializeInternal(string path, ExtractCompilerFlags extractCompilerFlags);
    [ThreadSafeAttribute]
public static string GetDisassembly(MethodInfo m, string compilerOptions);
    [FreeFunctionAttribute]
public static int CompileAsyncDelegateMethod(object delegateMethod, string compilerOptions);
    [FreeFunctionAttribute]
public static Void* GetAsyncCompiledAsyncDelegateMethod(int userID);
    [ThreadSafeAttribute]
public static Void* GetOrCreateSharedMemory(Hash128& key, UInt32 size_of, UInt32 alignment);
    [ThreadSafeAttribute]
public static string GetMethodSignature(MethodInfo method);
    public static bool get_IsInitialized();
    [ThreadSafeAttribute]
public static void SetCurrentExecutionMode(UInt32 environment);
    [ThreadSafeAttribute]
public static UInt32 GetCurrentExecutionMode();
    [FreeFunctionAttribute("DefaultBurstLogCallback", "True")]
public static void Log(Void* userData, BurstLogType logType, Byte* message, Byte* filename, int lineNumber);
    [FreeFunctionAttribute("DefaultBurstRuntimeLogCallback", "True")]
public static void RuntimeLog(Void* userData, BurstLogType logType, Byte* message, Byte* filename, int lineNumber);
    public static bool LoadBurstLibrary(string fullPathToLibBurstGenerated);
    public static void Initialize(string folderRuntime, ExtractCompilerFlags extractCompilerFlags);
}
[UsedByNativeCodeAttribute]
public enum Unity.Collections.Allocator : Enum {
    public int value__;
    public static Allocator Invalid;
    public static Allocator None;
    public static Allocator Temp;
    public static Allocator TempJob;
    public static Allocator Persistent;
    public static Allocator AudioKernel;
    public static Allocator FirstUserIndex;
}
[ExtensionAttribute]
[VisibleToOtherModulesAttribute]
internal static class Unity.Collections.CollectionExtensions : object {
    [ExtensionAttribute]
internal static void AddSorted(List`1<T> list, T item, IComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool ContainsByEquals(IEnumerable`1<T> collection, T element);
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.DeallocateOnJobCompletionAttribute : Attribute {
}
[UsedByNativeCodeAttribute]
internal enum Unity.Collections.LeakCategory : Enum {
    public int value__;
    public static LeakCategory Invalid;
    public static LeakCategory Malloc;
    public static LeakCategory TempJob;
    public static LeakCategory Persistent;
    public static LeakCategory LightProbesQuery;
    public static LeakCategory NativeTest;
    public static LeakCategory MeshDataArray;
    public static LeakCategory TransformAccessArray;
    public static LeakCategory NavMeshQuery;
}
[StaticAccessorAttribute("BurstLike", "2")]
[NativeHeaderAttribute("Runtime/Export/BurstLike/BurstLike.bindings.h")]
internal static class Unity.Collections.LowLevel.Unsafe.BurstLike : object {
    [BurstAuthorizedExternalMethodAttribute]
[ThreadSafeAttribute]
internal static int NativeFunctionCall_Int_IntPtr_IntPtr(IntPtr function, IntPtr p0, IntPtr p1, Int32& error);
}
internal static class Unity.Collections.LowLevel.Unsafe.BurstRuntime : object {
    public static long GetHashCode64();
    internal static long HashStringWithFNV1A64(string text);
}
[ExtensionAttribute]
public static class Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility : object {
    public static NativeArray`1<T> ConvertExistingDataToNativeArray(Void* dataPointer, int length, Allocator allocator);
    [ExtensionAttribute]
public static Void* GetUnsafePtr(NativeArray`1<T> nativeArray);
    [ExtensionAttribute]
public static Void* GetUnsafeReadOnlyPtr(NativeArray`1<T> nativeArray);
    [ExtensionAttribute]
public static Void* GetUnsafeReadOnlyPtr(ReadOnly<T> nativeArray);
    public static Void* GetUnsafeBufferPointerWithoutChecks(NativeArray`1<T> nativeArray);
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("8")]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerIsAtomicWriteOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerIsReadOnlyAttribute : Attribute {
}
[ObsoleteAttribute("Use NativeSetThreadIndexAttribute instead")]
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("8")]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerNeedsThreadIndexAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerSupportsDeallocateOnJobCompletionAttribute : Attribute {
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("8")]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerSupportsDeferredConvertListToArray : Attribute {
}
[AttributeUsageAttribute("8")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.LowLevel.Unsafe.NativeContainerSupportsMinMaxWriteRestrictionAttribute : Attribute {
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("256")]
public class Unity.Collections.LowLevel.Unsafe.NativeDisableContainerSafetyRestrictionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.LowLevel.Unsafe.NativeDisableUnsafePtrRestrictionAttribute : Attribute {
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("256")]
public class Unity.Collections.LowLevel.Unsafe.NativeSetClassTypeToNullOnScheduleAttribute : Attribute {
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("256")]
public class Unity.Collections.LowLevel.Unsafe.NativeSetThreadIndexAttribute : Attribute {
}
[ExtensionAttribute]
public static class Unity.Collections.LowLevel.Unsafe.NativeSliceUnsafeUtility : object {
    public static NativeSlice`1<T> ConvertExistingDataToNativeSlice(Void* dataPointer, int stride, int length);
    [ExtensionAttribute]
public static Void* GetUnsafePtr(NativeSlice`1<T> nativeSlice);
    [ExtensionAttribute]
public static Void* GetUnsafeReadOnlyPtr(NativeSlice`1<T> nativeSlice);
}
[NativeHeaderAttribute("Runtime/Export/Unsafe/UnsafeUtility.bindings.h")]
[StaticAccessorAttribute("UnsafeUtility", "2")]
public static class Unity.Collections.LowLevel.Unsafe.UnsafeUtility : object {
    private static int kIsManaged;
    private static int kIsNativeContainer;
    [ThreadSafeAttribute]
private static int GetFieldOffsetInStruct(FieldInfo field);
    [ThreadSafeAttribute]
private static int GetFieldOffsetInClass(FieldInfo field);
    public static int GetFieldOffset(FieldInfo field);
    public static Void* PinGCObjectAndGetAddress(object target, UInt64& gcHandle);
    public static Void* PinGCArrayAndGetDataAddress(Array target, UInt64& gcHandle);
    [ThreadSafeAttribute]
private static Void* PinSystemArrayAndGetAddress(object target, UInt64& gcHandle);
    [ThreadSafeAttribute]
private static Void* PinSystemObjectAndGetAddress(object target, UInt64& gcHandle);
    [ThreadSafeAttribute]
public static void ReleaseGCObject(ulong gcHandle);
    [ThreadSafeAttribute]
public static void CopyObjectAddressToPtr(object target, Void* dstPtr);
    public static bool IsBlittable();
    [ThreadSafeAttribute]
public static int CheckForLeaks();
    [ThreadSafeAttribute]
public static int ForgiveLeaks();
    [BurstAuthorizedExternalMethodAttribute]
[ThreadSafeAttribute]
public static NativeLeakDetectionMode GetLeakDetectionMode();
    [ThreadSafeAttribute]
[BurstAuthorizedExternalMethodAttribute]
public static void SetLeakDetectionMode(NativeLeakDetectionMode value);
    [ThreadSafeAttribute]
[BurstAuthorizedExternalMethodAttribute]
internal static int LeakRecord(IntPtr handle, LeakCategory category, int callstacksToSkip);
    [ThreadSafeAttribute]
[BurstAuthorizedExternalMethodAttribute]
internal static int LeakErase(IntPtr handle, LeakCategory category);
    [ThreadSafeAttribute]
public static Void* MallocTracked(long size, int alignment, Allocator allocator, int callstacksToSkip);
    [ThreadSafeAttribute]
public static void FreeTracked(Void* memory, Allocator allocator);
    [ThreadSafeAttribute]
public static Void* Malloc(long size, int alignment, Allocator allocator);
    [ThreadSafeAttribute]
public static void Free(Void* memory, Allocator allocator);
    public static bool IsValidAllocator(Allocator allocator);
    [ThreadSafeAttribute]
public static void MemCpy(Void* destination, Void* source, long size);
    [ThreadSafeAttribute]
public static void MemCpyReplicate(Void* destination, Void* source, int size, int count);
    [ThreadSafeAttribute]
public static void MemCpyStride(Void* destination, int destinationStride, Void* source, int sourceStride, int elementSize, int count);
    [ThreadSafeAttribute]
public static void MemMove(Void* destination, Void* source, long size);
    [ThreadSafeAttribute]
public static void MemSet(Void* destination, byte value, long size);
    public static void MemClear(Void* destination, long size);
    [ThreadSafeAttribute]
public static int MemCmp(Void* ptr1, Void* ptr2, long size);
    [ThreadSafeAttribute]
public static int SizeOf(Type type);
    [ThreadSafeAttribute]
public static bool IsBlittable(Type type);
    [ThreadSafeAttribute]
public static bool IsUnmanaged(Type type);
    [ThreadSafeAttribute]
public static bool IsValidNativeContainerElementType(Type type);
    [ThreadSafeAttribute]
internal static int GetScriptingTypeFlags(Type type);
    [ThreadSafeAttribute]
internal static void LogError(string msg, string filename, int linenumber);
    private static bool IsBlittableValueType(Type t);
    private static string GetReasonForTypeNonBlittableImpl(Type t, string name);
    internal static bool IsArrayBlittable(Array arr);
    internal static bool IsGenericListBlittable();
    internal static string GetReasonForArrayNonBlittable(Array arr);
    internal static string GetReasonForGenericListNonBlittable();
    internal static string GetReasonForTypeNonBlittable(Type t);
    internal static string GetReasonForValueTypeNonBlittable();
    public static bool IsUnmanaged();
    public static bool IsNativeContainerType();
    public static bool IsValidNativeContainerElementType();
    public static int AlignOf();
    public static void CopyPtrToStructure(Void* ptr, T& output);
    private static void InternalCopyPtrToStructure(Void* ptr, T& output);
    public static void CopyStructureToPtr(T& input, Void* ptr);
    private static void InternalCopyStructureToPtr(T& input, Void* ptr);
    public static T ReadArrayElement(Void* source, int index);
    public static T ReadArrayElementWithStride(Void* source, int index, int stride);
    public static void WriteArrayElement(Void* destination, int index, T value);
    public static void WriteArrayElementWithStride(Void* destination, int index, int stride, T value);
    public static Void* AddressOf(T& output);
    public static int SizeOf();
    public static T& As(U& from);
    public static T& AsRef(Void* ptr);
    public static T& ArrayElementAsRef(Void* ptr, int index);
    public static int EnumToInt(T enumValue);
    private static void InternalEnumToInt(T& enumValue, Int32& intValue);
    public static bool EnumEquals(T lhs, T rhs);
}
[AttributeUsageAttribute("192")]
public class Unity.Collections.LowLevel.Unsafe.WriteAccessRequiredAttribute : Attribute {
}
[DebuggerDisplayAttribute("Length = {m_Length}")]
[DefaultMemberAttribute("Item")]
[NativeContainerAttribute]
[NativeContainerSupportsMinMaxWriteRestrictionAttribute]
[NativeContainerSupportsDeallocateOnJobCompletionAttribute]
[NativeContainerSupportsDeferredConvertListToArray]
[DebuggerTypeProxyAttribute("Unity.Collections.NativeArrayDebugView`1")]
public class Unity.Collections.NativeArray`1 : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal Void* m_Buffer;
    internal int m_Length;
    internal Allocator m_AllocatorLabel;
    public int Length { get; }
    public T Item { get; public set; }
    public bool IsCreated { get; }
    public NativeArray`1(int length, Allocator allocator, NativeArrayOptions options);
    public NativeArray`1(T[] array, Allocator allocator);
    public NativeArray`1(NativeArray`1<T> array, Allocator allocator);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private static void CheckAllocateArguments(int length, Allocator allocator);
    private static void Allocate(int length, Allocator allocator, NativeArray`1& array);
    public int get_Length();
    [BurstDiscardAttribute]
[ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal static void IsUnmanagedAndThrow();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckElementReadAccess(int index);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckElementWriteAccess(int index);
    public T get_Item(int index);
    [WriteAccessRequiredAttribute]
public void set_Item(int index, T value);
    public bool get_IsCreated();
    [WriteAccessRequiredAttribute]
public sealed virtual void Dispose();
    public JobHandle Dispose(JobHandle inputDeps);
    [WriteAccessRequiredAttribute]
public void CopyFrom(T[] array);
    [WriteAccessRequiredAttribute]
public void CopyFrom(NativeArray`1<T> array);
    public void CopyTo(T[] array);
    public void CopyTo(NativeArray`1<T> array);
    public T[] ToArray();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(NativeArray`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NativeArray`1<T> left, NativeArray`1<T> right);
    public static bool op_Inequality(NativeArray`1<T> left, NativeArray`1<T> right);
    public static void Copy(NativeArray`1<T> src, NativeArray`1<T> dst);
    public static void Copy(ReadOnly<T> src, NativeArray`1<T> dst);
    public static void Copy(T[] src, NativeArray`1<T> dst);
    public static void Copy(NativeArray`1<T> src, T[] dst);
    public static void Copy(ReadOnly<T> src, T[] dst);
    public static void Copy(NativeArray`1<T> src, NativeArray`1<T> dst, int length);
    public static void Copy(ReadOnly<T> src, NativeArray`1<T> dst, int length);
    public static void Copy(T[] src, NativeArray`1<T> dst, int length);
    public static void Copy(NativeArray`1<T> src, T[] dst, int length);
    public static void Copy(ReadOnly<T> src, T[] dst, int length);
    public static void Copy(NativeArray`1<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    public static void Copy(ReadOnly<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    public static void Copy(T[] src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    public static void Copy(NativeArray`1<T> src, int srcIndex, T[] dst, int dstIndex, int length);
    public static void Copy(ReadOnly<T> src, int srcIndex, T[] dst, int dstIndex, int length);
    private static void CopySafe(NativeArray`1<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    private static void CopySafe(ReadOnly<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    private static void CopySafe(T[] src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length);
    private static void CopySafe(NativeArray`1<T> src, int srcIndex, T[] dst, int dstIndex, int length);
    private static void CopySafe(ReadOnly<T> src, int srcIndex, T[] dst, int dstIndex, int length);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private static void CheckCopyPtr(T[] ptr);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private static void CheckCopyLengths(int srcLength, int dstLength);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private static void CheckCopyArguments(int srcLength, int srcIndex, int dstLength, int dstIndex, int length);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckReinterpretLoadRange(int sourceIndex);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckReinterpretStoreRange(int destIndex);
    public U ReinterpretLoad(int sourceIndex);
    public void ReinterpretStore(int destIndex, U data);
    private NativeArray`1<U> InternalReinterpret(int length);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private static void CheckReinterpretSize();
    public NativeArray`1<U> Reinterpret();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckReinterpretSize(long tSize, long uSize, int expectedTypeSize, long byteLen, long uLen);
    public NativeArray`1<U> Reinterpret(int expectedTypeSize);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckGetSubArrayArguments(int start, int length);
    public NativeArray`1<T> GetSubArray(int start, int length);
    public ReadOnly<T> AsReadOnly();
    [WriteAccessRequiredAttribute]
[IsReadOnlyAttribute]
public Span`1<T> AsSpan();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> AsReadOnlySpan();
    public static Span`1<T> op_Implicit(NativeArray`1& source);
    public static ReadOnlySpan`1<T> op_Implicit(NativeArray`1& source);
}
internal class Unity.Collections.NativeArrayDebugView`1 : object {
    private NativeArray`1<T> m_Array;
    public T[] Items { get; }
    public NativeArrayDebugView`1(NativeArray`1<T> array);
    public T[] get_Items();
}
[NativeContainerAttribute]
internal class Unity.Collections.NativeArrayDispose : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal Void* m_Buffer;
    internal Allocator m_AllocatorLabel;
    public void Dispose();
}
[NativeClassAttribute("")]
internal class Unity.Collections.NativeArrayDisposeJob : ValueType {
    internal NativeArrayDispose Data;
    public sealed virtual void Execute();
    [RequiredByNativeCodeAttribute]
internal static void RegisterNativeArrayDisposeJobReflectionData();
}
public enum Unity.Collections.NativeArrayOptions : Enum {
    public int value__;
    public static NativeArrayOptions UninitializedMemory;
    public static NativeArrayOptions ClearMemory;
}
internal class Unity.Collections.NativeArrayReadOnlyDebugView`1 : object {
    private ReadOnly<T> m_Array;
    public T[] Items { get; }
    public NativeArrayReadOnlyDebugView`1(ReadOnly<T> array);
    public T[] get_Items();
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.NativeDisableParallelForRestrictionAttribute : Attribute {
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("256")]
public class Unity.Collections.NativeFixedLengthAttribute : Attribute {
    public int FixedLength;
    public NativeFixedLengthAttribute(int fixedLength);
}
public static class Unity.Collections.NativeLeakDetection : object {
    public static NativeLeakDetectionMode Mode { get; public set; }
    public static NativeLeakDetectionMode get_Mode();
    public static void set_Mode(NativeLeakDetectionMode value);
}
[UsedByNativeCodeAttribute]
public enum Unity.Collections.NativeLeakDetectionMode : Enum {
    public int value__;
    public static NativeLeakDetectionMode Disabled;
    public static NativeLeakDetectionMode Enabled;
    public static NativeLeakDetectionMode EnabledWithStackTrace;
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.NativeMatchesParallelForLengthAttribute : Attribute {
}
[NativeContainerAttribute]
[DebuggerTypeProxyAttribute("Unity.Collections.NativeSliceDebugView`1")]
[DebuggerDisplayAttribute("Length = {Length}")]
[NativeContainerSupportsMinMaxWriteRestrictionAttribute]
[DefaultMemberAttribute("Item")]
public class Unity.Collections.NativeSlice`1 : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal Byte* m_Buffer;
    internal int m_Stride;
    internal int m_Length;
    public T Item { get; public set; }
    public int Stride { get; }
    public int Length { get; }
    public NativeSlice`1(NativeSlice`1<T> slice, int start);
    public NativeSlice`1(NativeSlice`1<T> slice, int start, int length);
    public NativeSlice`1(NativeArray`1<T> array);
    public NativeSlice`1(NativeArray`1<T> array, int start);
    public NativeSlice`1(NativeArray`1<T> array, int start, int length);
    public static NativeSlice`1<T> op_Implicit(NativeArray`1<T> array);
    public NativeSlice`1<U> SliceConvert();
    public NativeSlice`1<U> SliceWithStride(int offset);
    public NativeSlice`1<U> SliceWithStride();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckReadIndex(int index);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckWriteIndex(int index);
    public T get_Item(int index);
    [WriteAccessRequiredAttribute]
public void set_Item(int index, T value);
    [WriteAccessRequiredAttribute]
public void CopyFrom(NativeSlice`1<T> slice);
    [WriteAccessRequiredAttribute]
public void CopyFrom(T[] array);
    public void CopyTo(NativeArray`1<T> array);
    public void CopyTo(T[] array);
    public T[] ToArray();
    public int get_Stride();
    public int get_Length();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(NativeSlice`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NativeSlice`1<T> left, NativeSlice`1<T> right);
    public static bool op_Inequality(NativeSlice`1<T> left, NativeSlice`1<T> right);
}
internal class Unity.Collections.NativeSliceDebugView`1 : object {
    private NativeSlice`1<T> m_Array;
    public T[] Items { get; }
    public NativeSliceDebugView`1(NativeSlice`1<T> array);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class Unity.Collections.NativeSliceExtensions : object {
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeArray`1<T> thisArray);
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start);
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start, int length);
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice);
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start);
    [ExtensionAttribute]
public static NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start, int length);
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("10496")]
public class Unity.Collections.ReadOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("10496")]
[RequiredByNativeCodeAttribute]
public class Unity.Collections.WriteOnlyAttribute : Attribute {
}
[StaticAccessorAttribute("GetContentNamespaceManager()", "0")]
[NativeHeaderAttribute("Runtime/Misc/ContentNamespace.h")]
public class Unity.Content.ContentNamespace : ValueType {
    internal ulong Id;
    private static bool s_defaultInitialized;
    private static ContentNamespace s_Default;
    private static Regex s_ValidName;
    public bool IsValid { get; }
    public static ContentNamespace Default { get; }
    private static ContentNamespace();
    public string GetName();
    public bool get_IsValid();
    public void Delete();
    private void ThrowIfInvalidNamespace();
    public static ContentNamespace get_Default();
    public static ContentNamespace GetOrCreateNamespace(string name);
    public static ContentNamespace[] GetAll();
    internal static ContentNamespace GetOrCreate(string name);
    internal static void RemoveNamespace(ContentNamespace ns);
    internal static string GetNamespaceName(ContentNamespace ns);
    internal static bool IsNamespaceHandleValid(ContentNamespace ns);
    private static void GetOrCreate_Injected(string name, ContentNamespace& ret);
    private static void RemoveNamespace_Injected(ContentNamespace& ns);
    private static string GetNamespaceName_Injected(ContentNamespace& ns);
    private static bool IsNamespaceHandleValid_Injected(ContentNamespace& ns);
}
[AttributeUsageAttribute("12")]
internal class Unity.IL2CPP.CompilerServices.Il2CppEagerStaticClassConstructionAttribute : Attribute {
}
[NativeHeaderAttribute("Runtime/VirtualFileSystem/ArchiveFileSystem/ArchiveFileHandle.h")]
[RequiredByNativeCodeAttribute]
public class Unity.IO.Archive.ArchiveFileInfo : ValueType {
    public string Filename;
    public ulong FileSize;
}
[RequiredByNativeCodeAttribute]
[StaticAccessorAttribute("GetManagedArchiveSystem()", "0")]
[NativeHeaderAttribute("Runtime/VirtualFileSystem/ArchiveFileSystem/ArchiveFileHandle.h")]
public static class Unity.IO.Archive.ArchiveFileInterface : object {
    public static ArchiveHandle MountAsync(ContentNamespace namespaceId, string filePath, string prefix);
    public static ArchiveHandle[] GetMountedArchives(ContentNamespace namespaceId);
    internal static ArchiveStatus Archive_GetStatus(ArchiveHandle handle);
    internal static JobHandle Archive_GetJobHandle(ArchiveHandle handle);
    internal static bool Archive_IsValid(ArchiveHandle handle);
    internal static JobHandle Archive_UnmountAsync(ArchiveHandle handle);
    internal static string Archive_GetMountPath(ArchiveHandle handle);
    internal static CompressionType Archive_GetCompression(ArchiveHandle handle);
    internal static bool Archive_IsStreamed(ArchiveHandle handle);
    internal static ArchiveFileInfo[] Archive_GetFileInfo(ArchiveHandle handle);
    private static void MountAsync_Injected(ContentNamespace& namespaceId, string filePath, string prefix, ArchiveHandle& ret);
    private static ArchiveHandle[] GetMountedArchives_Injected(ContentNamespace& namespaceId);
    private static ArchiveStatus Archive_GetStatus_Injected(ArchiveHandle& handle);
    private static void Archive_GetJobHandle_Injected(ArchiveHandle& handle, JobHandle& ret);
    private static bool Archive_IsValid_Injected(ArchiveHandle& handle);
    private static void Archive_UnmountAsync_Injected(ArchiveHandle& handle, JobHandle& ret);
    private static string Archive_GetMountPath_Injected(ArchiveHandle& handle);
    private static CompressionType Archive_GetCompression_Injected(ArchiveHandle& handle);
    private static bool Archive_IsStreamed_Injected(ArchiveHandle& handle);
    private static ArchiveFileInfo[] Archive_GetFileInfo_Injected(ArchiveHandle& handle);
}
[NativeHeaderAttribute("Runtime/VirtualFileSystem/ArchiveFileSystem/ArchiveFileHandle.h")]
[RequiredByNativeCodeAttribute]
public class Unity.IO.Archive.ArchiveHandle : ValueType {
    internal ulong Handle;
    public ArchiveStatus Status { get; }
    public JobHandle JobHandle { get; }
    public CompressionType Compression { get; }
    public bool IsStreamed { get; }
    public ArchiveStatus get_Status();
    public JobHandle get_JobHandle();
    public JobHandle Unmount();
    private void ThrowIfInvalid();
    public string GetMountPath();
    public CompressionType get_Compression();
    public bool get_IsStreamed();
    public ArchiveFileInfo[] GetFileInfo();
}
[RequiredByNativeCodeAttribute]
public enum Unity.IO.Archive.ArchiveStatus : Enum {
    public int value__;
    public static ArchiveStatus InProgress;
    public static ArchiveStatus Complete;
    public static ArchiveStatus Failed;
}
public enum Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem : Enum {
    public int value__;
    public static AssetLoadingSubsystem Other;
    public static AssetLoadingSubsystem Texture;
    public static AssetLoadingSubsystem VirtualTexture;
    public static AssetLoadingSubsystem Mesh;
    public static AssetLoadingSubsystem Audio;
    public static AssetLoadingSubsystem Scripts;
    public static AssetLoadingSubsystem EntitiesScene;
    public static AssetLoadingSubsystem EntitiesStreamBinaryReader;
    public static AssetLoadingSubsystem FileInfo;
    public static AssetLoadingSubsystem ContentLoading;
}
[NativeHeaderAttribute("Runtime/File/AsyncReadManagerManagedApi.h")]
public static class Unity.IO.LowLevel.Unsafe.AsyncReadManager : object {
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::Read")]
private static ReadHandle ReadInternal(string filename, Void* cmds, UInt32 cmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem);
    public static ReadHandle Read(string filename, ReadCommand* readCmds, UInt32 readCmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetFileInfo")]
[ThreadAndSerializationSafeAttribute]
private static ReadHandle GetFileInfoInternal(string filename, Void* cmd);
    public static ReadHandle GetFileInfo(string filename, FileInfoResult* result);
    [FreeFunctionAttribute("AsyncReadManagerManaged::ReadWithHandles_NativePtr")]
[ThreadAndSerializationSafeAttribute]
private static ReadHandle ReadWithHandlesInternal_NativePtr(FileHandle& fileHandle, Void* readCmdArray, JobHandle dependency);
    [FreeFunctionAttribute("AsyncReadManagerManaged::ReadWithHandles_NativeCopy")]
[ThreadAndSerializationSafeAttribute]
private static ReadHandle ReadWithHandlesInternal_NativeCopy(FileHandle& fileHandle, Void* readCmdArray);
    public static ReadHandle ReadDeferred(FileHandle& fileHandle, ReadCommandArray* readCmdArray, JobHandle dependency);
    public static ReadHandle Read(FileHandle& fileHandle, ReadCommandArray readCmdArray);
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::ScheduleOpenRequest")]
private static FileHandle OpenFileAsync_Internal(string fileName);
    public static FileHandle OpenFileAsync(string fileName);
    [FreeFunctionAttribute("AsyncReadManagerManaged::ScheduleCloseRequest")]
[ThreadAndSerializationSafeAttribute]
internal static JobHandle CloseFileAsync(FileHandle& fileHandle, JobHandle dependency);
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::ScheduleCloseCachedFileRequest")]
public static JobHandle CloseCachedFileAsync(string fileName, JobHandle dependency);
    private static void ReadInternal_Injected(string filename, Void* cmds, UInt32 cmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem, ReadHandle& ret);
    private static void GetFileInfoInternal_Injected(string filename, Void* cmd, ReadHandle& ret);
    private static void ReadWithHandlesInternal_NativePtr_Injected(FileHandle& fileHandle, Void* readCmdArray, JobHandle& dependency, ReadHandle& ret);
    private static void ReadWithHandlesInternal_NativeCopy_Injected(FileHandle& fileHandle, Void* readCmdArray, ReadHandle& ret);
    private static void OpenFileAsync_Internal_Injected(string fileName, FileHandle& ret);
    private static void CloseFileAsync_Injected(FileHandle& fileHandle, JobHandle& dependency, JobHandle& ret);
    private static void CloseCachedFileAsync_Injected(string fileName, JobHandle& dependency, JobHandle& ret);
}
[NativeConditionalAttribute("ENABLE_PROFILER")]
public static class Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics : object {
    [FreeFunctionAttribute("AreMetricsEnabled_Internal")]
public static bool IsEnabled();
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->ClearMetrics")]
[ThreadSafeAttribute]
private static void ClearMetrics_Internal();
    public static void ClearCompletedMetrics();
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetMarshalledMetrics")]
[ThreadSafeAttribute]
internal static AsyncReadManagerRequestMetric[] GetMetrics_Internal(bool clear);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetMetrics_NoAlloc")]
internal static void GetMetrics_NoAlloc_Internal(List`1<AsyncReadManagerRequestMetric> metrics, bool clear);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetMarshalledMetrics_Filtered_Managed")]
internal static AsyncReadManagerRequestMetric[] GetMetrics_Filtered_Internal(AsyncReadManagerMetricsFilters filters, bool clear);
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetMetrics_NoAlloc_Filtered_Managed")]
[ThreadSafeAttribute]
internal static void GetMetrics_NoAlloc_Filtered_Internal(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters filters, bool clear);
    public static AsyncReadManagerRequestMetric[] GetMetrics(AsyncReadManagerMetricsFilters filters, Flags flags);
    public static void GetMetrics(List`1<AsyncReadManagerRequestMetric> outMetrics, AsyncReadManagerMetricsFilters filters, Flags flags);
    public static AsyncReadManagerRequestMetric[] GetMetrics(Flags flags);
    public static void GetMetrics(List`1<AsyncReadManagerRequestMetric> outMetrics, Flags flags);
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->StartCollecting")]
public static void StartCollectingMetrics();
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->StopCollecting")]
public static void StopCollectingMetrics();
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetCurrentSummaryMetrics")]
internal static AsyncReadManagerSummaryMetrics GetSummaryMetrics_Internal(bool clear);
    public static AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(Flags flags);
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetCurrentSummaryMetricsWithFilters")]
internal static AsyncReadManagerSummaryMetrics GetSummaryMetricsWithFilters_Internal(AsyncReadManagerMetricsFilters metricsFilters, bool clear);
    public static AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(AsyncReadManagerMetricsFilters metricsFilters, Flags flags);
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetSummaryOfMetrics_Managed")]
[ThreadSafeAttribute]
internal static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics_Internal(AsyncReadManagerRequestMetric[] metrics);
    public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetSummaryOfMetrics_FromContainer_Managed")]
internal static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics_FromContainer_Internal(List`1<AsyncReadManagerRequestMetric> metrics);
    public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List`1<AsyncReadManagerRequestMetric> metrics);
    [FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetSummaryOfMetricsWithFilters_Managed")]
[ThreadSafeAttribute]
internal static AsyncReadManagerSummaryMetrics GetSummaryOfMetricsWithFilters_Internal(AsyncReadManagerRequestMetric[] metrics, AsyncReadManagerMetricsFilters metricsFilters);
    public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics, AsyncReadManagerMetricsFilters metricsFilters);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetSummaryOfMetricsWithFilters_FromContainer_Managed")]
internal static AsyncReadManagerSummaryMetrics GetSummaryOfMetricsWithFilters_FromContainer_Internal(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters metricsFilters);
    public static AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters metricsFilters);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("GetAsyncReadManagerMetrics()->GetTotalSizeNonASRMReadsBytes")]
public static ulong GetTotalSizeOfNonASRMReadsBytes(bool emptyAfterRead);
}
[RequiredByNativeCodeAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
[NativeAsStructAttribute]
public class Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters : object {
    [NativeNameAttribute("typeIDs")]
internal UInt64[] TypeIDs;
    [NativeNameAttribute("states")]
internal ProcessingState[] States;
    [NativeNameAttribute("readTypes")]
internal FileReadType[] ReadTypes;
    [NativeNameAttribute("priorityLevels")]
internal Priority[] PriorityLevels;
    [NativeNameAttribute("subsystems")]
internal AssetLoadingSubsystem[] Subsystems;
    public AsyncReadManagerMetricsFilters(ulong typeID);
    public AsyncReadManagerMetricsFilters(ProcessingState state);
    public AsyncReadManagerMetricsFilters(FileReadType readType);
    public AsyncReadManagerMetricsFilters(Priority priorityLevel);
    public AsyncReadManagerMetricsFilters(AssetLoadingSubsystem subsystem);
    public AsyncReadManagerMetricsFilters(UInt64[] typeIDs);
    public AsyncReadManagerMetricsFilters(ProcessingState[] states);
    public AsyncReadManagerMetricsFilters(FileReadType[] readTypes);
    public AsyncReadManagerMetricsFilters(Priority[] priorityLevels);
    public AsyncReadManagerMetricsFilters(AssetLoadingSubsystem[] subsystems);
    public AsyncReadManagerMetricsFilters(UInt64[] typeIDs, ProcessingState[] states, FileReadType[] readTypes, Priority[] priorityLevels, AssetLoadingSubsystem[] subsystems);
    public void SetTypeIDFilter(UInt64[] _typeIDs);
    public void SetStateFilter(ProcessingState[] _states);
    public void SetReadTypeFilter(FileReadType[] _readTypes);
    public void SetPriorityFilter(Priority[] _priorityLevels);
    public void SetSubsystemFilter(AssetLoadingSubsystem[] _subsystems);
    public void SetTypeIDFilter(ulong _typeID);
    public void SetStateFilter(ProcessingState _state);
    public void SetReadTypeFilter(FileReadType _readType);
    public void SetPriorityFilter(Priority _priorityLevel);
    public void SetSubsystemFilter(AssetLoadingSubsystem _subsystem);
    public void RemoveTypeIDFilter();
    public void RemoveStateFilter();
    public void RemoveReadTypeFilter();
    public void RemovePriorityFilter();
    public void RemoveSubsystemFilter();
    public void ClearFilters();
}
[RequiredByNativeCodeAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
public class Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <AssetName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <FileName>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ulong <OffsetBytes>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ulong <SizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ulong <AssetTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ulong <CurrentBytesRead>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private UInt32 <BatchReadCount>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsBatchRead>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ProcessingState <State>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FileReadType <ReadType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Priority <PriorityLevel>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssetLoadingSubsystem <Subsystem>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private double <RequestTimeMicroseconds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private double <TimeInQueueMicroseconds>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private double <TotalTimeMicroseconds>k__BackingField;
    [NativeNameAttribute("assetName")]
public string AssetName { get; }
    [NativeNameAttribute("fileName")]
public string FileName { get; }
    [NativeNameAttribute("offsetBytes")]
public ulong OffsetBytes { get; }
    [NativeNameAttribute("sizeBytes")]
public ulong SizeBytes { get; }
    [NativeNameAttribute("assetTypeId")]
public ulong AssetTypeId { get; }
    [NativeNameAttribute("currentBytesRead")]
public ulong CurrentBytesRead { get; }
    [NativeNameAttribute("batchReadCount")]
public UInt32 BatchReadCount { get; }
    [NativeNameAttribute("isBatchRead")]
public bool IsBatchRead { get; }
    [NativeNameAttribute("state")]
public ProcessingState State { get; }
    [NativeNameAttribute("readType")]
public FileReadType ReadType { get; }
    [NativeNameAttribute("priorityLevel")]
public Priority PriorityLevel { get; }
    [NativeNameAttribute("subsystem")]
public AssetLoadingSubsystem Subsystem { get; }
    [NativeNameAttribute("requestTimeMicroseconds")]
public double RequestTimeMicroseconds { get; }
    [NativeNameAttribute("timeInQueueMicroseconds")]
public double TimeInQueueMicroseconds { get; }
    [NativeNameAttribute("totalTimeMicroseconds")]
public double TotalTimeMicroseconds { get; }
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_AssetName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ulong get_OffsetBytes();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_SizeBytes();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ulong get_AssetTypeId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_CurrentBytesRead();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_BatchReadCount();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public bool get_IsBatchRead();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ProcessingState get_State();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public FileReadType get_ReadType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Priority get_PriorityLevel();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public AssetLoadingSubsystem get_Subsystem();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_RequestTimeMicroseconds();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_TimeInQueueMicroseconds();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_TotalTimeMicroseconds();
}
[NativeAsStructAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
public class Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ulong <TotalBytesRead>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private float <AverageBandwidthMBPerSecond>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private float <AverageReadSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private float <AverageWaitTimeMicroseconds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private float <AverageReadTimeMicroseconds>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private float <AverageTotalRequestTimeMicroseconds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private float <AverageThroughputMBPerSecond>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private float <LongestWaitTimeMicroseconds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private float <LongestReadTimeMicroseconds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ulong <LongestReadAssetType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ulong <LongestWaitAssetType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssetLoadingSubsystem <LongestReadSubsystem>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private AssetLoadingSubsystem <LongestWaitSubsystem>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <NumberOfInProgressRequests>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <NumberOfCompletedRequests>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <NumberOfFailedRequests>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <NumberOfWaitingRequests>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <NumberOfCanceledRequests>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <TotalNumberOfRequests>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <NumberOfCachedReads>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <NumberOfAsyncReads>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <NumberOfSyncReads>k__BackingField;
    [NativeNameAttribute("totalBytesRead")]
public ulong TotalBytesRead { get; }
    [NativeNameAttribute("averageBandwidthMBPerSecond")]
public float AverageBandwidthMBPerSecond { get; }
    [NativeNameAttribute("averageReadSizeInBytes")]
public float AverageReadSizeInBytes { get; }
    [NativeNameAttribute("averageWaitTimeMicroseconds")]
public float AverageWaitTimeMicroseconds { get; }
    [NativeNameAttribute("averageReadTimeMicroseconds")]
public float AverageReadTimeMicroseconds { get; }
    [NativeNameAttribute("averageTotalRequestTimeMicroseconds")]
public float AverageTotalRequestTimeMicroseconds { get; }
    [NativeNameAttribute("averageThroughputMBPerSecond")]
public float AverageThroughputMBPerSecond { get; }
    [NativeNameAttribute("longestWaitTimeMicroseconds")]
public float LongestWaitTimeMicroseconds { get; }
    [NativeNameAttribute("longestReadTimeMicroseconds")]
public float LongestReadTimeMicroseconds { get; }
    [NativeNameAttribute("longestReadAssetType")]
public ulong LongestReadAssetType { get; }
    [NativeNameAttribute("longestWaitAssetType")]
public ulong LongestWaitAssetType { get; }
    [NativeNameAttribute("longestReadSubsystem")]
public AssetLoadingSubsystem LongestReadSubsystem { get; }
    [NativeNameAttribute("longestWaitSubsystem")]
public AssetLoadingSubsystem LongestWaitSubsystem { get; }
    [NativeNameAttribute("numberOfInProgressRequests")]
public int NumberOfInProgressRequests { get; }
    [NativeNameAttribute("numberOfCompletedRequests")]
public int NumberOfCompletedRequests { get; }
    [NativeNameAttribute("numberOfFailedRequests")]
public int NumberOfFailedRequests { get; }
    [NativeNameAttribute("numberOfWaitingRequests")]
public int NumberOfWaitingRequests { get; }
    [NativeNameAttribute("numberOfCanceledRequests")]
public int NumberOfCanceledRequests { get; }
    [NativeNameAttribute("totalNumberOfRequests")]
public int TotalNumberOfRequests { get; }
    [NativeNameAttribute("numberOfCachedReads")]
public int NumberOfCachedReads { get; }
    [NativeNameAttribute("numberOfAsyncReads")]
public int NumberOfAsyncReads { get; }
    [NativeNameAttribute("numberOfSyncReads")]
public int NumberOfSyncReads { get; }
    [CompilerGeneratedAttribute]
public ulong get_TotalBytesRead();
    [CompilerGeneratedAttribute]
public float get_AverageBandwidthMBPerSecond();
    [CompilerGeneratedAttribute]
public float get_AverageReadSizeInBytes();
    [CompilerGeneratedAttribute]
public float get_AverageWaitTimeMicroseconds();
    [CompilerGeneratedAttribute]
public float get_AverageReadTimeMicroseconds();
    [CompilerGeneratedAttribute]
public float get_AverageTotalRequestTimeMicroseconds();
    [CompilerGeneratedAttribute]
public float get_AverageThroughputMBPerSecond();
    [CompilerGeneratedAttribute]
public float get_LongestWaitTimeMicroseconds();
    [CompilerGeneratedAttribute]
public float get_LongestReadTimeMicroseconds();
    [CompilerGeneratedAttribute]
public ulong get_LongestReadAssetType();
    [CompilerGeneratedAttribute]
public ulong get_LongestWaitAssetType();
    [CompilerGeneratedAttribute]
public AssetLoadingSubsystem get_LongestReadSubsystem();
    [CompilerGeneratedAttribute]
public AssetLoadingSubsystem get_LongestWaitSubsystem();
    [CompilerGeneratedAttribute]
public int get_NumberOfInProgressRequests();
    [CompilerGeneratedAttribute]
public int get_NumberOfCompletedRequests();
    [CompilerGeneratedAttribute]
public int get_NumberOfFailedRequests();
    [CompilerGeneratedAttribute]
public int get_NumberOfWaitingRequests();
    [CompilerGeneratedAttribute]
public int get_NumberOfCanceledRequests();
    [CompilerGeneratedAttribute]
public int get_TotalNumberOfRequests();
    [CompilerGeneratedAttribute]
public int get_NumberOfCachedReads();
    [CompilerGeneratedAttribute]
public int get_NumberOfAsyncReads();
    [CompilerGeneratedAttribute]
public int get_NumberOfSyncReads();
}
[IsReadOnlyAttribute]
public class Unity.IO.LowLevel.Unsafe.FileHandle : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal IntPtr fileCommandPtr;
    internal int version;
    public FileStatus Status { get; }
    public JobHandle JobHandle { get; }
    public FileStatus get_Status();
    public JobHandle get_JobHandle();
    public bool IsValid();
    public JobHandle Close(JobHandle dependency);
    [FreeFunctionAttribute("AsyncReadManagerManaged::IsFileHandleValid")]
private static bool IsFileHandleValid(FileHandle& handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetFileStatusFromManagedHandle")]
private static FileStatus GetFileStatus_Internal(FileHandle& handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetJobFenceFromManagedHandle")]
private static JobHandle GetJobHandle_Internal(FileHandle& handle);
    private static void GetJobHandle_Internal_Injected(FileHandle& handle, JobHandle& ret);
}
public class Unity.IO.LowLevel.Unsafe.FileInfoResult : ValueType {
    public long FileSize;
    public FileState FileState;
}
public enum Unity.IO.LowLevel.Unsafe.FileReadType : Enum {
    public int value__;
    public static FileReadType Sync;
    public static FileReadType Async;
}
[RequiredByNativeCodeAttribute]
public enum Unity.IO.LowLevel.Unsafe.FileState : Enum {
    public int value__;
    public static FileState Absent;
    public static FileState Exists;
}
public enum Unity.IO.LowLevel.Unsafe.FileStatus : Enum {
    public int value__;
    public static FileStatus Closed;
    public static FileStatus Pending;
    public static FileStatus Open;
    public static FileStatus OpenFailed;
}
[RequiredByNativeCodeAttribute]
public enum Unity.IO.LowLevel.Unsafe.Priority : Enum {
    public int value__;
    public static Priority PriorityLow;
    public static Priority PriorityHigh;
}
[NativeHeaderAttribute("Runtime/File/AsyncReadManagerMetrics.h")]
public enum Unity.IO.LowLevel.Unsafe.ProcessingState : Enum {
    public int value__;
    public static ProcessingState Unknown;
    public static ProcessingState InQueue;
    public static ProcessingState Reading;
    public static ProcessingState Completed;
    public static ProcessingState Failed;
    public static ProcessingState Canceled;
}
public class Unity.IO.LowLevel.Unsafe.ReadCommand : ValueType {
    public Void* Buffer;
    public long Offset;
    public long Size;
}
public class Unity.IO.LowLevel.Unsafe.ReadCommandArray : ValueType {
    public ReadCommand* ReadCommands;
    public int CommandCount;
}
public class Unity.IO.LowLevel.Unsafe.ReadHandle : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal IntPtr ptr;
    internal int version;
    public JobHandle JobHandle { get; }
    public ReadStatus Status { get; }
    public long ReadCount { get; }
    public bool IsValid();
    public sealed virtual void Dispose();
    public void Cancel();
    [FreeFunctionAttribute("AsyncReadManagerManaged::CancelReadRequest")]
private static void CancelInternal(ReadHandle handle);
    public JobHandle get_JobHandle();
    public ReadStatus get_Status();
    public long get_ReadCount();
    public long GetBytesRead();
    public long GetBytesRead(UInt32 readCommandIndex);
    public UInt64* GetBytesReadArray();
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::GetReadStatus")]
private static ReadStatus GetReadStatus(ReadHandle handle);
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::GetReadCount")]
private static long GetReadCount(ReadHandle handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetBytesRead")]
[ThreadAndSerializationSafeAttribute]
private static long GetBytesRead(ReadHandle handle);
    [ThreadAndSerializationSafeAttribute]
[FreeFunctionAttribute("AsyncReadManagerManaged::GetBytesReadForCommand")]
private static long GetBytesReadForCommand(ReadHandle handle, UInt32 readCommandIndex);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetBytesReadArray")]
[ThreadAndSerializationSafeAttribute]
private static UInt64* GetBytesReadArray(ReadHandle handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::ReleaseReadHandle")]
[ThreadAndSerializationSafeAttribute]
private static void ReleaseReadHandle(ReadHandle handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::IsReadHandleValid")]
[ThreadAndSerializationSafeAttribute]
private static bool IsReadHandleValid(ReadHandle handle);
    [FreeFunctionAttribute("AsyncReadManagerManaged::GetJobHandle")]
[ThreadAndSerializationSafeAttribute]
private static JobHandle GetJobHandle(ReadHandle handle);
    private static void CancelInternal_Injected(ReadHandle& handle);
    private static ReadStatus GetReadStatus_Injected(ReadHandle& handle);
    private static long GetReadCount_Injected(ReadHandle& handle);
    private static long GetBytesRead_Injected(ReadHandle& handle);
    private static long GetBytesReadForCommand_Injected(ReadHandle& handle, UInt32 readCommandIndex);
    private static UInt64* GetBytesReadArray_Injected(ReadHandle& handle);
    private static void ReleaseReadHandle_Injected(ReadHandle& handle);
    private static bool IsReadHandleValid_Injected(ReadHandle& handle);
    private static void GetJobHandle_Injected(ReadHandle& handle, JobHandle& ret);
}
public enum Unity.IO.LowLevel.Unsafe.ReadStatus : Enum {
    public int value__;
    public static ReadStatus Complete;
    public static ReadStatus InProgress;
    public static ReadStatus Failed;
    public static ReadStatus Truncated;
    public static ReadStatus Canceled;
}
[NativeHeaderAttribute("Runtime/VirtualFileSystem/VirtualFileSystem.h")]
[StaticAccessorAttribute("GetFileSystem()", "0")]
public static class Unity.IO.LowLevel.Unsafe.VirtualFileSystem : object {
    [FreeFunctionAttribute]
public static bool GetLocalFileSystemName(string vfsFileName, String& localFileName, UInt64& localFileOffset, UInt64& localFileSize);
    internal static string ToLogicalPath(string physicalPath);
}
[JobProducerTypeAttribute("Unity.Jobs.IJobExtensions/JobStruct`1")]
public interface Unity.Jobs.IJob {
    public abstract virtual void Execute();
}
[ExtensionAttribute]
public static class Unity.Jobs.IJobExtensions : object {
    public static void EarlyJobInit();
    private static IntPtr GetReflectionData();
    [ExtensionAttribute]
public static JobHandle Schedule(T jobData, JobHandle dependsOn);
    [ExtensionAttribute]
public static void Run(T jobData);
    [ExtensionAttribute]
public static JobHandle ScheduleByRef(T& jobData, JobHandle dependsOn);
    [ExtensionAttribute]
public static void RunByRef(T& jobData);
}
[JobProducerTypeAttribute("Unity.Jobs.IJobForExtensions/ForJobStruct`1")]
public interface Unity.Jobs.IJobFor {
    public abstract virtual void Execute(int index);
}
[ExtensionAttribute]
public static class Unity.Jobs.IJobForExtensions : object {
    public static void EarlyJobInit();
    private static IntPtr GetReflectionData();
    [ExtensionAttribute]
public static JobHandle Schedule(T jobData, int arrayLength, JobHandle dependency);
    [ExtensionAttribute]
public static JobHandle ScheduleParallel(T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependency);
    [ExtensionAttribute]
public static void Run(T jobData, int arrayLength);
    [ExtensionAttribute]
public static JobHandle ScheduleByRef(T& jobData, int arrayLength, JobHandle dependency);
    [ExtensionAttribute]
public static JobHandle ScheduleParallelByRef(T& jobData, int arrayLength, int innerloopBatchCount, JobHandle dependency);
    [ExtensionAttribute]
public static void RunByRef(T& jobData, int arrayLength);
}
[JobProducerTypeAttribute("Unity.Jobs.IJobParallelForExtensions/ParallelForJobStruct`1")]
public interface Unity.Jobs.IJobParallelFor {
    public abstract virtual void Execute(int index);
}
[ExtensionAttribute]
public static class Unity.Jobs.IJobParallelForExtensions : object {
    public static void EarlyJobInit();
    private static IntPtr GetReflectionData();
    [ExtensionAttribute]
public static JobHandle Schedule(T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependsOn);
    [ExtensionAttribute]
public static void Run(T jobData, int arrayLength);
    [ExtensionAttribute]
public static JobHandle ScheduleByRef(T& jobData, int arrayLength, int innerloopBatchCount, JobHandle dependsOn);
    [ExtensionAttribute]
public static void RunByRef(T& jobData, int arrayLength);
}
[NativeTypeAttribute]
public class Unity.Jobs.JobHandle : ValueType {
    internal ulong jobGroup;
    internal int version;
    public bool IsCompleted { get; }
    public void Complete();
    public static void CompleteAll(JobHandle& job0, JobHandle& job1);
    public static void CompleteAll(JobHandle& job0, JobHandle& job1, JobHandle& job2);
    public static void CompleteAll(NativeArray`1<JobHandle> jobs);
    public bool get_IsCompleted();
    [NativeMethodAttribute("ScheduleBatchedScriptingJobs")]
public static void ScheduleBatchedJobs();
    [NativeMethodAttribute("ScheduleBatchedScriptingJobsAndComplete")]
private static void ScheduleBatchedJobsAndComplete(JobHandle& job);
    [NativeMethodAttribute("ScheduleBatchedScriptingJobsAndIsCompleted")]
private static bool ScheduleBatchedJobsAndIsCompleted(JobHandle& job);
    [NativeMethodAttribute("ScheduleBatchedScriptingJobsAndCompleteAll")]
private static void ScheduleBatchedJobsAndCompleteAll(Void* jobs, int count);
    public static JobHandle CombineDependencies(JobHandle job0, JobHandle job1);
    public static JobHandle CombineDependencies(JobHandle job0, JobHandle job1, JobHandle job2);
    public static JobHandle CombineDependencies(NativeArray`1<JobHandle> jobs);
    public static JobHandle CombineDependencies(NativeSlice`1<JobHandle> jobs);
    [NativeMethodAttribute]
private static JobHandle CombineDependenciesInternal2(JobHandle& job0, JobHandle& job1);
    [NativeMethodAttribute]
private static JobHandle CombineDependenciesInternal3(JobHandle& job0, JobHandle& job1, JobHandle& job2);
    [NativeMethodAttribute]
internal static JobHandle CombineDependenciesInternalPtr(Void* jobs, int count);
    [NativeMethodAttribute]
public static bool CheckFenceIsDependencyOrDidSyncFence(JobHandle jobHandle, JobHandle dependsOn);
    public sealed virtual bool Equals(JobHandle other);
    private static void CombineDependenciesInternal2_Injected(JobHandle& job0, JobHandle& job1, JobHandle& ret);
    private static void CombineDependenciesInternal3_Injected(JobHandle& job0, JobHandle& job1, JobHandle& job2, JobHandle& ret);
    private static void CombineDependenciesInternalPtr_Injected(Void* jobs, int count, JobHandle& ret);
    private static bool CheckFenceIsDependencyOrDidSyncFence_Injected(JobHandle& jobHandle, JobHandle& dependsOn);
}
internal static class Unity.Jobs.JobValidationInternal : object {
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal static void CheckReflectionDataCorrect(IntPtr reflectionData);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
[BurstDiscardAttribute]
private static void CheckReflectionDataCorrectInternal(IntPtr reflectionData, Boolean& burstCompiled);
}
public class Unity.Jobs.LowLevel.Unsafe.BatchQueryJob`2 : ValueType {
    [ReadOnlyAttribute]
internal NativeArray`1<CommandT> commands;
    internal NativeArray`1<ResultT> results;
    public BatchQueryJob`2(NativeArray`1<CommandT> commands, NativeArray`1<ResultT> results);
}
public class Unity.Jobs.LowLevel.Unsafe.BatchQueryJobStruct`1 : ValueType {
    internal static IntPtr jobReflectionData;
    public static IntPtr Initialize();
}
public static class Unity.Jobs.LowLevel.Unsafe.JobHandleUnsafeUtility : object {
    public static JobHandle CombineDependencies(JobHandle* jobs, int count);
}
[AttributeUsageAttribute("1024")]
public class Unity.Jobs.LowLevel.Unsafe.JobProducerTypeAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Type <ProducerType>k__BackingField;
    public Type ProducerType { get; }
    public JobProducerTypeAttribute(Type producerType);
    [CompilerGeneratedAttribute]
public Type get_ProducerType();
}
public class Unity.Jobs.LowLevel.Unsafe.JobRanges : ValueType {
    internal int BatchSize;
    internal int NumJobs;
    public int TotalIterationCount;
    internal IntPtr StartEndIndex;
}
[NativeTypeAttribute]
[NativeHeaderAttribute("Runtime/Jobs/JobSystem.h")]
public static class Unity.Jobs.LowLevel.Unsafe.JobsUtility : object {
    public static int MaxJobThreadCount;
    public static int CacheLineSize;
    internal static PanicFunction_ PanicFunction;
    public static bool IsExecutingJob { get; }
    public static bool JobDebuggerEnabled { get; public set; }
    public static bool JobCompilerEnabled { get; public set; }
    public static int JobWorkerMaximumCount { get; }
    public static int JobWorkerCount { get; public set; }
    public static int ThreadIndex { get; }
    public static int ThreadIndexCount { get; }
    internal static bool JobBatchingEnabled { get; }
    public static void GetJobRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex);
    [NativeMethodAttribute]
public static bool GetWorkStealingRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex);
    [FreeFunctionAttribute("ScheduleManagedJob")]
public static JobHandle Schedule(JobScheduleParameters& parameters);
    [FreeFunctionAttribute("ScheduleManagedJobParallelFor")]
public static JobHandle ScheduleParallelFor(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount);
    [FreeFunctionAttribute("ScheduleManagedJobParallelForDeferArraySize")]
public static JobHandle ScheduleParallelForDeferArraySize(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle);
    [FreeFunctionAttribute("ScheduleManagedJobParallelForTransform")]
public static JobHandle ScheduleParallelForTransform(JobScheduleParameters& parameters, IntPtr transfromAccesssArray);
    [FreeFunctionAttribute("ScheduleManagedJobParallelForTransformReadOnly")]
public static JobHandle ScheduleParallelForTransformReadOnly(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, int innerloopBatchCount);
    [NativeMethodAttribute]
[ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
public static void PatchBufferMinMaxRanges(IntPtr bufferRangePatchData, Void* jobdata, int startIndex, int rangeSize);
    [FreeFunctionAttribute]
private static IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2);
    [ObsoleteAttribute("JobType is obsolete. The parameter should be removed. (UnityUpgradable) -> !1")]
public static IntPtr CreateJobReflectionData(Type type, JobType jobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2);
    public static IntPtr CreateJobReflectionData(Type type, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2);
    [ObsoleteAttribute("JobType is obsolete. The parameter should be removed. (UnityUpgradable) -> !2")]
public static IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, JobType jobType, object managedJobFunction0);
    public static IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, object managedJobFunction0);
    [NativeMethodAttribute]
public static bool get_IsExecutingJob();
    [FreeFunctionAttribute]
public static bool get_JobDebuggerEnabled();
    [FreeFunctionAttribute]
public static void set_JobDebuggerEnabled(bool value);
    [FreeFunctionAttribute]
public static bool get_JobCompilerEnabled();
    [FreeFunctionAttribute]
public static void set_JobCompilerEnabled(bool value);
    [FreeFunctionAttribute("JobSystem::GetJobQueueWorkerThreadCount")]
private static int GetJobQueueWorkerThreadCount();
    [FreeFunctionAttribute("JobSystem::ForceSetJobQueueWorkerThreadCount")]
private static void SetJobQueueMaximumActiveThreadCount(int count);
    [FreeFunctionAttribute("JobSystem::GetJobQueueMaximumThreadCount")]
public static int get_JobWorkerMaximumCount();
    [FreeFunctionAttribute("JobSystem::ResetJobQueueWorkerThreadCount")]
public static void ResetJobWorkerCount();
    public static int get_JobWorkerCount();
    public static void set_JobWorkerCount(int value);
    [FreeFunctionAttribute("GetJobWorkerIndex")]
[BurstAuthorizedExternalMethodAttribute]
public static int get_ThreadIndex();
    [BurstAuthorizedExternalMethodAttribute]
[FreeFunctionAttribute("GetJobWorkerIndexCount")]
public static int get_ThreadIndexCount();
    [FreeFunctionAttribute("IsJobQueueBatchingEnabled")]
private static bool GetJobBatchingEnabled();
    internal static bool get_JobBatchingEnabled();
    [FreeFunctionAttribute("JobDebuggerGetSystemIdCellPtr")]
internal static IntPtr GetSystemIdCellPtr();
    [FreeFunctionAttribute("JobDebuggerClearSystemIds")]
internal static void ClearSystemIds();
    [FreeFunctionAttribute("JobDebuggerGetSystemIdMappings")]
internal static int GetSystemIdMappings(JobHandle* handles, Int32* systemIds, int maxCount);
    [RequiredByNativeCodeAttribute]
private static void InvokePanicFunction();
    private static void Schedule_Injected(JobScheduleParameters& parameters, JobHandle& ret);
    private static void ScheduleParallelFor_Injected(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount, JobHandle& ret);
    private static void ScheduleParallelForDeferArraySize_Injected(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle, JobHandle& ret);
    private static void ScheduleParallelForTransform_Injected(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, JobHandle& ret);
    private static void ScheduleParallelForTransformReadOnly_Injected(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, int innerloopBatchCount, JobHandle& ret);
}
[ObsoleteAttribute("Reflection data is now universal between job types. The parameter can be removed.", "False")]
public enum Unity.Jobs.LowLevel.Unsafe.JobType : Enum {
    public int value__;
    public static JobType Single;
    public static JobType ParallelFor;
}
public enum Unity.Jobs.LowLevel.Unsafe.ScheduleMode : Enum {
    public int value__;
    public static ScheduleMode Run;
    [ObsoleteAttribute("Batched is obsolete, use Parallel or Single depending on job type. (UnityUpgradable) -> Parallel", "False")]
public static ScheduleMode Batched;
    public static ScheduleMode Parallel;
    public static ScheduleMode Single;
}
public class Unity.Profiling.DebugScreenCapture : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private NativeArray`1<byte> <RawImageDataReference>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private TextureFormat <ImageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Height>k__BackingField;
    public NativeArray`1<byte> RawImageDataReference { get; public set; }
    public TextureFormat ImageFormat { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public NativeArray`1<byte> get_RawImageDataReference();
    [CompilerGeneratedAttribute]
public void set_RawImageDataReference(NativeArray`1<byte> value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public TextureFormat get_ImageFormat();
    [CompilerGeneratedAttribute]
public void set_ImageFormat(TextureFormat value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
}
[AttributeUsageAttribute("76")]
[RequiredByNativeCodeAttribute]
public class Unity.Profiling.IgnoredByDeepProfilerAttribute : Attribute {
}
[FlagsAttribute]
public enum Unity.Profiling.LowLevel.MarkerFlags : Enum {
    public ushort value__;
    public static MarkerFlags Default;
    public static MarkerFlags Script;
    public static MarkerFlags ScriptInvoke;
    public static MarkerFlags ScriptDeepProfiler;
    public static MarkerFlags AvailabilityEditor;
    public static MarkerFlags AvailabilityNonDevelopment;
    public static MarkerFlags Warning;
    public static MarkerFlags Counter;
    public static MarkerFlags SampleGPU;
}
public enum Unity.Profiling.LowLevel.ProfilerMarkerDataType : Enum {
    public byte value__;
    public static ProfilerMarkerDataType InstanceId;
    public static ProfilerMarkerDataType Int32;
    public static ProfilerMarkerDataType UInt32;
    public static ProfilerMarkerDataType Int64;
    public static ProfilerMarkerDataType UInt64;
    public static ProfilerMarkerDataType Float;
    public static ProfilerMarkerDataType Double;
    public static ProfilerMarkerDataType String16;
    public static ProfilerMarkerDataType Blob8;
    public static ProfilerMarkerDataType GfxResourceId;
}
[IsReadOnlyAttribute]
public class Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription : ValueType {
    public ushort Id;
    public ushort Flags;
    public Color32 Color;
    private int reserved0;
    public int NameUtf8Len;
    public Byte* NameUtf8;
    public string Name { get; }
    public string get_Name();
}
public class Unity.Profiling.LowLevel.Unsafe.ProfilerMarkerData : ValueType {
    public byte Type;
    private byte reserved0;
    private ushort reserved1;
    public UInt32 Size;
    public Void* Ptr;
}
[IsReadOnlyAttribute]
[UsedByNativeCodeAttribute]
public class Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription : ValueType {
    private ProfilerCategory category;
    private MarkerFlags flags;
    private ProfilerMarkerDataType dataType;
    private ProfilerMarkerDataUnit unitType;
    private int reserved0;
    private int nameUtf8Len;
    private Byte* nameUtf8;
    public ProfilerCategory Category { get; }
    public MarkerFlags Flags { get; }
    public ProfilerMarkerDataType DataType { get; }
    public ProfilerMarkerDataUnit UnitType { get; }
    public int NameUtf8Len { get; }
    public Byte* NameUtf8 { get; }
    public string Name { get; }
    public ProfilerCategory get_Category();
    public MarkerFlags get_Flags();
    public ProfilerMarkerDataType get_DataType();
    public ProfilerMarkerDataUnit get_UnitType();
    public int get_NameUtf8Len();
    public Byte* get_NameUtf8();
    public string get_Name();
}
[IsReadOnlyAttribute]
[UsedByNativeCodeAttribute]
public class Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle : ValueType {
    private static ulong k_InvalidHandle;
    internal ulong handle;
    public bool Valid { get; }
    internal ProfilerRecorderHandle(ulong handle);
    public bool get_Valid();
    internal static ProfilerRecorderHandle Get(ProfilerMarker marker);
    internal static ProfilerRecorderHandle Get(ProfilerCategory category, string statName);
    public static ProfilerRecorderDescription GetDescription(ProfilerRecorderHandle handle);
    [NativeMethodAttribute]
public static void GetAvailable(List`1<ProfilerRecorderHandle> outRecorderHandleList);
    [NativeMethodAttribute]
internal static ProfilerRecorderHandle GetByName(ProfilerCategory category, string name);
    [NativeMethodAttribute]
[RequiredMemberAttribute]
internal static ProfilerRecorderHandle GetByName__Unmanaged(ProfilerCategory category, Byte* name, int nameLen);
    internal static ProfilerRecorderHandle GetByName(ProfilerCategory category, Char* name, int nameLen);
    [NativeMethodAttribute]
private static ProfilerRecorderHandle GetByName_Unsafe(ProfilerCategory category, Char* name, int nameLen);
    [NativeMethodAttribute]
private static ProfilerRecorderDescription GetDescriptionInternal(ProfilerRecorderHandle handle);
    private static void GetByName_Injected(ProfilerCategory& category, string name, ProfilerRecorderHandle& ret);
    private static void GetByName__Unmanaged_Injected(ProfilerCategory& category, Byte* name, int nameLen, ProfilerRecorderHandle& ret);
    private static void GetByName_Unsafe_Injected(ProfilerCategory& category, Char* name, int nameLen, ProfilerRecorderHandle& ret);
    private static void GetDescriptionInternal_Injected(ProfilerRecorderHandle& handle, ProfilerRecorderDescription& ret);
}
[UsedByNativeCodeAttribute]
[IgnoredByDeepProfilerAttribute]
[NativeHeaderAttribute("Runtime/Profiler/ScriptBindings/ProfilerUnsafeUtility.bindings.h")]
public static class Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility : object {
    public static ushort CategoryRender;
    public static ushort CategoryScripts;
    public static ushort CategoryGUI;
    public static ushort CategoryPhysics;
    public static ushort CategoryAnimation;
    public static ushort CategoryAi;
    public static ushort CategoryAudio;
    public static ushort CategoryVideo;
    public static ushort CategoryParticles;
    public static ushort CategoryLighting;
    [ObsoleteAttribute("CategoryLightning has been renamed. Use CategoryLighting instead (UnityUpgradable) -> CategoryLighting", "False")]
public static ushort CategoryLightning;
    public static ushort CategoryNetwork;
    public static ushort CategoryLoading;
    public static ushort CategoryOther;
    public static ushort CategoryVr;
    public static ushort CategoryAllocation;
    public static ushort CategoryInternal;
    public static ushort CategoryFileIO;
    public static ushort CategoryInput;
    public static ushort CategoryVirtualTexturing;
    internal static ushort CategoryGPU;
    public static ushort CategoryPhysics2D;
    internal static ushort CategoryAny;
    public static long Timestamp { get; }
    public static TimestampConversionRatio TimestampToNanosecondsConversionRatio { get; }
    [ThreadSafeAttribute]
internal static ushort CreateCategory(string name, ProfilerCategoryColor colorIndex);
    [ThreadSafeAttribute]
[RequiredMemberAttribute]
internal static ushort CreateCategory__Unmanaged(Byte* name, int nameLen, ProfilerCategoryColor colorIndex);
    public static ushort CreateCategory(Char* name, int nameLen, ProfilerCategoryColor colorIndex);
    [ThreadSafeAttribute]
private static ushort CreateCategory_Unsafe(Char* name, int nameLen, ProfilerCategoryColor colorIndex);
    public static ushort GetCategoryByName(Char* name, int nameLen);
    [ThreadSafeAttribute]
private static ushort GetCategoryByName_Unsafe(Char* name, int nameLen);
    [ThreadSafeAttribute]
public static ProfilerCategoryDescription GetCategoryDescription(ushort categoryId);
    [ThreadSafeAttribute]
internal static Color32 GetCategoryColor(ProfilerCategoryColor colorIndex);
    [ThreadSafeAttribute]
public static IntPtr CreateMarker(string name, ushort categoryId, MarkerFlags flags, int metadataCount);
    [ThreadSafeAttribute]
[RequiredMemberAttribute]
internal static IntPtr CreateMarker__Unmanaged(Byte* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount);
    public static IntPtr CreateMarker(Char* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount);
    [ThreadSafeAttribute]
private static IntPtr CreateMarker_Unsafe(Char* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount);
    [ThreadSafeAttribute]
internal static IntPtr GetMarker(string name);
    [ThreadSafeAttribute]
public static void SetMarkerMetadata(IntPtr markerPtr, int index, string name, byte type, byte unit);
    [RequiredMemberAttribute]
[ThreadSafeAttribute]
internal static void SetMarkerMetadata__Unmanaged(IntPtr markerPtr, int index, Byte* name, int nameLen, byte type, byte unit);
    public static void SetMarkerMetadata(IntPtr markerPtr, int index, Char* name, int nameLen, byte type, byte unit);
    [ThreadSafeAttribute]
private static void SetMarkerMetadata_Unsafe(IntPtr markerPtr, int index, Char* name, int nameLen, byte type, byte unit);
    [ThreadSafeAttribute]
public static void BeginSample(IntPtr markerPtr);
    [ThreadSafeAttribute]
public static void BeginSampleWithMetadata(IntPtr markerPtr, int metadataCount, Void* metadata);
    [ThreadSafeAttribute]
public static void EndSample(IntPtr markerPtr);
    [ThreadSafeAttribute]
public static void SingleSampleWithMetadata(IntPtr markerPtr, int metadataCount, Void* metadata);
    [ThreadSafeAttribute]
public static Void* CreateCounterValue(IntPtr& counterPtr, string name, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
    [ThreadSafeAttribute]
[RequiredMemberAttribute]
internal static Void* CreateCounterValue__Unmanaged(IntPtr& counterPtr, Byte* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
    public static Void* CreateCounterValue(IntPtr& counterPtr, Char* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
    [ThreadSafeAttribute]
private static Void* CreateCounterValue_Unsafe(IntPtr& counterPtr, Char* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions);
    [ThreadSafeAttribute]
public static void FlushCounterValue(Void* counterValuePtr);
    internal static string Utf8ToString(Byte* chars, int charsLen);
    [ThreadSafeAttribute]
public static UInt32 CreateFlow(ushort categoryId);
    [ThreadSafeAttribute]
public static void FlowEvent(UInt32 flowId, ProfilerFlowEventType flowEventType);
    [ThreadSafeAttribute]
internal static void Internal_BeginWithObject(IntPtr markerPtr, Object contextUnityObject);
    [NativeConditionalAttribute("ENABLE_PROFILER")]
internal static string Internal_GetName(IntPtr markerPtr);
    [ThreadSafeAttribute]
public static long get_Timestamp();
    [ThreadSafeAttribute]
public static TimestampConversionRatio get_TimestampToNanosecondsConversionRatio();
    private static void GetCategoryDescription_Injected(ushort categoryId, ProfilerCategoryDescription& ret);
    private static void GetCategoryColor_Injected(ProfilerCategoryColor colorIndex, Color32& ret);
    private static void get_TimestampToNanosecondsConversionRatio_Injected(TimestampConversionRatio& ret);
}
[FlagsAttribute]
public enum Unity.Profiling.Memory.CaptureFlags : Enum {
    public UInt32 value__;
    public static CaptureFlags ManagedObjects;
    public static CaptureFlags NativeObjects;
    public static CaptureFlags NativeAllocations;
    public static CaptureFlags NativeAllocationSites;
    public static CaptureFlags NativeStackTraces;
}
[NativeHeaderAttribute("Modules/Profiler/Runtime/MemorySnapshotManager.h")]
public static class Unity.Profiling.Memory.MemoryProfiler : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<string, bool> m_SnapshotFinished;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`3<string, bool, DebugScreenCapture> m_SaveScreenshotToDisk;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<MemorySnapshotMetadata> CreatingMetadata;
    [CompilerGeneratedAttribute]
private static void add_m_SnapshotFinished(Action`2<string, bool> value);
    [CompilerGeneratedAttribute]
private static void remove_m_SnapshotFinished(Action`2<string, bool> value);
    [CompilerGeneratedAttribute]
private static void add_m_SaveScreenshotToDisk(Action`3<string, bool, DebugScreenCapture> value);
    [CompilerGeneratedAttribute]
private static void remove_m_SaveScreenshotToDisk(Action`3<string, bool, DebugScreenCapture> value);
    [CompilerGeneratedAttribute]
public static void add_CreatingMetadata(Action`1<MemorySnapshotMetadata> value);
    [CompilerGeneratedAttribute]
public static void remove_CreatingMetadata(Action`1<MemorySnapshotMetadata> value);
    [StaticAccessorAttribute("profiling::memory::GetMemorySnapshotManager()", "0")]
[NativeMethodAttribute("StartOperation")]
[NativeConditionalAttribute("ENABLE_PROFILER")]
private static void StartOperation(UInt32 captureFlag, bool requestScreenshot, string path, bool isRemote);
    public static void TakeSnapshot(string path, Action`2<string, bool> finishCallback, CaptureFlags captureFlags);
    public static void TakeSnapshot(string path, Action`2<string, bool> finishCallback, Action`3<string, bool, DebugScreenCapture> screenshotCallback, CaptureFlags captureFlags);
    public static void TakeTempSnapshot(Action`2<string, bool> finishCallback, CaptureFlags captureFlags);
    [RequiredByNativeCodeAttribute]
private static Byte[] PrepareMetadata();
    internal static int WriteIntToByteArray(Byte[] array, int offset, int value);
    internal static int WriteStringToByteArray(Byte[] array, int offset, string value);
    [RequiredByNativeCodeAttribute]
private static void FinalizeSnapshot(string path, bool result);
    [RequiredByNativeCodeAttribute]
private static void SaveScreenshotToDisk(string path, bool result, IntPtr pixelsPtr, int pixelsCount, TextureFormat format, int width, int height);
}
public class Unity.Profiling.Memory.MemorySnapshotMetadata : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public string Description { get; public set; }
    internal Byte[] Data { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
internal void set_Data(Byte[] value);
}
[UsedByNativeCodeAttribute]
[IsReadOnlyAttribute]
public class Unity.Profiling.ProfilerCategory : ValueType {
    private ushort m_CategoryId;
    public string Name { get; }
    public Color32 Color { get; }
    public static ProfilerCategory Render { get; }
    public static ProfilerCategory Scripts { get; }
    public static ProfilerCategory Gui { get; }
    public static ProfilerCategory Physics { get; }
    public static ProfilerCategory Physics2D { get; }
    public static ProfilerCategory Animation { get; }
    public static ProfilerCategory Ai { get; }
    public static ProfilerCategory Audio { get; }
    public static ProfilerCategory Video { get; }
    public static ProfilerCategory Particles { get; }
    public static ProfilerCategory Lighting { get; }
    public static ProfilerCategory Network { get; }
    public static ProfilerCategory Loading { get; }
    public static ProfilerCategory Vr { get; }
    public static ProfilerCategory Input { get; }
    public static ProfilerCategory Memory { get; }
    public static ProfilerCategory VirtualTexturing { get; }
    public static ProfilerCategory FileIO { get; }
    public static ProfilerCategory Internal { get; }
    internal static ProfilerCategory Any { get; }
    internal static ProfilerCategory GPU { get; }
    public ProfilerCategory(string categoryName);
    public ProfilerCategory(string categoryName, ProfilerCategoryColor color);
    internal ProfilerCategory(ushort category);
    public string get_Name();
    public Color32 get_Color();
    public virtual string ToString();
    public static ProfilerCategory get_Render();
    public static ProfilerCategory get_Scripts();
    public static ProfilerCategory get_Gui();
    public static ProfilerCategory get_Physics();
    public static ProfilerCategory get_Physics2D();
    public static ProfilerCategory get_Animation();
    public static ProfilerCategory get_Ai();
    public static ProfilerCategory get_Audio();
    public static ProfilerCategory get_Video();
    public static ProfilerCategory get_Particles();
    public static ProfilerCategory get_Lighting();
    public static ProfilerCategory get_Network();
    public static ProfilerCategory get_Loading();
    public static ProfilerCategory get_Vr();
    public static ProfilerCategory get_Input();
    public static ProfilerCategory get_Memory();
    public static ProfilerCategory get_VirtualTexturing();
    public static ProfilerCategory get_FileIO();
    public static ProfilerCategory get_Internal();
    internal static ProfilerCategory get_Any();
    internal static ProfilerCategory get_GPU();
    public static ushort op_Implicit(ProfilerCategory category);
}
public enum Unity.Profiling.ProfilerCategoryColor : Enum {
    public ushort value__;
    public static ProfilerCategoryColor Render;
    public static ProfilerCategoryColor Scripts;
    public static ProfilerCategoryColor BurstJobs;
    public static ProfilerCategoryColor Other;
    public static ProfilerCategoryColor Physics;
    public static ProfilerCategoryColor Animation;
    public static ProfilerCategoryColor Audio;
    public static ProfilerCategoryColor AudioJob;
    public static ProfilerCategoryColor AudioUpdateJob;
    public static ProfilerCategoryColor Lighting;
    public static ProfilerCategoryColor GC;
    public static ProfilerCategoryColor VSync;
    public static ProfilerCategoryColor Memory;
    public static ProfilerCategoryColor Internal;
    public static ProfilerCategoryColor UI;
    public static ProfilerCategoryColor Build;
    public static ProfilerCategoryColor Input;
}
[FlagsAttribute]
public enum Unity.Profiling.ProfilerCategoryFlags : Enum {
    public ushort value__;
    public static ProfilerCategoryFlags None;
    public static ProfilerCategoryFlags Builtin;
}
[FlagsAttribute]
public enum Unity.Profiling.ProfilerCounterOptions : Enum {
    public ushort value__;
    public static ProfilerCounterOptions None;
    public static ProfilerCounterOptions FlushOnEndOfFrame;
    public static ProfilerCounterOptions ResetToZeroOnFlush;
}
public enum Unity.Profiling.ProfilerFlowEventType : Enum {
    public byte value__;
    public static ProfilerFlowEventType Begin;
    public static ProfilerFlowEventType ParallelNext;
    public static ProfilerFlowEventType End;
    public static ProfilerFlowEventType Next;
}
[UsedByNativeCodeAttribute]
[IgnoredByDeepProfilerAttribute]
public class Unity.Profiling.ProfilerMarker : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal IntPtr m_Ptr;
    public IntPtr Handle { get; }
    public ProfilerMarker(string name);
    public ProfilerMarker(Char* name, int nameLen);
    public ProfilerMarker(ProfilerCategory category, string name);
    public ProfilerMarker(ProfilerCategory category, Char* name, int nameLen);
    public ProfilerMarker(ProfilerCategory category, string name, MarkerFlags flags);
    public ProfilerMarker(ProfilerCategory category, Char* name, int nameLen, MarkerFlags flags);
    public IntPtr get_Handle();
    [PureAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public void Begin();
    [ConditionalAttribute("ENABLE_PROFILER")]
public void Begin(Object contextUnityObject);
    [PureAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public void End();
    [ConditionalAttribute("ENABLE_PROFILER")]
internal void GetName(String& name);
    [PureAttribute]
public AutoScope Auto();
}
public enum Unity.Profiling.ProfilerMarkerDataUnit : Enum {
    public byte value__;
    public static ProfilerMarkerDataUnit Undefined;
    public static ProfilerMarkerDataUnit TimeNanoseconds;
    public static ProfilerMarkerDataUnit Bytes;
    public static ProfilerMarkerDataUnit Count;
    public static ProfilerMarkerDataUnit Percent;
    public static ProfilerMarkerDataUnit FrequencyHz;
}
internal class Unity.Profiling.ProfilerMarkerWithStringData : ValueType {
    private static MethodImplOptions AggressiveInlining;
    private IntPtr _marker;
    public static ProfilerMarkerWithStringData Create(string name, string parameterName);
    [PureAttribute]
public AutoScope Auto(bool enabled, Func`1<string> parameterValue);
    [PureAttribute]
public AutoScope Auto(string value);
}
[DebuggerTypeProxyAttribute("Unity.Profiling.ProfilerRecorderDebugView")]
[UsedByNativeCodeAttribute]
[DebuggerDisplayAttribute("Count = {Count}")]
[NativeHeaderAttribute("Runtime/Profiler/ScriptBindings/ProfilerRecorder.bindings.h")]
public class Unity.Profiling.ProfilerRecorder : ValueType {
    internal ulong handle;
    internal static ProfilerRecorderOptions SharedRecorder;
    public bool Valid { get; }
    public ProfilerMarkerDataType DataType { get; }
    public ProfilerMarkerDataUnit UnitType { get; }
    public long CurrentValue { get; }
    public double CurrentValueAsDouble { get; }
    public long LastValue { get; }
    public double LastValueAsDouble { get; }
    public int Capacity { get; }
    public int Count { get; }
    public bool IsRunning { get; }
    public bool WrappedAround { get; }
    internal ProfilerRecorder(ProfilerRecorderOptions options);
    public ProfilerRecorder(string statName, int capacity, ProfilerRecorderOptions options);
    public ProfilerRecorder(string categoryName, string statName, int capacity, ProfilerRecorderOptions options);
    public ProfilerRecorder(ProfilerCategory category, string statName, int capacity, ProfilerRecorderOptions options);
    public ProfilerRecorder(ProfilerCategory category, Char* statName, int statNameLen, int capacity, ProfilerRecorderOptions options);
    public ProfilerRecorder(ProfilerMarker marker, int capacity, ProfilerRecorderOptions options);
    public ProfilerRecorder(ProfilerRecorderHandle statHandle, int capacity, ProfilerRecorderOptions options);
    public static ProfilerRecorder StartNew(ProfilerCategory category, string statName, int capacity, ProfilerRecorderOptions options);
    public static ProfilerRecorder StartNew(ProfilerMarker marker, int capacity, ProfilerRecorderOptions options);
    internal static ProfilerRecorder StartNew();
    public bool get_Valid();
    public ProfilerMarkerDataType get_DataType();
    public ProfilerMarkerDataUnit get_UnitType();
    public void Start();
    public void Stop();
    public void Reset();
    public long get_CurrentValue();
    public double get_CurrentValueAsDouble();
    public long get_LastValue();
    public double get_LastValueAsDouble();
    public int get_Capacity();
    public int get_Count();
    public bool get_IsRunning();
    public bool get_WrappedAround();
    public ProfilerRecorderSample GetSample(int index);
    public void CopyTo(List`1<ProfilerRecorderSample> outSamples, bool reset);
    public int CopyTo(ProfilerRecorderSample* dest, int destSize, bool reset);
    public ProfilerRecorderSample[] ToArray();
    internal void FilterToCurrentThread();
    internal void CollectFromAllThreads();
    [NativeMethodAttribute]
private static ProfilerRecorder Create(ProfilerRecorderHandle statHandle, int maxSampleCount, ProfilerRecorderOptions options);
    [NativeMethodAttribute]
private static void Control(ProfilerRecorder handle, ControlOptions options);
    [NativeMethodAttribute]
private static ProfilerMarkerDataUnit GetValueUnitType(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static ProfilerMarkerDataType GetValueDataType(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static long GetCurrentValue(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static double GetCurrentValueAsDouble(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static long GetLastValue(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static double GetLastValueAsDouble(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static int GetCount(ProfilerRecorder handle, CountOptions countOptions);
    [NativeMethodAttribute]
private static bool GetValid(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static bool GetWrapped(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static bool GetRunning(ProfilerRecorder handle);
    [NativeMethodAttribute]
private static ProfilerRecorderSample GetSampleInternal(ProfilerRecorder handle, int index);
    [NativeMethodAttribute]
private static void CopyTo_List(ProfilerRecorder handle, List`1<ProfilerRecorderSample> outSamples, bool reset);
    [NativeMethodAttribute]
private static int CopyTo_Pointer(ProfilerRecorder handle, ProfilerRecorderSample* outSamples, int outSamplesSize, bool reset);
    public sealed virtual void Dispose();
    [BurstDiscardAttribute]
private void CheckInitializedWithParamsAndThrow(ProfilerRecorderSample* dest);
    [BurstDiscardAttribute]
private void CheckInitializedAndThrow();
    private static void Create_Injected(ProfilerRecorderHandle& statHandle, int maxSampleCount, ProfilerRecorderOptions options, ProfilerRecorder& ret);
    private static void Control_Injected(ProfilerRecorder& handle, ControlOptions options);
    private static ProfilerMarkerDataUnit GetValueUnitType_Injected(ProfilerRecorder& handle);
    private static ProfilerMarkerDataType GetValueDataType_Injected(ProfilerRecorder& handle);
    private static long GetCurrentValue_Injected(ProfilerRecorder& handle);
    private static double GetCurrentValueAsDouble_Injected(ProfilerRecorder& handle);
    private static long GetLastValue_Injected(ProfilerRecorder& handle);
    private static double GetLastValueAsDouble_Injected(ProfilerRecorder& handle);
    private static int GetCount_Injected(ProfilerRecorder& handle, CountOptions countOptions);
    private static bool GetValid_Injected(ProfilerRecorder& handle);
    private static bool GetWrapped_Injected(ProfilerRecorder& handle);
    private static bool GetRunning_Injected(ProfilerRecorder& handle);
    private static void GetSampleInternal_Injected(ProfilerRecorder& handle, int index, ProfilerRecorderSample& ret);
    private static void CopyTo_List_Injected(ProfilerRecorder& handle, List`1<ProfilerRecorderSample> outSamples, bool reset);
    private static int CopyTo_Pointer_Injected(ProfilerRecorder& handle, ProfilerRecorderSample* outSamples, int outSamplesSize, bool reset);
}
internal class Unity.Profiling.ProfilerRecorderDebugView : object {
    private ProfilerRecorder m_Recorder;
    public ProfilerRecorderSample[] Items { get; }
    public ProfilerRecorderDebugView(ProfilerRecorder r);
    public ProfilerRecorderSample[] get_Items();
}
[FlagsAttribute]
public enum Unity.Profiling.ProfilerRecorderOptions : Enum {
    public int value__;
    public static ProfilerRecorderOptions None;
    public static ProfilerRecorderOptions StartImmediately;
    public static ProfilerRecorderOptions KeepAliveDuringDomainReload;
    public static ProfilerRecorderOptions CollectOnlyOnCurrentThread;
    public static ProfilerRecorderOptions WrapAroundWhenCapacityReached;
    public static ProfilerRecorderOptions SumAllSamplesInFrame;
    public static ProfilerRecorderOptions GpuRecorder;
    public static ProfilerRecorderOptions Default;
}
[UsedByNativeCodeAttribute]
[DebuggerDisplayAttribute("Value = {Value}; Count = {Count}")]
public class Unity.Profiling.ProfilerRecorderSample : ValueType {
    private long value;
    private long count;
    private long refValue;
    public long Value { get; }
    public long Count { get; }
    public long get_Value();
    public long get_Count();
}
public class UnityEditor.Experimental.RenderSettings : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static bool <useRadianceAmbientProbe>k__BackingField;
    [ObsoleteAttribute("Use UnityEngine.Experimental.GlobalIllumination.useRadianceAmbientProbe instead. (UnityUpgradable) -> UnityEngine.Experimental.GlobalIllumination.RenderSettings.useRadianceAmbientProbe", "True")]
public static bool useRadianceAmbientProbe { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_useRadianceAmbientProbe();
    [CompilerGeneratedAttribute]
public static void set_useRadianceAmbientProbe(bool value);
}
internal class UnityEngine._Scripting.APIUpdating.APIUpdaterRuntimeHelpers : object {
    [RequiredByNativeCodeAttribute]
internal static bool GetMovedFromAttributeDataForType(Type sourceType, String& assembly, String& nsp, String& klass);
    [RequiredByNativeCodeAttribute]
internal static bool GetObsoleteTypeRedirection(Type sourceType, String& assemblyName, String& nsp, String& className);
}
public class UnityEngine.AddComponentMenu : Attribute {
    private string m_AddComponentMenu;
    private int m_Ordering;
    public string componentMenu { get; }
    public int componentOrder { get; }
    public AddComponentMenu(string menuName);
    public AddComponentMenu(string menuName, int order);
    public string get_componentMenu();
    public int get_componentOrder();
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Math/AnimationCurve.bindings.h")]
[DefaultMemberAttribute("Item")]
public class UnityEngine.AnimationCurve : object {
    internal IntPtr m_Ptr;
    public Keyframe[] keys { get; public set; }
    public Keyframe Item { get; }
    public int length { get; }
    public WrapMode preWrapMode { get; public set; }
    public WrapMode postWrapMode { get; public set; }
    public AnimationCurve(Keyframe[] keys);
    [FreeFunctionAttribute("AnimationCurveBindings::Internal_Destroy")]
private static void Internal_Destroy(IntPtr ptr);
    [FreeFunctionAttribute("AnimationCurveBindings::Internal_Create")]
private static IntPtr Internal_Create(Keyframe[] keys);
    [FreeFunctionAttribute("AnimationCurveBindings::Internal_Equals")]
private bool Internal_Equals(IntPtr other);
    [FreeFunctionAttribute("AnimationCurveBindings::Internal_CopyFrom")]
private void Internal_CopyFrom(IntPtr other);
    protected virtual override void Finalize();
    [ThreadSafeAttribute]
public float Evaluate(float time);
    public Keyframe[] get_keys();
    public void set_keys(Keyframe[] value);
    [FreeFunctionAttribute("AnimationCurveBindings::AddKeySmoothTangents")]
public int AddKey(float time, float value);
    public int AddKey(Keyframe key);
    [NativeMethodAttribute("AddKey")]
private int AddKey_Internal(Keyframe key);
    [NativeThrowsAttribute]
[FreeFunctionAttribute("AnimationCurveBindings::MoveKey")]
public int MoveKey(int index, Keyframe key);
    [FreeFunctionAttribute("AnimationCurveBindings::ClearKeys")]
public void ClearKeys();
    [FreeFunctionAttribute("AnimationCurveBindings::RemoveKey")]
[NativeThrowsAttribute]
public void RemoveKey(int index);
    public Keyframe get_Item(int index);
    [NativeMethodAttribute("GetKeyCount")]
public int get_length();
    [FreeFunctionAttribute("AnimationCurveBindings::SetKeys")]
private void SetKeys(Keyframe[] keys);
    [FreeFunctionAttribute("AnimationCurveBindings::GetKey")]
[NativeThrowsAttribute]
private Keyframe GetKey(int index);
    [FreeFunctionAttribute("AnimationCurveBindings::GetKeys")]
private Keyframe[] GetKeys();
    [FreeFunctionAttribute("AnimationCurveBindings::GetHashCode")]
public virtual int GetHashCode();
    [FreeFunctionAttribute("AnimationCurveBindings::SmoothTangents")]
[NativeThrowsAttribute]
public void SmoothTangents(int index, float weight);
    public static AnimationCurve Constant(float timeStart, float timeEnd, float value);
    public static AnimationCurve Linear(float timeStart, float valueStart, float timeEnd, float valueEnd);
    public static AnimationCurve EaseInOut(float timeStart, float valueStart, float timeEnd, float valueEnd);
    [NativeMethodAttribute("GetPreInfinity")]
public WrapMode get_preWrapMode();
    [NativeMethodAttribute("SetPreInfinity")]
public void set_preWrapMode(WrapMode value);
    [NativeMethodAttribute("GetPostInfinity")]
public WrapMode get_postWrapMode();
    [NativeMethodAttribute("SetPostInfinity")]
public void set_postWrapMode(WrapMode value);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(AnimationCurve other);
    public void CopyFrom(AnimationCurve other);
    private int AddKey_Internal_Injected(Keyframe& key);
    private int MoveKey_Injected(int index, Keyframe& key);
    private void GetKey_Injected(int index, Keyframe& ret);
}
public enum UnityEngine.AnisotropicFiltering : Enum {
    public int value__;
    public static AnisotropicFiltering Disable;
    public static AnisotropicFiltering Enable;
    public static AnisotropicFiltering ForceEnable;
}
[NativeHeaderAttribute("Runtime/Export/Apple/FrameCaptureMetalScriptBindings.h")]
[NativeConditionalAttribute("PLATFORM_APPLE")]
public class UnityEngine.Apple.FrameCapture : object {
    [FreeFunctionAttribute("FrameCaptureMetalScripting::IsDestinationSupported")]
private static bool IsDestinationSupportedImpl(FrameCaptureDestination dest);
    [FreeFunctionAttribute("FrameCaptureMetalScripting::BeginCapture")]
private static void BeginCaptureImpl(FrameCaptureDestination dest, string path);
    [FreeFunctionAttribute("FrameCaptureMetalScripting::EndCapture")]
private static void EndCaptureImpl();
    [FreeFunctionAttribute("FrameCaptureMetalScripting::CaptureNextFrame")]
private static void CaptureNextFrameImpl(FrameCaptureDestination dest, string path);
    public static bool IsDestinationSupported(FrameCaptureDestination dest);
    public static void BeginCaptureToXcode();
    public static void BeginCaptureToFile(string path);
    public static void EndCapture();
    public static void CaptureNextFrameToXcode();
    public static void CaptureNextFrameToFile(string path);
}
[NativeHeaderAttribute("Runtime/Export/Apple/FrameCaptureMetalScriptBindings.h")]
public enum UnityEngine.Apple.FrameCaptureDestination : Enum {
    public int value__;
    public static FrameCaptureDestination DevTools;
    public static FrameCaptureDestination GPUTraceDocument;
}
[NativeHeaderAttribute("Runtime/PreloadManager/LoadSceneOperation.h")]
[NativeHeaderAttribute("Runtime/Input/GetInput.h")]
[NativeHeaderAttribute("Runtime/Network/NetworkUtility.h")]
[NativeHeaderAttribute("Runtime/PreloadManager/PreloadManager.h")]
[NativeHeaderAttribute("Runtime/Utilities/Argv.h")]
[NativeHeaderAttribute("Runtime/Application/AdsIdHandler.h")]
[NativeHeaderAttribute("Runtime/Application/ApplicationInfo.h")]
[NativeHeaderAttribute("Runtime/BaseClasses/IsPlaying.h")]
[NativeHeaderAttribute("Runtime/Input/InputManager.h")]
[NativeHeaderAttribute("Runtime/Misc/Player.h")]
[NativeHeaderAttribute("Runtime/Utilities/URLUtility.h")]
[NativeHeaderAttribute("Runtime/Misc/SystemInfo.h")]
[NativeHeaderAttribute("Runtime/File/ApplicationSpecificPersistentDataPath.h")]
[NativeHeaderAttribute("Runtime/Export/Application/Application.bindings.h")]
[NativeHeaderAttribute("Runtime/Input/TargetFrameRate.h")]
[NativeHeaderAttribute("Runtime/Misc/PlayerSettings.h")]
[NativeHeaderAttribute("Runtime/Misc/BuildSettings.h")]
[NativeHeaderAttribute("Runtime/Logging/LogSystem.h")]
public class UnityEngine.Application : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static LowMemoryCallback lowMemory;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static MemoryUsageChangedCallback memoryUsageChanged;
    private static LogCallback s_LogCallbackHandler;
    private static LogCallback s_LogCallbackHandlerThreaded;
    internal static AdvertisingIdentifierCallback OnAdvertisingIdentifierCallback;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<bool> focusChanged;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`1<string> deepLinkActivated;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Func`1<bool> wantsToQuit;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action quitting;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action unloading;
    private static CancellationTokenSource s_currentCancellationTokenSource;
    private static LogCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_RegisterLogCallbackDeprecated;
    [ObsoleteAttribute("This property is deprecated, please use LoadLevelAsync to detect if a specific scene is currently loading.")]
public static bool isLoadingLevel { get; }
    [ObsoleteAttribute("Streaming was a Unity Web Player feature, and is removed. This property is deprecated and always returns 0.")]
public static int streamedBytes { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Application.webSecurityEnabled is no longer supported, since the Unity Web Player is no longer supported by Unity", "True")]
public static bool webSecurityEnabled { get; }
    public static bool isPlaying { get; }
    public static bool isFocused { get; }
    public static string buildGUID { get; }
    public static bool runInBackground { get; public set; }
    public static bool isBatchMode { get; }
    internal static bool isTestRun { get; }
    internal static bool isHumanControllingUs { get; }
    public static string dataPath { get; }
    public static string streamingAssetsPath { get; }
    public static string persistentDataPath { get; }
    public static string temporaryCachePath { get; }
    public static string absoluteURL { get; }
    public static string unityVersion { get; }
    internal static int unityVersionVer { get; }
    internal static int unityVersionMaj { get; }
    internal static int unityVersionMin { get; }
    public static string version { get; }
    public static string installerName { get; }
    public static string identifier { get; }
    public static ApplicationInstallMode installMode { get; }
    public static ApplicationSandboxType sandboxType { get; }
    public static string productName { get; }
    public static string companyName { get; }
    public static string cloudProjectId { get; }
    public static int targetFrameRate { get; public set; }
    [ObsoleteAttribute("Use SetStackTraceLogType/GetStackTraceLogType instead")]
public static StackTraceLogType stackTraceLogType { get; public set; }
    public static string consoleLogPath { get; }
    public static ThreadPriority backgroundLoadingPriority { get; public set; }
    public static bool genuine { get; }
    public static bool genuineCheckAvailable { get; }
    internal static bool submitAnalytics { get; }
    [ObsoleteAttribute("This property is deprecated, please use SplashScreen.isFinished instead")]
public static bool isShowingSplashScreen { get; }
    public static RuntimePlatform platform { get; }
    public static bool isMobilePlatform { get; }
    public static bool isConsolePlatform { get; }
    public static SystemLanguage systemLanguage { get; }
    public static NetworkReachability internetReachability { get; }
    [ObsoleteAttribute("use Application.isEditor instead")]
public static bool isPlayer { get; }
    public static CancellationToken exitCancellationToken { get; }
    [ObsoleteAttribute("Use SceneManager.sceneCountInBuildSettings")]
public static int levelCount { get; }
    [ObsoleteAttribute("Use SceneManager to determine what scenes have been loaded")]
public static int loadedLevel { get; }
    [ObsoleteAttribute("Use SceneManager to determine what scenes have been loaded")]
public static string loadedLevelName { get; }
    public static bool isEditor { get; }
    private static Application();
    [FreeFunctionAttribute("GetInputManager().QuitApplication")]
public static void Quit(int exitCode);
    public static void Quit();
    [FreeFunctionAttribute("GetInputManager().CancelQuitApplication")]
[ObsoleteAttribute("CancelQuit is deprecated. Use the wantsToQuit event instead.")]
public static void CancelQuit();
    [FreeFunctionAttribute("Application_Bindings::Unload")]
public static void Unload();
    [FreeFunctionAttribute("GetPreloadManager().IsLoadingOrQueued")]
public static bool get_isLoadingLevel();
    [FreeFunctionAttribute("UpdateMemoryUsage")]
internal static void SimulateMemoryUsage(ApplicationMemoryUsage usage);
    [ObsoleteAttribute("Streaming was a Unity Web Player feature, and is removed. This function is deprecated and always returns 1.0 for valid level indices.")]
public static float GetStreamProgressForLevel(int levelIndex);
    [ObsoleteAttribute("Streaming was a Unity Web Player feature, and is removed. This function is deprecated and always returns 1.0.")]
public static float GetStreamProgressForLevel(string levelName);
    public static int get_streamedBytes();
    public static bool get_webSecurityEnabled();
    public static bool CanStreamedLevelBeLoaded(int levelIndex);
    [FreeFunctionAttribute("Application_Bindings::CanStreamedLevelBeLoaded")]
public static bool CanStreamedLevelBeLoaded(string levelName);
    [FreeFunctionAttribute("IsWorldPlaying")]
public static bool get_isPlaying();
    [FreeFunctionAttribute]
public static bool IsPlaying(Object obj);
    [FreeFunctionAttribute("IsPlayerFocused")]
public static bool get_isFocused();
    [ObsoleteAttribute("Application.GetBuildTags is no longer supported and will be removed.", "False")]
[FreeFunctionAttribute("GetBuildSettings().GetBuildTags")]
public static String[] GetBuildTags();
    [FreeFunctionAttribute("GetBuildSettings().SetBuildTags")]
[ObsoleteAttribute("Application.SetBuildTags is no longer supported and will be removed.", "False")]
public static void SetBuildTags(String[] buildTags);
    [FreeFunctionAttribute("Application_Bindings::GetBuildGUID")]
public static string get_buildGUID();
    [FreeFunctionAttribute("GetPlayerSettingsRunInBackground")]
public static bool get_runInBackground();
    [FreeFunctionAttribute("SetPlayerSettingsRunInBackground")]
public static void set_runInBackground(bool value);
    [FreeFunctionAttribute("GetBuildSettings().GetHasPROVersion")]
public static bool HasProLicense();
    [FreeFunctionAttribute("::IsBatchmode")]
public static bool get_isBatchMode();
    [FreeFunctionAttribute("::IsTestRun")]
internal static bool get_isTestRun();
    [FreeFunctionAttribute("::IsHumanControllingUs")]
internal static bool get_isHumanControllingUs();
    [FreeFunctionAttribute("HasARGV")]
internal static bool HasARGV(string name);
    [FreeFunctionAttribute("GetFirstValueForARGV")]
internal static string GetValueForARGV(string name);
    [FreeFunctionAttribute("GetAppDataPath")]
public static string get_dataPath();
    [FreeFunctionAttribute("GetStreamingAssetsPath")]
public static string get_streamingAssetsPath();
    [FreeFunctionAttribute("GetPersistentDataPathApplicationSpecific")]
public static string get_persistentDataPath();
    [FreeFunctionAttribute("GetTemporaryCachePathApplicationSpecific")]
public static string get_temporaryCachePath();
    [FreeFunctionAttribute("GetPlayerSettings().GetAbsoluteURL")]
public static string get_absoluteURL();
    [ObsoleteAttribute("Application.ExternalEval is deprecated. See https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html for alternatives.")]
public static void ExternalEval(string script);
    [FreeFunctionAttribute("Application_Bindings::ExternalCall")]
private static void Internal_ExternalCall(string script);
    [FreeFunctionAttribute("Application_Bindings::GetUnityVersion")]
public static string get_unityVersion();
    [FreeFunctionAttribute("Application_Bindings::GetUnityVersionVer")]
internal static int get_unityVersionVer();
    [FreeFunctionAttribute("Application_Bindings::GetUnityVersionMaj")]
internal static int get_unityVersionMaj();
    [FreeFunctionAttribute("Application_Bindings::GetUnityVersionMin")]
internal static int get_unityVersionMin();
    [FreeFunctionAttribute("GetApplicationInfo().GetVersion")]
public static string get_version();
    [FreeFunctionAttribute("GetApplicationInfo().GetInstallerName")]
public static string get_installerName();
    [FreeFunctionAttribute("GetApplicationInfo().GetApplicationIdentifier")]
public static string get_identifier();
    [FreeFunctionAttribute("GetApplicationInfo().GetInstallMode")]
public static ApplicationInstallMode get_installMode();
    [FreeFunctionAttribute("GetApplicationInfo().GetSandboxType")]
public static ApplicationSandboxType get_sandboxType();
    [FreeFunctionAttribute("GetPlayerSettings().GetProductName")]
public static string get_productName();
    [FreeFunctionAttribute("GetPlayerSettings().GetCompanyName")]
public static string get_companyName();
    [FreeFunctionAttribute("GetPlayerSettings().GetCloudProjectId")]
public static string get_cloudProjectId();
    [FreeFunctionAttribute("GetAdsIdHandler().RequestAdsIdAsync")]
public static bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod);
    [FreeFunctionAttribute("OpenURL")]
public static void OpenURL(string url);
    [ObsoleteAttribute("Use UnityEngine.Diagnostics.Utils.ForceCrash")]
public static void ForceCrash(int mode);
    [FreeFunctionAttribute("GetTargetFrameRate")]
public static int get_targetFrameRate();
    [FreeFunctionAttribute("SetTargetFrameRate")]
public static void set_targetFrameRate(int value);
    [FreeFunctionAttribute("Application_Bindings::SetLogCallbackDefined")]
private static void SetLogCallbackDefined(bool defined);
    [FreeFunctionAttribute("Application_Bindings::GetStackTraceLogType")]
public static StackTraceLogType get_stackTraceLogType();
    [FreeFunctionAttribute("Application_Bindings::SetStackTraceLogType")]
public static void set_stackTraceLogType(StackTraceLogType value);
    [FreeFunctionAttribute("GetStackTraceLogType")]
public static StackTraceLogType GetStackTraceLogType(LogType logType);
    [FreeFunctionAttribute("SetStackTraceLogType")]
public static void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType);
    [FreeFunctionAttribute("GetConsoleLogPath")]
public static string get_consoleLogPath();
    [FreeFunctionAttribute("GetPreloadManager().GetThreadPriority")]
public static ThreadPriority get_backgroundLoadingPriority();
    [FreeFunctionAttribute("GetPreloadManager().SetThreadPriority")]
public static void set_backgroundLoadingPriority(ThreadPriority value);
    [FreeFunctionAttribute("IsApplicationGenuine")]
public static bool get_genuine();
    [FreeFunctionAttribute("IsApplicationGenuineAvailable")]
public static bool get_genuineCheckAvailable();
    [FreeFunctionAttribute("Application_Bindings::RequestUserAuthorization")]
public static AsyncOperation RequestUserAuthorization(UserAuthorization mode);
    [FreeFunctionAttribute("Application_Bindings::HasUserAuthorization")]
public static bool HasUserAuthorization(UserAuthorization mode);
    [FreeFunctionAttribute("GetPlayerSettings().GetSubmitAnalytics")]
internal static bool get_submitAnalytics();
    public static bool get_isShowingSplashScreen();
    [FreeFunctionAttribute("systeminfo::GetRuntimePlatform")]
public static RuntimePlatform get_platform();
    public static bool get_isMobilePlatform();
    public static bool get_isConsolePlatform();
    [FreeFunctionAttribute("(SystemLanguage)systeminfo::GetSystemLanguage")]
public static SystemLanguage get_systemLanguage();
    [FreeFunctionAttribute("GetInternetReachability")]
public static NetworkReachability get_internetReachability();
    [CompilerGeneratedAttribute]
public static void add_lowMemory(LowMemoryCallback value);
    [CompilerGeneratedAttribute]
public static void remove_lowMemory(LowMemoryCallback value);
    [CompilerGeneratedAttribute]
public static void add_memoryUsageChanged(MemoryUsageChangedCallback value);
    [CompilerGeneratedAttribute]
public static void remove_memoryUsageChanged(MemoryUsageChangedCallback value);
    [RequiredByNativeCodeAttribute]
internal static void CallLowMemory(ApplicationMemoryUsage usage);
    [RequiredByNativeCodeAttribute]
internal static bool HasLogCallback();
    public static void add_logMessageReceived(LogCallback value);
    public static void remove_logMessageReceived(LogCallback value);
    public static void add_logMessageReceivedThreaded(LogCallback value);
    public static void remove_logMessageReceivedThreaded(LogCallback value);
    [RequiredByNativeCodeAttribute]
private static void CallLogCallback(string logString, string stackTrace, LogType type, bool invokedOnMainThread);
    internal static void InvokeOnAdvertisingIdentifierCallback(string advertisingId, bool trackingEnabled);
    private static string ObjectToJSString(object o);
    [ObsoleteAttribute("Application.ExternalCall is deprecated. See https://docs.unity3d.com/Manual/webgl-interactingwithbrowserscripting.html for alternatives.")]
public static void ExternalCall(string functionName, Object[] args);
    private static string BuildInvocationForArguments(string functionName, Object[] args);
    public static bool get_isPlayer();
    [ObsoleteAttribute("Use Object.DontDestroyOnLoad instead")]
public static void DontDestroyOnLoad(Object o);
    [ObsoleteAttribute("Application.CaptureScreenshot is obsolete. Use ScreenCapture.CaptureScreenshot instead (UnityUpgradable) -> [UnityEngine] UnityEngine.ScreenCapture.CaptureScreenshot(*)", "True")]
public static void CaptureScreenshot(string filename, int superSize);
    [ObsoleteAttribute("Application.CaptureScreenshot is obsolete. Use ScreenCapture.CaptureScreenshot instead (UnityUpgradable) -> [UnityEngine] UnityEngine.ScreenCapture.CaptureScreenshot(*)", "True")]
public static void CaptureScreenshot(string filename);
    public static void add_onBeforeRender(UnityAction value);
    public static void remove_onBeforeRender(UnityAction value);
    [CompilerGeneratedAttribute]
public static void add_focusChanged(Action`1<bool> value);
    [CompilerGeneratedAttribute]
public static void remove_focusChanged(Action`1<bool> value);
    [CompilerGeneratedAttribute]
public static void add_deepLinkActivated(Action`1<string> value);
    [CompilerGeneratedAttribute]
public static void remove_deepLinkActivated(Action`1<string> value);
    [CompilerGeneratedAttribute]
public static void add_wantsToQuit(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public static void remove_wantsToQuit(Func`1<bool> value);
    [CompilerGeneratedAttribute]
public static void add_quitting(Action value);
    [CompilerGeneratedAttribute]
public static void remove_quitting(Action value);
    [CompilerGeneratedAttribute]
public static void add_unloading(Action value);
    [CompilerGeneratedAttribute]
public static void remove_unloading(Action value);
    [RequiredByNativeCodeAttribute]
private static bool Internal_ApplicationWantsToQuit();
    public static CancellationToken get_exitCancellationToken();
    [RequiredByNativeCodeAttribute]
private static void Internal_ApplicationInit();
    [RequiredByNativeCodeAttribute]
private static void Internal_ApplicationQuit();
    [RequiredByNativeCodeAttribute]
private static void Internal_ApplicationUnload();
    [RequiredByNativeCodeAttribute]
internal static void InvokeOnBeforeRender();
    [RequiredByNativeCodeAttribute]
internal static void InvokeFocusChanged(bool focus);
    [RequiredByNativeCodeAttribute]
internal static void InvokeDeepLinkActivated(string url);
    [ObsoleteAttribute("Application.RegisterLogCallback is deprecated. Use Application.logMessageReceived instead.")]
public static void RegisterLogCallback(LogCallback handler);
    [ObsoleteAttribute("Application.RegisterLogCallbackThreaded is deprecated. Use Application.logMessageReceivedThreaded instead.")]
public static void RegisterLogCallbackThreaded(LogCallback handler);
    private static void RegisterLogCallback(LogCallback handler, bool threaded);
    public static int get_levelCount();
    public static int get_loadedLevel();
    public static string get_loadedLevelName();
    [ObsoleteAttribute("Use SceneManager.LoadScene")]
public static void LoadLevel(int index);
    [ObsoleteAttribute("Use SceneManager.LoadScene")]
public static void LoadLevel(string name);
    [ObsoleteAttribute("Use SceneManager.LoadScene")]
public static void LoadLevelAdditive(int index);
    [ObsoleteAttribute("Use SceneManager.LoadScene")]
public static void LoadLevelAdditive(string name);
    [ObsoleteAttribute("Use SceneManager.LoadSceneAsync")]
public static AsyncOperation LoadLevelAsync(int index);
    [ObsoleteAttribute("Use SceneManager.LoadSceneAsync")]
public static AsyncOperation LoadLevelAsync(string levelName);
    [ObsoleteAttribute("Use SceneManager.LoadSceneAsync")]
public static AsyncOperation LoadLevelAdditiveAsync(int index);
    [ObsoleteAttribute("Use SceneManager.LoadSceneAsync")]
public static AsyncOperation LoadLevelAdditiveAsync(string levelName);
    [ObsoleteAttribute("Use SceneManager.UnloadScene")]
public static bool UnloadLevel(int index);
    [ObsoleteAttribute("Use SceneManager.UnloadScene")]
public static bool UnloadLevel(string scenePath);
    public static bool get_isEditor();
}
public enum UnityEngine.ApplicationInstallMode : Enum {
    public int value__;
    public static ApplicationInstallMode Unknown;
    public static ApplicationInstallMode Store;
    public static ApplicationInstallMode DeveloperBuild;
    public static ApplicationInstallMode Adhoc;
    public static ApplicationInstallMode Enterprise;
    public static ApplicationInstallMode Editor;
}
public enum UnityEngine.ApplicationMemoryUsage : Enum {
    public int value__;
    public static ApplicationMemoryUsage Unknown;
    public static ApplicationMemoryUsage Low;
    public static ApplicationMemoryUsage Medium;
    public static ApplicationMemoryUsage High;
    public static ApplicationMemoryUsage Critical;
}
public class UnityEngine.ApplicationMemoryUsageChange : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ApplicationMemoryUsage <memoryUsage>k__BackingField;
    public ApplicationMemoryUsage memoryUsage { get; private set; }
    public ApplicationMemoryUsageChange(ApplicationMemoryUsage usage);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ApplicationMemoryUsage get_memoryUsage();
    [CompilerGeneratedAttribute]
private void set_memoryUsage(ApplicationMemoryUsage value);
}
public enum UnityEngine.ApplicationSandboxType : Enum {
    public int value__;
    public static ApplicationSandboxType Unknown;
    public static ApplicationSandboxType NotSandboxed;
    public static ApplicationSandboxType Sandboxed;
    public static ApplicationSandboxType SandboxBroken;
}
[NativeHeaderAttribute("Runtime/Mono/AssemblyFullName.h")]
[RequiredByNativeCodeAttribute]
internal class UnityEngine.AssemblyFullName : ValueType {
    [NativeNameAttribute("name")]
public string Name;
    [NativeNameAttribute("version")]
public AssemblyVersion Version;
    [NativeNameAttribute("publicKeyToken")]
public string PublicKeyToken;
    [NativeNameAttribute("culture")]
public string Culture;
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("1")]
public class UnityEngine.AssemblyIsEditorAssembly : Attribute {
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Mono/AssemblyFullName.h")]
internal class UnityEngine.AssemblyVersion : ValueType {
    public ushort major;
    public ushort minor;
    public ushort build;
    public ushort revision;
    public AssemblyVersion(ushort major, ushort minor, ushort build, ushort revision);
    public static bool op_Equality(AssemblyVersion lhs, AssemblyVersion rhs);
    public static bool op_Inequality(AssemblyVersion lhs, AssemblyVersion rhs);
    public static bool op_LessThan(AssemblyVersion lhs, AssemblyVersion rhs);
    public static bool op_GreaterThan(AssemblyVersion lhs, AssemblyVersion rhs);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[DebuggerStepThroughAttribute]
public static class UnityEngine.Assertions.Assert : object {
    internal static string UNITY_ASSERTIONS;
    [ObsoleteAttribute("Future versions of Unity are expected to always throw exceptions and not have this field.")]
public static bool raiseExceptions;
    private static Assert();
    private static void Fail(string message, string userMessage);
    [ObsoleteAttribute("Assert.Equals should not be used for Assertions", "True")]
[EditorBrowsableAttribute("1")]
public static bool Equals(object obj1, object obj2);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Assert.ReferenceEquals should not be used for Assertions", "True")]
public static bool ReferenceEquals(object obj1, object obj2);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsTrue(bool condition);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsTrue(bool condition, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsFalse(bool condition);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsFalse(bool condition, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreApproximatelyEqual(float expected, float actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreApproximatelyEqual(float expected, float actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreApproximatelyEqual(float expected, float actual, float tolerance);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreApproximatelyEqual(float expected, float actual, float tolerance, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotApproximatelyEqual(float expected, float actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotApproximatelyEqual(float expected, float actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotApproximatelyEqual(float expected, float actual, float tolerance);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotApproximatelyEqual(float expected, float actual, float tolerance, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(T expected, T actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(T expected, T actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(Object expected, Object actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(T expected, T actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(T expected, T actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(Object expected, Object actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNull(T value);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNull(T value, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNull(Object value, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNotNull(T value);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNotNull(T value, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void IsNotNull(Object value, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(sbyte expected, sbyte actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(sbyte expected, sbyte actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(sbyte expected, sbyte actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(sbyte expected, sbyte actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(byte expected, byte actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(byte expected, byte actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(byte expected, byte actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(byte expected, byte actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(char expected, char actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(char expected, char actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(char expected, char actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(char expected, char actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(short expected, short actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(short expected, short actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(short expected, short actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(short expected, short actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(ushort expected, ushort actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(ushort expected, ushort actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(ushort expected, ushort actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(ushort expected, ushort actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(int expected, int actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(int expected, int actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(int expected, int actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(int expected, int actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(UInt32 expected, UInt32 actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(UInt32 expected, UInt32 actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(UInt32 expected, UInt32 actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(UInt32 expected, UInt32 actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(long expected, long actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(long expected, long actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(long expected, long actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(long expected, long actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(ulong expected, ulong actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreEqual(ulong expected, ulong actual, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(ulong expected, ulong actual);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AreNotEqual(ulong expected, ulong actual, string message);
}
public class UnityEngine.Assertions.AssertionException : Exception {
    private string m_UserMessage;
    public string Message { get; }
    public AssertionException(string message, string userMessage);
    public virtual string get_Message();
}
internal class UnityEngine.Assertions.AssertionMessageUtil : object {
    private static string k_Expected;
    private static string k_AssertionFailed;
    public static string GetMessage(string failureMessage);
    public static string GetMessage(string failureMessage, string expected);
    public static string GetEqualityMessage(object actual, object expected, bool expectEqual);
    public static string NullFailureMessage(object value, bool expectNull);
    public static string BooleanFailureMessage(bool expected);
}
public class UnityEngine.Assertions.Comparers.FloatComparer : object {
    private float m_Error;
    private bool m_Relative;
    public static FloatComparer s_ComparerWithDefaultTolerance;
    public static float kEpsilon;
    public FloatComparer(bool relative);
    public FloatComparer(float error);
    public FloatComparer(float error, bool relative);
    private static FloatComparer();
    public sealed virtual bool Equals(float a, float b);
    public sealed virtual int GetHashCode(float obj);
    public static bool AreEqual(float expected, float actual, float error);
    public static bool AreEqualRelative(float expected, float actual, float error);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static class UnityEngine.Assertions.Must.MustExtensions : object {
    [ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustBeTrue(bool value);
    [ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustBeTrue(bool value, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ExtensionAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustBeFalse(bool value);
    [ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ExtensionAttribute]
public static void MustBeFalse(bool value, string message);
    [ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ExtensionAttribute]
public static void MustBeApproximatelyEqual(float actual, float expected);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
public static void MustBeApproximatelyEqual(float actual, float expected, string message);
    [ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustBeApproximatelyEqual(float actual, float expected, float tolerance);
    [ExtensionAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustBeApproximatelyEqual(float actual, float expected, float tolerance, string message);
    [ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ExtensionAttribute]
public static void MustNotBeApproximatelyEqual(float actual, float expected);
    [ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustNotBeApproximatelyEqual(float actual, float expected, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
public static void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance);
    [ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
public static void MustBeEqual(T actual, T expected);
    [ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustBeEqual(T actual, T expected, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
public static void MustNotBeEqual(T actual, T expected);
    [ExtensionAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustNotBeEqual(T actual, T expected, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ExtensionAttribute]
public static void MustBeNull(T expected);
    [ExtensionAttribute]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
public static void MustBeNull(T expected, string message);
    [ExtensionAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustNotBeNull(T expected);
    [ExtensionAttribute]
[ObsoleteAttribute("Must extensions are deprecated. Use UnityEngine.Assertions.Assert instead")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
public static void MustNotBeNull(T expected, string message);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/GameCode/AsyncInstantiate/AsyncInstantiateOperation.h")]
public class UnityEngine.AsyncInstantiateOperation : AsyncOperation {
    internal Object[] m_Result;
    public Object[] Result { get; }
    [StaticAccessorAttribute("GetAsyncInstantiateManager()", "0")]
internal static float IntegrationTimeMS { get; internal set; }
    public Object[] get_Result();
    [NativeMethodAttribute("IsWaitingForSceneActivation")]
public bool IsWaitingForSceneActivation();
    [NativeMethodAttribute("WaitForCompletion")]
public void WaitForCompletion();
    [NativeMethodAttribute("Cancel")]
public void Cancel();
    internal static float get_IntegrationTimeMS();
    internal static void set_IntegrationTimeMS(float value);
    public static float GetIntegrationTimeMS();
    public static void SetIntegrationTimeMS(float integrationTimeMS);
}
[ExcludeFromDocsAttribute]
public class UnityEngine.AsyncInstantiateOperation`1 : CustomYieldInstruction {
    internal AsyncInstantiateOperation m_op;
    public bool keepWaiting { get; }
    public bool isDone { get; }
    public float progress { get; }
    public bool allowSceneActivation { get; public set; }
    public T[] Result { get; }
    internal AsyncInstantiateOperation`1(AsyncInstantiateOperation op);
    public virtual bool get_keepWaiting();
    public AsyncInstantiateOperation GetOperation();
    public static AsyncInstantiateOperation op_Implicit(AsyncInstantiateOperation`1<T> generic);
    public bool IsWaitingForSceneActivation();
    public void add_completed(Action`1<AsyncOperation> value);
    public void remove_completed(Action`1<AsyncOperation> value);
    public bool get_isDone();
    public float get_progress();
    public bool get_allowSceneActivation();
    public void set_allowSceneActivation(bool value);
    public void WaitForCompletion();
    public void Cancel();
    public T[] get_Result();
}
[RequiredByNativeCodeAttribute]
internal class UnityEngine.AsyncInstantiateOperationHelper : object {
    [RequiredByNativeCodeAttribute]
public static void SetAsyncInstantiateOperationResult(AsyncInstantiateOperation op, Object[] result);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Scripting/AsyncOperation.bindings.h")]
[NativeHeaderAttribute("Runtime/Misc/AsyncOperation.h")]
public class UnityEngine.AsyncOperation : YieldInstruction {
    internal IntPtr m_Ptr;
    private Action`1<AsyncOperation> m_completeCallback;
    public bool isDone { get; }
    public float progress { get; }
    public int priority { get; public set; }
    public bool allowSceneActivation { get; public set; }
    [NativeMethodAttribute]
[StaticAccessorAttribute("AsyncOperationBindings", "2")]
private static void InternalDestroy(IntPtr ptr);
    [NativeMethodAttribute("IsDone")]
public bool get_isDone();
    [NativeMethodAttribute("GetProgress")]
public float get_progress();
    [NativeMethodAttribute("GetPriority")]
public int get_priority();
    [NativeMethodAttribute("SetPriority")]
public void set_priority(int value);
    [NativeMethodAttribute("GetAllowSceneActivation")]
public bool get_allowSceneActivation();
    [NativeMethodAttribute("SetAllowSceneActivation")]
public void set_allowSceneActivation(bool value);
    protected virtual override void Finalize();
    [RequiredByNativeCodeAttribute]
internal void InvokeCompletionEvent();
    public void add_completed(Action`1<AsyncOperation> value);
    public void remove_completed(Action`1<AsyncOperation> value);
}
internal class UnityEngine.AttributeHelperEngine : object {
    [RequiredByNativeCodeAttribute]
private static Type GetParentTypeDisallowingMultipleInclusion(Type type);
    [RequiredByNativeCodeAttribute]
private static Type[] GetRequiredComponents(Type klass);
    private static int GetExecuteMode(Type klass);
    [RequiredByNativeCodeAttribute]
private static int CheckIsEditorScript(Type klass);
    [RequiredByNativeCodeAttribute]
private static int GetDefaultExecutionOrderFor(Type klass);
    private static T GetCustomAttributeOfType(Type klass);
}
public enum UnityEngine.AudioType : Enum {
    public int value__;
    public static AudioType UNKNOWN;
    public static AudioType ACC;
    public static AudioType AIFF;
    public static AudioType IT;
    public static AudioType MOD;
    public static AudioType MPEG;
    public static AudioType OGGVORBIS;
    public static AudioType S3M;
    public static AudioType WAV;
    public static AudioType XM;
    public static AudioType XMA;
    public static AudioType VAG;
    public static AudioType AUDIOQUEUE;
}
public enum UnityEngine.BatteryStatus : Enum {
    public int value__;
    public static BatteryStatus Unknown;
    public static BatteryStatus Charging;
    public static BatteryStatus Discharging;
    public static BatteryStatus NotCharging;
    public static BatteryStatus Full;
}
internal static class UnityEngine.BeforeRenderHelper : object {
    private static List`1<OrderBlock> s_OrderBlocks;
    private static BeforeRenderHelper();
    private static int GetUpdateOrder(UnityAction callback);
    public static void RegisterCallback(UnityAction callback);
    public static void UnregisterCallback(UnityAction callback);
    public static void Invoke();
}
[AttributeUsageAttribute("64")]
public class UnityEngine.BeforeRenderOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <order>k__BackingField;
    public int order { get; private set; }
    public BeforeRenderOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_order();
    [CompilerGeneratedAttribute]
private void set_order(int value);
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Mono/MonoBehaviour.h")]
public class UnityEngine.Behaviour : Component {
    [NativePropertyAttribute]
[RequiredByNativeCodeAttribute]
public bool enabled { get; public set; }
    [NativePropertyAttribute]
public bool isActiveAndEnabled { get; }
    public bool get_enabled();
    public void set_enabled(bool value);
    [NativeMethodAttribute("IsAddedToManager")]
public bool get_isActiveAndEnabled();
}
[NativeHeaderAttribute("Runtime/Export/Graphics/BillboardRenderer.bindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/Billboard/BillboardAsset.h")]
public class UnityEngine.BillboardAsset : Object {
    public float width { get; public set; }
    public float height { get; public set; }
    public float bottom { get; public set; }
    public int imageCount { get; }
    public int vertexCount { get; }
    public int indexCount { get; }
    public Material material { get; public set; }
    [FreeFunctionAttribute]
private static void Internal_Create(BillboardAsset obj);
    public float get_width();
    public void set_width(float value);
    public float get_height();
    public void set_height(float value);
    public float get_bottom();
    public void set_bottom(float value);
    [NativeMethodAttribute("GetNumImages")]
public int get_imageCount();
    [NativeMethodAttribute("GetNumVertices")]
public int get_vertexCount();
    [NativeMethodAttribute("GetNumIndices")]
public int get_indexCount();
    public Material get_material();
    public void set_material(Material value);
    public void GetImageTexCoords(List`1<Vector4> imageTexCoords);
    [NativeMethodAttribute("GetBillboardDataReadonly().GetImageTexCoords")]
public Vector4[] GetImageTexCoords();
    [FreeFunctionAttribute]
internal void GetImageTexCoordsInternal(object list);
    public void SetImageTexCoords(List`1<Vector4> imageTexCoords);
    [FreeFunctionAttribute]
public void SetImageTexCoords(Vector4[] imageTexCoords);
    [FreeFunctionAttribute]
internal void SetImageTexCoordsInternalList(object list);
    public void GetVertices(List`1<Vector2> vertices);
    [NativeMethodAttribute("GetBillboardDataReadonly().GetVertices")]
public Vector2[] GetVertices();
    [FreeFunctionAttribute]
internal void GetVerticesInternal(object list);
    public void SetVertices(List`1<Vector2> vertices);
    [FreeFunctionAttribute]
public void SetVertices(Vector2[] vertices);
    [FreeFunctionAttribute]
internal void SetVerticesInternalList(object list);
    public void GetIndices(List`1<ushort> indices);
    [NativeMethodAttribute("GetBillboardDataReadonly().GetIndices")]
public UInt16[] GetIndices();
    [FreeFunctionAttribute]
internal void GetIndicesInternal(object list);
    public void SetIndices(List`1<ushort> indices);
    [FreeFunctionAttribute]
public void SetIndices(UInt16[] indices);
    [FreeFunctionAttribute]
internal void SetIndicesInternalList(object list);
    [FreeFunctionAttribute]
internal void MakeMaterialProperties(MaterialPropertyBlock properties, Camera camera);
}
[NativeHeaderAttribute("Runtime/Graphics/Billboard/BillboardRenderer.h")]
public class UnityEngine.BillboardRenderer : Renderer {
    public BillboardAsset billboard { get; public set; }
    public BillboardAsset get_billboard();
    public void set_billboard(BillboardAsset value);
}
[UsedByNativeCodeAttribute]
internal class UnityEngine.BlendShape : ValueType {
    [SerializeField]
private UInt32 m_FirstVertex;
    [SerializeField]
private UInt32 m_VertexCount;
    [SerializeField]
private bool m_HasNormals;
    [SerializeField]
private bool m_HasTangents;
    public UInt32 firstVertex { get; public set; }
    public UInt32 vertexCount { get; public set; }
    public bool hasNormals { get; public set; }
    public bool hasTangents { get; public set; }
    public UInt32 get_firstVertex();
    public void set_firstVertex(UInt32 value);
    public UInt32 get_vertexCount();
    public void set_vertexCount(UInt32 value);
    public bool get_hasNormals();
    public void set_hasNormals(bool value);
    public bool get_hasTangents();
    public void set_hasTangents(bool value);
}
public class UnityEngine.BlendShapeBufferRange : ValueType {
    [SerializeField]
private UInt32 m_StartIndex;
    [SerializeField]
private UInt32 m_EndIndex;
    public UInt32 startIndex { get; internal set; }
    public UInt32 endIndex { get; internal set; }
    public UInt32 get_startIndex();
    internal void set_startIndex(UInt32 value);
    public UInt32 get_endIndex();
    internal void set_endIndex(UInt32 value);
}
[ObsoleteAttribute("BlendWeights is obsolete. Use SkinWeights instead (UnityUpgradable) -> SkinWeights", "True")]
public enum UnityEngine.BlendWeights : Enum {
    public int value__;
    [ObsoleteAttribute("BlendWeights.OneBone is obsolete. Use SkinWeights.OneBone instead (UnityUpgradable) -> SkinWeights.OneBone", "True")]
public static BlendWeights OneBone;
    [ObsoleteAttribute("BlendWeights.TwoBones is obsolete. Use SkinWeights.TwoBones instead (UnityUpgradable) -> SkinWeights.TwoBones", "True")]
public static BlendWeights TwoBones;
    [ObsoleteAttribute("BlendWeights.FourBones is obsolete. Use SkinWeights.FourBones instead (UnityUpgradable) -> SkinWeights.FourBones", "True")]
public static BlendWeights FourBones;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.BoneWeight : ValueType {
    [SerializeField]
private float m_Weight0;
    [SerializeField]
private float m_Weight1;
    [SerializeField]
private float m_Weight2;
    [SerializeField]
private float m_Weight3;
    [SerializeField]
private int m_BoneIndex0;
    [SerializeField]
private int m_BoneIndex1;
    [SerializeField]
private int m_BoneIndex2;
    [SerializeField]
private int m_BoneIndex3;
    public float weight0 { get; public set; }
    public float weight1 { get; public set; }
    public float weight2 { get; public set; }
    public float weight3 { get; public set; }
    public int boneIndex0 { get; public set; }
    public int boneIndex1 { get; public set; }
    public int boneIndex2 { get; public set; }
    public int boneIndex3 { get; public set; }
    public float get_weight0();
    public void set_weight0(float value);
    public float get_weight1();
    public void set_weight1(float value);
    public float get_weight2();
    public void set_weight2(float value);
    public float get_weight3();
    public void set_weight3(float value);
    public int get_boneIndex0();
    public void set_boneIndex0(int value);
    public int get_boneIndex1();
    public void set_boneIndex1(int value);
    public int get_boneIndex2();
    public void set_boneIndex2(int value);
    public int get_boneIndex3();
    public void set_boneIndex3(int value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(BoneWeight other);
    public static bool op_Equality(BoneWeight lhs, BoneWeight rhs);
    public static bool op_Inequality(BoneWeight lhs, BoneWeight rhs);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.BoneWeight1 : ValueType {
    [SerializeField]
private float m_Weight;
    [SerializeField]
private int m_BoneIndex;
    public float weight { get; public set; }
    public int boneIndex { get; public set; }
    public float get_weight();
    public void set_weight(float value);
    public int get_boneIndex();
    public void set_boneIndex(int value);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(BoneWeight1 other);
    public virtual int GetHashCode();
    public static bool op_Equality(BoneWeight1 lhs, BoneWeight1 rhs);
    public static bool op_Inequality(BoneWeight1 lhs, BoneWeight1 rhs);
}
[NativeHeaderAttribute("Runtime/Export/Bootstrap/BootConfig.bindings.h")]
internal class UnityEngine.BootConfigData : object {
    private IntPtr m_Ptr;
    private BootConfigData(IntPtr nativeHandle);
    public void AddKey(string key);
    public string Get(string key);
    public string Get(string key, int index);
    public void Append(string key, string value);
    public void Set(string key, string value);
    private string GetValue(string key, int index);
    [RequiredByNativeCodeAttribute]
private static BootConfigData WrapBootConfigData(IntPtr nativeHandle);
}
public class UnityEngine.BoundingSphere : ValueType {
    public Vector3 position;
    public float radius;
    public BoundingSphere(Vector3 pos, float rad);
    public BoundingSphere(Vector4 packedSphere);
}
[NativeTypeAttribute]
[NativeHeaderAttribute("Runtime/Geometry/Ray.h")]
[NativeHeaderAttribute("Runtime/Geometry/Intersection.h")]
[NativeClassAttribute("AABB")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Math/MathScripting.h")]
[NativeHeaderAttribute("Runtime/Geometry/AABB.h")]
public class UnityEngine.Bounds : ValueType {
    private Vector3 m_Center;
    [NativeNameAttribute("m_Extent")]
private Vector3 m_Extents;
    public Vector3 center { get; public set; }
    public Vector3 size { get; public set; }
    public Vector3 extents { get; public set; }
    public Vector3 min { get; public set; }
    public Vector3 max { get; public set; }
    public Bounds(Vector3 center, Vector3 size);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Bounds other);
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public Vector3 get_size();
    public void set_size(Vector3 value);
    public Vector3 get_extents();
    public void set_extents(Vector3 value);
    public Vector3 get_min();
    public void set_min(Vector3 value);
    public Vector3 get_max();
    public void set_max(Vector3 value);
    public static bool op_Equality(Bounds lhs, Bounds rhs);
    public static bool op_Inequality(Bounds lhs, Bounds rhs);
    public void SetMinMax(Vector3 min, Vector3 max);
    public void Encapsulate(Vector3 point);
    public void Encapsulate(Bounds bounds);
    public void Expand(float amount);
    public void Expand(Vector3 amount);
    public bool Intersects(Bounds bounds);
    public bool IntersectRay(Ray ray);
    public bool IntersectRay(Ray ray, Single& distance);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NativeMethodAttribute("IsInside")]
public bool Contains(Vector3 point);
    [FreeFunctionAttribute("BoundsScripting::SqrDistance")]
public float SqrDistance(Vector3 point);
    [FreeFunctionAttribute("IntersectRayAABB")]
private static bool IntersectRayAABB(Ray ray, Bounds bounds, Single& dist);
    [FreeFunctionAttribute("BoundsScripting::ClosestPoint")]
public Vector3 ClosestPoint(Vector3 point);
    private static bool Contains_Injected(Bounds& _unity_self, Vector3& point);
    private static float SqrDistance_Injected(Bounds& _unity_self, Vector3& point);
    private static bool IntersectRayAABB_Injected(Ray& ray, Bounds& bounds, Single& dist);
    private static void ClosestPoint_Injected(Bounds& _unity_self, Vector3& point, Vector3& ret);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.BoundsInt : ValueType {
    private Vector3Int m_Position;
    private Vector3Int m_Size;
    public int x { get; public set; }
    public int y { get; public set; }
    public int z { get; public set; }
    public Vector3 center { get; }
    public Vector3Int min { get; public set; }
    public Vector3Int max { get; public set; }
    public int xMin { get; public set; }
    public int yMin { get; public set; }
    public int zMin { get; public set; }
    public int xMax { get; public set; }
    public int yMax { get; public set; }
    public int zMax { get; public set; }
    public Vector3Int position { get; public set; }
    public Vector3Int size { get; public set; }
    public PositionEnumerator allPositionsWithin { get; }
    public BoundsInt(int xMin, int yMin, int zMin, int sizeX, int sizeY, int sizeZ);
    public BoundsInt(Vector3Int position, Vector3Int size);
    public int get_x();
    public void set_x(int value);
    public int get_y();
    public void set_y(int value);
    public int get_z();
    public void set_z(int value);
    public Vector3 get_center();
    public Vector3Int get_min();
    public void set_min(Vector3Int value);
    public Vector3Int get_max();
    public void set_max(Vector3Int value);
    public int get_xMin();
    public void set_xMin(int value);
    public int get_yMin();
    public void set_yMin(int value);
    public int get_zMin();
    public void set_zMin(int value);
    public int get_xMax();
    public void set_xMax(int value);
    public int get_yMax();
    public void set_yMax(int value);
    public int get_zMax();
    public void set_zMax(int value);
    public Vector3Int get_position();
    public void set_position(Vector3Int value);
    public Vector3Int get_size();
    public void set_size(Vector3Int value);
    public void SetMinMax(Vector3Int minPosition, Vector3Int maxPosition);
    public void ClampToBounds(BoundsInt bounds);
    public bool Contains(Vector3Int position);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(BoundsInt lhs, BoundsInt rhs);
    public static bool op_Inequality(BoundsInt lhs, BoundsInt rhs);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(BoundsInt other);
    public virtual int GetHashCode();
    public PositionEnumerator get_allPositionsWithin();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.BuildCompression : ValueType {
    public static BuildCompression Uncompressed;
    public static BuildCompression LZ4;
    public static BuildCompression LZMA;
    public static BuildCompression UncompressedRuntime;
    public static BuildCompression LZ4Runtime;
    [NativeNameAttribute("compression")]
private CompressionType _compression;
    [NativeNameAttribute("level")]
private CompressionLevel _level;
    [NativeNameAttribute("blockSize")]
private UInt32 _blockSize;
    public CompressionType compression { get; private set; }
    public CompressionLevel level { get; private set; }
    public UInt32 blockSize { get; private set; }
    private BuildCompression(CompressionType in_compression, CompressionLevel in_level, UInt32 in_blockSize);
    private static BuildCompression();
    public CompressionType get_compression();
    private void set_compression(CompressionType value);
    public CompressionLevel get_level();
    private void set_level(CompressionLevel value);
    public UInt32 get_blockSize();
    private void set_blockSize(UInt32 value);
}
[StaticAccessorAttribute("CacheWrapper", "2")]
[NativeHeaderAttribute("Runtime/Misc/Cache.h")]
public class UnityEngine.Cache : ValueType {
    private int m_Handle;
    internal int handle { get; }
    public bool valid { get; }
    public bool ready { get; }
    public bool readOnly { get; }
    public string path { get; }
    public int index { get; }
    public long spaceFree { get; }
    public long maximumAvailableStorageSpace { get; public set; }
    public long spaceOccupied { get; }
    public int expirationDelay { get; public set; }
    internal int get_handle();
    public static bool op_Equality(Cache lhs, Cache rhs);
    public static bool op_Inequality(Cache lhs, Cache rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Cache other);
    public bool get_valid();
    internal static bool Cache_IsValid(int handle);
    public bool get_ready();
    [NativeThrowsAttribute]
internal static bool Cache_IsReady(int handle);
    public bool get_readOnly();
    [NativeThrowsAttribute]
internal static bool Cache_IsReadonly(int handle);
    public string get_path();
    [NativeThrowsAttribute]
internal static string Cache_GetPath(int handle);
    public int get_index();
    internal static int Cache_GetIndex(int handle);
    public long get_spaceFree();
    [NativeThrowsAttribute]
internal static long Cache_GetSpaceFree(int handle);
    public long get_maximumAvailableStorageSpace();
    public void set_maximumAvailableStorageSpace(long value);
    [NativeThrowsAttribute]
internal static long Cache_GetMaximumDiskSpaceAvailable(int handle);
    [NativeThrowsAttribute]
internal static void Cache_SetMaximumDiskSpaceAvailable(int handle, long value);
    public long get_spaceOccupied();
    [NativeThrowsAttribute]
internal static long Cache_GetCachingDiskSpaceUsed(int handle);
    public int get_expirationDelay();
    public void set_expirationDelay(int value);
    [NativeThrowsAttribute]
internal static int Cache_GetExpirationDelay(int handle);
    [NativeThrowsAttribute]
internal static void Cache_SetExpirationDelay(int handle, int value);
    public bool ClearCache();
    [NativeThrowsAttribute]
internal static bool Cache_ClearCache(int handle);
    public bool ClearCache(int expiration);
    [NativeThrowsAttribute]
internal static bool Cache_ClearCache_Expiration(int handle, int expiration);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.CachedAssetBundle : ValueType {
    private string m_Name;
    private Hash128 m_Hash;
    public string name { get; public set; }
    public Hash128 hash { get; public set; }
    public CachedAssetBundle(string name, Hash128 hash);
    public string get_name();
    public void set_name(string value);
    public Hash128 get_hash();
    public void set_hash(Hash128 value);
}
[ObsoleteAttribute("This struct is not for public use.")]
[UsedByNativeCodeAttribute]
public class UnityEngine.CacheIndex : ValueType {
    public string name;
    public int bytesUsed;
    public int expires;
}
[StaticAccessorAttribute("GetCachingManager()", "0")]
[NativeHeaderAttribute("Runtime/Misc/CachingManager.h")]
public class UnityEngine.Caching : object {
    public static bool compressionEnabled { get; public set; }
    public static bool ready { get; }
    [ObsoleteAttribute("Please use use Cache.spaceOccupied to get used bytes per cache.")]
public static int spaceUsed { get; }
    [ObsoleteAttribute("This property is only used for the current cache, use Cache.spaceOccupied to get used bytes per cache.")]
public static long spaceOccupied { get; }
    [ObsoleteAttribute("Please use use Cache.spaceOccupied to get used bytes per cache.")]
public static int spaceAvailable { get; }
    [ObsoleteAttribute("This property is only used for the current cache, use Cache.spaceFree to get unused bytes per cache.")]
public static long spaceFree { get; }
    [StaticAccessorAttribute("GetCachingManager().GetCurrentCache()", "0")]
[ObsoleteAttribute("This property is only used for the current cache, use Cache.maximumAvailableStorageSpace to access the maximum available storage space per cache.")]
public static long maximumAvailableDiskSpace { get; public set; }
    [StaticAccessorAttribute("GetCachingManager().GetCurrentCache()", "0")]
[ObsoleteAttribute("This property is only used for the current cache, use Cache.expirationDelay to access the expiration delay per cache.")]
public static int expirationDelay { get; public set; }
    public static int cacheCount { get; }
    [StaticAccessorAttribute("CachingManagerWrapper", "2")]
public static Cache defaultCache { get; }
    [StaticAccessorAttribute("CachingManagerWrapper", "2")]
public static Cache currentCacheForWriting { get; public set; }
    public static bool get_compressionEnabled();
    public static void set_compressionEnabled(bool value);
    [NativeNameAttribute("GetIsReady")]
public static bool get_ready();
    public static bool ClearCache();
    public static bool ClearCache(int expiration);
    [NativeNameAttribute("ClearCache")]
internal static bool ClearCache_Int(int expiration);
    public static bool ClearCachedVersion(string assetBundleName, Hash128 hash);
    [NativeNameAttribute("ClearCachedVersion")]
internal static bool ClearCachedVersionInternal(string assetBundleName, Hash128 hash);
    public static bool ClearOtherCachedVersions(string assetBundleName, Hash128 hash);
    public static bool ClearAllCachedVersions(string assetBundleName);
    internal static bool ClearCachedVersions(string assetBundleName, Hash128 hash, bool keepInputVersion);
    internal static Hash128[] GetCachedVersions(string assetBundleName);
    public static void GetCachedVersions(string assetBundleName, List`1<Hash128> outCachedVersions);
    [ObsoleteAttribute("Please use IsVersionCached with Hash128 instead.")]
public static bool IsVersionCached(string url, int version);
    public static bool IsVersionCached(string url, Hash128 hash);
    public static bool IsVersionCached(CachedAssetBundle cachedBundle);
    [NativeNameAttribute("IsCached")]
internal static bool IsVersionCached(string url, string assetBundleName, Hash128 hash);
    [ObsoleteAttribute("Please use MarkAsUsed with Hash128 instead.")]
public static bool MarkAsUsed(string url, int version);
    public static bool MarkAsUsed(string url, Hash128 hash);
    public static bool MarkAsUsed(CachedAssetBundle cachedBundle);
    internal static bool MarkAsUsed(string url, string assetBundleName, Hash128 hash);
    [ObsoleteAttribute("This function is obsolete and will always return -1. Use IsVersionCached instead.")]
public static int GetVersionFromCache(string url);
    public static int get_spaceUsed();
    [NativeNameAttribute("GetCachingDiskSpaceUsed")]
[StaticAccessorAttribute("GetCachingManager().GetCurrentCache()", "0")]
public static long get_spaceOccupied();
    public static int get_spaceAvailable();
    [NativeNameAttribute("GetCachingDiskSpaceFree")]
[StaticAccessorAttribute("GetCachingManager().GetCurrentCache()", "0")]
public static long get_spaceFree();
    [NativeNameAttribute("GetMaximumDiskSpaceAvailable")]
public static long get_maximumAvailableDiskSpace();
    [NativeNameAttribute("SetMaximumDiskSpaceAvailable")]
public static void set_maximumAvailableDiskSpace(long value);
    public static int get_expirationDelay();
    public static void set_expirationDelay(int value);
    public static Cache AddCache(string cachePath);
    [NativeNameAttribute("AddCachePath")]
internal static Cache AddCache(string cachePath, bool isReadonly);
    [NativeThrowsAttribute]
[NativeNameAttribute("Caching_GetCacheHandleAt")]
[StaticAccessorAttribute("CachingManagerWrapper", "2")]
public static Cache GetCacheAt(int cacheIndex);
    [StaticAccessorAttribute("CachingManagerWrapper", "2")]
[NativeThrowsAttribute]
[NativeNameAttribute("Caching_GetCacheHandleByPath")]
public static Cache GetCacheByPath(string cachePath);
    public static void GetAllCachePaths(List`1<string> cachePaths);
    [NativeNameAttribute("Caching_RemoveCacheByHandle")]
[NativeThrowsAttribute]
[StaticAccessorAttribute("CachingManagerWrapper", "2")]
public static bool RemoveCache(Cache cache);
    [StaticAccessorAttribute("CachingManagerWrapper", "2")]
[NativeNameAttribute("Caching_MoveCacheBeforeByHandle")]
[NativeThrowsAttribute]
public static void MoveCacheBefore(Cache src, Cache dst);
    [NativeThrowsAttribute]
[NativeNameAttribute("Caching_MoveCacheAfterByHandle")]
[StaticAccessorAttribute("CachingManagerWrapper", "2")]
public static void MoveCacheAfter(Cache src, Cache dst);
    public static int get_cacheCount();
    [NativeNameAttribute("Caching_GetDefaultCacheHandle")]
public static Cache get_defaultCache();
    [NativeNameAttribute("Caching_GetCurrentCacheHandle")]
public static Cache get_currentCacheForWriting();
    [NativeNameAttribute("Caching_SetCurrentCacheByHandle")]
[NativeThrowsAttribute]
public static void set_currentCacheForWriting(Cache value);
    [ObsoleteAttribute("This function is obsolete. Please use ClearCache.  (UnityUpgradable) -> ClearCache()")]
public static bool CleanCache();
    private static bool ClearCachedVersionInternal_Injected(string assetBundleName, Hash128& hash);
    private static bool ClearCachedVersions_Injected(string assetBundleName, Hash128& hash, bool keepInputVersion);
    private static bool IsVersionCached_Injected(string url, string assetBundleName, Hash128& hash);
    private static bool MarkAsUsed_Injected(string url, string assetBundleName, Hash128& hash);
    private static void AddCache_Injected(string cachePath, bool isReadonly, Cache& ret);
    private static void GetCacheAt_Injected(int cacheIndex, Cache& ret);
    private static void GetCacheByPath_Injected(string cachePath, Cache& ret);
    private static bool RemoveCache_Injected(Cache& cache);
    private static void MoveCacheBefore_Injected(Cache& src, Cache& dst);
    private static void MoveCacheAfter_Injected(Cache& src, Cache& dst);
    private static void get_defaultCache_Injected(Cache& ret);
    private static void get_currentCacheForWriting_Injected(Cache& ret);
    private static void set_currentCacheForWriting_Injected(Cache& value);
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Camera/RenderManager.h")]
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
[NativeHeaderAttribute("Runtime/Graphics/RenderTexture.h")]
[NativeHeaderAttribute("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
[NativeHeaderAttribute("Runtime/Misc/GameObjectUtility.h")]
[NativeHeaderAttribute("Runtime/Shaders/Shader.h")]
[RequireComponent("UnityEngine.Transform")]
[NativeHeaderAttribute("Runtime/Camera/Camera.h")]
public class UnityEngine.Camera : Behaviour {
    public static float kMinAperture;
    public static float kMaxAperture;
    public static int kMinBladeCount;
    public static int kMaxBladeCount;
    public static CameraCallback onPreCull;
    public static CameraCallback onPreRender;
    public static CameraCallback onPostRender;
    [NativePropertyAttribute("Near")]
public float nearClipPlane { get; public set; }
    [NativePropertyAttribute("Far")]
public float farClipPlane { get; public set; }
    [NativePropertyAttribute("VerticalFieldOfView")]
public float fieldOfView { get; public set; }
    public RenderingPath renderingPath { get; public set; }
    public RenderingPath actualRenderingPath { get; }
    public bool allowHDR { get; public set; }
    public bool allowMSAA { get; public set; }
    public bool allowDynamicResolution { get; public set; }
    [NativePropertyAttribute("ForceIntoRT")]
public bool forceIntoRenderTexture { get; public set; }
    public float orthographicSize { get; public set; }
    public bool orthographic { get; public set; }
    public OpaqueSortMode opaqueSortMode { get; public set; }
    public TransparencySortMode transparencySortMode { get; public set; }
    public Vector3 transparencySortAxis { get; public set; }
    public float depth { get; public set; }
    public float aspect { get; public set; }
    public Vector3 velocity { get; }
    public int cullingMask { get; public set; }
    public int eventMask { get; public set; }
    public bool layerCullSpherical { get; public set; }
    public CameraType cameraType { get; public set; }
    internal Material skyboxMaterial { get; }
    [NativeConditionalAttribute("UNITY_EDITOR")]
public ulong overrideSceneCullingMask { get; public set; }
    [NativeConditionalAttribute("UNITY_EDITOR")]
internal ulong sceneCullingMask { get; }
    public Single[] layerCullDistances { get; public set; }
    [ObsoleteAttribute("PreviewCullingLayer is obsolete. Use scene culling masks instead.", "False")]
internal static int PreviewCullingLayer { get; }
    public bool useOcclusionCulling { get; public set; }
    public Matrix4x4 cullingMatrix { get; public set; }
    public Color backgroundColor { get; public set; }
    public CameraClearFlags clearFlags { get; public set; }
    public DepthTextureMode depthTextureMode { get; public set; }
    public bool clearStencilAfterLightingPass { get; public set; }
    internal ProjectionMatrixMode projectionMatrixMode { get; }
    public bool usePhysicalProperties { get; public set; }
    public int iso { get; public set; }
    public float shutterSpeed { get; public set; }
    public float aperture { get; public set; }
    public float focusDistance { get; public set; }
    public float focalLength { get; public set; }
    public int bladeCount { get; public set; }
    public Vector2 curvature { get; public set; }
    public float barrelClipping { get; public set; }
    public float anamorphism { get; public set; }
    public Vector2 sensorSize { get; public set; }
    public Vector2 lensShift { get; public set; }
    public GateFitMode gateFit { get; public set; }
    [NativePropertyAttribute("NormalizedViewportRect")]
public Rect rect { get; public set; }
    [NativePropertyAttribute("ScreenViewportRect")]
public Rect pixelRect { get; public set; }
    public int pixelWidth { get; }
    public int pixelHeight { get; }
    public int scaledPixelWidth { get; }
    public int scaledPixelHeight { get; }
    public RenderTexture targetTexture { get; public set; }
    public RenderTexture activeTexture { get; }
    public int targetDisplay { get; public set; }
    public Matrix4x4 cameraToWorldMatrix { get; }
    public Matrix4x4 worldToCameraMatrix { get; public set; }
    public Matrix4x4 projectionMatrix { get; public set; }
    public Matrix4x4 nonJitteredProjectionMatrix { get; public set; }
    [NativePropertyAttribute("UseJitteredProjectionMatrixForTransparent")]
public bool useJitteredProjectionMatrixForTransparentRendering { get; public set; }
    public Matrix4x4 previousViewProjectionMatrix { get; }
    public static Camera main { get; }
    public static Camera current { get; }
    public Scene scene { get; public set; }
    public bool stereoEnabled { get; }
    public float stereoSeparation { get; public set; }
    public float stereoConvergence { get; public set; }
    public bool areVRStereoViewMatricesWithinSingleCullTolerance { get; }
    public StereoTargetEyeMask stereoTargetEye { get; public set; }
    public MonoOrStereoscopicEye stereoActiveEye { get; }
    public static int allCamerasCount { get; }
    public static Camera[] allCameras { get; }
    [NativeConditionalAttribute("UNITY_EDITOR")]
public SceneViewFilterMode sceneViewFilterMode { get; }
    public int commandBufferCount { get; }
    public float get_nearClipPlane();
    public void set_nearClipPlane(float value);
    public float get_farClipPlane();
    public void set_farClipPlane(float value);
    public float get_fieldOfView();
    public void set_fieldOfView(float value);
    public RenderingPath get_renderingPath();
    public void set_renderingPath(RenderingPath value);
    [NativeNameAttribute("CalculateRenderingPath")]
public RenderingPath get_actualRenderingPath();
    public void Reset();
    public bool get_allowHDR();
    public void set_allowHDR(bool value);
    public bool get_allowMSAA();
    public void set_allowMSAA(bool value);
    public bool get_allowDynamicResolution();
    public void set_allowDynamicResolution(bool value);
    public bool get_forceIntoRenderTexture();
    public void set_forceIntoRenderTexture(bool value);
    public float get_orthographicSize();
    public void set_orthographicSize(float value);
    public bool get_orthographic();
    public void set_orthographic(bool value);
    public OpaqueSortMode get_opaqueSortMode();
    public void set_opaqueSortMode(OpaqueSortMode value);
    public TransparencySortMode get_transparencySortMode();
    public void set_transparencySortMode(TransparencySortMode value);
    public Vector3 get_transparencySortAxis();
    public void set_transparencySortAxis(Vector3 value);
    public void ResetTransparencySortSettings();
    public float get_depth();
    public void set_depth(float value);
    public float get_aspect();
    public void set_aspect(float value);
    public void ResetAspect();
    public Vector3 get_velocity();
    public int get_cullingMask();
    public void set_cullingMask(int value);
    public int get_eventMask();
    public void set_eventMask(int value);
    public bool get_layerCullSpherical();
    public void set_layerCullSpherical(bool value);
    public CameraType get_cameraType();
    public void set_cameraType(CameraType value);
    internal Material get_skyboxMaterial();
    public ulong get_overrideSceneCullingMask();
    public void set_overrideSceneCullingMask(ulong value);
    internal ulong get_sceneCullingMask();
    [FreeFunctionAttribute("CameraScripting::GetLayerCullDistances")]
private Single[] GetLayerCullDistances();
    [FreeFunctionAttribute("CameraScripting::SetLayerCullDistances")]
private void SetLayerCullDistances(Single[] d);
    public Single[] get_layerCullDistances();
    public void set_layerCullDistances(Single[] value);
    internal static int get_PreviewCullingLayer();
    public bool get_useOcclusionCulling();
    public void set_useOcclusionCulling(bool value);
    public Matrix4x4 get_cullingMatrix();
    public void set_cullingMatrix(Matrix4x4 value);
    public void ResetCullingMatrix();
    public Color get_backgroundColor();
    public void set_backgroundColor(Color value);
    public CameraClearFlags get_clearFlags();
    public void set_clearFlags(CameraClearFlags value);
    public DepthTextureMode get_depthTextureMode();
    public void set_depthTextureMode(DepthTextureMode value);
    public bool get_clearStencilAfterLightingPass();
    public void set_clearStencilAfterLightingPass(bool value);
    public void SetReplacementShader(Shader shader, string replacementTag);
    public void ResetReplacementShader();
    internal ProjectionMatrixMode get_projectionMatrixMode();
    public bool get_usePhysicalProperties();
    public void set_usePhysicalProperties(bool value);
    public int get_iso();
    public void set_iso(int value);
    public float get_shutterSpeed();
    public void set_shutterSpeed(float value);
    public float get_aperture();
    public void set_aperture(float value);
    public float get_focusDistance();
    public void set_focusDistance(float value);
    public float get_focalLength();
    public void set_focalLength(float value);
    public int get_bladeCount();
    public void set_bladeCount(int value);
    public Vector2 get_curvature();
    public void set_curvature(Vector2 value);
    public float get_barrelClipping();
    public void set_barrelClipping(float value);
    public float get_anamorphism();
    public void set_anamorphism(float value);
    public Vector2 get_sensorSize();
    public void set_sensorSize(Vector2 value);
    public Vector2 get_lensShift();
    public void set_lensShift(Vector2 value);
    public GateFitMode get_gateFit();
    public void set_gateFit(GateFitMode value);
    public float GetGateFittedFieldOfView();
    public Vector2 GetGateFittedLensShift();
    internal Vector3 GetLocalSpaceAim();
    public Rect get_rect();
    public void set_rect(Rect value);
    public Rect get_pixelRect();
    public void set_pixelRect(Rect value);
    [FreeFunctionAttribute("CameraScripting::GetPixelWidth")]
public int get_pixelWidth();
    [FreeFunctionAttribute("CameraScripting::GetPixelHeight")]
public int get_pixelHeight();
    [FreeFunctionAttribute("CameraScripting::GetScaledPixelWidth")]
public int get_scaledPixelWidth();
    [FreeFunctionAttribute("CameraScripting::GetScaledPixelHeight")]
public int get_scaledPixelHeight();
    public RenderTexture get_targetTexture();
    public void set_targetTexture(RenderTexture value);
    [NativeNameAttribute("GetCurrentTargetTexture")]
public RenderTexture get_activeTexture();
    public int get_targetDisplay();
    public void set_targetDisplay(int value);
    [FreeFunctionAttribute("CameraScripting::SetTargetBuffers")]
private void SetTargetBuffersImpl(RenderBuffer color, RenderBuffer depth);
    public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer);
    [FreeFunctionAttribute("CameraScripting::SetTargetBuffers")]
private void SetTargetBuffersMRTImpl(RenderBuffer[] color, RenderBuffer depth);
    public void SetTargetBuffers(RenderBuffer[] colorBuffer, RenderBuffer depthBuffer);
    internal String[] GetCameraBufferWarnings();
    public Matrix4x4 get_cameraToWorldMatrix();
    public Matrix4x4 get_worldToCameraMatrix();
    public void set_worldToCameraMatrix(Matrix4x4 value);
    public Matrix4x4 get_projectionMatrix();
    public void set_projectionMatrix(Matrix4x4 value);
    public Matrix4x4 get_nonJitteredProjectionMatrix();
    public void set_nonJitteredProjectionMatrix(Matrix4x4 value);
    public bool get_useJitteredProjectionMatrixForTransparentRendering();
    public void set_useJitteredProjectionMatrixForTransparentRendering(bool value);
    public Matrix4x4 get_previousViewProjectionMatrix();
    public void ResetWorldToCameraMatrix();
    public void ResetProjectionMatrix();
    [FreeFunctionAttribute("CameraScripting::CalculateObliqueMatrix")]
public Matrix4x4 CalculateObliqueMatrix(Vector4 clipPlane);
    public Vector3 WorldToScreenPoint(Vector3 position, MonoOrStereoscopicEye eye);
    public Vector3 WorldToViewportPoint(Vector3 position, MonoOrStereoscopicEye eye);
    public Vector3 ViewportToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye);
    public Vector3 ScreenToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye);
    public Vector3 WorldToScreenPoint(Vector3 position);
    public Vector3 WorldToViewportPoint(Vector3 position);
    public Vector3 ViewportToWorldPoint(Vector3 position);
    public Vector3 ScreenToWorldPoint(Vector3 position);
    public Vector3 ScreenToViewportPoint(Vector3 position);
    public Vector3 ViewportToScreenPoint(Vector3 position);
    internal Vector2 GetFrustumPlaneSizeAt(float distance);
    private Ray ViewportPointToRay(Vector2 pos, MonoOrStereoscopicEye eye);
    public Ray ViewportPointToRay(Vector3 pos, MonoOrStereoscopicEye eye);
    public Ray ViewportPointToRay(Vector3 pos);
    private Ray ScreenPointToRay(Vector2 pos, MonoOrStereoscopicEye eye);
    public Ray ScreenPointToRay(Vector3 pos, MonoOrStereoscopicEye eye);
    public Ray ScreenPointToRay(Vector3 pos);
    [FreeFunctionAttribute("CameraScripting::CalculateViewportRayVectors")]
private void CalculateFrustumCornersInternal(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners);
    public void CalculateFrustumCorners(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners);
    [NativeNameAttribute("CalculateProjectionMatrixFromPhysicalProperties")]
private static void CalculateProjectionMatrixFromPhysicalPropertiesInternal(Matrix4x4& output, float focalLength, Vector2 sensorSize, Vector2 lensShift, float nearClip, float farClip, float gateAspect, GateFitMode gateFitMode);
    public static void CalculateProjectionMatrixFromPhysicalProperties(Matrix4x4& output, float focalLength, Vector2 sensorSize, Vector2 lensShift, float nearClip, float farClip, GateFitParameters gateFitParameters);
    [NativeNameAttribute("FocalLengthToFieldOfView_Safe")]
public static float FocalLengthToFieldOfView(float focalLength, float sensorSize);
    [NativeNameAttribute("FieldOfViewToFocalLength_Safe")]
public static float FieldOfViewToFocalLength(float fieldOfView, float sensorSize);
    [NativeNameAttribute("HorizontalToVerticalFieldOfView_Safe")]
public static float HorizontalToVerticalFieldOfView(float horizontalFieldOfView, float aspectRatio);
    public static float VerticalToHorizontalFieldOfView(float verticalFieldOfView, float aspectRatio);
    [FreeFunctionAttribute("FindMainCamera")]
public static Camera get_main();
    [FreeFunctionAttribute("GetCurrentCameraPPtr")]
public static Camera get_current();
    [FreeFunctionAttribute("CameraScripting::GetScene")]
public Scene get_scene();
    [FreeFunctionAttribute("CameraScripting::SetScene")]
public void set_scene(Scene value);
    [NativeMethodAttribute("GetStereoEnabledForBuiltInOrSRP")]
public bool get_stereoEnabled();
    public float get_stereoSeparation();
    public void set_stereoSeparation(float value);
    public float get_stereoConvergence();
    public void set_stereoConvergence(float value);
    [NativeNameAttribute("AreVRStereoViewMatricesWithinSingleCullTolerance")]
public bool get_areVRStereoViewMatricesWithinSingleCullTolerance();
    public StereoTargetEyeMask get_stereoTargetEye();
    public void set_stereoTargetEye(StereoTargetEyeMask value);
    [FreeFunctionAttribute("CameraScripting::GetStereoActiveEye")]
public MonoOrStereoscopicEye get_stereoActiveEye();
    public Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye eye);
    [FreeFunctionAttribute("CameraScripting::GetStereoViewMatrix")]
public Matrix4x4 GetStereoViewMatrix(StereoscopicEye eye);
    public void CopyStereoDeviceProjectionMatrixToNonJittered(StereoscopicEye eye);
    [FreeFunctionAttribute("CameraScripting::GetStereoProjectionMatrix")]
public Matrix4x4 GetStereoProjectionMatrix(StereoscopicEye eye);
    public void SetStereoProjectionMatrix(StereoscopicEye eye, Matrix4x4 matrix);
    public void ResetStereoProjectionMatrices();
    public void SetStereoViewMatrix(StereoscopicEye eye, Matrix4x4 matrix);
    public void ResetStereoViewMatrices();
    [FreeFunctionAttribute("CameraScripting::GetAllCamerasCount")]
private static int GetAllCamerasCount();
    [FreeFunctionAttribute("CameraScripting::GetAllCameras")]
private static int GetAllCamerasImpl(Camera[] cam);
    public static int get_allCamerasCount();
    public static Camera[] get_allCameras();
    public static int GetAllCameras(Camera[] cameras);
    [FreeFunctionAttribute("CameraScripting::RenderToCubemap")]
private bool RenderToCubemapImpl(Texture tex, int faceMask);
    public bool RenderToCubemap(Cubemap cubemap, int faceMask);
    public bool RenderToCubemap(Cubemap cubemap);
    public bool RenderToCubemap(RenderTexture cubemap, int faceMask);
    public bool RenderToCubemap(RenderTexture cubemap);
    [NativeConditionalAttribute("UNITY_EDITOR")]
private int GetFilterMode();
    public SceneViewFilterMode get_sceneViewFilterMode();
    [NativeNameAttribute("RenderToCubemap")]
private bool RenderToCubemapEyeImpl(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye);
    public bool RenderToCubemap(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye);
    [FreeFunctionAttribute("CameraScripting::Render")]
public void Render();
    [FreeFunctionAttribute("CameraScripting::RenderWithShader")]
public void RenderWithShader(Shader shader, string replacementTag);
    [FreeFunctionAttribute("CameraScripting::RenderDontRestore")]
public void RenderDontRestore();
    [ObsoleteAttribute("SubmitRenderRequests is obsolete, use SubmitRenderRequest with RequestData of supported types such as RenderPipeline.StandardRequest", "True")]
public void SubmitRenderRequests(List`1<RenderRequest> renderRequests);
    public void SubmitRenderRequest(RequestData renderRequest);
    [FreeFunctionAttribute("CameraScripting::SubmitRenderRequests")]
private void SubmitRenderRequestsInternal(object requests);
    [NativeConditionalAttribute("UNITY_EDITOR")]
[FreeFunctionAttribute("CameraScripting::SubmitBuiltInObjectIDRenderRequest")]
private Object[] SubmitBuiltInObjectIDRenderRequest(RenderTexture target, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    [FreeFunctionAttribute("CameraScripting::SetupCurrent")]
public static void SetupCurrent(Camera cur);
    [FreeFunctionAttribute("CameraScripting::CopyFrom")]
public void CopyFrom(Camera other);
    public int get_commandBufferCount();
    public void RemoveCommandBuffers(CameraEvent evt);
    public void RemoveAllCommandBuffers();
    [NativeNameAttribute("AddCommandBuffer")]
private void AddCommandBufferImpl(CameraEvent evt, CommandBuffer buffer);
    [NativeNameAttribute("AddCommandBufferAsync")]
private void AddCommandBufferAsyncImpl(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType);
    [NativeNameAttribute("RemoveCommandBuffer")]
private void RemoveCommandBufferImpl(CameraEvent evt, CommandBuffer buffer);
    public void AddCommandBuffer(CameraEvent evt, CommandBuffer buffer);
    public void AddCommandBufferAsync(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType);
    public void RemoveCommandBuffer(CameraEvent evt, CommandBuffer buffer);
    [FreeFunctionAttribute("CameraScripting::GetCommandBuffers")]
public CommandBuffer[] GetCommandBuffers(CameraEvent evt);
    [RequiredByNativeCodeAttribute]
private static void FireOnPreCull(Camera cam);
    [RequiredByNativeCodeAttribute]
private static void FireOnPreRender(Camera cam);
    [RequiredByNativeCodeAttribute]
private static void FireOnPostRender(Camera cam);
    internal void OnlyUsedForTesting1();
    internal void OnlyUsedForTesting2();
    public bool TryGetCullingParameters(ScriptableCullingParameters& cullingParameters);
    public bool TryGetCullingParameters(bool stereoAware, ScriptableCullingParameters& cullingParameters);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::GetCullingParameters_Internal")]
[NativeHeaderAttribute("Runtime/Export/RenderPipeline/ScriptableRenderPipeline.bindings.h")]
private static bool GetCullingParameters_Internal(Camera camera, bool stereoAware, ScriptableCullingParameters& cullingParameters, int managedCullingParametersSize);
    private void get_transparencySortAxis_Injected(Vector3& ret);
    private void set_transparencySortAxis_Injected(Vector3& value);
    private void get_velocity_Injected(Vector3& ret);
    private void get_cullingMatrix_Injected(Matrix4x4& ret);
    private void set_cullingMatrix_Injected(Matrix4x4& value);
    private void get_backgroundColor_Injected(Color& ret);
    private void set_backgroundColor_Injected(Color& value);
    private void get_curvature_Injected(Vector2& ret);
    private void set_curvature_Injected(Vector2& value);
    private void get_sensorSize_Injected(Vector2& ret);
    private void set_sensorSize_Injected(Vector2& value);
    private void get_lensShift_Injected(Vector2& ret);
    private void set_lensShift_Injected(Vector2& value);
    private void GetGateFittedLensShift_Injected(Vector2& ret);
    private void GetLocalSpaceAim_Injected(Vector3& ret);
    private void get_rect_Injected(Rect& ret);
    private void set_rect_Injected(Rect& value);
    private void get_pixelRect_Injected(Rect& ret);
    private void set_pixelRect_Injected(Rect& value);
    private void SetTargetBuffersImpl_Injected(RenderBuffer& color, RenderBuffer& depth);
    private void SetTargetBuffersMRTImpl_Injected(RenderBuffer[] color, RenderBuffer& depth);
    private void get_cameraToWorldMatrix_Injected(Matrix4x4& ret);
    private void get_worldToCameraMatrix_Injected(Matrix4x4& ret);
    private void set_worldToCameraMatrix_Injected(Matrix4x4& value);
    private void get_projectionMatrix_Injected(Matrix4x4& ret);
    private void set_projectionMatrix_Injected(Matrix4x4& value);
    private void get_nonJitteredProjectionMatrix_Injected(Matrix4x4& ret);
    private void set_nonJitteredProjectionMatrix_Injected(Matrix4x4& value);
    private void get_previousViewProjectionMatrix_Injected(Matrix4x4& ret);
    private void CalculateObliqueMatrix_Injected(Vector4& clipPlane, Matrix4x4& ret);
    private void WorldToScreenPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret);
    private void WorldToViewportPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret);
    private void ViewportToWorldPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret);
    private void ScreenToWorldPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret);
    private void ScreenToViewportPoint_Injected(Vector3& position, Vector3& ret);
    private void ViewportToScreenPoint_Injected(Vector3& position, Vector3& ret);
    private void GetFrustumPlaneSizeAt_Injected(float distance, Vector2& ret);
    private void ViewportPointToRay_Injected(Vector2& pos, MonoOrStereoscopicEye eye, Ray& ret);
    private void ScreenPointToRay_Injected(Vector2& pos, MonoOrStereoscopicEye eye, Ray& ret);
    private void CalculateFrustumCornersInternal_Injected(Rect& viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners);
    private static void CalculateProjectionMatrixFromPhysicalPropertiesInternal_Injected(Matrix4x4& output, float focalLength, Vector2& sensorSize, Vector2& lensShift, float nearClip, float farClip, float gateAspect, GateFitMode gateFitMode);
    private void get_scene_Injected(Scene& ret);
    private void set_scene_Injected(Scene& value);
    private void GetStereoNonJitteredProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret);
    private void GetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret);
    private void GetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret);
    private void SetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix);
    private void SetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix);
}
public enum UnityEngine.CameraClearFlags : Enum {
    public int value__;
    public static CameraClearFlags Skybox;
    public static CameraClearFlags Color;
    public static CameraClearFlags SolidColor;
    public static CameraClearFlags Depth;
    public static CameraClearFlags Nothing;
}
[FlagsAttribute]
public enum UnityEngine.CameraType : Enum {
    public int value__;
    public static CameraType Game;
    public static CameraType SceneView;
    public static CameraType Preview;
    public static CameraType VR;
    public static CameraType Reflection;
}
internal class UnityEngine.CastHelper`1 : ValueType {
    public T t;
    public IntPtr onePointerFurtherThanT;
}
internal static class UnityEngine.ClassLibraryInitializer : object {
    [RequiredByNativeCodeAttribute]
private static void Init();
    [RequiredByNativeCodeAttribute]
private static void InitStdErrWithHandle(IntPtr fileHandle);
    [RequiredByNativeCodeAttribute]
private static void InitAssemblyRedirections();
}
[DefaultMemberAttribute("Item")]
[NativeHeaderAttribute("Runtime/Math/Color.h")]
[RequiredByNativeCodeAttribute]
[NativeClassAttribute("ColorRGBAf")]
public class UnityEngine.Color : ValueType {
    public float r;
    public float g;
    public float b;
    public float a;
    public static Color red { get; }
    public static Color green { get; }
    public static Color blue { get; }
    public static Color white { get; }
    public static Color black { get; }
    public static Color yellow { get; }
    public static Color cyan { get; }
    public static Color magenta { get; }
    public static Color gray { get; }
    public static Color grey { get; }
    public static Color clear { get; }
    public float grayscale { get; }
    public Color linear { get; }
    public Color gamma { get; }
    public float maxColorComponent { get; }
    public float Item { get; public set; }
    public Color(float r, float g, float b, float a);
    public Color(float r, float g, float b);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Color other);
    public static Color op_Addition(Color a, Color b);
    public static Color op_Subtraction(Color a, Color b);
    public static Color op_Multiply(Color a, Color b);
    public static Color op_Multiply(Color a, float b);
    public static Color op_Multiply(float b, Color a);
    public static Color op_Division(Color a, float b);
    public static bool op_Equality(Color lhs, Color rhs);
    public static bool op_Inequality(Color lhs, Color rhs);
    public static Color Lerp(Color a, Color b, float t);
    public static Color LerpUnclamped(Color a, Color b, float t);
    internal Color RGBMultiplied(float multiplier);
    internal Color AlphaMultiplied(float multiplier);
    internal Color RGBMultiplied(Color multiplier);
    public static Color get_red();
    public static Color get_green();
    public static Color get_blue();
    public static Color get_white();
    public static Color get_black();
    public static Color get_yellow();
    public static Color get_cyan();
    public static Color get_magenta();
    public static Color get_gray();
    public static Color get_grey();
    public static Color get_clear();
    public float get_grayscale();
    public Color get_linear();
    public Color get_gamma();
    public float get_maxColorComponent();
    public static Vector4 op_Implicit(Color c);
    public static Color op_Implicit(Vector4 v);
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public static void RGBToHSV(Color rgbColor, Single& H, Single& S, Single& V);
    private static void RGBToHSVHelper(float offset, float dominantcolor, float colorone, float colortwo, Single& H, Single& S, Single& V);
    public static Color HSVToRGB(float H, float S, float V);
    public static Color HSVToRGB(float H, float S, float V, bool hdr);
}
[DefaultMemberAttribute("Item")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Color32 : ValueType {
    [IgnoreAttribute]
private int rgba;
    public byte r;
    public byte g;
    public byte b;
    public byte a;
    public byte Item { get; public set; }
    public Color32(byte r, byte g, byte b, byte a);
    public static Color32 op_Implicit(Color c);
    public static Color op_Implicit(Color32 c);
    public static Color32 Lerp(Color32 a, Color32 b, float t);
    public static Color32 LerpUnclamped(Color32 a, Color32 b, float t);
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    [VisibleToOtherModulesAttribute]
internal bool InternalEquals(Color32 other);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[NativeHeaderAttribute("Runtime/Graphics/ColorGamut.h")]
[UsedByNativeCodeAttribute]
public enum UnityEngine.ColorGamut : Enum {
    public int value__;
    public static ColorGamut sRGB;
    public static ColorGamut Rec709;
    public static ColorGamut Rec2020;
    public static ColorGamut DisplayP3;
    public static ColorGamut HDR10;
    public static ColorGamut DolbyHDR;
    public static ColorGamut P3D65G22;
}
public class UnityEngine.ColorGamutUtility : object {
    [FreeFunctionAttribute]
public static ColorPrimaries GetColorPrimaries(ColorGamut gamut);
    [FreeFunctionAttribute]
public static WhitePoint GetWhitePoint(ColorGamut gamut);
    [FreeFunctionAttribute]
public static TransferFunction GetTransferFunction(ColorGamut gamut);
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/ColorGamut.h")]
public enum UnityEngine.ColorPrimaries : Enum {
    public int value__;
    public static ColorPrimaries Unknown;
    public static ColorPrimaries Rec709;
    public static ColorPrimaries Rec2020;
    public static ColorPrimaries P3;
}
public enum UnityEngine.ColorSpace : Enum {
    public int value__;
    public static ColorSpace Uninitialized;
    public static ColorSpace Gamma;
    public static ColorSpace Linear;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.ColorUsageAttribute : PropertyAttribute {
    public bool showAlpha;
    public bool hdr;
    [ObsoleteAttribute("This field is no longer used for anything.")]
public float minBrightness;
    [ObsoleteAttribute("This field is no longer used for anything.")]
public float maxBrightness;
    [ObsoleteAttribute("This field is no longer used for anything.")]
public float minExposureValue;
    [ObsoleteAttribute("This field is no longer used for anything.")]
public float maxExposureValue;
    public ColorUsageAttribute(bool showAlpha);
    public ColorUsageAttribute(bool showAlpha, bool hdr);
    [ObsoleteAttribute("Brightness and exposure parameters are no longer used for anything. Use ColorUsageAttribute(bool showAlpha, bool hdr)")]
public ColorUsageAttribute(bool showAlpha, bool hdr, float minBrightness, float maxBrightness, float minExposureValue, float maxExposureValue);
}
[NativeHeaderAttribute("Runtime/Math/ColorUtility.h")]
public class UnityEngine.ColorUtility : object {
    [FreeFunctionAttribute("TryParseHtmlColor", "True")]
internal static bool DoTryParseHtmlColor(string htmlString, Color32& color);
    public static bool TryParseHtmlString(string htmlString, Color& color);
    public static string ToHtmlStringRGB(Color color);
    public static string ToHtmlStringRGBA(Color color);
}
public class UnityEngine.CombineInstance : ValueType {
    private int m_MeshInstanceID;
    private int m_SubMeshIndex;
    private Matrix4x4 m_Transform;
    private Vector4 m_LightmapScaleOffset;
    private Vector4 m_RealtimeLightmapScaleOffset;
    public Mesh mesh { get; public set; }
    public int subMeshIndex { get; public set; }
    public Matrix4x4 transform { get; public set; }
    public Vector4 lightmapScaleOffset { get; public set; }
    public Vector4 realtimeLightmapScaleOffset { get; public set; }
    public Mesh get_mesh();
    public void set_mesh(Mesh value);
    public int get_subMeshIndex();
    public void set_subMeshIndex(int value);
    public Matrix4x4 get_transform();
    public void set_transform(Matrix4x4 value);
    public Vector4 get_lightmapScaleOffset();
    public void set_lightmapScaleOffset(Vector4 value);
    public Vector4 get_realtimeLightmapScaleOffset();
    public void set_realtimeLightmapScaleOffset(Vector4 value);
}
[NativeHeaderAttribute("Runtime/Export/Scripting/Component.bindings.h")]
[NativeClassAttribute("Unity::Component")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.Component : Object {
    public Transform transform { get; }
    public GameObject gameObject { get; }
    public string tag { get; public set; }
    [FreeFunctionAttribute("GetTransform")]
public Transform get_transform();
    [FreeFunctionAttribute("GetGameObject")]
public GameObject get_gameObject();
    [TypeInferenceRuleAttribute("0")]
public Component GetComponent(Type type);
    [FreeFunctionAttribute]
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue);
    [SecuritySafeCriticalAttribute]
public T GetComponent();
    [TypeInferenceRuleAttribute("0")]
public bool TryGetComponent(Type type, Component& component);
    [SecuritySafeCriticalAttribute]
public bool TryGetComponent(T& component);
    [FreeFunctionAttribute]
public Component GetComponent(string type);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInChildren(Type t, bool includeInactive);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInChildren(Type t);
    public T GetComponentInChildren(bool includeInactive);
    [ExcludeFromDocsAttribute]
public T GetComponentInChildren();
    public Component[] GetComponentsInChildren(Type t, bool includeInactive);
    [ExcludeFromDocsAttribute]
public Component[] GetComponentsInChildren(Type t);
    public T[] GetComponentsInChildren(bool includeInactive);
    public void GetComponentsInChildren(bool includeInactive, List`1<T> result);
    public T[] GetComponentsInChildren();
    public void GetComponentsInChildren(List`1<T> results);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInParent(Type t, bool includeInactive);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInParent(Type t);
    public T GetComponentInParent(bool includeInactive);
    public T GetComponentInParent();
    public Component[] GetComponentsInParent(Type t, bool includeInactive);
    [ExcludeFromDocsAttribute]
public Component[] GetComponentsInParent(Type t);
    public T[] GetComponentsInParent(bool includeInactive);
    public void GetComponentsInParent(bool includeInactive, List`1<T> results);
    public T[] GetComponentsInParent();
    public Component[] GetComponents(Type type);
    [FreeFunctionAttribute]
private void GetComponentsForListInternal(Type searchType, object resultList);
    public void GetComponents(Type type, List`1<Component> results);
    public void GetComponents(List`1<T> results);
    public string get_tag();
    public void set_tag(string value);
    public T[] GetComponents();
    public int GetComponentIndex();
    public bool CompareTag(string tag);
    [FreeFunctionAttribute]
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options);
    [ExcludeFromDocsAttribute]
public void SendMessageUpwards(string methodName, object value);
    [ExcludeFromDocsAttribute]
public void SendMessageUpwards(string methodName);
    public void SendMessageUpwards(string methodName, SendMessageOptions options);
    public void SendMessage(string methodName, object value);
    public void SendMessage(string methodName);
    [FreeFunctionAttribute("SendMessage")]
public void SendMessage(string methodName, object value, SendMessageOptions options);
    public void SendMessage(string methodName, SendMessageOptions options);
    [FreeFunctionAttribute("BroadcastMessage")]
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options);
    [ExcludeFromDocsAttribute]
public void BroadcastMessage(string methodName, object parameter);
    [ExcludeFromDocsAttribute]
public void BroadcastMessage(string methodName);
    public void BroadcastMessage(string methodName, SendMessageOptions options);
}
public enum UnityEngine.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Fastest;
    public static CompressionLevel Fast;
    public static CompressionLevel Normal;
    public static CompressionLevel High;
    public static CompressionLevel Maximum;
}
public enum UnityEngine.CompressionType : Enum {
    public int value__;
    public static CompressionType None;
    public static CompressionType Lzma;
    public static CompressionType Lz4;
    public static CompressionType Lz4HC;
}
[NativeClassAttribute("GraphicsBuffer")]
[NativeHeaderAttribute("Runtime/Shaders/GraphicsBuffer.h")]
[NativeHeaderAttribute("Runtime/Export/Graphics/GraphicsBuffer.bindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.ComputeBuffer : object {
    internal IntPtr m_Ptr;
    public int count { get; }
    public int stride { get; }
    private ComputeBufferMode usage { get; }
    unknown string name {public set; }
    public ComputeBuffer(int count, int stride);
    public ComputeBuffer(int count, int stride, ComputeBufferType type);
    public ComputeBuffer(int count, int stride, ComputeBufferType type, ComputeBufferMode usage);
    private ComputeBuffer(int count, int stride, ComputeBufferType type, ComputeBufferMode usage, int stackDepth);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::InitComputeBuffer")]
private static IntPtr InitBuffer(int count, int stride, ComputeBufferType type, ComputeBufferMode usage);
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::DestroyComputeBuffer")]
private static void DestroyBuffer(ComputeBuffer buf);
    public void Release();
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::IsValidBuffer")]
private static bool IsValidBuffer(ComputeBuffer buf);
    public bool IsValid();
    public int get_count();
    public int get_stride();
    private ComputeBufferMode get_usage();
    [SecuritySafeCriticalAttribute]
public void SetData(Array data);
    [SecuritySafeCriticalAttribute]
public void SetData(List`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetData(NativeArray`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetData(List`1<T> data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetData(NativeArray`1<T> data, int nativeBufferStartIndex, int computeBufferStartIndex, int count);
    [FreeFunctionAttribute]
private void InternalSetNativeData(IntPtr data, int nativeBufferStartIndex, int computeBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
private void InternalSetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize);
    [SecurityCriticalAttribute]
public void GetData(Array data);
    [SecurityCriticalAttribute]
public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
    [FreeFunctionAttribute]
private void InternalGetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize);
    private Void* BeginBufferWrite(int offset, int size);
    public NativeArray`1<T> BeginWrite(int computeBufferStartIndex, int count);
    private void EndBufferWrite(int bytesWritten);
    public void EndWrite(int countWritten);
    public void set_name(string value);
    [FreeFunctionAttribute]
private void SetName(string name);
    public void SetCounterValue(UInt32 counterValue);
    public static void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes);
    public IntPtr GetNativeBufferPtr();
}
[NativeTypeAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.ComputeBufferMode : Enum {
    public int value__;
    public static ComputeBufferMode Immutable;
    public static ComputeBufferMode Dynamic;
    [ObsoleteAttribute("ComputeBufferMode.Circular is deprecated (legacy mode)")]
public static ComputeBufferMode Circular;
    [ObsoleteAttribute("ComputeBufferMode.StreamOut is deprecated (internal use only)")]
public static ComputeBufferMode StreamOut;
    public static ComputeBufferMode SubUpdates;
}
[FlagsAttribute]
public enum UnityEngine.ComputeBufferType : Enum {
    public int value__;
    public static ComputeBufferType Default;
    public static ComputeBufferType Raw;
    public static ComputeBufferType Append;
    public static ComputeBufferType Counter;
    public static ComputeBufferType Constant;
    public static ComputeBufferType Structured;
    [ObsoleteAttribute("Enum member DrawIndirect has been deprecated. Use IndirectArguments instead (UnityUpgradable) -> IndirectArguments", "False")]
public static ComputeBufferType DrawIndirect;
    public static ComputeBufferType IndirectArguments;
    [ObsoleteAttribute("Enum member GPUMemory has been deprecated. All compute buffers now follow the behavior previously defined by this member.", "False")]
public static ComputeBufferType GPUMemory;
}
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.ComputeShader : Object {
    public LocalKeywordSpace keywordSpace { get; }
    public String[] shaderKeywords { get; public set; }
    public LocalKeyword[] enabledKeywords { get; public set; }
    [NativeMethodAttribute]
[RequiredByNativeCodeAttribute]
public int FindKernel(string name);
    [FreeFunctionAttribute]
public bool HasKernel(string name);
    [FreeFunctionAttribute]
public void SetFloat(int nameID, float val);
    [FreeFunctionAttribute]
public void SetInt(int nameID, int val);
    [FreeFunctionAttribute]
public void SetVector(int nameID, Vector4 val);
    [FreeFunctionAttribute]
public void SetMatrix(int nameID, Matrix4x4 val);
    [FreeFunctionAttribute]
private void SetFloatArray(int nameID, Single[] values);
    [FreeFunctionAttribute]
private void SetIntArray(int nameID, Int32[] values);
    [FreeFunctionAttribute]
public void SetVectorArray(int nameID, Vector4[] values);
    [FreeFunctionAttribute]
public void SetMatrixArray(int nameID, Matrix4x4[] values);
    [NativeMethodAttribute]
public void SetTexture(int kernelIndex, int nameID, Texture texture, int mipLevel);
    [NativeMethodAttribute]
private void SetRenderTexture(int kernelIndex, int nameID, RenderTexture texture, int mipLevel, RenderTextureSubElement element);
    [NativeMethodAttribute]
public void SetTextureFromGlobal(int kernelIndex, int nameID, int globalTextureNameID);
    [FreeFunctionAttribute]
private void Internal_SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer);
    [FreeFunctionAttribute]
private void Internal_SetGraphicsBuffer(int kernelIndex, int nameID, GraphicsBuffer buffer);
    public void SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer);
    public void SetBuffer(int kernelIndex, int nameID, GraphicsBuffer buffer);
    [FreeFunctionAttribute]
private void SetConstantComputeBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
    [FreeFunctionAttribute]
private void SetConstantGraphicsBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
    [NativeMethodAttribute]
public void GetKernelThreadGroupSizes(int kernelIndex, UInt32& x, UInt32& y, UInt32& z);
    [NativeNameAttribute("DispatchComputeShader")]
public void Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
    [FreeFunctionAttribute]
private void Internal_DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset);
    [FreeFunctionAttribute]
private void Internal_DispatchIndirectGraphicsBuffer(int kernelIndex, GraphicsBuffer argsBuffer, UInt32 argsOffset);
    public LocalKeywordSpace get_keywordSpace();
    [FreeFunctionAttribute("ComputeShaderScripting::EnableKeyword")]
public void EnableKeyword(string keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::DisableKeyword")]
public void DisableKeyword(string keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::IsKeywordEnabled")]
public bool IsKeywordEnabled(string keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::EnableKeyword")]
private void EnableLocalKeyword(LocalKeyword keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::DisableKeyword")]
private void DisableLocalKeyword(LocalKeyword keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::SetKeyword")]
private void SetLocalKeyword(LocalKeyword keyword, bool value);
    [FreeFunctionAttribute("ComputeShaderScripting::IsKeywordEnabled")]
private bool IsLocalKeywordEnabled(LocalKeyword keyword);
    public void EnableKeyword(LocalKeyword& keyword);
    public void DisableKeyword(LocalKeyword& keyword);
    public void SetKeyword(LocalKeyword& keyword, bool value);
    public bool IsKeywordEnabled(LocalKeyword& keyword);
    [FreeFunctionAttribute("ComputeShaderScripting::IsSupported")]
public bool IsSupported(int kernelIndex);
    [FreeFunctionAttribute("ComputeShaderScripting::GetShaderKeywords")]
private String[] GetShaderKeywords();
    [FreeFunctionAttribute("ComputeShaderScripting::SetShaderKeywords")]
private void SetShaderKeywords(String[] names);
    public String[] get_shaderKeywords();
    public void set_shaderKeywords(String[] value);
    [FreeFunctionAttribute("ComputeShaderScripting::GetEnabledKeywords")]
private LocalKeyword[] GetEnabledKeywords();
    [FreeFunctionAttribute("ComputeShaderScripting::SetEnabledKeywords")]
private void SetEnabledKeywords(LocalKeyword[] keywords);
    public LocalKeyword[] get_enabledKeywords();
    public void set_enabledKeywords(LocalKeyword[] value);
    public void SetFloat(string name, float val);
    public void SetInt(string name, int val);
    public void SetVector(string name, Vector4 val);
    public void SetMatrix(string name, Matrix4x4 val);
    public void SetVectorArray(string name, Vector4[] values);
    public void SetMatrixArray(string name, Matrix4x4[] values);
    public void SetFloats(string name, Single[] values);
    public void SetFloats(int nameID, Single[] values);
    public void SetInts(string name, Int32[] values);
    public void SetInts(int nameID, Int32[] values);
    public void SetBool(string name, bool val);
    public void SetBool(int nameID, bool val);
    public void SetTexture(int kernelIndex, int nameID, Texture texture);
    public void SetTexture(int kernelIndex, string name, Texture texture);
    public void SetTexture(int kernelIndex, string name, Texture texture, int mipLevel);
    public void SetTexture(int kernelIndex, int nameID, RenderTexture texture, int mipLevel, RenderTextureSubElement element);
    public void SetTexture(int kernelIndex, string name, RenderTexture texture, int mipLevel, RenderTextureSubElement element);
    public void SetTextureFromGlobal(int kernelIndex, string name, string globalTextureName);
    public void SetBuffer(int kernelIndex, string name, ComputeBuffer buffer);
    public void SetBuffer(int kernelIndex, string name, GraphicsBuffer buffer);
    public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
    public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size);
    public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
    public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size);
    public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset);
    [ExcludeFromDocsAttribute]
public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer);
    public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer, UInt32 argsOffset);
    [ExcludeFromDocsAttribute]
public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer);
    private void SetVector_Injected(int nameID, Vector4& val);
    private void SetMatrix_Injected(int nameID, Matrix4x4& val);
    private void get_keywordSpace_Injected(LocalKeywordSpace& ret);
    private void EnableLocalKeyword_Injected(LocalKeyword& keyword);
    private void DisableLocalKeyword_Injected(LocalKeyword& keyword);
    private void SetLocalKeyword_Injected(LocalKeyword& keyword, bool value);
    private bool IsLocalKeywordEnabled_Injected(LocalKeyword& keyword);
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("64")]
public class UnityEngine.ContextMenu : Attribute {
    public string menuItem;
    public bool validate;
    public int priority;
    public ContextMenu(string itemName);
    public ContextMenu(string itemName, bool isValidateFunction);
    public ContextMenu(string itemName, bool isValidateFunction, int priority);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.ContextMenuItemAttribute : PropertyAttribute {
    public string name;
    public string function;
    public ContextMenuItemAttribute(string name, string function);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Mono/Coroutine.h")]
public class UnityEngine.Coroutine : YieldInstruction {
    internal IntPtr m_Ptr;
    protected virtual override void Finalize();
    [FreeFunctionAttribute("Coroutine::CleanupCoroutineGC", "True")]
private static void ReleaseCoroutine(IntPtr ptr);
}
[NativeHeaderAttribute("Runtime/Export/CrashReport/CrashReport.bindings.h")]
public class UnityEngine.CrashReport : object {
    private static List`1<CrashReport> internalReports;
    private static object reportsLock;
    private string id;
    public DateTime time;
    public string text;
    public static CrashReport[] reports { get; }
    public static CrashReport lastReport { get; }
    private CrashReport(string id, DateTime time, string text);
    private static CrashReport();
    private static int Compare(CrashReport c1, CrashReport c2);
    private static void PopulateReports();
    public static CrashReport[] get_reports();
    public static CrashReport get_lastReport();
    public static void RemoveAll();
    public void Remove();
    [FreeFunctionAttribute]
private static String[] GetReports();
    [FreeFunctionAttribute]
private static string GetReportData(string id, Double& secondsSinceUnixEpoch);
    [FreeFunctionAttribute]
private static bool RemoveReport(string id);
}
[AttributeUsageAttribute("4")]
public class UnityEngine.CreateAssetMenuAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <menuName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <fileName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <order>k__BackingField;
    public string menuName { get; public set; }
    public string fileName { get; public set; }
    public int order { get; public set; }
    [CompilerGeneratedAttribute]
public string get_menuName();
    [CompilerGeneratedAttribute]
public void set_menuName(string value);
    [CompilerGeneratedAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
public void set_fileName(string value);
    [CompilerGeneratedAttribute]
public int get_order();
    [CompilerGeneratedAttribute]
public void set_order(int value);
}
[NativeHeaderAttribute("Runtime/Graphics/CubemapTexture.h")]
[ExcludeFromPresetAttribute]
public class UnityEngine.Cubemap : Texture {
    public TextureFormat format { get; }
    public bool isReadable { get; }
    internal bool isPreProcessed { get; }
    public bool streamingMipmaps { get; }
    public int streamingMipmapsPriority { get; }
    public int requestedMipmapLevel { get; public set; }
    internal bool loadAllMips { get; internal set; }
    public int desiredMipmapLevel { get; }
    public int loadingMipmapLevel { get; }
    public int loadedMipmapLevel { get; }
    [ExcludeFromDocsAttribute]
public Cubemap(int width, DefaultFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Cubemap(int width, DefaultFormat format, TextureCreationFlags flags, int mipCount);
    [ExcludeFromDocsAttribute]
[RequiredByNativeCodeAttribute]
public Cubemap(int width, GraphicsFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Cubemap(int width, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
    internal Cubemap(int width, TextureFormat textureFormat, int mipCount, IntPtr nativeTex, bool createUninitialized);
    public Cubemap(int width, TextureFormat textureFormat, bool mipChain);
    public Cubemap(int width, TextureFormat textureFormat, bool mipChain, bool createUninitialized);
    public Cubemap(int width, TextureFormat format, int mipCount);
    public Cubemap(int width, TextureFormat format, int mipCount, bool createUninitialized);
    [NativeNameAttribute("GetTextureFormat")]
public TextureFormat get_format();
    [FreeFunctionAttribute("CubemapScripting::Create")]
private static bool Internal_CreateImpl(Cubemap mono, int ext, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex);
    private static void Internal_Create(Cubemap mono, int ext, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex);
    [FreeFunctionAttribute]
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable);
    [FreeFunctionAttribute("CubemapScripting::UpdateExternalTexture")]
public void UpdateExternalTexture(IntPtr nativeTexture);
    public virtual bool get_isReadable();
    [NativeNameAttribute("SetPixel")]
private void SetPixelImpl(int image, int mip, int x, int y, Color color);
    [NativeNameAttribute("GetPixel")]
private Color GetPixelImpl(int image, int mip, int x, int y);
    [NativeNameAttribute("FixupEdges")]
public void SmoothEdges(int smoothRegionWidthInPixels);
    public void SmoothEdges();
    [FreeFunctionAttribute]
public Color[] GetPixels(CubemapFace face, int miplevel);
    public Color[] GetPixels(CubemapFace face);
    [FreeFunctionAttribute]
public void SetPixels(Color[] colors, CubemapFace face, int miplevel);
    [FreeFunctionAttribute]
private bool SetPixelDataImplArray(Array data, int mipLevel, int face, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int face, int elementSize, int dataArraySize, int sourceDataStartIndex);
    public void SetPixels(Color[] colors, CubemapFace face);
    private IntPtr GetWritableImageData(int frame);
    internal bool get_isPreProcessed();
    public bool get_streamingMipmaps();
    public int get_streamingMipmapsPriority();
    [FreeFunctionAttribute]
public int get_requestedMipmapLevel();
    [FreeFunctionAttribute]
public void set_requestedMipmapLevel(int value);
    [FreeFunctionAttribute]
internal bool get_loadAllMips();
    [FreeFunctionAttribute]
internal void set_loadAllMips(bool value);
    [FreeFunctionAttribute]
public int get_desiredMipmapLevel();
    [FreeFunctionAttribute]
public int get_loadingMipmapLevel();
    [FreeFunctionAttribute]
public int get_loadedMipmapLevel();
    [FreeFunctionAttribute]
public void ClearRequestedMipmapLevel();
    [FreeFunctionAttribute]
public bool IsRequestedMipmapLevelLoaded();
    internal bool ValidateFormat(TextureFormat format, int width);
    internal bool ValidateFormat(GraphicsFormat format, int width);
    public static Cubemap CreateExternalTexture(int width, TextureFormat format, bool mipmap, IntPtr nativeTex);
    public void SetPixelData(T[] data, int mipLevel, CubemapFace face, int sourceDataStartIndex);
    public void SetPixelData(NativeArray`1<T> data, int mipLevel, CubemapFace face, int sourceDataStartIndex);
    public NativeArray`1<T> GetPixelData(int mipLevel, CubemapFace face);
    [ExcludeFromDocsAttribute]
public void SetPixel(CubemapFace face, int x, int y, Color color);
    public void SetPixel(CubemapFace face, int x, int y, Color color, int mip);
    [ExcludeFromDocsAttribute]
public Color GetPixel(CubemapFace face, int x, int y);
    public Color GetPixel(CubemapFace face, int x, int y, int mip);
    public void Apply(bool updateMipmaps, bool makeNoLongerReadable);
    [ExcludeFromDocsAttribute]
public void Apply(bool updateMipmaps);
    [ExcludeFromDocsAttribute]
public void Apply();
    private static void ValidateIsNotCrunched(TextureCreationFlags flags);
    private void SetPixelImpl_Injected(int image, int mip, int x, int y, Color& color);
    private void GetPixelImpl_Injected(int image, int mip, int x, int y, Color& ret);
}
[NativeHeaderAttribute("Runtime/Graphics/CubemapArrayTexture.h")]
[ExcludeFromPresetAttribute]
public class UnityEngine.CubemapArray : Texture {
    public int cubemapCount { get; }
    public TextureFormat format { get; }
    public bool isReadable { get; }
    [ExcludeFromDocsAttribute]
public CubemapArray(int width, int cubemapCount, DefaultFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public CubemapArray(int width, int cubemapCount, DefaultFormat format, TextureCreationFlags flags, int mipCount);
    [RequiredByNativeCodeAttribute]
public CubemapArray(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public CubemapArray(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
    public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, int mipCount, bool linear, bool createUninitialized);
    public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, int mipCount, bool linear);
    public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain, bool linear, bool createUninitialized);
    [ExcludeFromDocsAttribute]
public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain, bool linear);
    public CubemapArray(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain);
    public int get_cubemapCount();
    [NativeNameAttribute("GetTextureFormat")]
public TextureFormat get_format();
    public virtual bool get_isReadable();
    [FreeFunctionAttribute("CubemapArrayScripting::Create")]
private static bool Internal_CreateImpl(CubemapArray mono, int ext, int count, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags);
    private static void Internal_Create(CubemapArray mono, int ext, int count, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags);
    [FreeFunctionAttribute]
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable);
    [FreeFunctionAttribute]
public Color[] GetPixels(CubemapFace face, int arrayElement, int miplevel);
    public Color[] GetPixels(CubemapFace face, int arrayElement);
    [FreeFunctionAttribute]
public Color32[] GetPixels32(CubemapFace face, int arrayElement, int miplevel);
    public Color32[] GetPixels32(CubemapFace face, int arrayElement);
    [FreeFunctionAttribute]
public void SetPixels(Color[] colors, CubemapFace face, int arrayElement, int miplevel);
    public void SetPixels(Color[] colors, CubemapFace face, int arrayElement);
    [FreeFunctionAttribute]
public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement, int miplevel);
    public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement);
    [FreeFunctionAttribute]
private bool SetPixelDataImplArray(Array data, int mipLevel, int face, int element, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int face, int element, int elementSize, int dataArraySize, int sourceDataStartIndex);
    private IntPtr GetImageDataPointer();
    public void Apply(bool updateMipmaps, bool makeNoLongerReadable);
    [ExcludeFromDocsAttribute]
public void Apply(bool updateMipmaps);
    [ExcludeFromDocsAttribute]
public void Apply();
    public void SetPixelData(T[] data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex);
    public void SetPixelData(NativeArray`1<T> data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex);
    public NativeArray`1<T> GetPixelData(int mipLevel, CubemapFace face, int element);
    private static void ValidateIsNotCrunched(TextureCreationFlags flags);
}
public enum UnityEngine.CubemapFace : Enum {
    public int value__;
    public static CubemapFace Unknown;
    public static CubemapFace PositiveX;
    public static CubemapFace NegativeX;
    public static CubemapFace PositiveY;
    public static CubemapFace NegativeY;
    public static CubemapFace PositiveZ;
    public static CubemapFace NegativeZ;
}
[NativeHeaderAttribute("Runtime/Export/Camera/CullingGroup.bindings.h")]
public class UnityEngine.CullingGroup : object {
    internal IntPtr m_Ptr;
    private StateChanged m_OnStateChanged;
    public StateChanged onStateChanged { get; public set; }
    public bool enabled { get; public set; }
    public Camera targetCamera { get; public set; }
    protected virtual override void Finalize();
    [FreeFunctionAttribute("CullingGroup_Bindings::Dispose")]
private void DisposeInternal();
    public sealed virtual void Dispose();
    public StateChanged get_onStateChanged();
    public void set_onStateChanged(StateChanged value);
    public bool get_enabled();
    public void set_enabled(bool value);
    public Camera get_targetCamera();
    public void set_targetCamera(Camera value);
    public void SetBoundingSpheres(BoundingSphere[] array);
    public void SetBoundingSphereCount(int count);
    public void EraseSwapBack(int index);
    public static void EraseSwapBack(int index, T[] myArray, Int32& size);
    public int QueryIndices(bool visible, Int32[] result, int firstIndex);
    public int QueryIndices(int distanceIndex, Int32[] result, int firstIndex);
    public int QueryIndices(bool visible, int distanceIndex, Int32[] result, int firstIndex);
    [NativeThrowsAttribute]
[FreeFunctionAttribute("CullingGroup_Bindings::QueryIndices")]
private int QueryIndices(bool visible, int distanceIndex, CullingQueryOptions options, Int32[] result, int firstIndex);
    [FreeFunctionAttribute("CullingGroup_Bindings::IsVisible")]
[NativeThrowsAttribute]
public bool IsVisible(int index);
    [NativeThrowsAttribute]
[FreeFunctionAttribute("CullingGroup_Bindings::GetDistance")]
public int GetDistance(int index);
    [FreeFunctionAttribute("CullingGroup_Bindings::SetBoundingDistances")]
public void SetBoundingDistances(Single[] distances);
    [FreeFunctionAttribute("CullingGroup_Bindings::SetDistanceReferencePoint")]
private void SetDistanceReferencePoint_InternalVector3(Vector3 point);
    [NativeMethodAttribute("SetDistanceReferenceTransform")]
private void SetDistanceReferencePoint_InternalTransform(Transform transform);
    public void SetDistanceReferencePoint(Vector3 point);
    public void SetDistanceReferencePoint(Transform transform);
    [SecuritySafeCriticalAttribute]
[RequiredByNativeCodeAttribute]
private static void SendEvents(CullingGroup cullingGroup, IntPtr eventsPtr, int count);
    [FreeFunctionAttribute("CullingGroup_Bindings::Init")]
private static IntPtr Init(object scripting);
    [FreeFunctionAttribute("CullingGroup_Bindings::FinalizerFailure")]
private void FinalizerFailure();
    private void SetDistanceReferencePoint_InternalVector3_Injected(Vector3& point);
}
public class UnityEngine.CullingGroupEvent : ValueType {
    private int m_Index;
    private byte m_PrevState;
    private byte m_ThisState;
    private static byte kIsVisibleMask;
    private static byte kDistanceMask;
    public int index { get; }
    public bool isVisible { get; }
    public bool wasVisible { get; }
    public bool hasBecomeVisible { get; }
    public bool hasBecomeInvisible { get; }
    public int currentDistance { get; }
    public int previousDistance { get; }
    public int get_index();
    public bool get_isVisible();
    public bool get_wasVisible();
    public bool get_hasBecomeVisible();
    public bool get_hasBecomeInvisible();
    public int get_currentDistance();
    public int get_previousDistance();
}
internal enum UnityEngine.CullingQueryOptions : Enum {
    public int value__;
    public static CullingQueryOptions Normal;
    public static CullingQueryOptions IgnoreVisibility;
    public static CullingQueryOptions IgnoreDistance;
}
[NativeHeaderAttribute("Runtime/Export/Input/Cursor.bindings.h")]
public class UnityEngine.Cursor : object {
    public static bool visible { get; public set; }
    public static CursorLockMode lockState { get; public set; }
    private static void SetCursor(Texture2D texture, CursorMode cursorMode);
    public static void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode);
    public static bool get_visible();
    public static void set_visible(bool value);
    public static CursorLockMode get_lockState();
    public static void set_lockState(CursorLockMode value);
    private static void SetCursor_Injected(Texture2D texture, Vector2& hotspot, CursorMode cursorMode);
}
public enum UnityEngine.CursorLockMode : Enum {
    public int value__;
    public static CursorLockMode None;
    public static CursorLockMode Locked;
    public static CursorLockMode Confined;
}
public enum UnityEngine.CursorMode : Enum {
    public int value__;
    public static CursorMode Auto;
    public static CursorMode ForceSoftware;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/CustomRenderTexture.h")]
public class UnityEngine.CustomRenderTexture : RenderTexture {
    public Material material { get; public set; }
    public Material initializationMaterial { get; public set; }
    public Texture initializationTexture { get; public set; }
    public CustomRenderTextureInitializationSource initializationSource { get; public set; }
    public Color initializationColor { get; public set; }
    public CustomRenderTextureUpdateMode updateMode { get; public set; }
    public CustomRenderTextureUpdateMode initializationMode { get; public set; }
    public CustomRenderTextureUpdateZoneSpace updateZoneSpace { get; public set; }
    public int shaderPass { get; public set; }
    public UInt32 cubemapFaceMask { get; public set; }
    public bool doubleBuffered { get; public set; }
    public bool wrapUpdateZones { get; public set; }
    public float updatePeriod { get; public set; }
    public CustomRenderTexture(int width, int height, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    [ExcludeFromDocsAttribute]
public CustomRenderTexture(int width, int height, RenderTextureFormat format);
    [ExcludeFromDocsAttribute]
public CustomRenderTexture(int width, int height);
    [ExcludeFromDocsAttribute]
public CustomRenderTexture(int width, int height, DefaultFormat defaultFormat);
    [ExcludeFromDocsAttribute]
public CustomRenderTexture(int width, int height, GraphicsFormat format);
    [FreeFunctionAttribute]
private static void Internal_CreateCustomRenderTexture(CustomRenderTexture rt);
    [NativeNameAttribute("TriggerUpdate")]
private void TriggerUpdate(int count);
    public void Update(int count);
    public void Update();
    [NativeNameAttribute("TriggerInitialization")]
private void TriggerInitialization();
    public void Initialize();
    public void ClearUpdateZones();
    public Material get_material();
    public void set_material(Material value);
    public Material get_initializationMaterial();
    public void set_initializationMaterial(Material value);
    public Texture get_initializationTexture();
    public void set_initializationTexture(Texture value);
    [FreeFunctionAttribute]
internal void GetUpdateZonesInternal(object updateZones);
    public void GetUpdateZones(List`1<CustomRenderTextureUpdateZone> updateZones);
    [FreeFunctionAttribute]
private void SetUpdateZonesInternal(CustomRenderTextureUpdateZone[] updateZones);
    [FreeFunctionAttribute]
public RenderTexture GetDoubleBufferRenderTexture();
    public void EnsureDoubleBufferConsistency();
    public void SetUpdateZones(CustomRenderTextureUpdateZone[] updateZones);
    public CustomRenderTextureInitializationSource get_initializationSource();
    public void set_initializationSource(CustomRenderTextureInitializationSource value);
    public Color get_initializationColor();
    public void set_initializationColor(Color value);
    public CustomRenderTextureUpdateMode get_updateMode();
    public void set_updateMode(CustomRenderTextureUpdateMode value);
    public CustomRenderTextureUpdateMode get_initializationMode();
    public void set_initializationMode(CustomRenderTextureUpdateMode value);
    public CustomRenderTextureUpdateZoneSpace get_updateZoneSpace();
    public void set_updateZoneSpace(CustomRenderTextureUpdateZoneSpace value);
    public int get_shaderPass();
    public void set_shaderPass(int value);
    public UInt32 get_cubemapFaceMask();
    public void set_cubemapFaceMask(UInt32 value);
    public bool get_doubleBuffered();
    public void set_doubleBuffered(bool value);
    public bool get_wrapUpdateZones();
    public void set_wrapUpdateZones(bool value);
    public float get_updatePeriod();
    public void set_updatePeriod(float value);
    private void get_initializationColor_Injected(Color& ret);
    private void set_initializationColor_Injected(Color& value);
}
public enum UnityEngine.CustomRenderTextureInitializationSource : Enum {
    public int value__;
    public static CustomRenderTextureInitializationSource TextureAndColor;
    public static CustomRenderTextureInitializationSource Material;
}
[NativeHeaderAttribute("Runtime/Graphics/CustomRenderTextureManager.h")]
public static class UnityEngine.CustomRenderTextureManager : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`1<CustomRenderTexture> textureLoaded;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<CustomRenderTexture> textureUnloaded;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<CustomRenderTexture, int> updateTriggered;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<CustomRenderTexture> initializeTriggered;
    [CompilerGeneratedAttribute]
public static void add_textureLoaded(Action`1<CustomRenderTexture> value);
    [CompilerGeneratedAttribute]
public static void remove_textureLoaded(Action`1<CustomRenderTexture> value);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnTextureLoaded_Internal(CustomRenderTexture source);
    [CompilerGeneratedAttribute]
public static void add_textureUnloaded(Action`1<CustomRenderTexture> value);
    [CompilerGeneratedAttribute]
public static void remove_textureUnloaded(Action`1<CustomRenderTexture> value);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnTextureUnloaded_Internal(CustomRenderTexture source);
    [FreeFunctionAttribute]
public static void GetAllCustomRenderTextures(List`1<CustomRenderTexture> currentCustomRenderTextures);
    [CompilerGeneratedAttribute]
public static void add_updateTriggered(Action`2<CustomRenderTexture, int> value);
    [CompilerGeneratedAttribute]
public static void remove_updateTriggered(Action`2<CustomRenderTexture, int> value);
    internal static void InvokeTriggerUpdate(CustomRenderTexture crt, int updateCount);
    [CompilerGeneratedAttribute]
public static void add_initializeTriggered(Action`1<CustomRenderTexture> value);
    [CompilerGeneratedAttribute]
public static void remove_initializeTriggered(Action`1<CustomRenderTexture> value);
    internal static void InvokeTriggerInitialize(CustomRenderTexture crt);
}
public enum UnityEngine.CustomRenderTextureUpdateMode : Enum {
    public int value__;
    public static CustomRenderTextureUpdateMode OnLoad;
    public static CustomRenderTextureUpdateMode Realtime;
    public static CustomRenderTextureUpdateMode OnDemand;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.CustomRenderTextureUpdateZone : ValueType {
    public Vector3 updateZoneCenter;
    public Vector3 updateZoneSize;
    public float rotation;
    public int passIndex;
    public bool needSwap;
}
public enum UnityEngine.CustomRenderTextureUpdateZoneSpace : Enum {
    public int value__;
    public static CustomRenderTextureUpdateZoneSpace Normalized;
    public static CustomRenderTextureUpdateZoneSpace Pixel;
}
public abstract class UnityEngine.CustomYieldInstruction : object {
    public bool keepWaiting { get; }
    public object Current { get; }
    public abstract virtual bool get_keepWaiting();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public virtual void Reset();
}
[ObsoleteAttribute("D3DHDRDisplayBitDepth has been replaced by HDRDisplayBitDepth. (UnityUpgradable) -> HDRDisplayBitDepth", "True")]
public enum UnityEngine.D3DHDRDisplayBitDepth : Enum {
    public int value__;
    [ObsoleteAttribute("D3DHDRDisplayBitDepth::D3DHDRDisplayBitDepth10 has been replaced by HDRDisplayBitDepth::BitDepth10 (UnityUpgradable) -> HDRDisplayBitDepth.BitDepth10", "True")]
public static D3DHDRDisplayBitDepth D3DHDRDisplayBitDepth10;
    [ObsoleteAttribute("D3DHDRDisplayBitDepth::D3DHDRDisplayBitDepth16 has been replaced by HDRDisplayBitDepth::BitDepth16 (UnityUpgradable) -> HDRDisplayBitDepth.BitDepth16", "True")]
public static D3DHDRDisplayBitDepth D3DHDRDisplayBitDepth16;
}
[NativeHeaderAttribute("Runtime/Export/Debug/Debug.bindings.h")]
public class UnityEngine.Debug : object {
    internal static ILogger s_DefaultLogger;
    internal static ILogger s_Logger;
    public static ILogger unityLogger { get; }
    public static bool developerConsoleEnabled { get; public set; }
    public static bool developerConsoleVisible { get; public set; }
    public static bool isDebugBuild { get; }
    [NativeThrowsAttribute]
internal static DiagnosticSwitch[] diagnosticSwitches { get; }
    [ObsoleteAttribute("Debug.logger is obsolete. Please use Debug.unityLogger instead (UnityUpgradable) -> unityLogger")]
[EditorBrowsableAttribute("1")]
public static ILogger logger { get; }
    private static Debug();
    public static ILogger get_unityLogger();
    [ExcludeFromDocsAttribute]
public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration);
    [ExcludeFromDocsAttribute]
public static void DrawLine(Vector3 start, Vector3 end, Color color);
    [ExcludeFromDocsAttribute]
public static void DrawLine(Vector3 start, Vector3 end);
    [FreeFunctionAttribute("DebugDrawLine")]
public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration, bool depthTest);
    [ExcludeFromDocsAttribute]
public static void DrawRay(Vector3 start, Vector3 dir, Color color, float duration);
    [ExcludeFromDocsAttribute]
public static void DrawRay(Vector3 start, Vector3 dir, Color color);
    [ExcludeFromDocsAttribute]
public static void DrawRay(Vector3 start, Vector3 dir);
    public static void DrawRay(Vector3 start, Vector3 dir, Color color, float duration, bool depthTest);
    [FreeFunctionAttribute("PauseEditor")]
public static void Break();
    public static void DebugBreak();
    [ThreadSafeAttribute]
public static int ExtractStackTraceNoAlloc(Byte* buffer, int bufferMax, string projectFolder);
    public static void Log(object message);
    public static void Log(object message, Object context);
    public static void LogFormat(string format, Object[] args);
    public static void LogFormat(Object context, string format, Object[] args);
    public static void LogFormat(LogType logType, LogOption logOptions, Object context, string format, Object[] args);
    public static void LogError(object message);
    public static void LogError(object message, Object context);
    public static void LogErrorFormat(string format, Object[] args);
    public static void LogErrorFormat(Object context, string format, Object[] args);
    public static void ClearDeveloperConsole();
    public static bool get_developerConsoleEnabled();
    public static void set_developerConsoleEnabled(bool value);
    public static bool get_developerConsoleVisible();
    public static void set_developerConsoleVisible(bool value);
    public static void LogException(Exception exception);
    public static void LogException(Exception exception, Object context);
    public static void LogWarning(object message);
    public static void LogWarning(object message, Object context);
    public static void LogWarningFormat(string format, Object[] args);
    public static void LogWarningFormat(Object context, string format, Object[] args);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition, Object context);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition, object message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition, object message, Object context);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void Assert(bool condition, string message, Object context);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AssertFormat(bool condition, string format, Object[] args);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void AssertFormat(bool condition, Object context, string format, Object[] args);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void LogAssertion(object message);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void LogAssertion(object message, Object context);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void LogAssertionFormat(string format, Object[] args);
    [ConditionalAttribute("UNITY_ASSERTIONS")]
public static void LogAssertionFormat(Object context, string format, Object[] args);
    public static bool get_isDebugBuild();
    [FreeFunctionAttribute("DeveloperConsole_OpenConsoleFile")]
internal static void OpenConsoleFile();
    internal static DiagnosticSwitch[] get_diagnosticSwitches();
    internal static DiagnosticSwitch GetDiagnosticSwitch(string name);
    [RequiredByNativeCodeAttribute]
internal static bool CallOverridenDebugHandler(Exception exception, Object obj);
    [RequiredByNativeCodeAttribute]
internal static bool IsLoggingEnabled();
    [EditorBrowsableAttribute("1")]
[ConditionalAttribute("UNITY_ASSERTIONS")]
[ObsoleteAttribute("Assert(bool, string, params object[]) is obsolete. Use AssertFormat(bool, string, params object[]) (UnityUpgradable) -> AssertFormat(*)", "True")]
public static void Assert(bool condition, string format, Object[] args);
    public static ILogger get_logger();
    private static void DrawLine_Injected(Vector3& start, Vector3& end, Color& color, float duration, bool depthTest);
}
[NativeHeaderAttribute("Runtime/Export/Debug/Debug.bindings.h")]
internal class UnityEngine.DebugLogHandler : object {
    [ThreadAndSerializationSafeAttribute]
internal static void Internal_Log(LogType level, LogOption options, string msg, Object obj);
    [ThreadAndSerializationSafeAttribute]
internal static void Internal_LogException(Exception ex, Object obj);
    public sealed virtual void LogFormat(LogType logType, Object context, string format, Object[] args);
    public void LogFormat(LogType logType, LogOption logOptions, Object context, string format, Object[] args);
    public sealed virtual void LogException(Exception exception, Object context);
}
[UsedByNativeCodeAttribute]
[AttributeUsageAttribute("4")]
public class UnityEngine.DefaultExecutionOrder : Attribute {
    private int m_Order;
    public int order { get; }
    public DefaultExecutionOrder(int order);
    public int get_order();
}
[AttributeUsageAttribute("256")]
public class UnityEngine.DelayedAttribute : PropertyAttribute {
}
[FlagsAttribute]
public enum UnityEngine.DepthTextureMode : Enum {
    public int value__;
    public static DepthTextureMode None;
    public static DepthTextureMode Depth;
    public static DepthTextureMode DepthNormals;
    public static DepthTextureMode MotionVectors;
}
public static class UnityEngine.Device.Application : object {
    public static string absoluteURL { get; }
    public static ThreadPriority backgroundLoadingPriority { get; public set; }
    public static string buildGUID { get; }
    public static string cloudProjectId { get; }
    public static string companyName { get; }
    public static string consoleLogPath { get; }
    public static string dataPath { get; }
    public static bool genuine { get; }
    public static bool genuineCheckAvailable { get; }
    public static string identifier { get; }
    public static string installerName { get; }
    public static ApplicationInstallMode installMode { get; }
    public static NetworkReachability internetReachability { get; }
    public static bool isBatchMode { get; }
    public static bool isConsolePlatform { get; }
    public static bool isEditor { get; }
    public static bool isFocused { get; }
    public static bool isMobilePlatform { get; }
    public static bool isPlaying { get; }
    public static string persistentDataPath { get; }
    public static RuntimePlatform platform { get; }
    public static string productName { get; }
    public static bool runInBackground { get; public set; }
    public static ApplicationSandboxType sandboxType { get; }
    public static string streamingAssetsPath { get; }
    public static SystemLanguage systemLanguage { get; }
    public static int targetFrameRate { get; public set; }
    public static string temporaryCachePath { get; }
    public static string unityVersion { get; }
    public static string version { get; }
    public static CancellationToken exitCancellationToken { get; }
    public static string get_absoluteURL();
    public static ThreadPriority get_backgroundLoadingPriority();
    public static void set_backgroundLoadingPriority(ThreadPriority value);
    public static string get_buildGUID();
    public static string get_cloudProjectId();
    public static string get_companyName();
    public static string get_consoleLogPath();
    public static string get_dataPath();
    public static bool get_genuine();
    public static bool get_genuineCheckAvailable();
    public static string get_identifier();
    public static string get_installerName();
    public static ApplicationInstallMode get_installMode();
    public static NetworkReachability get_internetReachability();
    public static bool get_isBatchMode();
    public static bool get_isConsolePlatform();
    public static bool get_isEditor();
    public static bool get_isFocused();
    public static bool get_isMobilePlatform();
    public static bool get_isPlaying();
    public static string get_persistentDataPath();
    public static RuntimePlatform get_platform();
    public static string get_productName();
    public static bool get_runInBackground();
    public static void set_runInBackground(bool value);
    public static ApplicationSandboxType get_sandboxType();
    public static string get_streamingAssetsPath();
    public static SystemLanguage get_systemLanguage();
    public static int get_targetFrameRate();
    public static void set_targetFrameRate(int value);
    public static string get_temporaryCachePath();
    public static string get_unityVersion();
    public static string get_version();
    public static void add_deepLinkActivated(Action`1<string> value);
    public static void remove_deepLinkActivated(Action`1<string> value);
    public static void add_focusChanged(Action`1<bool> value);
    public static void remove_focusChanged(Action`1<bool> value);
    public static void add_logMessageReceived(LogCallback value);
    public static void remove_logMessageReceived(LogCallback value);
    public static void add_logMessageReceivedThreaded(LogCallback value);
    public static void remove_logMessageReceivedThreaded(LogCallback value);
    public static void add_lowMemory(LowMemoryCallback value);
    public static void remove_lowMemory(LowMemoryCallback value);
    public static void add_memoryUsageChanged(MemoryUsageChangedCallback value);
    public static void remove_memoryUsageChanged(MemoryUsageChangedCallback value);
    public static void add_onBeforeRender(UnityAction value);
    public static void remove_onBeforeRender(UnityAction value);
    public static void add_quitting(Action value);
    public static void remove_quitting(Action value);
    public static void add_wantsToQuit(Func`1<bool> value);
    public static void remove_wantsToQuit(Func`1<bool> value);
    public static void add_unloading(Action value);
    public static void remove_unloading(Action value);
    public static bool CanStreamedLevelBeLoaded(int levelIndex);
    public static bool CanStreamedLevelBeLoaded(string levelName);
    [ObsoleteAttribute("Application.GetBuildTags is no longer supported and will be removed.", "False")]
public static String[] GetBuildTags();
    [ObsoleteAttribute("Application.SetBuildTags is no longer supported and will be removed.", "False")]
public static void SetBuildTags(String[] buildTags);
    public static StackTraceLogType GetStackTraceLogType(LogType logType);
    public static bool HasProLicense();
    public static bool HasUserAuthorization(UserAuthorization mode);
    public static bool IsPlaying(Object obj);
    public static void OpenURL(string url);
    public static void Quit();
    public static void Quit(int exitCode);
    public static bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod);
    public static AsyncOperation RequestUserAuthorization(UserAuthorization mode);
    public static void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType);
    public static void Unload();
    public static CancellationToken get_exitCancellationToken();
}
public static class UnityEngine.Device.Screen : object {
    public static float brightness { get; public set; }
    public static bool autorotateToLandscapeLeft { get; public set; }
    public static bool autorotateToLandscapeRight { get; public set; }
    public static bool autorotateToPortrait { get; public set; }
    public static bool autorotateToPortraitUpsideDown { get; public set; }
    public static Resolution currentResolution { get; }
    public static Rect[] cutouts { get; }
    public static float dpi { get; }
    public static bool fullScreen { get; public set; }
    public static FullScreenMode fullScreenMode { get; public set; }
    public static int height { get; }
    public static int width { get; }
    public static ScreenOrientation orientation { get; public set; }
    public static Resolution[] resolutions { get; }
    public static Rect safeArea { get; }
    public static int sleepTimeout { get; public set; }
    public static Vector2Int mainWindowPosition { get; }
    public static DisplayInfo mainWindowDisplayInfo { get; }
    public static float get_brightness();
    public static void set_brightness(float value);
    public static bool get_autorotateToLandscapeLeft();
    public static void set_autorotateToLandscapeLeft(bool value);
    public static bool get_autorotateToLandscapeRight();
    public static void set_autorotateToLandscapeRight(bool value);
    public static bool get_autorotateToPortrait();
    public static void set_autorotateToPortrait(bool value);
    public static bool get_autorotateToPortraitUpsideDown();
    public static void set_autorotateToPortraitUpsideDown(bool value);
    public static Resolution get_currentResolution();
    public static Rect[] get_cutouts();
    public static float get_dpi();
    public static bool get_fullScreen();
    public static void set_fullScreen(bool value);
    public static FullScreenMode get_fullScreenMode();
    public static void set_fullScreenMode(FullScreenMode value);
    public static int get_height();
    public static int get_width();
    public static ScreenOrientation get_orientation();
    public static void set_orientation(ScreenOrientation value);
    public static Resolution[] get_resolutions();
    public static Rect get_safeArea();
    public static int get_sleepTimeout();
    public static void set_sleepTimeout(int value);
    public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, RefreshRate preferredRefreshRate);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("SetResolution(int, int, FullScreenMode, int) is obsolete. Use SetResolution(int, int, FullScreenMode, RefreshRate) instead.")]
public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate);
    public static void SetResolution(int width, int height, FullScreenMode fullscreenMode);
    [ObsoleteAttribute("SetResolution(int, int, bool, int) is obsolete. Use SetResolution(int, int, FullScreenMode, RefreshRate) instead.")]
[EditorBrowsableAttribute("1")]
public static void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate);
    public static void SetResolution(int width, int height, bool fullscreen);
    public static Vector2Int get_mainWindowPosition();
    public static DisplayInfo get_mainWindowDisplayInfo();
    public static void GetDisplayLayout(List`1<DisplayInfo> displayLayout);
    public static AsyncOperation MoveMainWindowTo(DisplayInfo& display, Vector2Int position);
}
public static class UnityEngine.Device.SystemInfo : object {
    public static string unsupportedIdentifier;
    public static float batteryLevel { get; }
    public static BatteryStatus batteryStatus { get; }
    public static string operatingSystem { get; }
    public static OperatingSystemFamily operatingSystemFamily { get; }
    public static string processorType { get; }
    public static int processorFrequency { get; }
    public static int processorCount { get; }
    public static int systemMemorySize { get; }
    public static string deviceUniqueIdentifier { get; }
    public static string deviceName { get; }
    public static string deviceModel { get; }
    public static bool supportsAccelerometer { get; }
    public static bool supportsGyroscope { get; }
    public static bool supportsLocationService { get; }
    public static bool supportsVibration { get; }
    public static bool supportsAudio { get; }
    public static DeviceType deviceType { get; }
    public static int graphicsMemorySize { get; }
    public static string graphicsDeviceName { get; }
    public static string graphicsDeviceVendor { get; }
    public static int graphicsDeviceID { get; }
    public static int graphicsDeviceVendorID { get; }
    public static GraphicsDeviceType graphicsDeviceType { get; }
    public static bool graphicsUVStartsAtTop { get; }
    public static string graphicsDeviceVersion { get; }
    public static int graphicsShaderLevel { get; }
    public static bool graphicsMultiThreaded { get; }
    public static RenderingThreadingMode renderingThreadingMode { get; }
    public static FoveatedRenderingCaps foveatedRenderingCaps { get; }
    public static bool hasHiddenSurfaceRemovalOnGPU { get; }
    public static bool hasDynamicUniformArrayIndexingInFragmentShaders { get; }
    public static bool supportsShadows { get; }
    public static bool supportsRawShadowDepthSampling { get; }
    public static bool supportsMotionVectors { get; }
    public static bool supports3DTextures { get; }
    public static bool supportsCompressed3DTextures { get; }
    public static bool supports2DArrayTextures { get; }
    public static bool supports3DRenderTextures { get; }
    public static bool supportsCubemapArrayTextures { get; }
    public static CopyTextureSupport copyTextureSupport { get; }
    public static bool supportsComputeShaders { get; }
    public static bool supportsGeometryShaders { get; }
    public static bool supportsTessellationShaders { get; }
    public static bool supportsRenderTargetArrayIndexFromVertexShader { get; }
    public static bool supportsInstancing { get; }
    public static bool supportsHardwareQuadTopology { get; }
    public static bool supports32bitsIndexBuffer { get; }
    public static bool supportsSparseTextures { get; }
    public static int supportedRenderTargetCount { get; }
    public static bool supportsSeparatedRenderTargetsBlend { get; }
    public static int supportedRandomWriteTargetCount { get; }
    public static int supportsMultisampledTextures { get; }
    public static bool supportsMultisampled2DArrayTextures { get; }
    public static bool supportsMultisampleAutoResolve { get; }
    public static int supportsTextureWrapMirrorOnce { get; }
    public static bool usesReversedZBuffer { get; }
    public static NPOTSupport npotSupport { get; }
    public static int maxTextureSize { get; }
    public static int maxTexture3DSize { get; }
    public static int maxTextureArraySlices { get; }
    public static int maxCubemapSize { get; }
    public static int maxComputeBufferInputsVertex { get; }
    public static int maxComputeBufferInputsFragment { get; }
    public static int maxComputeBufferInputsGeometry { get; }
    public static int maxComputeBufferInputsDomain { get; }
    public static int maxComputeBufferInputsHull { get; }
    public static int maxComputeBufferInputsCompute { get; }
    public static int maxComputeWorkGroupSize { get; }
    public static int maxComputeWorkGroupSizeX { get; }
    public static int maxComputeWorkGroupSizeY { get; }
    public static int maxComputeWorkGroupSizeZ { get; }
    public static int computeSubGroupSize { get; }
    public static bool supportsAsyncCompute { get; }
    public static bool supportsGpuRecorder { get; }
    public static bool supportsGraphicsFence { get; }
    public static bool supportsAsyncGPUReadback { get; }
    public static bool supportsRayTracing { get; }
    public static bool supportsSetConstantBuffer { get; }
    public static int constantBufferOffsetAlignment { get; }
    public static int maxConstantBufferSize { get; }
    public static long maxGraphicsBufferSize { get; }
    public static bool hasMipMaxLevel { get; }
    public static bool supportsMipStreaming { get; }
    public static bool usesLoadStoreActions { get; }
    public static HDRDisplaySupportFlags hdrDisplaySupportFlags { get; }
    public static bool supportsConservativeRaster { get; }
    public static bool supportsMultiview { get; }
    public static bool supportsStoreAndResolveAction { get; }
    public static bool supportsMultisampleResolveDepth { get; }
    public static bool supportsMultisampleResolveStencil { get; }
    public static bool supportsIndirectArgumentsBuffer { get; }
    public static float get_batteryLevel();
    public static BatteryStatus get_batteryStatus();
    public static string get_operatingSystem();
    public static OperatingSystemFamily get_operatingSystemFamily();
    public static string get_processorType();
    public static int get_processorFrequency();
    public static int get_processorCount();
    public static int get_systemMemorySize();
    public static string get_deviceUniqueIdentifier();
    public static string get_deviceName();
    public static string get_deviceModel();
    public static bool get_supportsAccelerometer();
    public static bool get_supportsGyroscope();
    public static bool get_supportsLocationService();
    public static bool get_supportsVibration();
    public static bool get_supportsAudio();
    public static DeviceType get_deviceType();
    public static int get_graphicsMemorySize();
    public static string get_graphicsDeviceName();
    public static string get_graphicsDeviceVendor();
    public static int get_graphicsDeviceID();
    public static int get_graphicsDeviceVendorID();
    public static GraphicsDeviceType get_graphicsDeviceType();
    public static bool get_graphicsUVStartsAtTop();
    public static string get_graphicsDeviceVersion();
    public static int get_graphicsShaderLevel();
    public static bool get_graphicsMultiThreaded();
    public static RenderingThreadingMode get_renderingThreadingMode();
    public static FoveatedRenderingCaps get_foveatedRenderingCaps();
    public static bool get_hasHiddenSurfaceRemovalOnGPU();
    public static bool get_hasDynamicUniformArrayIndexingInFragmentShaders();
    public static bool get_supportsShadows();
    public static bool get_supportsRawShadowDepthSampling();
    public static bool get_supportsMotionVectors();
    public static bool get_supports3DTextures();
    public static bool get_supportsCompressed3DTextures();
    public static bool get_supports2DArrayTextures();
    public static bool get_supports3DRenderTextures();
    public static bool get_supportsCubemapArrayTextures();
    public static CopyTextureSupport get_copyTextureSupport();
    public static bool get_supportsComputeShaders();
    public static bool get_supportsGeometryShaders();
    public static bool get_supportsTessellationShaders();
    public static bool get_supportsRenderTargetArrayIndexFromVertexShader();
    public static bool get_supportsInstancing();
    public static bool get_supportsHardwareQuadTopology();
    public static bool get_supports32bitsIndexBuffer();
    public static bool get_supportsSparseTextures();
    public static int get_supportedRenderTargetCount();
    public static bool get_supportsSeparatedRenderTargetsBlend();
    public static int get_supportedRandomWriteTargetCount();
    public static int get_supportsMultisampledTextures();
    public static bool get_supportsMultisampled2DArrayTextures();
    public static bool get_supportsMultisampleAutoResolve();
    public static int get_supportsTextureWrapMirrorOnce();
    public static bool get_usesReversedZBuffer();
    public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
    public static bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format);
    public static bool SupportsTextureFormat(TextureFormat format);
    public static bool SupportsVertexAttributeFormat(VertexAttributeFormat format, int dimension);
    public static NPOTSupport get_npotSupport();
    public static int get_maxTextureSize();
    public static int get_maxTexture3DSize();
    public static int get_maxTextureArraySlices();
    public static int get_maxCubemapSize();
    public static int get_maxComputeBufferInputsVertex();
    public static int get_maxComputeBufferInputsFragment();
    public static int get_maxComputeBufferInputsGeometry();
    public static int get_maxComputeBufferInputsDomain();
    public static int get_maxComputeBufferInputsHull();
    public static int get_maxComputeBufferInputsCompute();
    public static int get_maxComputeWorkGroupSize();
    public static int get_maxComputeWorkGroupSizeX();
    public static int get_maxComputeWorkGroupSizeY();
    public static int get_maxComputeWorkGroupSizeZ();
    public static int get_computeSubGroupSize();
    public static bool get_supportsAsyncCompute();
    public static bool get_supportsGpuRecorder();
    public static bool get_supportsGraphicsFence();
    public static bool get_supportsAsyncGPUReadback();
    public static bool get_supportsRayTracing();
    public static bool get_supportsSetConstantBuffer();
    public static int get_constantBufferOffsetAlignment();
    public static int get_maxConstantBufferSize();
    public static long get_maxGraphicsBufferSize();
    public static bool get_hasMipMaxLevel();
    public static bool get_supportsMipStreaming();
    public static bool get_usesLoadStoreActions();
    public static HDRDisplaySupportFlags get_hdrDisplaySupportFlags();
    public static bool get_supportsConservativeRaster();
    public static bool get_supportsMultiview();
    public static bool get_supportsStoreAndResolveAction();
    public static bool get_supportsMultisampleResolveDepth();
    public static bool get_supportsMultisampleResolveStencil();
    public static bool get_supportsIndirectArgumentsBuffer();
    public static bool IsFormatSupported(GraphicsFormat format, FormatUsage usage);
    public static GraphicsFormat GetCompatibleFormat(GraphicsFormat format, FormatUsage usage);
    public static GraphicsFormat GetGraphicsFormat(DefaultFormat format);
    public static int GetRenderTextureSupportedMSAASampleCount(RenderTextureDescriptor desc);
    public static bool SupportsRandomWriteOnRenderTextureFormat(RenderTextureFormat format);
}
public enum UnityEngine.DeviceType : Enum {
    public int value__;
    public static DeviceType Unknown;
    public static DeviceType Handheld;
    public static DeviceType Console;
    public static DeviceType Desktop;
}
public enum UnityEngine.Diagnostics.ForcedCrashCategory : Enum {
    public int value__;
    public static ForcedCrashCategory AccessViolation;
    public static ForcedCrashCategory FatalError;
    public static ForcedCrashCategory Abort;
    public static ForcedCrashCategory PureVirtualFunction;
    public static ForcedCrashCategory MonoAbort;
}
public static class UnityEngine.Diagnostics.PlayerConnection : object {
    [ObsoleteAttribute("Use UnityEngine.Networking.PlayerConnection.PlayerConnection.instance.isConnected instead.")]
public static bool connected { get; }
    public static bool get_connected();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("PlayerConnection.SendFile is no longer supported.", "True")]
public static void SendFile(string remoteFilePath, Byte[] data);
}
[NativeHeaderAttribute("Runtime/Misc/GarbageCollectSharedAssets.h")]
[NativeHeaderAttribute("Runtime/Export/Diagnostics/DiagnosticsUtils.bindings.h")]
public static class UnityEngine.Diagnostics.Utils : object {
    [FreeFunctionAttribute("DiagnosticsUtils_Bindings::ForceCrash")]
public static void ForceCrash(ForcedCrashCategory crashCategory);
    [FreeFunctionAttribute("DiagnosticsUtils_Bindings::NativeAssert")]
public static void NativeAssert(string message);
    [FreeFunctionAttribute("DiagnosticsUtils_Bindings::NativeError")]
public static void NativeError(string message);
    [FreeFunctionAttribute("DiagnosticsUtils_Bindings::NativeWarning")]
public static void NativeWarning(string message);
    [FreeFunctionAttribute("ValidateHeap")]
public static void ValidateHeap();
}
[NativeAsStructAttribute]
[NativeHeaderAttribute("Runtime/Utilities/DiagnosticSwitch.h")]
[NativeClassAttribute("DiagnosticSwitch", "struct DiagnosticSwitch;")]
internal class UnityEngine.DiagnosticSwitch : object {
    private IntPtr m_Ptr;
    public string name { get; }
    public string description { get; }
    [NativeNameAttribute("OwningModuleName")]
public string owningModule { get; }
    public Flags flags { get; }
    public object value { get; public set; }
    [NativeNameAttribute("ScriptingDefaultValue")]
public object defaultValue { get; }
    [NativeNameAttribute("ScriptingMinValue")]
public object minValue { get; }
    [NativeNameAttribute("ScriptingMaxValue")]
public object maxValue { get; }
    public object persistentValue { get; public set; }
    [NativeNameAttribute("ScriptingEnumInfo")]
public EnumInfo enumInfo { get; }
    public bool isSetToDefault { get; }
    public bool needsRestart { get; }
    public string get_name();
    public string get_description();
    public string get_owningModule();
    public Flags get_flags();
    public object get_value();
    public void set_value(object value);
    public object get_defaultValue();
    public object get_minValue();
    public object get_maxValue();
    public object get_persistentValue();
    public void set_persistentValue(object value);
    public EnumInfo get_enumInfo();
    private object GetScriptingValue();
    private object GetScriptingPersistentValue();
    [NativeThrowsAttribute]
private void SetScriptingValue(object value, bool setPersistent);
    public bool get_isSetToDefault();
    public bool get_needsRestart();
}
internal enum UnityEngine.DisableBatchingType : Enum {
    public int value__;
    public static DisableBatchingType False;
    public static DisableBatchingType True;
    public static DisableBatchingType WhenLODFading;
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("4")]
public class UnityEngine.DisallowMultipleComponent : Attribute {
}
[NativeHeaderAttribute("Runtime/Graphics/DisplayManager.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Display : object {
    internal IntPtr nativeDisplay;
    public static Display[] displays;
    private static Display _mainDisplay;
    private static int m_ActiveEditorGameViewTarget;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static DisplaysUpdatedDelegate onDisplaysUpdated;
    public int renderingWidth { get; }
    public int renderingHeight { get; }
    public int systemWidth { get; }
    public int systemHeight { get; }
    public RenderBuffer colorBuffer { get; }
    public RenderBuffer depthBuffer { get; }
    public bool active { get; }
    public bool requiresBlitToBackbuffer { get; }
    public bool requiresSrgbBlitToBackbuffer { get; }
    public static Display main { get; }
    public static int activeEditorGameViewTarget { get; internal set; }
    internal Display(IntPtr nativeDisplay);
    private static Display();
    public int get_renderingWidth();
    public int get_renderingHeight();
    public int get_systemWidth();
    public int get_systemHeight();
    public RenderBuffer get_colorBuffer();
    public RenderBuffer get_depthBuffer();
    public bool get_active();
    public bool get_requiresBlitToBackbuffer();
    public bool get_requiresSrgbBlitToBackbuffer();
    public void Activate();
    public void Activate(int width, int height, RefreshRate refreshRate);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Activate(int, int, int) is deprecated. Use Activate(int, int, RefreshRate) instead.", "False")]
public void Activate(int width, int height, int refreshRate);
    public void SetParams(int width, int height, int x, int y);
    public void SetRenderingResolution(int w, int h);
    [ObsoleteAttribute("MultiDisplayLicense has been deprecated.", "False")]
public static bool MultiDisplayLicense();
    public static Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates);
    public static Display get_main();
    public static int get_activeEditorGameViewTarget();
    internal static void set_activeEditorGameViewTarget(int value);
    [RequiredByNativeCodeAttribute]
internal static void RecreateDisplayList(IntPtr[] nativeDisplay);
    [RequiredByNativeCodeAttribute]
internal static void FireDisplaysUpdated();
    [CompilerGeneratedAttribute]
public static void add_onDisplaysUpdated(DisplaysUpdatedDelegate value);
    [CompilerGeneratedAttribute]
public static void remove_onDisplaysUpdated(DisplaysUpdatedDelegate value);
    [FreeFunctionAttribute("UnityDisplayManager_DisplaySystemResolution")]
private static void GetSystemExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h);
    [FreeFunctionAttribute("UnityDisplayManager_DisplayRenderingResolution")]
private static void GetRenderingExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h);
    [FreeFunctionAttribute("UnityDisplayManager_GetRenderingBuffersWrapper")]
private static void GetRenderingBuffersImpl(IntPtr nativeDisplay, RenderBuffer& color, RenderBuffer& depth);
    [FreeFunctionAttribute("UnityDisplayManager_SetRenderingResolution")]
private static void SetRenderingResolutionImpl(IntPtr nativeDisplay, int w, int h);
    [FreeFunctionAttribute("UnityDisplayManager_ActivateDisplay")]
private static void ActivateDisplayImpl(IntPtr nativeDisplay, int width, int height, RefreshRate refreshRate);
    [FreeFunctionAttribute("UnityDisplayManager_SetDisplayParam")]
private static void SetParamsImpl(IntPtr nativeDisplay, int width, int height, int x, int y);
    [FreeFunctionAttribute("UnityDisplayManager_RelativeMouseAt")]
private static int RelativeMouseAtImpl(int x, int y, Int32& rx, Int32& ry);
    [FreeFunctionAttribute("UnityDisplayManager_DisplayActive")]
private static bool GetActiveImpl(IntPtr nativeDisplay);
    [FreeFunctionAttribute("UnityDisplayManager_RequiresBlitToBackbuffer")]
private static bool RequiresBlitToBackbufferImpl(IntPtr nativeDisplay);
    [FreeFunctionAttribute("UnityDisplayManager_RequiresSRGBBlitToBackbuffer")]
private static bool RequiresSrgbBlitToBackbufferImpl(IntPtr nativeDisplay);
    private static void ActivateDisplayImpl_Injected(IntPtr nativeDisplay, int width, int height, RefreshRate& refreshRate);
}
[NativeTypeAttribute("Runtime/Graphics/DisplayInfo.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.DisplayInfo : ValueType {
    [RequiredMemberAttribute]
internal ulong handle;
    [RequiredMemberAttribute]
public int width;
    [RequiredMemberAttribute]
public int height;
    [RequiredMemberAttribute]
public RefreshRate refreshRate;
    [RequiredMemberAttribute]
public RectInt workArea;
    [RequiredMemberAttribute]
public string name;
    public sealed virtual bool Equals(DisplayInfo other);
}
[NativeHeaderAttribute("Editor/Src/Properties/DrivenPropertyManager.h")]
internal class UnityEngine.DrivenPropertyManager : object {
    [ConditionalAttribute("UNITY_EDITOR")]
public static void RegisterProperty(Object driver, Object target, string propertyPath);
    [ConditionalAttribute("UNITY_EDITOR")]
public static void TryRegisterProperty(Object driver, Object target, string propertyPath);
    [ConditionalAttribute("UNITY_EDITOR")]
public static void UnregisterProperty(Object driver, Object target, string propertyPath);
    [NativeConditionalAttribute("UNITY_EDITOR")]
[ConditionalAttribute("UNITY_EDITOR")]
[StaticAccessorAttribute("GetDrivenPropertyManager()", "0")]
public static void UnregisterProperties(Object driver);
    [StaticAccessorAttribute("GetDrivenPropertyManager()", "0")]
[NativeConditionalAttribute("UNITY_EDITOR")]
private static void RegisterPropertyPartial(Object driver, Object target, string propertyPath);
    [NativeConditionalAttribute("UNITY_EDITOR")]
[StaticAccessorAttribute("GetDrivenPropertyManager()", "0")]
private static void TryRegisterPropertyPartial(Object driver, Object target, string propertyPath);
    [NativeConditionalAttribute("UNITY_EDITOR")]
[StaticAccessorAttribute("GetDrivenPropertyManager()", "0")]
private static void UnregisterPropertyPartial(Object driver, Object target, string propertyPath);
}
public class UnityEngine.DrivenRectTransformTracker : ValueType {
    internal static bool CanRecordModifications();
    public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties);
    [ObsoleteAttribute("revertValues parameter is ignored. Please use Clear() instead.")]
public void Clear(bool revertValues);
    public void Clear();
}
[FlagsAttribute]
public enum UnityEngine.DrivenTransformProperties : Enum {
    public int value__;
    public static DrivenTransformProperties None;
    public static DrivenTransformProperties All;
    public static DrivenTransformProperties AnchoredPositionX;
    public static DrivenTransformProperties AnchoredPositionY;
    public static DrivenTransformProperties AnchoredPositionZ;
    public static DrivenTransformProperties Rotation;
    public static DrivenTransformProperties ScaleX;
    public static DrivenTransformProperties ScaleY;
    public static DrivenTransformProperties ScaleZ;
    public static DrivenTransformProperties AnchorMinX;
    public static DrivenTransformProperties AnchorMinY;
    public static DrivenTransformProperties AnchorMaxX;
    public static DrivenTransformProperties AnchorMaxY;
    public static DrivenTransformProperties SizeDeltaX;
    public static DrivenTransformProperties SizeDeltaY;
    public static DrivenTransformProperties PivotX;
    public static DrivenTransformProperties PivotY;
    public static DrivenTransformProperties AnchoredPosition;
    public static DrivenTransformProperties AnchoredPosition3D;
    public static DrivenTransformProperties Scale;
    public static DrivenTransformProperties AnchorMin;
    public static DrivenTransformProperties AnchorMax;
    public static DrivenTransformProperties Anchors;
    public static DrivenTransformProperties SizeDelta;
    public static DrivenTransformProperties Pivot;
}
[NativeHeaderAttribute("Runtime/GI/DynamicGI.h")]
public class UnityEngine.DynamicGI : object {
    public static float indirectScale { get; public set; }
    public static float updateThreshold { get; public set; }
    public static int materialUpdateTimeSlice { get; public set; }
    public static bool synchronousMode { get; public set; }
    public static bool isConverged { get; }
    internal static int scheduledMaterialUpdatesCount { get; }
    internal static bool asyncMaterialUpdates { get; internal set; }
    public static float get_indirectScale();
    public static void set_indirectScale(float value);
    public static float get_updateThreshold();
    public static void set_updateThreshold(float value);
    public static int get_materialUpdateTimeSlice();
    public static void set_materialUpdateTimeSlice(int value);
    public static void SetEmissive(Renderer renderer, Color color);
    [NativeThrowsAttribute]
public static void SetEnvironmentData(Single[] input);
    public static bool get_synchronousMode();
    public static void set_synchronousMode(bool value);
    public static bool get_isConverged();
    internal static int get_scheduledMaterialUpdatesCount();
    internal static bool get_asyncMaterialUpdates();
    internal static void set_asyncMaterialUpdates(bool value);
    public static void UpdateEnvironment();
    [ObsoleteAttribute("DynamicGI.UpdateMaterials(Renderer) is deprecated; instead, use extension method from RendererExtensions: 'renderer.UpdateGIMaterials()' (UnityUpgradable).", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateMaterials(Renderer renderer);
    [ObsoleteAttribute("DynamicGI.UpdateMaterials(Terrain) is deprecated; instead, use extension method from TerrainExtensions: 'terrain.UpdateGIMaterials()' (UnityUpgradable).", "True")]
[EditorBrowsableAttribute("1")]
public static void UpdateMaterials(Object renderer);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("DynamicGI.UpdateMaterials(Terrain, int, int, int, int) is deprecated; instead, use extension method from TerrainExtensions: 'terrain.UpdateGIMaterials(x, y, width, height)' (UnityUpgradable).", "True")]
public static void UpdateMaterials(Object renderer, int x, int y, int width, int height);
    private static void SetEmissive_Injected(Renderer renderer, Color& color);
}
internal enum UnityEngine.EnabledOrientation : Enum {
    public int value__;
    public static EnabledOrientation kAutorotateToPortrait;
    public static EnabledOrientation kAutorotateToPortraitUpsideDown;
    public static EnabledOrientation kAutorotateToLandscapeLeft;
    public static EnabledOrientation kAutorotateToLandscapeRight;
}
internal class UnityEngine.EnumData : ValueType {
    public Enum[] values;
    public Int32[] flagValues;
    public String[] displayNames;
    public String[] names;
    public String[] tooltip;
    public bool flags;
    public Type underlyingType;
    public bool unsigned;
    public bool serializable;
}
internal static class UnityEngine.EnumDataUtility : object {
    private static Dictionary`2<ValueTuple`2<CachedType, Type>, EnumData> s_EnumData;
    private static EnumDataUtility();
    public static EnumData GetCachedEnumData(Type enumType, CachedType cachedType, Func`2<string, string> nicifyName);
    internal static int EnumFlagsToInt(EnumData enumData, Enum enumValue);
    internal static Enum IntToEnumFlags(Type enumType, int value);
    internal static void HandleInspectorOrderAttribute(Type enumType, EnumData& enumData);
    private static bool CheckObsoleteAddition(FieldInfo field, CachedType cachedType);
    private static string EnumTooltipFromEnumField(FieldInfo field);
    private static string EnumNameFromEnumField(FieldInfo field, Func`2<string, string> nicifyName);
    [CompilerGeneratedAttribute]
internal static string <EnumNameFromEnumField>g__NicifyName|8_0(<>c__DisplayClass8_0& );
}
internal class UnityEngine.EnumInfo : object {
    public String[] names;
    public Int32[] values;
    public String[] annotations;
    public bool isFlags;
    [UsedByNativeCodeAttribute]
internal static EnumInfo CreateEnumInfoFromNativeEnum(String[] names, Int32[] values, String[] annotations, bool isFlags);
}
internal class UnityEngine.Events.ArgumentCache : object {
    [FormerlySerializedAsAttribute("objectArgument")]
[SerializeField]
private Object m_ObjectArgument;
    [SerializeField]
[FormerlySerializedAsAttribute("objectArgumentAssemblyTypeName")]
private string m_ObjectArgumentAssemblyTypeName;
    [FormerlySerializedAsAttribute("intArgument")]
[SerializeField]
private int m_IntArgument;
    [FormerlySerializedAsAttribute("floatArgument")]
[SerializeField]
private float m_FloatArgument;
    [FormerlySerializedAsAttribute("stringArgument")]
[SerializeField]
private string m_StringArgument;
    [SerializeField]
private bool m_BoolArgument;
    public Object unityObjectArgument { get; public set; }
    public string unityObjectArgumentAssemblyTypeName { get; }
    public int intArgument { get; public set; }
    public float floatArgument { get; public set; }
    public string stringArgument { get; public set; }
    public bool boolArgument { get; public set; }
    public Object get_unityObjectArgument();
    public void set_unityObjectArgument(Object value);
    public string get_unityObjectArgumentAssemblyTypeName();
    public int get_intArgument();
    public void set_intArgument(int value);
    public float get_floatArgument();
    public void set_floatArgument(float value);
    public string get_stringArgument();
    public void set_stringArgument(string value);
    public bool get_boolArgument();
    public void set_boolArgument(bool value);
    public sealed virtual void OnBeforeSerialize();
    public sealed virtual void OnAfterDeserialize();
}
internal abstract class UnityEngine.Events.BaseInvokableCall : object {
    protected BaseInvokableCall(object target, MethodInfo function);
    public abstract virtual void Invoke(Object[] args);
    protected static void ThrowOnInvalidArg(object arg);
    protected static bool AllowInvoke(Delegate delegate);
    public abstract virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.CachedInvokableCall`1 : InvokableCall`1<T> {
    private T m_Arg1;
    public CachedInvokableCall`1(Object target, MethodInfo theFunction, T argument);
    public virtual void Invoke(Object[] args);
    public virtual void Invoke(T arg0);
}
internal class UnityEngine.Events.InvokableCall : BaseInvokableCall {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private UnityAction Delegate;
    public InvokableCall(object target, MethodInfo theFunction);
    public InvokableCall(UnityAction action);
    [CompilerGeneratedAttribute]
private void add_Delegate(UnityAction value);
    [CompilerGeneratedAttribute]
private void remove_Delegate(UnityAction value);
    public virtual void Invoke(Object[] args);
    public void Invoke();
    public virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.InvokableCall`1 : BaseInvokableCall {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private UnityAction`1<T1> Delegate;
    public InvokableCall`1(object target, MethodInfo theFunction);
    public InvokableCall`1(UnityAction`1<T1> action);
    [CompilerGeneratedAttribute]
protected void add_Delegate(UnityAction`1<T1> value);
    [CompilerGeneratedAttribute]
protected void remove_Delegate(UnityAction`1<T1> value);
    public virtual void Invoke(Object[] args);
    public virtual void Invoke(T1 args0);
    public virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.InvokableCall`2 : BaseInvokableCall {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private UnityAction`2<T1, T2> Delegate;
    public InvokableCall`2(object target, MethodInfo theFunction);
    public InvokableCall`2(UnityAction`2<T1, T2> action);
    [CompilerGeneratedAttribute]
protected void add_Delegate(UnityAction`2<T1, T2> value);
    [CompilerGeneratedAttribute]
protected void remove_Delegate(UnityAction`2<T1, T2> value);
    public virtual void Invoke(Object[] args);
    public void Invoke(T1 args0, T2 args1);
    public virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.InvokableCall`3 : BaseInvokableCall {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private UnityAction`3<T1, T2, T3> Delegate;
    public InvokableCall`3(object target, MethodInfo theFunction);
    public InvokableCall`3(UnityAction`3<T1, T2, T3> action);
    [CompilerGeneratedAttribute]
protected void add_Delegate(UnityAction`3<T1, T2, T3> value);
    [CompilerGeneratedAttribute]
protected void remove_Delegate(UnityAction`3<T1, T2, T3> value);
    public virtual void Invoke(Object[] args);
    public void Invoke(T1 args0, T2 args1, T3 args2);
    public virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.InvokableCall`4 : BaseInvokableCall {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private UnityAction`4<T1, T2, T3, T4> Delegate;
    public InvokableCall`4(object target, MethodInfo theFunction);
    public InvokableCall`4(UnityAction`4<T1, T2, T3, T4> action);
    [CompilerGeneratedAttribute]
protected void add_Delegate(UnityAction`4<T1, T2, T3, T4> value);
    [CompilerGeneratedAttribute]
protected void remove_Delegate(UnityAction`4<T1, T2, T3, T4> value);
    public virtual void Invoke(Object[] args);
    public void Invoke(T1 args0, T2 args1, T3 args2, T4 args3);
    public virtual bool Find(object targetObj, MethodInfo method);
}
internal class UnityEngine.Events.InvokableCallList : object {
    private List`1<BaseInvokableCall> m_PersistentCalls;
    private List`1<BaseInvokableCall> m_RuntimeCalls;
    private List`1<BaseInvokableCall> m_ExecutingCalls;
    private bool m_NeedsUpdate;
    public int Count { get; }
    public int get_Count();
    public void AddPersistentInvokableCall(BaseInvokableCall call);
    public void AddListener(BaseInvokableCall call);
    public void RemoveListener(object targetObj, MethodInfo method);
    public void Clear();
    public void ClearPersistent();
    public List`1<BaseInvokableCall> PrepareInvoke();
}
internal class UnityEngine.Events.PersistentCall : object {
    [SerializeField]
[FormerlySerializedAsAttribute("instance")]
private Object m_Target;
    [SerializeField]
private string m_TargetAssemblyTypeName;
    [FormerlySerializedAsAttribute("methodName")]
[SerializeField]
private string m_MethodName;
    [FormerlySerializedAsAttribute("mode")]
[SerializeField]
private PersistentListenerMode m_Mode;
    [SerializeField]
[FormerlySerializedAsAttribute("arguments")]
private ArgumentCache m_Arguments;
    [FormerlySerializedAsAttribute("m_Enabled")]
[FormerlySerializedAsAttribute("enabled")]
[SerializeField]
private UnityEventCallState m_CallState;
    public Object target { get; }
    public string targetAssemblyTypeName { get; }
    public string methodName { get; }
    public PersistentListenerMode mode { get; public set; }
    public ArgumentCache arguments { get; }
    public UnityEventCallState callState { get; public set; }
    public Object get_target();
    public string get_targetAssemblyTypeName();
    public string get_methodName();
    public PersistentListenerMode get_mode();
    public void set_mode(PersistentListenerMode value);
    public ArgumentCache get_arguments();
    public UnityEventCallState get_callState();
    public void set_callState(UnityEventCallState value);
    public bool IsValid();
    public BaseInvokableCall GetRuntimeCall(UnityEventBase theEvent);
    private static BaseInvokableCall GetObjectCall(Object target, MethodInfo method, ArgumentCache arguments);
    public void RegisterPersistentListener(Object ttarget, Type targetType, string mmethodName);
    public void UnregisterPersistentListener();
    public sealed virtual void OnBeforeSerialize();
    public sealed virtual void OnAfterDeserialize();
}
internal class UnityEngine.Events.PersistentCallGroup : object {
    [SerializeField]
[FormerlySerializedAsAttribute("m_Listeners")]
private List`1<PersistentCall> m_Calls;
    public int Count { get; }
    public int get_Count();
    public PersistentCall GetListener(int index);
    public IEnumerable`1<PersistentCall> GetListeners();
    public void AddListener();
    public void AddListener(PersistentCall call);
    public void RemoveListener(int index);
    public void Clear();
    public void RegisterEventPersistentListener(int index, Object targetObj, Type targetObjType, string methodName);
    public void RegisterVoidPersistentListener(int index, Object targetObj, Type targetObjType, string methodName);
    public void RegisterObjectPersistentListener(int index, Object targetObj, Type targetObjType, Object argument, string methodName);
    public void RegisterIntPersistentListener(int index, Object targetObj, Type targetObjType, int argument, string methodName);
    public void RegisterFloatPersistentListener(int index, Object targetObj, Type targetObjType, float argument, string methodName);
    public void RegisterStringPersistentListener(int index, Object targetObj, Type targetObjType, string argument, string methodName);
    public void RegisterBoolPersistentListener(int index, Object targetObj, Type targetObjType, bool argument, string methodName);
    public void UnregisterPersistentListener(int index);
    public void RemoveListeners(Object target, string methodName);
    public void Initialize(InvokableCallList invokableList, UnityEventBase unityEventBase);
}
public enum UnityEngine.Events.PersistentListenerMode : Enum {
    public int value__;
    public static PersistentListenerMode EventDefined;
    public static PersistentListenerMode Void;
    public static PersistentListenerMode Object;
    public static PersistentListenerMode Int;
    public static PersistentListenerMode Float;
    public static PersistentListenerMode String;
    public static PersistentListenerMode Bool;
}
public class UnityEngine.Events.UnityAction : MulticastDelegate {
    public UnityAction(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class UnityEngine.Events.UnityAction`1 : MulticastDelegate {
    public UnityAction`1(object object, IntPtr method);
    public virtual void Invoke(T0 arg0);
    public virtual IAsyncResult BeginInvoke(T0 arg0, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class UnityEngine.Events.UnityAction`2 : MulticastDelegate {
    public UnityAction`2(object object, IntPtr method);
    public virtual void Invoke(T0 arg0, T1 arg1);
    public virtual IAsyncResult BeginInvoke(T0 arg0, T1 arg1, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class UnityEngine.Events.UnityAction`3 : MulticastDelegate {
    public UnityAction`3(object object, IntPtr method);
    public virtual void Invoke(T0 arg0, T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class UnityEngine.Events.UnityAction`4 : MulticastDelegate {
    public UnityAction`4(object object, IntPtr method);
    public virtual void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class UnityEngine.Events.UnityEvent : UnityEventBase {
    private Object[] m_InvokeArray;
    public void AddListener(UnityAction call);
    public void RemoveListener(UnityAction call);
    protected virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    private static BaseInvokableCall GetDelegate(UnityAction action);
    public void Invoke();
}
public class UnityEngine.Events.UnityEvent`1 : UnityEventBase {
    private Object[] m_InvokeArray;
    public void AddListener(UnityAction`1<T0> call);
    public void RemoveListener(UnityAction`1<T0> call);
    protected virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    private static BaseInvokableCall GetDelegate(UnityAction`1<T0> action);
    public void Invoke(T0 arg0);
}
public class UnityEngine.Events.UnityEvent`2 : UnityEventBase {
    private Object[] m_InvokeArray;
    public void AddListener(UnityAction`2<T0, T1> call);
    public void RemoveListener(UnityAction`2<T0, T1> call);
    protected virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    private static BaseInvokableCall GetDelegate(UnityAction`2<T0, T1> action);
    public void Invoke(T0 arg0, T1 arg1);
}
public class UnityEngine.Events.UnityEvent`3 : UnityEventBase {
    private Object[] m_InvokeArray;
    public void AddListener(UnityAction`3<T0, T1, T2> call);
    public void RemoveListener(UnityAction`3<T0, T1, T2> call);
    protected virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    private static BaseInvokableCall GetDelegate(UnityAction`3<T0, T1, T2> action);
    public void Invoke(T0 arg0, T1 arg1, T2 arg2);
}
public class UnityEngine.Events.UnityEvent`4 : UnityEventBase {
    private Object[] m_InvokeArray;
    public void AddListener(UnityAction`4<T0, T1, T2, T3> call);
    public void RemoveListener(UnityAction`4<T0, T1, T2, T3> call);
    protected virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    private static BaseInvokableCall GetDelegate(UnityAction`4<T0, T1, T2, T3> action);
    public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
}
[UsedByNativeCodeAttribute]
public abstract class UnityEngine.Events.UnityEventBase : object {
    private InvokableCallList m_Calls;
    [SerializeField]
[FormerlySerializedAsAttribute("m_PersistentListeners")]
private PersistentCallGroup m_PersistentCalls;
    private bool m_CallsDirty;
    private sealed virtual override void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize();
    private sealed virtual override void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize();
    protected MethodInfo FindMethod_Impl(string name, object targetObj);
    protected abstract virtual MethodInfo FindMethod_Impl(string name, Type targetObjType);
    internal abstract virtual BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
    internal MethodInfo FindMethod(PersistentCall call);
    internal MethodInfo FindMethod(string name, Type listenerType, PersistentListenerMode mode, Type argumentType);
    public int GetPersistentEventCount();
    public Object GetPersistentTarget(int index);
    public string GetPersistentMethodName(int index);
    private void DirtyPersistentCalls();
    private void RebuildPersistentCallsIfNeeded();
    public void SetPersistentListenerState(int index, UnityEventCallState state);
    public UnityEventCallState GetPersistentListenerState(int index);
    protected void AddListener(object targetObj, MethodInfo method);
    internal void AddCall(BaseInvokableCall call);
    protected void RemoveListener(object targetObj, MethodInfo method);
    public void RemoveAllListeners();
    internal List`1<BaseInvokableCall> PrepareInvoke();
    protected void Invoke(Object[] parameters);
    public virtual string ToString();
    public static MethodInfo GetValidMethodInfo(object obj, string functionName, Type[] argumentTypes);
    public static MethodInfo GetValidMethodInfo(Type objectType, string functionName, Type[] argumentTypes);
}
public enum UnityEngine.Events.UnityEventCallState : Enum {
    public int value__;
    public static UnityEventCallState Off;
    public static UnityEventCallState EditorAndRuntime;
    public static UnityEventCallState RuntimeOnly;
}
internal class UnityEngine.Events.UnityEventTools : object {
    internal static string TidyAssemblyTypeName(string assemblyTypeName);
}
[AttributeUsageAttribute("4")]
[UsedByNativeCodeAttribute]
public class UnityEngine.ExcludeFromObjectFactoryAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[UsedByNativeCodeAttribute]
public class UnityEngine.ExcludeFromPresetAttribute : Attribute {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ExecuteAlways : Attribute {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ExecuteInEditMode : Attribute {
}
public enum UnityEngine.Experimental.GlobalIllumination.AngularFalloffType : Enum {
    public byte value__;
    public static AngularFalloffType LUT;
    public static AngularFalloffType AnalyticAndInnerAngle;
}
public class UnityEngine.Experimental.GlobalIllumination.Cookie : ValueType {
    public int instanceID;
    public float scale;
    public Vector2 sizes;
    public static Cookie Defaults();
}
public class UnityEngine.Experimental.GlobalIllumination.DirectionalLight : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float penumbraWidthRadian;
    [ObsoleteAttribute("Directional lights support cookies now. In order to position the cookie projection in the world, a position and full orientation are necessary. Use the position and orientation members instead of the direction parameter.", "True")]
public Vector3 direction;
}
public class UnityEngine.Experimental.GlobalIllumination.DiscLight : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float radius;
    public FalloffType falloff;
}
public enum UnityEngine.Experimental.GlobalIllumination.FalloffType : Enum {
    public byte value__;
    public static FalloffType InverseSquared;
    public static FalloffType InverseSquaredNoRangeAttenuation;
    public static FalloffType Linear;
    public static FalloffType Legacy;
    public static FalloffType Undefined;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Experimental.GlobalIllumination.LightDataGI : ValueType {
    public int instanceID;
    public int cookieID;
    public float cookieScale;
    public LinearColor color;
    public LinearColor indirectColor;
    public Quaternion orientation;
    public Vector3 position;
    public float range;
    public float coneAngle;
    public float innerConeAngle;
    public float shape0;
    public float shape1;
    public LightType type;
    public LightMode mode;
    public byte shadow;
    public FalloffType falloff;
    public void Init(DirectionalLight& light, Cookie& cookie);
    public void Init(PointLight& light, Cookie& cookie);
    public void Init(SpotLight& light, Cookie& cookie);
    public void Init(RectangleLight& light, Cookie& cookie);
    public void Init(DiscLight& light, Cookie& cookie);
    public void Init(SpotLightBoxShape& light, Cookie& cookie);
    public void Init(SpotLightPyramidShape& light, Cookie& cookie);
    public void Init(DirectionalLight& light);
    public void Init(PointLight& light);
    public void Init(SpotLight& light);
    public void Init(RectangleLight& light);
    public void Init(DiscLight& light);
    public void Init(SpotLightBoxShape& light);
    public void Init(SpotLightPyramidShape& light);
    public void InitNoBake(int lightInstanceID);
}
public static class UnityEngine.Experimental.GlobalIllumination.LightmapperUtils : object {
    public static LightMode Extract(LightmapBakeType baketype);
    public static LinearColor ExtractIndirect(Light l);
    public static float ExtractInnerCone(Light l);
    private static Color ExtractColorTemperature(Light l);
    private static void ApplyColorTemperature(Color cct, LinearColor& lightColor);
    public static void Extract(Light l, DirectionalLight& dir);
    public static void Extract(Light l, PointLight& point);
    public static void Extract(Light l, SpotLight& spot);
    public static void Extract(Light l, RectangleLight& rect);
    public static void Extract(Light l, DiscLight& disc);
    public static void Extract(Light l, Cookie& cookie);
}
public static class UnityEngine.Experimental.GlobalIllumination.Lightmapping : object {
    [RequiredByNativeCodeAttribute]
private static RequestLightsDelegate s_DefaultDelegate;
    [RequiredByNativeCodeAttribute]
private static RequestLightsDelegate s_RequestLightsDelegate;
    private static Lightmapping();
    [RequiredByNativeCodeAttribute]
public static void SetDelegate(RequestLightsDelegate del);
    [RequiredByNativeCodeAttribute]
public static RequestLightsDelegate GetDelegate();
    [RequiredByNativeCodeAttribute]
public static void ResetDelegate();
    [RequiredByNativeCodeAttribute]
internal static void RequestLights(Light[] lights, IntPtr outLightsPtr, int outLightsCount);
}
public enum UnityEngine.Experimental.GlobalIllumination.LightMode : Enum {
    public byte value__;
    public static LightMode Realtime;
    public static LightMode Mixed;
    public static LightMode Baked;
    public static LightMode Unknown;
}
public enum UnityEngine.Experimental.GlobalIllumination.LightType : Enum {
    public byte value__;
    public static LightType Directional;
    public static LightType Point;
    public static LightType Spot;
    public static LightType Rectangle;
    public static LightType Disc;
    public static LightType SpotPyramidShape;
    public static LightType SpotBoxShape;
}
public class UnityEngine.Experimental.GlobalIllumination.LinearColor : ValueType {
    private float m_red;
    private float m_green;
    private float m_blue;
    private float m_intensity;
    public float red { get; public set; }
    public float green { get; public set; }
    public float blue { get; public set; }
    public float intensity { get; public set; }
    public float get_red();
    public void set_red(float value);
    public float get_green();
    public void set_green(float value);
    public float get_blue();
    public void set_blue(float value);
    public float get_intensity();
    public void set_intensity(float value);
    public static LinearColor Convert(Color color, float intensity);
    public static LinearColor Black();
}
public class UnityEngine.Experimental.GlobalIllumination.PointLight : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float sphereRadius;
    public FalloffType falloff;
}
public class UnityEngine.Experimental.GlobalIllumination.RectangleLight : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float width;
    public float height;
    public FalloffType falloff;
}
[NativeHeaderAttribute("Runtime/Camera/RenderSettings.h")]
[StaticAccessorAttribute("GetRenderSettings()", "0")]
public class UnityEngine.Experimental.GlobalIllumination.RenderSettings : object {
    public static bool useRadianceAmbientProbe { get; public set; }
    public static bool get_useRadianceAmbientProbe();
    public static void set_useRadianceAmbientProbe(bool value);
}
public class UnityEngine.Experimental.GlobalIllumination.SpotLight : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float sphereRadius;
    public float coneAngle;
    public float innerConeAngle;
    public FalloffType falloff;
    public AngularFalloffType angularFalloff;
}
public class UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float width;
    public float height;
}
public class UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape : ValueType {
    public int instanceID;
    public bool shadow;
    public LightMode mode;
    public Vector3 position;
    public Quaternion orientation;
    public LinearColor color;
    public LinearColor indirectColor;
    public float range;
    public float angle;
    public float aspectRatio;
    public FalloffType falloff;
}
[StaticAccessorAttribute("CameraPlayableBindings", "2")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Director/CameraPlayable.bindings.h")]
[NativeHeaderAttribute("Runtime/Camera//Director/CameraPlayable.h")]
public class UnityEngine.Experimental.Playables.CameraPlayable : ValueType {
    private PlayableHandle m_Handle;
    internal CameraPlayable(PlayableHandle handle);
    public static CameraPlayable Create(PlayableGraph graph, Camera camera);
    private static PlayableHandle CreateHandle(PlayableGraph graph, Camera camera);
    public sealed virtual PlayableHandle GetHandle();
    public static Playable op_Implicit(CameraPlayable playable);
    public static CameraPlayable op_Explicit(Playable playable);
    public sealed virtual bool Equals(CameraPlayable other);
    public Camera GetCamera();
    public void SetCamera(Camera value);
    [NativeThrowsAttribute]
private static Camera GetCameraInternal(PlayableHandle& hdl);
    [NativeThrowsAttribute]
private static void SetCameraInternal(PlayableHandle& hdl, Camera camera);
    [NativeThrowsAttribute]
private static bool InternalCreateCameraPlayable(PlayableGraph& graph, Camera camera, PlayableHandle& handle);
    [NativeThrowsAttribute]
private static bool ValidateType(PlayableHandle& hdl);
}
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
[NativeHeaderAttribute("Runtime/Shaders/Director/MaterialEffectPlayable.h")]
[NativeHeaderAttribute("Runtime/Export/Director/MaterialEffectPlayable.bindings.h")]
[RequiredByNativeCodeAttribute]
[StaticAccessorAttribute("MaterialEffectPlayableBindings", "2")]
public class UnityEngine.Experimental.Playables.MaterialEffectPlayable : ValueType {
    private PlayableHandle m_Handle;
    internal MaterialEffectPlayable(PlayableHandle handle);
    public static MaterialEffectPlayable Create(PlayableGraph graph, Material material, int pass);
    private static PlayableHandle CreateHandle(PlayableGraph graph, Material material, int pass);
    public sealed virtual PlayableHandle GetHandle();
    public static Playable op_Implicit(MaterialEffectPlayable playable);
    public static MaterialEffectPlayable op_Explicit(Playable playable);
    public sealed virtual bool Equals(MaterialEffectPlayable other);
    public Material GetMaterial();
    public void SetMaterial(Material value);
    public int GetPass();
    public void SetPass(int value);
    [NativeThrowsAttribute]
private static Material GetMaterialInternal(PlayableHandle& hdl);
    [NativeThrowsAttribute]
private static void SetMaterialInternal(PlayableHandle& hdl, Material material);
    [NativeThrowsAttribute]
private static int GetPassInternal(PlayableHandle& hdl);
    [NativeThrowsAttribute]
private static void SetPassInternal(PlayableHandle& hdl, int pass);
    [NativeThrowsAttribute]
private static bool InternalCreateMaterialEffectPlayable(PlayableGraph& graph, Material material, int pass, PlayableHandle& handle);
    [NativeThrowsAttribute]
private static bool ValidateType(PlayableHandle& hdl);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Director/TextureMixerPlayable.bindings.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
[StaticAccessorAttribute("TextureMixerPlayableBindings", "2")]
[NativeHeaderAttribute("Runtime/Graphics/Director/TextureMixerPlayable.h")]
public class UnityEngine.Experimental.Playables.TextureMixerPlayable : ValueType {
    private PlayableHandle m_Handle;
    internal TextureMixerPlayable(PlayableHandle handle);
    public static TextureMixerPlayable Create(PlayableGraph graph);
    private static PlayableHandle CreateHandle(PlayableGraph graph);
    public sealed virtual PlayableHandle GetHandle();
    public static Playable op_Implicit(TextureMixerPlayable playable);
    public static TextureMixerPlayable op_Explicit(Playable playable);
    public sealed virtual bool Equals(TextureMixerPlayable other);
    [NativeThrowsAttribute]
private static bool CreateTextureMixerPlayableInternal(PlayableGraph& graph, PlayableHandle& handle);
}
public static class UnityEngine.Experimental.Playables.TexturePlayableBinding : object {
    public static PlayableBinding Create(string name, Object key);
    private static PlayableOutput CreateTextureOutput(PlayableGraph graph, string name);
}
[NativeHeaderAttribute("Runtime/Export/Director/TexturePlayableGraphExtensions.bindings.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayableOutput.h")]
[StaticAccessorAttribute("TexturePlayableGraphExtensionsBindings", "2")]
internal static class UnityEngine.Experimental.Playables.TexturePlayableGraphExtensions : object {
    [NativeThrowsAttribute]
internal static bool InternalCreateTextureOutput(PlayableGraph& graph, string name, PlayableOutputHandle& handle);
}
[NativeHeaderAttribute("Runtime/Export/Director/TexturePlayableOutput.bindings.h")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/Director/TexturePlayableOutput.h")]
[NativeHeaderAttribute("Runtime/Graphics/RenderTexture.h")]
[StaticAccessorAttribute("TexturePlayableOutputBindings", "2")]
public class UnityEngine.Experimental.Playables.TexturePlayableOutput : ValueType {
    private PlayableOutputHandle m_Handle;
    public static TexturePlayableOutput Null { get; }
    internal TexturePlayableOutput(PlayableOutputHandle handle);
    public static TexturePlayableOutput Create(PlayableGraph graph, string name, RenderTexture target);
    public static TexturePlayableOutput get_Null();
    public sealed virtual PlayableOutputHandle GetHandle();
    public static PlayableOutput op_Implicit(TexturePlayableOutput output);
    public static TexturePlayableOutput op_Explicit(PlayableOutput output);
    public RenderTexture GetTarget();
    public void SetTarget(RenderTexture value);
    [NativeThrowsAttribute]
private static RenderTexture InternalGetTarget(PlayableOutputHandle& output);
    [NativeThrowsAttribute]
private static void InternalSetTarget(PlayableOutputHandle& output, RenderTexture target);
}
[NativeHeaderAttribute("Runtime/Camera/ReflectionProbes.h")]
internal class UnityEngine.Experimental.Rendering.BuiltinRuntimeReflectionSystem : object {
    public sealed virtual bool TickRealtimeProbes();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [StaticAccessorAttribute("GetReflectionProbes()")]
private static bool BuiltinUpdate();
    [RequiredByNativeCodeAttribute]
private static BuiltinRuntimeReflectionSystem Internal_BuiltinRuntimeReflectionSystem_New();
}
public enum UnityEngine.Experimental.Rendering.DefaultFormat : Enum {
    public int value__;
    public static DefaultFormat LDR;
    public static DefaultFormat HDR;
    public static DefaultFormat DepthStencil;
    public static DefaultFormat Shadow;
    public static DefaultFormat Video;
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public static class UnityEngine.Experimental.Rendering.ExternalGPUProfiler : object {
    [FreeFunctionAttribute("ExternalGPUProfilerBindings::BeginGPUCapture")]
public static void BeginGPUCapture();
    [FreeFunctionAttribute("ExternalGPUProfilerBindings::EndGPUCapture")]
public static void EndGPUCapture();
    [FreeFunctionAttribute("ExternalGPUProfilerBindings::IsAttached")]
public static bool IsAttached();
}
public enum UnityEngine.Experimental.Rendering.FormatUsage : Enum {
    public int value__;
    public static FormatUsage Sample;
    public static FormatUsage Linear;
    public static FormatUsage Sparse;
    public static FormatUsage Render;
    public static FormatUsage Blend;
    public static FormatUsage GetPixels;
    public static FormatUsage SetPixels;
    public static FormatUsage SetPixels32;
    public static FormatUsage ReadPixels;
    public static FormatUsage LoadStore;
    public static FormatUsage MSAA2x;
    public static FormatUsage MSAA4x;
    public static FormatUsage MSAA8x;
    public static FormatUsage StencilSampling;
}
public static class UnityEngine.Experimental.Rendering.GraphicsDeviceSettings : object {
    [StaticAccessorAttribute("GetGfxDevice()", "0")]
public static WaitForPresentSyncPoint waitForPresentSyncPoint { get; public set; }
    [StaticAccessorAttribute("GetGfxDevice()", "0")]
public static GraphicsJobsSyncPoint graphicsJobsSyncPoint { get; public set; }
    public static WaitForPresentSyncPoint get_waitForPresentSyncPoint();
    public static void set_waitForPresentSyncPoint(WaitForPresentSyncPoint value);
    public static GraphicsJobsSyncPoint get_graphicsJobsSyncPoint();
    public static void set_graphicsJobsSyncPoint(GraphicsJobsSyncPoint value);
}
public enum UnityEngine.Experimental.Rendering.GraphicsFormat : Enum {
    public int value__;
    public static GraphicsFormat None;
    public static GraphicsFormat R8_SRGB;
    public static GraphicsFormat R8G8_SRGB;
    public static GraphicsFormat R8G8B8_SRGB;
    public static GraphicsFormat R8G8B8A8_SRGB;
    public static GraphicsFormat R8_UNorm;
    public static GraphicsFormat R8G8_UNorm;
    public static GraphicsFormat R8G8B8_UNorm;
    public static GraphicsFormat R8G8B8A8_UNorm;
    public static GraphicsFormat R8_SNorm;
    public static GraphicsFormat R8G8_SNorm;
    public static GraphicsFormat R8G8B8_SNorm;
    public static GraphicsFormat R8G8B8A8_SNorm;
    public static GraphicsFormat R8_UInt;
    public static GraphicsFormat R8G8_UInt;
    public static GraphicsFormat R8G8B8_UInt;
    public static GraphicsFormat R8G8B8A8_UInt;
    public static GraphicsFormat R8_SInt;
    public static GraphicsFormat R8G8_SInt;
    public static GraphicsFormat R8G8B8_SInt;
    public static GraphicsFormat R8G8B8A8_SInt;
    public static GraphicsFormat R16_UNorm;
    public static GraphicsFormat R16G16_UNorm;
    public static GraphicsFormat R16G16B16_UNorm;
    public static GraphicsFormat R16G16B16A16_UNorm;
    public static GraphicsFormat R16_SNorm;
    public static GraphicsFormat R16G16_SNorm;
    public static GraphicsFormat R16G16B16_SNorm;
    public static GraphicsFormat R16G16B16A16_SNorm;
    public static GraphicsFormat R16_UInt;
    public static GraphicsFormat R16G16_UInt;
    public static GraphicsFormat R16G16B16_UInt;
    public static GraphicsFormat R16G16B16A16_UInt;
    public static GraphicsFormat R16_SInt;
    public static GraphicsFormat R16G16_SInt;
    public static GraphicsFormat R16G16B16_SInt;
    public static GraphicsFormat R16G16B16A16_SInt;
    public static GraphicsFormat R32_UInt;
    public static GraphicsFormat R32G32_UInt;
    public static GraphicsFormat R32G32B32_UInt;
    public static GraphicsFormat R32G32B32A32_UInt;
    public static GraphicsFormat R32_SInt;
    public static GraphicsFormat R32G32_SInt;
    public static GraphicsFormat R32G32B32_SInt;
    public static GraphicsFormat R32G32B32A32_SInt;
    public static GraphicsFormat R16_SFloat;
    public static GraphicsFormat R16G16_SFloat;
    public static GraphicsFormat R16G16B16_SFloat;
    public static GraphicsFormat R16G16B16A16_SFloat;
    public static GraphicsFormat R32_SFloat;
    public static GraphicsFormat R32G32_SFloat;
    public static GraphicsFormat R32G32B32_SFloat;
    public static GraphicsFormat R32G32B32A32_SFloat;
    public static GraphicsFormat B8G8R8_SRGB;
    public static GraphicsFormat B8G8R8A8_SRGB;
    public static GraphicsFormat B8G8R8_UNorm;
    public static GraphicsFormat B8G8R8A8_UNorm;
    public static GraphicsFormat B8G8R8_SNorm;
    public static GraphicsFormat B8G8R8A8_SNorm;
    public static GraphicsFormat B8G8R8_UInt;
    public static GraphicsFormat B8G8R8A8_UInt;
    public static GraphicsFormat B8G8R8_SInt;
    public static GraphicsFormat B8G8R8A8_SInt;
    public static GraphicsFormat R4G4B4A4_UNormPack16;
    public static GraphicsFormat B4G4R4A4_UNormPack16;
    public static GraphicsFormat R5G6B5_UNormPack16;
    public static GraphicsFormat B5G6R5_UNormPack16;
    public static GraphicsFormat R5G5B5A1_UNormPack16;
    public static GraphicsFormat B5G5R5A1_UNormPack16;
    public static GraphicsFormat A1R5G5B5_UNormPack16;
    public static GraphicsFormat E5B9G9R9_UFloatPack32;
    public static GraphicsFormat B10G11R11_UFloatPack32;
    public static GraphicsFormat A2B10G10R10_UNormPack32;
    public static GraphicsFormat A2B10G10R10_UIntPack32;
    public static GraphicsFormat A2B10G10R10_SIntPack32;
    public static GraphicsFormat A2R10G10B10_UNormPack32;
    public static GraphicsFormat A2R10G10B10_UIntPack32;
    public static GraphicsFormat A2R10G10B10_SIntPack32;
    public static GraphicsFormat A2R10G10B10_XRSRGBPack32;
    public static GraphicsFormat A2R10G10B10_XRUNormPack32;
    public static GraphicsFormat R10G10B10_XRSRGBPack32;
    public static GraphicsFormat R10G10B10_XRUNormPack32;
    public static GraphicsFormat A10R10G10B10_XRSRGBPack32;
    public static GraphicsFormat A10R10G10B10_XRUNormPack32;
    public static GraphicsFormat D16_UNorm;
    public static GraphicsFormat D24_UNorm;
    public static GraphicsFormat D24_UNorm_S8_UInt;
    public static GraphicsFormat D32_SFloat;
    public static GraphicsFormat D32_SFloat_S8_UInt;
    public static GraphicsFormat S8_UInt;
    [ObsoleteAttribute("Enum member GraphicsFormat.RGB_DXT1_SRGB has been deprecated. Use GraphicsFormat.RGBA_DXT1_SRGB instead (UnityUpgradable) -> RGBA_DXT1_SRGB", "True")]
[EditorBrowsableAttribute("1")]
public static GraphicsFormat RGB_DXT1_SRGB;
    public static GraphicsFormat RGBA_DXT1_SRGB;
    [ObsoleteAttribute("Enum member GraphicsFormat.RGB_DXT1_UNorm has been deprecated. Use GraphicsFormat.RGBA_DXT1_UNorm instead (UnityUpgradable) -> RGBA_DXT1_UNorm", "True")]
[EditorBrowsableAttribute("1")]
public static GraphicsFormat RGB_DXT1_UNorm;
    public static GraphicsFormat RGBA_DXT1_UNorm;
    public static GraphicsFormat RGBA_DXT3_SRGB;
    public static GraphicsFormat RGBA_DXT3_UNorm;
    public static GraphicsFormat RGBA_DXT5_SRGB;
    public static GraphicsFormat RGBA_DXT5_UNorm;
    public static GraphicsFormat R_BC4_UNorm;
    public static GraphicsFormat R_BC4_SNorm;
    public static GraphicsFormat RG_BC5_UNorm;
    public static GraphicsFormat RG_BC5_SNorm;
    public static GraphicsFormat RGB_BC6H_UFloat;
    public static GraphicsFormat RGB_BC6H_SFloat;
    public static GraphicsFormat RGBA_BC7_SRGB;
    public static GraphicsFormat RGBA_BC7_UNorm;
    public static GraphicsFormat RGB_PVRTC_2Bpp_SRGB;
    public static GraphicsFormat RGB_PVRTC_2Bpp_UNorm;
    public static GraphicsFormat RGB_PVRTC_4Bpp_SRGB;
    public static GraphicsFormat RGB_PVRTC_4Bpp_UNorm;
    public static GraphicsFormat RGBA_PVRTC_2Bpp_SRGB;
    public static GraphicsFormat RGBA_PVRTC_2Bpp_UNorm;
    public static GraphicsFormat RGBA_PVRTC_4Bpp_SRGB;
    public static GraphicsFormat RGBA_PVRTC_4Bpp_UNorm;
    public static GraphicsFormat RGB_ETC_UNorm;
    public static GraphicsFormat RGB_ETC2_SRGB;
    public static GraphicsFormat RGB_ETC2_UNorm;
    public static GraphicsFormat RGB_A1_ETC2_SRGB;
    public static GraphicsFormat RGB_A1_ETC2_UNorm;
    public static GraphicsFormat RGBA_ETC2_SRGB;
    public static GraphicsFormat RGBA_ETC2_UNorm;
    public static GraphicsFormat R_EAC_UNorm;
    public static GraphicsFormat R_EAC_SNorm;
    public static GraphicsFormat RG_EAC_UNorm;
    public static GraphicsFormat RG_EAC_SNorm;
    public static GraphicsFormat RGBA_ASTC4X4_SRGB;
    public static GraphicsFormat RGBA_ASTC4X4_UNorm;
    public static GraphicsFormat RGBA_ASTC5X5_SRGB;
    public static GraphicsFormat RGBA_ASTC5X5_UNorm;
    public static GraphicsFormat RGBA_ASTC6X6_SRGB;
    public static GraphicsFormat RGBA_ASTC6X6_UNorm;
    public static GraphicsFormat RGBA_ASTC8X8_SRGB;
    public static GraphicsFormat RGBA_ASTC8X8_UNorm;
    public static GraphicsFormat RGBA_ASTC10X10_SRGB;
    public static GraphicsFormat RGBA_ASTC10X10_UNorm;
    public static GraphicsFormat RGBA_ASTC12X12_SRGB;
    public static GraphicsFormat RGBA_ASTC12X12_UNorm;
    public static GraphicsFormat YUV2;
    [ObsoleteAttribute("Enum member GraphicsFormat.DepthAuto has been deprecated. Use GraphicsFormat.None as a color format to indicate depth only rendering and DefaultFormat to get the default depth buffer format.", "False")]
public static GraphicsFormat DepthAuto;
    [ObsoleteAttribute("Enum member GraphicsFormat.ShadowAuto has been deprecated. Use GraphicsFormat.None as a color format to indicate depth only rendering and DefaultFormat to get the default shadow buffer format.", "False")]
public static GraphicsFormat ShadowAuto;
    [ObsoleteAttribute("Enum member GraphicsFormat.VideoAuto has been deprecated. Use DefaultFormat instead.", "False")]
public static GraphicsFormat VideoAuto;
    public static GraphicsFormat RGBA_ASTC4X4_UFloat;
    public static GraphicsFormat RGBA_ASTC5X5_UFloat;
    public static GraphicsFormat RGBA_ASTC6X6_UFloat;
    public static GraphicsFormat RGBA_ASTC8X8_UFloat;
    public static GraphicsFormat RGBA_ASTC10X10_UFloat;
    public static GraphicsFormat RGBA_ASTC12X12_UFloat;
    public static GraphicsFormat D16_UNorm_S8_UInt;
}
[NativeHeaderAttribute("Runtime/Graphics/Format.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsFormatUtility.bindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/TextureFormat.h")]
public class UnityEngine.Experimental.Rendering.GraphicsFormatUtility : object {
    private static GraphicsFormat[] tableNoStencil;
    private static GraphicsFormat[] tableStencil;
    private static GraphicsFormatUtility();
    [FreeFunctionAttribute("GetGraphicsFormat_Native_Texture")]
internal static GraphicsFormat GetFormat(Texture texture);
    public static GraphicsFormat GetGraphicsFormat(TextureFormat format, bool isSRGB);
    [FreeFunctionAttribute]
private static GraphicsFormat GetGraphicsFormat_Native_TextureFormat(TextureFormat format, bool isSRGB);
    public static TextureFormat GetTextureFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
private static TextureFormat GetTextureFormat_Native_GraphicsFormat(GraphicsFormat format);
    public static GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, bool isSRGB);
    [FreeFunctionAttribute]
private static GraphicsFormat GetGraphicsFormat_Native_RenderTextureFormat(RenderTextureFormat format, bool isSRGB);
    public static GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, RenderTextureReadWrite readWrite);
    [FreeFunctionAttribute]
private static GraphicsFormat GetDepthStencilFormatFromBitsLegacy_Native(int minimumDepthBits);
    internal static GraphicsFormat GetDepthStencilFormat(int minimumDepthBits);
    [FreeFunctionAttribute]
public static int GetDepthBits(GraphicsFormat format);
    public static GraphicsFormat GetDepthStencilFormat(int minimumDepthBits, int minimumStencilBits);
    [FreeFunctionAttribute]
public static bool IsSRGBFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsSwizzleFormat(GraphicsFormat format);
    public static bool IsSwizzleFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static GraphicsFormat GetSRGBFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static GraphicsFormat GetLinearFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static RenderTextureFormat GetRenderTextureFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetColorComponentCount(GraphicsFormat format);
    public static UInt32 GetColorComponentCount(TextureFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetAlphaComponentCount(GraphicsFormat format);
    public static UInt32 GetAlphaComponentCount(TextureFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetComponentCount(GraphicsFormat format);
    public static UInt32 GetComponentCount(TextureFormat format);
    [FreeFunctionAttribute]
public static string GetFormatString(GraphicsFormat format);
    [FreeFunctionAttribute]
private static string GetFormatString_Native_TextureFormat(TextureFormat format);
    public static string GetFormatString(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsCompressedFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
private static bool IsCompressedFormat_Native_TextureFormat(TextureFormat format);
    [ObsoleteAttribute("IsCompressedTextureFormat is obsolete, please use IsCompressedFormat instead.")]
internal static bool IsCompressedTextureFormat(TextureFormat format);
    public static bool IsCompressedFormat(TextureFormat format);
    [FreeFunctionAttribute]
private static bool CanDecompressFormat(GraphicsFormat format, bool wholeImage);
    internal static bool CanDecompressFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsPackedFormat(GraphicsFormat format);
    public static bool IsPackedFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool Is16BitPackedFormat(GraphicsFormat format);
    public static bool Is16BitPackedFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static GraphicsFormat ConvertToAlphaFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
private static TextureFormat ConvertToAlphaFormat_Native_TextureFormat(TextureFormat format);
    public static TextureFormat ConvertToAlphaFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsAlphaOnlyFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
private static bool IsAlphaOnlyFormat_Native_TextureFormat(TextureFormat format);
    public static bool IsAlphaOnlyFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsAlphaTestFormat(GraphicsFormat format);
    public static bool IsAlphaTestFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool HasAlphaChannel(GraphicsFormat format);
    [FreeFunctionAttribute]
private static bool HasAlphaChannel_Native_TextureFormat(TextureFormat format);
    public static bool HasAlphaChannel(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsDepthFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsStencilFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsDepthStencilFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsIEEE754Format(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsFloatFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsHalfFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsUnsignedFormat(GraphicsFormat format);
    public static bool IsUnsignedFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsSignedFormat(GraphicsFormat format);
    public static bool IsSignedFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsNormFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsUNormFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsSNormFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsIntegerFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsUIntFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsSIntFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsXRFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
public static bool IsDXTCFormat(GraphicsFormat format);
    public static bool IsDXTCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsRGTCFormat(GraphicsFormat format);
    public static bool IsRGTCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsBPTCFormat(GraphicsFormat format);
    public static bool IsBPTCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsBCFormat(GraphicsFormat format);
    public static bool IsBCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsPVRTCFormat(GraphicsFormat format);
    public static bool IsPVRTCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsETCFormat(GraphicsFormat format);
    public static bool IsETCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsEACFormat(GraphicsFormat format);
    public static bool IsEACFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsASTCFormat(GraphicsFormat format);
    public static bool IsASTCFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static bool IsHDRFormat(GraphicsFormat format);
    [FreeFunctionAttribute]
private static bool IsHDRFormat_Native_TextureFormat(TextureFormat format);
    public static bool IsHDRFormat(TextureFormat format);
    [FreeFunctionAttribute("IsCompressedCrunchTextureFormat")]
public static bool IsCrunchFormat(TextureFormat format);
    [FreeFunctionAttribute]
public static FormatSwizzle GetSwizzleR(GraphicsFormat format);
    public static FormatSwizzle GetSwizzleR(TextureFormat format);
    [FreeFunctionAttribute]
public static FormatSwizzle GetSwizzleG(GraphicsFormat format);
    public static FormatSwizzle GetSwizzleG(TextureFormat format);
    [FreeFunctionAttribute]
public static FormatSwizzle GetSwizzleB(GraphicsFormat format);
    public static FormatSwizzle GetSwizzleB(TextureFormat format);
    [FreeFunctionAttribute]
public static FormatSwizzle GetSwizzleA(GraphicsFormat format);
    public static FormatSwizzle GetSwizzleA(TextureFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetBlockSize(GraphicsFormat format);
    public static UInt32 GetBlockSize(TextureFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetBlockWidth(GraphicsFormat format);
    public static UInt32 GetBlockWidth(TextureFormat format);
    [FreeFunctionAttribute]
public static UInt32 GetBlockHeight(GraphicsFormat format);
    public static UInt32 GetBlockHeight(TextureFormat format);
    public static UInt32 ComputeMipmapSize(int width, int height, GraphicsFormat format);
    public static UInt32 ComputeMipmapSize(int width, int height, TextureFormat format);
    [FreeFunctionAttribute]
private static UInt32 ComputeMipChainSize_Native_2D(int width, int height, GraphicsFormat format, int mipCount);
    public static UInt32 ComputeMipChainSize(int width, int height, GraphicsFormat format, int mipCount);
    public static UInt32 ComputeMipChainSize(int width, int height, TextureFormat format, int mipCount);
    public static UInt32 ComputeMipmapSize(int width, int height, int depth, GraphicsFormat format);
    public static UInt32 ComputeMipmapSize(int width, int height, int depth, TextureFormat format);
    [FreeFunctionAttribute]
private static UInt32 ComputeMipChainSize_Native_3D(int width, int height, int depth, GraphicsFormat format, int mipCount);
    public static UInt32 ComputeMipChainSize(int width, int height, int depth, GraphicsFormat format, int mipCount);
    public static UInt32 ComputeMipChainSize(int width, int height, int depth, TextureFormat format, int mipCount);
}
public enum UnityEngine.Experimental.Rendering.GraphicsJobsSyncPoint : Enum {
    public int value__;
    public static GraphicsJobsSyncPoint EndOfFrame;
    public static GraphicsJobsSyncPoint AfterScriptUpdate;
    public static GraphicsJobsSyncPoint AfterScriptLateUpdate;
    public static GraphicsJobsSyncPoint WaitForPresent;
}
public interface UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem {
    public abstract virtual bool TickRealtimeProbes();
}
public class UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure : object {
    internal IntPtr m_Ptr;
    public RayTracingAccelerationStructure(RASSettings settings);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [FreeFunctionAttribute("RayTracingAccelerationStructure_Bindings::Create")]
private static IntPtr Create(RASSettings desc);
    [FreeFunctionAttribute("RayTracingAccelerationStructure_Bindings::Destroy")]
private static void Destroy(RayTracingAccelerationStructure accelStruct);
    public void Release();
    public void Build();
    public void AddInstance(Renderer targetRenderer, RayTracingSubMeshFlags[] subMeshFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id);
    public int AddInstance(GraphicsBuffer aabbBuffer, UInt32 aabbCount, bool dynamicData, Matrix4x4 matrix, Material material, bool opaqueMaterial, MaterialPropertyBlock properties, UInt32 mask, UInt32 id);
    public void RemoveInstance(Renderer targetRenderer);
    public void RemoveInstance(int handle);
    public void UpdateInstanceTransform(Renderer renderer);
    public void UpdateInstanceTransform(int handle, Matrix4x4 matrix);
    [ObsoleteAttribute("Method Update has been deprecated. Use Build instead (UnityUpgradable) -> Build()", "True")]
public void Update();
    [ObsoleteAttribute("Method Update has been deprecated. Use Build instead (UnityUpgradable) -> Build(*)", "True")]
[FreeFunctionAttribute]
public void Update(Vector3 relativeOrigin);
    [ObsoleteAttribute("This AddInstance method has been deprecated and will be removed in a future version. Please use the alternate method for adding Renderers to the acceleration structure.", "False")]
[FreeFunctionAttribute]
public void AddInstance(Renderer targetRenderer, Boolean[] subMeshMask, Boolean[] subMeshTransparencyFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id);
    [ObsoleteAttribute("This AddInstance method has been deprecated and will be removed in a future version. Please use the alternate method for adding procedural geometry (AABBs) to the acceleration structure.", "False")]
public void AddInstance(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id);
    [ObsoleteAttribute("This AddInstance method has been deprecated and will be removed in a future version. Please use the alternate method for adding procedural geometry (AABBs) to the acceleration structure.", "False")]
public void AddInstance(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4 instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id);
    [FreeFunctionAttribute]
public void Build(Vector3 relativeOrigin);
    [FreeFunctionAttribute]
private void AddInstance_Procedural_Deprecated(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4 instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id);
    [FreeFunctionAttribute]
private int AddInstance_Procedural(GraphicsBuffer aabbBuffer, UInt32 aabbCount, bool dynamicData, Matrix4x4 matrix, Material material, bool opaqueMaterial, MaterialPropertyBlock properties, UInt32 mask, UInt32 id);
    [FreeFunctionAttribute]
private void RemoveInstance_Renderer(Renderer targetRenderer);
    [FreeFunctionAttribute]
private void RemoveInstance_InstanceID(int instanceID);
    [FreeFunctionAttribute]
private void UpdateInstanceTransform_Renderer(Renderer renderer);
    [FreeFunctionAttribute]
private void UpdateInstanceTransform_InstanceID(int instanceID, Matrix4x4 matrix);
    [FreeFunctionAttribute]
public void UpdateInstanceMask(Renderer renderer, UInt32 mask);
    [FreeFunctionAttribute]
public void UpdateInstanceID(Renderer renderer, UInt32 instanceID);
    [FreeFunctionAttribute]
public void UpdateInstancePropertyBlock(int handle, MaterialPropertyBlock properties);
    [FreeFunctionAttribute]
public ulong GetSize();
    [FreeFunctionAttribute]
public UInt32 GetInstanceCount();
    [FreeFunctionAttribute]
public void ClearInstances();
    [FreeFunctionAttribute]
public RayTracingInstanceCullingResults CullInstances(RayTracingInstanceCullingConfig& cullingConfig);
    [FreeFunctionAttribute]
private void AddInstanceSubMeshFlagsArray(Renderer targetRenderer, RayTracingSubMeshFlags[] subMeshFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id);
    private static IntPtr Create_Injected(RASSettings& desc);
    private void Update_Injected(Vector3& relativeOrigin);
    private void Build_Injected(Vector3& relativeOrigin);
    private void AddInstance_Procedural_Deprecated_Injected(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4& instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id);
    private int AddInstance_Procedural_Injected(GraphicsBuffer aabbBuffer, UInt32 aabbCount, bool dynamicData, Matrix4x4& matrix, Material material, bool opaqueMaterial, MaterialPropertyBlock properties, UInt32 mask, UInt32 id);
    private void UpdateInstanceTransform_InstanceID_Injected(int instanceID, Matrix4x4& matrix);
    private void CullInstances_Injected(RayTracingInstanceCullingConfig& cullingConfig, RayTracingInstanceCullingResults& ret);
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceCullingConfig : ValueType {
    public RayTracingInstanceCullingFlags flags;
    public Vector3 sphereCenter;
    public float sphereRadius;
    public Plane[] planes;
    public RayTracingInstanceCullingTest[] instanceTests;
    public RayTracingInstanceCullingMaterialTest materialTest;
    public RayTracingInstanceMaterialConfig transparentMaterialConfig;
    public RayTracingInstanceMaterialConfig alphaTestedMaterialConfig;
    public RayTracingSubMeshFlagsConfig subMeshFlagsConfig;
    public RayTracingInstanceTriangleCullingConfig triangleCullingConfig;
    public LODParameters lodParameters;
}
[FlagsAttribute]
public enum UnityEngine.Experimental.Rendering.RayTracingInstanceCullingFlags : Enum {
    public int value__;
    public static RayTracingInstanceCullingFlags None;
    public static RayTracingInstanceCullingFlags EnableSphereCulling;
    public static RayTracingInstanceCullingFlags EnablePlaneCulling;
    public static RayTracingInstanceCullingFlags EnableLODCulling;
    public static RayTracingInstanceCullingFlags ComputeMaterialsCRC;
    public static RayTracingInstanceCullingFlags IgnoreReflectionProbes;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceCullingMaterialTest : ValueType {
    public String[] deniedShaderPasses;
    public RayTracingInstanceCullingShaderTagConfig[] requiredShaderTags;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceCullingResults : ValueType {
    public RayTracingInstanceMaterialCRC[] materialsCRC;
    public bool transformsChanged;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceCullingShaderTagConfig : ValueType {
    public ShaderTagId tagId;
    public ShaderTagId tagValueId;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceCullingTest : ValueType {
    public UInt32 instanceMask;
    public int layerMask;
    public int shadowCastingModeMask;
    public bool allowOpaqueMaterials;
    public bool allowTransparentMaterials;
    public bool allowAlphaTestedMaterials;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceMaterialConfig : ValueType {
    public int renderQueueLowerBound;
    public int renderQueueUpperBound;
    public RayTracingInstanceCullingShaderTagConfig[] optionalShaderTags;
    public String[] optionalShaderKeywords;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceMaterialCRC : ValueType {
    public int instanceID;
    public int crc;
}
public class UnityEngine.Experimental.Rendering.RayTracingInstanceTriangleCullingConfig : ValueType {
    public String[] optionalDoubleSidedShaderKeywords;
    public bool frontTriangleCounterClockwise;
    public bool checkDoubleSidedGIMaterial;
    public bool forceDoubleSided;
}
public enum UnityEngine.Experimental.Rendering.RayTracingMode : Enum {
    public int value__;
    public static RayTracingMode Off;
    public static RayTracingMode Static;
    public static RayTracingMode DynamicTransform;
    public static RayTracingMode DynamicGeometry;
}
[NativeHeaderAttribute("Runtime/Shaders/RayTracingAccelerationStructure.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/RayTracingShader.h")]
public class UnityEngine.Experimental.Rendering.RayTracingShader : Object {
    public float maxRecursionDepth { get; }
    public float get_maxRecursionDepth();
    [FreeFunctionAttribute]
public void SetFloat(int nameID, float val);
    [FreeFunctionAttribute]
public void SetInt(int nameID, int val);
    [FreeFunctionAttribute]
public void SetVector(int nameID, Vector4 val);
    [FreeFunctionAttribute]
public void SetMatrix(int nameID, Matrix4x4 val);
    [FreeFunctionAttribute]
private void SetFloatArray(int nameID, Single[] values);
    [FreeFunctionAttribute]
private void SetIntArray(int nameID, Int32[] values);
    [FreeFunctionAttribute]
public void SetVectorArray(int nameID, Vector4[] values);
    [FreeFunctionAttribute]
public void SetMatrixArray(int nameID, Matrix4x4[] values);
    [NativeMethodAttribute]
public void SetTexture(int nameID, Texture texture);
    [NativeMethodAttribute]
public void SetBuffer(int nameID, ComputeBuffer buffer);
    [NativeMethodAttribute]
private void SetGraphicsBuffer(int nameID, GraphicsBuffer buffer);
    [FreeFunctionAttribute]
private void SetConstantComputeBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
    [FreeFunctionAttribute]
private void SetConstantGraphicsBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
    [NativeMethodAttribute]
public void SetAccelerationStructure(int nameID, RayTracingAccelerationStructure accelerationStructure);
    public void SetShaderPass(string passName);
    [NativeMethodAttribute]
public void SetTextureFromGlobal(int nameID, int globalTextureNameID);
    [NativeNameAttribute("DispatchRays")]
public void Dispatch(string rayGenFunctionName, int width, int height, int depth, Camera camera);
    public void SetBuffer(int nameID, GraphicsBuffer buffer);
    public void SetFloat(string name, float val);
    public void SetInt(string name, int val);
    public void SetVector(string name, Vector4 val);
    public void SetMatrix(string name, Matrix4x4 val);
    public void SetVectorArray(string name, Vector4[] values);
    public void SetMatrixArray(string name, Matrix4x4[] values);
    public void SetFloats(string name, Single[] values);
    public void SetFloats(int nameID, Single[] values);
    public void SetInts(string name, Int32[] values);
    public void SetInts(int nameID, Int32[] values);
    public void SetBool(string name, bool val);
    public void SetBool(int nameID, bool val);
    public void SetTexture(string name, Texture texture);
    public void SetBuffer(string name, ComputeBuffer buffer);
    public void SetBuffer(string name, GraphicsBuffer buffer);
    public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size);
    public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size);
    public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size);
    public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size);
    public void SetAccelerationStructure(string name, RayTracingAccelerationStructure accelerationStructure);
    public void SetTextureFromGlobal(string name, string globalTextureName);
    private void SetVector_Injected(int nameID, Vector4& val);
    private void SetMatrix_Injected(int nameID, Matrix4x4& val);
}
[NativeHeaderAttribute("Runtime/Export/Graphics/RayTracingAccelerationStructure.bindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/RayTracingAccelerationStructure.h")]
[UsedByNativeCodeAttribute]
[FlagsAttribute]
public enum UnityEngine.Experimental.Rendering.RayTracingSubMeshFlags : Enum {
    public int value__;
    public static RayTracingSubMeshFlags Disabled;
    public static RayTracingSubMeshFlags Enabled;
    public static RayTracingSubMeshFlags ClosestHitOnly;
    public static RayTracingSubMeshFlags UniqueAnyHitCalls;
}
public class UnityEngine.Experimental.Rendering.RayTracingSubMeshFlagsConfig : ValueType {
    public RayTracingSubMeshFlags opaqueMaterials;
    public RayTracingSubMeshFlags transparentMaterials;
    public RayTracingSubMeshFlags alphaTestedMaterials;
}
public abstract class UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystem : object {
    public virtual bool TickRealtimeProbes();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.IDisposable.Dispose();
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Camera/ScriptableRuntimeReflectionSystem.h")]
public static class UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystemSettings : object {
    private static ScriptableRuntimeReflectionSystemWrapper s_Instance;
    public static IScriptableRuntimeReflectionSystem system { get; public set; }
    private static IScriptableRuntimeReflectionSystem Internal_ScriptableRuntimeReflectionSystemSettings_system { get; private set; }
    private static ScriptableRuntimeReflectionSystemWrapper Internal_ScriptableRuntimeReflectionSystemSettings_instance { get; }
    private static ScriptableRuntimeReflectionSystemSettings();
    public static IScriptableRuntimeReflectionSystem get_system();
    public static void set_system(IScriptableRuntimeReflectionSystem value);
    private static IScriptableRuntimeReflectionSystem get_Internal_ScriptableRuntimeReflectionSystemSettings_system();
    [RequiredByNativeCodeAttribute]
private static void set_Internal_ScriptableRuntimeReflectionSystemSettings_system(IScriptableRuntimeReflectionSystem value);
    [RequiredByNativeCodeAttribute]
private static ScriptableRuntimeReflectionSystemWrapper get_Internal_ScriptableRuntimeReflectionSystemSettings_instance();
    [StaticAccessorAttribute("ScriptableRuntimeReflectionSystem", "2")]
[RuntimeInitializeOnLoadMethodAttribute("0")]
private static void ScriptingDirtyReflectionSystemInstance();
}
[RequiredByNativeCodeAttribute]
internal class UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystemWrapper : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private IScriptableRuntimeReflectionSystem <implementation>k__BackingField;
    internal IScriptableRuntimeReflectionSystem implementation { get; internal set; }
    [CompilerGeneratedAttribute]
internal IScriptableRuntimeReflectionSystem get_implementation();
    [CompilerGeneratedAttribute]
internal void set_implementation(IScriptableRuntimeReflectionSystem value);
    [RequiredByNativeCodeAttribute]
private void Internal_ScriptableRuntimeReflectionSystemWrapper_TickRealtimeProbes(Boolean& result);
}
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
public static class UnityEngine.Experimental.Rendering.ShaderWarmup : object {
    [FreeFunctionAttribute]
public static void WarmupShader(Shader shader, ShaderWarmupSetup setup);
    [FreeFunctionAttribute]
public static void WarmupShaderFromCollection(ShaderVariantCollection collection, Shader shader, ShaderWarmupSetup setup);
    private static void WarmupShader_Injected(Shader shader, ShaderWarmupSetup& setup);
    private static void WarmupShaderFromCollection_Injected(ShaderVariantCollection collection, Shader shader, ShaderWarmupSetup& setup);
}
public class UnityEngine.Experimental.Rendering.ShaderWarmupSetup : ValueType {
    public VertexAttributeDescriptor[] vdecl;
}
[FlagsAttribute]
public enum UnityEngine.Experimental.Rendering.TextureCreationFlags : Enum {
    public int value__;
    public static TextureCreationFlags None;
    public static TextureCreationFlags MipChain;
    public static TextureCreationFlags DontInitializePixels;
    public static TextureCreationFlags Crunch;
    public static TextureCreationFlags DontUploadUponCreate;
    public static TextureCreationFlags IgnoreMipmapLimit;
}
public enum UnityEngine.Experimental.Rendering.WaitForPresentSyncPoint : Enum {
    public int value__;
    public static WaitForPresentSyncPoint BeginFrame;
    public static WaitForPresentSyncPoint EndFrame;
}
[NativeHeaderAttribute("Runtime/2D/Renderer/SpriteRendererGroup.h")]
[RequiredByNativeCodeAttribute]
internal class UnityEngine.Experimental.U2D.SpriteIntermediateRendererInfo : ValueType {
    public int SpriteID;
    public int TextureID;
    public int MaterialID;
    public Color Color;
    public Matrix4x4 Transform;
    public Bounds Bounds;
    public int Layer;
    public int SortingLayer;
    public int SortingOrder;
    public ulong SceneCullingMask;
    public IntPtr IndexData;
    public IntPtr VertexData;
    public int IndexCount;
    public int VertexCount;
    public int ShaderChannelMask;
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/2D/Renderer/SpriteRendererGroup.h")]
internal class UnityEngine.Experimental.U2D.SpriteRendererGroup : object {
    public static void AddRenderers(NativeArray`1<SpriteIntermediateRendererInfo> renderers);
    private static void AddRenderers(Void* renderers, int count);
    public static void Clear();
}
[NativeHeaderAttribute("Runtime/Utilities/PropertyName.h")]
[NativeHeaderAttribute("Runtime/Director/Core/ExposedPropertyTable.bindings.h")]
public class UnityEngine.ExposedPropertyResolver : ValueType {
    internal IntPtr table;
    internal static Object ResolveReferenceInternal(IntPtr ptr, PropertyName name, Boolean& isValid);
    [FreeFunctionAttribute("ExposedPropertyTableBindings::ResolveReferenceInternal")]
private static Object ResolveReferenceBindingsInternal(IntPtr ptr, PropertyName name, Boolean& isValid);
    private static Object ResolveReferenceBindingsInternal_Injected(IntPtr ptr, PropertyName& name, Boolean& isValid);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ExposedReference`1 : ValueType {
    [SerializeField]
public PropertyName exposedName;
    [SerializeField]
public Object defaultValue;
    public T Resolve(IExposedPropertyTable resolver);
}
[MovedFromAttribute("True", "UnityEditor", "UnityEditor", "")]
public class UnityEngine.ExpressionEvaluator : object {
    private static PcgRandom s_Random;
    private static Dictionary`2<string, Operator> s_Operators;
    private static ExpressionEvaluator();
    public static bool Evaluate(string expression, T& value);
    internal static bool Evaluate(string expression, T& value, Expression& delayed);
    internal static void SetRandomState(UInt32 state);
    private static bool EvaluateTokens(String[] tokens, T& value, int index, int count);
    private static bool EvaluateDouble(String[] tokens, Double& value, int index, int count);
    private static String[] InfixToRPN(String[] tokens);
    private static bool NeedToPop(Stack`1<string> operatorStack, Operator newOperator);
    private static String[] ExpressionToTokens(string expression, Boolean& hasVariables);
    private static bool IsCommand(string token);
    private static bool IsVariable(string token);
    private static bool IsDelayedFunction(string token);
    private static bool IsOperator(string token);
    private static Operator TokenToOperator(string token);
    private static string PreFormatExpression(string expression);
    private static String[] FixUnaryOperators(String[] tokens);
    private static double EvaluateOp(Double[] values, Op op, int index, int count);
    private static bool TryParse(string expression, T& result);
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("1028")]
internal class UnityEngine.ExtensionOfNativeClassAttribute : Attribute {
}
[ExcludeFromObjectFactoryAttribute]
[NativeClassAttribute("")]
[RequiredByNativeCodeAttribute]
internal class UnityEngine.FailedToLoadScriptObject : Object {
}
public enum UnityEngine.FilterMode : Enum {
    public int value__;
    public static FilterMode Point;
    public static FilterMode Bilinear;
    public static FilterMode Trilinear;
}
public enum UnityEngine.FindObjectsInactive : Enum {
    public int value__;
    public static FindObjectsInactive Exclude;
    public static FindObjectsInactive Include;
}
public enum UnityEngine.FindObjectsSortMode : Enum {
    public int value__;
    public static FindObjectsSortMode None;
    public static FindObjectsSortMode InstanceID;
}
[NativeHeaderAttribute("Runtime/Camera/Flare.h")]
public class UnityEngine.Flare : Object {
    private static void Internal_Create(Flare self);
}
[RequireComponent("UnityEngine.Camera")]
public class UnityEngine.FlareLayer : Behaviour {
}
public enum UnityEngine.FogMode : Enum {
    public int value__;
    public static FogMode Linear;
    public static FogMode Exponential;
    public static FogMode ExponentialSquared;
}
[StaticAccessorAttribute("FrameDebugger", "2")]
[NativeHeaderAttribute("Runtime/Profiler/PerformanceTools/FrameDebugger.h")]
public static class UnityEngine.FrameDebugger : object {
    public static bool enabled { get; }
    public static bool get_enabled();
    internal static bool IsLocalEnabled();
    internal static bool IsRemoteEnabled();
}
[NativeHeaderAttribute("Runtime/GfxDevice/FrameTiming.h")]
public class UnityEngine.FrameTiming : ValueType {
    [NativeNameAttribute("totalFrameTime")]
public double cpuFrameTime;
    [NativeNameAttribute("mainThreadActiveTime")]
public double cpuMainThreadFrameTime;
    [NativeNameAttribute("mainThreadPresentWaitTime")]
public double cpuMainThreadPresentWaitTime;
    [NativeNameAttribute("renderThreadActiveTime")]
public double cpuRenderThreadFrameTime;
    [NativeNameAttribute("gpuFrameTime")]
public double gpuFrameTime;
    [NativeNameAttribute("frameStartTimestamp")]
public ulong frameStartTimestamp;
    [NativeNameAttribute("firstSubmitTimestamp")]
public ulong firstSubmitTimestamp;
    [NativeNameAttribute("presentFrameTimestamp")]
public ulong cpuTimePresentCalled;
    [NativeNameAttribute("frameCompleteTimestamp")]
public ulong cpuTimeFrameComplete;
    [NativeNameAttribute("heightScale")]
public float heightScale;
    [NativeNameAttribute("widthScale")]
public float widthScale;
    [NativeNameAttribute("syncInterval")]
public UInt32 syncInterval;
}
[StaticAccessorAttribute("GetUncheckedRealGfxDevice().GetFrameTimingManager()", "0")]
public static class UnityEngine.FrameTimingManager : object {
    [StaticAccessorAttribute("FrameTimingManager", "2")]
public static bool IsFeatureEnabled();
    public static void CaptureFrameTimings();
    public static UInt32 GetLatestTimings(UInt32 numFrames, FrameTiming[] timings);
    public static float GetVSyncsPerSecond();
    public static ulong GetGpuTimerFrequency();
    public static ulong GetCpuTimerFrequency();
}
public class UnityEngine.FrustumPlanes : ValueType {
    public float left;
    public float right;
    public float bottom;
    public float top;
    public float zNear;
    public float zFar;
}
public enum UnityEngine.FullScreenMode : Enum {
    public int value__;
    public static FullScreenMode ExclusiveFullScreen;
    public static FullScreenMode FullScreenWindow;
    public static FullScreenMode MaximizedWindow;
    public static FullScreenMode Windowed;
}
[NativeHeaderAttribute("Runtime/Export/Scripting/GameObject.bindings.h")]
[UsedByNativeCodeAttribute]
[ExcludeFromPresetAttribute]
public class UnityEngine.GameObject : Object {
    public Transform transform { get; }
    public int layer { get; public set; }
    [ObsoleteAttribute("GameObject.active is obsolete. Use GameObject.SetActive(), GameObject.activeSelf or GameObject.activeInHierarchy.")]
public bool active { get; public set; }
    public bool activeSelf { get; }
    public bool activeInHierarchy { get; }
    public bool isStatic { get; public set; }
    internal bool isStaticBatchable { get; }
    public string tag { get; public set; }
    public Scene scene { get; }
    public ulong sceneCullingMask { get; }
    public GameObject gameObject { get; }
    public GameObject(string name);
    public GameObject(string name, Type[] components);
    [FreeFunctionAttribute("GameObjectBindings::CreatePrimitive")]
public static GameObject CreatePrimitive(PrimitiveType type);
    [SecuritySafeCriticalAttribute]
public T GetComponent();
    [FreeFunctionAttribute]
[TypeInferenceRuleAttribute("0")]
public Component GetComponent(Type type);
    [NativeWritableSelfAttribute]
[FreeFunctionAttribute]
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue);
    [FreeFunctionAttribute]
internal Component GetComponentByName(string type);
    [FreeFunctionAttribute]
internal Component GetComponentByNameWithCase(string type, bool caseSensitive);
    public Component GetComponent(string type);
    [TypeInferenceRuleAttribute("0")]
[FreeFunctionAttribute]
public Component GetComponentInChildren(Type type, bool includeInactive);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInChildren(Type type);
    [ExcludeFromDocsAttribute]
public T GetComponentInChildren();
    public T GetComponentInChildren(bool includeInactive);
    [TypeInferenceRuleAttribute("0")]
[FreeFunctionAttribute]
public Component GetComponentInParent(Type type, bool includeInactive);
    [TypeInferenceRuleAttribute("0")]
public Component GetComponentInParent(Type type);
    [ExcludeFromDocsAttribute]
public T GetComponentInParent();
    public T GetComponentInParent(bool includeInactive);
    [FreeFunctionAttribute]
private Array GetComponentsInternal(Type type, bool useSearchTypeAsArrayReturnType, bool recursive, bool includeInactive, bool reverse, object resultList);
    public Component[] GetComponents(Type type);
    public T[] GetComponents();
    public void GetComponents(Type type, List`1<Component> results);
    public void GetComponents(List`1<T> results);
    [ExcludeFromDocsAttribute]
public Component[] GetComponentsInChildren(Type type);
    public Component[] GetComponentsInChildren(Type type, bool includeInactive);
    public T[] GetComponentsInChildren(bool includeInactive);
    public void GetComponentsInChildren(bool includeInactive, List`1<T> results);
    public T[] GetComponentsInChildren();
    public void GetComponentsInChildren(List`1<T> results);
    [ExcludeFromDocsAttribute]
public Component[] GetComponentsInParent(Type type);
    public Component[] GetComponentsInParent(Type type, bool includeInactive);
    public void GetComponentsInParent(bool includeInactive, List`1<T> results);
    public T[] GetComponentsInParent(bool includeInactive);
    public T[] GetComponentsInParent();
    [SecuritySafeCriticalAttribute]
public bool TryGetComponent(T& component);
    public bool TryGetComponent(Type type, Component& component);
    [FreeFunctionAttribute]
[TypeInferenceRuleAttribute("0")]
internal Component TryGetComponentInternal(Type type);
    [NativeWritableSelfAttribute]
[FreeFunctionAttribute]
internal void TryGetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue);
    public static GameObject FindWithTag(string tag);
    public void SendMessageUpwards(string methodName, SendMessageOptions options);
    public void SendMessage(string methodName, SendMessageOptions options);
    public void BroadcastMessage(string methodName, SendMessageOptions options);
    [FreeFunctionAttribute]
internal Component AddComponentInternal(string className);
    [FreeFunctionAttribute]
private Component Internal_AddComponentWithType(Type componentType);
    [TypeInferenceRuleAttribute("0")]
public Component AddComponent(Type componentType);
    public T AddComponent();
    public int GetComponentCount();
    [NativeNameAttribute("QueryComponentAtIndex<Unity::Component>")]
internal Component QueryComponentAtIndex(int index);
    public Component GetComponentAtIndex(int index);
    public T GetComponentAtIndex(int index);
    public int GetComponentIndex(Component component);
    [FreeFunctionAttribute("GameObjectBindings::GetTransform")]
public Transform get_transform();
    public int get_layer();
    public void set_layer(int value);
    [NativeMethodAttribute]
public bool get_active();
    [NativeMethodAttribute]
public void set_active(bool value);
    [NativeMethodAttribute]
public void SetActive(bool value);
    [NativeMethodAttribute]
public bool get_activeSelf();
    [NativeMethodAttribute]
public bool get_activeInHierarchy();
    [NativeMethodAttribute]
[ObsoleteAttribute("gameObject.SetActiveRecursively() is obsolete. Use GameObject.SetActive(), which is now inherited by children.")]
public void SetActiveRecursively(bool state);
    [NativeMethodAttribute]
public bool get_isStatic();
    [NativeMethodAttribute]
public void set_isStatic(bool value);
    [NativeMethodAttribute]
internal bool get_isStaticBatchable();
    [FreeFunctionAttribute("GameObjectBindings::GetTag")]
public string get_tag();
    [FreeFunctionAttribute("GameObjectBindings::SetTag")]
public void set_tag(string value);
    [FreeFunctionAttribute]
public bool CompareTag(string tag);
    [FreeFunctionAttribute]
public static GameObject FindGameObjectWithTag(string tag);
    [FreeFunctionAttribute]
public static GameObject[] FindGameObjectsWithTag(string tag);
    [FreeFunctionAttribute]
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options);
    [ExcludeFromDocsAttribute]
public void SendMessageUpwards(string methodName, object value);
    [ExcludeFromDocsAttribute]
public void SendMessageUpwards(string methodName);
    [FreeFunctionAttribute]
public void SendMessage(string methodName, object value, SendMessageOptions options);
    [ExcludeFromDocsAttribute]
public void SendMessage(string methodName, object value);
    [ExcludeFromDocsAttribute]
public void SendMessage(string methodName);
    [FreeFunctionAttribute]
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options);
    [ExcludeFromDocsAttribute]
public void BroadcastMessage(string methodName, object parameter);
    [ExcludeFromDocsAttribute]
public void BroadcastMessage(string methodName);
    [FreeFunctionAttribute]
private static void Internal_CreateGameObject(GameObject self, string name);
    [FreeFunctionAttribute]
public static GameObject Find(string name);
    [FreeFunctionAttribute]
private static void SetGameObjectsActive(IntPtr instanceIds, int instanceCount, bool active);
    public static void SetGameObjectsActive(NativeArray`1<int> instanceIDs, bool active);
    public static void SetGameObjectsActive(ReadOnlySpan`1<int> instanceIDs, bool active);
    [FreeFunctionAttribute("GameObjectBindings::InstantiateGameObjectsByInstanceID")]
private static void InstantiateGameObjects(int sourceInstanceID, IntPtr newInstanceIDs, IntPtr newTransformInstanceIDs, int count, Scene destinationScene);
    public static void InstantiateGameObjects(int sourceInstanceID, int count, NativeArray`1<int> newInstanceIDs, NativeArray`1<int> newTransformInstanceIDs, Scene destinationScene);
    [FreeFunctionAttribute]
public static Scene GetScene(int instanceID);
    [FreeFunctionAttribute("GameObjectBindings::GetScene")]
public Scene get_scene();
    [FreeFunctionAttribute]
public ulong get_sceneCullingMask();
    public GameObject get_gameObject();
    private static void InstantiateGameObjects_Injected(int sourceInstanceID, IntPtr newInstanceIDs, IntPtr newTransformInstanceIDs, int count, Scene& destinationScene);
    private static void GetScene_Injected(int instanceID, Scene& ret);
    private void get_scene_Injected(Scene& ret);
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[StaticAccessorAttribute("GeometryUtilityScripting", "2")]
public class UnityEngine.GeometryUtility : object {
    public static Plane[] CalculateFrustumPlanes(Camera camera);
    public static Plane[] CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix);
    public static void CalculateFrustumPlanes(Camera camera, Plane[] planes);
    public static void CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix, Plane[] planes);
    public static Bounds CalculateBounds(Vector3[] positions, Matrix4x4 transform);
    public static bool TryCreatePlaneFromPolygon(Vector3[] vertices, Plane& plane);
    public static bool TestPlanesAABB(Plane[] planes, Bounds bounds);
    [NativeNameAttribute("ExtractPlanes")]
private static void Internal_ExtractPlanes(Plane[] planes, Matrix4x4 worldToProjectionMatrix);
    [NativeNameAttribute("CalculateBounds")]
private static Bounds Internal_CalculateBounds(Vector3[] positions, Matrix4x4 transform);
    private static bool TestPlanesAABB_Injected(Plane[] planes, Bounds& bounds);
    private static void Internal_ExtractPlanes_Injected(Plane[] planes, Matrix4x4& worldToProjectionMatrix);
    private static void Internal_CalculateBounds_Injected(Vector3[] positions, Matrix4x4& transform, Bounds& ret);
}
[NativeHeaderAttribute("Runtime/Export/Gizmos/Gizmos.bindings.h")]
[StaticAccessorAttribute("GizmoBindings", "2")]
public class UnityEngine.Gizmos : object {
    public static Color color { get; public set; }
    public static Matrix4x4 matrix { get; public set; }
    public static Texture exposure { get; public set; }
    public static float probeSize { get; }
    [NativeThrowsAttribute]
public static void DrawLine(Vector3 from, Vector3 to);
    [NativeThrowsAttribute]
internal static void DrawLineStrip(Vector3* points, int count, bool looped);
    public static void DrawLineStrip(ReadOnlySpan`1<Vector3> points, bool looped);
    [NativeThrowsAttribute]
internal static void DrawLineList(Vector3* points, int count);
    public static void DrawLineList(ReadOnlySpan`1<Vector3> points);
    [NativeThrowsAttribute]
public static void DrawWireSphere(Vector3 center, float radius);
    [NativeThrowsAttribute]
public static void DrawSphere(Vector3 center, float radius);
    [NativeThrowsAttribute]
public static void DrawWireCube(Vector3 center, Vector3 size);
    [NativeThrowsAttribute]
public static void DrawCube(Vector3 center, Vector3 size);
    [NativeThrowsAttribute]
public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale);
    [NativeThrowsAttribute]
public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale);
    [NativeThrowsAttribute]
public static void DrawIcon(Vector3 center, string name, bool allowScaling);
    [NativeThrowsAttribute]
public static void DrawIcon(Vector3 center, string name, bool allowScaling, Color tint);
    [NativeThrowsAttribute]
public static void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
    public static Color get_color();
    public static void set_color(Color value);
    public static Matrix4x4 get_matrix();
    public static void set_matrix(Matrix4x4 value);
    public static Texture get_exposure();
    public static void set_exposure(Texture value);
    public static float get_probeSize();
    public static void DrawFrustum(Vector3 center, float fov, float maxRange, float minRange, float aspect);
    public static void DrawRay(Ray r);
    public static void DrawRay(Vector3 from, Vector3 direction);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh);
    public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, int submeshIndex);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh, Vector3 position);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh);
    public static void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position);
    [ExcludeFromDocsAttribute]
public static void DrawWireMesh(Mesh mesh, int submeshIndex);
    [ExcludeFromDocsAttribute]
public static void DrawIcon(Vector3 center, string name);
    [ExcludeFromDocsAttribute]
public static void DrawGUITexture(Rect screenRect, Texture texture);
    public static void DrawGUITexture(Rect screenRect, Texture texture, Material mat);
    [ExcludeFromDocsAttribute]
public static void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
    private static void DrawLine_Injected(Vector3& from, Vector3& to);
    private static void DrawWireSphere_Injected(Vector3& center, float radius);
    private static void DrawSphere_Injected(Vector3& center, float radius);
    private static void DrawWireCube_Injected(Vector3& center, Vector3& size);
    private static void DrawCube_Injected(Vector3& center, Vector3& size);
    private static void DrawMesh_Injected(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale);
    private static void DrawWireMesh_Injected(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale);
    private static void DrawIcon_Injected(Vector3& center, string name, bool allowScaling, Color& tint);
    private static void DrawGUITexture_Injected(Rect& screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
    private static void get_color_Injected(Color& ret);
    private static void set_color_Injected(Color& value);
    private static void get_matrix_Injected(Matrix4x4& ret);
    private static void set_matrix_Injected(Matrix4x4& value);
    private static void DrawFrustum_Injected(Vector3& center, float fov, float maxRange, float minRange, float aspect);
}
[NativeHeaderAttribute("Runtime/Camera/CameraUtil.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[StaticAccessorAttribute("GetGfxDevice()", "0")]
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDevice.h")]
[NativeHeaderAttribute("Runtime/Camera/Camera.h")]
public class UnityEngine.GL : object {
    public static int TRIANGLES;
    public static int TRIANGLE_STRIP;
    public static int QUADS;
    public static int LINES;
    public static int LINE_STRIP;
    public static bool wireframe { get; public set; }
    public static bool sRGBWrite { get; public set; }
    [NativePropertyAttribute("UserBackfaceMode")]
public static bool invertCulling { get; public set; }
    public static Matrix4x4 modelview { get; public set; }
    [NativeNameAttribute("ImmediateVertex")]
public static void Vertex3(float x, float y, float z);
    public static void Vertex(Vector3 v);
    [NativeNameAttribute("ImmediateVertices")]
internal static void Vertices(Vector3* v, Vector3* coords, Vector4* colors, int length);
    [NativeNameAttribute("ImmediateTexCoordAll")]
public static void TexCoord3(float x, float y, float z);
    public static void TexCoord(Vector3 v);
    public static void TexCoord2(float x, float y);
    [NativeNameAttribute("ImmediateTexCoord")]
public static void MultiTexCoord3(int unit, float x, float y, float z);
    public static void MultiTexCoord(int unit, Vector3 v);
    public static void MultiTexCoord2(int unit, float x, float y);
    [NativeNameAttribute("ImmediateColor")]
private static void ImmediateColor(float r, float g, float b, float a);
    public static void Color(Color c);
    public static bool get_wireframe();
    public static void set_wireframe(bool value);
    public static bool get_sRGBWrite();
    public static void set_sRGBWrite(bool value);
    public static bool get_invertCulling();
    public static void set_invertCulling(bool value);
    public static void Flush();
    public static void RenderTargetBarrier();
    private static Matrix4x4 GetWorldViewMatrix();
    private static void SetViewMatrix(Matrix4x4 m);
    public static Matrix4x4 get_modelview();
    public static void set_modelview(Matrix4x4 value);
    [NativeNameAttribute("SetWorldMatrix")]
public static void MultMatrix(Matrix4x4 m);
    [NativeNameAttribute("InsertCustomMarker")]
[ObsoleteAttribute("IssuePluginEvent(eventID) is deprecated. Use IssuePluginEvent(callback, eventID) instead.", "False")]
public static void IssuePluginEvent(int eventID);
    [ObsoleteAttribute("SetRevertBackfacing(revertBackFaces) is deprecated. Use invertCulling property instead. (UnityUpgradable) -> invertCulling", "False")]
[NativeNameAttribute("SetUserBackfaceMode")]
public static void SetRevertBackfacing(bool revertBackFaces);
    [FreeFunctionAttribute("GLPushMatrixScript")]
public static void PushMatrix();
    [FreeFunctionAttribute("GLPopMatrixScript")]
public static void PopMatrix();
    [FreeFunctionAttribute("GLLoadIdentityScript")]
public static void LoadIdentity();
    [FreeFunctionAttribute("GLLoadOrthoScript")]
public static void LoadOrtho();
    [FreeFunctionAttribute("GLLoadPixelMatrixScript")]
public static void LoadPixelMatrix();
    [FreeFunctionAttribute("GLLoadProjectionMatrixScript")]
public static void LoadProjectionMatrix(Matrix4x4 mat);
    [FreeFunctionAttribute("GLInvalidateState")]
public static void InvalidateState();
    [FreeFunctionAttribute("GLGetGPUProjectionMatrix")]
public static Matrix4x4 GetGPUProjectionMatrix(Matrix4x4 proj, bool renderIntoTexture);
    [FreeFunctionAttribute]
private static void GLLoadPixelMatrixScript(float left, float right, float bottom, float top);
    public static void LoadPixelMatrix(float left, float right, float bottom, float top);
    [FreeFunctionAttribute]
private static void GLIssuePluginEvent(IntPtr callback, int eventID);
    public static void IssuePluginEvent(IntPtr callback, int eventID);
    [FreeFunctionAttribute("GLBegin")]
public static void Begin(int mode);
    [FreeFunctionAttribute("GLEnd")]
public static void End();
    [FreeFunctionAttribute]
private static void GLClear(bool clearDepth, bool clearColor, Color backgroundColor, float depth);
    public static void Clear(bool clearDepth, bool clearColor, Color backgroundColor, float depth);
    public static void Clear(bool clearDepth, bool clearColor, Color backgroundColor);
    [FreeFunctionAttribute("SetGLViewport")]
public static void Viewport(Rect pixelRect);
    [FreeFunctionAttribute("ClearWithSkybox")]
public static void ClearWithSkybox(bool clearDepth, Camera camera);
    private static void GetWorldViewMatrix_Injected(Matrix4x4& ret);
    private static void SetViewMatrix_Injected(Matrix4x4& m);
    private static void MultMatrix_Injected(Matrix4x4& m);
    private static void LoadProjectionMatrix_Injected(Matrix4x4& mat);
    private static void GetGPUProjectionMatrix_Injected(Matrix4x4& proj, bool renderIntoTexture, Matrix4x4& ret);
    private static void GLClear_Injected(bool clearDepth, bool clearColor, Color& backgroundColor, float depth);
    private static void Viewport_Injected(Rect& pixelRect);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Math/Gradient.bindings.h")]
public class UnityEngine.Gradient : object {
    internal IntPtr m_Ptr;
    public GradientColorKey[] colorKeys { get; public set; }
    public GradientAlphaKey[] alphaKeys { get; public set; }
    [NativePropertyAttribute]
public GradientMode mode { get; public set; }
    [NativePropertyAttribute]
public ColorSpace colorSpace { get; public set; }
    [FreeFunctionAttribute]
private static IntPtr Init();
    [FreeFunctionAttribute]
private void Cleanup();
    [FreeFunctionAttribute("Gradient_Bindings::Internal_Equals")]
private bool Internal_Equals(IntPtr other);
    protected virtual override void Finalize();
    [FreeFunctionAttribute]
public Color Evaluate(float time);
    [FreeFunctionAttribute("Gradient_Bindings::GetColorKeys")]
public GradientColorKey[] get_colorKeys();
    [FreeFunctionAttribute("Gradient_Bindings::SetColorKeys")]
public void set_colorKeys(GradientColorKey[] value);
    [FreeFunctionAttribute("Gradient_Bindings::GetAlphaKeys")]
public GradientAlphaKey[] get_alphaKeys();
    [FreeFunctionAttribute("Gradient_Bindings::SetAlphaKeys")]
public void set_alphaKeys(GradientAlphaKey[] value);
    public GradientMode get_mode();
    public void set_mode(GradientMode value);
    public ColorSpace get_colorSpace();
    public void set_colorSpace(ColorSpace value);
    [FreeFunctionAttribute]
public void SetKeys(GradientColorKey[] colorKeys, GradientAlphaKey[] alphaKeys);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Gradient other);
    public virtual int GetHashCode();
    private void Evaluate_Injected(float time, Color& ret);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.GradientAlphaKey : ValueType {
    public float alpha;
    public float time;
    public GradientAlphaKey(float alpha, float time);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.GradientColorKey : ValueType {
    public Color color;
    public float time;
    public GradientColorKey(Color col, float time);
}
public enum UnityEngine.GradientMode : Enum {
    public int value__;
    public static GradientMode Blend;
    public static GradientMode Fixed;
    public static GradientMode PerceptualBlend;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.GradientUsageAttribute : PropertyAttribute {
    public bool hdr;
    public ColorSpace colorSpace;
    public GradientUsageAttribute(bool hdr);
    public GradientUsageAttribute(bool hdr, ColorSpace colorSpace);
}
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
[NativeHeaderAttribute("Runtime/Misc/PlayerSettings.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/CopyTexture.h")]
[NativeHeaderAttribute("Runtime/Graphics/ColorGamut.h")]
[NativeHeaderAttribute("Runtime/Camera/LightProbeProxyVolume.h")]
public class UnityEngine.Graphics : object {
    internal static int kMaxDrawMeshInstanceCount;
    internal static Dictionary`2<int, RenderInstancedDataLayout> s_RenderInstancedDataLayouts;
    public static ColorGamut activeColorGamut { get; }
    [StaticAccessorAttribute("GetGfxDevice()", "0")]
public static GraphicsTier activeTier { get; public set; }
    public static bool preserveFramebufferAlpha { get; }
    public static OpenGLESVersion minOpenGLESVersion { get; }
    public static RenderBuffer activeColorBuffer { get; }
    public static RenderBuffer activeDepthBuffer { get; }
    private static Graphics();
    [FreeFunctionAttribute("GraphicsScripting::GetMaxDrawMeshInstanceCount")]
private static int Internal_GetMaxDrawMeshInstanceCount();
    [FreeFunctionAttribute]
private static ColorGamut GetActiveColorGamut();
    public static ColorGamut get_activeColorGamut();
    public static GraphicsTier get_activeTier();
    public static void set_activeTier(GraphicsTier value);
    [StaticAccessorAttribute("GetPlayerSettings()", "0")]
[NativeMethodAttribute]
internal static bool GetPreserveFramebufferAlpha();
    public static bool get_preserveFramebufferAlpha();
    [NativeMethodAttribute]
[StaticAccessorAttribute("GetPlayerSettings()", "0")]
internal static OpenGLESVersion GetMinOpenGLESVersion();
    public static OpenGLESVersion get_minOpenGLESVersion();
    [FreeFunctionAttribute("GraphicsScripting::GetActiveColorBuffer")]
private static RenderBuffer GetActiveColorBuffer();
    [FreeFunctionAttribute("GraphicsScripting::GetActiveDepthBuffer")]
private static RenderBuffer GetActiveDepthBuffer();
    [FreeFunctionAttribute("GraphicsScripting::SetNullRT")]
private static void Internal_SetNullRT();
    [NativeMethodAttribute]
private static void Internal_SetRTSimple(RenderBuffer color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice);
    [NativeMethodAttribute]
private static void Internal_SetMRTSimple(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice);
    [NativeMethodAttribute]
private static void Internal_SetMRTFullSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice, RenderBufferLoadAction[] colorLA, RenderBufferStoreAction[] colorSA, RenderBufferLoadAction depthLA, RenderBufferStoreAction depthSA);
    [NativeMethodAttribute]
private static void Internal_SetRandomWriteTargetRT(int index, RenderTexture uav);
    [FreeFunctionAttribute("GraphicsScripting::SetRandomWriteTargetBuffer")]
private static void Internal_SetRandomWriteTargetBuffer(int index, ComputeBuffer uav, bool preserveCounterValue);
    [FreeFunctionAttribute("GraphicsScripting::SetRandomWriteTargetBuffer")]
private static void Internal_SetRandomWriteTargetGraphicsBuffer(int index, GraphicsBuffer uav, bool preserveCounterValue);
    [StaticAccessorAttribute("GetGfxDevice()", "0")]
public static void ClearRandomWriteTargets();
    [FreeFunctionAttribute("CopyTexture")]
private static void CopyTexture_Full(Texture src, Texture dst);
    [FreeFunctionAttribute("CopyTexture")]
private static void CopyTexture_Slice_AllMips(Texture src, int srcElement, Texture dst, int dstElement);
    [FreeFunctionAttribute("CopyTexture")]
private static void CopyTexture_Slice(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip);
    [FreeFunctionAttribute("CopyTexture")]
private static void CopyTexture_Region(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY);
    [FreeFunctionAttribute("ConvertTexture")]
private static bool ConvertTexture_Full(Texture src, Texture dst);
    [FreeFunctionAttribute("ConvertTexture")]
private static bool ConvertTexture_Slice(Texture src, int srcElement, Texture dst, int dstElement);
    [FreeFunctionAttribute("GraphicsScripting::CopyBuffer")]
private static void CopyBufferImpl(GraphicsBuffer source, GraphicsBuffer dest);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshNow")]
private static void Internal_DrawMeshNow1(Mesh mesh, int subsetIndex, Vector3 position, Quaternion rotation);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshNow")]
private static void Internal_DrawMeshNow2(Mesh mesh, int subsetIndex, Matrix4x4 matrix);
    [VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[FreeFunctionAttribute("GraphicsScripting::DrawTexture")]
internal static void Internal_DrawTexture(Internal_DrawTextureArguments& args);
    [FreeFunctionAttribute("GraphicsScripting::RenderMesh")]
private static void Internal_RenderMesh(RenderParams rparams, Mesh mesh, int submeshIndex, Matrix4x4 objectToWorld, Matrix4x4* prevObjectToWorld);
    [FreeFunctionAttribute("GraphicsScripting::RenderMeshInstanced")]
private static void Internal_RenderMeshInstanced(RenderParams rparams, Mesh mesh, int submeshIndex, IntPtr instanceData, RenderInstancedDataLayout layout, UInt32 instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::RenderMeshIndirect")]
private static void Internal_RenderMeshIndirect(RenderParams rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    [FreeFunctionAttribute("GraphicsScripting::RenderMeshPrimitives")]
private static void Internal_RenderMeshPrimitives(RenderParams rparams, Mesh mesh, int submeshIndex, int instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::RenderPrimitives")]
private static void Internal_RenderPrimitives(RenderParams rparams, MeshTopology topology, int vertexCount, int instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::RenderPrimitivesIndexed")]
private static void Internal_RenderPrimitivesIndexed(RenderParams rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::RenderPrimitivesIndirect")]
private static void Internal_RenderPrimitivesIndirect(RenderParams rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    [FreeFunctionAttribute("GraphicsScripting::RenderPrimitivesIndexedIndirect")]
private static void Internal_RenderPrimitivesIndexedIndirect(RenderParams rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    [FreeFunctionAttribute("GraphicsScripting::DrawMesh")]
private static void Internal_DrawMesh(Mesh mesh, int submeshIndex, Matrix4x4 matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshInstanced")]
private static void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshInstancedProcedural")]
private static void Internal_DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, Bounds bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshInstancedIndirect")]
private static void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    [FreeFunctionAttribute("GraphicsScripting::DrawMeshInstancedIndirect")]
private static void Internal_DrawMeshInstancedIndirectGraphicsBuffer(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralNow")]
private static void Internal_DrawProceduralNow(MeshTopology topology, int vertexCount, int instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexedNow")]
private static void Internal_DrawProceduralIndexedNow(MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndirectNow")]
private static void Internal_DrawProceduralIndirectNow(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexedIndirectNow")]
private static void Internal_DrawProceduralIndexedIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndirectNow")]
private static void Internal_DrawProceduralIndirectNowGraphicsBuffer(MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexedIndirectNow")]
private static void Internal_DrawProceduralIndexedIndirectNowGraphicsBuffer(MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset);
    [FreeFunctionAttribute("GraphicsScripting::DrawProcedural")]
private static void Internal_DrawProcedural(Material material, Bounds bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexed")]
private static void Internal_DrawProceduralIndexed(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndirect")]
private static void Internal_DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndirect")]
private static void Internal_DrawProceduralIndirectGraphicsBuffer(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexedIndirect")]
private static void Internal_DrawProceduralIndexedIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::DrawProceduralIndexedIndirect")]
private static void Internal_DrawProceduralIndexedIndirectGraphicsBuffer(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [FreeFunctionAttribute("GraphicsScripting::BlitMaterial")]
private static void Internal_BlitMaterial5(Texture source, RenderTexture dest, Material mat, int pass, bool setRT);
    [FreeFunctionAttribute("GraphicsScripting::BlitMaterial")]
private static void Internal_BlitMaterial6(Texture source, RenderTexture dest, Material mat, int pass, bool setRT, int destDepthSlice);
    [FreeFunctionAttribute("GraphicsScripting::BlitMultitap")]
private static void Internal_BlitMultiTap4(Texture source, RenderTexture dest, Material mat, Vector2[] offsets);
    [FreeFunctionAttribute("GraphicsScripting::BlitMultitap")]
private static void Internal_BlitMultiTap5(Texture source, RenderTexture dest, Material mat, Vector2[] offsets, int destDepthSlice);
    [FreeFunctionAttribute("GraphicsScripting::Blit")]
private static void Blit2(Texture source, RenderTexture dest);
    [FreeFunctionAttribute("GraphicsScripting::Blit")]
private static void Blit3(Texture source, RenderTexture dest, int sourceDepthSlice, int destDepthSlice);
    [FreeFunctionAttribute("GraphicsScripting::Blit")]
private static void Blit4(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset);
    [FreeFunctionAttribute("GraphicsScripting::Blit")]
private static void Blit5(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    [NativeMethodAttribute]
private static IntPtr CreateGPUFenceImpl(GraphicsFenceType fenceType, SynchronisationStageFlags stage);
    [NativeMethodAttribute]
private static void WaitOnGPUFenceImpl(IntPtr fencePtr, SynchronisationStageFlags stage);
    [NativeMethodAttribute]
public static void ExecuteCommandBuffer(CommandBuffer buffer);
    [NativeMethodAttribute]
public static void ExecuteCommandBufferAsync(CommandBuffer buffer, ComputeQueueType queueType);
    internal static void CheckLoadActionValid(RenderBufferLoadAction load, string bufferType);
    internal static void CheckStoreActionValid(RenderBufferStoreAction store, string bufferType);
    internal static void SetRenderTargetImpl(RenderTargetSetup setup);
    internal static void SetRenderTargetImpl(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice);
    internal static void SetRenderTargetImpl(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice);
    internal static void SetRenderTargetImpl(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice);
    public static void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice);
    public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice);
    public static void SetRenderTarget(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer);
    public static void SetRenderTarget(RenderTargetSetup setup);
    public static RenderBuffer get_activeColorBuffer();
    public static RenderBuffer get_activeDepthBuffer();
    public static void SetRandomWriteTarget(int index, RenderTexture uav);
    public static void SetRandomWriteTarget(int index, ComputeBuffer uav, bool preserveCounterValue);
    public static void SetRandomWriteTarget(int index, GraphicsBuffer uav, bool preserveCounterValue);
    public static void CopyTexture(Texture src, Texture dst);
    public static void CopyTexture(Texture src, int srcElement, Texture dst, int dstElement);
    public static void CopyTexture(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip);
    public static void CopyTexture(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY);
    public static bool ConvertTexture(Texture src, Texture dst);
    public static bool ConvertTexture(Texture src, int srcElement, Texture dst, int dstElement);
    public static GraphicsFence CreateAsyncGraphicsFence(SynchronisationStage stage);
    public static GraphicsFence CreateAsyncGraphicsFence();
    public static GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, SynchronisationStageFlags stage);
    public static void WaitOnAsyncGraphicsFence(GraphicsFence fence);
    public static void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStage stage);
    internal static void ValidateCopyBuffer(GraphicsBuffer source, GraphicsBuffer dest);
    public static void CopyBuffer(GraphicsBuffer source, GraphicsBuffer dest);
    private static void DrawTextureImpl(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass);
    public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass);
    public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass);
    public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass);
    public static void DrawTexture(Rect screenRect, Texture texture, Material mat, int pass);
    public static void RenderMesh(RenderParams& rparams, Mesh mesh, int submeshIndex, Matrix4x4 objectToWorld, Nullable`1<Matrix4x4> prevObjectToWorld);
    private static RenderInstancedDataLayout GetCachedRenderInstancedDataLayout(Type type);
    public static void RenderMeshInstanced(RenderParams& rparams, Mesh mesh, int submeshIndex, T[] instanceData, int instanceCount, int startInstance);
    public static void RenderMeshInstanced(RenderParams& rparams, Mesh mesh, int submeshIndex, List`1<T> instanceData, int instanceCount, int startInstance);
    public static void RenderMeshInstanced(RenderParams rparams, Mesh mesh, int submeshIndex, NativeArray`1<T> instanceData, int instanceCount, int startInstance);
    public static void RenderMeshIndirect(RenderParams& rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    public static void RenderMeshPrimitives(RenderParams& rparams, Mesh mesh, int submeshIndex, int instanceCount);
    public static void RenderPrimitives(RenderParams& rparams, MeshTopology topology, int vertexCount, int instanceCount);
    public static void RenderPrimitivesIndexed(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount);
    public static void RenderPrimitivesIndirect(RenderParams& rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    public static void RenderPrimitivesIndexedIndirect(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex);
    public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix, int materialIndex);
    public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation);
    public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix);
    public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes);
    public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes);
    public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes);
    public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, Bounds bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    public static void DrawProceduralNow(MeshTopology topology, int vertexCount, int instanceCount);
    public static void DrawProceduralNow(MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount);
    public static void DrawProceduralIndirectNow(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset);
    public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    public static void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset);
    public static void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    public static void Blit(Texture source, RenderTexture dest);
    public static void Blit(Texture source, RenderTexture dest, int sourceDepthSlice, int destDepthSlice);
    public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset);
    public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    public static void Blit(Texture source, RenderTexture dest, Material mat, int pass);
    public static void Blit(Texture source, RenderTexture dest, Material mat, int pass, int destDepthSlice);
    public static void Blit(Texture source, RenderTexture dest, Material mat);
    public static void Blit(Texture source, Material mat, int pass);
    public static void Blit(Texture source, Material mat, int pass, int destDepthSlice);
    public static void Blit(Texture source, Material mat);
    public static void BlitMultiTap(Texture source, RenderTexture dest, Material mat, Vector2[] offsets);
    public static void BlitMultiTap(Texture source, RenderTexture dest, Material mat, int destDepthSlice, Vector2[] offsets);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor);
    public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes);
    [ExcludeFromDocsAttribute]
public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
    [ExcludeFromDocsAttribute]
public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture, Material mat);
    [ExcludeFromDocsAttribute]
public static void DrawTexture(Rect screenRect, Texture texture);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderTexture rt);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderTexture rt, int mipLevel);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel);
    [ExcludeFromDocsAttribute]
public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face);
    [ExcludeFromDocsAttribute]
public static void SetRandomWriteTarget(int index, ComputeBuffer uav);
    [ExcludeFromDocsAttribute]
public static void SetRandomWriteTarget(int index, GraphicsBuffer uav);
    private static void GetActiveColorBuffer_Injected(RenderBuffer& ret);
    private static void GetActiveDepthBuffer_Injected(RenderBuffer& ret);
    private static void Internal_SetRTSimple_Injected(RenderBuffer& color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice);
    private static void Internal_SetMRTSimple_Injected(RenderBuffer[] color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice);
    private static void Internal_SetMRTFullSetup_Injected(RenderBuffer[] color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice, RenderBufferLoadAction[] colorLA, RenderBufferStoreAction[] colorSA, RenderBufferLoadAction depthLA, RenderBufferStoreAction depthSA);
    private static void Internal_DrawMeshNow1_Injected(Mesh mesh, int subsetIndex, Vector3& position, Quaternion& rotation);
    private static void Internal_DrawMeshNow2_Injected(Mesh mesh, int subsetIndex, Matrix4x4& matrix);
    private static void Internal_RenderMesh_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, Matrix4x4& objectToWorld, Matrix4x4* prevObjectToWorld);
    private static void Internal_RenderMeshInstanced_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, IntPtr instanceData, RenderInstancedDataLayout& layout, UInt32 instanceCount);
    private static void Internal_RenderMeshIndirect_Injected(RenderParams& rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    private static void Internal_RenderMeshPrimitives_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, int instanceCount);
    private static void Internal_RenderPrimitives_Injected(RenderParams& rparams, MeshTopology topology, int vertexCount, int instanceCount);
    private static void Internal_RenderPrimitivesIndexed_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount);
    private static void Internal_RenderPrimitivesIndirect_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    private static void Internal_RenderPrimitivesIndexedIndirect_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand);
    private static void Internal_DrawMesh_Injected(Mesh mesh, int submeshIndex, Matrix4x4& matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    private static void Internal_DrawMeshInstancedProcedural_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    private static void Internal_DrawMeshInstancedIndirect_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    private static void Internal_DrawMeshInstancedIndirectGraphicsBuffer_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume);
    private static void Internal_DrawProcedural_Injected(Material material, Bounds& bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Internal_DrawProceduralIndexed_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Internal_DrawProceduralIndirect_Injected(Material material, Bounds& bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Internal_DrawProceduralIndirectGraphicsBuffer_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Internal_DrawProceduralIndexedIndirect_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Internal_DrawProceduralIndexedIndirectGraphicsBuffer_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer);
    private static void Blit4_Injected(Texture source, RenderTexture dest, Vector2& scale, Vector2& offset);
    private static void Blit5_Injected(Texture source, RenderTexture dest, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice);
}
[NativeHeaderAttribute("Runtime/Shaders/GraphicsBuffer.h")]
[NativeHeaderAttribute("Runtime/Export/Graphics/GraphicsBuffer.bindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.GraphicsBuffer : object {
    internal IntPtr m_Ptr;
    public int count { get; }
    public int stride { get; }
    public Target target { get; }
    public UsageFlags usageFlags { get; }
    public GraphicsBufferHandle bufferHandle { get; }
    unknown string name {public set; }
    public GraphicsBuffer(Target target, int count, int stride);
    public GraphicsBuffer(Target target, UsageFlags usageFlags, int count, int stride);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private static bool RequiresCompute(Target target);
    private static bool IsVertexIndexOrCopyOnly(Target target);
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::InitBuffer")]
private static IntPtr InitBuffer(Target target, UsageFlags usageFlags, int count, int stride);
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::DestroyBuffer")]
private static void DestroyBuffer(GraphicsBuffer buf);
    private void InternalInitialization(Target target, UsageFlags usageFlags, int count, int stride);
    public void Release();
    [FreeFunctionAttribute("GraphicsBuffer_Bindings::IsValidBuffer")]
private static bool IsValidBuffer(GraphicsBuffer buf);
    public bool IsValid();
    public int get_count();
    public int get_stride();
    public Target get_target();
    [FreeFunctionAttribute]
private UsageFlags GetUsageFlags();
    public UsageFlags get_usageFlags();
    public GraphicsBufferHandle get_bufferHandle();
    [SecuritySafeCriticalAttribute]
public void SetData(Array data);
    [SecuritySafeCriticalAttribute]
public void SetData(List`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetData(NativeArray`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetData(Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetData(List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetData(NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count);
    [FreeFunctionAttribute]
[SecurityCriticalAttribute]
private void InternalSetNativeData(IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [SecurityCriticalAttribute]
[FreeFunctionAttribute]
private void InternalSetData(Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [SecurityCriticalAttribute]
public void GetData(Array data);
    [SecurityCriticalAttribute]
public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count);
    [FreeFunctionAttribute]
[SecurityCriticalAttribute]
private void InternalGetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
public IntPtr GetNativeBufferPtr();
    private Void* BeginBufferWrite(int offset, int size);
    public NativeArray`1<T> LockBufferForWrite(int bufferStartIndex, int count);
    private void EndBufferWrite(int bytesWritten);
    public void UnlockBufferAfterWrite(int countWritten);
    public void set_name(string value);
    [FreeFunctionAttribute]
private void SetName(string name);
    public void SetCounterValue(UInt32 counterValue);
    [FreeFunctionAttribute]
private static void CopyCountCC(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes);
    [FreeFunctionAttribute]
private static void CopyCountGC(GraphicsBuffer src, ComputeBuffer dst, int dstOffsetBytes);
    [FreeFunctionAttribute]
private static void CopyCountCG(ComputeBuffer src, GraphicsBuffer dst, int dstOffsetBytes);
    [FreeFunctionAttribute]
private static void CopyCountGG(GraphicsBuffer src, GraphicsBuffer dst, int dstOffsetBytes);
    public static void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes);
    public static void CopyCount(GraphicsBuffer src, ComputeBuffer dst, int dstOffsetBytes);
    public static void CopyCount(ComputeBuffer src, GraphicsBuffer dst, int dstOffsetBytes);
    public static void CopyCount(GraphicsBuffer src, GraphicsBuffer dst, int dstOffsetBytes);
    private void get_bufferHandle_Injected(GraphicsBufferHandle& ret);
}
[NativeClassAttribute("GfxBufferID")]
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
[IsReadOnlyAttribute]
public class UnityEngine.GraphicsBufferHandle : ValueType {
    public UInt32 value;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GraphicsBufferHandle other);
    public int CompareTo(GraphicsBufferHandle other);
    public static bool op_Equality(GraphicsBufferHandle a, GraphicsBufferHandle b);
    public static bool op_Inequality(GraphicsBufferHandle a, GraphicsBufferHandle b);
}
[RequireComponent("UnityEngine.Transform")]
[NativeHeaderAttribute("Runtime/Camera/HaloManager.h")]
internal class UnityEngine.Halo : Behaviour {
}
[NativeHeaderAttribute("Runtime/Export/Hashing/Hash128.bindings.h")]
[NativeHeaderAttribute("Runtime/Utilities/Hash128.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Hash128 : ValueType {
    internal ulong u64_0;
    internal ulong u64_1;
    private static ulong kConst;
    public bool isValid { get; }
    public Hash128(UInt32 u32_0, UInt32 u32_1, UInt32 u32_2, UInt32 u32_3);
    public Hash128(ulong u64_0, ulong u64_1);
    public bool get_isValid();
    public sealed virtual int CompareTo(Hash128 rhs);
    public virtual string ToString();
    [FreeFunctionAttribute("StringToHash128")]
public static Hash128 Parse(string hashString);
    [FreeFunctionAttribute("Hash128ToString")]
private static string Hash128ToStringImpl(Hash128 hash);
    [FreeFunctionAttribute("ComputeHash128FromScriptString")]
private static void ComputeFromString(string data, Hash128& hash);
    [FreeFunctionAttribute("ComputeHash128FromScriptPointer")]
private static void ComputeFromPtr(IntPtr data, int start, int count, int elemSize, Hash128& hash);
    [FreeFunctionAttribute("ComputeHash128FromScriptArray")]
private static void ComputeFromArray(Array data, int start, int count, int elemSize, Hash128& hash);
    public static Hash128 Compute(string data);
    public static Hash128 Compute(NativeArray`1<T> data);
    public static Hash128 Compute(NativeArray`1<T> data, int start, int count);
    public static Hash128 Compute(T[] data);
    public static Hash128 Compute(T[] data, int start, int count);
    public static Hash128 Compute(List`1<T> data);
    public static Hash128 Compute(List`1<T> data, int start, int count);
    public static Hash128 Compute(T& val);
    public static Hash128 Compute(int val);
    public static Hash128 Compute(float val);
    public static Hash128 Compute(Void* data, ulong size);
    public void Append(string data);
    public void Append(NativeArray`1<T> data);
    public void Append(NativeArray`1<T> data, int start, int count);
    public void Append(T[] data);
    public void Append(T[] data, int start, int count);
    public void Append(List`1<T> data);
    public void Append(List`1<T> data, int start, int count);
    public void Append(T& val);
    public void Append(int val);
    public void Append(float val);
    public void Append(Void* data, ulong size);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Hash128 obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(Hash128 hash1, Hash128 hash2);
    public static bool op_Inequality(Hash128 hash1, Hash128 hash2);
    public static bool op_LessThan(Hash128 x, Hash128 y);
    public static bool op_GreaterThan(Hash128 x, Hash128 y);
    private void ShortHash4(UInt32 data);
    private static void ShortEnd(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3);
    private static void Rot64(UInt64& x, int k);
    private static void Parse_Injected(string hashString, Hash128& ret);
    private static string Hash128ToStringImpl_Injected(Hash128& hash);
}
public static class UnityEngine.HashUnsafeUtilities : object {
    public static void ComputeHash128(Void* data, ulong dataSize, UInt64* hash1, UInt64* hash2);
    public static void ComputeHash128(Void* data, ulong dataSize, Hash128* hash);
}
public static class UnityEngine.HashUtilities : object {
    public static void AppendHash(Hash128& inHash, Hash128& outHash);
    public static void QuantisedMatrixHash(Matrix4x4& value, Hash128& hash);
    public static void QuantisedVectorHash(Vector3& value, Hash128& hash);
    public static void ComputeHash128(T& value, Hash128& hash);
    public static void ComputeHash128(Byte[] value, Hash128& hash);
}
public enum UnityEngine.HDRDisplayBitDepth : Enum {
    public int value__;
    public static HDRDisplayBitDepth BitDepth10;
    public static HDRDisplayBitDepth BitDepth16;
}
[FlagsAttribute]
public enum UnityEngine.HDRDisplaySupportFlags : Enum {
    public int value__;
    public static HDRDisplaySupportFlags None;
    public static HDRDisplaySupportFlags Supported;
    public static HDRDisplaySupportFlags RuntimeSwitchable;
    public static HDRDisplaySupportFlags AutomaticTonemapping;
}
[NativeHeaderAttribute("Runtime/GfxDevice/HDROutputSettings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.HDROutputSettings : object {
    private int m_DisplayIndex;
    public static HDROutputSettings[] displays;
    private static HDROutputSettings _mainDisplay;
    public static HDROutputSettings main { get; }
    public bool active { get; }
    public bool available { get; }
    public bool automaticHDRTonemapping { get; public set; }
    public ColorGamut displayColorGamut { get; }
    public RenderTextureFormat format { get; }
    public GraphicsFormat graphicsFormat { get; }
    public float paperWhiteNits { get; public set; }
    public int maxFullFrameToneMapLuminance { get; }
    public int maxToneMapLuminance { get; }
    public int minToneMapLuminance { get; }
    public bool HDRModeChangeRequested { get; }
    [VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HDROutputSettings(int displayIndex);
    private static HDROutputSettings();
    public static HDROutputSettings get_main();
    public bool get_active();
    public bool get_available();
    public bool get_automaticHDRTonemapping();
    public void set_automaticHDRTonemapping(bool value);
    public ColorGamut get_displayColorGamut();
    public RenderTextureFormat get_format();
    public GraphicsFormat get_graphicsFormat();
    public float get_paperWhiteNits();
    public void set_paperWhiteNits(float value);
    public int get_maxFullFrameToneMapLuminance();
    public int get_maxToneMapLuminance();
    public int get_minToneMapLuminance();
    public bool get_HDRModeChangeRequested();
    public void RequestHDRModeChange(bool enabled);
    [ObsoleteAttribute("SetPaperWhiteInNits is deprecated, please use paperWhiteNits instead.")]
public static void SetPaperWhiteInNits(float paperWhite);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetActive")]
private static bool GetActive(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetAvailable")]
private static bool GetAvailable(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetAutomaticHDRTonemapping")]
private static bool GetAutomaticHDRTonemapping(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::SetAutomaticHDRTonemapping")]
private static void SetAutomaticHDRTonemapping(int displayIndex, bool scripted);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetDisplayColorGamut")]
private static ColorGamut GetDisplayColorGamut(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetGraphicsFormat")]
private static GraphicsFormat GetGraphicsFormat(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetPaperWhiteNits")]
private static float GetPaperWhiteNits(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::SetPaperWhiteNits")]
private static void SetPaperWhiteNits(int displayIndex, float paperWhite);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetMaxFullFrameToneMapLuminance")]
private static int GetMaxFullFrameToneMapLuminance(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetMaxToneMapLuminance")]
private static int GetMaxToneMapLuminance(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetMinToneMapLuminance")]
private static int GetMinToneMapLuminance(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::GetHDRModeChangeRequested")]
private static bool GetHDRModeChangeRequested(int displayIndex);
    [FreeFunctionAttribute("HDROutputSettingsBindings::RequestHDRModeChange")]
private static void RequestHDRModeChangeInternal(int displayIndex, bool enabled);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.HeaderAttribute : PropertyAttribute {
    public string header;
    public HeaderAttribute(string header);
}
[UsedByNativeCodeAttribute]
[AttributeUsageAttribute("4")]
public class UnityEngine.HelpURLAttribute : Attribute {
    internal string m_Url;
    internal bool m_Dispatcher;
    internal string m_DispatchingFieldName;
    public string URL { get; }
    public HelpURLAttribute(string url);
    internal HelpURLAttribute(string defaultURL, string dispatchingFieldName);
    public string get_URL();
}
[FlagsAttribute]
public enum UnityEngine.HideFlags : Enum {
    public int value__;
    public static HideFlags None;
    public static HideFlags HideInHierarchy;
    public static HideFlags HideInInspector;
    public static HideFlags DontSaveInEditor;
    public static HideFlags NotEditable;
    public static HideFlags DontSaveInBuild;
    public static HideFlags DontUnloadUnusedAsset;
    public static HideFlags DontSave;
    public static HideFlags HideAndDontSave;
}
[AttributeUsageAttribute("64")]
public class UnityEngine.HideInCallstackAttribute : Attribute {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.HideInInspector : Attribute {
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("UNITY_EDITOR")]
public class UnityEngine.IconAttribute : Attribute {
    private string m_IconPath;
    public string path { get; }
    public IconAttribute(string path);
    public string get_path();
}
public interface UnityEngine.IExposedPropertyTable {
    public abstract virtual void SetReferenceValue(PropertyName id, Object value);
    public abstract virtual Object GetReferenceValue(PropertyName id, Boolean& idValid);
    public abstract virtual void ClearReferenceValue(PropertyName id);
}
public interface UnityEngine.ILogger {
    public ILogHandler logHandler { get; public set; }
    public bool logEnabled { get; public set; }
    public LogType filterLogType { get; public set; }
    public abstract virtual ILogHandler get_logHandler();
    public abstract virtual void set_logHandler(ILogHandler value);
    public abstract virtual bool get_logEnabled();
    public abstract virtual void set_logEnabled(bool value);
    public abstract virtual LogType get_filterLogType();
    public abstract virtual void set_filterLogType(LogType value);
    public abstract virtual bool IsLogTypeAllowed(LogType logType);
    public abstract virtual void Log(LogType logType, object message);
    public abstract virtual void Log(LogType logType, object message, Object context);
    public abstract virtual void Log(LogType logType, string tag, object message);
    public abstract virtual void Log(LogType logType, string tag, object message, Object context);
    public abstract virtual void Log(object message);
    public abstract virtual void Log(string tag, object message);
    public abstract virtual void Log(string tag, object message, Object context);
    public abstract virtual void LogWarning(string tag, object message);
    public abstract virtual void LogWarning(string tag, object message, Object context);
    public abstract virtual void LogError(string tag, object message);
    public abstract virtual void LogError(string tag, object message, Object context);
    public abstract virtual void LogFormat(LogType logType, string format, Object[] args);
    public abstract virtual void LogException(Exception exception);
}
public interface UnityEngine.ILogHandler {
    public abstract virtual void LogFormat(LogType logType, Object context, string format, Object[] args);
    public abstract virtual void LogException(Exception exception, Object context);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ImageEffectAfterScale : Attribute {
}
public class UnityEngine.ImageEffectAllowedInSceneView : Attribute {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ImageEffectOpaque : Attribute {
}
[UsedByNativeCodeAttribute]
public class UnityEngine.ImageEffectTransformsToLDR : Attribute {
}
[AttributeUsageAttribute("64")]
[UsedByNativeCodeAttribute]
public class UnityEngine.ImageEffectUsesCommandBuffer : Attribute {
}
[AttributeUsageAttribute("256")]
[UsedByNativeCodeAttribute]
public class UnityEngine.InspectorNameAttribute : PropertyAttribute {
    public string displayName;
    public InspectorNameAttribute(string displayName);
}
[AttributeUsageAttribute("16")]
public class UnityEngine.InspectorOrderAttribute : PropertyAttribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InspectorSort <m_inspectorSort>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InspectorSortDirection <m_sortDirection>k__BackingField;
    internal InspectorSort m_inspectorSort { get; private set; }
    internal InspectorSortDirection m_sortDirection { get; private set; }
    public InspectorOrderAttribute(InspectorSort inspectorSort, InspectorSortDirection sortDirection);
    [CompilerGeneratedAttribute]
internal InspectorSort get_m_inspectorSort();
    [CompilerGeneratedAttribute]
private void set_m_inspectorSort(InspectorSort value);
    [CompilerGeneratedAttribute]
internal InspectorSortDirection get_m_sortDirection();
    [CompilerGeneratedAttribute]
private void set_m_sortDirection(InspectorSortDirection value);
}
public enum UnityEngine.InspectorSort : Enum {
    public int value__;
    public static InspectorSort ByName;
    public static InspectorSort ByValue;
}
public enum UnityEngine.InspectorSortDirection : Enum {
    public int value__;
    public static InspectorSortDirection Ascending;
    public static InspectorSortDirection Descending;
}
[VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class UnityEngine.Internal_DrawTextureArguments : ValueType {
    public Rect screenRect;
    public Rect sourceRect;
    public int leftBorder;
    public int rightBorder;
    public int topBorder;
    public int bottomBorder;
    public Color leftBorderColor;
    public Color rightBorderColor;
    public Color topBorderColor;
    public Color bottomBorderColor;
    public Color color;
    public Vector4 borderWidths;
    public Vector4 cornerRadiuses;
    public bool smoothCorners;
    public int pass;
    public Texture texture;
    public Material mat;
}
[AttributeUsageAttribute("18432")]
public class UnityEngine.Internal.DefaultValueAttribute : Attribute {
    private object DefaultValue;
    public object Value { get; }
    public DefaultValueAttribute(string value);
    public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class UnityEngine.Internal.ExcludeFromDocsAttribute : Attribute {
}
[ExcludeFromDocsAttribute]
[NativeHeaderAttribute("Runtime/GfxDevice/HDROutputSettings.h")]
internal static class UnityEngine.Internal.InternalHDROutputFaking : object {
    [FreeFunctionAttribute("HDROutputSettingsBindings::SetFakeHDROutputEnabled")]
[ExcludeFromDocsAttribute]
internal static void SetEnabled(bool enabled);
}
[VisibleToOtherModulesAttribute]
internal interface UnityEngine.Internal.ISubAssetNotDuplicatable {
}
[NativeConditionalAttribute("ENABLE_PROFILER")]
[StaticAccessorAttribute("FileAccessor", "2")]
[NativeHeaderAttribute("Runtime/VirtualFileSystem/VirtualFileSystem.h")]
internal static class UnityEngine.IO.File : object {
    internal static ulong totalOpenCalls { get; }
    internal static ulong totalCloseCalls { get; }
    internal static ulong totalReadCalls { get; }
    internal static ulong totalWriteCalls { get; }
    internal static ulong totalSeekCalls { get; }
    internal static ulong totalZeroSeekCalls { get; }
    internal static ulong totalFilesOpened { get; }
    internal static ulong totalFilesClosed { get; }
    internal static ulong totalBytesRead { get; }
    internal static ulong totalBytesWritten { get; }
    internal static bool recordZeroSeeks { get; internal set; }
    internal static ThreadIORestrictionMode MainThreadIORestrictionMode { get; internal set; }
    internal static ulong get_totalOpenCalls();
    internal static ulong get_totalCloseCalls();
    internal static ulong get_totalReadCalls();
    internal static ulong get_totalWriteCalls();
    internal static ulong get_totalSeekCalls();
    internal static ulong get_totalZeroSeekCalls();
    internal static ulong get_totalFilesOpened();
    internal static ulong get_totalFilesClosed();
    internal static ulong get_totalBytesRead();
    internal static ulong get_totalBytesWritten();
    internal static void set_recordZeroSeeks(bool value);
    internal static bool get_recordZeroSeeks();
    internal static ThreadIORestrictionMode get_MainThreadIORestrictionMode();
    internal static void set_MainThreadIORestrictionMode(ThreadIORestrictionMode value);
    internal static void SetRecordZeroSeeks(bool enable);
    internal static bool GetRecordZeroSeeks();
    internal static ulong GetTotalOpenCalls();
    internal static ulong GetTotalCloseCalls();
    internal static ulong GetTotalReadCalls();
    internal static ulong GetTotalWriteCalls();
    internal static ulong GetTotalSeekCalls();
    internal static ulong GetTotalZeroSeekCalls();
    internal static ulong GetTotalFilesOpened();
    internal static ulong GetTotalFilesClosed();
    internal static ulong GetTotalBytesRead();
    internal static ulong GetTotalBytesWritten();
    private static void SetMainThreadFileIORestriction(ThreadIORestrictionMode mode);
    private static ThreadIORestrictionMode GetMainThreadFileIORestriction();
}
[NativeHeaderAttribute("Runtime/VirtualFileSystem/VirtualFileSystem.h")]
internal enum UnityEngine.IO.ThreadIORestrictionMode : Enum {
    public int value__;
    public static ThreadIORestrictionMode Allowed;
    public static ThreadIORestrictionMode TreatAsError;
}
internal interface UnityEngine.IPlayerEditorConnectionNative {
    public abstract virtual void Initialize();
    public abstract virtual void DisconnectAll();
    public abstract virtual void SendMessage(Guid messageId, Byte[] data, int playerId);
    public abstract virtual bool TrySendMessage(Guid messageId, Byte[] data, int playerId);
    public abstract virtual void Poll();
    public abstract virtual void RegisterInternal(Guid messageId);
    public abstract virtual void UnregisterInternal(Guid messageId);
    public abstract virtual bool IsConnected();
}
[RequiredByNativeCodeAttribute]
public interface UnityEngine.ISerializationCallbackReceiver {
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnBeforeSerialize();
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnAfterDeserialize();
}
[JobProducerTypeAttribute("UnityEngine.Jobs.IJobParallelForTransformExtensions/TransformParallelForLoopStruct`1")]
public interface UnityEngine.Jobs.IJobParallelForTransform {
    public abstract virtual void Execute(int index, TransformAccess transform);
}
[ExtensionAttribute]
public static class UnityEngine.Jobs.IJobParallelForTransformExtensions : object {
    public static void EarlyJobInit();
    private static IntPtr GetReflectionData();
    [ExtensionAttribute]
public static JobHandle Schedule(T jobData, TransformAccessArray transforms, JobHandle dependsOn);
    [ExtensionAttribute]
public static JobHandle ScheduleReadOnly(T jobData, TransformAccessArray transforms, int batchSize, JobHandle dependsOn);
    [ExtensionAttribute]
public static void RunReadOnly(T jobData, TransformAccessArray transforms);
    [ExtensionAttribute]
public static JobHandle ScheduleByRef(T& jobData, TransformAccessArray transforms, JobHandle dependsOn);
    [ExtensionAttribute]
public static JobHandle ScheduleReadOnlyByRef(T& jobData, TransformAccessArray transforms, int batchSize, JobHandle dependsOn);
    [ExtensionAttribute]
public static void RunReadOnlyByRef(T& jobData, TransformAccessArray transforms);
}
[NativeHeaderAttribute("Runtime/Transform/ScriptBindings/TransformAccess.bindings.h")]
public class UnityEngine.Jobs.TransformAccess : ValueType {
    private IntPtr hierarchy;
    private int index;
    public Vector3 position { get; public set; }
    public Quaternion rotation { get; public set; }
    public Vector3 localPosition { get; public set; }
    public Quaternion localRotation { get; public set; }
    public Vector3 localScale { get; public set; }
    public Matrix4x4 localToWorldMatrix { get; }
    public Matrix4x4 worldToLocalMatrix { get; }
    public bool isValid { get; }
    public Vector3 get_position();
    public void set_position(Vector3 value);
    public Quaternion get_rotation();
    public void set_rotation(Quaternion value);
    public Vector3 get_localPosition();
    public void set_localPosition(Vector3 value);
    public Quaternion get_localRotation();
    public void set_localRotation(Quaternion value);
    public Vector3 get_localScale();
    public void set_localScale(Vector3 value);
    public Matrix4x4 get_localToWorldMatrix();
    public Matrix4x4 get_worldToLocalMatrix();
    public bool get_isValid();
    public void SetPositionAndRotation(Vector3 position, Quaternion rotation);
    public void SetLocalPositionAndRotation(Vector3 localPosition, Quaternion localRotation);
    public void GetPositionAndRotation(Vector3& position, Quaternion& rotation);
    public void GetLocalPositionAndRotation(Vector3& localPosition, Quaternion& localRotation);
    [NativeMethodAttribute]
private static void SetPositionAndRotation_Internal(TransformAccess& access, Vector3& position, Quaternion& rotation);
    [NativeMethodAttribute]
private static void SetLocalPositionAndRotation_Internal(TransformAccess& access, Vector3& localPosition, Quaternion& localRotation);
    [NativeMethodAttribute]
private static void GetPositionAndRotation_Internal(TransformAccess& access, Vector3& position, Quaternion& rotation);
    [NativeMethodAttribute]
private static void GetLocalPositionAndRotation_Internal(TransformAccess& access, Vector3& localPosition, Quaternion& localRotation);
    [NativeMethodAttribute]
private static void GetPosition(TransformAccess& access, Vector3& p);
    [NativeMethodAttribute]
private static void SetPosition(TransformAccess& access, Vector3& p);
    [NativeMethodAttribute]
private static void GetRotation(TransformAccess& access, Quaternion& r);
    [NativeMethodAttribute]
private static void SetRotation(TransformAccess& access, Quaternion& r);
    [NativeMethodAttribute]
private static void GetLocalPosition(TransformAccess& access, Vector3& p);
    [NativeMethodAttribute]
private static void SetLocalPosition(TransformAccess& access, Vector3& p);
    [NativeMethodAttribute]
private static void GetLocalRotation(TransformAccess& access, Quaternion& r);
    [NativeMethodAttribute]
private static void SetLocalRotation(TransformAccess& access, Quaternion& r);
    [NativeMethodAttribute]
private static void GetLocalScale(TransformAccess& access, Vector3& r);
    [NativeMethodAttribute]
private static void SetLocalScale(TransformAccess& access, Vector3& r);
    [NativeMethodAttribute]
private static void GetLocalToWorldMatrix(TransformAccess& access, Matrix4x4& m);
    [NativeMethodAttribute]
private static void GetWorldToLocalMatrix(TransformAccess& access, Matrix4x4& m);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal void CheckHierarchyValid();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal void MarkReadWrite();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal void MarkReadOnly();
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
private void CheckWriteAccess();
}
[NativeTypeAttribute]
[DefaultMemberAttribute("Item")]
public class UnityEngine.Jobs.TransformAccessArray : ValueType {
    private IntPtr m_TransformArray;
    public bool isCreated { get; }
    public Transform Item { get; public set; }
    public int capacity { get; public set; }
    public int length { get; }
    public TransformAccessArray(Transform[] transforms, int desiredJobCount);
    public TransformAccessArray(int capacity, int desiredJobCount);
    public static void Allocate(int capacity, int desiredJobCount, TransformAccessArray& array);
    public bool get_isCreated();
    public sealed virtual void Dispose();
    internal IntPtr GetTransformAccessArrayForSchedule();
    public Transform get_Item(int index);
    public void set_Item(int index, Transform value);
    public int get_capacity();
    public void set_capacity(int value);
    public int get_length();
    public void Add(Transform transform);
    public void Add(int instanceId);
    public void RemoveAtSwapBack(int index);
    public void SetTransforms(Transform[] transforms);
    [NativeMethodAttribute]
private static IntPtr Create(int capacity, int desiredJobCount);
    [NativeMethodAttribute]
private static void DestroyTransformAccessArray(IntPtr transformArray);
    [NativeMethodAttribute]
private static void SetTransforms(IntPtr transformArrayIntPtr, Transform[] transforms);
    [NativeMethodAttribute]
private static void Add(IntPtr transformArrayIntPtr, Transform transform);
    [NativeMethodAttribute]
private static void AddInstanceId(IntPtr transformArrayIntPtr, int instanceId);
    [NativeMethodAttribute]
private static void RemoveAtSwapBack(IntPtr transformArrayIntPtr, int index);
    [NativeMethodAttribute]
internal static IntPtr GetSortedTransformAccess(IntPtr transformArrayIntPtr);
    [NativeMethodAttribute]
internal static IntPtr GetSortedToUserIndex(IntPtr transformArrayIntPtr);
    [NativeMethodAttribute]
internal static int GetLength(IntPtr transformArrayIntPtr);
    [NativeMethodAttribute]
internal static int GetCapacity(IntPtr transformArrayIntPtr);
    [NativeMethodAttribute]
internal static void SetCapacity(IntPtr transformArrayIntPtr, int capacity);
    [NativeMethodAttribute]
internal static Transform GetTransform(IntPtr transformArrayIntPtr, int index);
    [NativeMethodAttribute]
internal static void SetTransform(IntPtr transformArrayIntPtr, int index, Transform transform);
}
public enum UnityEngine.KeyCode : Enum {
    public int value__;
    public static KeyCode None;
    public static KeyCode Backspace;
    public static KeyCode Delete;
    public static KeyCode Tab;
    public static KeyCode Clear;
    public static KeyCode Return;
    public static KeyCode Pause;
    public static KeyCode Escape;
    public static KeyCode Space;
    public static KeyCode Keypad0;
    public static KeyCode Keypad1;
    public static KeyCode Keypad2;
    public static KeyCode Keypad3;
    public static KeyCode Keypad4;
    public static KeyCode Keypad5;
    public static KeyCode Keypad6;
    public static KeyCode Keypad7;
    public static KeyCode Keypad8;
    public static KeyCode Keypad9;
    public static KeyCode KeypadPeriod;
    public static KeyCode KeypadDivide;
    public static KeyCode KeypadMultiply;
    public static KeyCode KeypadMinus;
    public static KeyCode KeypadPlus;
    public static KeyCode KeypadEnter;
    public static KeyCode KeypadEquals;
    public static KeyCode UpArrow;
    public static KeyCode DownArrow;
    public static KeyCode RightArrow;
    public static KeyCode LeftArrow;
    public static KeyCode Insert;
    public static KeyCode Home;
    public static KeyCode End;
    public static KeyCode PageUp;
    public static KeyCode PageDown;
    public static KeyCode F1;
    public static KeyCode F2;
    public static KeyCode F3;
    public static KeyCode F4;
    public static KeyCode F5;
    public static KeyCode F6;
    public static KeyCode F7;
    public static KeyCode F8;
    public static KeyCode F9;
    public static KeyCode F10;
    public static KeyCode F11;
    public static KeyCode F12;
    public static KeyCode F13;
    public static KeyCode F14;
    public static KeyCode F15;
    public static KeyCode Alpha0;
    public static KeyCode Alpha1;
    public static KeyCode Alpha2;
    public static KeyCode Alpha3;
    public static KeyCode Alpha4;
    public static KeyCode Alpha5;
    public static KeyCode Alpha6;
    public static KeyCode Alpha7;
    public static KeyCode Alpha8;
    public static KeyCode Alpha9;
    public static KeyCode Exclaim;
    public static KeyCode DoubleQuote;
    public static KeyCode Hash;
    public static KeyCode Dollar;
    public static KeyCode Percent;
    public static KeyCode Ampersand;
    public static KeyCode Quote;
    public static KeyCode LeftParen;
    public static KeyCode RightParen;
    public static KeyCode Asterisk;
    public static KeyCode Plus;
    public static KeyCode Comma;
    public static KeyCode Minus;
    public static KeyCode Period;
    public static KeyCode Slash;
    public static KeyCode Colon;
    public static KeyCode Semicolon;
    public static KeyCode Less;
    public static KeyCode Equals;
    public static KeyCode Greater;
    public static KeyCode Question;
    public static KeyCode At;
    public static KeyCode LeftBracket;
    public static KeyCode Backslash;
    public static KeyCode RightBracket;
    public static KeyCode Caret;
    public static KeyCode Underscore;
    public static KeyCode BackQuote;
    public static KeyCode A;
    public static KeyCode B;
    public static KeyCode C;
    public static KeyCode D;
    public static KeyCode E;
    public static KeyCode F;
    public static KeyCode G;
    public static KeyCode H;
    public static KeyCode I;
    public static KeyCode J;
    public static KeyCode K;
    public static KeyCode L;
    public static KeyCode M;
    public static KeyCode N;
    public static KeyCode O;
    public static KeyCode P;
    public static KeyCode Q;
    public static KeyCode R;
    public static KeyCode S;
    public static KeyCode T;
    public static KeyCode U;
    public static KeyCode V;
    public static KeyCode W;
    public static KeyCode X;
    public static KeyCode Y;
    public static KeyCode Z;
    public static KeyCode LeftCurlyBracket;
    public static KeyCode Pipe;
    public static KeyCode RightCurlyBracket;
    public static KeyCode Tilde;
    public static KeyCode Numlock;
    public static KeyCode CapsLock;
    public static KeyCode ScrollLock;
    public static KeyCode RightShift;
    public static KeyCode LeftShift;
    public static KeyCode RightControl;
    public static KeyCode LeftControl;
    public static KeyCode RightAlt;
    public static KeyCode LeftAlt;
    public static KeyCode LeftMeta;
    public static KeyCode LeftCommand;
    public static KeyCode LeftApple;
    public static KeyCode LeftWindows;
    public static KeyCode RightMeta;
    public static KeyCode RightCommand;
    public static KeyCode RightApple;
    public static KeyCode RightWindows;
    public static KeyCode AltGr;
    public static KeyCode Help;
    public static KeyCode Print;
    public static KeyCode SysReq;
    public static KeyCode Break;
    public static KeyCode Menu;
    public static KeyCode Mouse0;
    public static KeyCode Mouse1;
    public static KeyCode Mouse2;
    public static KeyCode Mouse3;
    public static KeyCode Mouse4;
    public static KeyCode Mouse5;
    public static KeyCode Mouse6;
    public static KeyCode JoystickButton0;
    public static KeyCode JoystickButton1;
    public static KeyCode JoystickButton2;
    public static KeyCode JoystickButton3;
    public static KeyCode JoystickButton4;
    public static KeyCode JoystickButton5;
    public static KeyCode JoystickButton6;
    public static KeyCode JoystickButton7;
    public static KeyCode JoystickButton8;
    public static KeyCode JoystickButton9;
    public static KeyCode JoystickButton10;
    public static KeyCode JoystickButton11;
    public static KeyCode JoystickButton12;
    public static KeyCode JoystickButton13;
    public static KeyCode JoystickButton14;
    public static KeyCode JoystickButton15;
    public static KeyCode JoystickButton16;
    public static KeyCode JoystickButton17;
    public static KeyCode JoystickButton18;
    public static KeyCode JoystickButton19;
    public static KeyCode Joystick1Button0;
    public static KeyCode Joystick1Button1;
    public static KeyCode Joystick1Button2;
    public static KeyCode Joystick1Button3;
    public static KeyCode Joystick1Button4;
    public static KeyCode Joystick1Button5;
    public static KeyCode Joystick1Button6;
    public static KeyCode Joystick1Button7;
    public static KeyCode Joystick1Button8;
    public static KeyCode Joystick1Button9;
    public static KeyCode Joystick1Button10;
    public static KeyCode Joystick1Button11;
    public static KeyCode Joystick1Button12;
    public static KeyCode Joystick1Button13;
    public static KeyCode Joystick1Button14;
    public static KeyCode Joystick1Button15;
    public static KeyCode Joystick1Button16;
    public static KeyCode Joystick1Button17;
    public static KeyCode Joystick1Button18;
    public static KeyCode Joystick1Button19;
    public static KeyCode Joystick2Button0;
    public static KeyCode Joystick2Button1;
    public static KeyCode Joystick2Button2;
    public static KeyCode Joystick2Button3;
    public static KeyCode Joystick2Button4;
    public static KeyCode Joystick2Button5;
    public static KeyCode Joystick2Button6;
    public static KeyCode Joystick2Button7;
    public static KeyCode Joystick2Button8;
    public static KeyCode Joystick2Button9;
    public static KeyCode Joystick2Button10;
    public static KeyCode Joystick2Button11;
    public static KeyCode Joystick2Button12;
    public static KeyCode Joystick2Button13;
    public static KeyCode Joystick2Button14;
    public static KeyCode Joystick2Button15;
    public static KeyCode Joystick2Button16;
    public static KeyCode Joystick2Button17;
    public static KeyCode Joystick2Button18;
    public static KeyCode Joystick2Button19;
    public static KeyCode Joystick3Button0;
    public static KeyCode Joystick3Button1;
    public static KeyCode Joystick3Button2;
    public static KeyCode Joystick3Button3;
    public static KeyCode Joystick3Button4;
    public static KeyCode Joystick3Button5;
    public static KeyCode Joystick3Button6;
    public static KeyCode Joystick3Button7;
    public static KeyCode Joystick3Button8;
    public static KeyCode Joystick3Button9;
    public static KeyCode Joystick3Button10;
    public static KeyCode Joystick3Button11;
    public static KeyCode Joystick3Button12;
    public static KeyCode Joystick3Button13;
    public static KeyCode Joystick3Button14;
    public static KeyCode Joystick3Button15;
    public static KeyCode Joystick3Button16;
    public static KeyCode Joystick3Button17;
    public static KeyCode Joystick3Button18;
    public static KeyCode Joystick3Button19;
    public static KeyCode Joystick4Button0;
    public static KeyCode Joystick4Button1;
    public static KeyCode Joystick4Button2;
    public static KeyCode Joystick4Button3;
    public static KeyCode Joystick4Button4;
    public static KeyCode Joystick4Button5;
    public static KeyCode Joystick4Button6;
    public static KeyCode Joystick4Button7;
    public static KeyCode Joystick4Button8;
    public static KeyCode Joystick4Button9;
    public static KeyCode Joystick4Button10;
    public static KeyCode Joystick4Button11;
    public static KeyCode Joystick4Button12;
    public static KeyCode Joystick4Button13;
    public static KeyCode Joystick4Button14;
    public static KeyCode Joystick4Button15;
    public static KeyCode Joystick4Button16;
    public static KeyCode Joystick4Button17;
    public static KeyCode Joystick4Button18;
    public static KeyCode Joystick4Button19;
    public static KeyCode Joystick5Button0;
    public static KeyCode Joystick5Button1;
    public static KeyCode Joystick5Button2;
    public static KeyCode Joystick5Button3;
    public static KeyCode Joystick5Button4;
    public static KeyCode Joystick5Button5;
    public static KeyCode Joystick5Button6;
    public static KeyCode Joystick5Button7;
    public static KeyCode Joystick5Button8;
    public static KeyCode Joystick5Button9;
    public static KeyCode Joystick5Button10;
    public static KeyCode Joystick5Button11;
    public static KeyCode Joystick5Button12;
    public static KeyCode Joystick5Button13;
    public static KeyCode Joystick5Button14;
    public static KeyCode Joystick5Button15;
    public static KeyCode Joystick5Button16;
    public static KeyCode Joystick5Button17;
    public static KeyCode Joystick5Button18;
    public static KeyCode Joystick5Button19;
    public static KeyCode Joystick6Button0;
    public static KeyCode Joystick6Button1;
    public static KeyCode Joystick6Button2;
    public static KeyCode Joystick6Button3;
    public static KeyCode Joystick6Button4;
    public static KeyCode Joystick6Button5;
    public static KeyCode Joystick6Button6;
    public static KeyCode Joystick6Button7;
    public static KeyCode Joystick6Button8;
    public static KeyCode Joystick6Button9;
    public static KeyCode Joystick6Button10;
    public static KeyCode Joystick6Button11;
    public static KeyCode Joystick6Button12;
    public static KeyCode Joystick6Button13;
    public static KeyCode Joystick6Button14;
    public static KeyCode Joystick6Button15;
    public static KeyCode Joystick6Button16;
    public static KeyCode Joystick6Button17;
    public static KeyCode Joystick6Button18;
    public static KeyCode Joystick6Button19;
    public static KeyCode Joystick7Button0;
    public static KeyCode Joystick7Button1;
    public static KeyCode Joystick7Button2;
    public static KeyCode Joystick7Button3;
    public static KeyCode Joystick7Button4;
    public static KeyCode Joystick7Button5;
    public static KeyCode Joystick7Button6;
    public static KeyCode Joystick7Button7;
    public static KeyCode Joystick7Button8;
    public static KeyCode Joystick7Button9;
    public static KeyCode Joystick7Button10;
    public static KeyCode Joystick7Button11;
    public static KeyCode Joystick7Button12;
    public static KeyCode Joystick7Button13;
    public static KeyCode Joystick7Button14;
    public static KeyCode Joystick7Button15;
    public static KeyCode Joystick7Button16;
    public static KeyCode Joystick7Button17;
    public static KeyCode Joystick7Button18;
    public static KeyCode Joystick7Button19;
    public static KeyCode Joystick8Button0;
    public static KeyCode Joystick8Button1;
    public static KeyCode Joystick8Button2;
    public static KeyCode Joystick8Button3;
    public static KeyCode Joystick8Button4;
    public static KeyCode Joystick8Button5;
    public static KeyCode Joystick8Button6;
    public static KeyCode Joystick8Button7;
    public static KeyCode Joystick8Button8;
    public static KeyCode Joystick8Button9;
    public static KeyCode Joystick8Button10;
    public static KeyCode Joystick8Button11;
    public static KeyCode Joystick8Button12;
    public static KeyCode Joystick8Button13;
    public static KeyCode Joystick8Button14;
    public static KeyCode Joystick8Button15;
    public static KeyCode Joystick8Button16;
    public static KeyCode Joystick8Button17;
    public static KeyCode Joystick8Button18;
    public static KeyCode Joystick8Button19;
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Keyframe : ValueType {
    private float m_Time;
    private float m_Value;
    private float m_InTangent;
    private float m_OutTangent;
    private int m_WeightedMode;
    private float m_InWeight;
    private float m_OutWeight;
    public float time { get; public set; }
    public float value { get; public set; }
    public float inTangent { get; public set; }
    public float outTangent { get; public set; }
    public float inWeight { get; public set; }
    public float outWeight { get; public set; }
    public WeightedMode weightedMode { get; public set; }
    [ObsoleteAttribute("Use AnimationUtility.SetKeyLeftTangentMode, AnimationUtility.SetKeyRightTangentMode, AnimationUtility.GetKeyLeftTangentMode or AnimationUtility.GetKeyRightTangentMode instead.")]
public int tangentMode { get; public set; }
    internal int tangentModeInternal { get; internal set; }
    public Keyframe(float time, float value);
    public Keyframe(float time, float value, float inTangent, float outTangent);
    public Keyframe(float time, float value, float inTangent, float outTangent, float inWeight, float outWeight);
    public float get_time();
    public void set_time(float value);
    public float get_value();
    public void set_value(float value);
    public float get_inTangent();
    public void set_inTangent(float value);
    public float get_outTangent();
    public void set_outTangent(float value);
    public float get_inWeight();
    public void set_inWeight(float value);
    public float get_outWeight();
    public void set_outWeight(float value);
    public WeightedMode get_weightedMode();
    public void set_weightedMode(WeightedMode value);
    public int get_tangentMode();
    public void set_tangentMode(int value);
    internal int get_tangentModeInternal();
    internal void set_tangentModeInternal(int value);
}
[NativeClassAttribute("BitField", "struct BitField;")]
[NativeHeaderAttribute("Runtime/BaseClasses/TagManager.h")]
[NativeHeaderAttribute("Runtime/BaseClasses/BitField.h")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.LayerMask : ValueType {
    [NativeNameAttribute("m_Bits")]
private int m_Mask;
    public int value { get; public set; }
    public static int op_Implicit(LayerMask mask);
    public static LayerMask op_Implicit(int intVal);
    public int get_value();
    public void set_value(int value);
    [NativeMethodAttribute("LayerToString")]
[StaticAccessorAttribute("GetTagManager()", "0")]
public static string LayerToName(int layer);
    [StaticAccessorAttribute("GetTagManager()", "0")]
[NativeMethodAttribute("StringToLayer")]
public static int NameToLayer(string layerName);
    public static int GetMask(String[] layerNames);
}
public class UnityEngine.LazyLoadReference`1 : ValueType {
    private static int kInstanceID_None;
    [SerializeField]
private int m_InstanceID;
    public bool isSet { get; }
    public bool isBroken { get; }
    public T asset { get; public set; }
    public int instanceID { get; public set; }
    public LazyLoadReference`1(T asset);
    public LazyLoadReference`1(int instanceID);
    public bool get_isSet();
    public bool get_isBroken();
    public T get_asset();
    public void set_asset(T value);
    public int get_instanceID();
    public void set_instanceID(int value);
    public static LazyLoadReference`1<T> op_Implicit(T asset);
    public static LazyLoadReference`1<T> op_Implicit(int instanceID);
}
[NativeHeaderAttribute("Runtime/Camera/Flare.h")]
public class UnityEngine.LensFlare : Behaviour {
    public float brightness { get; public set; }
    public float fadeSpeed { get; public set; }
    public Color color { get; public set; }
    public Flare flare { get; public set; }
    public float get_brightness();
    public void set_brightness(float value);
    public float get_fadeSpeed();
    public void set_fadeSpeed(float value);
    public Color get_color();
    public void set_color(Color value);
    public Flare get_flare();
    public void set_flare(Flare value);
    private void get_color_Injected(Color& ret);
    private void set_color_Injected(Color& value);
}
[NativeHeaderAttribute("Runtime/Export/Graphics/Light.bindings.h")]
[RequireComponent("UnityEngine.Transform")]
[RequireComponent("UnityEngine.Transform")]
[NativeHeaderAttribute("Runtime/Camera/Light.h")]
public class UnityEngine.Light : Behaviour {
    private int m_BakedIndex;
    [NativePropertyAttribute("LightType")]
public LightType type { get; public set; }
    [NativePropertyAttribute("LightShape")]
public LightShape shape { get; public set; }
    public float spotAngle { get; public set; }
    public float innerSpotAngle { get; public set; }
    public Color color { get; public set; }
    public float colorTemperature { get; public set; }
    public bool useColorTemperature { get; public set; }
    public float intensity { get; public set; }
    public float bounceIntensity { get; public set; }
    public bool useBoundingSphereOverride { get; public set; }
    public Vector4 boundingSphereOverride { get; public set; }
    public bool useViewFrustumForShadowCasterCull { get; public set; }
    public int shadowCustomResolution { get; public set; }
    public float shadowBias { get; public set; }
    public float shadowNormalBias { get; public set; }
    public float shadowNearPlane { get; public set; }
    public bool useShadowMatrixOverride { get; public set; }
    public Matrix4x4 shadowMatrixOverride { get; public set; }
    public float range { get; public set; }
    public Flare flare { get; public set; }
    public LightBakingOutput bakingOutput { get; public set; }
    public int cullingMask { get; public set; }
    public int renderingLayerMask { get; public set; }
    public LightShadowCasterMode lightShadowCasterMode { get; public set; }
    public LightShadows shadows { get; public set; }
    public float shadowStrength { get; public set; }
    public LightShadowResolution shadowResolution { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Shadow softness is removed in Unity 5.0+", "True")]
public float shadowSoftness { get; public set; }
    [ObsoleteAttribute("Shadow softness is removed in Unity 5.0+", "True")]
[EditorBrowsableAttribute("1")]
public float shadowSoftnessFade { get; public set; }
    public Single[] layerShadowCullDistances { get; public set; }
    public float cookieSize { get; public set; }
    public Texture cookie { get; public set; }
    public LightRenderMode renderMode { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("warning bakedIndex has been removed please use bakingOutput.isBaked instead.", "True")]
public int bakedIndex { get; public set; }
    public int commandBufferCount { get; }
    [ObsoleteAttribute("Use QualitySettings.pixelLightCount instead.")]
public static int pixelLightCount { get; public set; }
    [ObsoleteAttribute("light.shadowConstantBias was removed, use light.shadowBias", "True")]
public float shadowConstantBias { get; public set; }
    [ObsoleteAttribute("light.shadowObjectSizeBias was removed, use light.shadowBias", "True")]
public float shadowObjectSizeBias { get; public set; }
    [ObsoleteAttribute("light.attenuate was removed; all lights always attenuate now", "True")]
public bool attenuate { get; public set; }
    public LightType get_type();
    public void set_type(LightType value);
    public LightShape get_shape();
    public void set_shape(LightShape value);
    public float get_spotAngle();
    public void set_spotAngle(float value);
    public float get_innerSpotAngle();
    public void set_innerSpotAngle(float value);
    public Color get_color();
    public void set_color(Color value);
    public float get_colorTemperature();
    public void set_colorTemperature(float value);
    public bool get_useColorTemperature();
    public void set_useColorTemperature(bool value);
    public float get_intensity();
    public void set_intensity(float value);
    public float get_bounceIntensity();
    public void set_bounceIntensity(float value);
    public bool get_useBoundingSphereOverride();
    public void set_useBoundingSphereOverride(bool value);
    public Vector4 get_boundingSphereOverride();
    public void set_boundingSphereOverride(Vector4 value);
    public bool get_useViewFrustumForShadowCasterCull();
    public void set_useViewFrustumForShadowCasterCull(bool value);
    public int get_shadowCustomResolution();
    public void set_shadowCustomResolution(int value);
    public float get_shadowBias();
    public void set_shadowBias(float value);
    public float get_shadowNormalBias();
    public void set_shadowNormalBias(float value);
    public float get_shadowNearPlane();
    public void set_shadowNearPlane(float value);
    public bool get_useShadowMatrixOverride();
    public void set_useShadowMatrixOverride(bool value);
    public Matrix4x4 get_shadowMatrixOverride();
    public void set_shadowMatrixOverride(Matrix4x4 value);
    public float get_range();
    public void set_range(float value);
    public Flare get_flare();
    public void set_flare(Flare value);
    public LightBakingOutput get_bakingOutput();
    public void set_bakingOutput(LightBakingOutput value);
    public int get_cullingMask();
    public void set_cullingMask(int value);
    public int get_renderingLayerMask();
    public void set_renderingLayerMask(int value);
    public LightShadowCasterMode get_lightShadowCasterMode();
    public void set_lightShadowCasterMode(LightShadowCasterMode value);
    public void Reset();
    [NativeMethodAttribute("GetShadowType")]
public LightShadows get_shadows();
    [FreeFunctionAttribute("Light_Bindings::SetShadowType")]
public void set_shadows(LightShadows value);
    public float get_shadowStrength();
    [FreeFunctionAttribute("Light_Bindings::SetShadowStrength")]
public void set_shadowStrength(float value);
    public LightShadowResolution get_shadowResolution();
    [FreeFunctionAttribute("Light_Bindings::SetShadowResolution")]
public void set_shadowResolution(LightShadowResolution value);
    public float get_shadowSoftness();
    public void set_shadowSoftness(float value);
    public float get_shadowSoftnessFade();
    public void set_shadowSoftnessFade(float value);
    [FreeFunctionAttribute("Light_Bindings::GetLayerShadowCullDistances")]
public Single[] get_layerShadowCullDistances();
    [FreeFunctionAttribute("Light_Bindings::SetLayerShadowCullDistances")]
public void set_layerShadowCullDistances(Single[] value);
    public float get_cookieSize();
    public void set_cookieSize(float value);
    public Texture get_cookie();
    public void set_cookie(Texture value);
    public LightRenderMode get_renderMode();
    [FreeFunctionAttribute("Light_Bindings::SetRenderMode")]
public void set_renderMode(LightRenderMode value);
    public int get_bakedIndex();
    public void set_bakedIndex(int value);
    public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer);
    [FreeFunctionAttribute("Light_Bindings::AddCommandBuffer")]
public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask);
    public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ComputeQueueType queueType);
    [FreeFunctionAttribute("Light_Bindings::AddCommandBufferAsync")]
public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask, ComputeQueueType queueType);
    public void RemoveCommandBuffer(LightEvent evt, CommandBuffer buffer);
    public void RemoveCommandBuffers(LightEvent evt);
    public void RemoveAllCommandBuffers();
    [FreeFunctionAttribute("Light_Bindings::GetCommandBuffers")]
public CommandBuffer[] GetCommandBuffers(LightEvent evt);
    public int get_commandBufferCount();
    public static int get_pixelLightCount();
    public static void set_pixelLightCount(int value);
    [ObsoleteAttribute("Light.GetLights has been deprecated, use FindObjectsOfType in combination with light.cullingmask/light.type", "False")]
[FreeFunctionAttribute("Light_Bindings::GetLights")]
public static Light[] GetLights(LightType type, int layer);
    public float get_shadowConstantBias();
    public void set_shadowConstantBias(float value);
    public float get_shadowObjectSizeBias();
    public void set_shadowObjectSizeBias(float value);
    public bool get_attenuate();
    public void set_attenuate(bool value);
    private void get_color_Injected(Color& ret);
    private void set_color_Injected(Color& value);
    private void get_boundingSphereOverride_Injected(Vector4& ret);
    private void set_boundingSphereOverride_Injected(Vector4& value);
    private void get_shadowMatrixOverride_Injected(Matrix4x4& ret);
    private void set_shadowMatrixOverride_Injected(Matrix4x4& value);
    private void get_bakingOutput_Injected(LightBakingOutput& ret);
    private void set_bakingOutput_Injected(LightBakingOutput& value);
}
[NativeHeaderAttribute("Runtime/Camera/SharedLightData.h")]
public class UnityEngine.LightBakingOutput : ValueType {
    public int probeOcclusionLightIndex;
    public int occlusionMaskChannel;
    [NativeNameAttribute("lightmapBakeMode.lightmapBakeType")]
public LightmapBakeType lightmapBakeType;
    [NativeNameAttribute("lightmapBakeMode.mixedLightingMode")]
public MixedLightingMode mixedLightingMode;
    public bool isBaked;
}
[NativeHeaderAttribute("Runtime/Graphics/LightingSettings.h")]
[PreventReadOnlyInstanceModificationAttribute]
public class UnityEngine.LightingSettings : Object {
    [NativeNameAttribute("EnableBakedLightmaps")]
public bool bakedGI { get; public set; }
    [NativeNameAttribute("EnableRealtimeLightmaps")]
public bool realtimeGI { get; public set; }
    [NativeNameAttribute("RealtimeEnvironmentLighting")]
public bool realtimeEnvironmentLighting { get; public set; }
    [RequiredByNativeCodeAttribute]
internal void LightingSettingsDontStripMe();
    private static void Internal_Create(LightingSettings self);
    public bool get_bakedGI();
    public void set_bakedGI(bool value);
    public bool get_realtimeGI();
    public void set_realtimeGI(bool value);
    public bool get_realtimeEnvironmentLighting();
    public void set_realtimeEnvironmentLighting(bool value);
}
[FlagsAttribute]
public enum UnityEngine.LightmapBakeType : Enum {
    public int value__;
    public static LightmapBakeType Realtime;
    public static LightmapBakeType Baked;
    public static LightmapBakeType Mixed;
}
public enum UnityEngine.LightmapCompression : Enum {
    public int value__;
    public static LightmapCompression None;
    public static LightmapCompression LowQuality;
    public static LightmapCompression NormalQuality;
    public static LightmapCompression HighQuality;
}
[NativeHeaderAttribute("Runtime/Graphics/LightmapData.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.LightmapData : object {
    internal Texture2D m_Light;
    internal Texture2D m_Dir;
    internal Texture2D m_ShadowMask;
    [ObsoleteAttribute("Use lightmapColor property (UnityUpgradable) -> lightmapColor", "False")]
public Texture2D lightmapLight { get; public set; }
    public Texture2D lightmapColor { get; public set; }
    public Texture2D lightmapDir { get; public set; }
    public Texture2D shadowMask { get; public set; }
    public Texture2D get_lightmapLight();
    public void set_lightmapLight(Texture2D value);
    public Texture2D get_lightmapColor();
    public void set_lightmapColor(Texture2D value);
    public Texture2D get_lightmapDir();
    public void set_lightmapDir(Texture2D value);
    public Texture2D get_shadowMask();
    public void set_shadowMask(Texture2D value);
}
[StaticAccessorAttribute("GetLightmapSettings()")]
[NativeHeaderAttribute("Runtime/Graphics/LightmapSettings.h")]
public class UnityEngine.LightmapSettings : Object {
    public static LightmapData[] lightmaps { get; public set; }
    public static LightmapsMode lightmapsMode { get; public set; }
    public static LightProbes lightProbes { get; public set; }
    [ObsoleteAttribute("Use lightmapsMode instead.", "False")]
public static LightmapsModeLegacy lightmapsModeLegacy { get; public set; }
    [ObsoleteAttribute("Use QualitySettings.desiredColorSpace instead.", "False")]
public static ColorSpace bakedColorSpace { get; public set; }
    [FreeFunctionAttribute]
public static LightmapData[] get_lightmaps();
    [FreeFunctionAttribute]
public static void set_lightmaps(LightmapData[] value);
    public static LightmapsMode get_lightmapsMode();
    [FreeFunctionAttribute]
public static void set_lightmapsMode(LightmapsMode value);
    public static LightProbes get_lightProbes();
    [NativeNameAttribute("SetLightProbes")]
[FreeFunctionAttribute]
public static void set_lightProbes(LightProbes value);
    [NativeNameAttribute("ResetAndAwakeFromLoad")]
internal static void Reset();
    public static LightmapsModeLegacy get_lightmapsModeLegacy();
    public static void set_lightmapsModeLegacy(LightmapsModeLegacy value);
    public static ColorSpace get_bakedColorSpace();
    public static void set_bakedColorSpace(ColorSpace value);
}
[FlagsAttribute]
public enum UnityEngine.LightmapsMode : Enum {
    public int value__;
    public static LightmapsMode NonDirectional;
    public static LightmapsMode CombinedDirectional;
}
public enum UnityEngine.LightmapsModeLegacy : Enum {
    public int value__;
    public static LightmapsModeLegacy Single;
    public static LightmapsModeLegacy Dual;
    public static LightmapsModeLegacy Directional;
}
[NativeHeaderAttribute("Runtime/Graphics/LightProbeGroup.h")]
public class UnityEngine.LightProbeGroup : Behaviour {
    public Vector3[] probePositions { get; }
    public Vector3[] get_probePositions();
}
[NativeHeaderAttribute("Runtime/Camera/LightProbeProxyVolume.h")]
public class UnityEngine.LightProbeProxyVolume : Behaviour {
    public static bool isFeatureSupported { get; }
    [NativeNameAttribute("GlobalAABB")]
public Bounds boundsGlobal { get; }
    [NativeNameAttribute("BoundingBoxSizeCustom")]
public Vector3 sizeCustom { get; public set; }
    [NativeNameAttribute("BoundingBoxOriginCustom")]
public Vector3 originCustom { get; public set; }
    public float probeDensity { get; public set; }
    public int gridResolutionX { get; public set; }
    public int gridResolutionY { get; public set; }
    public int gridResolutionZ { get; public set; }
    public BoundingBoxMode boundingBoxMode { get; public set; }
    public ResolutionMode resolutionMode { get; public set; }
    public ProbePositionMode probePositionMode { get; public set; }
    public RefreshMode refreshMode { get; public set; }
    public QualityMode qualityMode { get; public set; }
    public DataFormat dataFormat { get; public set; }
    [NativeNameAttribute("IsFeatureSupported")]
public static bool get_isFeatureSupported();
    public Bounds get_boundsGlobal();
    public Vector3 get_sizeCustom();
    public void set_sizeCustom(Vector3 value);
    public Vector3 get_originCustom();
    public void set_originCustom(Vector3 value);
    public float get_probeDensity();
    public void set_probeDensity(float value);
    public int get_gridResolutionX();
    public void set_gridResolutionX(int value);
    public int get_gridResolutionY();
    public void set_gridResolutionY(int value);
    public int get_gridResolutionZ();
    public void set_gridResolutionZ(int value);
    public BoundingBoxMode get_boundingBoxMode();
    public void set_boundingBoxMode(BoundingBoxMode value);
    public ResolutionMode get_resolutionMode();
    public void set_resolutionMode(ResolutionMode value);
    public ProbePositionMode get_probePositionMode();
    public void set_probePositionMode(ProbePositionMode value);
    public RefreshMode get_refreshMode();
    public void set_refreshMode(RefreshMode value);
    public QualityMode get_qualityMode();
    public void set_qualityMode(QualityMode value);
    public DataFormat get_dataFormat();
    public void set_dataFormat(DataFormat value);
    public void Update();
    private void SetDirtyFlag(bool flag);
    private void get_boundsGlobal_Injected(Bounds& ret);
    private void get_sizeCustom_Injected(Vector3& ret);
    private void set_sizeCustom_Injected(Vector3& value);
    private void get_originCustom_Injected(Vector3& ret);
    private void set_originCustom_Injected(Vector3& value);
}
[NativeHeaderAttribute("Runtime/Export/Graphics/Graphics.bindings.h")]
public class UnityEngine.LightProbes : Object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action lightProbesUpdated;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action tetrahedralizationCompleted;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action needsRetetrahedralization;
    public Vector3[] positions { get; }
    public SphericalHarmonicsL2[] bakedProbes { get; public set; }
    public int count { get; }
    public int cellCount { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use bakedProbes instead.", "True")]
public Single[] coefficients { get; public set; }
    [CompilerGeneratedAttribute]
public static void add_lightProbesUpdated(Action value);
    [CompilerGeneratedAttribute]
public static void remove_lightProbesUpdated(Action value);
    [RequiredByNativeCodeAttribute]
private static void Internal_CallLightProbesUpdatedFunction();
    [CompilerGeneratedAttribute]
public static void add_tetrahedralizationCompleted(Action value);
    [CompilerGeneratedAttribute]
public static void remove_tetrahedralizationCompleted(Action value);
    [RequiredByNativeCodeAttribute]
private static void Internal_CallTetrahedralizationCompletedFunction();
    [CompilerGeneratedAttribute]
public static void add_needsRetetrahedralization(Action value);
    [CompilerGeneratedAttribute]
public static void remove_needsRetetrahedralization(Action value);
    [RequiredByNativeCodeAttribute]
private static void Internal_CallNeedsRetetrahedralizationFunction();
    [FreeFunctionAttribute]
public static void Tetrahedralize();
    [FreeFunctionAttribute]
public static void TetrahedralizeAsync();
    [FreeFunctionAttribute]
public static void GetInterpolatedProbe(Vector3 position, Renderer renderer, SphericalHarmonicsL2& probe);
    [FreeFunctionAttribute]
internal static bool AreLightProbesAllowed(Renderer renderer);
    public static void CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes);
    public static void CalculateInterpolatedLightAndOcclusionProbes(List`1<Vector3> positions, List`1<SphericalHarmonicsL2> lightProbes, List`1<Vector4> occlusionProbes);
    [NativeNameAttribute("CalculateInterpolatedLightAndOcclusionProbes")]
[FreeFunctionAttribute]
internal static void CalculateInterpolatedLightAndOcclusionProbes_Internal(Vector3[] positions, int positionsCount, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes);
    [FreeFunctionAttribute]
[NativeNameAttribute("GetLightProbePositions")]
public Vector3[] get_positions();
    [FreeFunctionAttribute]
[NativeNameAttribute("GetBakedCoefficients")]
public SphericalHarmonicsL2[] get_bakedProbes();
    [NativeNameAttribute("SetBakedCoefficients")]
[FreeFunctionAttribute]
public void set_bakedProbes(SphericalHarmonicsL2[] value);
    [NativeNameAttribute("GetLightProbeCount")]
[FreeFunctionAttribute]
public int get_count();
    [FreeFunctionAttribute]
[NativeNameAttribute("GetTetrahedraSize")]
public int get_cellCount();
    [NativeNameAttribute("GetLightProbeCount")]
[FreeFunctionAttribute]
internal static int GetCount();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetInterpolatedProbe instead.", "True")]
public void GetInterpolatedLightProbe(Vector3 position, Renderer renderer, Single[] coefficients);
    public Single[] get_coefficients();
    public void set_coefficients(Single[] value);
    private static void GetInterpolatedProbe_Injected(Vector3& position, Renderer renderer, SphericalHarmonicsL2& probe);
}
[NativeContainerAttribute]
[NativeHeaderAttribute("Runtime/Camera/RenderLoops/LightProbeContext.h")]
[StaticAccessorAttribute("LightProbeContextWrapper", "2")]
public class UnityEngine.LightProbesQuery : ValueType {
    [NativeDisableUnsafePtrRestrictionAttribute]
internal IntPtr m_LightProbeContextWrapper;
    internal Allocator m_AllocatorLabel;
    public bool IsCreated { get; }
    public LightProbesQuery(Allocator allocator);
    public sealed virtual void Dispose();
    public JobHandle Dispose(JobHandle inputDeps);
    public bool get_IsCreated();
    private static IntPtr Create();
    [ThreadSafeAttribute]
private static void Destroy(IntPtr lightProbeContextWrapper);
    public void CalculateInterpolatedLightAndOcclusionProbe(Vector3 position, Int32& tetrahedronIndex, SphericalHarmonicsL2& lightProbe, Vector4& occlusionProbe);
    public void CalculateInterpolatedLightAndOcclusionProbes(NativeArray`1<Vector3> positions, NativeArray`1<int> tetrahedronIndices, NativeArray`1<SphericalHarmonicsL2> lightProbes, NativeArray`1<Vector4> occlusionProbes);
    [ThreadSafeAttribute]
private static void CalculateInterpolatedLightAndOcclusionProbe(IntPtr lightProbeContextWrapper, Vector3 position, Int32& tetrahedronIndex, SphericalHarmonicsL2& lightProbe, Vector4& occlusionProbe);
    [ThreadSafeAttribute]
private static void CalculateInterpolatedLightAndOcclusionProbes(IntPtr lightProbeContextWrapper, IntPtr positions, IntPtr tetrahedronIndices, IntPtr lightProbes, IntPtr occlusionProbes, int count);
    private static void CalculateInterpolatedLightAndOcclusionProbe_Injected(IntPtr lightProbeContextWrapper, Vector3& position, Int32& tetrahedronIndex, SphericalHarmonicsL2& lightProbe, Vector4& occlusionProbe);
}
public enum UnityEngine.LightRenderMode : Enum {
    public int value__;
    public static LightRenderMode Auto;
    public static LightRenderMode ForcePixel;
    public static LightRenderMode ForceVertex;
}
[NativeHeaderAttribute("Runtime/Camera/SharedLightData.h")]
public enum UnityEngine.LightShadowCasterMode : Enum {
    public int value__;
    public static LightShadowCasterMode Default;
    public static LightShadowCasterMode NonLightmappedOnly;
    public static LightShadowCasterMode Everything;
}
public enum UnityEngine.LightShadows : Enum {
    public int value__;
    public static LightShadows None;
    public static LightShadows Hard;
    public static LightShadows Soft;
}
public enum UnityEngine.LightShape : Enum {
    public int value__;
    public static LightShape Cone;
    public static LightShape Pyramid;
    public static LightShape Box;
}
public enum UnityEngine.LightType : Enum {
    public int value__;
    public static LightType Spot;
    public static LightType Directional;
    public static LightType Point;
    public static LightType Area;
    public static LightType Rectangle;
    public static LightType Disc;
}
public enum UnityEngine.LineAlignment : Enum {
    public int value__;
    public static LineAlignment View;
    [ObsoleteAttribute("Enum member Local has been deprecated. Use TransformZ instead (UnityUpgradable) -> TransformZ", "False")]
public static LineAlignment Local;
    public static LineAlignment TransformZ;
}
[NativeHeaderAttribute("Runtime/Graphics/LineRenderer.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public class UnityEngine.LineRenderer : Renderer {
    [ObsoleteAttribute("Use positionCount instead (UnityUpgradable) -> positionCount", "False")]
public int numPositions { get; public set; }
    public float startWidth { get; public set; }
    public float endWidth { get; public set; }
    public float widthMultiplier { get; public set; }
    public int numCornerVertices { get; public set; }
    public int numCapVertices { get; public set; }
    public bool useWorldSpace { get; public set; }
    public bool loop { get; public set; }
    public Color startColor { get; public set; }
    public Color endColor { get; public set; }
    [NativePropertyAttribute("PositionsCount")]
public int positionCount { get; public set; }
    public Vector2 textureScale { get; public set; }
    public float shadowBias { get; public set; }
    public bool generateLightingData { get; public set; }
    public LineTextureMode textureMode { get; public set; }
    public LineAlignment alignment { get; public set; }
    public SpriteMaskInteraction maskInteraction { get; public set; }
    public AnimationCurve widthCurve { get; public set; }
    public Gradient colorGradient { get; public set; }
    [ObsoleteAttribute("Use startWidth, endWidth or widthCurve instead.", "False")]
public void SetWidth(float start, float end);
    [ObsoleteAttribute("Use startColor, endColor or colorGradient instead.", "False")]
public void SetColors(Color start, Color end);
    [ObsoleteAttribute("Use positionCount instead.", "False")]
public void SetVertexCount(int count);
    public int get_numPositions();
    public void set_numPositions(int value);
    public float get_startWidth();
    public void set_startWidth(float value);
    public float get_endWidth();
    public void set_endWidth(float value);
    public float get_widthMultiplier();
    public void set_widthMultiplier(float value);
    public int get_numCornerVertices();
    public void set_numCornerVertices(int value);
    public int get_numCapVertices();
    public void set_numCapVertices(int value);
    public bool get_useWorldSpace();
    public void set_useWorldSpace(bool value);
    public bool get_loop();
    public void set_loop(bool value);
    public Color get_startColor();
    public void set_startColor(Color value);
    public Color get_endColor();
    public void set_endColor(Color value);
    public int get_positionCount();
    public void set_positionCount(int value);
    public void SetPosition(int index, Vector3 position);
    public Vector3 GetPosition(int index);
    public Vector2 get_textureScale();
    public void set_textureScale(Vector2 value);
    public float get_shadowBias();
    public void set_shadowBias(float value);
    public bool get_generateLightingData();
    public void set_generateLightingData(bool value);
    public LineTextureMode get_textureMode();
    public void set_textureMode(LineTextureMode value);
    public LineAlignment get_alignment();
    public void set_alignment(LineAlignment value);
    public SpriteMaskInteraction get_maskInteraction();
    public void set_maskInteraction(SpriteMaskInteraction value);
    public void Simplify(float tolerance);
    public void BakeMesh(Mesh mesh, bool useTransform);
    public void BakeMesh(Mesh mesh, Camera camera, bool useTransform);
    public AnimationCurve get_widthCurve();
    public void set_widthCurve(AnimationCurve value);
    public Gradient get_colorGradient();
    public void set_colorGradient(Gradient value);
    private AnimationCurve GetWidthCurveCopy();
    private void SetWidthCurve(AnimationCurve curve);
    private Gradient GetColorGradientCopy();
    private void SetColorGradient(Gradient curve);
    [FreeFunctionAttribute]
public int GetPositions(Vector3[] positions);
    [FreeFunctionAttribute]
public void SetPositions(Vector3[] positions);
    public void SetPositions(NativeArray`1<Vector3> positions);
    public void SetPositions(NativeSlice`1<Vector3> positions);
    public int GetPositions(NativeArray`1<Vector3> positions);
    public int GetPositions(NativeSlice`1<Vector3> positions);
    [FreeFunctionAttribute]
private void SetPositionsWithNativeContainer(IntPtr positions, int count);
    [FreeFunctionAttribute]
private int GetPositionsWithNativeContainer(IntPtr positions, int length);
    private void get_startColor_Injected(Color& ret);
    private void set_startColor_Injected(Color& value);
    private void get_endColor_Injected(Color& ret);
    private void set_endColor_Injected(Color& value);
    private void SetPosition_Injected(int index, Vector3& position);
    private void GetPosition_Injected(int index, Vector3& ret);
    private void get_textureScale_Injected(Vector2& ret);
    private void set_textureScale_Injected(Vector2& value);
}
public enum UnityEngine.LineTextureMode : Enum {
    public int value__;
    public static LineTextureMode Stretch;
    public static LineTextureMode Tile;
    public static LineTextureMode DistributePerSegment;
    public static LineTextureMode RepeatPerSegment;
    public static LineTextureMode Static;
}
[NativeHeaderAttribute("Runtime/Export/Graphics/LineUtility.bindings.h")]
public class UnityEngine.LineUtility : object {
    public static void Simplify(List`1<Vector3> points, float tolerance, List`1<int> pointsToKeep);
    public static void Simplify(List`1<Vector3> points, float tolerance, List`1<Vector3> simplifiedPoints);
    public static void Simplify(List`1<Vector2> points, float tolerance, List`1<int> pointsToKeep);
    public static void Simplify(List`1<Vector2> points, float tolerance, List`1<Vector2> simplifiedPoints);
    [FreeFunctionAttribute("LineUtility_Bindings::GeneratePointsToKeep3D")]
internal static void GeneratePointsToKeep3D(object pointsList, float tolerance, object pointsToKeepList);
    [FreeFunctionAttribute("LineUtility_Bindings::GeneratePointsToKeep2D")]
internal static void GeneratePointsToKeep2D(object pointsList, float tolerance, object pointsToKeepList);
    [FreeFunctionAttribute("LineUtility_Bindings::GenerateSimplifiedPoints3D")]
internal static void GenerateSimplifiedPoints3D(object pointsList, float tolerance, object simplifiedPoints);
    [FreeFunctionAttribute("LineUtility_Bindings::GenerateSimplifiedPoints2D")]
internal static void GenerateSimplifiedPoints2D(object pointsList, float tolerance, object simplifiedPoints);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.LOD : ValueType {
    public float screenRelativeTransitionHeight;
    public float fadeTransitionWidth;
    public Renderer[] renderers;
    public LOD(float screenRelativeTransitionHeight, Renderer[] renderers);
}
public enum UnityEngine.LODFadeMode : Enum {
    public int value__;
    public static LODFadeMode None;
    public static LODFadeMode CrossFade;
    public static LODFadeMode SpeedTree;
}
[NativeHeaderAttribute("Runtime/Graphics/LOD/LODGroup.h")]
[NativeHeaderAttribute("Runtime/Graphics/LOD/LODUtility.h")]
[StaticAccessorAttribute("GetLODGroupManager()", "0")]
[NativeHeaderAttribute("Runtime/Graphics/LOD/LODGroupManager.h")]
public class UnityEngine.LODGroup : Component {
    public Vector3 localReferencePoint { get; public set; }
    public float size { get; public set; }
    public int lodCount { get; }
    public bool lastLODBillboard { get; public set; }
    public LODFadeMode fadeMode { get; public set; }
    public bool animateCrossFading { get; public set; }
    public bool enabled { get; public set; }
    [StaticAccessorAttribute("GetLODGroupManager()")]
public static float crossFadeAnimationDuration { get; public set; }
    internal Vector3 worldReferencePoint { get; }
    public Vector3 get_localReferencePoint();
    public void set_localReferencePoint(Vector3 value);
    public float get_size();
    public void set_size(float value);
    [NativeMethodAttribute("GetLODCount")]
public int get_lodCount();
    [NativeMethodAttribute("GetLastLODIsBillboard")]
public bool get_lastLODBillboard();
    [NativeMethodAttribute("SetLastLODIsBillboard")]
public void set_lastLODBillboard(bool value);
    public LODFadeMode get_fadeMode();
    public void set_fadeMode(LODFadeMode value);
    public bool get_animateCrossFading();
    public void set_animateCrossFading(bool value);
    public bool get_enabled();
    public void set_enabled(bool value);
    [FreeFunctionAttribute("UpdateLODGroupBoundingBox")]
public void RecalculateBounds();
    [FreeFunctionAttribute("GetLODs_Binding")]
public LOD[] GetLODs();
    [ObsoleteAttribute("Use SetLODs instead.")]
public void SetLODS(LOD[] lods);
    [FreeFunctionAttribute("SetLODs_Binding")]
public void SetLODs(LOD[] lods);
    [FreeFunctionAttribute("ForceLODLevel")]
public void ForceLOD(int index);
    public static float get_crossFadeAnimationDuration();
    public static void set_crossFadeAnimationDuration(float value);
    internal Vector3 get_worldReferencePoint();
    private void get_localReferencePoint_Injected(Vector3& ret);
    private void set_localReferencePoint_Injected(Vector3& value);
    private void get_worldReferencePoint_Injected(Vector3& ret);
}
public class UnityEngine.Logger : object {
    private static string kNoTagFormat;
    private static string kTagFormat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ILogHandler <logHandler>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <logEnabled>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private LogType <filterLogType>k__BackingField;
    public ILogHandler logHandler { get; public set; }
    public bool logEnabled { get; public set; }
    public LogType filterLogType { get; public set; }
    public Logger(ILogHandler logHandler);
    [CompilerGeneratedAttribute]
public sealed virtual ILogHandler get_logHandler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_logHandler(ILogHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_logEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_logEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual LogType get_filterLogType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_filterLogType(LogType value);
    public sealed virtual bool IsLogTypeAllowed(LogType logType);
    private static string GetString(object message);
    public sealed virtual void Log(LogType logType, object message);
    public sealed virtual void Log(LogType logType, object message, Object context);
    public sealed virtual void Log(LogType logType, string tag, object message);
    public sealed virtual void Log(LogType logType, string tag, object message, Object context);
    public sealed virtual void Log(object message);
    public sealed virtual void Log(string tag, object message);
    public sealed virtual void Log(string tag, object message, Object context);
    public sealed virtual void LogWarning(string tag, object message);
    public sealed virtual void LogWarning(string tag, object message, Object context);
    public sealed virtual void LogError(string tag, object message);
    public sealed virtual void LogError(string tag, object message, Object context);
    public sealed virtual void LogException(Exception exception);
    public sealed virtual void LogException(Exception exception, Object context);
    public sealed virtual void LogFormat(LogType logType, string format, Object[] args);
    public sealed virtual void LogFormat(LogType logType, Object context, string format, Object[] args);
}
public enum UnityEngine.LogOption : Enum {
    public int value__;
    public static LogOption None;
    public static LogOption NoStacktrace;
}
public enum UnityEngine.LogType : Enum {
    public int value__;
    public static LogType Error;
    public static LogType Assert;
    public static LogType Warning;
    public static LogType Log;
    public static LogType Exception;
}
internal class UnityEngine.LowerResBlitTexture : Object {
    [RequiredByNativeCodeAttribute]
internal void LowerResBlitTextureDontStripMe();
}
[MovedFromAttribute("UnityEngine.Experimental.LowLevel")]
public class UnityEngine.LowLevel.PlayerLoop : object {
    public static PlayerLoopSystem GetDefaultPlayerLoop();
    public static PlayerLoopSystem GetCurrentPlayerLoop();
    public static void SetPlayerLoop(PlayerLoopSystem loop);
    private static int PlayerLoopSystemToInternal(PlayerLoopSystem sys, List`1& internalSys);
    private static PlayerLoopSystem InternalToPlayerLoopSystem(PlayerLoopSystemInternal[] internalSys, Int32& offset);
    [NativeMethodAttribute]
private static PlayerLoopSystemInternal[] GetDefaultPlayerLoopInternal();
    [NativeMethodAttribute]
private static PlayerLoopSystemInternal[] GetCurrentPlayerLoopInternal();
    [NativeMethodAttribute]
private static void SetPlayerLoopInternal(PlayerLoopSystemInternal[] loop);
}
[MovedFromAttribute("UnityEngine.Experimental.LowLevel")]
public class UnityEngine.LowLevel.PlayerLoopSystem : ValueType {
    public Type type;
    public PlayerLoopSystem[] subSystemList;
    public UpdateFunction updateDelegate;
    public IntPtr updateFunction;
    public IntPtr loopConditionFunction;
    public virtual string ToString();
}
[RequiredByNativeCodeAttribute]
[NativeTypeAttribute]
[MovedFromAttribute("UnityEngine.Experimental.LowLevel")]
internal class UnityEngine.LowLevel.PlayerLoopSystemInternal : ValueType {
    public Type type;
    public UpdateFunction updateDelegate;
    public IntPtr updateFunction;
    public IntPtr loopConditionFunction;
    public int numSubSystems;
}
[AttributeUsageAttribute("4")]
[ObsoleteAttribute("Lumin is no longer supported in Unity 2022.2")]
public class UnityEngine.Lumin.UsesLuminPlatformLevelAttribute : Attribute {
    private UInt32 m_PlatformLevel;
    public UInt32 platformLevel { get; }
    public UsesLuminPlatformLevelAttribute(UInt32 platformLevel);
    public UInt32 get_platformLevel();
}
[ObsoleteAttribute("Lumin is no longer supported in Unity 2022.2")]
[AttributeUsageAttribute("4")]
public class UnityEngine.Lumin.UsesLuminPrivilegeAttribute : Attribute {
    private string m_Privilege;
    public string privilege { get; }
    public UsesLuminPrivilegeAttribute(string privilege);
    public string get_privilege();
}
internal static class UnityEngine.ManagedStreamHelpers : object {
    internal static void ValidateLoadFromStream(Stream stream);
    [RequiredByNativeCodeAttribute]
internal static void ManagedStreamRead(Byte[] buffer, int offset, int count, Stream stream, IntPtr returnValueAddress);
    [RequiredByNativeCodeAttribute]
internal static void ManagedStreamSeek(long offset, UInt32 origin, Stream stream, IntPtr returnValueAddress);
    [RequiredByNativeCodeAttribute]
internal static void ManagedStreamLength(Stream stream, IntPtr returnValueAddress);
}
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/Material.h")]
public class UnityEngine.Material : Object {
    public Shader shader { get; public set; }
    public Color color { get; public set; }
    public Texture mainTexture { get; public set; }
    public Vector2 mainTextureOffset { get; public set; }
    public Vector2 mainTextureScale { get; public set; }
    public int renderQueue { get; public set; }
    internal int rawRenderQueue { get; }
    public LocalKeyword[] enabledKeywords { get; public set; }
    public MaterialGlobalIlluminationFlags globalIlluminationFlags { get; public set; }
    public bool doubleSidedGI { get; public set; }
    [NativePropertyAttribute("EnableInstancingVariants")]
public bool enableInstancing { get; public set; }
    public int passCount { get; }
    public String[] shaderKeywords { get; public set; }
    public Material(Shader shader);
    [RequiredByNativeCodeAttribute]
public Material(Material source);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Creating materials from shader source string is no longer supported. Use Shader assets instead.", "False")]
public Material(string contents);
    [ObsoleteAttribute("Creating materials from shader source string will be removed in the future. Use Shader assets instead.", "False")]
public static Material Create(string scriptContents);
    [FreeFunctionAttribute("MaterialScripting::CreateWithShader")]
private static void CreateWithShader(Material self, Shader shader);
    [FreeFunctionAttribute("MaterialScripting::CreateWithMaterial")]
private static void CreateWithMaterial(Material self, Material source);
    [FreeFunctionAttribute("MaterialScripting::CreateWithString")]
private static void CreateWithString(Material self);
    internal static Material GetDefaultMaterial();
    internal static Material GetDefaultParticleMaterial();
    internal static Material GetDefaultLineMaterial();
    public Shader get_shader();
    public void set_shader(Shader value);
    public Color get_color();
    public void set_color(Color value);
    public Texture get_mainTexture();
    public void set_mainTexture(Texture value);
    public Vector2 get_mainTextureOffset();
    public void set_mainTextureOffset(Vector2 value);
    public Vector2 get_mainTextureScale();
    public void set_mainTextureScale(Vector2 value);
    [NativeNameAttribute("GetFirstPropertyNameIdByAttributeFromScript")]
private int GetFirstPropertyNameIdByAttribute(ShaderPropertyFlags attributeFlag);
    [NativeNameAttribute("HasPropertyFromScript")]
public bool HasProperty(int nameID);
    public bool HasProperty(string name);
    [NativeNameAttribute("HasFloatFromScript")]
private bool HasFloatImpl(int name);
    public bool HasFloat(string name);
    public bool HasFloat(int nameID);
    public bool HasInt(string name);
    public bool HasInt(int nameID);
    [NativeNameAttribute("HasIntegerFromScript")]
private bool HasIntImpl(int name);
    public bool HasInteger(string name);
    public bool HasInteger(int nameID);
    [NativeNameAttribute("HasTextureFromScript")]
private bool HasTextureImpl(int name);
    public bool HasTexture(string name);
    public bool HasTexture(int nameID);
    [NativeNameAttribute("HasMatrixFromScript")]
private bool HasMatrixImpl(int name);
    public bool HasMatrix(string name);
    public bool HasMatrix(int nameID);
    [NativeNameAttribute("HasVectorFromScript")]
private bool HasVectorImpl(int name);
    public bool HasVector(string name);
    public bool HasVector(int nameID);
    public bool HasColor(string name);
    public bool HasColor(int nameID);
    [NativeNameAttribute("HasBufferFromScript")]
private bool HasBufferImpl(int name);
    public bool HasBuffer(string name);
    public bool HasBuffer(int nameID);
    [NativeNameAttribute("HasConstantBufferFromScript")]
private bool HasConstantBufferImpl(int name);
    public bool HasConstantBuffer(string name);
    public bool HasConstantBuffer(int nameID);
    [NativeNameAttribute("GetActualRenderQueue")]
public int get_renderQueue();
    [NativeNameAttribute("SetCustomRenderQueue")]
public void set_renderQueue(int value);
    [NativeNameAttribute("GetCustomRenderQueue")]
internal int get_rawRenderQueue();
    public void EnableKeyword(string keyword);
    public void DisableKeyword(string keyword);
    public bool IsKeywordEnabled(string keyword);
    [FreeFunctionAttribute("MaterialScripting::EnableKeyword")]
private void EnableLocalKeyword(LocalKeyword keyword);
    [FreeFunctionAttribute("MaterialScripting::DisableKeyword")]
private void DisableLocalKeyword(LocalKeyword keyword);
    [FreeFunctionAttribute("MaterialScripting::SetKeyword")]
private void SetLocalKeyword(LocalKeyword keyword, bool value);
    [FreeFunctionAttribute("MaterialScripting::IsKeywordEnabled")]
private bool IsLocalKeywordEnabled(LocalKeyword keyword);
    public void EnableKeyword(LocalKeyword& keyword);
    public void DisableKeyword(LocalKeyword& keyword);
    public void SetKeyword(LocalKeyword& keyword, bool value);
    public bool IsKeywordEnabled(LocalKeyword& keyword);
    [FreeFunctionAttribute("MaterialScripting::GetEnabledKeywords")]
private LocalKeyword[] GetEnabledKeywords();
    [FreeFunctionAttribute("MaterialScripting::SetEnabledKeywords")]
private void SetEnabledKeywords(LocalKeyword[] keywords);
    public LocalKeyword[] get_enabledKeywords();
    public void set_enabledKeywords(LocalKeyword[] value);
    public MaterialGlobalIlluminationFlags get_globalIlluminationFlags();
    public void set_globalIlluminationFlags(MaterialGlobalIlluminationFlags value);
    public bool get_doubleSidedGI();
    public void set_doubleSidedGI(bool value);
    public bool get_enableInstancing();
    public void set_enableInstancing(bool value);
    [NativeNameAttribute("GetShader()->GetPassCount")]
public int get_passCount();
    [FreeFunctionAttribute("MaterialScripting::SetShaderPassEnabled")]
public void SetShaderPassEnabled(string passName, bool enabled);
    [FreeFunctionAttribute("MaterialScripting::GetShaderPassEnabled")]
public bool GetShaderPassEnabled(string passName);
    public string GetPassName(int pass);
    public int FindPass(string passName);
    public void SetOverrideTag(string tag, string val);
    [NativeNameAttribute("GetTag")]
private string GetTagImpl(string tag, bool currentSubShaderOnly, string defaultValue);
    public string GetTag(string tag, bool searchFallbacks, string defaultValue);
    public string GetTag(string tag, bool searchFallbacks);
    [NativeThrowsAttribute]
[FreeFunctionAttribute("MaterialScripting::Lerp")]
public void Lerp(Material start, Material end, float t);
    [FreeFunctionAttribute("MaterialScripting::SetPass")]
public bool SetPass(int pass);
    [FreeFunctionAttribute("MaterialScripting::CopyPropertiesFrom")]
public void CopyPropertiesFromMaterial(Material mat);
    [FreeFunctionAttribute("MaterialScripting::CopyMatchingPropertiesFrom")]
public void CopyMatchingPropertiesFromMaterial(Material mat);
    [FreeFunctionAttribute("MaterialScripting::GetShaderKeywords")]
private String[] GetShaderKeywords();
    [FreeFunctionAttribute("MaterialScripting::SetShaderKeywords")]
private void SetShaderKeywords(String[] names);
    public String[] get_shaderKeywords();
    public void set_shaderKeywords(String[] value);
    [FreeFunctionAttribute("MaterialScripting::GetPropertyNames")]
private String[] GetPropertyNamesImpl(int propertyType);
    public int ComputeCRC();
    [FreeFunctionAttribute("MaterialScripting::GetTexturePropertyNames")]
public String[] GetTexturePropertyNames();
    [FreeFunctionAttribute("MaterialScripting::GetTexturePropertyNameIDs")]
public Int32[] GetTexturePropertyNameIDs();
    [FreeFunctionAttribute("MaterialScripting::GetTexturePropertyNamesInternal")]
private void GetTexturePropertyNamesInternal(object outNames);
    [FreeFunctionAttribute("MaterialScripting::GetTexturePropertyNameIDsInternal")]
private void GetTexturePropertyNameIDsInternal(object outNames);
    public void GetTexturePropertyNames(List`1<string> outNames);
    public void GetTexturePropertyNameIDs(List`1<int> outNames);
    [NativeNameAttribute("SetIntFromScript")]
private void SetIntImpl(int name, int value);
    [NativeNameAttribute("SetFloatFromScript")]
private void SetFloatImpl(int name, float value);
    [NativeNameAttribute("SetColorFromScript")]
private void SetColorImpl(int name, Color value);
    [NativeNameAttribute("SetMatrixFromScript")]
private void SetMatrixImpl(int name, Matrix4x4 value);
    [NativeNameAttribute("SetTextureFromScript")]
private void SetTextureImpl(int name, Texture value);
    [NativeNameAttribute("SetRenderTextureFromScript")]
private void SetRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element);
    [NativeNameAttribute("SetBufferFromScript")]
private void SetBufferImpl(int name, ComputeBuffer value);
    [NativeNameAttribute("SetBufferFromScript")]
private void SetGraphicsBufferImpl(int name, GraphicsBuffer value);
    [NativeNameAttribute("SetConstantBufferFromScript")]
private void SetConstantBufferImpl(int name, ComputeBuffer value, int offset, int size);
    [NativeNameAttribute("SetConstantBufferFromScript")]
private void SetConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size);
    [NativeNameAttribute("GetIntFromScript")]
private int GetIntImpl(int name);
    [NativeNameAttribute("GetFloatFromScript")]
private float GetFloatImpl(int name);
    [NativeNameAttribute("GetColorFromScript")]
private Color GetColorImpl(int name);
    [NativeNameAttribute("GetMatrixFromScript")]
private Matrix4x4 GetMatrixImpl(int name);
    [NativeNameAttribute("GetTextureFromScript")]
private Texture GetTextureImpl(int name);
    [NativeNameAttribute("GetBufferFromScript")]
private GraphicsBufferHandle GetBufferImpl(int name);
    [NativeNameAttribute("GetConstantBufferFromScript")]
private GraphicsBufferHandle GetConstantBufferImpl(int name);
    [FreeFunctionAttribute]
private void SetFloatArrayImpl(int name, Single[] values, int count);
    [FreeFunctionAttribute]
private void SetVectorArrayImpl(int name, Vector4[] values, int count);
    [FreeFunctionAttribute]
private void SetColorArrayImpl(int name, Color[] values, int count);
    [FreeFunctionAttribute]
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count);
    [FreeFunctionAttribute]
private Single[] GetFloatArrayImpl(int name);
    [FreeFunctionAttribute]
private Vector4[] GetVectorArrayImpl(int name);
    [FreeFunctionAttribute]
private Color[] GetColorArrayImpl(int name);
    [FreeFunctionAttribute]
private Matrix4x4[] GetMatrixArrayImpl(int name);
    [FreeFunctionAttribute]
private int GetFloatArrayCountImpl(int name);
    [FreeFunctionAttribute]
private int GetVectorArrayCountImpl(int name);
    [FreeFunctionAttribute]
private int GetColorArrayCountImpl(int name);
    [FreeFunctionAttribute]
private int GetMatrixArrayCountImpl(int name);
    [FreeFunctionAttribute]
private void ExtractFloatArrayImpl(int name, Single[] val);
    [FreeFunctionAttribute]
private void ExtractVectorArrayImpl(int name, Vector4[] val);
    [FreeFunctionAttribute]
private void ExtractColorArrayImpl(int name, Color[] val);
    [FreeFunctionAttribute]
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val);
    [NativeNameAttribute("GetTextureScaleAndOffsetFromScript")]
private Vector4 GetTextureScaleAndOffsetImpl(int name);
    [NativeNameAttribute("SetTextureOffsetFromScript")]
private void SetTextureOffsetImpl(int name, Vector2 offset);
    [NativeNameAttribute("SetTextureScaleFromScript")]
private void SetTextureScaleImpl(int name, Vector2 scale);
    private void SetFloatArray(int name, Single[] values, int count);
    private void SetVectorArray(int name, Vector4[] values, int count);
    private void SetColorArray(int name, Color[] values, int count);
    private void SetMatrixArray(int name, Matrix4x4[] values, int count);
    private void ExtractFloatArray(int name, List`1<float> values);
    private void ExtractVectorArray(int name, List`1<Vector4> values);
    private void ExtractColorArray(int name, List`1<Color> values);
    private void ExtractMatrixArray(int name, List`1<Matrix4x4> values);
    public void SetInt(string name, int value);
    public void SetInt(int nameID, int value);
    public void SetFloat(string name, float value);
    public void SetFloat(int nameID, float value);
    public void SetInteger(string name, int value);
    public void SetInteger(int nameID, int value);
    public void SetColor(string name, Color value);
    public void SetColor(int nameID, Color value);
    public void SetVector(string name, Vector4 value);
    public void SetVector(int nameID, Vector4 value);
    public void SetMatrix(string name, Matrix4x4 value);
    public void SetMatrix(int nameID, Matrix4x4 value);
    public void SetTexture(string name, Texture value);
    public void SetTexture(int nameID, Texture value);
    public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element);
    public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
    public void SetBuffer(string name, ComputeBuffer value);
    public void SetBuffer(int nameID, ComputeBuffer value);
    public void SetBuffer(string name, GraphicsBuffer value);
    public void SetBuffer(int nameID, GraphicsBuffer value);
    public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size);
    public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
    public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
    public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
    public void SetFloatArray(string name, List`1<float> values);
    public void SetFloatArray(int nameID, List`1<float> values);
    public void SetFloatArray(string name, Single[] values);
    public void SetFloatArray(int nameID, Single[] values);
    public void SetColorArray(string name, List`1<Color> values);
    public void SetColorArray(int nameID, List`1<Color> values);
    public void SetColorArray(string name, Color[] values);
    public void SetColorArray(int nameID, Color[] values);
    public void SetVectorArray(string name, List`1<Vector4> values);
    public void SetVectorArray(int nameID, List`1<Vector4> values);
    public void SetVectorArray(string name, Vector4[] values);
    public void SetVectorArray(int nameID, Vector4[] values);
    public void SetMatrixArray(string name, List`1<Matrix4x4> values);
    public void SetMatrixArray(int nameID, List`1<Matrix4x4> values);
    public void SetMatrixArray(string name, Matrix4x4[] values);
    public void SetMatrixArray(int nameID, Matrix4x4[] values);
    public int GetInt(string name);
    public int GetInt(int nameID);
    public float GetFloat(string name);
    public float GetFloat(int nameID);
    public int GetInteger(string name);
    public int GetInteger(int nameID);
    public Color GetColor(string name);
    public Color GetColor(int nameID);
    public Vector4 GetVector(string name);
    public Vector4 GetVector(int nameID);
    public Matrix4x4 GetMatrix(string name);
    public Matrix4x4 GetMatrix(int nameID);
    public Texture GetTexture(string name);
    public Texture GetTexture(int nameID);
    public GraphicsBufferHandle GetBuffer(string name);
    public GraphicsBufferHandle GetConstantBuffer(string name);
    public Single[] GetFloatArray(string name);
    public Single[] GetFloatArray(int nameID);
    public Color[] GetColorArray(string name);
    public Color[] GetColorArray(int nameID);
    public Vector4[] GetVectorArray(string name);
    public Vector4[] GetVectorArray(int nameID);
    public Matrix4x4[] GetMatrixArray(string name);
    public Matrix4x4[] GetMatrixArray(int nameID);
    public void GetFloatArray(string name, List`1<float> values);
    public void GetFloatArray(int nameID, List`1<float> values);
    public void GetColorArray(string name, List`1<Color> values);
    public void GetColorArray(int nameID, List`1<Color> values);
    public void GetVectorArray(string name, List`1<Vector4> values);
    public void GetVectorArray(int nameID, List`1<Vector4> values);
    public void GetMatrixArray(string name, List`1<Matrix4x4> values);
    public void GetMatrixArray(int nameID, List`1<Matrix4x4> values);
    public void SetTextureOffset(string name, Vector2 value);
    public void SetTextureOffset(int nameID, Vector2 value);
    public void SetTextureScale(string name, Vector2 value);
    public void SetTextureScale(int nameID, Vector2 value);
    public Vector2 GetTextureOffset(string name);
    public Vector2 GetTextureOffset(int nameID);
    public Vector2 GetTextureScale(string name);
    public Vector2 GetTextureScale(int nameID);
    public String[] GetPropertyNames(MaterialPropertyType type);
    private void EnableLocalKeyword_Injected(LocalKeyword& keyword);
    private void DisableLocalKeyword_Injected(LocalKeyword& keyword);
    private void SetLocalKeyword_Injected(LocalKeyword& keyword, bool value);
    private bool IsLocalKeywordEnabled_Injected(LocalKeyword& keyword);
    private void SetColorImpl_Injected(int name, Color& value);
    private void SetMatrixImpl_Injected(int name, Matrix4x4& value);
    private void GetColorImpl_Injected(int name, Color& ret);
    private void GetMatrixImpl_Injected(int name, Matrix4x4& ret);
    private void GetBufferImpl_Injected(int name, GraphicsBufferHandle& ret);
    private void GetConstantBufferImpl_Injected(int name, GraphicsBufferHandle& ret);
    private void GetTextureScaleAndOffsetImpl_Injected(int name, Vector4& ret);
    private void SetTextureOffsetImpl_Injected(int name, Vector2& offset);
    private void SetTextureScaleImpl_Injected(int name, Vector2& scale);
}
[FlagsAttribute]
public enum UnityEngine.MaterialGlobalIlluminationFlags : Enum {
    public int value__;
    public static MaterialGlobalIlluminationFlags None;
    public static MaterialGlobalIlluminationFlags RealtimeEmissive;
    public static MaterialGlobalIlluminationFlags BakedEmissive;
    public static MaterialGlobalIlluminationFlags EmissiveIsBlack;
    public static MaterialGlobalIlluminationFlags AnyEmissive;
}
[NativeHeaderAttribute("Runtime/Math/SphericalHarmonicsL2.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/ShaderPropertySheet.h")]
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
public class UnityEngine.MaterialPropertyBlock : object {
    internal IntPtr m_Ptr;
    public bool isEmpty { get; }
    [ObsoleteAttribute("Use SetFloat instead (UnityUpgradable) -> SetFloat(*)", "False")]
public void AddFloat(string name, float value);
    [ObsoleteAttribute("Use SetFloat instead (UnityUpgradable) -> SetFloat(*)", "False")]
public void AddFloat(int nameID, float value);
    [ObsoleteAttribute("Use SetVector instead (UnityUpgradable) -> SetVector(*)", "False")]
public void AddVector(string name, Vector4 value);
    [ObsoleteAttribute("Use SetVector instead (UnityUpgradable) -> SetVector(*)", "False")]
public void AddVector(int nameID, Vector4 value);
    [ObsoleteAttribute("Use SetColor instead (UnityUpgradable) -> SetColor(*)", "False")]
public void AddColor(string name, Color value);
    [ObsoleteAttribute("Use SetColor instead (UnityUpgradable) -> SetColor(*)", "False")]
public void AddColor(int nameID, Color value);
    [ObsoleteAttribute("Use SetMatrix instead (UnityUpgradable) -> SetMatrix(*)", "False")]
public void AddMatrix(string name, Matrix4x4 value);
    [ObsoleteAttribute("Use SetMatrix instead (UnityUpgradable) -> SetMatrix(*)", "False")]
public void AddMatrix(int nameID, Matrix4x4 value);
    [ObsoleteAttribute("Use SetTexture instead (UnityUpgradable) -> SetTexture(*)", "False")]
public void AddTexture(string name, Texture value);
    [ObsoleteAttribute("Use SetTexture instead (UnityUpgradable) -> SetTexture(*)", "False")]
public void AddTexture(int nameID, Texture value);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetIntFromScript")]
private int GetIntImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetFloatFromScript")]
private float GetFloatImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetVectorFromScript")]
private Vector4 GetVectorImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetColorFromScript")]
private Color GetColorImpl(int name);
    [NativeNameAttribute("GetMatrixFromScript")]
[ThreadSafeAttribute]
private Matrix4x4 GetMatrixImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetTextureFromScript")]
private Texture GetTextureImpl(int name);
    [NativeNameAttribute("HasPropertyFromScript")]
private bool HasPropertyImpl(int name);
    [NativeNameAttribute("HasFloatFromScript")]
private bool HasFloatImpl(int name);
    [NativeNameAttribute("HasIntegerFromScript")]
private bool HasIntImpl(int name);
    [NativeNameAttribute("HasTextureFromScript")]
private bool HasTextureImpl(int name);
    [NativeNameAttribute("HasMatrixFromScript")]
private bool HasMatrixImpl(int name);
    [NativeNameAttribute("HasVectorFromScript")]
private bool HasVectorImpl(int name);
    [NativeNameAttribute("HasBufferFromScript")]
private bool HasBufferImpl(int name);
    [NativeNameAttribute("HasConstantBufferFromScript")]
private bool HasConstantBufferImpl(int name);
    [NativeNameAttribute("SetIntFromScript")]
[ThreadSafeAttribute]
private void SetIntImpl(int name, int value);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetFloatFromScript")]
private void SetFloatImpl(int name, float value);
    [NativeNameAttribute("SetVectorFromScript")]
[ThreadSafeAttribute]
private void SetVectorImpl(int name, Vector4 value);
    [NativeNameAttribute("SetColorFromScript")]
[ThreadSafeAttribute]
private void SetColorImpl(int name, Color value);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetMatrixFromScript")]
private void SetMatrixImpl(int name, Matrix4x4 value);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetTextureFromScript")]
private void SetTextureImpl(int name, Texture value);
    [NativeNameAttribute("SetRenderTextureFromScript")]
[ThreadSafeAttribute]
private void SetRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element);
    [NativeNameAttribute("SetBufferFromScript")]
[ThreadSafeAttribute]
private void SetBufferImpl(int name, ComputeBuffer value);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetBufferFromScript")]
private void SetGraphicsBufferImpl(int name, GraphicsBuffer value);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetConstantBufferFromScript")]
private void SetConstantBufferImpl(int name, ComputeBuffer value, int offset, int size);
    [NativeNameAttribute("SetConstantBufferFromScript")]
[ThreadSafeAttribute]
private void SetConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetFloatArrayFromScript")]
private void SetFloatArrayImpl(int name, Single[] values, int count);
    [NativeNameAttribute("SetVectorArrayFromScript")]
[ThreadSafeAttribute]
private void SetVectorArrayImpl(int name, Vector4[] values, int count);
    [ThreadSafeAttribute]
[NativeNameAttribute("SetMatrixArrayFromScript")]
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetFloatArrayFromScript")]
private Single[] GetFloatArrayImpl(int name);
    [NativeNameAttribute("GetVectorArrayFromScript")]
[ThreadSafeAttribute]
private Vector4[] GetVectorArrayImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetMatrixArrayFromScript")]
private Matrix4x4[] GetMatrixArrayImpl(int name);
    [NativeNameAttribute("GetFloatArrayCountFromScript")]
[ThreadSafeAttribute]
private int GetFloatArrayCountImpl(int name);
    [ThreadSafeAttribute]
[NativeNameAttribute("GetVectorArrayCountFromScript")]
private int GetVectorArrayCountImpl(int name);
    [NativeNameAttribute("GetMatrixArrayCountFromScript")]
[ThreadSafeAttribute]
private int GetMatrixArrayCountImpl(int name);
    [NativeNameAttribute("ExtractFloatArrayFromScript")]
[ThreadSafeAttribute]
private void ExtractFloatArrayImpl(int name, Single[] val);
    [ThreadSafeAttribute]
[NativeNameAttribute("ExtractVectorArrayFromScript")]
private void ExtractVectorArrayImpl(int name, Vector4[] val);
    [NativeNameAttribute("ExtractMatrixArrayFromScript")]
[ThreadSafeAttribute]
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("ConvertAndCopySHCoefficientArraysToPropertySheetFromScript")]
internal static void Internal_CopySHCoefficientArraysFrom(MaterialPropertyBlock properties, SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count);
    [ThreadSafeAttribute]
[FreeFunctionAttribute("CopyProbeOcclusionArrayToPropertySheetFromScript")]
internal static void Internal_CopyProbeOcclusionArrayFrom(MaterialPropertyBlock properties, Vector4[] occlusionProbes, int sourceStart, int destStart, int count);
    [NativeMethodAttribute]
private static IntPtr CreateImpl();
    [NativeMethodAttribute]
private static void DestroyImpl(IntPtr mpb);
    [ThreadSafeAttribute]
[NativeNameAttribute("IsEmpty")]
public bool get_isEmpty();
    [ThreadSafeAttribute]
private void Clear(bool keepMemory);
    public void Clear();
    private void SetFloatArray(int name, Single[] values, int count);
    private void SetVectorArray(int name, Vector4[] values, int count);
    private void SetMatrixArray(int name, Matrix4x4[] values, int count);
    private void ExtractFloatArray(int name, List`1<float> values);
    private void ExtractVectorArray(int name, List`1<Vector4> values);
    private void ExtractMatrixArray(int name, List`1<Matrix4x4> values);
    protected virtual override void Finalize();
    private void Dispose();
    public void SetInt(string name, int value);
    public void SetInt(int nameID, int value);
    public void SetFloat(string name, float value);
    public void SetFloat(int nameID, float value);
    public void SetInteger(string name, int value);
    public void SetInteger(int nameID, int value);
    public void SetVector(string name, Vector4 value);
    public void SetVector(int nameID, Vector4 value);
    public void SetColor(string name, Color value);
    public void SetColor(int nameID, Color value);
    public void SetMatrix(string name, Matrix4x4 value);
    public void SetMatrix(int nameID, Matrix4x4 value);
    public void SetBuffer(string name, ComputeBuffer value);
    public void SetBuffer(int nameID, ComputeBuffer value);
    public void SetBuffer(string name, GraphicsBuffer value);
    public void SetBuffer(int nameID, GraphicsBuffer value);
    public void SetTexture(string name, Texture value);
    public void SetTexture(int nameID, Texture value);
    public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element);
    public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
    public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size);
    public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
    public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
    public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
    public void SetFloatArray(string name, List`1<float> values);
    public void SetFloatArray(int nameID, List`1<float> values);
    public void SetFloatArray(string name, Single[] values);
    public void SetFloatArray(int nameID, Single[] values);
    public void SetVectorArray(string name, List`1<Vector4> values);
    public void SetVectorArray(int nameID, List`1<Vector4> values);
    public void SetVectorArray(string name, Vector4[] values);
    public void SetVectorArray(int nameID, Vector4[] values);
    public void SetMatrixArray(string name, List`1<Matrix4x4> values);
    public void SetMatrixArray(int nameID, List`1<Matrix4x4> values);
    public void SetMatrixArray(string name, Matrix4x4[] values);
    public void SetMatrixArray(int nameID, Matrix4x4[] values);
    public bool HasProperty(string name);
    public bool HasProperty(int nameID);
    public bool HasInt(string name);
    public bool HasInt(int nameID);
    public bool HasFloat(string name);
    public bool HasFloat(int nameID);
    public bool HasInteger(string name);
    public bool HasInteger(int nameID);
    public bool HasTexture(string name);
    public bool HasTexture(int nameID);
    public bool HasMatrix(string name);
    public bool HasMatrix(int nameID);
    public bool HasVector(string name);
    public bool HasVector(int nameID);
    public bool HasColor(string name);
    public bool HasColor(int nameID);
    public bool HasBuffer(string name);
    public bool HasBuffer(int nameID);
    public bool HasConstantBuffer(string name);
    public bool HasConstantBuffer(int nameID);
    public float GetFloat(string name);
    public float GetFloat(int nameID);
    public int GetInt(string name);
    public int GetInt(int nameID);
    public int GetInteger(string name);
    public int GetInteger(int nameID);
    public Vector4 GetVector(string name);
    public Vector4 GetVector(int nameID);
    public Color GetColor(string name);
    public Color GetColor(int nameID);
    public Matrix4x4 GetMatrix(string name);
    public Matrix4x4 GetMatrix(int nameID);
    public Texture GetTexture(string name);
    public Texture GetTexture(int nameID);
    public Single[] GetFloatArray(string name);
    public Single[] GetFloatArray(int nameID);
    public Vector4[] GetVectorArray(string name);
    public Vector4[] GetVectorArray(int nameID);
    public Matrix4x4[] GetMatrixArray(string name);
    public Matrix4x4[] GetMatrixArray(int nameID);
    public void GetFloatArray(string name, List`1<float> values);
    public void GetFloatArray(int nameID, List`1<float> values);
    public void GetVectorArray(string name, List`1<Vector4> values);
    public void GetVectorArray(int nameID, List`1<Vector4> values);
    public void GetMatrixArray(string name, List`1<Matrix4x4> values);
    public void GetMatrixArray(int nameID, List`1<Matrix4x4> values);
    public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes);
    public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes);
    public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes, int sourceStart, int destStart, int count);
    public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count);
    public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes);
    public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes);
    public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes, int sourceStart, int destStart, int count);
    public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes, int sourceStart, int destStart, int count);
    private void GetVectorImpl_Injected(int name, Vector4& ret);
    private void GetColorImpl_Injected(int name, Color& ret);
    private void GetMatrixImpl_Injected(int name, Matrix4x4& ret);
    private void SetVectorImpl_Injected(int name, Vector4& value);
    private void SetColorImpl_Injected(int name, Color& value);
    private void SetMatrixImpl_Injected(int name, Matrix4x4& value);
}
public enum UnityEngine.MaterialPropertyType : Enum {
    public int value__;
    public static MaterialPropertyType Float;
    public static MaterialPropertyType Int;
    public static MaterialPropertyType Vector;
    public static MaterialPropertyType Matrix;
    public static MaterialPropertyType Texture;
    public static MaterialPropertyType ConstantBuffer;
    public static MaterialPropertyType ComputeBuffer;
}
internal enum UnityEngine.MaterialSerializedProperty : Enum {
    public int value__;
    public static MaterialSerializedProperty None;
    public static MaterialSerializedProperty LightmapFlags;
    public static MaterialSerializedProperty EnableInstancingVariants;
    public static MaterialSerializedProperty DoubleSidedGI;
    public static MaterialSerializedProperty CustomRenderQueue;
}
[NativeHeaderAttribute("Runtime/Utilities/BitUtility.h")]
[Il2CppEagerStaticClassConstructionAttribute]
[NativeHeaderAttribute("Runtime/Math/ColorSpaceConversion.h")]
[NativeHeaderAttribute("Runtime/Math/FloatConversion.h")]
[NativeHeaderAttribute("Runtime/Math/PerlinNoise.h")]
public class UnityEngine.Mathf : ValueType {
    public static float PI;
    public static float Infinity;
    public static float NegativeInfinity;
    public static float Deg2Rad;
    public static float Rad2Deg;
    internal static int kMaxDecimals;
    public static float Epsilon;
    private static Mathf();
    [FreeFunctionAttribute]
public static int ClosestPowerOfTwo(int value);
    [FreeFunctionAttribute]
public static bool IsPowerOfTwo(int value);
    [FreeFunctionAttribute]
public static int NextPowerOfTwo(int value);
    [FreeFunctionAttribute]
public static float GammaToLinearSpace(float value);
    [FreeFunctionAttribute]
public static float LinearToGammaSpace(float value);
    [FreeFunctionAttribute]
public static Color CorrelatedColorTemperatureToRGB(float kelvin);
    [FreeFunctionAttribute]
public static ushort FloatToHalf(float val);
    [FreeFunctionAttribute]
public static float HalfToFloat(ushort val);
    [FreeFunctionAttribute("PerlinNoise::NoiseNormalized")]
public static float PerlinNoise(float x, float y);
    [FreeFunctionAttribute("PerlinNoise::NoiseNormalized")]
public static float PerlinNoise1D(float x);
    public static float Sin(float f);
    public static float Cos(float f);
    public static float Tan(float f);
    public static float Asin(float f);
    public static float Acos(float f);
    public static float Atan(float f);
    public static float Atan2(float y, float x);
    public static float Sqrt(float f);
    public static float Abs(float f);
    public static int Abs(int value);
    public static float Min(float a, float b);
    public static float Min(Single[] values);
    public static int Min(int a, int b);
    public static int Min(Int32[] values);
    public static float Max(float a, float b);
    public static float Max(Single[] values);
    public static int Max(int a, int b);
    public static int Max(Int32[] values);
    public static float Pow(float f, float p);
    public static float Exp(float power);
    public static float Log(float f, float p);
    public static float Log(float f);
    public static float Log10(float f);
    public static float Ceil(float f);
    public static float Floor(float f);
    public static float Round(float f);
    public static int CeilToInt(float f);
    public static int FloorToInt(float f);
    public static int RoundToInt(float f);
    public static float Sign(float f);
    public static float Clamp(float value, float min, float max);
    public static int Clamp(int value, int min, int max);
    public static float Clamp01(float value);
    public static float Lerp(float a, float b, float t);
    public static float LerpUnclamped(float a, float b, float t);
    public static float LerpAngle(float a, float b, float t);
    public static float MoveTowards(float current, float target, float maxDelta);
    public static float MoveTowardsAngle(float current, float target, float maxDelta);
    public static float SmoothStep(float from, float to, float t);
    public static float Gamma(float value, float absmax, float gamma);
    public static bool Approximately(float a, float b);
    [ExcludeFromDocsAttribute]
public static float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed);
    [ExcludeFromDocsAttribute]
public static float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime);
    public static float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime);
    [ExcludeFromDocsAttribute]
public static float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed);
    [ExcludeFromDocsAttribute]
public static float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime);
    public static float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime);
    public static float Repeat(float t, float length);
    public static float PingPong(float t, float length);
    public static float InverseLerp(float a, float b, float value);
    public static float DeltaAngle(float current, float target);
    internal static bool LineIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result);
    internal static bool LineSegmentIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result);
    internal static long RandomToLong(Random r);
    internal static float ClampToFloat(double value);
    internal static int ClampToInt(long value);
    internal static UInt32 ClampToUInt(long value);
    internal static float RoundToMultipleOf(float value, float roundingValue);
    internal static float GetClosestPowerOfTen(float positiveNumber);
    internal static int GetNumberOfDecimalsForMinimumDifference(float minDifference);
    internal static int GetNumberOfDecimalsForMinimumDifference(double minDifference);
    internal static float RoundBasedOnMinimumDifference(float valueToRound, float minDifference);
    internal static double RoundBasedOnMinimumDifference(double valueToRound, double minDifference);
    internal static float DiscardLeastSignificantDecimal(float v);
    internal static double DiscardLeastSignificantDecimal(double v);
    private static void CorrelatedColorTemperatureToRGB_Injected(float kelvin, Color& ret);
}
[Il2CppEagerStaticClassConstructionAttribute]
[NativeClassAttribute("Matrix4x4f")]
[NativeTypeAttribute]
[DefaultMemberAttribute("Item")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Math/MathScripting.h")]
public class UnityEngine.Matrix4x4 : ValueType {
    [NativeNameAttribute("m_Data[0]")]
public float m00;
    [NativeNameAttribute("m_Data[1]")]
public float m10;
    [NativeNameAttribute("m_Data[2]")]
public float m20;
    [NativeNameAttribute("m_Data[3]")]
public float m30;
    [NativeNameAttribute("m_Data[4]")]
public float m01;
    [NativeNameAttribute("m_Data[5]")]
public float m11;
    [NativeNameAttribute("m_Data[6]")]
public float m21;
    [NativeNameAttribute("m_Data[7]")]
public float m31;
    [NativeNameAttribute("m_Data[8]")]
public float m02;
    [NativeNameAttribute("m_Data[9]")]
public float m12;
    [NativeNameAttribute("m_Data[10]")]
public float m22;
    [NativeNameAttribute("m_Data[11]")]
public float m32;
    [NativeNameAttribute("m_Data[12]")]
public float m03;
    [NativeNameAttribute("m_Data[13]")]
public float m13;
    [NativeNameAttribute("m_Data[14]")]
public float m23;
    [NativeNameAttribute("m_Data[15]")]
public float m33;
    private static Matrix4x4 zeroMatrix;
    private static Matrix4x4 identityMatrix;
    public Quaternion rotation { get; }
    public Vector3 lossyScale { get; }
    public bool isIdentity { get; }
    public float determinant { get; }
    public FrustumPlanes decomposeProjection { get; }
    public Matrix4x4 inverse { get; }
    public Matrix4x4 transpose { get; }
    public float Item { get; public set; }
    public float Item { get; public set; }
    public static Matrix4x4 zero { get; }
    public static Matrix4x4 identity { get; }
    public Matrix4x4(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3);
    private static Matrix4x4();
    [ThreadSafeAttribute]
private Quaternion GetRotation();
    [ThreadSafeAttribute]
private Vector3 GetLossyScale();
    [ThreadSafeAttribute]
private bool IsIdentity();
    [ThreadSafeAttribute]
private float GetDeterminant();
    [ThreadSafeAttribute]
private FrustumPlanes DecomposeProjection();
    public Quaternion get_rotation();
    public Vector3 get_lossyScale();
    public bool get_isIdentity();
    public float get_determinant();
    public FrustumPlanes get_decomposeProjection();
    [ThreadSafeAttribute]
public bool ValidTRS();
    public static float Determinant(Matrix4x4 m);
    [FreeFunctionAttribute("MatrixScripting::TRS")]
public static Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s);
    public void SetTRS(Vector3 pos, Quaternion q, Vector3 s);
    [FreeFunctionAttribute("MatrixScripting::Inverse3DAffine")]
public static bool Inverse3DAffine(Matrix4x4 input, Matrix4x4& result);
    [FreeFunctionAttribute("MatrixScripting::Inverse")]
public static Matrix4x4 Inverse(Matrix4x4 m);
    public Matrix4x4 get_inverse();
    [FreeFunctionAttribute("MatrixScripting::Transpose")]
public static Matrix4x4 Transpose(Matrix4x4 m);
    public Matrix4x4 get_transpose();
    [FreeFunctionAttribute("MatrixScripting::Ortho")]
public static Matrix4x4 Ortho(float left, float right, float bottom, float top, float zNear, float zFar);
    [FreeFunctionAttribute("MatrixScripting::Perspective")]
public static Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar);
    [FreeFunctionAttribute("MatrixScripting::LookAt")]
public static Matrix4x4 LookAt(Vector3 from, Vector3 to, Vector3 up);
    [FreeFunctionAttribute("MatrixScripting::Frustum")]
public static Matrix4x4 Frustum(float left, float right, float bottom, float top, float zNear, float zFar);
    public static Matrix4x4 Frustum(FrustumPlanes fp);
    [FreeFunctionAttribute("MatrixScripting::Internal_CompareApproximately")]
internal static bool CompareApproximately(Matrix4x4 a, Matrix4x4 b, float threshold);
    public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Matrix4x4 other);
    public static Matrix4x4 op_Multiply(Matrix4x4 lhs, Matrix4x4 rhs);
    public static Vector4 op_Multiply(Matrix4x4 lhs, Vector4 vector);
    public static bool op_Equality(Matrix4x4 lhs, Matrix4x4 rhs);
    public static bool op_Inequality(Matrix4x4 lhs, Matrix4x4 rhs);
    public Vector4 GetColumn(int index);
    public Vector4 GetRow(int index);
    public Vector3 GetPosition();
    public void SetColumn(int index, Vector4 column);
    public void SetRow(int index, Vector4 row);
    public Vector3 MultiplyPoint(Vector3 point);
    public Vector3 MultiplyPoint3x4(Vector3 point);
    public Vector3 MultiplyVector(Vector3 vector);
    public Plane TransformPlane(Plane plane);
    public static Matrix4x4 Scale(Vector3 vector);
    public static Matrix4x4 Translate(Vector3 vector);
    public static Matrix4x4 Rotate(Quaternion q);
    public static Matrix4x4 get_zero();
    public static Matrix4x4 get_identity();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private static void GetRotation_Injected(Matrix4x4& _unity_self, Quaternion& ret);
    private static void GetLossyScale_Injected(Matrix4x4& _unity_self, Vector3& ret);
    private static bool IsIdentity_Injected(Matrix4x4& _unity_self);
    private static float GetDeterminant_Injected(Matrix4x4& _unity_self);
    private static void DecomposeProjection_Injected(Matrix4x4& _unity_self, FrustumPlanes& ret);
    private static bool ValidTRS_Injected(Matrix4x4& _unity_self);
    private static void TRS_Injected(Vector3& pos, Quaternion& q, Vector3& s, Matrix4x4& ret);
    private static bool Inverse3DAffine_Injected(Matrix4x4& input, Matrix4x4& result);
    private static void Inverse_Injected(Matrix4x4& m, Matrix4x4& ret);
    private static void Transpose_Injected(Matrix4x4& m, Matrix4x4& ret);
    private static void Ortho_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret);
    private static void Perspective_Injected(float fov, float aspect, float zNear, float zFar, Matrix4x4& ret);
    private static void LookAt_Injected(Vector3& from, Vector3& to, Vector3& up, Matrix4x4& ret);
    private static void Frustum_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret);
    private static bool CompareApproximately_Injected(Matrix4x4& a, Matrix4x4& b, float threshold);
}
[RequiredByNativeCodeAttribute]
[ExcludeFromPresetAttribute]
[NativeHeaderAttribute("Runtime/Graphics/Mesh/MeshScriptBindings.h")]
public class UnityEngine.Mesh : Object {
    public IndexFormat indexFormat { get; public set; }
    public int vertexBufferCount { get; }
    public Target vertexBufferTarget { get; public set; }
    public Target indexBufferTarget { get; public set; }
    public int blendShapeCount { get; }
    public int bindposeCount { get; }
    [NativeNameAttribute("BindPosesFromScript")]
public Matrix4x4[] bindposes { get; public set; }
    public bool isReadable { get; }
    internal bool canAccess { get; }
    public int vertexCount { get; }
    public int subMeshCount { get; public set; }
    public Bounds bounds { get; public set; }
    public Vector3[] vertices { get; public set; }
    public Vector3[] normals { get; public set; }
    public Vector4[] tangents { get; public set; }
    public Vector2[] uv { get; public set; }
    public Vector2[] uv2 { get; public set; }
    public Vector2[] uv3 { get; public set; }
    public Vector2[] uv4 { get; public set; }
    public Vector2[] uv5 { get; public set; }
    public Vector2[] uv6 { get; public set; }
    public Vector2[] uv7 { get; public set; }
    public Vector2[] uv8 { get; public set; }
    public Color[] colors { get; public set; }
    public Color32[] colors32 { get; public set; }
    public int vertexAttributeCount { get; }
    public Int32[] triangles { get; public set; }
    public BoneWeight[] boneWeights { get; public set; }
    public SkinWeights skinWeightBufferLayout { get; }
    [FreeFunctionAttribute("MeshScripting::CreateMesh")]
private static void Internal_Create(Mesh mono);
    [FreeFunctionAttribute("MeshScripting::MeshFromInstanceId")]
internal static Mesh FromInstanceID(int id);
    public IndexFormat get_indexFormat();
    public void set_indexFormat(IndexFormat value);
    internal UInt32 GetTotalIndexCount();
    [FreeFunctionAttribute]
public void SetIndexBufferParams(int indexCount, IndexFormat format);
    [FreeFunctionAttribute]
private void InternalSetIndexBufferData(IntPtr data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private void InternalSetIndexBufferDataFromArray(Array data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private void SetVertexBufferParamsFromPtr(int vertexCount, IntPtr attributesPtr, int attributesCount);
    [FreeFunctionAttribute]
private void SetVertexBufferParamsFromArray(int vertexCount, VertexAttributeDescriptor[] attributes);
    [FreeFunctionAttribute]
private void InternalSetVertexBufferData(int stream, IntPtr data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private void InternalSetVertexBufferDataFromArray(int stream, Array data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private Array GetVertexAttributesAlloc();
    [FreeFunctionAttribute]
private int GetVertexAttributesArray(VertexAttributeDescriptor[] attributes);
    [FreeFunctionAttribute]
private int GetVertexAttributesList(List`1<VertexAttributeDescriptor> attributes);
    [FreeFunctionAttribute]
private int GetVertexAttributeCountImpl();
    [FreeFunctionAttribute]
public VertexAttributeDescriptor GetVertexAttribute(int index);
    [FreeFunctionAttribute]
private UInt32 GetIndexStartImpl(int submesh);
    [FreeFunctionAttribute]
private UInt32 GetIndexCountImpl(int submesh);
    [FreeFunctionAttribute]
private UInt32 GetTrianglesCountImpl(int submesh);
    [FreeFunctionAttribute]
private UInt32 GetBaseVertexImpl(int submesh);
    [FreeFunctionAttribute]
private Int32[] GetTrianglesImpl(int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private Int32[] GetIndicesImpl(int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private void SetIndicesImpl(int submesh, MeshTopology topology, IndexFormat indicesFormat, Array indices, int arrayStart, int arraySize, bool calculateBounds, int baseVertex);
    [FreeFunctionAttribute]
private void SetIndicesNativeArrayImpl(int submesh, MeshTopology topology, IndexFormat indicesFormat, IntPtr indices, int arrayStart, int arraySize, bool calculateBounds, int baseVertex);
    [FreeFunctionAttribute]
private void GetTrianglesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private void GetTrianglesNonAllocImpl16(UInt16[] values, int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private void GetIndicesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private void GetIndicesNonAllocImpl16(UInt16[] values, int submesh, bool applyBaseVertex);
    [FreeFunctionAttribute]
private void PrintErrorCantAccessChannel(VertexAttribute ch);
    [FreeFunctionAttribute]
public bool HasVertexAttribute(VertexAttribute attr);
    [FreeFunctionAttribute]
public int GetVertexAttributeDimension(VertexAttribute attr);
    [FreeFunctionAttribute]
public VertexAttributeFormat GetVertexAttributeFormat(VertexAttribute attr);
    [FreeFunctionAttribute]
public int GetVertexAttributeStream(VertexAttribute attr);
    [FreeFunctionAttribute]
public int GetVertexAttributeOffset(VertexAttribute attr);
    [FreeFunctionAttribute]
private void SetArrayForChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values, int arraySize, int valuesStart, int valuesCount, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private void SetNativeArrayForChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, IntPtr values, int arraySize, int valuesStart, int valuesCount, MeshUpdateFlags flags);
    [FreeFunctionAttribute]
private Array GetAllocArrayFromChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim);
    [FreeFunctionAttribute]
private void GetArrayFromChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values);
    [FreeFunctionAttribute]
public int get_vertexBufferCount();
    [FreeFunctionAttribute]
public int GetVertexBufferStride(int stream);
    [NativeThrowsAttribute]
[FreeFunctionAttribute]
public IntPtr GetNativeVertexBufferPtr(int index);
    [FreeFunctionAttribute]
public IntPtr GetNativeIndexBufferPtr();
    [FreeFunctionAttribute]
private GraphicsBuffer GetVertexBufferImpl(int index);
    [FreeFunctionAttribute]
private GraphicsBuffer GetIndexBufferImpl();
    [FreeFunctionAttribute]
private GraphicsBuffer GetBoneWeightBufferImpl(int bonesPerVertex);
    [FreeFunctionAttribute]
private GraphicsBuffer GetBlendShapeBufferImpl(int layout);
    public Target get_vertexBufferTarget();
    public void set_vertexBufferTarget(Target value);
    public Target get_indexBufferTarget();
    public void set_indexBufferTarget(Target value);
    [NativeMethodAttribute]
public int get_blendShapeCount();
    [FreeFunctionAttribute]
public void ClearBlendShapes();
    [FreeFunctionAttribute]
public string GetBlendShapeName(int shapeIndex);
    [FreeFunctionAttribute]
public int GetBlendShapeIndex(string blendShapeName);
    [FreeFunctionAttribute]
public int GetBlendShapeFrameCount(int shapeIndex);
    [FreeFunctionAttribute]
public float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex);
    [FreeFunctionAttribute]
public void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents);
    [FreeFunctionAttribute]
public void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents);
    [FreeFunctionAttribute]
private BlendShape GetBlendShapeOffsetInternal(int index);
    [NativeMethodAttribute("HasBoneWeights")]
private bool HasBoneWeights();
    [FreeFunctionAttribute]
private BoneWeight[] GetBoneWeightsImpl();
    [FreeFunctionAttribute]
private void SetBoneWeightsImpl(BoneWeight[] weights);
    public void SetBoneWeights(NativeArray`1<byte> bonesPerVertex, NativeArray`1<BoneWeight1> weights);
    [FreeFunctionAttribute]
[SecurityCriticalAttribute]
private void InternalSetBoneWeights(IntPtr bonesPerVertex, int bonesPerVertexSize, IntPtr weights, int weightsSize);
    public NativeArray`1<BoneWeight1> GetAllBoneWeights();
    public NativeArray`1<byte> GetBonesPerVertex();
    [FreeFunctionAttribute]
private int GetAllBoneWeightsArraySize();
    [NativeMethodAttribute("GetBoneWeightBufferDimension")]
private int GetBoneWeightBufferLayoutInternal();
    [SecurityCriticalAttribute]
[FreeFunctionAttribute]
private IntPtr GetAllBoneWeightsArray();
    [FreeFunctionAttribute]
[SecurityCriticalAttribute]
private IntPtr GetBonesPerVertexArray();
    public int get_bindposeCount();
    public Matrix4x4[] get_bindposes();
    public void set_bindposes(Matrix4x4[] value);
    public NativeArray`1<Matrix4x4> GetBindposes();
    [SecurityCriticalAttribute]
[FreeFunctionAttribute]
private IntPtr GetBindposesArray();
    [FreeFunctionAttribute]
private void GetBoneWeightsNonAllocImpl(BoneWeight[] values);
    [FreeFunctionAttribute]
private void GetBindposesNonAllocImpl(Matrix4x4[] values);
    [NativeMethodAttribute("GetIsReadable")]
public bool get_isReadable();
    [NativeMethodAttribute("CanAccessFromScript")]
internal bool get_canAccess();
    [NativeMethodAttribute("GetVertexCount")]
public int get_vertexCount();
    [NativeMethodAttribute]
public int get_subMeshCount();
    [FreeFunctionAttribute]
public void set_subMeshCount(int value);
    [FreeFunctionAttribute("MeshScripting::SetSubMesh")]
public void SetSubMesh(int index, SubMeshDescriptor desc, MeshUpdateFlags flags);
    [FreeFunctionAttribute("MeshScripting::GetSubMesh")]
public SubMeshDescriptor GetSubMesh(int index);
    [FreeFunctionAttribute("MeshScripting::SetAllSubMeshesAtOnceFromArray")]
private void SetAllSubMeshesAtOnceFromArray(SubMeshDescriptor[] desc, int start, int count, MeshUpdateFlags flags);
    [FreeFunctionAttribute("MeshScripting::SetAllSubMeshesAtOnceFromNativeArray")]
private void SetAllSubMeshesAtOnceFromNativeArray(IntPtr desc, int start, int count, MeshUpdateFlags flags);
    public Bounds get_bounds();
    public void set_bounds(Bounds value);
    [NativeMethodAttribute("Clear")]
private void ClearImpl(bool keepVertexLayout);
    [NativeMethodAttribute("RecalculateBounds")]
private void RecalculateBoundsImpl(MeshUpdateFlags flags);
    [NativeMethodAttribute("RecalculateNormals")]
private void RecalculateNormalsImpl(MeshUpdateFlags flags);
    [NativeMethodAttribute("RecalculateTangents")]
private void RecalculateTangentsImpl(MeshUpdateFlags flags);
    [NativeMethodAttribute("MarkDynamic")]
private void MarkDynamicImpl();
    [NativeMethodAttribute("MarkModified")]
public void MarkModified();
    [NativeMethodAttribute("UploadMeshData")]
private void UploadMeshDataImpl(bool markNoLongerReadable);
    [FreeFunctionAttribute]
private MeshTopology GetTopologyImpl(int submesh);
    [NativeMethodAttribute("RecalculateMeshMetric")]
private void RecalculateUVDistributionMetricImpl(int uvSetIndex, float uvAreaThreshold);
    [NativeMethodAttribute("RecalculateMeshMetrics")]
private void RecalculateUVDistributionMetricsImpl(float uvAreaThreshold);
    [NativeMethodAttribute("GetMeshMetric")]
public float GetUVDistributionMetric(int uvSetIndex);
    [NativeMethodAttribute]
private void CombineMeshesImpl(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData);
    [NativeMethodAttribute("Optimize")]
private void OptimizeImpl();
    [NativeMethodAttribute("OptimizeIndexBuffers")]
private void OptimizeIndexBuffersImpl();
    [NativeMethodAttribute("OptimizeReorderVertexBuffer")]
private void OptimizeReorderVertexBufferImpl();
    internal static VertexAttribute GetUVChannel(int uvIndex);
    internal static int DefaultDimensionForChannel(VertexAttribute channel);
    private T[] GetAllocArrayFromChannel(VertexAttribute channel, VertexAttributeFormat format, int dim);
    private T[] GetAllocArrayFromChannel(VertexAttribute channel);
    private void SetSizedArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values, int valuesArrayLength, int valuesStart, int valuesCount, MeshUpdateFlags flags);
    private void SetSizedNativeArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, IntPtr values, int valuesArrayLength, int valuesStart, int valuesCount, MeshUpdateFlags flags);
    private void SetArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, T[] values, MeshUpdateFlags flags);
    private void SetArrayForChannel(VertexAttribute channel, T[] values, MeshUpdateFlags flags);
    private void SetListForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, List`1<T> values, int start, int length, MeshUpdateFlags flags);
    private void SetListForChannel(VertexAttribute channel, List`1<T> values, int start, int length, MeshUpdateFlags flags);
    private void GetListForChannel(List`1<T> buffer, int capacity, VertexAttribute channel, int dim);
    private void GetListForChannel(List`1<T> buffer, int capacity, VertexAttribute channel, int dim, VertexAttributeFormat channelType);
    public Vector3[] get_vertices();
    public void set_vertices(Vector3[] value);
    public Vector3[] get_normals();
    public void set_normals(Vector3[] value);
    public Vector4[] get_tangents();
    public void set_tangents(Vector4[] value);
    public Vector2[] get_uv();
    public void set_uv(Vector2[] value);
    public Vector2[] get_uv2();
    public void set_uv2(Vector2[] value);
    public Vector2[] get_uv3();
    public void set_uv3(Vector2[] value);
    public Vector2[] get_uv4();
    public void set_uv4(Vector2[] value);
    public Vector2[] get_uv5();
    public void set_uv5(Vector2[] value);
    public Vector2[] get_uv6();
    public void set_uv6(Vector2[] value);
    public Vector2[] get_uv7();
    public void set_uv7(Vector2[] value);
    public Vector2[] get_uv8();
    public void set_uv8(Vector2[] value);
    public Color[] get_colors();
    public void set_colors(Color[] value);
    public Color32[] get_colors32();
    public void set_colors32(Color32[] value);
    public void GetVertices(List`1<Vector3> vertices);
    public void SetVertices(List`1<Vector3> inVertices);
    [ExcludeFromDocsAttribute]
public void SetVertices(List`1<Vector3> inVertices, int start, int length);
    public void SetVertices(List`1<Vector3> inVertices, int start, int length, MeshUpdateFlags flags);
    public void SetVertices(Vector3[] inVertices);
    [ExcludeFromDocsAttribute]
public void SetVertices(Vector3[] inVertices, int start, int length);
    public void SetVertices(Vector3[] inVertices, int start, int length, MeshUpdateFlags flags);
    public void SetVertices(NativeArray`1<T> inVertices);
    [ExcludeFromDocsAttribute]
public void SetVertices(NativeArray`1<T> inVertices, int start, int length);
    public void SetVertices(NativeArray`1<T> inVertices, int start, int length, MeshUpdateFlags flags);
    public void GetNormals(List`1<Vector3> normals);
    public void SetNormals(List`1<Vector3> inNormals);
    [ExcludeFromDocsAttribute]
public void SetNormals(List`1<Vector3> inNormals, int start, int length);
    public void SetNormals(List`1<Vector3> inNormals, int start, int length, MeshUpdateFlags flags);
    public void SetNormals(Vector3[] inNormals);
    [ExcludeFromDocsAttribute]
public void SetNormals(Vector3[] inNormals, int start, int length);
    public void SetNormals(Vector3[] inNormals, int start, int length, MeshUpdateFlags flags);
    public void SetNormals(NativeArray`1<T> inNormals);
    [ExcludeFromDocsAttribute]
public void SetNormals(NativeArray`1<T> inNormals, int start, int length);
    public void SetNormals(NativeArray`1<T> inNormals, int start, int length, MeshUpdateFlags flags);
    public void GetTangents(List`1<Vector4> tangents);
    public void SetTangents(List`1<Vector4> inTangents);
    [ExcludeFromDocsAttribute]
public void SetTangents(List`1<Vector4> inTangents, int start, int length);
    public void SetTangents(List`1<Vector4> inTangents, int start, int length, MeshUpdateFlags flags);
    public void SetTangents(Vector4[] inTangents);
    [ExcludeFromDocsAttribute]
public void SetTangents(Vector4[] inTangents, int start, int length);
    public void SetTangents(Vector4[] inTangents, int start, int length, MeshUpdateFlags flags);
    public void SetTangents(NativeArray`1<T> inTangents);
    [ExcludeFromDocsAttribute]
public void SetTangents(NativeArray`1<T> inTangents, int start, int length);
    public void SetTangents(NativeArray`1<T> inTangents, int start, int length, MeshUpdateFlags flags);
    public void GetColors(List`1<Color> colors);
    public void SetColors(List`1<Color> inColors);
    [ExcludeFromDocsAttribute]
public void SetColors(List`1<Color> inColors, int start, int length);
    public void SetColors(List`1<Color> inColors, int start, int length, MeshUpdateFlags flags);
    public void SetColors(Color[] inColors);
    [ExcludeFromDocsAttribute]
public void SetColors(Color[] inColors, int start, int length);
    public void SetColors(Color[] inColors, int start, int length, MeshUpdateFlags flags);
    public void GetColors(List`1<Color32> colors);
    public void SetColors(List`1<Color32> inColors);
    [ExcludeFromDocsAttribute]
public void SetColors(List`1<Color32> inColors, int start, int length);
    public void SetColors(List`1<Color32> inColors, int start, int length, MeshUpdateFlags flags);
    public void SetColors(Color32[] inColors);
    [ExcludeFromDocsAttribute]
public void SetColors(Color32[] inColors, int start, int length);
    public void SetColors(Color32[] inColors, int start, int length, MeshUpdateFlags flags);
    public void SetColors(NativeArray`1<T> inColors);
    [ExcludeFromDocsAttribute]
public void SetColors(NativeArray`1<T> inColors, int start, int length);
    public void SetColors(NativeArray`1<T> inColors, int start, int length, MeshUpdateFlags flags);
    private void SetUvsImpl(int uvIndex, int dim, List`1<T> uvs, int start, int length, MeshUpdateFlags flags);
    public void SetUVs(int channel, List`1<Vector2> uvs);
    public void SetUVs(int channel, List`1<Vector3> uvs);
    public void SetUVs(int channel, List`1<Vector4> uvs);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, List`1<Vector2> uvs, int start, int length);
    public void SetUVs(int channel, List`1<Vector2> uvs, int start, int length, MeshUpdateFlags flags);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, List`1<Vector3> uvs, int start, int length);
    public void SetUVs(int channel, List`1<Vector3> uvs, int start, int length, MeshUpdateFlags flags);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, List`1<Vector4> uvs, int start, int length);
    public void SetUVs(int channel, List`1<Vector4> uvs, int start, int length, MeshUpdateFlags flags);
    private void SetUvsImpl(int uvIndex, int dim, Array uvs, int arrayStart, int arraySize, MeshUpdateFlags flags);
    public void SetUVs(int channel, Vector2[] uvs);
    public void SetUVs(int channel, Vector3[] uvs);
    public void SetUVs(int channel, Vector4[] uvs);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, Vector2[] uvs, int start, int length);
    public void SetUVs(int channel, Vector2[] uvs, int start, int length, MeshUpdateFlags flags);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, Vector3[] uvs, int start, int length);
    public void SetUVs(int channel, Vector3[] uvs, int start, int length, MeshUpdateFlags flags);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, Vector4[] uvs, int start, int length);
    public void SetUVs(int channel, Vector4[] uvs, int start, int length, MeshUpdateFlags flags);
    public void SetUVs(int channel, NativeArray`1<T> uvs);
    [ExcludeFromDocsAttribute]
public void SetUVs(int channel, NativeArray`1<T> uvs, int start, int length);
    public void SetUVs(int channel, NativeArray`1<T> uvs, int start, int length, MeshUpdateFlags flags);
    private void GetUVsImpl(int uvIndex, List`1<T> uvs, int dim);
    public void GetUVs(int channel, List`1<Vector2> uvs);
    public void GetUVs(int channel, List`1<Vector3> uvs);
    public void GetUVs(int channel, List`1<Vector4> uvs);
    public int get_vertexAttributeCount();
    public VertexAttributeDescriptor[] GetVertexAttributes();
    public int GetVertexAttributes(VertexAttributeDescriptor[] attributes);
    public int GetVertexAttributes(List`1<VertexAttributeDescriptor> attributes);
    public void SetVertexBufferParams(int vertexCount, VertexAttributeDescriptor[] attributes);
    public void SetVertexBufferParams(int vertexCount, NativeArray`1<VertexAttributeDescriptor> attributes);
    public void SetVertexBufferData(NativeArray`1<T> data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags);
    public void SetVertexBufferData(T[] data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags);
    public void SetVertexBufferData(List`1<T> data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags);
    public static MeshDataArray AcquireReadOnlyMeshData(Mesh mesh);
    public static MeshDataArray AcquireReadOnlyMeshData(Mesh[] meshes);
    public static MeshDataArray AcquireReadOnlyMeshData(List`1<Mesh> meshes);
    public static MeshDataArray AllocateWritableMeshData(int meshCount);
    public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh mesh, MeshUpdateFlags flags);
    public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh[] meshes, MeshUpdateFlags flags);
    public static void ApplyAndDisposeWritableMeshData(MeshDataArray data, List`1<Mesh> meshes, MeshUpdateFlags flags);
    public GraphicsBuffer GetVertexBuffer(int index);
    public GraphicsBuffer GetIndexBuffer();
    public GraphicsBuffer GetBoneWeightBuffer(SkinWeights layout);
    public GraphicsBuffer GetBlendShapeBuffer(BlendShapeBufferLayout layout);
    public GraphicsBuffer GetBlendShapeBuffer();
    public BlendShapeBufferRange GetBlendShapeBufferRange(int blendShapeIndex);
    private void PrintErrorCantAccessIndices();
    private bool CheckCanAccessSubmesh(int submesh, bool errorAboutTriangles);
    private bool CheckCanAccessSubmeshTriangles(int submesh);
    private bool CheckCanAccessSubmeshIndices(int submesh);
    public Int32[] get_triangles();
    public void set_triangles(Int32[] value);
    public Int32[] GetTriangles(int submesh);
    public Int32[] GetTriangles(int submesh, bool applyBaseVertex);
    public void GetTriangles(List`1<int> triangles, int submesh);
    public void GetTriangles(List`1<int> triangles, int submesh, bool applyBaseVertex);
    public void GetTriangles(List`1<ushort> triangles, int submesh, bool applyBaseVertex);
    [ExcludeFromDocsAttribute]
public Int32[] GetIndices(int submesh);
    public Int32[] GetIndices(int submesh, bool applyBaseVertex);
    [ExcludeFromDocsAttribute]
public void GetIndices(List`1<int> indices, int submesh);
    public void GetIndices(List`1<int> indices, int submesh, bool applyBaseVertex);
    public void GetIndices(List`1<ushort> indices, int submesh, bool applyBaseVertex);
    public void SetIndexBufferData(NativeArray`1<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags);
    public void SetIndexBufferData(T[] data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags);
    public void SetIndexBufferData(List`1<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags);
    public UInt32 GetIndexStart(int submesh);
    public UInt32 GetIndexCount(int submesh);
    public UInt32 GetBaseVertex(int submesh);
    private void CheckIndicesArrayRange(int valuesLength, int start, int length);
    private void SetTrianglesImpl(int submesh, IndexFormat indicesFormat, Array triangles, int trianglesArrayLength, int start, int length, bool calculateBounds, int baseVertex);
    [ExcludeFromDocsAttribute]
public void SetTriangles(Int32[] triangles, int submesh);
    [ExcludeFromDocsAttribute]
public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds);
    public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(Int32[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(UInt16[] triangles, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(UInt16[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex);
    [ExcludeFromDocsAttribute]
public void SetTriangles(List`1<int> triangles, int submesh);
    [ExcludeFromDocsAttribute]
public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds);
    public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(List`1<int> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(List`1<ushort> triangles, int submesh, bool calculateBounds, int baseVertex);
    public void SetTriangles(List`1<ushort> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex);
    [ExcludeFromDocsAttribute]
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh);
    [ExcludeFromDocsAttribute]
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds);
    public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(Int32[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(UInt16[] indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(UInt16[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(NativeArray`1<T> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(NativeArray`1<T> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(List`1<int> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(List`1<int> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(List`1<ushort> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetIndices(List`1<ushort> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex);
    public void SetSubMeshes(SubMeshDescriptor[] desc, int start, int count, MeshUpdateFlags flags);
    public void SetSubMeshes(SubMeshDescriptor[] desc, MeshUpdateFlags flags);
    public void SetSubMeshes(List`1<SubMeshDescriptor> desc, int start, int count, MeshUpdateFlags flags);
    public void SetSubMeshes(List`1<SubMeshDescriptor> desc, MeshUpdateFlags flags);
    public void SetSubMeshes(NativeArray`1<T> desc, int start, int count, MeshUpdateFlags flags);
    public void SetSubMeshes(NativeArray`1<T> desc, MeshUpdateFlags flags);
    public void GetBindposes(List`1<Matrix4x4> bindposes);
    public void GetBoneWeights(List`1<BoneWeight> boneWeights);
    public BoneWeight[] get_boneWeights();
    public void set_boneWeights(BoneWeight[] value);
    public SkinWeights get_skinWeightBufferLayout();
    public void Clear(bool keepVertexLayout);
    [ExcludeFromDocsAttribute]
public void Clear();
    [ExcludeFromDocsAttribute]
public void RecalculateBounds();
    [ExcludeFromDocsAttribute]
public void RecalculateNormals();
    [ExcludeFromDocsAttribute]
public void RecalculateTangents();
    public void RecalculateBounds(MeshUpdateFlags flags);
    public void RecalculateNormals(MeshUpdateFlags flags);
    public void RecalculateTangents(MeshUpdateFlags flags);
    public void RecalculateUVDistributionMetric(int uvSetIndex, float uvAreaThreshold);
    public void RecalculateUVDistributionMetrics(float uvAreaThreshold);
    public void MarkDynamic();
    public void UploadMeshData(bool markNoLongerReadable);
    public void Optimize();
    public void OptimizeIndexBuffers();
    public void OptimizeReorderVertexBuffer();
    public MeshTopology GetTopology(int submesh);
    public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData);
    [ExcludeFromDocsAttribute]
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices);
    [ExcludeFromDocsAttribute]
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes);
    [ExcludeFromDocsAttribute]
public void CombineMeshes(CombineInstance[] combine);
    private void GetVertexAttribute_Injected(int index, VertexAttributeDescriptor& ret);
    private void GetBlendShapeOffsetInternal_Injected(int index, BlendShape& ret);
    private void SetSubMesh_Injected(int index, SubMeshDescriptor& desc, MeshUpdateFlags flags);
    private void GetSubMesh_Injected(int index, SubMeshDescriptor& ret);
    private void get_bounds_Injected(Bounds& ret);
    private void set_bounds_Injected(Bounds& value);
}
[NativeHeaderAttribute("Runtime/Graphics/Mesh/MeshFilter.h")]
[RequireComponent("UnityEngine.Transform")]
public class UnityEngine.MeshFilter : Component {
    public Mesh sharedMesh { get; public set; }
    public Mesh mesh { get; public set; }
    [RequiredByNativeCodeAttribute]
private void DontStripMeshFilter();
    public Mesh get_sharedMesh();
    public void set_sharedMesh(Mesh value);
    [NativeNameAttribute("GetInstantiatedMeshFromScript")]
public Mesh get_mesh();
    [NativeNameAttribute("SetInstantiatedMesh")]
public void set_mesh(Mesh value);
}
[NativeHeaderAttribute("Runtime/Graphics/Mesh/MeshRenderer.h")]
public class UnityEngine.MeshRenderer : Renderer {
    public Mesh additionalVertexStreams { get; public set; }
    public Mesh enlightenVertexStream { get; public set; }
    public int subMeshStartIndex { get; }
    [RequiredByNativeCodeAttribute]
private void DontStripMeshRenderer();
    public Mesh get_additionalVertexStreams();
    public void set_additionalVertexStreams(Mesh value);
    public Mesh get_enlightenVertexStream();
    public void set_enlightenVertexStream(Mesh value);
    [NativeNameAttribute("GetSubMeshStartIndex")]
public int get_subMeshStartIndex();
}
internal class UnityEngine.MeshSubsetCombineUtility : object {
}
public enum UnityEngine.MeshTopology : Enum {
    public int value__;
    public static MeshTopology Triangles;
    public static MeshTopology Quads;
    public static MeshTopology Lines;
    public static MeshTopology LineStrip;
    public static MeshTopology Points;
}
internal static class UnityEngine.MethodImplOptionsEx : object {
    public static short AggressiveInlining;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.MinAttribute : PropertyAttribute {
    public float min;
    public MinAttribute(float min);
}
public class UnityEngine.MissingComponentException : SystemException {
    private static int Result;
    private string unityStackTrace;
    public MissingComponentException(string message);
    public MissingComponentException(string message, Exception innerException);
    protected MissingComponentException(SerializationInfo info, StreamingContext context);
}
public class UnityEngine.MissingReferenceException : SystemException {
    private static int Result;
    private string unityStackTrace;
    public MissingReferenceException(string message);
    public MissingReferenceException(string message, Exception innerException);
    protected MissingReferenceException(SerializationInfo info, StreamingContext context);
}
public enum UnityEngine.MixedLightingMode : Enum {
    public int value__;
    public static MixedLightingMode IndirectOnly;
    public static MixedLightingMode Shadowmask;
    public static MixedLightingMode Subtractive;
}
[NativeHeaderAttribute("Runtime/Mono/MonoBehaviour.h")]
[RequiredByNativeCodeAttribute]
[ExtensionOfNativeClassAttribute]
[NativeHeaderAttribute("Runtime/Scripting/DelayedCallUtility.h")]
public class UnityEngine.MonoBehaviour : Behaviour {
    private CancellationTokenSource m_CancellationTokenSource;
    public CancellationToken destroyCancellationToken { get; }
    public bool useGUILayout { get; public set; }
    public CancellationToken get_destroyCancellationToken();
    [RequiredByNativeCodeAttribute]
private void RaiseCancellation();
    public bool IsInvoking();
    public void CancelInvoke();
    public void Invoke(string methodName, float time);
    public void InvokeRepeating(string methodName, float time, float repeatRate);
    public void CancelInvoke(string methodName);
    public bool IsInvoking(string methodName);
    [ExcludeFromDocsAttribute]
public Coroutine StartCoroutine(string methodName);
    public Coroutine StartCoroutine(string methodName, object value);
    public Coroutine StartCoroutine(IEnumerator routine);
    [ObsoleteAttribute("StartCoroutine_Auto has been deprecated. Use StartCoroutine instead (UnityUpgradable) -> StartCoroutine([mscorlib] System.Collections.IEnumerator)", "False")]
public Coroutine StartCoroutine_Auto(IEnumerator routine);
    public void StopCoroutine(IEnumerator routine);
    public void StopCoroutine(Coroutine routine);
    public void StopCoroutine(string methodName);
    public void StopAllCoroutines();
    public bool get_useGUILayout();
    public void set_useGUILayout(bool value);
    public static void print(object message);
    [FreeFunctionAttribute("CancelInvoke")]
private static void Internal_CancelInvokeAll(MonoBehaviour self);
    [FreeFunctionAttribute("IsInvoking")]
private static bool Internal_IsInvokingAll(MonoBehaviour self);
    [FreeFunctionAttribute]
private static void InvokeDelayed(MonoBehaviour self, string methodName, float time, float repeatRate);
    [FreeFunctionAttribute]
private static void CancelInvoke(MonoBehaviour self, string methodName);
    [FreeFunctionAttribute]
private static bool IsInvoking(MonoBehaviour self, string methodName);
    [FreeFunctionAttribute]
private static bool IsObjectMonoBehaviour(Object obj);
    private Coroutine StartCoroutineManaged(string methodName, object value);
    private Coroutine StartCoroutineManaged2(IEnumerator enumerator);
    private void StopCoroutineManaged(Coroutine routine);
    private void StopCoroutineFromEnumeratorManaged(IEnumerator routine);
    internal string GetScriptClassName();
    private void OnCancellationTokenCreated();
}
public enum UnityEngine.MotionVectorGenerationMode : Enum {
    public int value__;
    public static MotionVectorGenerationMode Camera;
    public static MotionVectorGenerationMode Object;
    public static MotionVectorGenerationMode ForceNoMotion;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.MultilineAttribute : PropertyAttribute {
    public int lines;
    public MultilineAttribute(int lines);
}
[MovedFromAttribute("UnityEngine.Experimental.Networking.PlayerConnection")]
public enum UnityEngine.Networking.PlayerConnection.ConnectionTarget : Enum {
    public int value__;
    public static ConnectionTarget None;
    public static ConnectionTarget Player;
    public static ConnectionTarget Editor;
}
[MovedFromAttribute("UnityEngine.Experimental.Networking.PlayerConnection")]
public interface UnityEngine.Networking.PlayerConnection.IConnectionState {
    public ConnectionTarget connectedToTarget { get; }
    public string connectionName { get; }
    public abstract virtual ConnectionTarget get_connectedToTarget();
    public abstract virtual string get_connectionName();
}
public interface UnityEngine.Networking.PlayerConnection.IEditorPlayerConnection {
    public abstract virtual void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback);
    public abstract virtual void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback);
    public abstract virtual void DisconnectAll();
    public abstract virtual void RegisterConnection(UnityAction`1<int> callback);
    public abstract virtual void RegisterDisconnection(UnityAction`1<int> callback);
    public abstract virtual void UnregisterConnection(UnityAction`1<int> callback);
    public abstract virtual void UnregisterDisconnection(UnityAction`1<int> callback);
    public abstract virtual void Send(Guid messageId, Byte[] data);
    public abstract virtual bool TrySend(Guid messageId, Byte[] data);
}
public class UnityEngine.Networking.PlayerConnection.MessageEventArgs : object {
    public int playerId;
    public Byte[] data;
}
public class UnityEngine.Networking.PlayerConnection.PlayerConnection : ScriptableObject {
    internal static IPlayerEditorConnectionNative connectionNative;
    [SerializeField]
private PlayerEditorConnectionEvents m_PlayerEditorConnectionEvents;
    [SerializeField]
private List`1<int> m_connectedPlayers;
    private bool m_IsInitilized;
    private static PlayerConnection s_Instance;
    public static PlayerConnection instance { get; }
    public bool isConnected { get; }
    public static PlayerConnection get_instance();
    public bool get_isConnected();
    private static PlayerConnection CreateInstance();
    public void OnEnable();
    private IPlayerEditorConnectionNative GetConnectionNativeApi();
    public sealed virtual void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback);
    public sealed virtual void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback);
    public sealed virtual void RegisterConnection(UnityAction`1<int> callback);
    public sealed virtual void RegisterDisconnection(UnityAction`1<int> callback);
    public sealed virtual void UnregisterConnection(UnityAction`1<int> callback);
    public sealed virtual void UnregisterDisconnection(UnityAction`1<int> callback);
    public sealed virtual void Send(Guid messageId, Byte[] data);
    public sealed virtual bool TrySend(Guid messageId, Byte[] data);
    public bool BlockUntilRecvMsg(Guid messageId, int timeout);
    public sealed virtual void DisconnectAll();
    [RequiredByNativeCodeAttribute]
private static void MessageCallbackInternal(IntPtr data, ulong size, ulong guid, string messageId);
    [RequiredByNativeCodeAttribute]
private static void ConnectedCallbackInternal(int playerId);
    [RequiredByNativeCodeAttribute]
private static void DisconnectedCallback(int playerId);
}
internal class UnityEngine.Networking.PlayerConnection.PlayerEditorConnectionEvents : object {
    [SerializeField]
public List`1<MessageTypeSubscribers> messageTypeSubscribers;
    [SerializeField]
public ConnectionChangeEvent connectionEvent;
    [SerializeField]
public ConnectionChangeEvent disconnectionEvent;
    public void InvokeMessageIdSubscribers(Guid messageId, Byte[] data, int playerId);
    public UnityEvent`1<MessageEventArgs> AddAndCreate(Guid messageId);
    public void UnregisterManagedCallback(Guid messageId, UnityAction`1<MessageEventArgs> callback);
}
public enum UnityEngine.NetworkReachability : Enum {
    public int value__;
    public static NetworkReachability NotReachable;
    public static NetworkReachability ReachableViaCarrierDataNetwork;
    public static NetworkReachability ReachableViaLocalAreaNetwork;
}
[NativeHeaderAttribute("Runtime/Export/Scripting/NoAllocHelpers.bindings.h")]
internal class UnityEngine.NoAllocHelpers : object {
    public static void ResizeList(List`1<T> list, int size);
    public static void EnsureListElemCount(List`1<T> list, int count);
    public static int SafeLength(Array values);
    public static int SafeLength(List`1<T> values);
    public static T[] ExtractArrayFromListT(List`1<T> list);
    [FreeFunctionAttribute("NoAllocHelpers_Bindings::Internal_ResizeList")]
internal static void Internal_ResizeList(object list, int size);
    [FreeFunctionAttribute("NoAllocHelpers_Bindings::ExtractArrayFromList")]
public static Array ExtractArrayFromList(object list);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.NonReorderableAttribute : PropertyAttribute {
}
public enum UnityEngine.NPOTSupport : Enum {
    public int value__;
    [ObsoleteAttribute("NPOTSupport.None does not happen on any platforms")]
public static NPOTSupport None;
    public static NPOTSupport Restricted;
    public static NPOTSupport Full;
}
[MovedFromAttribute("UnityEditor")]
internal class UnityEngine.NumericFieldDraggerUtility : object {
    private static bool s_UseYSign;
    private static float kDragSensitivity;
    internal static float Acceleration(bool shiftPressed, bool altPressed);
    internal static float NiceDelta(Vector2 deviceDelta, float acceleration);
    internal static double CalculateFloatDragSensitivity(double value);
    internal static double CalculateFloatDragSensitivity(double value, double minValue, double maxValue);
    internal static long CalculateIntDragSensitivity(long value);
    internal static ulong CalculateIntDragSensitivity(ulong value);
    private static double CalculateIntDragSensitivity(double value);
    internal static long CalculateIntDragSensitivity(long value, long minValue, long maxValue);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Scripting/UnityEngineObject.bindings.h")]
[NativeHeaderAttribute("Runtime/GameCode/CloneObject.h")]
[NativeHeaderAttribute("Runtime/SceneManager/SceneManager.h")]
public class UnityEngine.Object : object {
    private IntPtr m_CachedPtr;
    internal static int OffsetOfInstanceIDInCPlusPlusObject;
    private static string objectIsNullMessage;
    private static string cloneDestroyedMessage;
    public string name { get; public set; }
    public HideFlags hideFlags { get; public set; }
    private static Object();
    [SecuritySafeCriticalAttribute]
public int GetInstanceID();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public static bool op_Implicit(Object exists);
    private static bool CompareBaseObjects(Object lhs, Object rhs);
    private void EnsureRunningOnMainThread();
    private static bool IsNativeObjectAlive(Object o);
    private IntPtr GetCachedPtr();
    public string get_name();
    public void set_name(string value);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, Transform parent);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, Vector3 position, Quaternion rotation);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, Transform parent, Vector3 position, Quaternion rotation);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count, Transform parent);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count, Vector3 position, Quaternion rotation);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count, ReadOnlySpan`1<Vector3> positions, ReadOnlySpan`1<Quaternion> rotations);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count, Transform parent, Vector3 position, Quaternion rotation);
    public static AsyncInstantiateOperation`1<T> InstantiateAsync(T original, int count, Transform parent, ReadOnlySpan`1<Vector3> positions, ReadOnlySpan`1<Quaternion> rotations);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original, Vector3 position, Quaternion rotation);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original, Scene scene);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original, Transform parent);
    [TypeInferenceRuleAttribute("3")]
public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace);
    public static T Instantiate(T original);
    public static T Instantiate(T original, Vector3 position, Quaternion rotation);
    public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent);
    public static T Instantiate(T original, Transform parent);
    public static T Instantiate(T original, Transform parent, bool worldPositionStays);
    [NativeMethodAttribute]
public static void Destroy(Object obj, float t);
    [ExcludeFromDocsAttribute]
public static void Destroy(Object obj);
    [NativeMethodAttribute]
public static void DestroyImmediate(Object obj, bool allowDestroyingAssets);
    [ExcludeFromDocsAttribute]
public static void DestroyImmediate(Object obj);
    public static Object[] FindObjectsOfType(Type type);
    [FreeFunctionAttribute("UnityEngineObjectBindings::FindObjectsOfType")]
[TypeInferenceRuleAttribute("2")]
public static Object[] FindObjectsOfType(Type type, bool includeInactive);
    public static Object[] FindObjectsByType(Type type, FindObjectsSortMode sortMode);
    [TypeInferenceRuleAttribute("2")]
[FreeFunctionAttribute("UnityEngineObjectBindings::FindObjectsByType")]
public static Object[] FindObjectsByType(Type type, FindObjectsInactive findObjectsInactive, FindObjectsSortMode sortMode);
    [FreeFunctionAttribute("GetSceneManager().DontDestroyOnLoad")]
public static void DontDestroyOnLoad(Object target);
    public HideFlags get_hideFlags();
    public void set_hideFlags(HideFlags value);
    [ObsoleteAttribute("use Object.Destroy instead.")]
public static void DestroyObject(Object obj, float t);
    [ObsoleteAttribute("use Object.Destroy instead.")]
[ExcludeFromDocsAttribute]
public static void DestroyObject(Object obj);
    [ObsoleteAttribute("warning use Object.FindObjectsByType instead.")]
public static Object[] FindSceneObjectsOfType(Type type);
    [ObsoleteAttribute("use Resources.FindObjectsOfTypeAll instead.")]
[FreeFunctionAttribute("UnityEngineObjectBindings::FindObjectsOfTypeIncludingAssets")]
public static Object[] FindObjectsOfTypeIncludingAssets(Type type);
    public static T[] FindObjectsOfType();
    public static T[] FindObjectsByType(FindObjectsSortMode sortMode);
    public static T[] FindObjectsOfType(bool includeInactive);
    public static T[] FindObjectsByType(FindObjectsInactive findObjectsInactive, FindObjectsSortMode sortMode);
    public static T FindObjectOfType();
    public static T FindObjectOfType(bool includeInactive);
    public static T FindFirstObjectByType();
    public static T FindAnyObjectByType();
    public static T FindFirstObjectByType(FindObjectsInactive findObjectsInactive);
    public static T FindAnyObjectByType(FindObjectsInactive findObjectsInactive);
    [ObsoleteAttribute("Please use Resources.FindObjectsOfTypeAll instead")]
public static Object[] FindObjectsOfTypeAll(Type type);
    private static void CheckNullArgument(object arg, string message);
    [TypeInferenceRuleAttribute("0")]
public static Object FindObjectOfType(Type type);
    public static Object FindFirstObjectByType(Type type);
    public static Object FindAnyObjectByType(Type type);
    [TypeInferenceRuleAttribute("0")]
public static Object FindObjectOfType(Type type, bool includeInactive);
    public static Object FindFirstObjectByType(Type type, FindObjectsInactive findObjectsInactive);
    public static Object FindAnyObjectByType(Type type, FindObjectsInactive findObjectsInactive);
    public virtual string ToString();
    public static bool op_Equality(Object x, Object y);
    public static bool op_Inequality(Object x, Object y);
    [NativeMethodAttribute]
private static int GetOffsetOfInstanceIDInCPlusPlusObject();
    [NativeMethodAttribute]
private static bool CurrentThreadIsMainThread();
    [NativeMethodAttribute]
private static Object Internal_CloneSingle(Object data);
    [FreeFunctionAttribute("CloneObjectToScene")]
private static Object Internal_CloneSingleWithScene(Object data, Scene scene);
    [FreeFunctionAttribute("CloneObject")]
private static Object Internal_CloneSingleWithParent(Object data, Transform parent, bool worldPositionStays);
    [FreeFunctionAttribute("InstantiateAsyncObjects")]
private static AsyncInstantiateOperation Internal_InstantiateAsyncWithParent(Object original, int count, Transform parent, IntPtr positions, int positionsCount, IntPtr rotations, int rotationsCount);
    [FreeFunctionAttribute("InstantiateObject")]
private static Object Internal_InstantiateSingle(Object data, Vector3 pos, Quaternion rot);
    [FreeFunctionAttribute("InstantiateObject")]
private static Object Internal_InstantiateSingleWithParent(Object data, Transform parent, Vector3 pos, Quaternion rot);
    [FreeFunctionAttribute("UnityEngineObjectBindings::ToString")]
private static string ToString(Object obj);
    [FreeFunctionAttribute("UnityEngineObjectBindings::GetName")]
private static string GetName(Object obj);
    [FreeFunctionAttribute("UnityEngineObjectBindings::IsPersistent")]
internal static bool IsPersistent(Object obj);
    [FreeFunctionAttribute("UnityEngineObjectBindings::SetName")]
private static void SetName(Object obj, string name);
    [NativeMethodAttribute]
internal static bool DoesObjectWithInstanceIDExist(int instanceID);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("UnityEngineObjectBindings::FindObjectFromInstanceID")]
internal static Object FindObjectFromInstanceID(int instanceID);
    [FreeFunctionAttribute("UnityEngineObjectBindings::ForceLoadFromInstanceID")]
[VisibleToOtherModulesAttribute]
internal static Object ForceLoadFromInstanceID(int instanceID);
    [FreeFunctionAttribute("UnityEngineObjectBindings::MarkObjectDirty")]
internal void MarkDirty();
    private static Object Internal_CloneSingleWithScene_Injected(Object data, Scene& scene);
    private static Object Internal_InstantiateSingle_Injected(Object data, Vector3& pos, Quaternion& rot);
    private static Object Internal_InstantiateSingleWithParent_Injected(Object data, Transform parent, Vector3& pos, Quaternion& rot);
}
[RequiredByNativeCodeAttribute]
[StaticAccessorAttribute("GetObjectDispatcher()", "0")]
[NativeHeaderAttribute("Runtime/Misc/ObjectDispatcher.h")]
internal class UnityEngine.ObjectDispatcher : object {
    private IntPtr m_Ptr;
    private static Action`6<Object[], IntPtr, IntPtr, int, int, Action`1<TypeDispatchData>> s_TypeDispatch;
    private static Action`8<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, int, Action`1<TransformDispatchData>> s_TransformDispatch;
    public bool valid { get; }
    public int maxDispatchHistoryFramesCount { get; public set; }
    private static ObjectDispatcher();
    public bool get_valid();
    public int get_maxDispatchHistoryFramesCount();
    public void set_maxDispatchHistoryFramesCount(int value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void ValidateSystemHandleAndThrow();
    private void ValidateTypeAndThrow(Type type);
    private void ValidateComponentTypeAndThrow(Type type);
    public void DispatchTypeChangesAndClear(Type type, Action`1<TypeDispatchData> callback, bool sortByInstanceID, bool noScriptingArray);
    public void DispatchTransformChangesAndClear(Type type, TransformTrackingType trackingType, Action`1<Component[]> callback, bool sortByInstanceID);
    public void DispatchTransformChangesAndClear(Type type, TransformTrackingType trackingType, Action`1<TransformDispatchData> callback);
    public void ClearTypeChanges(Type type);
    public TypeDispatchData GetTypeChangesAndClear(Type type, Allocator allocator, bool sortByInstanceID, bool noScriptingArray);
    public void GetTypeChangesAndClear(Type type, List`1<Object> changed, NativeArray`1& changedID, NativeArray`1& destroyedID, Allocator allocator, bool sortByInstanceID);
    public Component[] GetTransformChangesAndClear(Type type, TransformTrackingType trackingType, bool sortByInstanceID);
    public TransformDispatchData GetTransformChangesAndClear(Type type, TransformTrackingType trackingType, Allocator allocator);
    public void EnableTypeTracking(TypeTrackingFlags typeTrackingMask, Type[] types);
    public void EnableTypeTracking(Type[] types);
    [ObsoleteAttribute("EnableTypeTrackingIncludingAssets is deprecated, please use EnableTypeTracking and provide the flag that specifies whether you need assets or not.", "False")]
public void EnableTypeTrackingIncludingAssets(Type[] types);
    public void DisableTypeTracking(Type[] types);
    public void EnableTransformTracking(TransformTrackingType trackingType, Type[] types);
    public void DisableTransformTracking(TransformTrackingType trackingType, Type[] types);
    public void DispatchTypeChangesAndClear(Action`1<TypeDispatchData> callback, bool sortByInstanceID, bool noScriptingArray);
    public void DispatchTransformChangesAndClear(TransformTrackingType trackingType, Action`1<Component[]> callback, bool sortByInstanceID);
    public void DispatchTransformChangesAndClear(TransformTrackingType trackingType, Action`1<TransformDispatchData> callback);
    public void ClearTypeChanges();
    public TypeDispatchData GetTypeChangesAndClear(Allocator allocator, bool sortByInstanceID, bool noScriptingArray);
    public void GetTypeChangesAndClear(List`1<Object> changed, NativeArray`1& changedID, NativeArray`1& destroyedID, Allocator allocator, bool sortByInstanceID);
    public Component[] GetTransformChangesAndClear(TransformTrackingType trackingType, bool sortByInstanceID);
    public TransformDispatchData GetTransformChangesAndClear(TransformTrackingType trackingType, Allocator allocator);
    public void EnableTypeTracking(TypeTrackingFlags typeTrackingMask);
    public void DisableTypeTracking();
    public void EnableTransformTracking(TransformTrackingType trackingType);
    public void DisableTransformTracking(TransformTrackingType trackingType);
    private static IntPtr CreateDispatchSystemHandle();
    [ThreadSafeAttribute]
private static void DestroyDispatchSystemHandle(IntPtr ptr);
    private static int GetMaxDispatchHistoryFramesCount(IntPtr ptr);
    private static void SetMaxDispatchHistoryFramesCount(IntPtr ptr, int count);
    private static void EnableTypeTracking(IntPtr ptr, Type type, TypeTrackingFlags typeTrackingMask);
    private static void DisableTypeTracking(IntPtr ptr, Type type);
    private static void EnableTransformTracking(IntPtr ptr, Type type, TransformTrackingType trackingType);
    private static void DisableTransformTracking(IntPtr ptr, Type type, TransformTrackingType trackingType);
    private static void DispatchTypeChangesAndClear(IntPtr ptr, Type type, Action`6<Object[], IntPtr, IntPtr, int, int, Action`1<TypeDispatchData>> callback, bool sortByInstanceID, bool noScriptingArray, Action`1<TypeDispatchData> param);
    private static void DispatchTransformDataChangesAndClear(IntPtr ptr, Type type, TransformTrackingType trackingType, Action`8<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, int, Action`1<TransformDispatchData>> callback, Action`1<TransformDispatchData> param);
    private static void DispatchTransformChangesAndClear(IntPtr ptr, Type type, TransformTrackingType trackingType, Action`1<Component[]> callback, bool sortByInstanceID);
}
[NativeHeaderAttribute("Runtime/Camera/OcclusionArea.h")]
public class UnityEngine.OcclusionArea : Component {
    public Vector3 center { get; public set; }
    public Vector3 size { get; public set; }
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public Vector3 get_size();
    public void set_size(Vector3 value);
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
    private void get_size_Injected(Vector3& ret);
    private void set_size_Injected(Vector3& value);
}
[NativeHeaderAttribute("Runtime/Camera/OcclusionPortal.h")]
public class UnityEngine.OcclusionPortal : Component {
    [NativePropertyAttribute("IsOpen")]
public bool open { get; public set; }
    public bool get_open();
    public void set_open(bool value);
}
public enum UnityEngine.OperatingSystemFamily : Enum {
    public int value__;
    public static OperatingSystemFamily Other;
    public static OperatingSystemFamily MacOSX;
    public static OperatingSystemFamily Windows;
    public static OperatingSystemFamily Linux;
}
[NativeHeaderAttribute("Runtime/Export/Networking/Ping.bindings.h")]
public class UnityEngine.Ping : object {
    internal IntPtr m_Ptr;
    public bool isDone { get; }
    public int time { get; }
    public string ip { get; }
    public Ping(string address);
    protected virtual override void Finalize();
    [ThreadAndSerializationSafeAttribute]
public void DestroyPing();
    [FreeFunctionAttribute("DestroyPing")]
private static void Internal_Destroy(IntPtr ptr);
    [FreeFunctionAttribute("CreatePing")]
private static IntPtr Internal_Create(string address);
    public bool get_isDone();
    [NativeNameAttribute("GetIsDone")]
private bool Internal_IsDone();
    public int get_time();
    [NativeNameAttribute("GetIP")]
public string get_ip();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Plane : ValueType {
    internal static int size;
    private Vector3 m_Normal;
    private float m_Distance;
    public Vector3 normal { get; public set; }
    public float distance { get; public set; }
    public Plane flipped { get; }
    public Plane(Vector3 inNormal, Vector3 inPoint);
    public Plane(Vector3 inNormal, float d);
    public Plane(Vector3 a, Vector3 b, Vector3 c);
    public Vector3 get_normal();
    public void set_normal(Vector3 value);
    public float get_distance();
    public void set_distance(float value);
    public void SetNormalAndPosition(Vector3 inNormal, Vector3 inPoint);
    public void Set3Points(Vector3 a, Vector3 b, Vector3 c);
    public void Flip();
    public Plane get_flipped();
    public void Translate(Vector3 translation);
    public static Plane Translate(Plane plane, Vector3 translation);
    public Vector3 ClosestPointOnPlane(Vector3 point);
    public float GetDistanceToPoint(Vector3 point);
    public bool GetSide(Vector3 point);
    public bool SameSide(Vector3 inPt0, Vector3 inPt1);
    public bool Raycast(Ray ray, Single& enter);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
[ObsoleteAttribute("DataStreamType is no longer required and will be removed in a future release.", "False")]
public enum UnityEngine.Playables.DataStreamType : Enum {
    public int value__;
    public static DataStreamType Animation;
    public static DataStreamType Audio;
    public static DataStreamType Texture;
    public static DataStreamType None;
}
public enum UnityEngine.Playables.DirectorUpdateMode : Enum {
    public int value__;
    public static DirectorUpdateMode DSPClock;
    public static DirectorUpdateMode GameTime;
    public static DirectorUpdateMode UnscaledGameTime;
    public static DirectorUpdateMode Manual;
}
public enum UnityEngine.Playables.DirectorWrapMode : Enum {
    public int value__;
    public static DirectorWrapMode Hold;
    public static DirectorWrapMode Loop;
    public static DirectorWrapMode None;
}
public class UnityEngine.Playables.FrameData : ValueType {
    internal ulong m_FrameID;
    internal double m_DeltaTime;
    internal float m_Weight;
    internal float m_EffectiveWeight;
    internal double m_EffectiveParentDelay;
    internal float m_EffectiveParentSpeed;
    internal float m_EffectiveSpeed;
    internal Flags m_Flags;
    internal PlayableOutput m_Output;
    public ulong frameId { get; }
    public float deltaTime { get; }
    public float weight { get; }
    public float effectiveWeight { get; }
    [ObsoleteAttribute("effectiveParentDelay is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public double effectiveParentDelay { get; }
    public float effectiveParentSpeed { get; }
    public float effectiveSpeed { get; }
    public EvaluationType evaluationType { get; }
    public bool seekOccurred { get; }
    public bool timeLooped { get; }
    public bool timeHeld { get; }
    public PlayableOutput output { get; }
    public PlayState effectivePlayState { get; }
    private bool HasFlags(Flags flag);
    public ulong get_frameId();
    public float get_deltaTime();
    public float get_weight();
    public float get_effectiveWeight();
    public double get_effectiveParentDelay();
    public float get_effectiveParentSpeed();
    public float get_effectiveSpeed();
    public EvaluationType get_evaluationType();
    public bool get_seekOccurred();
    public bool get_timeLooped();
    public bool get_timeHeld();
    public PlayableOutput get_output();
    public PlayState get_effectivePlayState();
}
[UsedByNativeCodeAttribute("FrameRate")]
[NativeHeaderAttribute("Runtime/Director/Core/FrameRate.h")]
internal class UnityEngine.Playables.FrameRate : ValueType {
    [IgnoreAttribute]
public static FrameRate k_24Fps;
    [IgnoreAttribute]
public static FrameRate k_23_976Fps;
    [IgnoreAttribute]
public static FrameRate k_25Fps;
    [IgnoreAttribute]
public static FrameRate k_30Fps;
    [IgnoreAttribute]
public static FrameRate k_29_97Fps;
    [IgnoreAttribute]
public static FrameRate k_50Fps;
    [IgnoreAttribute]
public static FrameRate k_60Fps;
    [IgnoreAttribute]
public static FrameRate k_59_94Fps;
    [SerializeField]
private int m_Rate;
    public bool dropFrame { get; }
    public double rate { get; }
    public FrameRate(UInt32 frameRate, bool drop);
    private static FrameRate();
    public bool get_dropFrame();
    public double get_rate();
    public bool IsValid();
    public sealed virtual bool Equals(FrameRate other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(FrameRate a, FrameRate b);
    public static bool op_Inequality(FrameRate a, FrameRate b);
    public static bool op_LessThan(FrameRate a, FrameRate b);
    public static bool op_LessThanOrEqual(FrameRate a, FrameRate b);
    public static bool op_GreaterThan(FrameRate a, FrameRate b);
    public static bool op_GreaterThanOrEqual(FrameRate a, FrameRate b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(string format, IFormatProvider formatProvider);
    internal static int FrameRateToInt(FrameRate framerate);
    internal static FrameRate DoubleToFrameRate(double framerate);
}
public interface UnityEngine.Playables.INotification {
    public PropertyName id { get; }
    public abstract virtual PropertyName get_id();
}
[RequiredByNativeCodeAttribute]
public interface UnityEngine.Playables.INotificationReceiver {
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnNotify(Playable origin, INotification notification, object context);
}
public interface UnityEngine.Playables.IPlayable {
    public abstract virtual PlayableHandle GetHandle();
}
public interface UnityEngine.Playables.IPlayableAsset {
    public double duration { get; }
    public IEnumerable`1<PlayableBinding> outputs { get; }
    public abstract virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    public abstract virtual double get_duration();
    public abstract virtual IEnumerable`1<PlayableBinding> get_outputs();
}
public interface UnityEngine.Playables.IPlayableBehaviour {
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnGraphStart(Playable playable);
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnGraphStop(Playable playable);
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnPlayableCreate(Playable playable);
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnPlayableDestroy(Playable playable);
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnBehaviourPlay(Playable playable, FrameData info);
    [RequiredByNativeCodeAttribute]
public abstract virtual void OnBehaviourPause(Playable playable, FrameData info);
    [RequiredByNativeCodeAttribute]
public abstract virtual void PrepareFrame(Playable playable, FrameData info);
    [RequiredByNativeCodeAttribute]
public abstract virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
}
public interface UnityEngine.Playables.IPlayableOutput {
    public abstract virtual PlayableOutputHandle GetHandle();
}
public class UnityEngine.Playables.Notification : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private PropertyName <id>k__BackingField;
    public PropertyName id { get; }
    public Notification(string name);
    [CompilerGeneratedAttribute]
public sealed virtual PropertyName get_id();
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Playables.Playable : ValueType {
    private PlayableHandle m_Handle;
    private static Playable m_NullPlayable;
    public static Playable Null { get; }
    [VisibleToOtherModulesAttribute]
internal Playable(PlayableHandle handle);
    private static Playable();
    public static Playable get_Null();
    public static Playable Create(PlayableGraph graph, int inputCount);
    public sealed virtual PlayableHandle GetHandle();
    public bool IsPlayableOfType();
    public Type GetPlayableType();
    public sealed virtual bool Equals(Playable other);
}
[AssetFileNameExtensionAttribute("playable", "Mono.Cecil.CustomAttributeArgument[]")]
[RequiredByNativeCodeAttribute]
public abstract class UnityEngine.Playables.PlayableAsset : ScriptableObject {
    public double duration { get; }
    public IEnumerable`1<PlayableBinding> outputs { get; }
    public abstract virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner);
    public virtual double get_duration();
    public virtual IEnumerable`1<PlayableBinding> get_outputs();
    [RequiredByNativeCodeAttribute]
internal static void Internal_CreatePlayable(PlayableAsset asset, PlayableGraph graph, GameObject go, IntPtr ptr);
    [RequiredByNativeCodeAttribute]
internal static void Internal_GetPlayableAssetDuration(PlayableAsset asset, IntPtr ptrToDouble);
}
[RequiredByNativeCodeAttribute]
public abstract class UnityEngine.Playables.PlayableBehaviour : object {
    public virtual void OnGraphStart(Playable playable);
    public virtual void OnGraphStop(Playable playable);
    public virtual void OnPlayableCreate(Playable playable);
    public virtual void OnPlayableDestroy(Playable playable);
    [ObsoleteAttribute("OnBehaviourDelay is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public virtual void OnBehaviourDelay(Playable playable, FrameData info);
    public virtual void OnBehaviourPlay(Playable playable, FrameData info);
    public virtual void OnBehaviourPause(Playable playable, FrameData info);
    public virtual void PrepareData(Playable playable, FrameData info);
    public virtual void PrepareFrame(Playable playable, FrameData info);
    public virtual void ProcessFrame(Playable playable, FrameData info, object playerData);
    public virtual object Clone();
}
public class UnityEngine.Playables.PlayableBinding : ValueType {
    private string m_StreamName;
    private Object m_SourceObject;
    private Type m_SourceBindingType;
    private CreateOutputMethod m_CreateOutputMethod;
    public static PlayableBinding[] None;
    public static double DefaultDuration;
    public string streamName { get; public set; }
    public Object sourceObject { get; public set; }
    public Type outputTargetType { get; }
    [ObsoleteAttribute("sourceBindingType is no longer supported on PlayableBinding. Use outputBindingType instead to get the required output target type, and the appropriate binding create method (e.g. AnimationPlayableBinding.Create(name, key)) to create PlayableBindings", "True")]
[EditorBrowsableAttribute("1")]
public Type sourceBindingType { get; public set; }
    [ObsoleteAttribute("streamType is no longer supported on PlayableBinding. Use the appropriate binding create method (e.g. AnimationPlayableBinding.Create(name, key)) instead.", "True")]
[EditorBrowsableAttribute("1")]
public DataStreamType streamType { get; public set; }
    private static PlayableBinding();
    public string get_streamName();
    public void set_streamName(string value);
    public Object get_sourceObject();
    public void set_sourceObject(Object value);
    public Type get_outputTargetType();
    public Type get_sourceBindingType();
    public void set_sourceBindingType(Type value);
    public DataStreamType get_streamType();
    public void set_streamType(DataStreamType value);
    internal PlayableOutput CreateOutput(PlayableGraph graph);
    [VisibleToOtherModulesAttribute]
internal static PlayableBinding CreateInternal(string name, Object sourceObject, Type sourceType, CreateOutputMethod createFunction);
}
[ExtensionAttribute]
public static class UnityEngine.Playables.PlayableExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(U playable);
    [ExtensionAttribute]
public static bool IsValid(U playable);
    [ExtensionAttribute]
public static void Destroy(U playable);
    [ExtensionAttribute]
public static PlayableGraph GetGraph(U playable);
    [ObsoleteAttribute("SetPlayState() has been deprecated. Use Play(), Pause() or SetDelay() instead", "False")]
[ExtensionAttribute]
public static void SetPlayState(U playable, PlayState value);
    [ExtensionAttribute]
public static PlayState GetPlayState(U playable);
    [ExtensionAttribute]
public static void Play(U playable);
    [ExtensionAttribute]
public static void Pause(U playable);
    [ExtensionAttribute]
public static void SetSpeed(U playable, double value);
    [ExtensionAttribute]
public static double GetSpeed(U playable);
    [ExtensionAttribute]
public static void SetDuration(U playable, double value);
    [ExtensionAttribute]
public static double GetDuration(U playable);
    [ExtensionAttribute]
public static void SetTime(U playable, double value);
    [ExtensionAttribute]
public static double GetTime(U playable);
    [ExtensionAttribute]
public static double GetPreviousTime(U playable);
    [ExtensionAttribute]
public static void SetDone(U playable, bool value);
    [ExtensionAttribute]
public static bool IsDone(U playable);
    [ExtensionAttribute]
public static void SetPropagateSetTime(U playable, bool value);
    [ExtensionAttribute]
public static bool GetPropagateSetTime(U playable);
    [ExtensionAttribute]
public static bool CanChangeInputs(U playable);
    [ExtensionAttribute]
public static bool CanSetWeights(U playable);
    [ExtensionAttribute]
public static bool CanDestroy(U playable);
    [ExtensionAttribute]
public static void SetInputCount(U playable, int value);
    [ExtensionAttribute]
public static int GetInputCount(U playable);
    [ExtensionAttribute]
public static void SetOutputCount(U playable, int value);
    [ExtensionAttribute]
public static int GetOutputCount(U playable);
    [ExtensionAttribute]
public static Playable GetInput(U playable, int inputPort);
    [ExtensionAttribute]
public static Playable GetOutput(U playable, int outputPort);
    [ExtensionAttribute]
public static void SetInputWeight(U playable, int inputIndex, float weight);
    [ExtensionAttribute]
public static void SetInputWeight(U playable, V input, float weight);
    [ExtensionAttribute]
public static float GetInputWeight(U playable, int inputIndex);
    [ExtensionAttribute]
public static void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex);
    [ExtensionAttribute]
public static void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex, float weight);
    [ExtensionAttribute]
public static void DisconnectInput(U playable, int inputPort);
    [ExtensionAttribute]
public static int AddInput(U playable, V sourcePlayable, int sourceOutputIndex, float weight);
    [ExtensionAttribute]
[ObsoleteAttribute("SetDelay is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public static void SetDelay(U playable, double delay);
    [ExtensionAttribute]
[ObsoleteAttribute("GetDelay is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public static double GetDelay(U playable);
    [ExtensionAttribute]
[ObsoleteAttribute("IsDelayed is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public static bool IsDelayed(U playable);
    [ExtensionAttribute]
public static void SetLeadTime(U playable, float value);
    [ExtensionAttribute]
public static float GetLeadTime(U playable);
    [ExtensionAttribute]
public static PlayableTraversalMode GetTraversalMode(U playable);
    [ExtensionAttribute]
public static void SetTraversalMode(U playable, PlayableTraversalMode mode);
    [ExtensionAttribute]
internal static DirectorWrapMode GetTimeWrapMode(U playable);
    [ExtensionAttribute]
internal static void SetTimeWrapMode(U playable, DirectorWrapMode value);
}
[NativeHeaderAttribute("Runtime/Export/Director/PlayableGraph.bindings.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayableOutput.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayableGraph.h")]
public class UnityEngine.Playables.PlayableGraph : ValueType {
    internal IntPtr m_Handle;
    internal UInt32 m_Version;
    public Playable GetRootPlayable(int index);
    public bool Connect(U source, int sourceOutputPort, V destination, int destinationInputPort);
    public void Disconnect(U input, int inputPort);
    public void DestroyPlayable(U playable);
    public void DestroySubgraph(U playable);
    public void DestroyOutput(U output);
    public int GetOutputCountByType();
    public PlayableOutput GetOutput(int index);
    public PlayableOutput GetOutputByType(int index);
    public void Evaluate();
    public static PlayableGraph Create();
    public static PlayableGraph Create(string name);
    [FreeFunctionAttribute("PlayableGraphBindings::Destroy")]
public void Destroy();
    public bool IsValid();
    [FreeFunctionAttribute("PlayableGraphBindings::IsPlaying")]
public bool IsPlaying();
    [FreeFunctionAttribute("PlayableGraphBindings::IsDone")]
public bool IsDone();
    [FreeFunctionAttribute("PlayableGraphBindings::Play")]
public void Play();
    [FreeFunctionAttribute("PlayableGraphBindings::Stop")]
public void Stop();
    [FreeFunctionAttribute("PlayableGraphBindings::Evaluate")]
public void Evaluate(float deltaTime);
    [FreeFunctionAttribute("PlayableGraphBindings::GetTimeUpdateMode")]
public DirectorUpdateMode GetTimeUpdateMode();
    [FreeFunctionAttribute("PlayableGraphBindings::SetTimeUpdateMode")]
public void SetTimeUpdateMode(DirectorUpdateMode value);
    [FreeFunctionAttribute("PlayableGraphBindings::GetResolver")]
public IExposedPropertyTable GetResolver();
    [FreeFunctionAttribute("PlayableGraphBindings::SetResolver")]
public void SetResolver(IExposedPropertyTable value);
    [FreeFunctionAttribute("PlayableGraphBindings::GetPlayableCount")]
public int GetPlayableCount();
    [FreeFunctionAttribute("PlayableGraphBindings::GetRootPlayableCount")]
public int GetRootPlayableCount();
    [FreeFunctionAttribute("PlayableGraphBindings::SynchronizeEvaluation")]
internal void SynchronizeEvaluation(PlayableGraph playable);
    [FreeFunctionAttribute("PlayableGraphBindings::GetOutputCount")]
public int GetOutputCount();
    [FreeFunctionAttribute("PlayableGraphBindings::CreatePlayableHandle")]
internal PlayableHandle CreatePlayableHandle();
    [FreeFunctionAttribute("PlayableGraphBindings::CreateScriptOutputInternal")]
internal bool CreateScriptOutputInternal(string name, PlayableOutputHandle& handle);
    [FreeFunctionAttribute("PlayableGraphBindings::GetRootPlayableInternal")]
internal PlayableHandle GetRootPlayableInternal(int index);
    [FreeFunctionAttribute("PlayableGraphBindings::DestroyOutputInternal")]
internal void DestroyOutputInternal(PlayableOutputHandle handle);
    [FreeFunctionAttribute("PlayableGraphBindings::IsMatchFrameRateEnabled")]
internal bool IsMatchFrameRateEnabled();
    [FreeFunctionAttribute("PlayableGraphBindings::EnableMatchFrameRate")]
internal void EnableMatchFrameRate(FrameRate frameRate);
    [FreeFunctionAttribute("PlayableGraphBindings::DisableMatchFrameRate")]
internal void DisableMatchFrameRate();
    [FreeFunctionAttribute("PlayableGraphBindings::GetFrameRate")]
internal FrameRate GetFrameRate();
    [FreeFunctionAttribute("PlayableGraphBindings::GetOutputInternal")]
private bool GetOutputInternal(int index, PlayableOutputHandle& handle);
    [FreeFunctionAttribute("PlayableGraphBindings::GetOutputCountByTypeInternal")]
private int GetOutputCountByTypeInternal(Type outputType);
    [FreeFunctionAttribute("PlayableGraphBindings::GetOutputByTypeInternal")]
private bool GetOutputByTypeInternal(Type outputType, int index, PlayableOutputHandle& handle);
    [FreeFunctionAttribute("PlayableGraphBindings::ConnectInternal")]
private bool ConnectInternal(PlayableHandle source, int sourceOutputPort, PlayableHandle destination, int destinationInputPort);
    [FreeFunctionAttribute("PlayableGraphBindings::DisconnectInternal")]
private void DisconnectInternal(PlayableHandle playable, int inputPort);
    [FreeFunctionAttribute("PlayableGraphBindings::DestroyPlayableInternal")]
private void DestroyPlayableInternal(PlayableHandle playable);
    [FreeFunctionAttribute("PlayableGraphBindings::DestroySubgraphInternal")]
private void DestroySubgraphInternal(PlayableHandle playable);
    private static void Create_Injected(string name, PlayableGraph& ret);
    private static void Destroy_Injected(PlayableGraph& _unity_self);
    private static bool IsValid_Injected(PlayableGraph& _unity_self);
    private static bool IsPlaying_Injected(PlayableGraph& _unity_self);
    private static bool IsDone_Injected(PlayableGraph& _unity_self);
    private static void Play_Injected(PlayableGraph& _unity_self);
    private static void Stop_Injected(PlayableGraph& _unity_self);
    private static void Evaluate_Injected(PlayableGraph& _unity_self, float deltaTime);
    private static DirectorUpdateMode GetTimeUpdateMode_Injected(PlayableGraph& _unity_self);
    private static void SetTimeUpdateMode_Injected(PlayableGraph& _unity_self, DirectorUpdateMode value);
    private static IExposedPropertyTable GetResolver_Injected(PlayableGraph& _unity_self);
    private static void SetResolver_Injected(PlayableGraph& _unity_self, IExposedPropertyTable value);
    private static int GetPlayableCount_Injected(PlayableGraph& _unity_self);
    private static int GetRootPlayableCount_Injected(PlayableGraph& _unity_self);
    private static void SynchronizeEvaluation_Injected(PlayableGraph& _unity_self, PlayableGraph& playable);
    private static int GetOutputCount_Injected(PlayableGraph& _unity_self);
    private static void CreatePlayableHandle_Injected(PlayableGraph& _unity_self, PlayableHandle& ret);
    private static bool CreateScriptOutputInternal_Injected(PlayableGraph& _unity_self, string name, PlayableOutputHandle& handle);
    private static void GetRootPlayableInternal_Injected(PlayableGraph& _unity_self, int index, PlayableHandle& ret);
    private static void DestroyOutputInternal_Injected(PlayableGraph& _unity_self, PlayableOutputHandle& handle);
    private static bool IsMatchFrameRateEnabled_Injected(PlayableGraph& _unity_self);
    private static void EnableMatchFrameRate_Injected(PlayableGraph& _unity_self, FrameRate& frameRate);
    private static void DisableMatchFrameRate_Injected(PlayableGraph& _unity_self);
    private static void GetFrameRate_Injected(PlayableGraph& _unity_self, FrameRate& ret);
    private static bool GetOutputInternal_Injected(PlayableGraph& _unity_self, int index, PlayableOutputHandle& handle);
    private static int GetOutputCountByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType);
    private static bool GetOutputByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType, int index, PlayableOutputHandle& handle);
    private static bool ConnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& source, int sourceOutputPort, PlayableHandle& destination, int destinationInputPort);
    private static void DisconnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable, int inputPort);
    private static void DestroyPlayableInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable);
    private static void DestroySubgraphInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable);
}
[NativeHeaderAttribute("Runtime/Export/Director/PlayableHandle.bindings.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayableGraph.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Playables.PlayableHandle : ValueType {
    internal IntPtr m_Handle;
    internal UInt32 m_Version;
    private static PlayableHandle m_Null;
    public static PlayableHandle Null { get; }
    private static PlayableHandle();
    internal T GetObject();
    [VisibleToOtherModulesAttribute]
internal bool IsPlayableOfType();
    public static PlayableHandle get_Null();
    internal Playable GetInput(int inputPort);
    internal Playable GetOutput(int outputPort);
    internal bool SetInputWeight(int inputIndex, float weight);
    internal float GetInputWeight(int inputIndex);
    internal void Destroy();
    public static bool op_Equality(PlayableHandle x, PlayableHandle y);
    public static bool op_Inequality(PlayableHandle x, PlayableHandle y);
    public virtual bool Equals(object p);
    public sealed virtual bool Equals(PlayableHandle other);
    public virtual int GetHashCode();
    internal static bool CompareVersion(PlayableHandle lhs, PlayableHandle rhs);
    internal bool CheckInputBounds(int inputIndex);
    internal bool CheckInputBounds(int inputIndex, bool acceptAny);
    [VisibleToOtherModulesAttribute]
internal bool IsNull();
    [VisibleToOtherModulesAttribute]
internal bool IsValid();
    [FreeFunctionAttribute("PlayableHandleBindings::GetPlayableType")]
[VisibleToOtherModulesAttribute]
internal Type GetPlayableType();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetJobType")]
internal Type GetJobType();
    [FreeFunctionAttribute("PlayableHandleBindings::SetScriptInstance")]
[VisibleToOtherModulesAttribute]
internal void SetScriptInstance(object scriptInstance);
    [FreeFunctionAttribute("PlayableHandleBindings::CanChangeInputs")]
[VisibleToOtherModulesAttribute]
internal bool CanChangeInputs();
    [FreeFunctionAttribute("PlayableHandleBindings::CanSetWeights")]
[VisibleToOtherModulesAttribute]
internal bool CanSetWeights();
    [FreeFunctionAttribute("PlayableHandleBindings::CanDestroy")]
[VisibleToOtherModulesAttribute]
internal bool CanDestroy();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetPlayState")]
internal PlayState GetPlayState();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::Play")]
internal void Play();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::Pause")]
internal void Pause();
    [FreeFunctionAttribute("PlayableHandleBindings::GetSpeed")]
[VisibleToOtherModulesAttribute]
internal double GetSpeed();
    [FreeFunctionAttribute("PlayableHandleBindings::SetSpeed")]
[VisibleToOtherModulesAttribute]
internal void SetSpeed(double value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetTime")]
internal double GetTime();
    [FreeFunctionAttribute("PlayableHandleBindings::SetTime")]
[VisibleToOtherModulesAttribute]
internal void SetTime(double value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::IsDone")]
internal bool IsDone();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetDone")]
internal void SetDone(bool value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetDuration")]
internal double GetDuration();
    [FreeFunctionAttribute("PlayableHandleBindings::SetDuration")]
[VisibleToOtherModulesAttribute]
internal void SetDuration(double value);
    [FreeFunctionAttribute("PlayableHandleBindings::GetPropagateSetTime")]
[VisibleToOtherModulesAttribute]
internal bool GetPropagateSetTime();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetPropagateSetTime")]
internal void SetPropagateSetTime(bool value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetGraph")]
internal PlayableGraph GetGraph();
    [FreeFunctionAttribute("PlayableHandleBindings::GetInputCount")]
[VisibleToOtherModulesAttribute]
internal int GetInputCount();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetInputCount")]
internal void SetInputCount(int value);
    [FreeFunctionAttribute("PlayableHandleBindings::GetOutputCount")]
[VisibleToOtherModulesAttribute]
internal int GetOutputCount();
    [FreeFunctionAttribute("PlayableHandleBindings::SetOutputCount")]
[VisibleToOtherModulesAttribute]
internal void SetOutputCount(int value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetInputWeight")]
internal void SetInputWeight(PlayableHandle input, float weight);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetDelay")]
internal void SetDelay(double delay);
    [FreeFunctionAttribute("PlayableHandleBindings::GetDelay")]
[VisibleToOtherModulesAttribute]
internal double GetDelay();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::IsDelayed")]
internal bool IsDelayed();
    [FreeFunctionAttribute("PlayableHandleBindings::GetPreviousTime")]
[VisibleToOtherModulesAttribute]
internal double GetPreviousTime();
    [FreeFunctionAttribute("PlayableHandleBindings::SetLeadTime")]
[VisibleToOtherModulesAttribute]
internal void SetLeadTime(float value);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetLeadTime")]
internal float GetLeadTime();
    [FreeFunctionAttribute("PlayableHandleBindings::GetTraversalMode")]
[VisibleToOtherModulesAttribute]
internal PlayableTraversalMode GetTraversalMode();
    [FreeFunctionAttribute("PlayableHandleBindings::SetTraversalMode")]
[VisibleToOtherModulesAttribute]
internal void SetTraversalMode(PlayableTraversalMode mode);
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetJobData")]
internal IntPtr GetJobData();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::GetTimeWrapMode")]
internal DirectorWrapMode GetTimeWrapMode();
    [VisibleToOtherModulesAttribute]
[FreeFunctionAttribute("PlayableHandleBindings::SetTimeWrapMode")]
internal void SetTimeWrapMode(DirectorWrapMode mode);
    [FreeFunctionAttribute("PlayableHandleBindings::GetScriptInstance")]
private object GetScriptInstance();
    [FreeFunctionAttribute("PlayableHandleBindings::GetInputHandle")]
private PlayableHandle GetInputHandle(int index);
    [FreeFunctionAttribute("PlayableHandleBindings::GetOutputHandle")]
private PlayableHandle GetOutputHandle(int index);
    [FreeFunctionAttribute("PlayableHandleBindings::SetInputWeightFromIndex")]
private void SetInputWeightFromIndex(int index, float weight);
    [FreeFunctionAttribute("PlayableHandleBindings::GetInputWeightFromIndex")]
private float GetInputWeightFromIndex(int index);
    private static bool IsNull_Injected(PlayableHandle& _unity_self);
    private static bool IsValid_Injected(PlayableHandle& _unity_self);
    private static Type GetPlayableType_Injected(PlayableHandle& _unity_self);
    private static Type GetJobType_Injected(PlayableHandle& _unity_self);
    private static void SetScriptInstance_Injected(PlayableHandle& _unity_self, object scriptInstance);
    private static bool CanChangeInputs_Injected(PlayableHandle& _unity_self);
    private static bool CanSetWeights_Injected(PlayableHandle& _unity_self);
    private static bool CanDestroy_Injected(PlayableHandle& _unity_self);
    private static PlayState GetPlayState_Injected(PlayableHandle& _unity_self);
    private static void Play_Injected(PlayableHandle& _unity_self);
    private static void Pause_Injected(PlayableHandle& _unity_self);
    private static double GetSpeed_Injected(PlayableHandle& _unity_self);
    private static void SetSpeed_Injected(PlayableHandle& _unity_self, double value);
    private static double GetTime_Injected(PlayableHandle& _unity_self);
    private static void SetTime_Injected(PlayableHandle& _unity_self, double value);
    private static bool IsDone_Injected(PlayableHandle& _unity_self);
    private static void SetDone_Injected(PlayableHandle& _unity_self, bool value);
    private static double GetDuration_Injected(PlayableHandle& _unity_self);
    private static void SetDuration_Injected(PlayableHandle& _unity_self, double value);
    private static bool GetPropagateSetTime_Injected(PlayableHandle& _unity_self);
    private static void SetPropagateSetTime_Injected(PlayableHandle& _unity_self, bool value);
    private static void GetGraph_Injected(PlayableHandle& _unity_self, PlayableGraph& ret);
    private static int GetInputCount_Injected(PlayableHandle& _unity_self);
    private static void SetInputCount_Injected(PlayableHandle& _unity_self, int value);
    private static int GetOutputCount_Injected(PlayableHandle& _unity_self);
    private static void SetOutputCount_Injected(PlayableHandle& _unity_self, int value);
    private static void SetInputWeight_Injected(PlayableHandle& _unity_self, PlayableHandle& input, float weight);
    private static void SetDelay_Injected(PlayableHandle& _unity_self, double delay);
    private static double GetDelay_Injected(PlayableHandle& _unity_self);
    private static bool IsDelayed_Injected(PlayableHandle& _unity_self);
    private static double GetPreviousTime_Injected(PlayableHandle& _unity_self);
    private static void SetLeadTime_Injected(PlayableHandle& _unity_self, float value);
    private static float GetLeadTime_Injected(PlayableHandle& _unity_self);
    private static PlayableTraversalMode GetTraversalMode_Injected(PlayableHandle& _unity_self);
    private static void SetTraversalMode_Injected(PlayableHandle& _unity_self, PlayableTraversalMode mode);
    private static IntPtr GetJobData_Injected(PlayableHandle& _unity_self);
    private static DirectorWrapMode GetTimeWrapMode_Injected(PlayableHandle& _unity_self);
    private static void SetTimeWrapMode_Injected(PlayableHandle& _unity_self, DirectorWrapMode mode);
    private static object GetScriptInstance_Injected(PlayableHandle& _unity_self);
    private static void GetInputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret);
    private static void GetOutputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret);
    private static void SetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index, float weight);
    private static float GetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index);
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Playables.PlayableOutput : ValueType {
    private PlayableOutputHandle m_Handle;
    private static PlayableOutput m_NullPlayableOutput;
    public static PlayableOutput Null { get; }
    [VisibleToOtherModulesAttribute]
internal PlayableOutput(PlayableOutputHandle handle);
    private static PlayableOutput();
    public static PlayableOutput get_Null();
    public sealed virtual PlayableOutputHandle GetHandle();
    public bool IsPlayableOutputOfType();
    public Type GetPlayableOutputType();
    public sealed virtual bool Equals(PlayableOutput other);
}
[ExtensionAttribute]
public static class UnityEngine.Playables.PlayableOutputExtensions : object {
    [ExtensionAttribute]
public static bool IsOutputNull(U output);
    [ExtensionAttribute]
public static bool IsOutputValid(U output);
    [ExtensionAttribute]
public static Object GetReferenceObject(U output);
    [ExtensionAttribute]
public static void SetReferenceObject(U output, Object value);
    [ExtensionAttribute]
public static Object GetUserData(U output);
    [ExtensionAttribute]
public static void SetUserData(U output, Object value);
    [ExtensionAttribute]
public static Playable GetSourcePlayable(U output);
    [ExtensionAttribute]
public static void SetSourcePlayable(U output, V value);
    [ExtensionAttribute]
public static void SetSourcePlayable(U output, V value, int port);
    [ExtensionAttribute]
public static int GetSourceOutputPort(U output);
    [ExtensionAttribute]
public static float GetWeight(U output);
    [ExtensionAttribute]
public static void SetWeight(U output, float value);
    [ExtensionAttribute]
public static void PushNotification(U output, Playable origin, INotification notification, object context);
    [ExtensionAttribute]
public static INotificationReceiver[] GetNotificationReceivers(U output);
    [ExtensionAttribute]
public static void AddNotificationReceiver(U output, INotificationReceiver receiver);
    [ExtensionAttribute]
public static void RemoveNotificationReceiver(U output, INotificationReceiver receiver);
    [ObsoleteAttribute("Method GetSourceInputPort has been renamed to GetSourceOutputPort (UnityUpgradable) -> GetSourceOutputPort<U>(*)", "False")]
[ExtensionAttribute]
public static int GetSourceInputPort(U output);
    [ExtensionAttribute]
[ObsoleteAttribute("Method SetSourceInputPort has been deprecated. Use SetSourcePlayable(Playable, Port) instead.", "False")]
public static void SetSourceInputPort(U output, int value);
    [ObsoleteAttribute("Method SetSourceOutputPort has been deprecated. Use SetSourcePlayable(Playable, Port) instead.", "False")]
[ExtensionAttribute]
public static void SetSourceOutputPort(U output, int value);
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayableOutput.h")]
[NativeHeaderAttribute("Runtime/Export/Director/PlayableOutputHandle.bindings.h")]
[NativeHeaderAttribute("Runtime/Director/Core/HPlayable.h")]
public class UnityEngine.Playables.PlayableOutputHandle : ValueType {
    internal IntPtr m_Handle;
    internal UInt32 m_Version;
    private static PlayableOutputHandle m_Null;
    public static PlayableOutputHandle Null { get; }
    private static PlayableOutputHandle();
    public static PlayableOutputHandle get_Null();
    [VisibleToOtherModulesAttribute]
internal bool IsPlayableOutputOfType();
    public virtual int GetHashCode();
    public static bool op_Equality(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
    public static bool op_Inequality(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
    public virtual bool Equals(object p);
    public sealed virtual bool Equals(PlayableOutputHandle other);
    internal static bool CompareVersion(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
    [VisibleToOtherModulesAttribute]
internal bool IsNull();
    [VisibleToOtherModulesAttribute]
internal bool IsValid();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetPlayableOutputType")]
internal Type GetPlayableOutputType();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetReferenceObject")]
internal Object GetReferenceObject();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::SetReferenceObject")]
internal void SetReferenceObject(Object target);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetUserData")]
internal Object GetUserData();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::SetUserData")]
internal void SetUserData(Object target);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetSourcePlayable")]
internal PlayableHandle GetSourcePlayable();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::SetSourcePlayable")]
internal void SetSourcePlayable(PlayableHandle target, int port);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetSourceOutputPort")]
internal int GetSourceOutputPort();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetWeight")]
internal float GetWeight();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::SetWeight")]
internal void SetWeight(float weight);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::PushNotification")]
internal void PushNotification(PlayableHandle origin, INotification notification, object context);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::GetNotificationReceivers")]
internal INotificationReceiver[] GetNotificationReceivers();
    [FreeFunctionAttribute("PlayableOutputHandleBindings::AddNotificationReceiver")]
internal void AddNotificationReceiver(INotificationReceiver receiver);
    [FreeFunctionAttribute("PlayableOutputHandleBindings::RemoveNotificationReceiver")]
internal void RemoveNotificationReceiver(INotificationReceiver receiver);
    private static bool IsNull_Injected(PlayableOutputHandle& _unity_self);
    private static bool IsValid_Injected(PlayableOutputHandle& _unity_self);
    private static Type GetPlayableOutputType_Injected(PlayableOutputHandle& _unity_self);
    private static Object GetReferenceObject_Injected(PlayableOutputHandle& _unity_self);
    private static void SetReferenceObject_Injected(PlayableOutputHandle& _unity_self, Object target);
    private static Object GetUserData_Injected(PlayableOutputHandle& _unity_self);
    private static void SetUserData_Injected(PlayableOutputHandle& _unity_self, Object target);
    private static void GetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& ret);
    private static void SetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& target, int port);
    private static int GetSourceOutputPort_Injected(PlayableOutputHandle& _unity_self);
    private static float GetWeight_Injected(PlayableOutputHandle& _unity_self);
    private static void SetWeight_Injected(PlayableOutputHandle& _unity_self, float weight);
    private static void PushNotification_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& origin, INotification notification, object context);
    private static INotificationReceiver[] GetNotificationReceivers_Injected(PlayableOutputHandle& _unity_self);
    private static void AddNotificationReceiver_Injected(PlayableOutputHandle& _unity_self, INotificationReceiver receiver);
    private static void RemoveNotificationReceiver_Injected(PlayableOutputHandle& _unity_self, INotificationReceiver receiver);
}
public enum UnityEngine.Playables.PlayableTraversalMode : Enum {
    public int value__;
    public static PlayableTraversalMode Mix;
    public static PlayableTraversalMode Passthrough;
}
public enum UnityEngine.Playables.PlayState : Enum {
    public int value__;
    public static PlayState Paused;
    public static PlayState Playing;
    [ObsoleteAttribute("Delayed is obsolete; use a custom ScriptPlayable to implement this feature", "False")]
public static PlayState Delayed;
}
public class UnityEngine.Playables.ScriptPlayable`1 : ValueType {
    private PlayableHandle m_Handle;
    private static ScriptPlayable`1<T> m_NullPlayable;
    public static ScriptPlayable`1<T> Null { get; }
    internal ScriptPlayable`1(PlayableHandle handle);
    private static ScriptPlayable`1();
    public static ScriptPlayable`1<T> get_Null();
    public static ScriptPlayable`1<T> Create(PlayableGraph graph, int inputCount);
    public static ScriptPlayable`1<T> Create(PlayableGraph graph, T template, int inputCount);
    private static PlayableHandle CreateHandle(PlayableGraph graph, T template, int inputCount);
    private static object CreateScriptInstance();
    private static object CloneScriptInstance(IPlayableBehaviour source);
    private static object CloneScriptInstanceFromEngineObject(Object source);
    private static object CloneScriptInstanceFromIClonable(ICloneable source);
    public sealed virtual PlayableHandle GetHandle();
    public T GetBehaviour();
    public static Playable op_Implicit(ScriptPlayable`1<T> playable);
    public static ScriptPlayable`1<T> op_Explicit(Playable playable);
    public sealed virtual bool Equals(ScriptPlayable`1<T> other);
}
public static class UnityEngine.Playables.ScriptPlayableBinding : object {
    public static PlayableBinding Create(string name, Object key, Type type);
    private static PlayableOutput CreateScriptOutput(PlayableGraph graph, string name);
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Playables.ScriptPlayableOutput : ValueType {
    private PlayableOutputHandle m_Handle;
    public static ScriptPlayableOutput Null { get; }
    internal ScriptPlayableOutput(PlayableOutputHandle handle);
    public static ScriptPlayableOutput Create(PlayableGraph graph, string name);
    public static ScriptPlayableOutput get_Null();
    public sealed virtual PlayableOutputHandle GetHandle();
    public static PlayableOutput op_Implicit(ScriptPlayableOutput output);
    public static ScriptPlayableOutput op_Explicit(PlayableOutput output);
}
[NativeHeaderAttribute("Runtime/Export/PlayerConnection/PlayerConnectionInternal.bindings.h")]
internal class UnityEngine.PlayerConnectionInternal : object {
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.SendMessage(Guid messageId, Byte[] data, int playerId);
    private sealed virtual override bool UnityEngine.IPlayerEditorConnectionNative.TrySendMessage(Guid messageId, Byte[] data, int playerId);
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.Poll();
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.RegisterInternal(Guid messageId);
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.UnregisterInternal(Guid messageId);
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.Initialize();
    private sealed virtual override bool UnityEngine.IPlayerEditorConnectionNative.IsConnected();
    private sealed virtual override void UnityEngine.IPlayerEditorConnectionNative.DisconnectAll();
    [FreeFunctionAttribute("PlayerConnection_Bindings::IsConnected")]
private static bool IsConnected();
    [FreeFunctionAttribute("PlayerConnection_Bindings::Initialize")]
private static void Initialize();
    [FreeFunctionAttribute("PlayerConnection_Bindings::RegisterInternal")]
private static void RegisterInternal(string messageId);
    [FreeFunctionAttribute("PlayerConnection_Bindings::UnregisterInternal")]
private static void UnregisterInternal(string messageId);
    [FreeFunctionAttribute("PlayerConnection_Bindings::SendMessage")]
private static void SendMessage(string messageId, Byte[] data, int playerId);
    [FreeFunctionAttribute("PlayerConnection_Bindings::TrySendMessage")]
private static bool TrySendMessage(string messageId, Byte[] data, int playerId);
    [FreeFunctionAttribute("PlayerConnection_Bindings::PollInternal")]
private static void PollInternal();
    [FreeFunctionAttribute("PlayerConnection_Bindings::DisconnectAll")]
private static void DisconnectAll();
}
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.EarlyUpdate : ValueType {
}
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.FixedUpdate : ValueType {
}
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.Initialization : ValueType {
}
[RequiredByNativeCodeAttribute]
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
public class UnityEngine.PlayerLoop.PostLateUpdate : ValueType {
}
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.PreLateUpdate : ValueType {
}
[RequiredByNativeCodeAttribute]
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
public class UnityEngine.PlayerLoop.PreUpdate : ValueType {
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.TimeUpdate : ValueType {
}
[MovedFromAttribute("UnityEngine.Experimental.PlayerLoop")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.PlayerLoop.Update : ValueType {
}
[NativeHeaderAttribute("Runtime/Utilities/PlayerPrefs.h")]
public class UnityEngine.PlayerPrefs : object {
    [NativeMethodAttribute("SetInt")]
private static bool TrySetInt(string key, int value);
    [NativeMethodAttribute("SetFloat")]
private static bool TrySetFloat(string key, float value);
    [NativeMethodAttribute("SetString")]
private static bool TrySetSetString(string key, string value);
    public static void SetInt(string key, int value);
    public static int GetInt(string key, int defaultValue);
    public static int GetInt(string key);
    public static void SetFloat(string key, float value);
    public static float GetFloat(string key, float defaultValue);
    public static float GetFloat(string key);
    public static void SetString(string key, string value);
    public static string GetString(string key, string defaultValue);
    public static string GetString(string key);
    public static bool HasKey(string key);
    public static void DeleteKey(string key);
    [NativeMethodAttribute("DeleteAllWithCallback")]
public static void DeleteAll();
    [NativeMethodAttribute("Sync")]
public static void Save();
}
public class UnityEngine.PlayerPrefsException : Exception {
    public PlayerPrefsException(string error);
}
public class UnityEngine.Pool.CollectionPool`2 : object {
    internal static ObjectPool`1<TCollection> s_Pool;
    private static CollectionPool`2();
    public static TCollection Get();
    public static PooledObject`1<TCollection> Get(TCollection& value);
    public static void Release(TCollection toRelease);
}
public class UnityEngine.Pool.DictionaryPool`2 : CollectionPool`2<Dictionary`2<TKey, TValue>, KeyValuePair`2<TKey, TValue>> {
}
public class UnityEngine.Pool.GenericPool`1 : object {
    internal static ObjectPool`1<T> s_Pool;
    private static GenericPool`1();
    public static T Get();
    public static PooledObject`1<T> Get(T& value);
    public static void Release(T toRelease);
}
public class UnityEngine.Pool.HashSetPool`1 : CollectionPool`2<HashSet`1<T>, T> {
}
public interface UnityEngine.Pool.IObjectPool`1 {
    public int CountInactive { get; }
    public abstract virtual int get_CountInactive();
    public abstract virtual T Get();
    public abstract virtual PooledObject`1<T> Get(T& v);
    public abstract virtual void Release(T element);
    public abstract virtual void Clear();
}
public class UnityEngine.Pool.LinkedPool`1 : object {
    private Func`1<T> m_CreateFunc;
    private Action`1<T> m_ActionOnGet;
    private Action`1<T> m_ActionOnRelease;
    private Action`1<T> m_ActionOnDestroy;
    private int m_Limit;
    internal LinkedPoolItem<T> m_PoolFirst;
    internal LinkedPoolItem<T> m_NextAvailableListItem;
    private bool m_CollectionCheck;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <CountInactive>k__BackingField;
    public int CountInactive { get; private set; }
    public LinkedPool`1(Func`1<T> createFunc, Action`1<T> actionOnGet, Action`1<T> actionOnRelease, Action`1<T> actionOnDestroy, bool collectionCheck, int maxSize);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CountInactive();
    [CompilerGeneratedAttribute]
private void set_CountInactive(int value);
    public sealed virtual T Get();
    public sealed virtual PooledObject`1<T> Get(T& v);
    public sealed virtual void Release(T item);
    public sealed virtual void Clear();
    public sealed virtual void Dispose();
}
public class UnityEngine.Pool.ListPool`1 : CollectionPool`2<List`1<T>, T> {
}
public class UnityEngine.Pool.ObjectPool`1 : object {
    internal List`1<T> m_List;
    private Func`1<T> m_CreateFunc;
    private Action`1<T> m_ActionOnGet;
    private Action`1<T> m_ActionOnRelease;
    private Action`1<T> m_ActionOnDestroy;
    private int m_MaxSize;
    internal bool m_CollectionCheck;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <CountAll>k__BackingField;
    public int CountAll { get; private set; }
    public int CountActive { get; }
    public int CountInactive { get; }
    public ObjectPool`1(Func`1<T> createFunc, Action`1<T> actionOnGet, Action`1<T> actionOnRelease, Action`1<T> actionOnDestroy, bool collectionCheck, int defaultCapacity, int maxSize);
    [CompilerGeneratedAttribute]
public int get_CountAll();
    [CompilerGeneratedAttribute]
private void set_CountAll(int value);
    public int get_CountActive();
    public sealed virtual int get_CountInactive();
    public sealed virtual T Get();
    public sealed virtual PooledObject`1<T> Get(T& v);
    public sealed virtual void Release(T element);
    public sealed virtual void Clear();
    public sealed virtual void Dispose();
}
public class UnityEngine.Pool.PooledObject`1 : ValueType {
    private T m_ToReturn;
    private IObjectPool`1<T> m_Pool;
    public PooledObject`1(T value, IObjectPool`1<T> pool);
    private sealed virtual override void System.IDisposable.Dispose();
}
public static class UnityEngine.Pool.UnsafeGenericPool`1 : object {
    internal static ObjectPool`1<T> s_Pool;
    private static UnsafeGenericPool`1();
    public static T Get();
    public static PooledObject`1<T> Get(T& value);
    public static void Release(T toRelease);
}
public class UnityEngine.Pose : ValueType {
    public Vector3 position;
    public Quaternion rotation;
    private static Pose k_Identity;
    public Vector3 forward { get; }
    public Vector3 right { get; }
    public Vector3 up { get; }
    public static Pose identity { get; }
    public Pose(Vector3 position, Quaternion rotation);
    private static Pose();
    public virtual string ToString();
    public string ToString(string format);
    public Pose GetTransformedBy(Pose lhs);
    public Pose GetTransformedBy(Transform lhs);
    public Vector3 get_forward();
    public Vector3 get_right();
    public Vector3 get_up();
    public static Pose get_identity();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Pose other);
    public virtual int GetHashCode();
    public static bool op_Equality(Pose a, Pose b);
    public static bool op_Inequality(Pose a, Pose b);
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("4")]
public class UnityEngine.PreferBinarySerialization : Attribute {
}
internal class UnityEngine.PreloadData : Object {
    [RequiredByNativeCodeAttribute]
internal void PreloadDataDontStripMe();
}
public enum UnityEngine.PrimitiveType : Enum {
    public int value__;
    public static PrimitiveType Sphere;
    public static PrimitiveType Capsule;
    public static PrimitiveType Cylinder;
    public static PrimitiveType Cube;
    public static PrimitiveType Plane;
    public static PrimitiveType Quad;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Profiler/ScriptBindings/Sampler.bindings.h")]
[NativeHeaderAttribute("Runtime/Profiler/Marker.h")]
public class UnityEngine.Profiling.CustomSampler : Sampler {
    internal static CustomSampler s_InvalidCustomSampler;
    internal CustomSampler(IntPtr ptr);
    private static CustomSampler();
    public static CustomSampler Create(string name, bool collectGpuData);
    [IgnoredByDeepProfilerAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public void Begin();
    [IgnoredByDeepProfilerAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public void Begin(Object targetObject);
    [IgnoredByDeepProfilerAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public void End();
}
[MovedFromAttribute("UnityEngine")]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/ScriptingBackend/ScriptingApi.h")]
[NativeHeaderAttribute("Runtime/Profiler/ScriptBindings/Profiler.bindings.h")]
[NativeHeaderAttribute("Runtime/Utilities/MemoryUtilities.h")]
[NativeHeaderAttribute("Runtime/Allocator/MemoryManager.h")]
[NativeHeaderAttribute("Runtime/Profiler/MemoryProfiler.h")]
[NativeHeaderAttribute("Runtime/Profiler/Profiler.h")]
public class UnityEngine.Profiling.Profiler : object {
    internal static UInt32 invalidProfilerArea;
    public static bool supported { get; }
    [StaticAccessorAttribute("ProfilerBindings", "2")]
public static string logFile { get; public set; }
    public static bool enableBinaryLog { get; public set; }
    public static int maxUsedMemory { get; public set; }
    public static bool enabled { get; public set; }
    public static bool enableAllocationCallstacks { get; public set; }
    public static int areaCount { get; }
    [ObsoleteAttribute("maxNumberOfSamplesPerFrame has been depricated. Use maxUsedMemory instead")]
public static int maxNumberOfSamplesPerFrame { get; public set; }
    [ObsoleteAttribute("usedHeapSize has been deprecated since it is limited to 4GB. Please use usedHeapSizeLong instead.")]
public static UInt32 usedHeapSize { get; }
    public static long usedHeapSizeLong { get; }
    [NativeMethodAttribute]
public static bool get_supported();
    public static string get_logFile();
    public static void set_logFile(string value);
    [NativeMethodAttribute]
public static bool get_enableBinaryLog();
    [NativeMethodAttribute]
public static void set_enableBinaryLog(bool value);
    [NativeMethodAttribute]
public static int get_maxUsedMemory();
    [NativeMethodAttribute]
public static void set_maxUsedMemory(int value);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
public static bool get_enabled();
    [NativeMethodAttribute]
public static void set_enabled(bool value);
    [NativeMethodAttribute]
public static bool get_enableAllocationCallstacks();
    [NativeMethodAttribute]
public static void set_enableAllocationCallstacks(bool value);
    [ConditionalAttribute("ENABLE_PROFILER")]
[FreeFunctionAttribute("ProfilerBindings::profiler_set_area_enabled")]
public static void SetAreaEnabled(ProfilerArea area, bool enabled);
    public static int get_areaCount();
    [NativeConditionalAttribute("ENABLE_PROFILER")]
[FreeFunctionAttribute("ProfilerBindings::profiler_is_area_enabled")]
public static bool GetAreaEnabled(ProfilerArea area);
    [ConditionalAttribute("UNITY_EDITOR")]
public static void AddFramesFromFile(string file);
    [NativeConditionalAttribute("ENABLE_PROFILER && UNITY_EDITOR")]
[NativeMethodAttribute]
[StaticAccessorAttribute("profiling::GetProfilerSessionPtr()", "1")]
[NativeHeaderAttribute("Modules/ProfilerEditor/Public/ProfilerSession.h")]
private static void AddFramesFromFile_Internal(string file, bool keepExistingFrames);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void BeginThreadProfiling(string threadGroupName, string threadName);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
private static void BeginThreadProfilingInternal(string threadGroupName, string threadName);
    [NativeConditionalAttribute("ENABLE_PROFILER")]
public static void EndThreadProfiling();
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void BeginSample(string name);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void BeginSample(string name, Object targetObject);
    private static void ValidateArguments(string name);
    [NativeMethodAttribute]
private static void BeginSampleImpl(string name, Object targetObject);
    [NativeMethodAttribute]
[ConditionalAttribute("ENABLE_PROFILER")]
public static void EndSample();
    public static int get_maxNumberOfSamplesPerFrame();
    public static void set_maxNumberOfSamplesPerFrame(int value);
    public static UInt32 get_usedHeapSize();
    [NativeMethodAttribute]
public static long get_usedHeapSizeLong();
    [ObsoleteAttribute("GetRuntimeMemorySize has been deprecated since it is limited to 2GB. Please use GetRuntimeMemorySizeLong() instead.")]
public static int GetRuntimeMemorySize(Object o);
    [NativeMethodAttribute]
public static long GetRuntimeMemorySizeLong(Object o);
    [ObsoleteAttribute("GetMonoHeapSize has been deprecated since it is limited to 4GB. Please use GetMonoHeapSizeLong() instead.")]
public static UInt32 GetMonoHeapSize();
    [NativeMethodAttribute]
public static long GetMonoHeapSizeLong();
    [ObsoleteAttribute("GetMonoUsedSize has been deprecated since it is limited to 4GB. Please use GetMonoUsedSizeLong() instead.")]
public static UInt32 GetMonoUsedSize();
    [NativeMethodAttribute]
public static long GetMonoUsedSizeLong();
    [StaticAccessorAttribute("GetMemoryManager()", "0")]
[NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
public static bool SetTempAllocatorRequestedSize(UInt32 size);
    [NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
[StaticAccessorAttribute("GetMemoryManager()", "0")]
public static UInt32 GetTempAllocatorSize();
    [ObsoleteAttribute("GetTotalAllocatedMemory has been deprecated since it is limited to 4GB. Please use GetTotalAllocatedMemoryLong() instead.")]
public static UInt32 GetTotalAllocatedMemory();
    [StaticAccessorAttribute("GetMemoryManager()", "0")]
[NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
public static long GetTotalAllocatedMemoryLong();
    [ObsoleteAttribute("GetTotalUnusedReservedMemory has been deprecated since it is limited to 4GB. Please use GetTotalUnusedReservedMemoryLong() instead.")]
public static UInt32 GetTotalUnusedReservedMemory();
    [NativeMethodAttribute]
[StaticAccessorAttribute("GetMemoryManager()", "0")]
[NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
public static long GetTotalUnusedReservedMemoryLong();
    [ObsoleteAttribute("GetTotalReservedMemory has been deprecated since it is limited to 4GB. Please use GetTotalReservedMemoryLong() instead.")]
public static UInt32 GetTotalReservedMemory();
    [StaticAccessorAttribute("GetMemoryManager()", "0")]
[NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
public static long GetTotalReservedMemoryLong();
    [NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
public static long GetTotalFragmentationInfo(NativeArray`1<int> stats);
    [StaticAccessorAttribute("GetMemoryManager()", "0")]
[NativeConditionalAttribute("ENABLE_MEMORY_MANAGER")]
[NativeMethodAttribute]
private static long InternalGetTotalFragmentationInfo(IntPtr pStats, int count);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
[StaticAccessorAttribute("MemoryProfiler", "2")]
public static long GetAllocatedMemoryForGraphicsDriver();
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitFrameMetaData(Guid id, int tag, Array data);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitFrameMetaData(Guid id, int tag, List`1<T> data);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitFrameMetaData(Guid id, int tag, NativeArray`1<T> data);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitSessionMetaData(Guid id, int tag, Array data);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitSessionMetaData(Guid id, int tag, List`1<T> data);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void EmitSessionMetaData(Guid id, int tag, NativeArray`1<T> data);
    [NativeConditionalAttribute("ENABLE_PROFILER")]
[NativeMethodAttribute]
private static void Internal_EmitGlobalMetaData_Array(Void* id, int idLen, int tag, Array data, int count, int elementSize, bool frameData);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
private static void Internal_EmitGlobalMetaData_Native(Void* id, int idLen, int tag, IntPtr data, int count, int elementSize, bool frameData);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void SetCategoryEnabled(ProfilerCategory category, bool enabled);
    public static bool IsCategoryEnabled(ProfilerCategory category);
    [NativeHeaderAttribute("Runtime/Profiler/ProfilerManager.h")]
[StaticAccessorAttribute("profiling::GetProfilerManagerPtr()", "1")]
[NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
public static UInt32 GetCategoriesCount();
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void GetAllCategories(ProfilerCategory[] categories);
    [ConditionalAttribute("ENABLE_PROFILER")]
public static void GetAllCategories(NativeArray`1<ProfilerCategory> categories);
    [NativeConditionalAttribute("ENABLE_PROFILER")]
[NativeMethodAttribute]
private static void Internal_SetCategoryEnabled(ushort categoryId, bool enabled);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_PROFILER")]
private static bool Internal_IsCategoryEnabled(ushort categoryId);
}
public enum UnityEngine.Profiling.ProfilerArea : Enum {
    public int value__;
    public static ProfilerArea CPU;
    public static ProfilerArea GPU;
    public static ProfilerArea Rendering;
    public static ProfilerArea Memory;
    public static ProfilerArea Audio;
    public static ProfilerArea Video;
    public static ProfilerArea Physics;
    public static ProfilerArea Physics2D;
    public static ProfilerArea NetworkMessages;
    public static ProfilerArea NetworkOperations;
    public static ProfilerArea UI;
    public static ProfilerArea UIDetails;
    public static ProfilerArea GlobalIllumination;
    public static ProfilerArea VirtualTexturing;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Profiling.Recorder : object {
    private static ProfilerRecorderOptions s_RecorderDefaultOptions;
    internal static Recorder s_InvalidRecorder;
    private ProfilerRecorder m_RecorderCPU;
    private ProfilerRecorder m_RecorderGPU;
    public bool isValid { get; }
    public bool enabled { get; public set; }
    public long elapsedNanoseconds { get; }
    public long gpuElapsedNanoseconds { get; }
    public int sampleBlockCount { get; }
    public int gpuSampleBlockCount { get; }
    internal Recorder(ProfilerRecorderHandle handle);
    private static Recorder();
    protected virtual override void Finalize();
    public static Recorder Get(string samplerName);
    public bool get_isValid();
    public bool get_enabled();
    public void set_enabled(bool value);
    public long get_elapsedNanoseconds();
    public long get_gpuElapsedNanoseconds();
    public int get_sampleBlockCount();
    public int get_gpuSampleBlockCount();
    public void FilterToCurrentThread();
    public void CollectFromAllThreads();
    private void SetEnabled(bool state);
}
[NativeHeaderAttribute("Runtime/Profiler/ScriptBindings/Sampler.bindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Profiling.Sampler : object {
    internal IntPtr m_Ptr;
    internal static Sampler s_InvalidSampler;
    public bool isValid { get; }
    public string name { get; }
    internal Sampler(IntPtr ptr);
    private static Sampler();
    public bool get_isValid();
    public Recorder GetRecorder();
    public static Sampler Get(string name);
    public static int GetNames(List`1<string> names);
    public string get_name();
}
[NativeHeaderAttribute("Runtime/Camera/Projector.h")]
public class UnityEngine.Projector : Behaviour {
    public float nearClipPlane { get; public set; }
    public float farClipPlane { get; public set; }
    public float fieldOfView { get; public set; }
    public float aspectRatio { get; public set; }
    public bool orthographic { get; public set; }
    public float orthographicSize { get; public set; }
    public int ignoreLayers { get; public set; }
    public Material material { get; public set; }
    public float get_nearClipPlane();
    public void set_nearClipPlane(float value);
    public float get_farClipPlane();
    public void set_farClipPlane(float value);
    public float get_fieldOfView();
    public void set_fieldOfView(float value);
    public float get_aspectRatio();
    public void set_aspectRatio(float value);
    public bool get_orthographic();
    public void set_orthographic(bool value);
    public float get_orthographicSize();
    public void set_orthographicSize(float value);
    public int get_ignoreLayers();
    public void set_ignoreLayers(int value);
    public Material get_material();
    public void set_material(Material value);
}
[AttributeUsageAttribute("256")]
[UsedByNativeCodeAttribute]
public abstract class UnityEngine.PropertyAttribute : Attribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <order>k__BackingField;
    public int order { get; public set; }
    [CompilerGeneratedAttribute]
public int get_order();
    [CompilerGeneratedAttribute]
public void set_order(int value);
}
[UsedByNativeCodeAttribute]
public class UnityEngine.PropertyName : ValueType {
    internal int id;
    public PropertyName(string name);
    public PropertyName(PropertyName other);
    public PropertyName(int id);
    public static bool IsNullOrEmpty(PropertyName prop);
    public static bool op_Equality(PropertyName lhs, PropertyName rhs);
    public static bool op_Inequality(PropertyName lhs, PropertyName rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(PropertyName other);
    public static PropertyName op_Implicit(string name);
    public static PropertyName op_Implicit(int id);
    public virtual string ToString();
}
[NativeHeaderAttribute("Runtime/Utilities/PropertyName.h")]
internal class UnityEngine.PropertyNameUtils : object {
    [FreeFunctionAttribute]
public static PropertyName PropertyNameFromString(string name);
    private static void PropertyNameFromString_Injected(string name, PropertyName& ret);
}
[ObsoleteAttribute("See QualitySettings.names, QualitySettings.SetQualityLevel, and QualitySettings.GetQualityLevel")]
public enum UnityEngine.QualityLevel : Enum {
    public int value__;
    public static QualityLevel Fastest;
    public static QualityLevel Fast;
    public static QualityLevel Simple;
    public static QualityLevel Good;
    public static QualityLevel Beautiful;
    public static QualityLevel Fantastic;
}
[StaticAccessorAttribute("GetQualitySettings()", "0")]
[NativeHeaderAttribute("Runtime/Misc/PlayerSettings.h")]
[NativeHeaderAttribute("Runtime/Graphics/QualitySettings.h")]
public class UnityEngine.QualitySettings : Object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<int, int> activeQualityLevelChanged;
    [ObsoleteAttribute("Use GetQualityLevel and SetQualityLevel", "False")]
public static QualityLevel currentLevel { get; public set; }
    public static int pixelLightCount { get; public set; }
    [NativePropertyAttribute("ShadowQuality")]
public static ShadowQuality shadows { get; public set; }
    public static ShadowProjection shadowProjection { get; public set; }
    public static int shadowCascades { get; public set; }
    public static float shadowDistance { get; public set; }
    [NativePropertyAttribute("ShadowResolution")]
public static ShadowResolution shadowResolution { get; public set; }
    [NativePropertyAttribute("ShadowmaskMode")]
public static ShadowmaskMode shadowmaskMode { get; public set; }
    public static float shadowNearPlaneOffset { get; public set; }
    public static float shadowCascade2Split { get; public set; }
    public static Vector3 shadowCascade4Split { get; public set; }
    [NativePropertyAttribute("LODBias")]
public static float lodBias { get; public set; }
    [NativePropertyAttribute("AnisotropicTextures")]
public static AnisotropicFiltering anisotropicFiltering { get; public set; }
    [NativePropertyAttribute("GlobalTextureMipmapLimit")]
[ObsoleteAttribute("masterTextureLimit has been deprecated. Use globalTextureMipmapLimit instead (UnityUpgradable) -> globalTextureMipmapLimit", "False")]
public static int masterTextureLimit { get; public set; }
    public static int globalTextureMipmapLimit { get; public set; }
    public static int maximumLODLevel { get; public set; }
    public static bool enableLODCrossFade { get; public set; }
    public static int particleRaycastBudget { get; public set; }
    public static bool softParticles { get; public set; }
    public static bool softVegetation { get; public set; }
    public static int vSyncCount { get; public set; }
    public static int realtimeGICPUUsage { get; public set; }
    public static int antiAliasing { get; public set; }
    public static int asyncUploadTimeSlice { get; public set; }
    public static int asyncUploadBufferSize { get; public set; }
    public static bool asyncUploadPersistentBuffer { get; public set; }
    public static bool realtimeReflectionProbes { get; public set; }
    public static bool billboardsFaceCameraPosition { get; public set; }
    public static bool useLegacyDetailDistribution { get; public set; }
    public static float resolutionScalingFixedDPIFactor { get; public set; }
    public static TerrainQualityOverrides terrainQualityOverrides { get; public set; }
    public static float terrainPixelError { get; public set; }
    public static float terrainDetailDensityScale { get; public set; }
    public static float terrainBasemapDistance { get; public set; }
    public static float terrainDetailDistance { get; public set; }
    public static float terrainTreeDistance { get; public set; }
    public static float terrainBillboardStart { get; public set; }
    public static float terrainFadeLength { get; public set; }
    public static float terrainMaxTrees { get; public set; }
    [NativeNameAttribute("RenderPipeline")]
private static ScriptableObject INTERNAL_renderPipeline { get; private set; }
    public static RenderPipelineAsset renderPipeline { get; public set; }
    [ObsoleteAttribute("blendWeights is obsolete. Use skinWeights instead (UnityUpgradable) -> skinWeights", "True")]
public static BlendWeights blendWeights { get; public set; }
    public static SkinWeights skinWeights { get; public set; }
    public static int count { get; }
    public static bool streamingMipmapsActive { get; public set; }
    public static float streamingMipmapsMemoryBudget { get; public set; }
    public static int streamingMipmapsRenderersPerFrame { get; public set; }
    public static int streamingMipmapsMaxLevelReduction { get; public set; }
    public static bool streamingMipmapsAddAllCameras { get; public set; }
    public static int streamingMipmapsMaxFileIORequests { get; public set; }
    [StaticAccessorAttribute("QualitySettingsScripting", "2")]
public static int maxQueuedFrames { get; public set; }
    [NativePropertyAttribute("QualitySettingsNames")]
public static String[] names { get; }
    public static ColorSpace desiredColorSpace { get; }
    public static ColorSpace activeColorSpace { get; }
    [CompilerGeneratedAttribute]
public static void add_activeQualityLevelChanged(Action`2<int, int> value);
    [CompilerGeneratedAttribute]
public static void remove_activeQualityLevelChanged(Action`2<int, int> value);
    [RequiredByNativeCodeAttribute]
internal static void OnActiveQualityLevelChanged(int previousQualityLevel, int currentQualityLevel);
    public static void IncreaseLevel(bool applyExpensiveChanges);
    public static void DecreaseLevel(bool applyExpensiveChanges);
    public static void SetQualityLevel(int index);
    public static void IncreaseLevel();
    public static void DecreaseLevel();
    public static QualityLevel get_currentLevel();
    public static void set_currentLevel(QualityLevel value);
    public static void ForEach(Action callback);
    public static void ForEach(Action`2<int, string> callback);
    public static int get_pixelLightCount();
    public static void set_pixelLightCount(int value);
    public static ShadowQuality get_shadows();
    public static void set_shadows(ShadowQuality value);
    public static ShadowProjection get_shadowProjection();
    public static void set_shadowProjection(ShadowProjection value);
    public static int get_shadowCascades();
    public static void set_shadowCascades(int value);
    public static float get_shadowDistance();
    public static void set_shadowDistance(float value);
    public static ShadowResolution get_shadowResolution();
    public static void set_shadowResolution(ShadowResolution value);
    public static ShadowmaskMode get_shadowmaskMode();
    public static void set_shadowmaskMode(ShadowmaskMode value);
    public static float get_shadowNearPlaneOffset();
    public static void set_shadowNearPlaneOffset(float value);
    public static float get_shadowCascade2Split();
    public static void set_shadowCascade2Split(float value);
    public static Vector3 get_shadowCascade4Split();
    public static void set_shadowCascade4Split(Vector3 value);
    public static float get_lodBias();
    public static void set_lodBias(float value);
    public static AnisotropicFiltering get_anisotropicFiltering();
    public static void set_anisotropicFiltering(AnisotropicFiltering value);
    public static int get_masterTextureLimit();
    public static void set_masterTextureLimit(int value);
    public static int get_globalTextureMipmapLimit();
    public static void set_globalTextureMipmapLimit(int value);
    public static int get_maximumLODLevel();
    public static void set_maximumLODLevel(int value);
    public static bool get_enableLODCrossFade();
    public static void set_enableLODCrossFade(bool value);
    public static int get_particleRaycastBudget();
    public static void set_particleRaycastBudget(int value);
    public static bool get_softParticles();
    public static void set_softParticles(bool value);
    public static bool get_softVegetation();
    public static void set_softVegetation(bool value);
    public static int get_vSyncCount();
    public static void set_vSyncCount(int value);
    public static int get_realtimeGICPUUsage();
    public static void set_realtimeGICPUUsage(int value);
    public static int get_antiAliasing();
    public static void set_antiAliasing(int value);
    public static int get_asyncUploadTimeSlice();
    public static void set_asyncUploadTimeSlice(int value);
    public static int get_asyncUploadBufferSize();
    public static void set_asyncUploadBufferSize(int value);
    public static bool get_asyncUploadPersistentBuffer();
    public static void set_asyncUploadPersistentBuffer(bool value);
    [NativeNameAttribute("SetLODSettings")]
public static void SetLODSettings(float lodBias, int maximumLODLevel, bool setDirty);
    [NativeThrowsAttribute]
[NativeNameAttribute("SetTextureMipmapLimitSettings")]
public static void SetTextureMipmapLimitSettings(string groupName, TextureMipmapLimitSettings textureMipmapLimitSettings);
    [NativeThrowsAttribute]
[NativeNameAttribute("GetTextureMipmapLimitSettings")]
public static TextureMipmapLimitSettings GetTextureMipmapLimitSettings(string groupName);
    public static bool get_realtimeReflectionProbes();
    public static void set_realtimeReflectionProbes(bool value);
    public static bool get_billboardsFaceCameraPosition();
    public static void set_billboardsFaceCameraPosition(bool value);
    public static bool get_useLegacyDetailDistribution();
    public static void set_useLegacyDetailDistribution(bool value);
    public static float get_resolutionScalingFixedDPIFactor();
    public static void set_resolutionScalingFixedDPIFactor(float value);
    public static TerrainQualityOverrides get_terrainQualityOverrides();
    public static void set_terrainQualityOverrides(TerrainQualityOverrides value);
    public static float get_terrainPixelError();
    public static void set_terrainPixelError(float value);
    public static float get_terrainDetailDensityScale();
    public static void set_terrainDetailDensityScale(float value);
    public static float get_terrainBasemapDistance();
    public static void set_terrainBasemapDistance(float value);
    public static float get_terrainDetailDistance();
    public static void set_terrainDetailDistance(float value);
    public static float get_terrainTreeDistance();
    public static void set_terrainTreeDistance(float value);
    public static float get_terrainBillboardStart();
    public static void set_terrainBillboardStart(float value);
    public static float get_terrainFadeLength();
    public static void set_terrainFadeLength(float value);
    public static float get_terrainMaxTrees();
    public static void set_terrainMaxTrees(float value);
    private static ScriptableObject get_INTERNAL_renderPipeline();
    private static void set_INTERNAL_renderPipeline(ScriptableObject value);
    public static RenderPipelineAsset get_renderPipeline();
    public static void set_renderPipeline(RenderPipelineAsset value);
    [NativeNameAttribute("GetRenderPipelineAssetAt")]
internal static ScriptableObject InternalGetRenderPipelineAssetAt(int index);
    public static RenderPipelineAsset GetRenderPipelineAssetAt(int index);
    [NativeNameAttribute("GetSkinWeights")]
public static BlendWeights get_blendWeights();
    [NativeNameAttribute("SetSkinWeights")]
public static void set_blendWeights(BlendWeights value);
    public static SkinWeights get_skinWeights();
    public static void set_skinWeights(SkinWeights value);
    [NativeNameAttribute("GetQualitySettingsCount")]
public static int get_count();
    public static bool get_streamingMipmapsActive();
    public static void set_streamingMipmapsActive(bool value);
    public static float get_streamingMipmapsMemoryBudget();
    public static void set_streamingMipmapsMemoryBudget(float value);
    public static int get_streamingMipmapsRenderersPerFrame();
    public static void set_streamingMipmapsRenderersPerFrame(int value);
    public static int get_streamingMipmapsMaxLevelReduction();
    public static void set_streamingMipmapsMaxLevelReduction(int value);
    public static bool get_streamingMipmapsAddAllCameras();
    public static void set_streamingMipmapsAddAllCameras(bool value);
    public static int get_streamingMipmapsMaxFileIORequests();
    public static void set_streamingMipmapsMaxFileIORequests(int value);
    public static int get_maxQueuedFrames();
    public static void set_maxQueuedFrames(int value);
    [NativeNameAttribute("GetCurrentIndex")]
public static int GetQualityLevel();
    [FreeFunctionAttribute]
public static Object GetQualitySettings();
    [NativeNameAttribute("SetCurrentIndex")]
public static void SetQualityLevel(int index, bool applyExpensiveChanges);
    public static String[] get_names();
    [NativeNameAttribute("GetColorSpace")]
[StaticAccessorAttribute("GetPlayerSettings()", "0")]
public static ColorSpace get_desiredColorSpace();
    [StaticAccessorAttribute("GetPlayerSettings()", "0")]
[NativeNameAttribute("GetColorSpace")]
public static ColorSpace get_activeColorSpace();
    private static void get_shadowCascade4Split_Injected(Vector3& ret);
    private static void set_shadowCascade4Split_Injected(Vector3& value);
    private static void SetTextureMipmapLimitSettings_Injected(string groupName, TextureMipmapLimitSettings& textureMipmapLimitSettings);
    private static void GetTextureMipmapLimitSettings_Injected(string groupName, TextureMipmapLimitSettings& ret);
}
[NativeTypeAttribute]
[Il2CppEagerStaticClassConstructionAttribute]
[DefaultMemberAttribute("Item")]
[NativeHeaderAttribute("Runtime/Math/MathScripting.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Quaternion : ValueType {
    public float x;
    public float y;
    public float z;
    public float w;
    private static Quaternion identityQuaternion;
    public static float kEpsilon;
    public float Item { get; public set; }
    public static Quaternion identity { get; }
    public Vector3 eulerAngles { get; public set; }
    public Quaternion normalized { get; }
    public Quaternion(float x, float y, float z, float w);
    private static Quaternion();
    [FreeFunctionAttribute("FromToQuaternionSafe")]
public static Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection);
    [FreeFunctionAttribute]
public static Quaternion Inverse(Quaternion rotation);
    [FreeFunctionAttribute("QuaternionScripting::Slerp")]
public static Quaternion Slerp(Quaternion a, Quaternion b, float t);
    [FreeFunctionAttribute("QuaternionScripting::SlerpUnclamped")]
public static Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t);
    [FreeFunctionAttribute("QuaternionScripting::Lerp")]
public static Quaternion Lerp(Quaternion a, Quaternion b, float t);
    [FreeFunctionAttribute("QuaternionScripting::LerpUnclamped")]
public static Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t);
    [FreeFunctionAttribute("EulerToQuaternion")]
private static Quaternion Internal_FromEulerRad(Vector3 euler);
    [FreeFunctionAttribute("QuaternionScripting::ToEuler")]
private static Vector3 Internal_ToEulerRad(Quaternion rotation);
    [FreeFunctionAttribute("QuaternionScripting::ToAxisAngle")]
private static void Internal_ToAxisAngleRad(Quaternion q, Vector3& axis, Single& angle);
    [FreeFunctionAttribute("QuaternionScripting::AngleAxis")]
public static Quaternion AngleAxis(float angle, Vector3 axis);
    [FreeFunctionAttribute("QuaternionScripting::LookRotation")]
public static Quaternion LookRotation(Vector3 forward, Vector3 upwards);
    [ExcludeFromDocsAttribute]
public static Quaternion LookRotation(Vector3 forward);
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Set(float newX, float newY, float newZ, float newW);
    public static Quaternion get_identity();
    public static Quaternion op_Multiply(Quaternion lhs, Quaternion rhs);
    public static Vector3 op_Multiply(Quaternion rotation, Vector3 point);
    private static bool IsEqualUsingDot(float dot);
    public static bool op_Equality(Quaternion lhs, Quaternion rhs);
    public static bool op_Inequality(Quaternion lhs, Quaternion rhs);
    public static float Dot(Quaternion a, Quaternion b);
    [ExcludeFromDocsAttribute]
public void SetLookRotation(Vector3 view);
    public void SetLookRotation(Vector3 view, Vector3 up);
    public static float Angle(Quaternion a, Quaternion b);
    private static Vector3 Internal_MakePositive(Vector3 euler);
    public Vector3 get_eulerAngles();
    public void set_eulerAngles(Vector3 value);
    public static Quaternion Euler(float x, float y, float z);
    public static Quaternion Euler(Vector3 euler);
    public void ToAngleAxis(Single& angle, Vector3& axis);
    public void SetFromToRotation(Vector3 fromDirection, Vector3 toDirection);
    public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta);
    public static Quaternion Normalize(Quaternion q);
    public void Normalize();
    public Quaternion get_normalized();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Quaternion other);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public static Quaternion EulerRotation(float x, float y, float z);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public static Quaternion EulerRotation(Vector3 euler);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public void SetEulerRotation(float x, float y, float z);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public void SetEulerRotation(Vector3 euler);
    [ObsoleteAttribute("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
public Vector3 ToEuler();
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public static Quaternion EulerAngles(float x, float y, float z);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public static Quaternion EulerAngles(Vector3 euler);
    [ObsoleteAttribute("Use Quaternion.ToAngleAxis instead. This function was deprecated because it uses radians instead of degrees.")]
public void ToAxisAngle(Vector3& axis, Single& angle);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public void SetEulerAngles(float x, float y, float z);
    [ObsoleteAttribute("Use Quaternion.Euler instead. This function was deprecated because it uses radians instead of degrees.")]
public void SetEulerAngles(Vector3 euler);
    [ObsoleteAttribute("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
public static Vector3 ToEulerAngles(Quaternion rotation);
    [ObsoleteAttribute("Use Quaternion.eulerAngles instead. This function was deprecated because it uses radians instead of degrees.")]
public Vector3 ToEulerAngles();
    [ObsoleteAttribute("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees.")]
public void SetAxisAngle(Vector3 axis, float angle);
    [ObsoleteAttribute("Use Quaternion.AngleAxis instead. This function was deprecated because it uses radians instead of degrees")]
public static Quaternion AxisAngle(Vector3 axis, float angle);
    private static void FromToRotation_Injected(Vector3& fromDirection, Vector3& toDirection, Quaternion& ret);
    private static void Inverse_Injected(Quaternion& rotation, Quaternion& ret);
    private static void Slerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret);
    private static void SlerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret);
    private static void Lerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret);
    private static void LerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret);
    private static void Internal_FromEulerRad_Injected(Vector3& euler, Quaternion& ret);
    private static void Internal_ToEulerRad_Injected(Quaternion& rotation, Vector3& ret);
    private static void Internal_ToAxisAngleRad_Injected(Quaternion& q, Vector3& axis, Single& angle);
    private static void AngleAxis_Injected(float angle, Vector3& axis, Quaternion& ret);
    private static void LookRotation_Injected(Vector3& forward, Vector3& upwards, Quaternion& ret);
}
[NativeHeaderAttribute("Runtime/Export/Random/Random.bindings.h")]
public static class UnityEngine.Random : object {
    [StaticAccessorAttribute("GetScriptingRand()", "0")]
public static State state { get; public set; }
    public static float value { get; }
    public static Vector3 insideUnitSphere { get; }
    public static Vector2 insideUnitCircle { get; }
    public static Vector3 onUnitSphere { get; }
    public static Quaternion rotation { get; }
    public static Quaternion rotationUniform { get; }
    [StaticAccessorAttribute("GetScriptingRand()", "0")]
[ObsoleteAttribute("Deprecated. Use InitState() function or Random.state property instead.")]
public static int seed { get; public set; }
    [StaticAccessorAttribute("GetScriptingRand()", "0")]
[NativeMethodAttribute("SetSeed")]
public static void InitState(int seed);
    public static State get_state();
    public static void set_state(State value);
    [FreeFunctionAttribute]
public static float Range(float minInclusive, float maxInclusive);
    public static int Range(int minInclusive, int maxExclusive);
    [FreeFunctionAttribute]
private static int RandomRangeInt(int minInclusive, int maxExclusive);
    [FreeFunctionAttribute]
public static float get_value();
    [FreeFunctionAttribute]
public static Vector3 get_insideUnitSphere();
    [FreeFunctionAttribute]
private static void GetRandomUnitCircle(Vector2& output);
    public static Vector2 get_insideUnitCircle();
    [FreeFunctionAttribute]
public static Vector3 get_onUnitSphere();
    [FreeFunctionAttribute]
public static Quaternion get_rotation();
    [FreeFunctionAttribute]
public static Quaternion get_rotationUniform();
    public static int get_seed();
    public static void set_seed(int value);
    [ObsoleteAttribute("Use Random.Range instead")]
public static float RandomRange(float min, float max);
    [ObsoleteAttribute("Use Random.Range instead")]
public static int RandomRange(int min, int max);
    public static Color ColorHSV();
    public static Color ColorHSV(float hueMin, float hueMax);
    public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax);
    public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax);
    public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax, float alphaMin, float alphaMax);
    private static void get_state_Injected(State& ret);
    private static void set_state_Injected(State& value);
    private static void get_insideUnitSphere_Injected(Vector3& ret);
    private static void get_onUnitSphere_Injected(Vector3& ret);
    private static void get_rotation_Injected(Quaternion& ret);
    private static void get_rotationUniform_Injected(Quaternion& ret);
}
[AttributeUsageAttribute("256")]
public class UnityEngine.RangeAttribute : PropertyAttribute {
    public float min;
    public float max;
    public RangeAttribute(float min, float max);
}
public class UnityEngine.RangeInt : ValueType {
    public int start;
    public int length;
    public int end { get; }
    public RangeInt(int start, int length);
    public int get_end();
}
public class UnityEngine.Ray : ValueType {
    private Vector3 m_Origin;
    private Vector3 m_Direction;
    public Vector3 origin { get; public set; }
    public Vector3 direction { get; public set; }
    public Ray(Vector3 origin, Vector3 direction);
    public Vector3 get_origin();
    public void set_origin(Vector3 value);
    public Vector3 get_direction();
    public void set_direction(Vector3 value);
    public Vector3 GetPoint(float distance);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public class UnityEngine.Ray2D : ValueType {
    private Vector2 m_Origin;
    private Vector2 m_Direction;
    public Vector2 origin { get; public set; }
    public Vector2 direction { get; public set; }
    public Ray2D(Vector2 origin, Vector2 direction);
    public Vector2 get_origin();
    public void set_origin(Vector2 value);
    public Vector2 get_direction();
    public void set_direction(Vector2 value);
    public Vector2 GetPoint(float distance);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
public enum UnityEngine.ReceiveGI : Enum {
    public int value__;
    public static ReceiveGI Lightmaps;
    public static ReceiveGI LightProbes;
}
[RequiredByNativeCodeAttribute]
[NativeClassAttribute("Rectf", "template<typename T> class RectT; typedef RectT<float> Rectf;")]
[NativeHeaderAttribute("Runtime/Math/Rect.h")]
public class UnityEngine.Rect : ValueType {
    [NativeNameAttribute("x")]
private float m_XMin;
    [NativeNameAttribute("y")]
private float m_YMin;
    [NativeNameAttribute("width")]
private float m_Width;
    [NativeNameAttribute("height")]
private float m_Height;
    public static Rect zero { get; }
    public float x { get; public set; }
    public float y { get; public set; }
    public Vector2 position { get; public set; }
    public Vector2 center { get; public set; }
    public Vector2 min { get; public set; }
    public Vector2 max { get; public set; }
    public float width { get; public set; }
    public float height { get; public set; }
    public Vector2 size { get; public set; }
    public float xMin { get; public set; }
    public float yMin { get; public set; }
    public float xMax { get; public set; }
    public float yMax { get; public set; }
    [ObsoleteAttribute("use xMin")]
public float left { get; }
    [ObsoleteAttribute("use xMax")]
public float right { get; }
    [ObsoleteAttribute("use yMin")]
public float top { get; }
    [ObsoleteAttribute("use yMax")]
public float bottom { get; }
    public Rect(float x, float y, float width, float height);
    public Rect(Vector2 position, Vector2 size);
    public Rect(Rect source);
    public static Rect get_zero();
    public static Rect MinMaxRect(float xmin, float ymin, float xmax, float ymax);
    public void Set(float x, float y, float width, float height);
    public float get_x();
    public void set_x(float value);
    public float get_y();
    public void set_y(float value);
    public Vector2 get_position();
    public void set_position(Vector2 value);
    public Vector2 get_center();
    public void set_center(Vector2 value);
    public Vector2 get_min();
    public void set_min(Vector2 value);
    public Vector2 get_max();
    public void set_max(Vector2 value);
    public float get_width();
    public void set_width(float value);
    public float get_height();
    public void set_height(float value);
    public Vector2 get_size();
    public void set_size(Vector2 value);
    public float get_xMin();
    public void set_xMin(float value);
    public float get_yMin();
    public void set_yMin(float value);
    public float get_xMax();
    public void set_xMax(float value);
    public float get_yMax();
    public void set_yMax(float value);
    public bool Contains(Vector2 point);
    public bool Contains(Vector3 point);
    public bool Contains(Vector3 point, bool allowInverse);
    private static Rect OrderMinMax(Rect rect);
    public bool Overlaps(Rect other);
    public bool Overlaps(Rect other, bool allowInverse);
    public static Vector2 NormalizedToPoint(Rect rectangle, Vector2 normalizedRectCoordinates);
    public static Vector2 PointToNormalized(Rect rectangle, Vector2 point);
    public static bool op_Inequality(Rect lhs, Rect rhs);
    public static bool op_Equality(Rect lhs, Rect rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Rect other);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public float get_left();
    public float get_right();
    public float get_top();
    public float get_bottom();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.RectInt : ValueType {
    private int m_XMin;
    private int m_YMin;
    private int m_Width;
    private int m_Height;
    public int x { get; public set; }
    public int y { get; public set; }
    public Vector2 center { get; }
    public Vector2Int min { get; public set; }
    public Vector2Int max { get; public set; }
    public int width { get; public set; }
    public int height { get; public set; }
    public int xMin { get; public set; }
    public int yMin { get; public set; }
    public int xMax { get; public set; }
    public int yMax { get; public set; }
    public Vector2Int position { get; public set; }
    public Vector2Int size { get; public set; }
    public PositionEnumerator allPositionsWithin { get; }
    public RectInt(int xMin, int yMin, int width, int height);
    public RectInt(Vector2Int position, Vector2Int size);
    public int get_x();
    public void set_x(int value);
    public int get_y();
    public void set_y(int value);
    public Vector2 get_center();
    public Vector2Int get_min();
    public void set_min(Vector2Int value);
    public Vector2Int get_max();
    public void set_max(Vector2Int value);
    public int get_width();
    public void set_width(int value);
    public int get_height();
    public void set_height(int value);
    public int get_xMin();
    public void set_xMin(int value);
    public int get_yMin();
    public void set_yMin(int value);
    public int get_xMax();
    public void set_xMax(int value);
    public int get_yMax();
    public void set_yMax(int value);
    public Vector2Int get_position();
    public void set_position(Vector2Int value);
    public Vector2Int get_size();
    public void set_size(Vector2Int value);
    public void SetMinMax(Vector2Int minPosition, Vector2Int maxPosition);
    public void ClampToBounds(RectInt bounds);
    public bool Contains(Vector2Int position);
    public bool Overlaps(RectInt other);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool Equals(RectInt other);
    public PositionEnumerator get_allPositionsWithin();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/IMGUI/GUIStyle.h")]
public class UnityEngine.RectOffset : object {
    [VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IntPtr m_Ptr;
    private object m_SourceStyle;
    [NativePropertyAttribute("left", "False", "1")]
public int left { get; public set; }
    [NativePropertyAttribute("right", "False", "1")]
public int right { get; public set; }
    [NativePropertyAttribute("top", "False", "1")]
public int top { get; public set; }
    [NativePropertyAttribute("bottom", "False", "1")]
public int bottom { get; public set; }
    public int horizontal { get; }
    public int vertical { get; }
    [VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal RectOffset(object sourceStyle, IntPtr source);
    public RectOffset(int left, int right, int top, int bottom);
    protected virtual override void Finalize();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private void Destroy();
    [ThreadAndSerializationSafeAttribute]
private static IntPtr InternalCreate();
    [ThreadAndSerializationSafeAttribute]
private static void InternalDestroy(IntPtr ptr);
    public int get_left();
    public void set_left(int value);
    public int get_right();
    public void set_right(int value);
    public int get_top();
    public void set_top(int value);
    public int get_bottom();
    public void set_bottom(int value);
    public int get_horizontal();
    public int get_vertical();
    public Rect Add(Rect rect);
    public Rect Remove(Rect rect);
    private void Add_Injected(Rect& rect, Rect& ret);
    private void Remove_Injected(Rect& rect, Rect& ret);
}
[NativeClassAttribute("UI::RectTransform")]
[NativeHeaderAttribute("Runtime/Transform/RectTransform.h")]
public class UnityEngine.RectTransform : Transform {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static ReapplyDrivenProperties reapplyDrivenProperties;
    public Rect rect { get; }
    public Vector2 anchorMin { get; public set; }
    public Vector2 anchorMax { get; public set; }
    public Vector2 anchoredPosition { get; public set; }
    public Vector2 sizeDelta { get; public set; }
    public Vector2 pivot { get; public set; }
    public Vector3 anchoredPosition3D { get; public set; }
    public Vector2 offsetMin { get; public set; }
    public Vector2 offsetMax { get; public set; }
    public Object drivenByObject { get; internal set; }
    internal DrivenTransformProperties drivenProperties { get; internal set; }
    [CompilerGeneratedAttribute]
public static void add_reapplyDrivenProperties(ReapplyDrivenProperties value);
    [CompilerGeneratedAttribute]
public static void remove_reapplyDrivenProperties(ReapplyDrivenProperties value);
    public Rect get_rect();
    public Vector2 get_anchorMin();
    public void set_anchorMin(Vector2 value);
    public Vector2 get_anchorMax();
    public void set_anchorMax(Vector2 value);
    public Vector2 get_anchoredPosition();
    public void set_anchoredPosition(Vector2 value);
    public Vector2 get_sizeDelta();
    public void set_sizeDelta(Vector2 value);
    public Vector2 get_pivot();
    public void set_pivot(Vector2 value);
    public Vector3 get_anchoredPosition3D();
    public void set_anchoredPosition3D(Vector3 value);
    public Vector2 get_offsetMin();
    public void set_offsetMin(Vector2 value);
    public Vector2 get_offsetMax();
    public void set_offsetMax(Vector2 value);
    public Object get_drivenByObject();
    internal void set_drivenByObject(Object value);
    internal DrivenTransformProperties get_drivenProperties();
    internal void set_drivenProperties(DrivenTransformProperties value);
    [NativeMethodAttribute("UpdateIfTransformDispatchIsDirty")]
public void ForceUpdateRectTransforms();
    public void GetLocalCorners(Vector3[] fourCornersArray);
    public void GetWorldCorners(Vector3[] fourCornersArray);
    public void SetInsetAndSizeFromParentEdge(Edge edge, float inset, float size);
    public void SetSizeWithCurrentAnchors(Axis axis, float size);
    [RequiredByNativeCodeAttribute]
internal static void SendReapplyDrivenProperties(RectTransform driven);
    internal Rect GetRectInParentSpace();
    private Vector2 GetParentSize();
    private void get_rect_Injected(Rect& ret);
    private void get_anchorMin_Injected(Vector2& ret);
    private void set_anchorMin_Injected(Vector2& value);
    private void get_anchorMax_Injected(Vector2& ret);
    private void set_anchorMax_Injected(Vector2& value);
    private void get_anchoredPosition_Injected(Vector2& ret);
    private void set_anchoredPosition_Injected(Vector2& value);
    private void get_sizeDelta_Injected(Vector2& ret);
    private void set_sizeDelta_Injected(Vector2& value);
    private void get_pivot_Injected(Vector2& ret);
    private void set_pivot_Injected(Vector2& value);
}
[NativeHeaderAttribute("Runtime/Camera/ReflectionProbes.h")]
public class UnityEngine.ReflectionProbe : Behaviour {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<ReflectionProbe, ReflectionProbeEvent> reflectionProbeChanged;
    private static Dictionary`2<int, Action`1<Texture>> registeredDefaultReflectionSetActions;
    private static List`1<Action`1<Texture>> registeredDefaultReflectionTextureActions;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("type property has been deprecated. Starting with Unity 5.4, the only supported reflection probe type is Cube.", "True")]
[NativeNameAttribute("ProbeType")]
public ReflectionProbeType type { get; public set; }
    [NativeNameAttribute("BoxSize")]
public Vector3 size { get; public set; }
    [NativeNameAttribute("BoxOffset")]
public Vector3 center { get; public set; }
    [NativeNameAttribute("Near")]
public float nearClipPlane { get; public set; }
    [NativeNameAttribute("Far")]
public float farClipPlane { get; public set; }
    [NativeNameAttribute("IntensityMultiplier")]
public float intensity { get; public set; }
    [NativeNameAttribute("GlobalAABB")]
public Bounds bounds { get; }
    [NativeNameAttribute("HDR")]
public bool hdr { get; public set; }
    [NativeNameAttribute("RenderDynamicObjects")]
public bool renderDynamicObjects { get; public set; }
    public float shadowDistance { get; public set; }
    public int resolution { get; public set; }
    public int cullingMask { get; public set; }
    public ReflectionProbeClearFlags clearFlags { get; public set; }
    public Color backgroundColor { get; public set; }
    public float blendDistance { get; public set; }
    public bool boxProjection { get; public set; }
    public ReflectionProbeMode mode { get; public set; }
    public int importance { get; public set; }
    public ReflectionProbeRefreshMode refreshMode { get; public set; }
    public ReflectionProbeTimeSlicingMode timeSlicingMode { get; public set; }
    public Texture bakedTexture { get; public set; }
    public Texture customBakedTexture { get; public set; }
    public RenderTexture realtimeTexture { get; public set; }
    public Texture texture { get; }
    public Vector4 textureHDRDecodeValues { get; }
    [StaticAccessorAttribute("GetReflectionProbes()")]
public static int minBakedCubemapResolution { get; }
    [StaticAccessorAttribute("GetReflectionProbes()")]
public static int maxBakedCubemapResolution { get; }
    [StaticAccessorAttribute("GetReflectionProbes()")]
public static Vector4 defaultTextureHDRDecodeValues { get; }
    [StaticAccessorAttribute("GetReflectionProbes()")]
public static Texture defaultTexture { get; }
    private static ReflectionProbe();
    public ReflectionProbeType get_type();
    public void set_type(ReflectionProbeType value);
    public Vector3 get_size();
    public void set_size(Vector3 value);
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public float get_nearClipPlane();
    public void set_nearClipPlane(float value);
    public float get_farClipPlane();
    public void set_farClipPlane(float value);
    public float get_intensity();
    public void set_intensity(float value);
    public Bounds get_bounds();
    public bool get_hdr();
    public void set_hdr(bool value);
    public bool get_renderDynamicObjects();
    public void set_renderDynamicObjects(bool value);
    public float get_shadowDistance();
    public void set_shadowDistance(float value);
    public int get_resolution();
    public void set_resolution(int value);
    public int get_cullingMask();
    public void set_cullingMask(int value);
    public ReflectionProbeClearFlags get_clearFlags();
    public void set_clearFlags(ReflectionProbeClearFlags value);
    public Color get_backgroundColor();
    public void set_backgroundColor(Color value);
    public float get_blendDistance();
    public void set_blendDistance(float value);
    public bool get_boxProjection();
    public void set_boxProjection(bool value);
    public ReflectionProbeMode get_mode();
    public void set_mode(ReflectionProbeMode value);
    public int get_importance();
    public void set_importance(int value);
    public ReflectionProbeRefreshMode get_refreshMode();
    public void set_refreshMode(ReflectionProbeRefreshMode value);
    public ReflectionProbeTimeSlicingMode get_timeSlicingMode();
    public void set_timeSlicingMode(ReflectionProbeTimeSlicingMode value);
    public Texture get_bakedTexture();
    public void set_bakedTexture(Texture value);
    public Texture get_customBakedTexture();
    public void set_customBakedTexture(Texture value);
    public RenderTexture get_realtimeTexture();
    public void set_realtimeTexture(RenderTexture value);
    public Texture get_texture();
    [NativeNameAttribute("CalculateHDRDecodeValues")]
public Vector4 get_textureHDRDecodeValues();
    public void Reset();
    public int RenderProbe();
    public int RenderProbe(RenderTexture targetTexture);
    public bool IsFinishedRendering(int renderId);
    private int ScheduleRender(ReflectionProbeTimeSlicingMode timeSlicingMode, RenderTexture targetTexture);
    [NativeHeaderAttribute("Runtime/Camera/CubemapGPUUtility.h")]
[FreeFunctionAttribute("CubemapGPUBlend")]
public static bool BlendCubemap(Texture src, Texture dst, float blend, RenderTexture target);
    [NativeMethodAttribute("UpdateSampleData")]
[StaticAccessorAttribute("GetReflectionProbes()")]
public static void UpdateCachedState();
    public static int get_minBakedCubemapResolution();
    public static int get_maxBakedCubemapResolution();
    public static Vector4 get_defaultTextureHDRDecodeValues();
    public static Texture get_defaultTexture();
    [CompilerGeneratedAttribute]
public static void add_reflectionProbeChanged(Action`2<ReflectionProbe, ReflectionProbeEvent> value);
    [CompilerGeneratedAttribute]
public static void remove_reflectionProbeChanged(Action`2<ReflectionProbe, ReflectionProbeEvent> value);
    [RequiredByNativeCodeAttribute]
private static void CallReflectionProbeEvent(ReflectionProbe probe, ReflectionProbeEvent probeEvent);
    public static void add_defaultReflectionSet(Action`1<Cubemap> value);
    public static void remove_defaultReflectionSet(Action`1<Cubemap> value);
    public static void add_defaultReflectionTexture(Action`1<Texture> value);
    public static void remove_defaultReflectionTexture(Action`1<Texture> value);
    [RequiredByNativeCodeAttribute]
private static void CallSetDefaultReflection(Texture defaultReflectionCubemap);
    private void get_size_Injected(Vector3& ret);
    private void set_size_Injected(Vector3& value);
    private void get_center_Injected(Vector3& ret);
    private void set_center_Injected(Vector3& value);
    private void get_bounds_Injected(Bounds& ret);
    private void get_backgroundColor_Injected(Color& ret);
    private void set_backgroundColor_Injected(Color& value);
    private void get_textureHDRDecodeValues_Injected(Vector4& ret);
    private static void get_defaultTextureHDRDecodeValues_Injected(Vector4& ret);
}
[NativeTypeAttribute("Runtime/Graphics/RefreshRate.h")]
public class UnityEngine.RefreshRate : ValueType {
    [RequiredMemberAttribute]
public UInt32 numerator;
    [RequiredMemberAttribute]
public UInt32 denominator;
    public double value { get; }
    public double get_value();
    public sealed virtual bool Equals(RefreshRate other);
    public sealed virtual int CompareTo(RefreshRate other);
    public virtual string ToString();
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public class UnityEngine.RenderBuffer : ValueType {
    internal int m_RenderTextureInstanceID;
    internal IntPtr m_BufferPtr;
    internal RenderBufferLoadAction loadAction { get; internal set; }
    internal RenderBufferStoreAction storeAction { get; internal set; }
    [FreeFunctionAttribute]
internal void SetLoadAction(RenderBufferLoadAction action);
    [FreeFunctionAttribute]
internal void SetStoreAction(RenderBufferStoreAction action);
    [FreeFunctionAttribute]
internal RenderBufferLoadAction GetLoadAction();
    [FreeFunctionAttribute]
internal RenderBufferStoreAction GetStoreAction();
    [FreeFunctionAttribute]
public IntPtr GetNativeRenderBufferPtr();
    internal RenderBufferLoadAction get_loadAction();
    internal void set_loadAction(RenderBufferLoadAction value);
    internal RenderBufferStoreAction get_storeAction();
    internal void set_storeAction(RenderBufferStoreAction value);
    private static void SetLoadAction_Injected(RenderBuffer& _unity_self, RenderBufferLoadAction action);
    private static void SetStoreAction_Injected(RenderBuffer& _unity_self, RenderBufferStoreAction action);
    private static RenderBufferLoadAction GetLoadAction_Injected(RenderBuffer& _unity_self);
    private static RenderBufferStoreAction GetStoreAction_Injected(RenderBuffer& _unity_self);
    private static IntPtr GetNativeRenderBufferPtr_Injected(RenderBuffer& _unity_self);
}
[RequireComponent("UnityEngine.Transform")]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/Renderer.h")]
public class UnityEngine.Renderer : Component {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use shadowCastingMode instead.", "False")]
public bool castShadows { get; public set; }
    [ObsoleteAttribute("Use motionVectorGenerationMode instead.", "False")]
public bool motionVectors { get; public set; }
    [ObsoleteAttribute("Use lightProbeUsage instead.", "False")]
public bool useLightProbes { get; public set; }
    public Bounds bounds { get; public set; }
    public Bounds localBounds { get; public set; }
    public bool enabled { get; public set; }
    public bool isVisible { get; }
    public ShadowCastingMode shadowCastingMode { get; public set; }
    public bool receiveShadows { get; public set; }
    public bool forceRenderingOff { get; public set; }
    public bool staticShadowCaster { get; public set; }
    public MotionVectorGenerationMode motionVectorGenerationMode { get; public set; }
    public LightProbeUsage lightProbeUsage { get; public set; }
    public ReflectionProbeUsage reflectionProbeUsage { get; public set; }
    public UInt32 renderingLayerMask { get; public set; }
    public int rendererPriority { get; public set; }
    public RayTracingMode rayTracingMode { get; public set; }
    public string sortingLayerName { get; public set; }
    public int sortingLayerID { get; public set; }
    public int sortingOrder { get; public set; }
    internal UInt32 sortingKey { get; }
    internal int sortingGroupID { get; internal set; }
    internal int sortingGroupOrder { get; internal set; }
    internal UInt32 sortingGroupKey { get; }
    [NativePropertyAttribute("IsDynamicOccludee")]
public bool allowOcclusionWhenDynamic { get; public set; }
    [NativePropertyAttribute("StaticBatchRoot")]
internal Transform staticBatchRootTransform { get; internal set; }
    internal int staticBatchIndex { get; }
    public bool isPartOfStaticBatch { get; }
    public Matrix4x4 worldToLocalMatrix { get; }
    public Matrix4x4 localToWorldMatrix { get; }
    public GameObject lightProbeProxyVolumeOverride { get; public set; }
    public Transform probeAnchor { get; public set; }
    public int lightmapIndex { get; public set; }
    public int realtimeLightmapIndex { get; public set; }
    public Vector4 lightmapScaleOffset { get; public set; }
    public Vector4 realtimeLightmapScaleOffset { get; public set; }
    public Material[] materials { get; public set; }
    public Material material { get; public set; }
    public Material sharedMaterial { get; public set; }
    public Material[] sharedMaterials { get; public set; }
    public bool get_castShadows();
    public void set_castShadows(bool value);
    public bool get_motionVectors();
    public void set_motionVectors(bool value);
    public bool get_useLightProbes();
    public void set_useLightProbes(bool value);
    [FreeFunctionAttribute]
public Bounds get_bounds();
    [NativeNameAttribute("SetWorldAABB")]
public void set_bounds(Bounds value);
    [FreeFunctionAttribute]
public Bounds get_localBounds();
    [NativeNameAttribute("SetLocalAABB")]
public void set_localBounds(Bounds value);
    [NativeNameAttribute("ResetWorldAABB")]
public void ResetBounds();
    [NativeNameAttribute("ResetLocalAABB")]
public void ResetLocalBounds();
    [FreeFunctionAttribute]
private void SetStaticLightmapST(Vector4 st);
    [FreeFunctionAttribute]
private Material GetMaterial();
    [FreeFunctionAttribute]
private Material GetSharedMaterial();
    [FreeFunctionAttribute]
private void SetMaterial(Material m);
    [FreeFunctionAttribute]
private Material[] GetMaterialArray();
    [FreeFunctionAttribute]
private void CopyMaterialArray(Material[] m);
    [FreeFunctionAttribute]
private void CopySharedMaterialArray(Material[] m);
    [FreeFunctionAttribute]
private void SetMaterialArray(Material[] m, int length);
    private void SetMaterialArray(Material[] m);
    [FreeFunctionAttribute]
internal void Internal_SetPropertyBlock(MaterialPropertyBlock properties);
    [FreeFunctionAttribute]
internal void Internal_GetPropertyBlock(MaterialPropertyBlock dest);
    [FreeFunctionAttribute]
internal void Internal_SetPropertyBlockMaterialIndex(MaterialPropertyBlock properties, int materialIndex);
    [FreeFunctionAttribute]
internal void Internal_GetPropertyBlockMaterialIndex(MaterialPropertyBlock dest, int materialIndex);
    [FreeFunctionAttribute]
public bool HasPropertyBlock();
    public void SetPropertyBlock(MaterialPropertyBlock properties);
    public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex);
    public void GetPropertyBlock(MaterialPropertyBlock properties);
    public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex);
    [FreeFunctionAttribute]
private void GetClosestReflectionProbesInternal(object result);
    public bool get_enabled();
    public void set_enabled(bool value);
    [NativeNameAttribute("IsVisibleInScene")]
public bool get_isVisible();
    public ShadowCastingMode get_shadowCastingMode();
    public void set_shadowCastingMode(ShadowCastingMode value);
    public bool get_receiveShadows();
    public void set_receiveShadows(bool value);
    public bool get_forceRenderingOff();
    public void set_forceRenderingOff(bool value);
    [NativeNameAttribute("GetIsStaticShadowCaster")]
private bool GetIsStaticShadowCaster();
    [NativeNameAttribute("SetIsStaticShadowCaster")]
private void SetIsStaticShadowCaster(bool value);
    public bool get_staticShadowCaster();
    public void set_staticShadowCaster(bool value);
    public MotionVectorGenerationMode get_motionVectorGenerationMode();
    public void set_motionVectorGenerationMode(MotionVectorGenerationMode value);
    public LightProbeUsage get_lightProbeUsage();
    public void set_lightProbeUsage(LightProbeUsage value);
    public ReflectionProbeUsage get_reflectionProbeUsage();
    public void set_reflectionProbeUsage(ReflectionProbeUsage value);
    public UInt32 get_renderingLayerMask();
    public void set_renderingLayerMask(UInt32 value);
    public int get_rendererPriority();
    public void set_rendererPriority(int value);
    public RayTracingMode get_rayTracingMode();
    public void set_rayTracingMode(RayTracingMode value);
    public string get_sortingLayerName();
    public void set_sortingLayerName(string value);
    public int get_sortingLayerID();
    public void set_sortingLayerID(int value);
    public int get_sortingOrder();
    public void set_sortingOrder(int value);
    internal UInt32 get_sortingKey();
    internal int get_sortingGroupID();
    internal void set_sortingGroupID(int value);
    internal int get_sortingGroupOrder();
    internal void set_sortingGroupOrder(int value);
    internal UInt32 get_sortingGroupKey();
    public bool get_allowOcclusionWhenDynamic();
    public void set_allowOcclusionWhenDynamic(bool value);
    internal Transform get_staticBatchRootTransform();
    internal void set_staticBatchRootTransform(Transform value);
    internal int get_staticBatchIndex();
    internal void SetStaticBatchInfo(int firstSubMesh, int subMeshCount);
    [NativeNameAttribute("IsPartOfStaticBatch")]
public bool get_isPartOfStaticBatch();
    public Matrix4x4 get_worldToLocalMatrix();
    public Matrix4x4 get_localToWorldMatrix();
    public GameObject get_lightProbeProxyVolumeOverride();
    public void set_lightProbeProxyVolumeOverride(GameObject value);
    public Transform get_probeAnchor();
    public void set_probeAnchor(Transform value);
    [NativeNameAttribute("GetLightmapIndexInt")]
private int GetLightmapIndex(LightmapType lt);
    [NativeNameAttribute("SetLightmapIndexInt")]
private void SetLightmapIndex(int index, LightmapType lt);
    [NativeNameAttribute("GetLightmapST")]
private Vector4 GetLightmapST(LightmapType lt);
    [NativeNameAttribute("SetLightmapST")]
private void SetLightmapST(Vector4 st, LightmapType lt);
    public int get_lightmapIndex();
    public void set_lightmapIndex(int value);
    public int get_realtimeLightmapIndex();
    public void set_realtimeLightmapIndex(int value);
    public Vector4 get_lightmapScaleOffset();
    public void set_lightmapScaleOffset(Vector4 value);
    public Vector4 get_realtimeLightmapScaleOffset();
    public void set_realtimeLightmapScaleOffset(Vector4 value);
    private int GetMaterialCount();
    [NativeNameAttribute("GetMaterialArray")]
private Material[] GetSharedMaterialArray();
    public Material[] get_materials();
    public void set_materials(Material[] value);
    public Material get_material();
    public void set_material(Material value);
    public Material get_sharedMaterial();
    public void set_sharedMaterial(Material value);
    public Material[] get_sharedMaterials();
    public void set_sharedMaterials(Material[] value);
    public void GetMaterials(List`1<Material> m);
    public void SetSharedMaterials(List`1<Material> materials);
    public void SetMaterials(List`1<Material> materials);
    public void GetSharedMaterials(List`1<Material> m);
    public void GetClosestReflectionProbes(List`1<ReflectionProbeBlendInfo> result);
    private void get_bounds_Injected(Bounds& ret);
    private void set_bounds_Injected(Bounds& value);
    private void get_localBounds_Injected(Bounds& ret);
    private void set_localBounds_Injected(Bounds& value);
    private void SetStaticLightmapST_Injected(Vector4& st);
    private void get_worldToLocalMatrix_Injected(Matrix4x4& ret);
    private void get_localToWorldMatrix_Injected(Matrix4x4& ret);
    private void GetLightmapST_Injected(LightmapType lt, Vector4& ret);
    private void SetLightmapST_Injected(Vector4& st, LightmapType lt);
}
[ExtensionAttribute]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public static class UnityEngine.RendererExtensions : object {
    [ExtensionAttribute]
public static void UpdateGIMaterials(Renderer renderer);
    [FreeFunctionAttribute("RendererScripting::UpdateGIMaterialsForRenderer")]
internal static void UpdateGIMaterialsForRenderer(Renderer renderer);
}
public enum UnityEngine.Rendering.AmbientMode : Enum {
    public int value__;
    public static AmbientMode Skybox;
    public static AmbientMode Trilight;
    public static AmbientMode Flat;
    public static AmbientMode Custom;
}
[StaticAccessorAttribute("AsyncGPUReadbackManager::GetInstance()", "0")]
public static class UnityEngine.Rendering.AsyncGPUReadback : object {
    internal static void ValidateFormat(Texture src, GraphicsFormat dstformat);
    public static void WaitAllRequests();
    public static AsyncGPUReadbackRequest Request(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public static AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_1(ComputeBuffer buffer, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_2(ComputeBuffer src, int size, int offset, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_GraphicsBuffer_1(GraphicsBuffer buffer, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_GraphicsBuffer_2(GraphicsBuffer src, int size, int offset, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_Texture_1(Texture src, int mipIndex, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_Texture_2(Texture src, int mipIndex, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_Texture_3(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, AsyncRequestNativeArrayData* data);
    [NativeMethodAttribute("Request")]
private static AsyncGPUReadbackRequest Request_Internal_Texture_4(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data);
    private static void Request_Internal_ComputeBuffer_1_Injected(ComputeBuffer buffer, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_ComputeBuffer_2_Injected(ComputeBuffer src, int size, int offset, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_GraphicsBuffer_1_Injected(GraphicsBuffer buffer, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_GraphicsBuffer_2_Injected(GraphicsBuffer src, int size, int offset, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_Texture_1_Injected(Texture src, int mipIndex, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_Texture_2_Injected(Texture src, int mipIndex, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_Texture_3_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
    private static void Request_Internal_Texture_4_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret);
}
[NativeHeaderAttribute("Runtime/Graphics/Texture.h")]
[NativeHeaderAttribute("Runtime/Graphics/AsyncGPUReadbackManaged.h")]
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.AsyncGPUReadbackRequest : ValueType {
    internal IntPtr m_Ptr;
    internal int m_Version;
    public bool done { get; }
    public bool hasError { get; }
    public int layerCount { get; }
    public int layerDataSize { get; }
    public int width { get; }
    public int height { get; }
    public int depth { get; }
    public bool forcePlayerLoopUpdate { get; public set; }
    public void Update();
    public void WaitForCompletion();
    public NativeArray`1<T> GetData(int layer);
    public bool get_done();
    public bool get_hasError();
    public int get_layerCount();
    public int get_layerDataSize();
    public int get_width();
    public int get_height();
    public int get_depth();
    public bool get_forcePlayerLoopUpdate();
    public void set_forcePlayerLoopUpdate(bool value);
    private bool IsDone();
    private bool HasError();
    private int GetLayerCount();
    private int GetLayerDataSize();
    private int GetWidth();
    private int GetHeight();
    private int GetDepth();
    private bool GetForcePlayerLoopUpdate();
    private void SetForcePlayerLoopUpdate(bool b);
    internal void SetScriptingCallback(Action`1<AsyncGPUReadbackRequest> callback);
    private IntPtr GetDataRaw(int layer);
    private static void Update_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static void WaitForCompletion_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static bool IsDone_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static bool HasError_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static int GetLayerCount_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static int GetLayerDataSize_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static int GetWidth_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static int GetHeight_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static int GetDepth_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static bool GetForcePlayerLoopUpdate_Injected(AsyncGPUReadbackRequest& _unity_self);
    private static void SetForcePlayerLoopUpdate_Injected(AsyncGPUReadbackRequest& _unity_self, bool b);
    private static void SetScriptingCallback_Injected(AsyncGPUReadbackRequest& _unity_self, Action`1<AsyncGPUReadbackRequest> callback);
    private static IntPtr GetDataRaw_Injected(AsyncGPUReadbackRequest& _unity_self, int layer);
}
[NativeHeaderAttribute("Runtime/Graphics/AsyncGPUReadbackManaged.h")]
[UsedByNativeCodeAttribute]
internal class UnityEngine.Rendering.AsyncRequestNativeArrayData : ValueType {
    public Void* nativeArrayBuffer;
    public long lengthInBytes;
    public static AsyncRequestNativeArrayData CreateAndCheckAccess(NativeArray`1<T> array);
    public static AsyncRequestNativeArrayData CreateAndCheckAccess(NativeSlice`1<T> array);
}
public class UnityEngine.Rendering.AttachmentDescriptor : ValueType {
    private RenderBufferLoadAction m_LoadAction;
    private RenderBufferStoreAction m_StoreAction;
    private GraphicsFormat m_Format;
    private RenderTargetIdentifier m_LoadStoreTarget;
    private RenderTargetIdentifier m_ResolveTarget;
    private Color m_ClearColor;
    private float m_ClearDepth;
    private UInt32 m_ClearStencil;
    public RenderBufferLoadAction loadAction { get; public set; }
    public RenderBufferStoreAction storeAction { get; public set; }
    public GraphicsFormat graphicsFormat { get; public set; }
    public RenderTextureFormat format { get; public set; }
    public RenderTargetIdentifier loadStoreTarget { get; public set; }
    public RenderTargetIdentifier resolveTarget { get; public set; }
    public Color clearColor { get; public set; }
    public float clearDepth { get; public set; }
    public UInt32 clearStencil { get; public set; }
    public AttachmentDescriptor(GraphicsFormat format);
    public AttachmentDescriptor(RenderTextureFormat format);
    public AttachmentDescriptor(RenderTextureFormat format, RenderTargetIdentifier target, bool loadExistingContents, bool storeResults, bool resolve);
    public RenderBufferLoadAction get_loadAction();
    public void set_loadAction(RenderBufferLoadAction value);
    public RenderBufferStoreAction get_storeAction();
    public void set_storeAction(RenderBufferStoreAction value);
    public GraphicsFormat get_graphicsFormat();
    public void set_graphicsFormat(GraphicsFormat value);
    public RenderTextureFormat get_format();
    public void set_format(RenderTextureFormat value);
    public RenderTargetIdentifier get_loadStoreTarget();
    public void set_loadStoreTarget(RenderTargetIdentifier value);
    public RenderTargetIdentifier get_resolveTarget();
    public void set_resolveTarget(RenderTargetIdentifier value);
    public Color get_clearColor();
    public void set_clearColor(Color value);
    public float get_clearDepth();
    public void set_clearDepth(float value);
    public UInt32 get_clearStencil();
    public void set_clearStencil(UInt32 value);
    public void ConfigureTarget(RenderTargetIdentifier target, bool loadExistingContents, bool storeResults);
    public void ConfigureResolveTarget(RenderTargetIdentifier target);
    public void ConfigureClear(Color clearColor, float clearDepth, UInt32 clearStencil);
    public sealed virtual bool Equals(AttachmentDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AttachmentDescriptor left, AttachmentDescriptor right);
    public static bool op_Inequality(AttachmentDescriptor left, AttachmentDescriptor right);
}
public enum UnityEngine.Rendering.BatchBufferTarget : Enum {
    public int value__;
    public static BatchBufferTarget Unknown;
    public static BatchBufferTarget UnsupportedByUnderlyingGraphicsApi;
    public static BatchBufferTarget RawBuffer;
    public static BatchBufferTarget ConstantBuffer;
}
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.BatchCullingContext : ValueType {
    public NativeArray`1<Plane> cullingPlanes;
    public NativeArray`1<CullingSplit> cullingSplits;
    public LODParameters lodParameters;
    public Matrix4x4 localToWorldMatrix;
    public BatchCullingViewType viewType;
    public BatchCullingProjectionType projectionType;
    public BatchCullingFlags cullingFlags;
    public BatchPackedCullingViewID viewID;
    public UInt32 cullingLayerMask;
    public ulong sceneCullingMask;
    [ObsoleteAttribute("BatchCullingContext.isOrthographic is deprecated. Use BatchCullingContext.projectionType instead.")]
public byte isOrthographic;
    public int receiverPlaneOffset;
    public int receiverPlaneCount;
    internal BatchCullingContext(NativeArray`1<Plane> inCullingPlanes, NativeArray`1<CullingSplit> inCullingSplits, LODParameters inLodParameters, Matrix4x4 inLocalToWorldMatrix, BatchCullingViewType inViewType, BatchCullingProjectionType inProjectionType, BatchCullingFlags inBatchCullingFlags, ulong inViewID, UInt32 inCullingLayerMask, ulong inSceneCullingMask, int inReceiverPlaneOffset, int inReceiverPlaneCount);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.BatchCullingFlags : Enum {
    public int value__;
    public static BatchCullingFlags None;
    public static BatchCullingFlags CullLightmappedShadowCasters;
}
public class UnityEngine.Rendering.BatchCullingOutput : ValueType {
    public NativeArray`1<BatchCullingOutputDrawCommands> drawCommands;
}
public class UnityEngine.Rendering.BatchCullingOutputDrawCommands : ValueType {
    public BatchDrawCommand* drawCommands;
    public Int32* visibleInstances;
    public BatchDrawRange* drawRanges;
    public Single* instanceSortingPositions;
    public Int32* drawCommandPickingInstanceIDs;
    public int drawCommandCount;
    public int visibleInstanceCount;
    public int drawRangeCount;
    public int instanceSortingPositionFloatCount;
}
public enum UnityEngine.Rendering.BatchCullingProjectionType : Enum {
    public int value__;
    public static BatchCullingProjectionType Unknown;
    public static BatchCullingProjectionType Perspective;
    public static BatchCullingProjectionType Orthographic;
}
public enum UnityEngine.Rendering.BatchCullingViewType : Enum {
    public int value__;
    public static BatchCullingViewType Unknown;
    public static BatchCullingViewType Camera;
    public static BatchCullingViewType Light;
    public static BatchCullingViewType Picking;
    public static BatchCullingViewType SelectionOutline;
}
public class UnityEngine.Rendering.BatchDrawCommand : ValueType {
    public UInt32 visibleOffset;
    public UInt32 visibleCount;
    public BatchID batchID;
    public BatchMaterialID materialID;
    public BatchMeshID meshID;
    public ushort submeshIndex;
    public ushort splitVisibilityMask;
    public BatchDrawCommandFlags flags;
    public int sortingPosition;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.BatchDrawCommandFlags : Enum {
    public int value__;
    public static BatchDrawCommandFlags None;
    public static BatchDrawCommandFlags FlipWinding;
    public static BatchDrawCommandFlags HasMotion;
    public static BatchDrawCommandFlags IsLightMapped;
    public static BatchDrawCommandFlags HasSortingPosition;
    public static BatchDrawCommandFlags LODCrossFade;
}
public class UnityEngine.Rendering.BatchDrawRange : ValueType {
    public UInt32 drawCommandsBegin;
    public UInt32 drawCommandsCount;
    public BatchFilterSettings filterSettings;
}
public class UnityEngine.Rendering.BatchFilterSettings : ValueType {
    public UInt32 renderingLayerMask;
    public byte layer;
    private byte m_motionMode;
    private byte m_shadowMode;
    private byte m_receiveShadows;
    private byte m_staticShadowCaster;
    private byte m_allDepthSorted;
    public MotionVectorGenerationMode motionMode { get; public set; }
    public ShadowCastingMode shadowCastingMode { get; public set; }
    public bool receiveShadows { get; public set; }
    public bool staticShadowCaster { get; public set; }
    public bool allDepthSorted { get; public set; }
    public MotionVectorGenerationMode get_motionMode();
    public void set_motionMode(MotionVectorGenerationMode value);
    public ShadowCastingMode get_shadowCastingMode();
    public void set_shadowCastingMode(ShadowCastingMode value);
    public bool get_receiveShadows();
    public void set_receiveShadows(bool value);
    public bool get_staticShadowCaster();
    public void set_staticShadowCaster(bool value);
    public bool get_allDepthSorted();
    public void set_allDepthSorted(bool value);
}
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
[RequiredByNativeCodeAttribute]
[NativeClassAttribute("BatchID")]
public class UnityEngine.Rendering.BatchID : ValueType {
    public static BatchID Null;
    public UInt32 value;
    private static BatchID();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BatchID other);
    public int CompareTo(BatchID other);
    public static bool op_Equality(BatchID a, BatchID b);
    public static bool op_Inequality(BatchID a, BatchID b);
}
[NativeClassAttribute("BatchMaterialID")]
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.Rendering.BatchMaterialID : ValueType {
    public static BatchMaterialID Null;
    public UInt32 value;
    private static BatchMaterialID();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BatchMaterialID other);
    public int CompareTo(BatchMaterialID other);
    public static bool op_Equality(BatchMaterialID a, BatchMaterialID b);
    public static bool op_Inequality(BatchMaterialID a, BatchMaterialID b);
}
[RequiredByNativeCodeAttribute]
[NativeClassAttribute("BatchMeshID")]
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
public class UnityEngine.Rendering.BatchMeshID : ValueType {
    public static BatchMeshID Null;
    public UInt32 value;
    private static BatchMeshID();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BatchMeshID other);
    public int CompareTo(BatchMeshID other);
    public static bool op_Equality(BatchMeshID a, BatchMeshID b);
    public static bool op_Inequality(BatchMeshID a, BatchMeshID b);
}
public class UnityEngine.Rendering.BatchPackedCullingViewID : ValueType {
    internal ulong handle;
    public BatchPackedCullingViewID(int instanceID, int sliceIndex);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(BatchPackedCullingViewID other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BatchPackedCullingViewID lhs, BatchPackedCullingViewID rhs);
    public static bool op_Inequality(BatchPackedCullingViewID lhs, BatchPackedCullingViewID rhs);
    public int GetInstanceID();
    public int GetSliceIndex();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
internal class UnityEngine.Rendering.BatchRendererCullingOutput : ValueType {
    public JobHandle cullingJobsFence;
    public Matrix4x4 localToWorldMatrix;
    public Plane* cullingPlanes;
    public int cullingPlaneCount;
    public int receiverPlaneOffset;
    public int receiverPlaneCount;
    public CullingSplit* cullingSplits;
    public int cullingSplitCount;
    public BatchCullingViewType viewType;
    public BatchCullingProjectionType projectionType;
    public BatchCullingFlags cullingFlags;
    public ulong viewID;
    public UInt32 cullingLayerMask;
    public ulong sceneCullingMask;
    public BatchCullingOutputDrawCommands* drawCommands;
}
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Math/Matrix4x4.h")]
public class UnityEngine.Rendering.BatchRendererGroup : object {
    private IntPtr m_GroupHandle;
    private OnPerformCulling m_PerformCulling;
    public static BatchBufferTarget BufferTarget { get; }
    public BatchRendererGroup(OnPerformCulling cullingCallback, IntPtr userContext);
    public sealed virtual void Dispose();
    public ThreadedBatchContext GetThreadedBatchContext();
    private BatchID AddDrawCommandBatch(IntPtr values, int count, GraphicsBufferHandle buffer, UInt32 bufferOffset, UInt32 windowSize);
    public BatchID AddBatch(NativeArray`1<MetadataValue> batchMetadata, GraphicsBufferHandle buffer);
    public BatchID AddBatch(NativeArray`1<MetadataValue> batchMetadata, GraphicsBufferHandle buffer, UInt32 bufferOffset, UInt32 windowSize);
    private void RemoveDrawCommandBatch(BatchID batchID);
    public void RemoveBatch(BatchID batchID);
    private void SetDrawCommandBatchBuffer(BatchID batchID, GraphicsBufferHandle buffer);
    public void SetBatchBuffer(BatchID batchID, GraphicsBufferHandle buffer);
    public BatchMaterialID RegisterMaterial(Material material);
    public BatchMaterialID RegisterMaterial(int materialInstanceID);
    private BatchMaterialID RegisterMaterial_InstanceID(int materialInstanceID);
    public void UnregisterMaterial(BatchMaterialID material);
    public Material GetRegisteredMaterial(BatchMaterialID material);
    public BatchMeshID RegisterMesh(Mesh mesh);
    public BatchMeshID RegisterMesh(int meshInstanceID);
    private BatchMeshID RegisterMesh_InstanceID(int meshInstanceID);
    public void UnregisterMesh(BatchMeshID mesh);
    public Mesh GetRegisteredMesh(BatchMeshID mesh);
    public void SetGlobalBounds(Bounds bounds);
    public void SetPickingMaterial(Material material);
    public void SetErrorMaterial(Material material);
    public void SetLoadingMaterial(Material material);
    public void SetEnabledViewTypes(BatchCullingViewType[] viewTypes);
    private static BatchBufferTarget GetBufferTarget();
    public static BatchBufferTarget get_BufferTarget();
    public static int GetConstantBufferMaxWindowSize();
    public static int GetConstantBufferOffsetAlignment();
    private static IntPtr Create(BatchRendererGroup group, Void* userContext);
    private static void Destroy(IntPtr groupHandle);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnPerformCulling(BatchRendererGroup group, BatchRendererCullingOutput& context, LODParameters& lodParameters, IntPtr userContext);
    private void AddDrawCommandBatch_Injected(IntPtr values, int count, GraphicsBufferHandle& buffer, UInt32 bufferOffset, UInt32 windowSize, BatchID& ret);
    private void RemoveDrawCommandBatch_Injected(BatchID& batchID);
    private void SetDrawCommandBatchBuffer_Injected(BatchID& batchID, GraphicsBufferHandle& buffer);
    private void RegisterMaterial_Injected(Material material, BatchMaterialID& ret);
    private void RegisterMaterial_InstanceID_Injected(int materialInstanceID, BatchMaterialID& ret);
    private void UnregisterMaterial_Injected(BatchMaterialID& material);
    private Material GetRegisteredMaterial_Injected(BatchMaterialID& material);
    private void RegisterMesh_Injected(Mesh mesh, BatchMeshID& ret);
    private void RegisterMesh_InstanceID_Injected(int meshInstanceID, BatchMeshID& ret);
    private void UnregisterMesh_Injected(BatchMeshID& mesh);
    private Mesh GetRegisteredMesh_Injected(BatchMeshID& mesh);
    private void SetGlobalBounds_Injected(Bounds& bounds);
}
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.Rendering.BlendMode : Enum {
    public int value__;
    public static BlendMode Zero;
    public static BlendMode One;
    public static BlendMode DstColor;
    public static BlendMode SrcColor;
    public static BlendMode OneMinusDstColor;
    public static BlendMode SrcAlpha;
    public static BlendMode OneMinusSrcColor;
    public static BlendMode DstAlpha;
    public static BlendMode OneMinusDstAlpha;
    public static BlendMode SrcAlphaSaturate;
    public static BlendMode OneMinusSrcAlpha;
}
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.Rendering.BlendOp : Enum {
    public int value__;
    public static BlendOp Add;
    public static BlendOp Subtract;
    public static BlendOp ReverseSubtract;
    public static BlendOp Min;
    public static BlendOp Max;
    public static BlendOp LogicalClear;
    public static BlendOp LogicalSet;
    public static BlendOp LogicalCopy;
    public static BlendOp LogicalCopyInverted;
    public static BlendOp LogicalNoop;
    public static BlendOp LogicalInvert;
    public static BlendOp LogicalAnd;
    public static BlendOp LogicalNand;
    public static BlendOp LogicalOr;
    public static BlendOp LogicalNor;
    public static BlendOp LogicalXor;
    public static BlendOp LogicalEquivalence;
    public static BlendOp LogicalAndReverse;
    public static BlendOp LogicalAndInverted;
    public static BlendOp LogicalOrReverse;
    public static BlendOp LogicalOrInverted;
    public static BlendOp Multiply;
    public static BlendOp Screen;
    public static BlendOp Overlay;
    public static BlendOp Darken;
    public static BlendOp Lighten;
    public static BlendOp ColorDodge;
    public static BlendOp ColorBurn;
    public static BlendOp HardLight;
    public static BlendOp SoftLight;
    public static BlendOp Difference;
    public static BlendOp Exclusion;
    public static BlendOp HSLHue;
    public static BlendOp HSLSaturation;
    public static BlendOp HSLColor;
    public static BlendOp HSLLuminosity;
}
public enum UnityEngine.Rendering.BlendShapeBufferLayout : Enum {
    public int value__;
    public static BlendShapeBufferLayout PerShape;
    public static BlendShapeBufferLayout PerVertex;
}
public class UnityEngine.Rendering.BlendState : ValueType {
    private RenderTargetBlendState m_BlendState0;
    private RenderTargetBlendState m_BlendState1;
    private RenderTargetBlendState m_BlendState2;
    private RenderTargetBlendState m_BlendState3;
    private RenderTargetBlendState m_BlendState4;
    private RenderTargetBlendState m_BlendState5;
    private RenderTargetBlendState m_BlendState6;
    private RenderTargetBlendState m_BlendState7;
    private byte m_SeparateMRTBlendStates;
    private byte m_AlphaToMask;
    private short m_Padding;
    public static BlendState defaultValue { get; }
    public bool separateMRTBlendStates { get; public set; }
    public bool alphaToMask { get; public set; }
    public RenderTargetBlendState blendState0 { get; public set; }
    public RenderTargetBlendState blendState1 { get; public set; }
    public RenderTargetBlendState blendState2 { get; public set; }
    public RenderTargetBlendState blendState3 { get; public set; }
    public RenderTargetBlendState blendState4 { get; public set; }
    public RenderTargetBlendState blendState5 { get; public set; }
    public RenderTargetBlendState blendState6 { get; public set; }
    public RenderTargetBlendState blendState7 { get; public set; }
    public BlendState(bool separateMRTBlend, bool alphaToMask);
    public static BlendState get_defaultValue();
    public bool get_separateMRTBlendStates();
    public void set_separateMRTBlendStates(bool value);
    public bool get_alphaToMask();
    public void set_alphaToMask(bool value);
    public RenderTargetBlendState get_blendState0();
    public void set_blendState0(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState1();
    public void set_blendState1(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState2();
    public void set_blendState2(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState3();
    public void set_blendState3(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState4();
    public void set_blendState4(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState5();
    public void set_blendState5(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState6();
    public void set_blendState6(RenderTargetBlendState value);
    public RenderTargetBlendState get_blendState7();
    public void set_blendState7(RenderTargetBlendState value);
    public sealed virtual bool Equals(BlendState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BlendState left, BlendState right);
    public static bool op_Inequality(BlendState left, BlendState right);
}
public enum UnityEngine.Rendering.BuiltinRenderTextureType : Enum {
    public int value__;
    public static BuiltinRenderTextureType PropertyName;
    public static BuiltinRenderTextureType BufferPtr;
    public static BuiltinRenderTextureType RenderTexture;
    public static BuiltinRenderTextureType BindableTexture;
    public static BuiltinRenderTextureType None;
    public static BuiltinRenderTextureType CurrentActive;
    public static BuiltinRenderTextureType CameraTarget;
    public static BuiltinRenderTextureType Depth;
    public static BuiltinRenderTextureType DepthNormals;
    public static BuiltinRenderTextureType ResolvedDepth;
    [ObsoleteAttribute("Deferred Lighting has been removed, so PrepassNormalsSpec built-in render texture type is never used now.", "False")]
public static BuiltinRenderTextureType PrepassNormalsSpec;
    [ObsoleteAttribute("Deferred Lighting has been removed, so PrepassLight built-in render texture type is never used now.", "False")]
public static BuiltinRenderTextureType PrepassLight;
    [ObsoleteAttribute("Deferred Lighting has been removed, so PrepassLightSpec built-in render texture type is never used now.", "False")]
public static BuiltinRenderTextureType PrepassLightSpec;
    public static BuiltinRenderTextureType GBuffer0;
    public static BuiltinRenderTextureType GBuffer1;
    public static BuiltinRenderTextureType GBuffer2;
    public static BuiltinRenderTextureType GBuffer3;
    public static BuiltinRenderTextureType Reflections;
    public static BuiltinRenderTextureType MotionVectors;
    public static BuiltinRenderTextureType GBuffer4;
    public static BuiltinRenderTextureType GBuffer5;
    public static BuiltinRenderTextureType GBuffer6;
    public static BuiltinRenderTextureType GBuffer7;
}
public enum UnityEngine.Rendering.BuiltinShaderDefine : Enum {
    public int value__;
    public static BuiltinShaderDefine UNITY_NO_DXT5nm;
    public static BuiltinShaderDefine UNITY_NO_RGBM;
    [ObsoleteAttribute("Shaders unconditionally support HDR decoding.")]
public static BuiltinShaderDefine UNITY_USE_NATIVE_HDR;
    public static BuiltinShaderDefine UNITY_ENABLE_REFLECTION_BUFFERS;
    public static BuiltinShaderDefine UNITY_FRAMEBUFFER_FETCH_AVAILABLE;
    public static BuiltinShaderDefine UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS;
    public static BuiltinShaderDefine UNITY_METAL_SHADOWS_USE_POINT_FILTERING;
    public static BuiltinShaderDefine UNITY_NO_CUBEMAP_ARRAY;
    public static BuiltinShaderDefine UNITY_NO_SCREENSPACE_SHADOWS;
    public static BuiltinShaderDefine UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS;
    public static BuiltinShaderDefine UNITY_PBS_USE_BRDF1;
    public static BuiltinShaderDefine UNITY_PBS_USE_BRDF2;
    public static BuiltinShaderDefine UNITY_PBS_USE_BRDF3;
    public static BuiltinShaderDefine UNITY_NO_FULL_STANDARD_SHADER;
    public static BuiltinShaderDefine UNITY_SPECCUBE_BOX_PROJECTION;
    public static BuiltinShaderDefine UNITY_SPECCUBE_BLENDING;
    public static BuiltinShaderDefine UNITY_ENABLE_DETAIL_NORMALMAP;
    public static BuiltinShaderDefine SHADER_API_MOBILE;
    public static BuiltinShaderDefine SHADER_API_DESKTOP;
    public static BuiltinShaderDefine UNITY_HARDWARE_TIER1;
    public static BuiltinShaderDefine UNITY_HARDWARE_TIER2;
    public static BuiltinShaderDefine UNITY_HARDWARE_TIER3;
    public static BuiltinShaderDefine UNITY_COLORSPACE_GAMMA;
    public static BuiltinShaderDefine UNITY_LIGHT_PROBE_PROXY_VOLUME;
    public static BuiltinShaderDefine UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS;
    public static BuiltinShaderDefine UNITY_LIGHTMAP_DLDR_ENCODING;
    public static BuiltinShaderDefine UNITY_LIGHTMAP_RGBM_ENCODING;
    public static BuiltinShaderDefine UNITY_LIGHTMAP_FULL_HDR;
    public static BuiltinShaderDefine UNITY_VIRTUAL_TEXTURING;
    public static BuiltinShaderDefine UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION;
    public static BuiltinShaderDefine UNITY_ASTC_NORMALMAP_ENCODING;
    public static BuiltinShaderDefine SHADER_API_GLES30;
    public static BuiltinShaderDefine UNITY_UNIFIED_SHADER_PRECISION_MODEL;
    public static BuiltinShaderDefine UNITY_PLATFORM_SUPPORTS_WAVE_32;
    public static BuiltinShaderDefine UNITY_PLATFORM_SUPPORTS_WAVE_64;
    public static BuiltinShaderDefine UNITY_NEEDS_RENDERPASS_FBFETCH_FALLBACK;
}
public enum UnityEngine.Rendering.BuiltinShaderMode : Enum {
    public int value__;
    public static BuiltinShaderMode Disabled;
    public static BuiltinShaderMode UseBuiltin;
    public static BuiltinShaderMode UseCustom;
}
public enum UnityEngine.Rendering.BuiltinShaderType : Enum {
    public int value__;
    public static BuiltinShaderType DeferredShading;
    public static BuiltinShaderType DeferredReflections;
    [ObsoleteAttribute("LegacyDeferredLighting has been removed.", "False")]
public static BuiltinShaderType LegacyDeferredLighting;
    public static BuiltinShaderType ScreenSpaceShadows;
    public static BuiltinShaderType DepthNormals;
    public static BuiltinShaderType MotionVectors;
    public static BuiltinShaderType LightHalo;
    public static BuiltinShaderType LensFlare;
}
public enum UnityEngine.Rendering.CameraEvent : Enum {
    public int value__;
    public static CameraEvent BeforeDepthTexture;
    public static CameraEvent AfterDepthTexture;
    public static CameraEvent BeforeDepthNormalsTexture;
    public static CameraEvent AfterDepthNormalsTexture;
    public static CameraEvent BeforeGBuffer;
    public static CameraEvent AfterGBuffer;
    public static CameraEvent BeforeLighting;
    public static CameraEvent AfterLighting;
    public static CameraEvent BeforeFinalPass;
    public static CameraEvent AfterFinalPass;
    public static CameraEvent BeforeForwardOpaque;
    public static CameraEvent AfterForwardOpaque;
    public static CameraEvent BeforeImageEffectsOpaque;
    public static CameraEvent AfterImageEffectsOpaque;
    public static CameraEvent BeforeSkybox;
    public static CameraEvent AfterSkybox;
    public static CameraEvent BeforeForwardAlpha;
    public static CameraEvent AfterForwardAlpha;
    public static CameraEvent BeforeImageEffects;
    public static CameraEvent AfterImageEffects;
    public static CameraEvent AfterEverything;
    public static CameraEvent BeforeReflections;
    public static CameraEvent AfterReflections;
    public static CameraEvent BeforeHaloAndLensFlares;
    public static CameraEvent AfterHaloAndLensFlares;
}
internal static class UnityEngine.Rendering.CameraEventUtils : object {
    private static CameraEvent k_MinimumValue;
    private static CameraEvent k_MaximumValue;
    public static bool IsValid(CameraEvent value);
}
public enum UnityEngine.Rendering.CameraHDRMode : Enum {
    public int value__;
    public static CameraHDRMode FP16;
    public static CameraHDRMode R11G11B10;
}
public enum UnityEngine.Rendering.CameraLateLatchMatrixType : Enum {
    public int value__;
    public static CameraLateLatchMatrixType View;
    public static CameraLateLatchMatrixType InverseView;
    public static CameraLateLatchMatrixType ViewProjection;
    public static CameraLateLatchMatrixType InverseViewProjection;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.CameraProperties : ValueType {
    private static int k_NumLayers;
    private Rect screenRect;
    private Vector3 viewDir;
    private float projectionNear;
    private float projectionFar;
    private float cameraNear;
    private float cameraFar;
    private float cameraAspect;
    private Matrix4x4 cameraToWorld;
    private Matrix4x4 actualWorldToClip;
    private Matrix4x4 cameraClipToWorld;
    private Matrix4x4 cameraWorldToClip;
    private Matrix4x4 implicitProjection;
    private Matrix4x4 stereoWorldToClipLeft;
    private Matrix4x4 stereoWorldToClipRight;
    private Matrix4x4 worldToCamera;
    private Vector3 up;
    private Vector3 right;
    private Vector3 transformDirection;
    private Vector3 cameraEuler;
    private Vector3 velocity;
    private float farPlaneWorldSpaceLength;
    private UInt32 rendererCount;
    private static int k_PlaneCount;
    [FixedBufferAttribute("System.Byte", "96")]
internal <m_ShadowCullPlanes>e__FixedBuffer m_ShadowCullPlanes;
    [FixedBufferAttribute("System.Byte", "96")]
internal <m_CameraCullPlanes>e__FixedBuffer m_CameraCullPlanes;
    private float baseFarDistance;
    private Vector3 shadowCullCenter;
    [FixedBufferAttribute("System.Single", "32")]
internal <layerCullDistances>e__FixedBuffer layerCullDistances;
    private int layerCullSpherical;
    private CoreCameraValues coreCameraValues;
    private UInt32 cameraType;
    private int projectionIsOblique;
    private int isImplicitProjectionMatrix;
    public Plane GetShadowCullingPlane(int index);
    public void SetShadowCullingPlane(int index, Plane plane);
    public Plane GetCameraCullingPlane(int index);
    public void SetCameraCullingPlane(int index, Plane plane);
    public sealed virtual bool Equals(CameraProperties other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CameraProperties left, CameraProperties right);
    public static bool op_Inequality(CameraProperties left, CameraProperties right);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.ColorWriteMask : Enum {
    public int value__;
    public static ColorWriteMask Alpha;
    public static ColorWriteMask Blue;
    public static ColorWriteMask Green;
    public static ColorWriteMask Red;
    public static ColorWriteMask All;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Shaders/RayTracingShader.h")]
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
[NativeHeaderAttribute("Runtime/Export/Graphics/RenderingCommandBuffer.bindings.h")]
[NativeTypeAttribute("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
public class UnityEngine.Rendering.CommandBuffer : object {
    internal IntPtr m_Ptr;
    public string name { get; public set; }
    public int sizeInBytes { get; }
    public void ConvertTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst);
    public void ConvertTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement);
    [NativeMethodAttribute("AddWaitAllAsyncReadbackRequests")]
public void WaitAllAsyncReadbackRequests();
    public void RequestAsyncReadback(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_1(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_2(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_3(Texture src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_4(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_5(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_6(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_7(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_8(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddRequestAsyncReadback")]
private void Internal_RequestAsyncReadback_9(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData);
    [NativeMethodAttribute("AddSetInvertCulling")]
public void SetInvertCulling(bool invertCulling);
    private void ConvertTexture_Internal(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetSinglePassStereo")]
private void Internal_SetSinglePassStereo(SinglePassStereoMode mode);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::InitBuffer")]
private static IntPtr InitBuffer();
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::CreateGPUFence_Internal")]
private IntPtr CreateGPUFence_Internal(GraphicsFenceType fenceType, SynchronisationStageFlags stage);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::WaitOnGPUFence_Internal")]
private void WaitOnGPUFence_Internal(IntPtr fencePtr, SynchronisationStageFlags stage);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ReleaseBuffer")]
private void ReleaseBuffer();
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeFloatParam")]
public void SetComputeFloatParam(ComputeShader computeShader, int nameID, float val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeIntParam")]
public void SetComputeIntParam(ComputeShader computeShader, int nameID, int val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeVectorParam")]
public void SetComputeVectorParam(ComputeShader computeShader, int nameID, Vector4 val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeVectorArrayParam")]
public void SetComputeVectorArrayParam(ComputeShader computeShader, int nameID, Vector4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeMatrixParam")]
public void SetComputeMatrixParam(ComputeShader computeShader, int nameID, Matrix4x4 val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeMatrixArrayParam")]
public void SetComputeMatrixArrayParam(ComputeShader computeShader, int nameID, Matrix4x4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetComputeFloats")]
private void Internal_SetComputeFloats(ComputeShader computeShader, int nameID, Single[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetComputeInts")]
private void Internal_SetComputeInts(ComputeShader computeShader, int nameID, Int32[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetComputeTextureParam")]
private void Internal_SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier& rt, int mipLevel, RenderTextureSubElement element);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeBufferParam")]
private void Internal_SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeBufferParam")]
private void Internal_SetComputeGraphicsBufferHandleParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBufferHandle bufferHandle);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeBufferParam")]
private void Internal_SetComputeGraphicsBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeConstantBufferParam")]
private void Internal_SetComputeConstantComputeBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeConstantBufferParam")]
private void Internal_SetComputeConstantGraphicsBufferParam(ComputeShader computeShader, int nameID, GraphicsBuffer buffer, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeParamsFromMaterial")]
private void Internal_SetComputeParamsFromMaterial(ComputeShader computeShader, int kernelIndex, Material material);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DispatchCompute")]
private void Internal_DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DispatchComputeIndirect")]
private void Internal_DispatchComputeIndirect(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DispatchComputeIndirect")]
private void Internal_DispatchComputeIndirectGraphicsBuffer(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, UInt32 argsOffset);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingBufferParam")]
private void Internal_SetRayTracingBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingConstantBufferParam")]
private void Internal_SetRayTracingConstantComputeBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingConstantBufferParam")]
private void Internal_SetRayTracingConstantGraphicsBufferParam(RayTracingShader rayTracingShader, int nameID, GraphicsBuffer buffer, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingTextureParam")]
private void Internal_SetRayTracingTextureParam(RayTracingShader rayTracingShader, int nameID, RenderTargetIdentifier& rt);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingFloatParam")]
private void Internal_SetRayTracingFloatParam(RayTracingShader rayTracingShader, int nameID, float val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingIntParam")]
private void Internal_SetRayTracingIntParam(RayTracingShader rayTracingShader, int nameID, int val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingVectorParam")]
private void Internal_SetRayTracingVectorParam(RayTracingShader rayTracingShader, int nameID, Vector4 val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingVectorArrayParam")]
private void Internal_SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, int nameID, Vector4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingMatrixParam")]
private void Internal_SetRayTracingMatrixParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4 val);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingMatrixArrayParam")]
private void Internal_SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingFloats")]
private void Internal_SetRayTracingFloats(RayTracingShader rayTracingShader, int nameID, Single[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingInts")]
private void Internal_SetRayTracingInts(RayTracingShader rayTracingShader, int nameID, Int32[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_BuildRayTracingAccelerationStructure")]
private void Internal_BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure, Vector3 relativeOrigin);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_SetRayTracingAccelerationStructure")]
private void Internal_SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, int nameID, RayTracingAccelerationStructure accelerationStructure);
    [NativeMethodAttribute("AddSetRayTracingShaderPass")]
public void SetRayTracingShaderPass(RayTracingShader rayTracingShader, string passName);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DispatchRays")]
private void Internal_DispatchRays(RayTracingShader rayTracingShader, string rayGenShaderName, UInt32 width, UInt32 height, UInt32 depth, Camera camera);
    [NativeMethodAttribute("AddGenerateMips")]
private void Internal_GenerateMips(RenderTargetIdentifier rt);
    [NativeMethodAttribute("AddResolveAntiAliasedSurface")]
private void Internal_ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target);
    [NativeMethodAttribute("AddCopyCounterValue")]
private void CopyCounterValueCC(ComputeBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes);
    [NativeMethodAttribute("AddCopyCounterValue")]
private void CopyCounterValueGC(GraphicsBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes);
    [NativeMethodAttribute("AddCopyCounterValue")]
private void CopyCounterValueCG(ComputeBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes);
    [NativeMethodAttribute("AddCopyCounterValue")]
private void CopyCounterValueGG(GraphicsBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes);
    public string get_name();
    public void set_name(string value);
    [NativeMethodAttribute("GetBufferSize")]
public int get_sizeInBytes();
    [NativeMethodAttribute("ClearCommands")]
public void Clear();
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawMesh")]
private void Internal_DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties);
    [NativeMethodAttribute("AddDrawRenderer")]
private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass);
    [NativeMethodAttribute("AddDrawRendererList")]
private void Internal_DrawRendererList(RendererList rendererList);
    private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex);
    private void Internal_DrawRenderer(Renderer renderer, Material material);
    [NativeMethodAttribute("AddDrawProcedural")]
private void Internal_DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties);
    [NativeMethodAttribute("AddDrawProceduralIndexed")]
private void Internal_DrawProceduralIndexed(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawProceduralIndirect")]
private void Internal_DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawProceduralIndexedIndirect")]
private void Internal_DrawProceduralIndexedIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawProceduralIndirect")]
private void Internal_DrawProceduralIndirectGraphicsBuffer(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawProceduralIndexedIndirect")]
private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawMeshInstanced")]
private void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawMeshInstancedProcedural")]
private void Internal_DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawMeshInstancedIndirect")]
private void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawMeshInstancedIndirect")]
private void Internal_DrawMeshInstancedIndirectGraphicsBuffer(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Internal_DrawOcclusionMesh")]
private void Internal_DrawOcclusionMesh(RectInt normalizedCamViewport);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetRandomWriteTarget_Texture")]
private void SetRandomWriteTarget_Texture(int index, RenderTargetIdentifier& rt);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetRandomWriteTarget_Buffer")]
private void SetRandomWriteTarget_Buffer(int index, ComputeBuffer uav, bool preserveCounterValue);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetRandomWriteTarget_Buffer")]
private void SetRandomWriteTarget_GraphicsBuffer(int index, GraphicsBuffer uav, bool preserveCounterValue);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ClearRandomWriteTargets")]
public void ClearRandomWriteTargets();
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetViewport")]
public void SetViewport(Rect pixelRect);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EnableScissorRect")]
public void EnableScissorRect(Rect scissor);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::DisableScissorRect")]
public void DisableScissorRect();
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::CopyTexture_Internal")]
private void CopyTexture_Internal(RenderTargetIdentifier& src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier& dst, int dstElement, int dstMip, int dstX, int dstY, int mode);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Blit_Texture")]
private void Blit_Texture(Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::Blit_Identifier")]
private void Blit_Identifier(RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::GetTemporaryRT")]
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer);
    public void GetTemporaryRT(int nameID, int width, int height);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::GetTemporaryRTWithDescriptor")]
private void GetTemporaryRTWithDescriptor(int nameID, RenderTextureDescriptor desc, FilterMode filter);
    public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter);
    public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::GetTemporaryRTArray")]
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, bool useDynamicScale);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ReleaseTemporaryRT")]
public void ReleaseTemporaryRT(int nameID);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ClearRenderTarget")]
public void ClearRenderTarget(RTClearFlags clearFlags, Color backgroundColor, float depth, UInt32 stencil);
    public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor);
    public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor, float depth);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalFloat")]
public void SetGlobalFloat(int nameID, float value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalInt")]
public void SetGlobalInt(int nameID, int value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalInteger")]
public void SetGlobalInteger(int nameID, int value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalVector")]
public void SetGlobalVector(int nameID, Vector4 value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalColor")]
public void SetGlobalColor(int nameID, Color value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalMatrix")]
public void SetGlobalMatrix(int nameID, Matrix4x4 value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EnableShaderKeyword")]
public void EnableShaderKeyword(string keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EnableShaderKeyword")]
private void EnableGlobalKeyword(GlobalKeyword keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EnableMaterialKeyword")]
private void EnableMaterialKeyword(Material material, LocalKeyword keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EnableComputeKeyword")]
private void EnableComputeKeyword(ComputeShader computeShader, LocalKeyword keyword);
    public void EnableKeyword(GlobalKeyword& keyword);
    public void EnableKeyword(Material material, LocalKeyword& keyword);
    public void EnableKeyword(ComputeShader computeShader, LocalKeyword& keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::DisableShaderKeyword")]
public void DisableShaderKeyword(string keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::DisableShaderKeyword")]
private void DisableGlobalKeyword(GlobalKeyword keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::DisableMaterialKeyword")]
private void DisableMaterialKeyword(Material material, LocalKeyword keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::DisableComputeKeyword")]
private void DisableComputeKeyword(ComputeShader computeShader, LocalKeyword keyword);
    public void DisableKeyword(GlobalKeyword& keyword);
    public void DisableKeyword(Material material, LocalKeyword& keyword);
    public void DisableKeyword(ComputeShader computeShader, LocalKeyword& keyword);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetShaderKeyword")]
private void SetGlobalKeyword(GlobalKeyword keyword, bool value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetMaterialKeyword")]
private void SetMaterialKeyword(Material material, LocalKeyword keyword, bool value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetComputeKeyword")]
private void SetComputeKeyword(ComputeShader computeShader, LocalKeyword keyword, bool value);
    public void SetKeyword(GlobalKeyword& keyword, bool value);
    public void SetKeyword(Material material, LocalKeyword& keyword, bool value);
    public void SetKeyword(ComputeShader computeShader, LocalKeyword& keyword, bool value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetViewMatrix")]
public void SetViewMatrix(Matrix4x4 view);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetProjectionMatrix")]
public void SetProjectionMatrix(Matrix4x4 proj);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetViewProjectionMatrices")]
public void SetViewProjectionMatrices(Matrix4x4 view, Matrix4x4 proj);
    [NativeMethodAttribute("AddSetGlobalDepthBias")]
public void SetGlobalDepthBias(float bias, float slopeBias);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetExecutionFlags")]
public void SetExecutionFlags(CommandBufferExecutionFlags flags);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ValidateAgainstExecutionFlags")]
private bool ValidateAgainstExecutionFlags(CommandBufferExecutionFlags requiredFlags, CommandBufferExecutionFlags invalidFlags);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalFloatArrayListImpl")]
private void SetGlobalFloatArrayListImpl(int nameID, object values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalVectorArrayListImpl")]
private void SetGlobalVectorArrayListImpl(int nameID, object values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalMatrixArrayListImpl")]
private void SetGlobalMatrixArrayListImpl(int nameID, object values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalFloatArray")]
public void SetGlobalFloatArray(int nameID, Single[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalVectorArray")]
public void SetGlobalVectorArray(int nameID, Vector4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalMatrixArray")]
public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetLateLatchProjectionMatrices")]
public void SetLateLatchProjectionMatrices(Matrix4x4[] projectionMat);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::MarkLateLatchMatrixShaderPropertyID")]
public void MarkLateLatchMatrixShaderPropertyID(CameraLateLatchMatrixType matrixPropertyType, int shaderPropertyID);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::UnmarkLateLatchMatrix")]
public void UnmarkLateLatchMatrix(CameraLateLatchMatrixType matrixPropertyType);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalTexture_Impl")]
private void SetGlobalTexture_Impl(int nameID, RenderTargetIdentifier& rt, RenderTextureSubElement element);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalBuffer")]
private void SetGlobalBufferInternal(int nameID, ComputeBuffer value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalBuffer")]
private void SetGlobalGraphicsBufferInternal(int nameID, GraphicsBuffer value);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetShadowSamplingMode_Impl")]
private void SetShadowSamplingMode_Impl(RenderTargetIdentifier& shadowmap, ShadowSamplingMode mode);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IssuePluginEventInternal")]
private void IssuePluginEventInternal(IntPtr callback, int eventID);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::BeginSample")]
public void BeginSample(string name);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EndSample")]
public void EndSample(string name);
    public void BeginSample(CustomSampler sampler);
    public void EndSample(CustomSampler sampler);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::BeginSample_CustomSampler")]
private void BeginSample_CustomSampler(CustomSampler sampler);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EndSample_CustomSampler")]
private void EndSample_CustomSampler(CustomSampler sampler);
    [ConditionalAttribute("ENABLE_PROFILER")]
public void BeginSample(ProfilerMarker marker);
    [ConditionalAttribute("ENABLE_PROFILER")]
public void EndSample(ProfilerMarker marker);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::BeginSample_ProfilerMarker")]
private void BeginSample_ProfilerMarker(IntPtr markerHandle);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::EndSample_ProfilerMarker")]
private void EndSample_ProfilerMarker(IntPtr markerHandle);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IssuePluginEventAndDataInternal")]
private void IssuePluginEventAndDataInternal(IntPtr callback, int eventID, IntPtr data);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IssuePluginEventAndDataWithFlagsInternal")]
private void IssuePluginEventAndDataInternalWithFlags(IntPtr callback, int eventID, CustomMarkerCallbackFlags flags, IntPtr data);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IssuePluginCustomBlitInternal")]
private void IssuePluginCustomBlitInternal(IntPtr callback, UInt32 command, RenderTargetIdentifier& source, RenderTargetIdentifier& dest, UInt32 commandParam, UInt32 commandFlags);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IssuePluginCustomTextureUpdateInternal")]
private void IssuePluginCustomTextureUpdateInternal(IntPtr callback, Texture targetTexture, UInt32 userData, bool useNewUnityRenderingExtTextureUpdateParamsV2);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalConstantBuffer")]
private void SetGlobalConstantBufferInternal(ComputeBuffer buffer, int nameID, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetGlobalConstantBuffer")]
private void SetGlobalConstantGraphicsBufferInternal(GraphicsBuffer buffer, int nameID, int offset, int size);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::IncrementUpdateCount")]
public void IncrementUpdateCount(RenderTargetIdentifier dest);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetInstanceMultiplier")]
public void SetInstanceMultiplier(UInt32 multiplier);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetFoveatedRenderingMode")]
public void SetFoveatedRenderingMode(FoveatedRenderingMode foveatedRenderingMode);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::SetWireframe")]
public void SetWireframe(bool enable);
    [FreeFunctionAttribute("RenderingCommandBuffer_Bindings::ConfigureFoveatedRendering")]
public void ConfigureFoveatedRendering(IntPtr platformData);
    public void SetRenderTarget(RenderTargetIdentifier rt);
    public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction);
    public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel);
    public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace);
    public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth);
    public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel);
    public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace);
    public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth);
    public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(RenderTargetBinding binding, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(RenderTargetBinding binding);
    private void SetRenderTargetSingle_Internal(RenderTargetIdentifier rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    private void SetRenderTargetColorDepth_Internal(RenderTargetIdentifier color, RenderTargetIdentifier depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags);
    private void SetRenderTargetMulti_Internal(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags);
    private void SetRenderTargetColorDepthSubtarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    private void SetRenderTargetMultiSubtarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    [NativeMethodAttribute("ProcessVTFeedback")]
private void Internal_ProcessVTFeedback(RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, Array data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, List`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, NativeArray`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(ComputeBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count);
    public void SetBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue);
    [FreeFunctionAttribute]
private void InternalSetComputeBufferNativeData(ComputeBuffer buffer, IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
private void InternalSetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
private void InternalSetComputeBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, Array data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, List`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, NativeArray`1<T> data);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [SecuritySafeCriticalAttribute]
public void SetBufferData(GraphicsBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count);
    public void SetBufferCounterValue(GraphicsBuffer buffer, UInt32 counterValue);
    [FreeFunctionAttribute]
private void InternalSetGraphicsBufferNativeData(GraphicsBuffer buffer, IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
[SecurityCriticalAttribute]
private void InternalSetGraphicsBufferData(GraphicsBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize);
    [FreeFunctionAttribute]
private void InternalSetGraphicsBufferCounterValue(GraphicsBuffer buffer, UInt32 counterValue);
    [FreeFunctionAttribute]
private void CopyBufferImpl(GraphicsBuffer source, GraphicsBuffer dest);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public void Release();
    public GraphicsFence CreateAsyncGraphicsFence();
    public GraphicsFence CreateAsyncGraphicsFence(SynchronisationStage stage);
    public GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, SynchronisationStageFlags stage);
    public void WaitOnAsyncGraphicsFence(GraphicsFence fence);
    public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStage stage);
    public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStageFlags stage);
    public void SetComputeFloatParam(ComputeShader computeShader, string name, float val);
    public void SetComputeIntParam(ComputeShader computeShader, string name, int val);
    public void SetComputeVectorParam(ComputeShader computeShader, string name, Vector4 val);
    public void SetComputeVectorArrayParam(ComputeShader computeShader, string name, Vector4[] values);
    public void SetComputeMatrixParam(ComputeShader computeShader, string name, Matrix4x4 val);
    public void SetComputeMatrixArrayParam(ComputeShader computeShader, string name, Matrix4x4[] values);
    public void SetComputeFloatParams(ComputeShader computeShader, string name, Single[] values);
    public void SetComputeFloatParams(ComputeShader computeShader, int nameID, Single[] values);
    public void SetComputeIntParams(ComputeShader computeShader, string name, Int32[] values);
    public void SetComputeIntParams(ComputeShader computeShader, int nameID, Int32[] values);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, ComputeBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBufferHandle bufferHandle);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, GraphicsBufferHandle bufferHandle);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, GraphicsBuffer buffer);
    public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size);
    public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, ComputeBuffer buffer, int offset, int size);
    public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, GraphicsBuffer buffer, int offset, int size);
    public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, GraphicsBuffer buffer, int offset, int size);
    public void SetComputeParamsFromMaterial(ComputeShader computeShader, int kernelIndex, Material material);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, UInt32 argsOffset);
    public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure);
    public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure, Vector3 relativeOrigin);
    public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, string name, RayTracingAccelerationStructure rayTracingAccelerationStructure);
    public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, int nameID, RayTracingAccelerationStructure rayTracingAccelerationStructure);
    public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer);
    public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer);
    public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer, int offset, int size);
    public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer, int offset, int size);
    public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, GraphicsBuffer buffer, int offset, int size);
    public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, GraphicsBuffer buffer, int offset, int size);
    public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, string name, RenderTargetIdentifier rt);
    public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, int nameID, RenderTargetIdentifier rt);
    public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, string name, float val);
    public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, int nameID, float val);
    public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, string name, Single[] values);
    public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, int nameID, Single[] values);
    public void SetRayTracingIntParam(RayTracingShader rayTracingShader, string name, int val);
    public void SetRayTracingIntParam(RayTracingShader rayTracingShader, int nameID, int val);
    public void SetRayTracingIntParams(RayTracingShader rayTracingShader, string name, Int32[] values);
    public void SetRayTracingIntParams(RayTracingShader rayTracingShader, int nameID, Int32[] values);
    public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, string name, Vector4 val);
    public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, int nameID, Vector4 val);
    public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, string name, Vector4[] values);
    public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, int nameID, Vector4[] values);
    public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, string name, Matrix4x4 val);
    public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4 val);
    public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, string name, Matrix4x4[] values);
    public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4[] values);
    public void DispatchRays(RayTracingShader rayTracingShader, string rayGenName, UInt32 width, UInt32 height, UInt32 depth, Camera camera);
    public void GenerateMips(RenderTargetIdentifier rt);
    public void GenerateMips(RenderTexture rt);
    public void ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target);
    public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass);
    [ExcludeFromDocsAttribute]
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex);
    [ExcludeFromDocsAttribute]
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material);
    public void DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass);
    [ExcludeFromDocsAttribute]
public void DrawRenderer(Renderer renderer, Material material, int submeshIndex);
    [ExcludeFromDocsAttribute]
public void DrawRenderer(Renderer renderer, Material material);
    public void DrawRendererList(RendererList rendererList);
    public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties);
    [ExcludeFromDocsAttribute]
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount);
    [ExcludeFromDocsAttribute]
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices);
    public void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs);
    public void DrawOcclusionMesh(RectInt normalizedCamViewport);
    public void SetRandomWriteTarget(int index, RenderTargetIdentifier rt);
    public void SetRandomWriteTarget(int index, ComputeBuffer buffer, bool preserveCounterValue);
    public void SetRandomWriteTarget(int index, ComputeBuffer buffer);
    public void SetRandomWriteTarget(int index, GraphicsBuffer buffer, bool preserveCounterValue);
    public void SetRandomWriteTarget(int index, GraphicsBuffer buffer);
    public void CopyCounterValue(ComputeBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes);
    public void CopyCounterValue(GraphicsBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes);
    public void CopyCounterValue(ComputeBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes);
    public void CopyCounterValue(GraphicsBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes);
    public void CopyTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst);
    public void CopyTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement);
    public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, RenderTargetIdentifier dst, int dstElement, int dstMip);
    public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier dst, int dstElement, int dstMip, int dstX, int dstY);
    public void Blit(Texture source, RenderTargetIdentifier dest);
    public void Blit(Texture source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
    public void Blit(Texture source, RenderTargetIdentifier dest, Material mat);
    public void Blit(Texture source, RenderTargetIdentifier dest, Material mat, int pass);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, int sourceDepthSlice, int destDepthSlice);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass, int destDepthSlice);
    public void SetGlobalFloat(string name, float value);
    public void SetGlobalInt(string name, int value);
    public void SetGlobalInteger(string name, int value);
    public void SetGlobalVector(string name, Vector4 value);
    public void SetGlobalColor(string name, Color value);
    public void SetGlobalMatrix(string name, Matrix4x4 value);
    public void SetGlobalFloatArray(string propertyName, List`1<float> values);
    public void SetGlobalFloatArray(int nameID, List`1<float> values);
    public void SetGlobalFloatArray(string propertyName, Single[] values);
    public void SetGlobalVectorArray(string propertyName, List`1<Vector4> values);
    public void SetGlobalVectorArray(int nameID, List`1<Vector4> values);
    public void SetGlobalVectorArray(string propertyName, Vector4[] values);
    public void SetGlobalMatrixArray(string propertyName, List`1<Matrix4x4> values);
    public void SetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values);
    public void SetGlobalMatrixArray(string propertyName, Matrix4x4[] values);
    public void SetGlobalTexture(string name, RenderTargetIdentifier value);
    public void SetGlobalTexture(int nameID, RenderTargetIdentifier value);
    public void SetGlobalTexture(string name, RenderTargetIdentifier value, RenderTextureSubElement element);
    public void SetGlobalTexture(int nameID, RenderTargetIdentifier value, RenderTextureSubElement element);
    public void SetGlobalBuffer(string name, ComputeBuffer value);
    public void SetGlobalBuffer(int nameID, ComputeBuffer value);
    public void SetGlobalBuffer(string name, GraphicsBuffer value);
    public void SetGlobalBuffer(int nameID, GraphicsBuffer value);
    public void SetGlobalConstantBuffer(ComputeBuffer buffer, int nameID, int offset, int size);
    public void SetGlobalConstantBuffer(ComputeBuffer buffer, string name, int offset, int size);
    public void SetGlobalConstantBuffer(GraphicsBuffer buffer, int nameID, int offset, int size);
    public void SetGlobalConstantBuffer(GraphicsBuffer buffer, string name, int offset, int size);
    public void SetShadowSamplingMode(RenderTargetIdentifier shadowmap, ShadowSamplingMode mode);
    public void SetSinglePassStereo(SinglePassStereoMode mode);
    public void IssuePluginEvent(IntPtr callback, int eventID);
    public void IssuePluginEventAndData(IntPtr callback, int eventID, IntPtr data);
    public void IssuePluginEventAndDataWithFlags(IntPtr callback, int eventID, CustomMarkerCallbackFlags flags, IntPtr data);
    public void IssuePluginCustomBlit(IntPtr callback, UInt32 command, RenderTargetIdentifier source, RenderTargetIdentifier dest, UInt32 commandParam, UInt32 commandFlags);
    [ObsoleteAttribute("Use IssuePluginCustomTextureUpdateV2 to register TextureUpdate callbacks instead. Callbacks will be passed event IDs kUnityRenderingExtEventUpdateTextureBeginV2 or kUnityRenderingExtEventUpdateTextureEndV2, and data parameter of type UnityRenderingExtTextureUpdateParamsV2.", "False")]
public void IssuePluginCustomTextureUpdate(IntPtr callback, Texture targetTexture, UInt32 userData);
    [ObsoleteAttribute("Use IssuePluginCustomTextureUpdateV2 to register TextureUpdate callbacks instead. Callbacks will be passed event IDs kUnityRenderingExtEventUpdateTextureBeginV2 or kUnityRenderingExtEventUpdateTextureEndV2, and data parameter of type UnityRenderingExtTextureUpdateParamsV2.", "False")]
public void IssuePluginCustomTextureUpdateV1(IntPtr callback, Texture targetTexture, UInt32 userData);
    public void IssuePluginCustomTextureUpdateV2(IntPtr callback, Texture targetTexture, UInt32 userData);
    public void ProcessVTFeedback(RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip);
    public void CopyBuffer(GraphicsBuffer source, GraphicsBuffer dest);
    [ObsoleteAttribute("CommandBuffer.CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence(*)", "False")]
public GPUFence CreateGPUFence(SynchronisationStage stage);
    [ObsoleteAttribute("CommandBuffer.CreateGPUFence has been deprecated. Use CreateGraphicsFence instead (UnityUpgradable) -> CreateAsyncGraphicsFence()", "False")]
public GPUFence CreateGPUFence();
    [ObsoleteAttribute("CommandBuffer.WaitOnGPUFence has been deprecated. Use WaitOnGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", "False")]
public void WaitOnGPUFence(GPUFence fence, SynchronisationStage stage);
    [ObsoleteAttribute("CommandBuffer.WaitOnGPUFence has been deprecated. Use WaitOnGraphicsFence instead (UnityUpgradable) -> WaitOnAsyncGraphicsFence(*)", "False")]
public void WaitOnGPUFence(GPUFence fence);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, Array data);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData<T>(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, List`1<T> data);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData<T>(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, NativeArray`1<T> data);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData<T>(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferData has been deprecated. Use SetBufferData instead (UnityUpgradable) -> SetBufferData<T>(*)", "False")]
public void SetComputeBufferData(ComputeBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count);
    [ObsoleteAttribute("CommandBuffer.SetComputeBufferCounterValue has been deprecated. Use SetBufferCounterValue instead (UnityUpgradable) -> SetBufferCounterValue(*)", "False")]
public void SetComputeBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue);
    private void ConvertTexture_Internal_Injected(RenderTargetIdentifier& src, int srcElement, RenderTargetIdentifier& dst, int dstElement);
    private void SetComputeVectorParam_Injected(ComputeShader computeShader, int nameID, Vector4& val);
    private void SetComputeMatrixParam_Injected(ComputeShader computeShader, int nameID, Matrix4x4& val);
    private void Internal_SetComputeGraphicsBufferHandleParam_Injected(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBufferHandle& bufferHandle);
    private void Internal_SetRayTracingVectorParam_Injected(RayTracingShader rayTracingShader, int nameID, Vector4& val);
    private void Internal_SetRayTracingMatrixParam_Injected(RayTracingShader rayTracingShader, int nameID, Matrix4x4& val);
    private void Internal_BuildRayTracingAccelerationStructure_Injected(RayTracingAccelerationStructure accelerationStructure, Vector3& relativeOrigin);
    private void Internal_GenerateMips_Injected(RenderTargetIdentifier& rt);
    private void Internal_DrawMesh_Injected(Mesh mesh, Matrix4x4& matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties);
    private void Internal_DrawRendererList_Injected(RendererList& rendererList);
    private void Internal_DrawProcedural_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties);
    private void Internal_DrawProceduralIndexed_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties);
    private void Internal_DrawProceduralIndirect_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    private void Internal_DrawProceduralIndexedIndirect_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    private void Internal_DrawProceduralIndirectGraphicsBuffer_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    private void Internal_DrawOcclusionMesh_Injected(RectInt& normalizedCamViewport);
    private void SetViewport_Injected(Rect& pixelRect);
    private void EnableScissorRect_Injected(Rect& scissor);
    private void Blit_Texture_Injected(Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice);
    private void Blit_Identifier_Injected(RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice);
    private void GetTemporaryRTWithDescriptor_Injected(int nameID, RenderTextureDescriptor& desc, FilterMode filter);
    private void ClearRenderTarget_Injected(RTClearFlags clearFlags, Color& backgroundColor, float depth, UInt32 stencil);
    private void SetGlobalVector_Injected(int nameID, Vector4& value);
    private void SetGlobalColor_Injected(int nameID, Color& value);
    private void SetGlobalMatrix_Injected(int nameID, Matrix4x4& value);
    private void EnableGlobalKeyword_Injected(GlobalKeyword& keyword);
    private void EnableMaterialKeyword_Injected(Material material, LocalKeyword& keyword);
    private void EnableComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword);
    private void DisableGlobalKeyword_Injected(GlobalKeyword& keyword);
    private void DisableMaterialKeyword_Injected(Material material, LocalKeyword& keyword);
    private void DisableComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword);
    private void SetGlobalKeyword_Injected(GlobalKeyword& keyword, bool value);
    private void SetMaterialKeyword_Injected(Material material, LocalKeyword& keyword, bool value);
    private void SetComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword, bool value);
    private void SetViewMatrix_Injected(Matrix4x4& view);
    private void SetProjectionMatrix_Injected(Matrix4x4& proj);
    private void SetViewProjectionMatrices_Injected(Matrix4x4& view, Matrix4x4& proj);
    private void IncrementUpdateCount_Injected(RenderTargetIdentifier& dest);
    private void SetRenderTargetSingle_Internal_Injected(RenderTargetIdentifier& rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    private void SetRenderTargetColorDepth_Internal_Injected(RenderTargetIdentifier& color, RenderTargetIdentifier& depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags);
    private void SetRenderTargetMulti_Internal_Injected(RenderTargetIdentifier[] colors, RenderTargetIdentifier& depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags);
    private void SetRenderTargetColorDepthSubtarget_Injected(RenderTargetIdentifier& color, RenderTargetIdentifier& depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    private void SetRenderTargetMultiSubtarget_Injected(RenderTargetIdentifier[] colors, RenderTargetIdentifier& depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    private void Internal_ProcessVTFeedback_Injected(RenderTargetIdentifier& rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip);
}
public enum UnityEngine.Rendering.CommandBufferExecutionFlags : Enum {
    public int value__;
    public static CommandBufferExecutionFlags None;
    public static CommandBufferExecutionFlags AsyncCompute;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/Graphics/RenderingCommandBufferExtensions.bindings.h")]
[ExtensionAttribute]
public static class UnityEngine.Rendering.CommandBufferExtensions : object {
    [FreeFunctionAttribute("RenderingCommandBufferExtensions_Bindings::Internal_SwitchIntoFastMemory")]
private static void Internal_SwitchIntoFastMemory(CommandBuffer cmd, RenderTargetIdentifier& rt, FastMemoryFlags fastMemoryFlags, float residency, bool copyContents);
    [FreeFunctionAttribute("RenderingCommandBufferExtensions_Bindings::Internal_SwitchOutOfFastMemory")]
private static void Internal_SwitchOutOfFastMemory(CommandBuffer cmd, RenderTargetIdentifier& rt, bool copyContents);
    [ExtensionAttribute]
[NativeConditionalAttribute("UNITY_XBOXONE || UNITY_GAMECORE_XBOXONE")]
public static void SwitchIntoFastMemory(CommandBuffer cmd, RenderTargetIdentifier rid, FastMemoryFlags fastMemoryFlags, float residency, bool copyContents);
    [NativeConditionalAttribute("UNITY_XBOXONE || UNITY_GAMECORE_XBOXONE")]
[ExtensionAttribute]
public static void SwitchOutOfFastMemory(CommandBuffer cmd, RenderTargetIdentifier rid, bool copyContents);
}
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.Rendering.CompareFunction : Enum {
    public int value__;
    public static CompareFunction Disabled;
    public static CompareFunction Never;
    public static CompareFunction Less;
    public static CompareFunction Equal;
    public static CompareFunction LessEqual;
    public static CompareFunction Greater;
    public static CompareFunction NotEqual;
    public static CompareFunction GreaterEqual;
    public static CompareFunction Always;
}
public enum UnityEngine.Rendering.ComputeQueueType : Enum {
    public int value__;
    public static ComputeQueueType Default;
    public static ComputeQueueType Background;
    public static ComputeQueueType Urgent;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.CopyTextureSupport : Enum {
    public int value__;
    public static CopyTextureSupport None;
    public static CopyTextureSupport Basic;
    public static CopyTextureSupport Copy3D;
    public static CopyTextureSupport DifferentTypes;
    public static CopyTextureSupport TextureToRT;
    public static CopyTextureSupport RTToTexture;
}
[UsedByNativeCodeAttribute]
internal class UnityEngine.Rendering.CoreCameraValues : ValueType {
    private int filterMode;
    private UInt32 cullingMask;
    private int instanceID;
    public sealed virtual bool Equals(CoreCameraValues other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CoreCameraValues left, CoreCameraValues right);
    public static bool op_Inequality(CoreCameraValues left, CoreCameraValues right);
}
internal class UnityEngine.Rendering.CullingAllocationInfo : ValueType {
    public VisibleLight* visibleLightsPtr;
    public VisibleLight* visibleOffscreenVertexLightsPtr;
    public VisibleReflectionProbe* visibleReflectionProbesPtr;
    public int visibleLightCount;
    public int visibleOffscreenVertexLightCount;
    public int visibleReflectionProbeCount;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.CullingOptions : Enum {
    public int value__;
    public static CullingOptions None;
    public static CullingOptions ForceEvenIfCameraIsNotActive;
    public static CullingOptions OcclusionCull;
    public static CullingOptions NeedsLighting;
    public static CullingOptions NeedsReflectionProbes;
    public static CullingOptions Stereo;
    public static CullingOptions DisablePerObjectCulling;
    public static CullingOptions ShadowCasters;
}
[NativeHeaderAttribute("Runtime/Scripting/ScriptingCommonStructDefinitions.h")]
[NativeHeaderAttribute("Runtime/Export/RenderPipeline/ScriptableRenderPipeline.bindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/ScriptableRenderLoop/ScriptableCulling.h")]
public class UnityEngine.Rendering.CullingResults : ValueType {
    internal IntPtr ptr;
    private CullingAllocationInfo* m_AllocationInfo;
    public NativeArray`1<VisibleLight> visibleLights { get; }
    public NativeArray`1<VisibleLight> visibleOffscreenVertexLights { get; }
    public NativeArray`1<VisibleReflectionProbe> visibleReflectionProbes { get; }
    public int lightIndexCount { get; }
    public int reflectionProbeIndexCount { get; }
    public int lightAndReflectionProbeIndexCount { get; }
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::GetLightIndexCount")]
private static int GetLightIndexCount(IntPtr cullingResultsPtr);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::GetReflectionProbeIndexCount")]
private static int GetReflectionProbeIndexCount(IntPtr cullingResultsPtr);
    [FreeFunctionAttribute("FillLightAndReflectionProbeIndices")]
private static void FillLightAndReflectionProbeIndices(IntPtr cullingResultsPtr, ComputeBuffer computeBuffer);
    [FreeFunctionAttribute("FillLightAndReflectionProbeIndices")]
private static void FillLightAndReflectionProbeIndicesGraphicsBuffer(IntPtr cullingResultsPtr, GraphicsBuffer buffer);
    [FreeFunctionAttribute("GetLightIndexMapSize")]
private static int GetLightIndexMapSize(IntPtr cullingResultsPtr);
    [FreeFunctionAttribute("GetReflectionProbeIndexMapSize")]
private static int GetReflectionProbeIndexMapSize(IntPtr cullingResultsPtr);
    [FreeFunctionAttribute("FillLightIndexMapScriptable")]
private static void FillLightIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize);
    [FreeFunctionAttribute("FillReflectionProbeIndexMapScriptable")]
private static void FillReflectionProbeIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize);
    [FreeFunctionAttribute("SetLightIndexMapScriptable")]
private static void SetLightIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize);
    [FreeFunctionAttribute("SetReflectionProbeIndexMapScriptable")]
private static void SetReflectionProbeIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::GetShadowCasterBounds")]
private static bool GetShadowCasterBounds(IntPtr cullingResultsPtr, int lightIndex, Bounds& bounds);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::ComputeSpotShadowMatricesAndCullingPrimitives")]
private static bool ComputeSpotShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::ComputePointShadowMatricesAndCullingPrimitives")]
private static bool ComputePointShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::ComputeDirectionalShadowMatricesAndCullingPrimitives")]
private static bool ComputeDirectionalShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    public NativeArray`1<VisibleLight> get_visibleLights();
    public NativeArray`1<VisibleLight> get_visibleOffscreenVertexLights();
    public NativeArray`1<VisibleReflectionProbe> get_visibleReflectionProbes();
    private NativeArray`1<T> GetNativeArray(Void* dataPointer, int length);
    public int get_lightIndexCount();
    public int get_reflectionProbeIndexCount();
    public int get_lightAndReflectionProbeIndexCount();
    public void FillLightAndReflectionProbeIndices(ComputeBuffer computeBuffer);
    public void FillLightAndReflectionProbeIndices(GraphicsBuffer buffer);
    public NativeArray`1<int> GetLightIndexMap(Allocator allocator);
    public void SetLightIndexMap(NativeArray`1<int> lightIndexMap);
    public NativeArray`1<int> GetReflectionProbeIndexMap(Allocator allocator);
    public void SetReflectionProbeIndexMap(NativeArray`1<int> lightIndexMap);
    public bool GetShadowCasterBounds(int lightIndex, Bounds& outBounds);
    public bool ComputeSpotShadowMatricesAndCullingPrimitives(int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    public bool ComputePointShadowMatricesAndCullingPrimitives(int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    public bool ComputeDirectionalShadowMatricesAndCullingPrimitives(int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal void Validate();
    public sealed virtual bool Equals(CullingResults other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CullingResults left, CullingResults right);
    public static bool op_Inequality(CullingResults left, CullingResults right);
    private static bool ComputeDirectionalShadowMatricesAndCullingPrimitives_Injected(IntPtr cullingResultsPtr, int activeLightIndex, int splitIndex, int splitCount, Vector3& splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData);
}
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.CullingSplit : ValueType {
    public Vector3 sphereCenter;
    public float sphereRadius;
    public int cullingPlaneOffset;
    public int cullingPlaneCount;
    public float cascadeBlendCullingFactor;
    public float nearPlane;
    public Matrix4x4 cullingMatrix;
}
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.Rendering.CullMode : Enum {
    public int value__;
    public static CullMode Off;
    public static CullMode Front;
    public static CullMode Back;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.CustomMarkerCallbackFlags : Enum {
    public int value__;
    public static CustomMarkerCallbackFlags CustomMarkerCallbackDefault;
    public static CustomMarkerCallbackFlags CustomMarkerCallbackForceInvalidateStateTracking;
}
public enum UnityEngine.Rendering.DefaultReflectionMode : Enum {
    public int value__;
    public static DefaultReflectionMode Skybox;
    public static DefaultReflectionMode Custom;
}
public class UnityEngine.Rendering.DepthState : ValueType {
    private byte m_WriteEnabled;
    private sbyte m_CompareFunction;
    public static DepthState defaultValue { get; }
    public bool writeEnabled { get; public set; }
    public CompareFunction compareFunction { get; public set; }
    public DepthState(bool writeEnabled, CompareFunction compareFunction);
    public static DepthState get_defaultValue();
    public bool get_writeEnabled();
    public void set_writeEnabled(bool value);
    public CompareFunction get_compareFunction();
    public void set_compareFunction(CompareFunction value);
    public sealed virtual bool Equals(DepthState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DepthState left, DepthState right);
    public static bool op_Inequality(DepthState left, DepthState right);
}
public enum UnityEngine.Rendering.DistanceMetric : Enum {
    public int value__;
    public static DistanceMetric Perspective;
    public static DistanceMetric Orthographic;
    public static DistanceMetric CustomAxis;
}
public class UnityEngine.Rendering.DrawingSettings : ValueType {
    private static int kMaxShaderPasses;
    public static int maxShaderPasses;
    private SortingSettings m_SortingSettings;
    [FixedBufferAttribute("System.Int32", "16")]
internal <shaderPassNames>e__FixedBuffer shaderPassNames;
    private PerObjectData m_PerObjectData;
    private DrawRendererFlags m_Flags;
    private int m_OverrideShaderID;
    private int m_OverrideShaderPassIndex;
    private int m_OverrideMaterialInstanceId;
    private int m_OverrideMaterialPassIndex;
    private int m_fallbackMaterialInstanceId;
    private int m_MainLightIndex;
    private int m_UseSrpBatcher;
    public SortingSettings sortingSettings { get; public set; }
    public PerObjectData perObjectData { get; public set; }
    public bool enableDynamicBatching { get; public set; }
    public bool enableInstancing { get; public set; }
    public Material overrideMaterial { get; public set; }
    public Shader overrideShader { get; public set; }
    public int overrideMaterialPassIndex { get; public set; }
    public int overrideShaderPassIndex { get; public set; }
    public Material fallbackMaterial { get; public set; }
    public int mainLightIndex { get; public set; }
    public DrawingSettings(ShaderTagId shaderPassName, SortingSettings sortingSettings);
    private static DrawingSettings();
    public SortingSettings get_sortingSettings();
    public void set_sortingSettings(SortingSettings value);
    public PerObjectData get_perObjectData();
    public void set_perObjectData(PerObjectData value);
    public bool get_enableDynamicBatching();
    public void set_enableDynamicBatching(bool value);
    public bool get_enableInstancing();
    public void set_enableInstancing(bool value);
    public Material get_overrideMaterial();
    public void set_overrideMaterial(Material value);
    public Shader get_overrideShader();
    public void set_overrideShader(Shader value);
    public int get_overrideMaterialPassIndex();
    public void set_overrideMaterialPassIndex(int value);
    public int get_overrideShaderPassIndex();
    public void set_overrideShaderPassIndex(int value);
    public Material get_fallbackMaterial();
    public void set_fallbackMaterial(Material value);
    public int get_mainLightIndex();
    public void set_mainLightIndex(int value);
    public ShaderTagId GetShaderPassName(int index);
    public void SetShaderPassName(int index, ShaderTagId shaderPassName);
    public sealed virtual bool Equals(DrawingSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DrawingSettings left, DrawingSettings right);
    public static bool op_Inequality(DrawingSettings left, DrawingSettings right);
}
[FlagsAttribute]
internal enum UnityEngine.Rendering.DrawRendererFlags : Enum {
    public int value__;
    public static DrawRendererFlags None;
    public static DrawRendererFlags EnableDynamicBatching;
    public static DrawRendererFlags EnableInstancing;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.FastMemoryFlags : Enum {
    public int value__;
    public static FastMemoryFlags None;
    public static FastMemoryFlags SpillTop;
    public static FastMemoryFlags SpillBottom;
}
public class UnityEngine.Rendering.FilteringSettings : ValueType {
    private RenderQueueRange m_RenderQueueRange;
    private int m_LayerMask;
    private UInt32 m_RenderingLayerMask;
    private int m_ExcludeMotionVectorObjects;
    private SortingLayerRange m_SortingLayerRange;
    public static FilteringSettings defaultValue { get; }
    public RenderQueueRange renderQueueRange { get; public set; }
    public int layerMask { get; public set; }
    public UInt32 renderingLayerMask { get; public set; }
    public bool excludeMotionVectorObjects { get; public set; }
    public SortingLayerRange sortingLayerRange { get; public set; }
    public FilteringSettings(Nullable`1<RenderQueueRange> renderQueueRange, int layerMask, UInt32 renderingLayerMask, int excludeMotionVectorObjects);
    public static FilteringSettings get_defaultValue();
    public RenderQueueRange get_renderQueueRange();
    public void set_renderQueueRange(RenderQueueRange value);
    public int get_layerMask();
    public void set_layerMask(int value);
    public UInt32 get_renderingLayerMask();
    public void set_renderingLayerMask(UInt32 value);
    public bool get_excludeMotionVectorObjects();
    public void set_excludeMotionVectorObjects(bool value);
    public SortingLayerRange get_sortingLayerRange();
    public void set_sortingLayerRange(SortingLayerRange value);
    public sealed virtual bool Equals(FilteringSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FilteringSettings left, FilteringSettings right);
    public static bool op_Inequality(FilteringSettings left, FilteringSettings right);
}
public enum UnityEngine.Rendering.FormatSwizzle : Enum {
    public int value__;
    public static FormatSwizzle FormatSwizzleR;
    public static FormatSwizzle FormatSwizzleG;
    public static FormatSwizzle FormatSwizzleB;
    public static FormatSwizzle FormatSwizzleA;
    public static FormatSwizzle FormatSwizzle0;
    public static FormatSwizzle FormatSwizzle1;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.FoveatedRenderingCaps : Enum {
    public int value__;
    public static FoveatedRenderingCaps None;
    public static FoveatedRenderingCaps FoveationImage;
    public static FoveatedRenderingCaps NonUniformRaster;
}
public enum UnityEngine.Rendering.FoveatedRenderingMode : Enum {
    public int value__;
    public static FoveatedRenderingMode Disabled;
    public static FoveatedRenderingMode Enabled;
}
public enum UnityEngine.Rendering.GizmoSubset : Enum {
    public int value__;
    public static GizmoSubset PreImageEffects;
    public static GizmoSubset PostImageEffects;
}
[IsReadOnlyAttribute]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
public class UnityEngine.Rendering.GlobalKeyword : ValueType {
    internal string m_Name;
    internal UInt32 m_Index;
    public string name { get; }
    public GlobalKeyword(string name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalKeywordCount")]
private static UInt32 GetGlobalKeywordCount();
    [FreeFunctionAttribute("ShaderScripting::GetGlobalKeywordIndex")]
private static UInt32 GetGlobalKeywordIndex(string keyword);
    [FreeFunctionAttribute("ShaderScripting::CreateGlobalKeyword")]
private static void CreateGlobalKeyword(string keyword);
    public string get_name();
    public static GlobalKeyword Create(string name);
    public virtual string ToString();
}
[ObsoleteAttribute("GPUFence has been deprecated. Use GraphicsFence instead (UnityUpgradable) -> GraphicsFence", "False")]
public class UnityEngine.Rendering.GPUFence : ValueType {
    public bool passed { get; }
    public bool get_passed();
}
[UsedByNativeCodeAttribute]
public enum UnityEngine.Rendering.GraphicsDeviceType : Enum {
    public int value__;
    [ObsoleteAttribute("OpenGL2 is no longer supported in Unity 5.5+")]
public static GraphicsDeviceType OpenGL2;
    [ObsoleteAttribute("Direct3D 9 is no longer supported in Unity 2017.2+")]
public static GraphicsDeviceType Direct3D9;
    public static GraphicsDeviceType Direct3D11;
    [ObsoleteAttribute("PS3 is no longer supported in Unity 5.5+")]
public static GraphicsDeviceType PlayStation3;
    public static GraphicsDeviceType Null;
    [ObsoleteAttribute("Xbox360 is no longer supported in Unity 5.5+")]
public static GraphicsDeviceType Xbox360;
    public static GraphicsDeviceType OpenGLES2;
    public static GraphicsDeviceType OpenGLES3;
    [ObsoleteAttribute("PVita is no longer supported as of Unity 2018")]
public static GraphicsDeviceType PlayStationVita;
    public static GraphicsDeviceType PlayStation4;
    public static GraphicsDeviceType XboxOne;
    [ObsoleteAttribute("PlayStationMobile is no longer supported in Unity 5.3+")]
public static GraphicsDeviceType PlayStationMobile;
    public static GraphicsDeviceType Metal;
    public static GraphicsDeviceType OpenGLCore;
    public static GraphicsDeviceType Direct3D12;
    [ObsoleteAttribute("Nintendo 3DS support is unavailable since 2018.1")]
public static GraphicsDeviceType N3DS;
    public static GraphicsDeviceType Vulkan;
    public static GraphicsDeviceType Switch;
    public static GraphicsDeviceType XboxOneD3D12;
    public static GraphicsDeviceType GameCoreXboxOne;
    [ObsoleteAttribute("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", "False")]
public static GraphicsDeviceType GameCoreScarlett;
    public static GraphicsDeviceType GameCoreXboxSeries;
    public static GraphicsDeviceType PlayStation5;
    public static GraphicsDeviceType PlayStation5NGGC;
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/GPUFence.h")]
public class UnityEngine.Rendering.GraphicsFence : ValueType {
    internal IntPtr m_Ptr;
    internal int m_Version;
    internal GraphicsFenceType m_FenceType;
    public bool passed { get; }
    internal static SynchronisationStageFlags TranslateSynchronizationStageToFlags(SynchronisationStage s);
    public bool get_passed();
    [FreeFunctionAttribute("GPUFenceInternals::HasFencePassed_Internal")]
private static bool HasFencePassed_Internal(IntPtr fencePtr);
    internal void InitPostAllocation();
    internal bool IsFencePending();
    internal void Validate();
    private int GetPlatformNotSupportedVersion();
    [NativeThrowsAttribute]
[FreeFunctionAttribute("GPUFenceInternals::GetVersionNumber")]
private static int GetVersionNumber(IntPtr fencePtr);
}
public enum UnityEngine.Rendering.GraphicsFenceType : Enum {
    public int value__;
    public static GraphicsFenceType AsyncQueueSynchronisation;
    public static GraphicsFenceType CPUSynchronisation;
}
[NativeHeaderAttribute("Runtime/Camera/GraphicsSettings.h")]
[StaticAccessorAttribute("GetGraphicsSettings()", "0")]
public class UnityEngine.Rendering.GraphicsSettings : Object {
    public static TransparencySortMode transparencySortMode { get; public set; }
    public static Vector3 transparencySortAxis { get; public set; }
    public static bool realtimeDirectRectangularAreaLights { get; public set; }
    public static bool lightsUseLinearIntensity { get; public set; }
    public static bool lightsUseColorTemperature { get; public set; }
    public static UInt32 defaultRenderingLayerMask { get; public set; }
    public static bool useScriptableRenderPipelineBatching { get; public set; }
    public static bool logWhenShaderIsCompiled { get; public set; }
    public static bool disableBuiltinCustomRenderTextureUpdate { get; public set; }
    public static VideoShadersIncludeMode videoShadersIncludeMode { get; }
    public static LightProbeOutsideHullStrategy lightProbeOutsideHullStrategy { get; public set; }
    [NativeNameAttribute("CurrentRenderPipeline")]
private static ScriptableObject INTERNAL_currentRenderPipeline { get; }
    public static RenderPipelineAsset currentRenderPipeline { get; }
    public static RenderPipelineAsset renderPipelineAsset { get; public set; }
    [NativeNameAttribute("DefaultRenderPipeline")]
private static ScriptableObject INTERNAL_defaultRenderPipeline { get; private set; }
    public static RenderPipelineAsset defaultRenderPipeline { get; public set; }
    public static RenderPipelineAsset[] allConfiguredRenderPipelines { get; }
    public static bool cameraRelativeLightCulling { get; public set; }
    public static bool cameraRelativeShadowCulling { get; public set; }
    public static TransparencySortMode get_transparencySortMode();
    public static void set_transparencySortMode(TransparencySortMode value);
    public static Vector3 get_transparencySortAxis();
    public static void set_transparencySortAxis(Vector3 value);
    public static bool get_realtimeDirectRectangularAreaLights();
    public static void set_realtimeDirectRectangularAreaLights(bool value);
    public static bool get_lightsUseLinearIntensity();
    public static void set_lightsUseLinearIntensity(bool value);
    public static bool get_lightsUseColorTemperature();
    public static void set_lightsUseColorTemperature(bool value);
    public static UInt32 get_defaultRenderingLayerMask();
    public static void set_defaultRenderingLayerMask(UInt32 value);
    public static bool get_useScriptableRenderPipelineBatching();
    public static void set_useScriptableRenderPipelineBatching(bool value);
    public static bool get_logWhenShaderIsCompiled();
    public static void set_logWhenShaderIsCompiled(bool value);
    public static bool get_disableBuiltinCustomRenderTextureUpdate();
    public static void set_disableBuiltinCustomRenderTextureUpdate(bool value);
    public static VideoShadersIncludeMode get_videoShadersIncludeMode();
    public static LightProbeOutsideHullStrategy get_lightProbeOutsideHullStrategy();
    public static void set_lightProbeOutsideHullStrategy(LightProbeOutsideHullStrategy value);
    public static bool HasShaderDefine(GraphicsTier tier, BuiltinShaderDefine defineHash);
    public static bool HasShaderDefine(BuiltinShaderDefine defineHash);
    private static ScriptableObject get_INTERNAL_currentRenderPipeline();
    public static RenderPipelineAsset get_currentRenderPipeline();
    public static RenderPipelineAsset get_renderPipelineAsset();
    public static void set_renderPipelineAsset(RenderPipelineAsset value);
    private static ScriptableObject get_INTERNAL_defaultRenderPipeline();
    private static void set_INTERNAL_defaultRenderPipeline(ScriptableObject value);
    public static RenderPipelineAsset get_defaultRenderPipeline();
    public static void set_defaultRenderPipeline(RenderPipelineAsset value);
    [NativeNameAttribute("GetAllConfiguredRenderPipelinesForScript")]
private static ScriptableObject[] GetAllConfiguredRenderPipelines();
    public static RenderPipelineAsset[] get_allConfiguredRenderPipelines();
    [FreeFunctionAttribute]
public static Object GetGraphicsSettings();
    [NativeNameAttribute("SetShaderModeScript")]
public static void SetShaderMode(BuiltinShaderType type, BuiltinShaderMode mode);
    [NativeNameAttribute("GetShaderModeScript")]
public static BuiltinShaderMode GetShaderMode(BuiltinShaderType type);
    [NativeNameAttribute("SetCustomShaderScript")]
public static void SetCustomShader(BuiltinShaderType type, Shader shader);
    [NativeNameAttribute("GetCustomShaderScript")]
public static Shader GetCustomShader(BuiltinShaderType type);
    public static void RegisterRenderPipelineSettings(RenderPipelineGlobalSettings settings);
    [NativeNameAttribute("RegisterRenderPipelineSettings")]
private static void RegisterRenderPipeline(string renderpipelineName, Object settings);
    public static void UnregisterRenderPipelineSettings();
    [NativeNameAttribute("UnregisterRenderPipelineSettings")]
private static void UnregisterRenderPipeline(string renderpipelineName);
    public static RenderPipelineGlobalSettings GetSettingsForRenderPipeline();
    [NativeNameAttribute("GetSettingsForRenderPipeline")]
private static Object GetSettingsForRenderPipeline(string renderpipelineName);
    public static bool get_cameraRelativeLightCulling();
    public static void set_cameraRelativeLightCulling(bool value);
    public static bool get_cameraRelativeShadowCulling();
    public static void set_cameraRelativeShadowCulling(bool value);
    private static void get_transparencySortAxis_Injected(Vector3& ret);
    private static void set_transparencySortAxis_Injected(Vector3& value);
}
public enum UnityEngine.Rendering.GraphicsTier : Enum {
    public int value__;
    public static GraphicsTier Tier1;
    public static GraphicsTier Tier2;
    public static GraphicsTier Tier3;
}
public enum UnityEngine.Rendering.IndexFormat : Enum {
    public int value__;
    public static IndexFormat UInt16;
    public static IndexFormat UInt32;
}
public enum UnityEngine.Rendering.LightEvent : Enum {
    public int value__;
    public static LightEvent BeforeShadowMap;
    public static LightEvent AfterShadowMap;
    public static LightEvent BeforeScreenspaceMask;
    public static LightEvent AfterScreenspaceMask;
    public static LightEvent BeforeShadowMapPass;
    public static LightEvent AfterShadowMapPass;
}
public enum UnityEngine.Rendering.LightProbeOutsideHullStrategy : Enum {
    public int value__;
    public static LightProbeOutsideHullStrategy kLightProbeSearchTetrahedralHull;
    public static LightProbeOutsideHullStrategy kLightProbeUseAmbientProbe;
}
public enum UnityEngine.Rendering.LightProbeUsage : Enum {
    public int value__;
    public static LightProbeUsage Off;
    public static LightProbeUsage BlendProbes;
    public static LightProbeUsage UseProxyVolume;
    public static LightProbeUsage CustomProvided;
}
public enum UnityEngine.Rendering.LightShadowResolution : Enum {
    public int value__;
    public static LightShadowResolution FromQualitySettings;
    public static LightShadowResolution Low;
    public static LightShadowResolution Medium;
    public static LightShadowResolution High;
    public static LightShadowResolution VeryHigh;
}
public static class UnityEngine.Rendering.LoadStoreActionDebugModeSettings : object {
    [StaticAccessorAttribute("GetGfxDevice()", "0")]
public static bool LoadStoreDebugModeEnabled { get; public set; }
    public static bool get_LoadStoreDebugModeEnabled();
    public static void set_LoadStoreDebugModeEnabled(bool value);
}
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[IsReadOnlyAttribute]
public class UnityEngine.Rendering.LocalKeyword : ValueType {
    internal LocalKeywordSpace m_SpaceInfo;
    internal string m_Name;
    internal UInt32 m_Index;
    public string name { get; }
    public bool isDynamic { get; }
    public bool isOverridable { get; }
    public bool isValid { get; }
    public ShaderKeywordType type { get; }
    public LocalKeyword(Shader shader, string name);
    public LocalKeyword(ComputeShader shader, string name);
    [FreeFunctionAttribute("keywords::IsKeywordDynamic")]
private static bool IsDynamic(LocalKeyword kw);
    [FreeFunctionAttribute("keywords::IsKeywordOverridable")]
private static bool IsOverridable(LocalKeyword kw);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordCount")]
private static UInt32 GetShaderKeywordCount(Shader shader);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordIndex")]
private static UInt32 GetShaderKeywordIndex(Shader shader, string keyword);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordCount")]
private static UInt32 GetComputeShaderKeywordCount(ComputeShader shader);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordIndex")]
private static UInt32 GetComputeShaderKeywordIndex(ComputeShader shader, string keyword);
    [FreeFunctionAttribute("keywords::GetKeywordType")]
private static ShaderKeywordType GetKeywordType(LocalKeywordSpace spaceInfo, UInt32 keyword);
    [FreeFunctionAttribute("keywords::IsKeywordValid")]
private static bool IsValid(LocalKeywordSpace spaceInfo, UInt32 keyword);
    public string get_name();
    public bool get_isDynamic();
    public bool get_isOverridable();
    public bool get_isValid();
    public ShaderKeywordType get_type();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(LocalKeyword rhs);
    public static bool op_Equality(LocalKeyword lhs, LocalKeyword rhs);
    public static bool op_Inequality(LocalKeyword lhs, LocalKeyword rhs);
    public virtual int GetHashCode();
    private static bool IsDynamic_Injected(LocalKeyword& kw);
    private static bool IsOverridable_Injected(LocalKeyword& kw);
    private static ShaderKeywordType GetKeywordType_Injected(LocalKeywordSpace& spaceInfo, UInt32 keyword);
    private static bool IsValid_Injected(LocalKeywordSpace& spaceInfo, UInt32 keyword);
}
[IsReadOnlyAttribute]
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
public class UnityEngine.Rendering.LocalKeywordSpace : ValueType {
    private IntPtr m_KeywordSpace;
    public LocalKeyword[] keywords { get; }
    public String[] keywordNames { get; }
    public UInt32 keywordCount { get; }
    [FreeFunctionAttribute("keywords::GetKeywords")]
private LocalKeyword[] GetKeywords();
    [FreeFunctionAttribute("keywords::GetKeywordNames")]
private String[] GetKeywordNames();
    [FreeFunctionAttribute("keywords::GetKeywordCount")]
private UInt32 GetKeywordCount();
    [FreeFunctionAttribute("keywords::GetKeyword")]
private LocalKeyword GetKeyword(string name);
    public LocalKeyword[] get_keywords();
    public String[] get_keywordNames();
    public UInt32 get_keywordCount();
    public LocalKeyword FindKeyword(string name);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(LocalKeywordSpace rhs);
    public static bool op_Equality(LocalKeywordSpace lhs, LocalKeywordSpace rhs);
    public static bool op_Inequality(LocalKeywordSpace lhs, LocalKeywordSpace rhs);
    public virtual int GetHashCode();
    private static LocalKeyword[] GetKeywords_Injected(LocalKeywordSpace& _unity_self);
    private static String[] GetKeywordNames_Injected(LocalKeywordSpace& _unity_self);
    private static UInt32 GetKeywordCount_Injected(LocalKeywordSpace& _unity_self);
    private static void GetKeyword_Injected(LocalKeywordSpace& _unity_self, string name, LocalKeyword& ret);
}
public class UnityEngine.Rendering.LODParameters : ValueType {
    private int m_IsOrthographic;
    private Vector3 m_CameraPosition;
    private float m_FieldOfView;
    private float m_OrthoSize;
    private int m_CameraPixelHeight;
    public bool isOrthographic { get; public set; }
    public Vector3 cameraPosition { get; public set; }
    public float fieldOfView { get; public set; }
    public float orthoSize { get; public set; }
    public int cameraPixelHeight { get; public set; }
    public bool get_isOrthographic();
    public void set_isOrthographic(bool value);
    public Vector3 get_cameraPosition();
    public void set_cameraPosition(Vector3 value);
    public float get_fieldOfView();
    public void set_fieldOfView(float value);
    public float get_orthoSize();
    public void set_orthoSize(float value);
    public int get_cameraPixelHeight();
    public void set_cameraPixelHeight(int value);
    public sealed virtual bool Equals(LODParameters other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LODParameters left, LODParameters right);
    public static bool op_Inequality(LODParameters left, LODParameters right);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.MeshUpdateFlags : Enum {
    public int value__;
    public static MeshUpdateFlags Default;
    public static MeshUpdateFlags DontValidateIndices;
    public static MeshUpdateFlags DontResetBoneBounds;
    public static MeshUpdateFlags DontNotifyMeshUsers;
    public static MeshUpdateFlags DontRecalculateBounds;
}
public class UnityEngine.Rendering.MetadataValue : ValueType {
    public int NameID;
    public UInt32 Value;
}
public class UnityEngine.Rendering.ObjectIdRequest : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RenderTexture <destination>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <mipLevel>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private CubemapFace <face>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <slice>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ObjectIdResult <result>k__BackingField;
    public RenderTexture destination { get; public set; }
    public int mipLevel { get; public set; }
    public CubemapFace face { get; public set; }
    public int slice { get; public set; }
    public ObjectIdResult result { get; internal set; }
    public ObjectIdRequest(RenderTexture destination, int mipLevel, CubemapFace face, int slice);
    [CompilerGeneratedAttribute]
public RenderTexture get_destination();
    [CompilerGeneratedAttribute]
public void set_destination(RenderTexture value);
    [CompilerGeneratedAttribute]
public int get_mipLevel();
    [CompilerGeneratedAttribute]
public void set_mipLevel(int value);
    [CompilerGeneratedAttribute]
public CubemapFace get_face();
    [CompilerGeneratedAttribute]
public void set_face(CubemapFace value);
    [CompilerGeneratedAttribute]
public int get_slice();
    [CompilerGeneratedAttribute]
public void set_slice(int value);
    [CompilerGeneratedAttribute]
public ObjectIdResult get_result();
    [CompilerGeneratedAttribute]
internal void set_result(ObjectIdResult value);
}
public class UnityEngine.Rendering.ObjectIdResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Object[] <idToObjectMapping>k__BackingField;
    public Object[] idToObjectMapping { get; }
    internal ObjectIdResult(Object[] idToObjectMapping);
    [CompilerGeneratedAttribute]
public Object[] get_idToObjectMapping();
    public static int DecodeIdFromColor(Color color);
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Rendering.OnDemandRendering : object {
    private static int m_RenderFrameInterval;
    public static bool willCurrentFrameRender { get; }
    public static int renderFrameInterval { get; public set; }
    public static int effectiveRenderFrameRate { get; }
    private static OnDemandRendering();
    public static bool get_willCurrentFrameRender();
    public static int get_renderFrameInterval();
    public static void set_renderFrameInterval(int value);
    [RequiredByNativeCodeAttribute]
internal static void GetRenderFrameInterval(Int32& frameInterval);
    [FreeFunctionAttribute]
internal static float GetEffectiveRenderFrameRate();
    public static int get_effectiveRenderFrameRate();
}
public enum UnityEngine.Rendering.OpaqueSortMode : Enum {
    public int value__;
    public static OpaqueSortMode Default;
    public static OpaqueSortMode FrontToBack;
    public static OpaqueSortMode NoDistanceSort;
}
public enum UnityEngine.Rendering.OpenGLESVersion : Enum {
    public int value__;
    public static OpenGLESVersion None;
    public static OpenGLESVersion OpenGLES20;
    public static OpenGLESVersion OpenGLES30;
    public static OpenGLESVersion OpenGLES31;
    public static OpenGLESVersion OpenGLES31AEP;
    public static OpenGLESVersion OpenGLES32;
}
[IsReadOnlyAttribute]
[NativeHeaderAttribute("Runtime/Shaders/PassIdentifier.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.PassIdentifier : ValueType {
    internal UInt32 m_SubShaderIndex;
    internal UInt32 m_PassIndex;
    public UInt32 SubshaderIndex { get; }
    public UInt32 PassIndex { get; }
    public PassIdentifier(UInt32 subshaderIndex, UInt32 passIndex);
    public UInt32 get_SubshaderIndex();
    public UInt32 get_PassIndex();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(PassIdentifier rhs);
    public static bool op_Equality(PassIdentifier lhs, PassIdentifier rhs);
    public static bool op_Inequality(PassIdentifier lhs, PassIdentifier rhs);
    public virtual int GetHashCode();
}
public enum UnityEngine.Rendering.PassType : Enum {
    public int value__;
    public static PassType Normal;
    public static PassType Vertex;
    public static PassType VertexLM;
    [ObsoleteAttribute("VertexLMRGBM PassType is obsolete. Please use VertexLM PassType together with DecodeLightmap shader function.")]
public static PassType VertexLMRGBM;
    public static PassType ForwardBase;
    public static PassType ForwardAdd;
    [ObsoleteAttribute("Deferred Lighting was removed, so LightPrePassBase pass type is never used anymore.")]
public static PassType LightPrePassBase;
    [ObsoleteAttribute("Deferred Lighting was removed, so LightPrePassFinal pass type is never used anymore.")]
public static PassType LightPrePassFinal;
    public static PassType ShadowCaster;
    public static PassType Deferred;
    public static PassType Meta;
    public static PassType MotionVectors;
    public static PassType ScriptableRenderPipeline;
    public static PassType ScriptableRenderPipelineDefaultUnlit;
    public static PassType GrabPass;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.PerObjectData : Enum {
    public int value__;
    public static PerObjectData None;
    public static PerObjectData LightProbe;
    public static PerObjectData ReflectionProbes;
    public static PerObjectData LightProbeProxyVolume;
    public static PerObjectData Lightmaps;
    public static PerObjectData LightData;
    public static PerObjectData MotionVectors;
    public static PerObjectData LightIndices;
    public static PerObjectData ReflectionProbeData;
    public static PerObjectData OcclusionProbe;
    public static PerObjectData OcclusionProbeProxyVolume;
    public static PerObjectData ShadowMask;
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public class UnityEngine.Rendering.PIX : object {
    [FreeFunctionAttribute("PIX::BeginGPUCapture")]
public static void BeginGPUCapture();
    [FreeFunctionAttribute("PIX::EndGPUCapture")]
public static void EndGPUCapture();
    [FreeFunctionAttribute("PIX::IsAttached")]
public static bool IsAttached();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.PlatformKeywordSet : ValueType {
    private static int k_SizeInBits;
    internal ulong m_Bits;
    private ulong ComputeKeywordMask(BuiltinShaderDefine define);
    public bool IsEnabled(BuiltinShaderDefine define);
    public void Enable(BuiltinShaderDefine define);
    public void Disable(BuiltinShaderDefine define);
}
public class UnityEngine.Rendering.RasterState : ValueType {
    public static RasterState defaultValue;
    private CullMode m_CullingMode;
    private int m_OffsetUnits;
    private float m_OffsetFactor;
    private byte m_DepthClip;
    private byte m_Conservative;
    private byte m_Padding1;
    private byte m_Padding2;
    public CullMode cullingMode { get; public set; }
    public bool depthClip { get; public set; }
    public bool conservative { get; public set; }
    public int offsetUnits { get; public set; }
    public float offsetFactor { get; public set; }
    public RasterState(CullMode cullingMode, int offsetUnits, float offsetFactor, bool depthClip);
    private static RasterState();
    public CullMode get_cullingMode();
    public void set_cullingMode(CullMode value);
    public bool get_depthClip();
    public void set_depthClip(bool value);
    public bool get_conservative();
    public void set_conservative(bool value);
    public int get_offsetUnits();
    public void set_offsetUnits(int value);
    public float get_offsetFactor();
    public void set_offsetFactor(float value);
    public sealed virtual bool Equals(RasterState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RasterState left, RasterState right);
    public static bool op_Inequality(RasterState left, RasterState right);
}
public enum UnityEngine.Rendering.RealtimeGICPUUsage : Enum {
    public int value__;
    public static RealtimeGICPUUsage Low;
    public static RealtimeGICPUUsage Medium;
    public static RealtimeGICPUUsage High;
    public static RealtimeGICPUUsage Unlimited;
}
public enum UnityEngine.Rendering.ReflectionCubemapCompression : Enum {
    public int value__;
    public static ReflectionCubemapCompression Uncompressed;
    public static ReflectionCubemapCompression Compressed;
    public static ReflectionCubemapCompression Auto;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.ReflectionProbeBlendInfo : ValueType {
    public ReflectionProbe probe;
    public float weight;
}
public enum UnityEngine.Rendering.ReflectionProbeClearFlags : Enum {
    public int value__;
    public static ReflectionProbeClearFlags Skybox;
    public static ReflectionProbeClearFlags SolidColor;
}
public enum UnityEngine.Rendering.ReflectionProbeMode : Enum {
    public int value__;
    public static ReflectionProbeMode Baked;
    public static ReflectionProbeMode Realtime;
    public static ReflectionProbeMode Custom;
}
public enum UnityEngine.Rendering.ReflectionProbeRefreshMode : Enum {
    public int value__;
    public static ReflectionProbeRefreshMode OnAwake;
    public static ReflectionProbeRefreshMode EveryFrame;
    public static ReflectionProbeRefreshMode ViaScripting;
}
public enum UnityEngine.Rendering.ReflectionProbeSortingCriteria : Enum {
    public int value__;
    public static ReflectionProbeSortingCriteria None;
    public static ReflectionProbeSortingCriteria Importance;
    public static ReflectionProbeSortingCriteria Size;
    public static ReflectionProbeSortingCriteria ImportanceThenSize;
}
public enum UnityEngine.Rendering.ReflectionProbeTimeSlicingMode : Enum {
    public int value__;
    public static ReflectionProbeTimeSlicingMode AllFacesAtOnce;
    public static ReflectionProbeTimeSlicingMode IndividualFaces;
    public static ReflectionProbeTimeSlicingMode NoTimeSlicing;
}
public enum UnityEngine.Rendering.ReflectionProbeType : Enum {
    public int value__;
    public static ReflectionProbeType Cube;
    public static ReflectionProbeType Card;
}
public enum UnityEngine.Rendering.ReflectionProbeUsage : Enum {
    public int value__;
    public static ReflectionProbeUsage Off;
    public static ReflectionProbeUsage BlendProbes;
    public static ReflectionProbeUsage BlendProbesAndSkybox;
    public static ReflectionProbeUsage Simple;
}
public enum UnityEngine.Rendering.RenderBufferLoadAction : Enum {
    public int value__;
    public static RenderBufferLoadAction Load;
    public static RenderBufferLoadAction Clear;
    public static RenderBufferLoadAction DontCare;
}
public enum UnityEngine.Rendering.RenderBufferStoreAction : Enum {
    public int value__;
    public static RenderBufferStoreAction Store;
    public static RenderBufferStoreAction Resolve;
    public static RenderBufferStoreAction StoreAndResolve;
    public static RenderBufferStoreAction DontCare;
}
[MovedFromAttribute("UnityEngine.Rendering.RendererUtils")]
[NativeHeaderAttribute("Runtime/Graphics/ScriptableRenderLoop/RendererList.h")]
public class UnityEngine.Rendering.RendererList : ValueType {
    internal UIntPtr context;
    internal UInt32 index;
    internal UInt32 frame;
    internal UInt32 type;
    public static RendererList nullRendererList;
    public bool isValid { get; }
    internal RendererList(UIntPtr ctx, UInt32 indx);
    private static RendererList();
    public bool get_isValid();
    private static bool get_isValid_Injected(RendererList& _unity_self);
}
public class UnityEngine.Rendering.RendererListParams : ValueType {
    public static RendererListParams Invalid;
    public CullingResults cullingResults;
    public DrawingSettings drawSettings;
    public FilteringSettings filteringSettings;
    public ShaderTagId tagName;
    public bool isPassTagName;
    public Nullable`1<NativeArray`1<ShaderTagId>> tagValues;
    public Nullable`1<NativeArray`1<RenderStateBlock>> stateBlocks;
    internal int numStateBlocks { get; }
    internal IntPtr stateBlocksPtr { get; }
    internal IntPtr tagsValuePtr { get; }
    public RendererListParams(CullingResults cullingResults, DrawingSettings drawSettings, FilteringSettings filteringSettings);
    private static RendererListParams();
    internal int get_numStateBlocks();
    internal IntPtr get_stateBlocksPtr();
    internal IntPtr get_tagsValuePtr();
    internal void Dispose();
    internal void Validate();
    public sealed virtual bool Equals(RendererListParams other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RendererListParams left, RendererListParams right);
    public static bool op_Inequality(RendererListParams left, RendererListParams right);
}
[MovedFromAttribute("UnityEngine.Rendering.RendererUtils")]
public enum UnityEngine.Rendering.RendererListStatus : Enum {
    public int value__;
    public static RendererListStatus kRendererListInvalid;
    public static RendererListStatus kRendererListProcessing;
    public static RendererListStatus kRendererListEmpty;
    public static RendererListStatus kRendererListPopulated;
}
public class UnityEngine.Rendering.RendererUtils.RendererListDesc : ValueType {
    public SortingCriteria sortingCriteria;
    public PerObjectData rendererConfiguration;
    public RenderQueueRange renderQueueRange;
    public Nullable`1<RenderStateBlock> stateBlock;
    public Shader overrideShader;
    public Material overrideMaterial;
    public bool excludeObjectMotionVectors;
    public int layerMask;
    public UInt32 renderingLayerMask;
    public int overrideMaterialPassIndex;
    public int overrideShaderPassIndex;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private CullingResults <cullingResult>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Camera <camera>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ShaderTagId <passName>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ShaderTagId[] <passNames>k__BackingField;
    private static ShaderTagId s_EmptyName;
    internal CullingResults cullingResult { get; private set; }
    internal Camera camera { get; internal set; }
    internal ShaderTagId passName { get; private set; }
    internal ShaderTagId[] passNames { get; private set; }
    public RendererListDesc(ShaderTagId passName, CullingResults cullingResult, Camera camera);
    public RendererListDesc(ShaderTagId[] passNames, CullingResults cullingResult, Camera camera);
    private static RendererListDesc();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal CullingResults get_cullingResult();
    [CompilerGeneratedAttribute]
private void set_cullingResult(CullingResults value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal Camera get_camera();
    [CompilerGeneratedAttribute]
internal void set_camera(Camera value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal ShaderTagId get_passName();
    [CompilerGeneratedAttribute]
private void set_passName(ShaderTagId value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
internal ShaderTagId[] get_passNames();
    [CompilerGeneratedAttribute]
private void set_passNames(ShaderTagId[] value);
    public bool IsValid();
    public static RendererListParams ConvertToParameters(RendererListDesc& desc);
}
[MovedFromAttribute("UnityEngine.Experimental.Rendering")]
public enum UnityEngine.Rendering.RenderingThreadingMode : Enum {
    public int value__;
    public static RenderingThreadingMode Direct;
    public static RenderingThreadingMode SingleThreaded;
    public static RenderingThreadingMode MultiThreaded;
    public static RenderingThreadingMode LegacyJobified;
    public static RenderingThreadingMode NativeGraphicsJobs;
    public static RenderingThreadingMode NativeGraphicsJobsWithoutRenderThread;
}
public abstract class UnityEngine.Rendering.RenderPipeline : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <disposed>k__BackingField;
    public bool disposed { get; private set; }
    public RenderPipelineGlobalSettings defaultSettings { get; }
    protected abstract virtual void Render(ScriptableRenderContext context, Camera[] cameras);
    protected virtual void ProcessRenderRequests(ScriptableRenderContext context, Camera camera, RequestData renderRequest);
    protected internal virtual bool IsRenderRequestSupported(Camera camera, RequestData data);
    protected static void BeginFrameRendering(ScriptableRenderContext context, Camera[] cameras);
    protected static void BeginContextRendering(ScriptableRenderContext context, List`1<Camera> cameras);
    protected static void BeginCameraRendering(ScriptableRenderContext context, Camera camera);
    protected static void EndContextRendering(ScriptableRenderContext context, List`1<Camera> cameras);
    protected static void EndFrameRendering(ScriptableRenderContext context, Camera[] cameras);
    protected static void EndCameraRendering(ScriptableRenderContext context, Camera camera);
    protected virtual void Render(ScriptableRenderContext context, List`1<Camera> cameras);
    internal void InternalRender(ScriptableRenderContext context, List`1<Camera> cameras);
    internal void InternalProcessRenderRequests(ScriptableRenderContext context, Camera camera, RequestData renderRequest);
    public static bool SupportsRenderRequest(Camera camera, RequestData data);
    public static void SubmitRenderRequest(Camera camera, RequestData data);
    [CompilerGeneratedAttribute]
public bool get_disposed();
    [CompilerGeneratedAttribute]
private void set_disposed(bool value);
    internal void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual RenderPipelineGlobalSettings get_defaultSettings();
}
public abstract class UnityEngine.Rendering.RenderPipelineAsset : ScriptableObject {
    public String[] renderingLayerMaskNames { get; }
    public String[] prefixedRenderingLayerMaskNames { get; }
    public Material defaultMaterial { get; }
    public Shader autodeskInteractiveShader { get; }
    public Shader autodeskInteractiveTransparentShader { get; }
    public Shader autodeskInteractiveMaskedShader { get; }
    public Shader terrainDetailLitShader { get; }
    public Shader terrainDetailGrassShader { get; }
    public Shader terrainDetailGrassBillboardShader { get; }
    public Material defaultParticleMaterial { get; }
    public Material defaultLineMaterial { get; }
    public Material defaultTerrainMaterial { get; }
    public Material defaultUIMaterial { get; }
    public Material defaultUIOverdrawMaterial { get; }
    public Material defaultUIETC1SupportedMaterial { get; }
    public Material default2DMaterial { get; }
    public Material default2DMaskMaterial { get; }
    public Shader defaultShader { get; }
    public Shader defaultSpeedTree7Shader { get; }
    public Shader defaultSpeedTree8Shader { get; }
    public string renderPipelineShaderTag { get; }
    internal RenderPipeline InternalCreatePipeline();
    public virtual String[] get_renderingLayerMaskNames();
    public virtual String[] get_prefixedRenderingLayerMaskNames();
    public virtual Material get_defaultMaterial();
    public virtual Shader get_autodeskInteractiveShader();
    public virtual Shader get_autodeskInteractiveTransparentShader();
    public virtual Shader get_autodeskInteractiveMaskedShader();
    public virtual Shader get_terrainDetailLitShader();
    public virtual Shader get_terrainDetailGrassShader();
    public virtual Shader get_terrainDetailGrassBillboardShader();
    public virtual Material get_defaultParticleMaterial();
    public virtual Material get_defaultLineMaterial();
    public virtual Material get_defaultTerrainMaterial();
    public virtual Material get_defaultUIMaterial();
    public virtual Material get_defaultUIOverdrawMaterial();
    public virtual Material get_defaultUIETC1SupportedMaterial();
    public virtual Material get_default2DMaterial();
    public virtual Material get_default2DMaskMaterial();
    public virtual Shader get_defaultShader();
    public virtual Shader get_defaultSpeedTree7Shader();
    public virtual Shader get_defaultSpeedTree8Shader();
    public virtual string get_renderPipelineShaderTag();
    protected abstract virtual RenderPipeline CreatePipeline();
    protected virtual void OnValidate();
    protected virtual void OnDisable();
}
public abstract class UnityEngine.Rendering.RenderPipelineGlobalSettings : ScriptableObject {
}
public static class UnityEngine.Rendering.RenderPipelineManager : object {
    internal static RenderPipelineAsset s_CurrentPipelineAsset;
    private static List`1<Camera> s_Cameras;
    private static string s_CurrentPipelineType;
    private static string k_BuiltinPipelineName;
    private static RenderPipeline s_CurrentPipeline;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`2<ScriptableRenderContext, Camera[]> beginFrameRendering;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<ScriptableRenderContext, Camera[]> endFrameRendering;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<ScriptableRenderContext, List`1<Camera>> beginContextRendering;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`2<ScriptableRenderContext, List`1<Camera>> endContextRendering;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<ScriptableRenderContext, Camera> beginCameraRendering;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`2<ScriptableRenderContext, Camera> endCameraRendering;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action activeRenderPipelineTypeChanged;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`2<RenderPipelineAsset, RenderPipelineAsset> activeRenderPipelineAssetChanged;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action activeRenderPipelineCreated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action activeRenderPipelineDisposed;
    public static RenderPipeline currentPipeline { get; private set; }
    public static bool pipelineSwitchCompleted { get; }
    private static RenderPipelineManager();
    public static RenderPipeline get_currentPipeline();
    private static void set_currentPipeline(RenderPipeline value);
    [CompilerGeneratedAttribute]
public static void add_beginFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value);
    [CompilerGeneratedAttribute]
public static void remove_beginFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value);
    [CompilerGeneratedAttribute]
public static void add_endFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value);
    [CompilerGeneratedAttribute]
public static void remove_endFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value);
    [CompilerGeneratedAttribute]
public static void add_beginContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value);
    [CompilerGeneratedAttribute]
public static void remove_beginContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value);
    [CompilerGeneratedAttribute]
public static void add_endContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value);
    [CompilerGeneratedAttribute]
public static void remove_endContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value);
    [CompilerGeneratedAttribute]
public static void add_beginCameraRendering(Action`2<ScriptableRenderContext, Camera> value);
    [CompilerGeneratedAttribute]
public static void remove_beginCameraRendering(Action`2<ScriptableRenderContext, Camera> value);
    [CompilerGeneratedAttribute]
public static void add_endCameraRendering(Action`2<ScriptableRenderContext, Camera> value);
    [CompilerGeneratedAttribute]
public static void remove_endCameraRendering(Action`2<ScriptableRenderContext, Camera> value);
    [CompilerGeneratedAttribute]
public static void add_activeRenderPipelineTypeChanged(Action value);
    [CompilerGeneratedAttribute]
public static void remove_activeRenderPipelineTypeChanged(Action value);
    [CompilerGeneratedAttribute]
public static void add_activeRenderPipelineAssetChanged(Action`2<RenderPipelineAsset, RenderPipelineAsset> value);
    [CompilerGeneratedAttribute]
public static void remove_activeRenderPipelineAssetChanged(Action`2<RenderPipelineAsset, RenderPipelineAsset> value);
    [CompilerGeneratedAttribute]
public static void add_activeRenderPipelineCreated(Action value);
    [CompilerGeneratedAttribute]
public static void remove_activeRenderPipelineCreated(Action value);
    [CompilerGeneratedAttribute]
public static void add_activeRenderPipelineDisposed(Action value);
    [CompilerGeneratedAttribute]
public static void remove_activeRenderPipelineDisposed(Action value);
    public static bool get_pipelineSwitchCompleted();
    internal static void BeginContextRendering(ScriptableRenderContext context, List`1<Camera> cameras);
    internal static void BeginCameraRendering(ScriptableRenderContext context, Camera camera);
    internal static void EndContextRendering(ScriptableRenderContext context, List`1<Camera> cameras);
    internal static void EndCameraRendering(ScriptableRenderContext context, Camera camera);
    [RequiredByNativeCodeAttribute]
internal static void OnActiveRenderPipelineTypeChanged();
    [RequiredByNativeCodeAttribute]
internal static void OnActiveRenderPipelineAssetChanged(ScriptableObject from, ScriptableObject to);
    [RequiredByNativeCodeAttribute]
internal static void HandleRenderPipelineChange(RenderPipelineAsset pipelineAsset);
    [RequiredByNativeCodeAttribute]
internal static void CleanupRenderPipeline();
    [RequiredByNativeCodeAttribute]
private static string GetCurrentPipelineAssetType();
    [RequiredByNativeCodeAttribute]
private static void DoRenderLoop_Internal(RenderPipelineAsset pipe, IntPtr loopPtr, Object renderRequest);
    internal static void PrepareRenderPipeline(RenderPipelineAsset pipelineAsset);
    private static bool IsPipelineRequireCreation();
}
public enum UnityEngine.Rendering.RenderQueue : Enum {
    public int value__;
    public static RenderQueue Background;
    public static RenderQueue Geometry;
    public static RenderQueue AlphaTest;
    public static RenderQueue GeometryLast;
    public static RenderQueue Transparent;
    public static RenderQueue Overlay;
}
public class UnityEngine.Rendering.RenderQueueRange : ValueType {
    private int m_LowerBound;
    private int m_UpperBound;
    private static int k_MinimumBound;
    public static int minimumBound;
    private static int k_MaximumBound;
    public static int maximumBound;
    public static RenderQueueRange all { get; }
    public static RenderQueueRange opaque { get; }
    public static RenderQueueRange transparent { get; }
    public int lowerBound { get; public set; }
    public int upperBound { get; public set; }
    public RenderQueueRange(int lowerBound, int upperBound);
    private static RenderQueueRange();
    public static RenderQueueRange get_all();
    public static RenderQueueRange get_opaque();
    public static RenderQueueRange get_transparent();
    public int get_lowerBound();
    public void set_lowerBound(int value);
    public int get_upperBound();
    public void set_upperBound(int value);
    public sealed virtual bool Equals(RenderQueueRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RenderQueueRange left, RenderQueueRange right);
    public static bool op_Inequality(RenderQueueRange left, RenderQueueRange right);
}
public class UnityEngine.Rendering.RenderStateBlock : ValueType {
    private BlendState m_BlendState;
    private RasterState m_RasterState;
    private DepthState m_DepthState;
    private StencilState m_StencilState;
    private int m_StencilReference;
    private RenderStateMask m_Mask;
    public BlendState blendState { get; public set; }
    public RasterState rasterState { get; public set; }
    public DepthState depthState { get; public set; }
    public StencilState stencilState { get; public set; }
    public int stencilReference { get; public set; }
    public RenderStateMask mask { get; public set; }
    public RenderStateBlock(RenderStateMask mask);
    public BlendState get_blendState();
    public void set_blendState(BlendState value);
    public RasterState get_rasterState();
    public void set_rasterState(RasterState value);
    public DepthState get_depthState();
    public void set_depthState(DepthState value);
    public StencilState get_stencilState();
    public void set_stencilState(StencilState value);
    public int get_stencilReference();
    public void set_stencilReference(int value);
    public RenderStateMask get_mask();
    public void set_mask(RenderStateMask value);
    public sealed virtual bool Equals(RenderStateBlock other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RenderStateBlock left, RenderStateBlock right);
    public static bool op_Inequality(RenderStateBlock left, RenderStateBlock right);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.RenderStateMask : Enum {
    public int value__;
    public static RenderStateMask Nothing;
    public static RenderStateMask Blend;
    public static RenderStateMask Raster;
    public static RenderStateMask Depth;
    public static RenderStateMask Stencil;
    public static RenderStateMask Everything;
}
public class UnityEngine.Rendering.RenderTargetBinding : ValueType {
    private RenderTargetIdentifier[] m_ColorRenderTargets;
    private RenderTargetIdentifier m_DepthRenderTarget;
    private RenderBufferLoadAction[] m_ColorLoadActions;
    private RenderBufferStoreAction[] m_ColorStoreActions;
    private RenderBufferLoadAction m_DepthLoadAction;
    private RenderBufferStoreAction m_DepthStoreAction;
    private RenderTargetFlags m_Flags;
    public RenderTargetIdentifier[] colorRenderTargets { get; public set; }
    public RenderTargetIdentifier depthRenderTarget { get; public set; }
    public RenderBufferLoadAction[] colorLoadActions { get; public set; }
    public RenderBufferStoreAction[] colorStoreActions { get; public set; }
    public RenderBufferLoadAction depthLoadAction { get; public set; }
    public RenderBufferStoreAction depthStoreAction { get; public set; }
    public RenderTargetFlags flags { get; public set; }
    public RenderTargetBinding(RenderTargetIdentifier[] colorRenderTargets, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    public RenderTargetBinding(RenderTargetIdentifier colorRenderTarget, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction);
    public RenderTargetBinding(RenderTargetSetup setup);
    public RenderTargetIdentifier[] get_colorRenderTargets();
    public void set_colorRenderTargets(RenderTargetIdentifier[] value);
    public RenderTargetIdentifier get_depthRenderTarget();
    public void set_depthRenderTarget(RenderTargetIdentifier value);
    public RenderBufferLoadAction[] get_colorLoadActions();
    public void set_colorLoadActions(RenderBufferLoadAction[] value);
    public RenderBufferStoreAction[] get_colorStoreActions();
    public void set_colorStoreActions(RenderBufferStoreAction[] value);
    public RenderBufferLoadAction get_depthLoadAction();
    public void set_depthLoadAction(RenderBufferLoadAction value);
    public RenderBufferStoreAction get_depthStoreAction();
    public void set_depthStoreAction(RenderBufferStoreAction value);
    public RenderTargetFlags get_flags();
    public void set_flags(RenderTargetFlags value);
}
public class UnityEngine.Rendering.RenderTargetBlendState : ValueType {
    private byte m_WriteMask;
    private byte m_SourceColorBlendMode;
    private byte m_DestinationColorBlendMode;
    private byte m_SourceAlphaBlendMode;
    private byte m_DestinationAlphaBlendMode;
    private byte m_ColorBlendOperation;
    private byte m_AlphaBlendOperation;
    private byte m_Padding;
    public static RenderTargetBlendState defaultValue { get; }
    public ColorWriteMask writeMask { get; public set; }
    public BlendMode sourceColorBlendMode { get; public set; }
    public BlendMode destinationColorBlendMode { get; public set; }
    public BlendMode sourceAlphaBlendMode { get; public set; }
    public BlendMode destinationAlphaBlendMode { get; public set; }
    public BlendOp colorBlendOperation { get; public set; }
    public BlendOp alphaBlendOperation { get; public set; }
    public RenderTargetBlendState(ColorWriteMask writeMask, BlendMode sourceColorBlendMode, BlendMode destinationColorBlendMode, BlendMode sourceAlphaBlendMode, BlendMode destinationAlphaBlendMode, BlendOp colorBlendOperation, BlendOp alphaBlendOperation);
    public static RenderTargetBlendState get_defaultValue();
    public ColorWriteMask get_writeMask();
    public void set_writeMask(ColorWriteMask value);
    public BlendMode get_sourceColorBlendMode();
    public void set_sourceColorBlendMode(BlendMode value);
    public BlendMode get_destinationColorBlendMode();
    public void set_destinationColorBlendMode(BlendMode value);
    public BlendMode get_sourceAlphaBlendMode();
    public void set_sourceAlphaBlendMode(BlendMode value);
    public BlendMode get_destinationAlphaBlendMode();
    public void set_destinationAlphaBlendMode(BlendMode value);
    public BlendOp get_colorBlendOperation();
    public void set_colorBlendOperation(BlendOp value);
    public BlendOp get_alphaBlendOperation();
    public void set_alphaBlendOperation(BlendOp value);
    public sealed virtual bool Equals(RenderTargetBlendState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RenderTargetBlendState left, RenderTargetBlendState right);
    public static bool op_Inequality(RenderTargetBlendState left, RenderTargetBlendState right);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.RenderTargetFlags : Enum {
    public int value__;
    public static RenderTargetFlags None;
    public static RenderTargetFlags ReadOnlyDepth;
    public static RenderTargetFlags ReadOnlyStencil;
    public static RenderTargetFlags ReadOnlyDepthStencil;
}
public class UnityEngine.Rendering.RenderTargetIdentifier : ValueType {
    public static int AllDepthSlices;
    private BuiltinRenderTextureType m_Type;
    private int m_NameID;
    private int m_InstanceID;
    private IntPtr m_BufferPointer;
    private int m_MipLevel;
    private CubemapFace m_CubeFace;
    private int m_DepthSlice;
    public RenderTargetIdentifier(BuiltinRenderTextureType type);
    public RenderTargetIdentifier(BuiltinRenderTextureType type, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public RenderTargetIdentifier(string name);
    public RenderTargetIdentifier(string name, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public RenderTargetIdentifier(int nameID);
    public RenderTargetIdentifier(int nameID, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public RenderTargetIdentifier(RenderTargetIdentifier renderTargetIdentifier, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public RenderTargetIdentifier(Texture tex);
    public RenderTargetIdentifier(Texture tex, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public RenderTargetIdentifier(RenderBuffer buf, int mipLevel, CubemapFace cubeFace, int depthSlice);
    public static RenderTargetIdentifier op_Implicit(BuiltinRenderTextureType type);
    public static RenderTargetIdentifier op_Implicit(string name);
    public static RenderTargetIdentifier op_Implicit(int nameID);
    public static RenderTargetIdentifier op_Implicit(Texture tex);
    public static RenderTargetIdentifier op_Implicit(RenderBuffer buf);
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RenderTargetIdentifier rhs);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs);
    public static bool op_Inequality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs);
}
public enum UnityEngine.Rendering.RenderTextureSubElement : Enum {
    public int value__;
    public static RenderTextureSubElement Color;
    public static RenderTextureSubElement Depth;
    public static RenderTextureSubElement Stencil;
    public static RenderTextureSubElement Default;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.RTClearFlags : Enum {
    public int value__;
    public static RTClearFlags None;
    public static RTClearFlags Color;
    public static RTClearFlags Depth;
    public static RTClearFlags Stencil;
    public static RTClearFlags All;
    public static RTClearFlags DepthStencil;
    public static RTClearFlags ColorDepth;
    public static RTClearFlags ColorStencil;
}
public class UnityEngine.Rendering.ScopedRenderPass : ValueType {
    private ScriptableRenderContext m_Context;
    internal ScopedRenderPass(ScriptableRenderContext context);
    public sealed virtual void Dispose();
}
public class UnityEngine.Rendering.ScopedSubPass : ValueType {
    private ScriptableRenderContext m_Context;
    internal ScopedSubPass(ScriptableRenderContext context);
    public sealed virtual void Dispose();
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.ScriptableCullingParameters : ValueType {
    private int m_IsOrthographic;
    private LODParameters m_LODParameters;
    private static int k_MaximumCullingPlaneCount;
    public static int maximumCullingPlaneCount;
    [FixedBufferAttribute("System.Byte", "160")]
internal <m_CullingPlanes>e__FixedBuffer m_CullingPlanes;
    private int m_CullingPlaneCount;
    private UInt32 m_CullingMask;
    private ulong m_SceneMask;
    private ulong m_ViewID;
    private static int k_LayerCount;
    public static int layerCount;
    [FixedBufferAttribute("System.Single", "32")]
internal <m_LayerFarCullDistances>e__FixedBuffer m_LayerFarCullDistances;
    private int m_LayerCull;
    private Matrix4x4 m_CullingMatrix;
    private Vector3 m_Origin;
    private float m_ShadowDistance;
    private float m_ShadowNearPlaneOffset;
    private CullingOptions m_CullingOptions;
    private ReflectionProbeSortingCriteria m_ReflectionProbeSortingCriteria;
    private CameraProperties m_CameraProperties;
    private float m_AccurateOcclusionThreshold;
    private int m_MaximumPortalCullingJobs;
    private static int k_CullingJobCountLowerLimit;
    private static int k_CullingJobCountUpperLimit;
    private Matrix4x4 m_StereoViewMatrix;
    private Matrix4x4 m_StereoProjectionMatrix;
    private float m_StereoSeparationDistance;
    private int m_maximumVisibleLights;
    private bool m_ConservativeEnclosingSphere;
    private int m_NumIterationsEnclosingSphere;
    public int maximumVisibleLights { get; public set; }
    public bool conservativeEnclosingSphere { get; public set; }
    public int numIterationsEnclosingSphere { get; public set; }
    public int cullingPlaneCount { get; public set; }
    public bool isOrthographic { get; public set; }
    public LODParameters lodParameters { get; public set; }
    public UInt32 cullingMask { get; public set; }
    public Matrix4x4 cullingMatrix { get; public set; }
    public Vector3 origin { get; public set; }
    public float shadowDistance { get; public set; }
    public float shadowNearPlaneOffset { get; public set; }
    public CullingOptions cullingOptions { get; public set; }
    public ReflectionProbeSortingCriteria reflectionProbeSortingCriteria { get; public set; }
    public CameraProperties cameraProperties { get; public set; }
    public Matrix4x4 stereoViewMatrix { get; public set; }
    public Matrix4x4 stereoProjectionMatrix { get; public set; }
    public float stereoSeparationDistance { get; public set; }
    public float accurateOcclusionThreshold { get; public set; }
    public int maximumPortalCullingJobs { get; public set; }
    public static int cullingJobsLowerLimit { get; }
    public static int cullingJobsUpperLimit { get; }
    private static ScriptableCullingParameters();
    public int get_maximumVisibleLights();
    public void set_maximumVisibleLights(int value);
    public bool get_conservativeEnclosingSphere();
    public void set_conservativeEnclosingSphere(bool value);
    public int get_numIterationsEnclosingSphere();
    public void set_numIterationsEnclosingSphere(int value);
    public int get_cullingPlaneCount();
    public void set_cullingPlaneCount(int value);
    public bool get_isOrthographic();
    public void set_isOrthographic(bool value);
    public LODParameters get_lodParameters();
    public void set_lodParameters(LODParameters value);
    public UInt32 get_cullingMask();
    public void set_cullingMask(UInt32 value);
    public Matrix4x4 get_cullingMatrix();
    public void set_cullingMatrix(Matrix4x4 value);
    public Vector3 get_origin();
    public void set_origin(Vector3 value);
    public float get_shadowDistance();
    public void set_shadowDistance(float value);
    public float get_shadowNearPlaneOffset();
    public void set_shadowNearPlaneOffset(float value);
    public CullingOptions get_cullingOptions();
    public void set_cullingOptions(CullingOptions value);
    public ReflectionProbeSortingCriteria get_reflectionProbeSortingCriteria();
    public void set_reflectionProbeSortingCriteria(ReflectionProbeSortingCriteria value);
    public CameraProperties get_cameraProperties();
    public void set_cameraProperties(CameraProperties value);
    public Matrix4x4 get_stereoViewMatrix();
    public void set_stereoViewMatrix(Matrix4x4 value);
    public Matrix4x4 get_stereoProjectionMatrix();
    public void set_stereoProjectionMatrix(Matrix4x4 value);
    public float get_stereoSeparationDistance();
    public void set_stereoSeparationDistance(float value);
    public float get_accurateOcclusionThreshold();
    public void set_accurateOcclusionThreshold(float value);
    public int get_maximumPortalCullingJobs();
    public void set_maximumPortalCullingJobs(int value);
    public static int get_cullingJobsLowerLimit();
    public static int get_cullingJobsUpperLimit();
    public float GetLayerCullingDistance(int layerIndex);
    public void SetLayerCullingDistance(int layerIndex, float distance);
    public Plane GetCullingPlane(int index);
    public void SetCullingPlane(int index, Plane plane);
    public sealed virtual bool Equals(ScriptableCullingParameters other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScriptableCullingParameters left, ScriptableCullingParameters right);
    public static bool op_Inequality(ScriptableCullingParameters left, ScriptableCullingParameters right);
}
[NativeHeaderAttribute("Modules/UI/CanvasManager.h")]
[NativeHeaderAttribute("Runtime/Export/RenderPipeline/ScriptableRenderPipeline.bindings.h")]
[NativeHeaderAttribute("Runtime/Export/RenderPipeline/ScriptableRenderContext.bindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/ScriptableRenderLoop/ScriptableDrawRenderersUtility.h")]
[NativeTypeAttribute("Runtime/Graphics/ScriptableRenderLoop/ScriptableRenderContext.h")]
[NativeHeaderAttribute("Modules/UI/Canvas.h")]
public class UnityEngine.Rendering.ScriptableRenderContext : ValueType {
    private static ShaderTagId kRenderTypeTag;
    private IntPtr m_Ptr;
    internal ScriptableRenderContext(IntPtr ptr);
    private static ScriptableRenderContext();
    [FreeFunctionAttribute("ScriptableRenderContext::BeginRenderPass")]
private static void BeginRenderPass_Internal(IntPtr self, int width, int height, int volumeDepth, int samples, IntPtr colors, int colorCount, int depthAttachmentIndex);
    [FreeFunctionAttribute("ScriptableRenderContext::BeginSubPass")]
private static void BeginSubPass_Internal(IntPtr self, IntPtr colors, int colorCount, IntPtr inputs, int inputCount, bool isDepthReadOnly, bool isStencilReadOnly);
    [FreeFunctionAttribute("ScriptableRenderContext::EndSubPass")]
private static void EndSubPass_Internal(IntPtr self);
    [FreeFunctionAttribute("ScriptableRenderContext::EndRenderPass")]
private static void EndRenderPass_Internal(IntPtr self);
    [FreeFunctionAttribute("ScriptableRenderPipeline_Bindings::Internal_Cull")]
private static void Internal_Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext renderLoop, IntPtr results);
    [FreeFunctionAttribute("InitializeSortSettings")]
internal static void InitializeSortSettings(Camera camera, SortingSettings& sortingSettings);
    private void Submit_Internal();
    private bool SubmitForRenderPassValidation_Internal();
    private void GetCameras_Internal(Type listType, object resultList);
    private void DrawRenderers_Internal(IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount);
    private void DrawShadows_Internal(IntPtr shadowDrawingSettings);
    [FreeFunctionAttribute("PlayerEmitCanvasGeometryForCamera")]
public static void EmitGeometryForCamera(Camera camera);
    [NativeThrowsAttribute]
private void ExecuteCommandBuffer_Internal(CommandBuffer commandBuffer);
    [NativeThrowsAttribute]
private void ExecuteCommandBufferAsync_Internal(CommandBuffer commandBuffer, ComputeQueueType queueType);
    private void SetupCameraProperties_Internal(Camera camera, bool stereoSetup, int eye);
    private void StereoEndRender_Internal(Camera camera, int eye, bool isFinalPass);
    private void StartMultiEye_Internal(Camera camera, int eye);
    private void StopMultiEye_Internal(Camera camera);
    private void DrawSkybox_Internal(Camera camera);
    private void InvokeOnRenderObjectCallback_Internal();
    private void DrawGizmos_Internal(Camera camera, GizmoSubset gizmoSubset);
    private void DrawWireOverlay_Impl(Camera camera);
    private void DrawUIOverlay_Internal(Camera camera);
    internal IntPtr Internal_GetPtr();
    private RendererList CreateRendererList_Internal(IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount);
    private RendererList CreateShadowRendererList_Internal(IntPtr shadowDrawinSettings);
    private RendererList CreateSkyboxRendererList_Internal(Camera camera, int mode, Matrix4x4 proj, Matrix4x4 view, Matrix4x4 projR, Matrix4x4 viewR);
    private void PrepareRendererListsAsync_Internal(object rendererLists);
    private RendererListStatus QueryRendererListStatus_Internal(RendererList handle);
    public void BeginRenderPass(int width, int height, int volumeDepth, int samples, NativeArray`1<AttachmentDescriptor> attachments, int depthAttachmentIndex);
    public void BeginRenderPass(int width, int height, int samples, NativeArray`1<AttachmentDescriptor> attachments, int depthAttachmentIndex);
    public ScopedRenderPass BeginScopedRenderPass(int width, int height, int samples, NativeArray`1<AttachmentDescriptor> attachments, int depthAttachmentIndex);
    public void BeginSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly);
    public void BeginSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthStencilReadOnly);
    public void BeginSubPass(NativeArray`1<int> colors, bool isDepthReadOnly, bool isStencilReadOnly);
    public void BeginSubPass(NativeArray`1<int> colors, bool isDepthStencilReadOnly);
    public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly);
    public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthStencilReadOnly);
    public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, bool isDepthReadOnly, bool isStencilReadOnly);
    public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, bool isDepthStencilReadOnly);
    public void EndSubPass();
    public void EndRenderPass();
    public void Submit();
    public bool SubmitForRenderPassValidation();
    internal void GetCameras(List`1<Camera> results);
    public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings);
    public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, RenderStateBlock& stateBlock);
    public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, NativeArray`1<ShaderTagId> renderTypes, NativeArray`1<RenderStateBlock> stateBlocks);
    public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, NativeArray`1<ShaderTagId> tagValues, NativeArray`1<RenderStateBlock> stateBlocks);
    public void DrawShadows(ShadowDrawingSettings& settings);
    public void ExecuteCommandBuffer(CommandBuffer commandBuffer);
    public void ExecuteCommandBufferAsync(CommandBuffer commandBuffer, ComputeQueueType queueType);
    public void SetupCameraProperties(Camera camera, bool stereoSetup);
    public void SetupCameraProperties(Camera camera, bool stereoSetup, int eye);
    public void StereoEndRender(Camera camera);
    public void StereoEndRender(Camera camera, int eye);
    public void StereoEndRender(Camera camera, int eye, bool isFinalPass);
    public void StartMultiEye(Camera camera);
    public void StartMultiEye(Camera camera, int eye);
    public void StopMultiEye(Camera camera);
    public void DrawSkybox(Camera camera);
    public void InvokeOnRenderObjectCallback();
    public void DrawGizmos(Camera camera, GizmoSubset gizmoSubset);
    public void DrawWireOverlay(Camera camera);
    public void DrawUIOverlay(Camera camera);
    public CullingResults Cull(ScriptableCullingParameters& parameters);
    [ConditionalAttribute("ENABLE_UNITY_COLLECTIONS_CHECKS")]
internal void Validate();
    public sealed virtual bool Equals(ScriptableRenderContext other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScriptableRenderContext left, ScriptableRenderContext right);
    public static bool op_Inequality(ScriptableRenderContext left, ScriptableRenderContext right);
    public RendererList CreateRendererList(RendererListDesc desc);
    public RendererList CreateRendererList(RendererListParams& param);
    public RendererList CreateShadowRendererList(ShadowDrawingSettings& settings);
    public RendererList CreateSkyboxRendererList(Camera camera, Matrix4x4 projectionMatrixL, Matrix4x4 viewMatrixL, Matrix4x4 projectionMatrixR, Matrix4x4 viewMatrixR);
    public RendererList CreateSkyboxRendererList(Camera camera, Matrix4x4 projectionMatrix, Matrix4x4 viewMatrix);
    public RendererList CreateSkyboxRendererList(Camera camera);
    public void PrepareRendererListsAsync(List`1<RendererList> rendererLists);
    public RendererListStatus QueryRendererListStatus(RendererList rendererList);
    private static void Internal_Cull_Injected(ScriptableCullingParameters& parameters, ScriptableRenderContext& renderLoop, IntPtr results);
    private static void Submit_Internal_Injected(ScriptableRenderContext& _unity_self);
    private static bool SubmitForRenderPassValidation_Internal_Injected(ScriptableRenderContext& _unity_self);
    private static void GetCameras_Internal_Injected(ScriptableRenderContext& _unity_self, Type listType, object resultList);
    private static void DrawRenderers_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId& tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount);
    private static void DrawShadows_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr shadowDrawingSettings);
    private static void ExecuteCommandBuffer_Internal_Injected(ScriptableRenderContext& _unity_self, CommandBuffer commandBuffer);
    private static void ExecuteCommandBufferAsync_Internal_Injected(ScriptableRenderContext& _unity_self, CommandBuffer commandBuffer, ComputeQueueType queueType);
    private static void SetupCameraProperties_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, bool stereoSetup, int eye);
    private static void StereoEndRender_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, int eye, bool isFinalPass);
    private static void StartMultiEye_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, int eye);
    private static void StopMultiEye_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera);
    private static void DrawSkybox_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera);
    private static void InvokeOnRenderObjectCallback_Internal_Injected(ScriptableRenderContext& _unity_self);
    private static void DrawGizmos_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, GizmoSubset gizmoSubset);
    private static void DrawWireOverlay_Impl_Injected(ScriptableRenderContext& _unity_self, Camera camera);
    private static void DrawUIOverlay_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera);
    private static void CreateRendererList_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId& tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount, RendererList& ret);
    private static void CreateShadowRendererList_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr shadowDrawinSettings, RendererList& ret);
    private static void CreateSkyboxRendererList_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, int mode, Matrix4x4& proj, Matrix4x4& view, Matrix4x4& projR, Matrix4x4& viewR, RendererList& ret);
    private static void PrepareRendererListsAsync_Internal_Injected(ScriptableRenderContext& _unity_self, object rendererLists);
    private static RendererListStatus QueryRendererListStatus_Internal_Injected(ScriptableRenderContext& _unity_self, RendererList& handle);
}
public enum UnityEngine.Rendering.ShaderConstantType : Enum {
    public int value__;
    public static ShaderConstantType Vector;
    public static ShaderConstantType Matrix;
    public static ShaderConstantType Struct;
}
[ObsoleteAttribute("ShaderHardwareTier was renamed to GraphicsTier (UnityUpgradable) -> GraphicsTier", "False")]
public enum UnityEngine.Rendering.ShaderHardwareTier : Enum {
    public int value__;
    public static ShaderHardwareTier Tier1;
    public static ShaderHardwareTier Tier2;
    public static ShaderHardwareTier Tier3;
}
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.ShaderKeyword : ValueType {
    internal string m_Name;
    internal UInt32 m_Index;
    internal bool m_IsLocal;
    internal bool m_IsCompute;
    internal bool m_IsValid;
    public string name { get; }
    public int index { get; }
    public ShaderKeyword(string keywordName);
    public ShaderKeyword(Shader shader, string keywordName);
    public ShaderKeyword(ComputeShader shader, string keywordName);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalKeywordCount")]
internal static UInt32 GetGlobalKeywordCount();
    [FreeFunctionAttribute("ShaderScripting::GetGlobalKeywordIndex")]
internal static UInt32 GetGlobalKeywordIndex(string keyword);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordCount")]
internal static UInt32 GetKeywordCount(Shader shader);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordIndex")]
internal static UInt32 GetKeywordIndex(Shader shader, string keyword);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordCount")]
internal static UInt32 GetComputeShaderKeywordCount(ComputeShader shader);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordIndex")]
internal static UInt32 GetComputeShaderKeywordIndex(ComputeShader shader, string keyword);
    [FreeFunctionAttribute("ShaderScripting::CreateGlobalKeyword")]
internal static void CreateGlobalKeyword(string keyword);
    [FreeFunctionAttribute("ShaderScripting::GetKeywordType")]
internal static ShaderKeywordType GetGlobalShaderKeywordType(UInt32 keyword);
    public string get_name();
    public static ShaderKeywordType GetGlobalKeywordType(ShaderKeyword index);
    public static bool IsKeywordLocal(ShaderKeyword keyword);
    public bool IsValid();
    public bool IsValid(ComputeShader shader);
    public bool IsValid(Shader shader);
    public int get_index();
    public virtual string ToString();
    [ObsoleteAttribute("GetKeywordType is deprecated. Only global keywords can have a type. This method always returns ShaderKeywordType.UserDefined.")]
public static ShaderKeywordType GetKeywordType(Shader shader, ShaderKeyword index);
    [ObsoleteAttribute("GetKeywordType is deprecated. Only global keywords can have a type. This method always returns ShaderKeywordType.UserDefined.")]
public static ShaderKeywordType GetKeywordType(ComputeShader shader, ShaderKeyword index);
    [ObsoleteAttribute("GetGlobalKeywordName is deprecated. Use the ShaderKeyword.name property instead.")]
public static string GetGlobalKeywordName(ShaderKeyword index);
    [ObsoleteAttribute("GetKeywordName is deprecated. Use the ShaderKeyword.name property instead.")]
public static string GetKeywordName(Shader shader, ShaderKeyword index);
    [ObsoleteAttribute("GetKeywordName is deprecated. Use the ShaderKeyword.name property instead.")]
public static string GetKeywordName(ComputeShader shader, ShaderKeyword index);
    [ObsoleteAttribute("GetKeywordType is deprecated. Use ShaderKeyword.name instead.")]
public ShaderKeywordType GetKeywordType();
    [ObsoleteAttribute("GetKeywordName is deprecated. Use ShaderKeyword.name instead.")]
public string GetKeywordName();
    [ObsoleteAttribute("GetName() has been deprecated. Use ShaderKeyword.name instead.")]
public string GetName();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Editor/Src/Graphics/ShaderCompilerData.h")]
public class UnityEngine.Rendering.ShaderKeywordSet : ValueType {
    private IntPtr m_KeywordState;
    private IntPtr m_Shader;
    private IntPtr m_ComputeShader;
    private ulong m_StateIndex;
    [FreeFunctionAttribute("keywords::IsKeywordEnabled")]
private static bool IsGlobalKeywordEnabled(ShaderKeywordSet state, UInt32 index);
    [FreeFunctionAttribute("keywords::IsKeywordEnabled")]
private static bool IsKeywordEnabled(ShaderKeywordSet state, LocalKeywordSpace keywordSpace, UInt32 index);
    [FreeFunctionAttribute("keywords::IsKeywordEnabled")]
private static bool IsKeywordNameEnabled(ShaderKeywordSet state, string name);
    [FreeFunctionAttribute("keywords::EnableKeyword")]
private static void EnableGlobalKeyword(ShaderKeywordSet state, UInt32 index);
    [FreeFunctionAttribute("keywords::EnableKeyword")]
private static void EnableKeywordName(ShaderKeywordSet state, string name);
    [FreeFunctionAttribute("keywords::DisableKeyword")]
private static void DisableGlobalKeyword(ShaderKeywordSet state, UInt32 index);
    [FreeFunctionAttribute("keywords::DisableKeyword")]
private static void DisableKeywordName(ShaderKeywordSet state, string name);
    [FreeFunctionAttribute("keywords::GetEnabledKeywords")]
private static ShaderKeyword[] GetEnabledKeywords(ShaderKeywordSet state);
    private void CheckKeywordCompatible(ShaderKeyword keyword);
    public bool IsEnabled(ShaderKeyword keyword);
    public bool IsEnabled(GlobalKeyword keyword);
    public bool IsEnabled(LocalKeyword keyword);
    public void Enable(ShaderKeyword keyword);
    public void Disable(ShaderKeyword keyword);
    public ShaderKeyword[] GetShaderKeywords();
    private static bool IsGlobalKeywordEnabled_Injected(ShaderKeywordSet& state, UInt32 index);
    private static bool IsKeywordEnabled_Injected(ShaderKeywordSet& state, LocalKeywordSpace& keywordSpace, UInt32 index);
    private static bool IsKeywordNameEnabled_Injected(ShaderKeywordSet& state, string name);
    private static void EnableGlobalKeyword_Injected(ShaderKeywordSet& state, UInt32 index);
    private static void EnableKeywordName_Injected(ShaderKeywordSet& state, string name);
    private static void DisableGlobalKeyword_Injected(ShaderKeywordSet& state, UInt32 index);
    private static void DisableKeywordName_Injected(ShaderKeywordSet& state, string name);
    private static ShaderKeyword[] GetEnabledKeywords_Injected(ShaderKeywordSet& state);
}
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
[UsedByNativeCodeAttribute]
public enum UnityEngine.Rendering.ShaderKeywordType : Enum {
    public int value__;
    public static ShaderKeywordType None;
    public static ShaderKeywordType BuiltinDefault;
    [ObsoleteAttribute("Shader keyword type BuiltinExtra is no longer used. Use BuiltinDefault instead. (UnityUpgradable) -> BuiltinDefault")]
public static ShaderKeywordType BuiltinExtra;
    [ObsoleteAttribute("Shader keyword type BuiltinAutoStripped is no longer used. Use BuiltinDefault instead. (UnityUpgradable) -> BuiltinDefault")]
public static ShaderKeywordType BuiltinAutoStripped;
    public static ShaderKeywordType UserDefined;
    public static ShaderKeywordType Plugin;
}
public enum UnityEngine.Rendering.ShaderParamType : Enum {
    public int value__;
    public static ShaderParamType Float;
    public static ShaderParamType Int;
    public static ShaderParamType Bool;
    public static ShaderParamType Half;
    public static ShaderParamType Short;
    public static ShaderParamType UInt;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.ShaderPropertyFlags : Enum {
    public int value__;
    public static ShaderPropertyFlags None;
    public static ShaderPropertyFlags HideInInspector;
    public static ShaderPropertyFlags PerRendererData;
    public static ShaderPropertyFlags NoScaleOffset;
    public static ShaderPropertyFlags Normal;
    public static ShaderPropertyFlags HDR;
    public static ShaderPropertyFlags Gamma;
    public static ShaderPropertyFlags NonModifiableTextureData;
    public static ShaderPropertyFlags MainTexture;
    public static ShaderPropertyFlags MainColor;
}
public enum UnityEngine.Rendering.ShaderPropertyType : Enum {
    public int value__;
    public static ShaderPropertyType Color;
    public static ShaderPropertyType Vector;
    public static ShaderPropertyType Float;
    public static ShaderPropertyType Range;
    public static ShaderPropertyType Texture;
    public static ShaderPropertyType Int;
}
public class UnityEngine.Rendering.ShaderTagId : ValueType {
    public static ShaderTagId none;
    private int m_Id;
    internal int id { get; internal set; }
    public string name { get; }
    public ShaderTagId(string name);
    internal int get_id();
    internal void set_id(int value);
    public string get_name();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ShaderTagId other);
    public virtual int GetHashCode();
    public static bool op_Equality(ShaderTagId tag1, ShaderTagId tag2);
    public static bool op_Inequality(ShaderTagId tag1, ShaderTagId tag2);
    public static ShaderTagId op_Explicit(string name);
    public static string op_Explicit(ShaderTagId tagId);
}
public enum UnityEngine.Rendering.ShadowCastingMode : Enum {
    public int value__;
    public static ShadowCastingMode Off;
    public static ShadowCastingMode On;
    public static ShadowCastingMode TwoSided;
    public static ShadowCastingMode ShadowsOnly;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.ShadowDrawingSettings : ValueType {
    private CullingResults m_CullingResults;
    private int m_LightIndex;
    private int m_UseRenderingLayerMaskTest;
    private ShadowSplitData m_SplitData;
    private ShadowObjectsFilter m_ObjectsFilter;
    private BatchCullingProjectionType m_ProjectionType;
    public CullingResults cullingResults { get; public set; }
    public int lightIndex { get; public set; }
    public bool useRenderingLayerMaskTest { get; public set; }
    public ShadowSplitData splitData { get; public set; }
    public ShadowObjectsFilter objectsFilter { get; public set; }
    public BatchCullingProjectionType projectionType { get; public set; }
    [ObsoleteAttribute("ShadowDrawingSettings(CullingResults, int) is deprecated. Use ShadowDrawingSettings(CullingResults, int, BatchCullingProjectionType) instead.")]
public ShadowDrawingSettings(CullingResults cullingResults, int lightIndex);
    public ShadowDrawingSettings(CullingResults cullingResults, int lightIndex, BatchCullingProjectionType projectionType);
    public CullingResults get_cullingResults();
    public void set_cullingResults(CullingResults value);
    public int get_lightIndex();
    public void set_lightIndex(int value);
    public bool get_useRenderingLayerMaskTest();
    public void set_useRenderingLayerMaskTest(bool value);
    public ShadowSplitData get_splitData();
    public void set_splitData(ShadowSplitData value);
    public ShadowObjectsFilter get_objectsFilter();
    public void set_objectsFilter(ShadowObjectsFilter value);
    public BatchCullingProjectionType get_projectionType();
    public void set_projectionType(BatchCullingProjectionType value);
    public sealed virtual bool Equals(ShadowDrawingSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ShadowDrawingSettings left, ShadowDrawingSettings right);
    public static bool op_Inequality(ShadowDrawingSettings left, ShadowDrawingSettings right);
}
[FlagsAttribute]
public enum UnityEngine.Rendering.ShadowMapPass : Enum {
    public int value__;
    public static ShadowMapPass PointlightPositiveX;
    public static ShadowMapPass PointlightNegativeX;
    public static ShadowMapPass PointlightPositiveY;
    public static ShadowMapPass PointlightNegativeY;
    public static ShadowMapPass PointlightPositiveZ;
    public static ShadowMapPass PointlightNegativeZ;
    public static ShadowMapPass DirectionalCascade0;
    public static ShadowMapPass DirectionalCascade1;
    public static ShadowMapPass DirectionalCascade2;
    public static ShadowMapPass DirectionalCascade3;
    public static ShadowMapPass Spotlight;
    public static ShadowMapPass Pointlight;
    public static ShadowMapPass Directional;
    public static ShadowMapPass All;
}
public enum UnityEngine.Rendering.ShadowSamplingMode : Enum {
    public int value__;
    public static ShadowSamplingMode CompareDepths;
    public static ShadowSamplingMode RawDepth;
    public static ShadowSamplingMode None;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.ShadowSplitData : ValueType {
    private static int k_MaximumCullingPlaneCount;
    public static int maximumCullingPlaneCount;
    private int m_CullingPlaneCount;
    [FixedBufferAttribute("System.Byte", "160")]
internal <m_CullingPlanes>e__FixedBuffer m_CullingPlanes;
    private Vector4 m_CullingSphere;
    private float m_ShadowCascadeBlendCullingFactor;
    private float m_CullingNearPlane;
    private Matrix4x4 m_CullingMatrix;
    public int cullingPlaneCount { get; public set; }
    public Vector4 cullingSphere { get; public set; }
    public Matrix4x4 cullingMatrix { get; public set; }
    public float cullingNearPlane { get; public set; }
    public float shadowCascadeBlendCullingFactor { get; public set; }
    private static ShadowSplitData();
    public int get_cullingPlaneCount();
    public void set_cullingPlaneCount(int value);
    public Vector4 get_cullingSphere();
    public void set_cullingSphere(Vector4 value);
    public Matrix4x4 get_cullingMatrix();
    public void set_cullingMatrix(Matrix4x4 value);
    public float get_cullingNearPlane();
    public void set_cullingNearPlane(float value);
    public float get_shadowCascadeBlendCullingFactor();
    public void set_shadowCascadeBlendCullingFactor(float value);
    public Plane GetCullingPlane(int index);
    public void SetCullingPlane(int index, Plane plane);
    public sealed virtual bool Equals(ShadowSplitData other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ShadowSplitData left, ShadowSplitData right);
    public static bool op_Inequality(ShadowSplitData left, ShadowSplitData right);
}
public enum UnityEngine.Rendering.SinglePassStereoMode : Enum {
    public int value__;
    public static SinglePassStereoMode None;
    public static SinglePassStereoMode SideBySide;
    public static SinglePassStereoMode Instancing;
    public static SinglePassStereoMode Multiview;
}
[FlagsAttribute]
public enum UnityEngine.Rendering.SortingCriteria : Enum {
    public int value__;
    public static SortingCriteria None;
    public static SortingCriteria SortingLayer;
    public static SortingCriteria RenderQueue;
    public static SortingCriteria BackToFront;
    public static SortingCriteria QuantizedFrontToBack;
    public static SortingCriteria OptimizeStateChanges;
    public static SortingCriteria CanvasOrder;
    public static SortingCriteria RendererPriority;
    public static SortingCriteria CommonOpaque;
    public static SortingCriteria CommonTransparent;
}
[RequireComponent("UnityEngine.Transform")]
[NativeTypeAttribute]
public class UnityEngine.Rendering.SortingGroup : Behaviour {
    [StaticAccessorAttribute("SortingGroup", "2")]
internal static int invalidSortingGroupID { get; }
    public string sortingLayerName { get; public set; }
    public int sortingLayerID { get; public set; }
    public int sortingOrder { get; public set; }
    public bool sortAtRoot { get; public set; }
    internal int sortingGroupID { get; }
    internal int sortingGroupOrder { get; }
    internal int index { get; }
    internal UInt32 sortingKey { get; }
    internal static int get_invalidSortingGroupID();
    [StaticAccessorAttribute("SortingGroup", "2")]
public static void UpdateAllSortingGroups();
    [StaticAccessorAttribute("SortingGroup", "2")]
internal static SortingGroup GetSortingGroupByIndex(int index);
    public string get_sortingLayerName();
    public void set_sortingLayerName(string value);
    public int get_sortingLayerID();
    public void set_sortingLayerID(int value);
    public int get_sortingOrder();
    public void set_sortingOrder(int value);
    public bool get_sortAtRoot();
    public void set_sortAtRoot(bool value);
    internal int get_sortingGroupID();
    internal int get_sortingGroupOrder();
    internal int get_index();
    internal UInt32 get_sortingKey();
}
public class UnityEngine.Rendering.SortingLayerRange : ValueType {
    private short m_LowerBound;
    private short m_UpperBound;
    public short lowerBound { get; public set; }
    public short upperBound { get; public set; }
    public static SortingLayerRange all { get; }
    public SortingLayerRange(short lowerBound, short upperBound);
    public short get_lowerBound();
    public void set_lowerBound(short value);
    public short get_upperBound();
    public void set_upperBound(short value);
    public static SortingLayerRange get_all();
    public sealed virtual bool Equals(SortingLayerRange other);
    public virtual bool Equals(object obj);
    public static bool op_Inequality(SortingLayerRange lhs, SortingLayerRange rhs);
    public static bool op_Equality(SortingLayerRange lhs, SortingLayerRange rhs);
    public virtual int GetHashCode();
}
public class UnityEngine.Rendering.SortingSettings : ValueType {
    private Matrix4x4 m_WorldToCameraMatrix;
    private Vector3 m_CameraPosition;
    private Vector3 m_CustomAxis;
    private SortingCriteria m_Criteria;
    private DistanceMetric m_DistanceMetric;
    public Matrix4x4 worldToCameraMatrix { get; public set; }
    public Vector3 cameraPosition { get; public set; }
    public Vector3 customAxis { get; public set; }
    public SortingCriteria criteria { get; public set; }
    public DistanceMetric distanceMetric { get; public set; }
    public SortingSettings(Camera camera);
    public Matrix4x4 get_worldToCameraMatrix();
    public void set_worldToCameraMatrix(Matrix4x4 value);
    public Vector3 get_cameraPosition();
    public void set_cameraPosition(Vector3 value);
    public Vector3 get_customAxis();
    public void set_customAxis(Vector3 value);
    public SortingCriteria get_criteria();
    public void set_criteria(SortingCriteria value);
    public DistanceMetric get_distanceMetric();
    public void set_distanceMetric(DistanceMetric value);
    public sealed virtual bool Equals(SortingSettings other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SortingSettings left, SortingSettings right);
    public static bool op_Inequality(SortingSettings left, SortingSettings right);
}
[NativeHeaderAttribute("Runtime/Export/Math/SphericalHarmonicsL2.bindings.h")]
[DefaultMemberAttribute("Item")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.SphericalHarmonicsL2 : ValueType {
    private float shr0;
    private float shr1;
    private float shr2;
    private float shr3;
    private float shr4;
    private float shr5;
    private float shr6;
    private float shr7;
    private float shr8;
    private float shg0;
    private float shg1;
    private float shg2;
    private float shg3;
    private float shg4;
    private float shg5;
    private float shg6;
    private float shg7;
    private float shg8;
    private float shb0;
    private float shb1;
    private float shb2;
    private float shb3;
    private float shb4;
    private float shb5;
    private float shb6;
    private float shb7;
    private float shb8;
    public float Item { get; public set; }
    public void Clear();
    private void SetZero();
    public void AddAmbientLight(Color color);
    public void AddDirectionalLight(Vector3 direction, Color color, float intensity);
    [FreeFunctionAttribute]
private static void AddDirectionalLightInternal(SphericalHarmonicsL2& sh, Vector3 direction, Color color);
    public void Evaluate(Vector3[] directions, Color[] results);
    [FreeFunctionAttribute]
private static void EvaluateInternal(SphericalHarmonicsL2& sh, Vector3[] directions, Color[] results);
    public float get_Item(int rgb, int coefficient);
    public void set_Item(int rgb, int coefficient, float value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(SphericalHarmonicsL2 other);
    public static SphericalHarmonicsL2 op_Multiply(SphericalHarmonicsL2 lhs, float rhs);
    public static SphericalHarmonicsL2 op_Multiply(float lhs, SphericalHarmonicsL2 rhs);
    public static SphericalHarmonicsL2 op_Addition(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
    public static bool op_Equality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
    public static bool op_Inequality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs);
    private static void SetZero_Injected(SphericalHarmonicsL2& _unity_self);
    private static void AddAmbientLight_Injected(SphericalHarmonicsL2& _unity_self, Color& color);
    private static void AddDirectionalLightInternal_Injected(SphericalHarmonicsL2& sh, Vector3& direction, Color& color);
}
[NativeHeaderAttribute("Runtime/Graphics/DrawSplashScreenAndWatermarks.h")]
public class UnityEngine.Rendering.SplashScreen : object {
    public static bool isFinished { get; }
    [FreeFunctionAttribute("IsSplashScreenFinished")]
public static bool get_isFinished();
    [FreeFunctionAttribute]
private static void CancelSplashScreen();
    [FreeFunctionAttribute]
private static void BeginSplashScreenFade();
    [FreeFunctionAttribute("BeginSplashScreen_Binding")]
public static void Begin();
    public static void Stop(StopBehavior stopBehavior);
    [FreeFunctionAttribute("DrawSplashScreen_Binding")]
public static void Draw();
    [FreeFunctionAttribute("SetSplashScreenTime")]
internal static void SetTime(float time);
}
[NativeHeaderAttribute("Runtime/GfxDevice/GfxDeviceTypes.h")]
public enum UnityEngine.Rendering.StencilOp : Enum {
    public int value__;
    public static StencilOp Keep;
    public static StencilOp Zero;
    public static StencilOp Replace;
    public static StencilOp IncrementSaturate;
    public static StencilOp DecrementSaturate;
    public static StencilOp Invert;
    public static StencilOp IncrementWrap;
    public static StencilOp DecrementWrap;
}
public class UnityEngine.Rendering.StencilState : ValueType {
    private byte m_Enabled;
    private byte m_ReadMask;
    private byte m_WriteMask;
    private byte m_Padding;
    private byte m_CompareFunctionFront;
    private byte m_PassOperationFront;
    private byte m_FailOperationFront;
    private byte m_ZFailOperationFront;
    private byte m_CompareFunctionBack;
    private byte m_PassOperationBack;
    private byte m_FailOperationBack;
    private byte m_ZFailOperationBack;
    public static StencilState defaultValue { get; }
    public bool enabled { get; public set; }
    public byte readMask { get; public set; }
    public byte writeMask { get; public set; }
    public CompareFunction compareFunctionFront { get; public set; }
    public StencilOp passOperationFront { get; public set; }
    public StencilOp failOperationFront { get; public set; }
    public StencilOp zFailOperationFront { get; public set; }
    public CompareFunction compareFunctionBack { get; public set; }
    public StencilOp passOperationBack { get; public set; }
    public StencilOp failOperationBack { get; public set; }
    public StencilOp zFailOperationBack { get; public set; }
    public StencilState(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunction, StencilOp passOperation, StencilOp failOperation, StencilOp zFailOperation);
    public StencilState(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunctionFront, StencilOp passOperationFront, StencilOp failOperationFront, StencilOp zFailOperationFront, CompareFunction compareFunctionBack, StencilOp passOperationBack, StencilOp failOperationBack, StencilOp zFailOperationBack);
    public static StencilState get_defaultValue();
    public bool get_enabled();
    public void set_enabled(bool value);
    public byte get_readMask();
    public void set_readMask(byte value);
    public byte get_writeMask();
    public void set_writeMask(byte value);
    public void SetCompareFunction(CompareFunction value);
    public void SetPassOperation(StencilOp value);
    public void SetFailOperation(StencilOp value);
    public void SetZFailOperation(StencilOp value);
    public CompareFunction get_compareFunctionFront();
    public void set_compareFunctionFront(CompareFunction value);
    public StencilOp get_passOperationFront();
    public void set_passOperationFront(StencilOp value);
    public StencilOp get_failOperationFront();
    public void set_failOperationFront(StencilOp value);
    public StencilOp get_zFailOperationFront();
    public void set_zFailOperationFront(StencilOp value);
    public CompareFunction get_compareFunctionBack();
    public void set_compareFunctionBack(CompareFunction value);
    public StencilOp get_passOperationBack();
    public void set_passOperationBack(StencilOp value);
    public StencilOp get_failOperationBack();
    public void set_failOperationBack(StencilOp value);
    public StencilOp get_zFailOperationBack();
    public void set_zFailOperationBack(StencilOp value);
    public sealed virtual bool Equals(StencilState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StencilState left, StencilState right);
    public static bool op_Inequality(StencilState left, StencilState right);
}
public class UnityEngine.Rendering.SubMeshDescriptor : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Bounds <bounds>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private MeshTopology <topology>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <indexStart>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <indexCount>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <baseVertex>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <firstVertex>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <vertexCount>k__BackingField;
    public Bounds bounds { get; public set; }
    public MeshTopology topology { get; public set; }
    public int indexStart { get; public set; }
    public int indexCount { get; public set; }
    public int baseVertex { get; public set; }
    public int firstVertex { get; public set; }
    public int vertexCount { get; public set; }
    public SubMeshDescriptor(int indexStart, int indexCount, MeshTopology topology);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Bounds get_bounds();
    [CompilerGeneratedAttribute]
public void set_bounds(Bounds value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshTopology get_topology();
    [CompilerGeneratedAttribute]
public void set_topology(MeshTopology value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_indexStart();
    [CompilerGeneratedAttribute]
public void set_indexStart(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_indexCount();
    [CompilerGeneratedAttribute]
public void set_indexCount(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_baseVertex();
    [CompilerGeneratedAttribute]
public void set_baseVertex(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_firstVertex();
    [CompilerGeneratedAttribute]
public void set_firstVertex(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_vertexCount();
    [CompilerGeneratedAttribute]
public void set_vertexCount(int value);
    public virtual string ToString();
}
public class UnityEngine.Rendering.SupportedRenderingFeatures : object {
    private static SupportedRenderingFeatures s_Active;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ReflectionProbeModes <reflectionProbeModes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LightmapMixedBakeModes <defaultMixedLightingModes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LightmapMixedBakeModes <mixedLightingModes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LightmapBakeType <lightmapBakeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LightmapsMode <lightmapsModes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <enlightenLightmapper>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <enlighten>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <lightProbeProxyVolumes>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <motionVectors>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <receiveShadows>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <reflectionProbes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <reflectionProbesBlendDistance>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <rendererPriority>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <rendersUIOverlay>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <overridesEnvironmentLighting>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesFog>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesRealtimeReflectionProbes>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <overridesOtherLightingSettings>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <editableMaterialRenderQueue>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesLODBias>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesMaximumLODLevel>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesEnableLODCrossFade>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <rendererProbes>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <particleSystemInstancing>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <autoAmbientProbeBaking>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <autoDefaultReflectionProbeBaking>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <overridesShadowmask>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <overridesLightProbeSystem>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private bool <supportsHDR>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <overridesLightProbeSystemWarningMessage>k__BackingField;
    public static SupportedRenderingFeatures active { get; public set; }
    public ReflectionProbeModes reflectionProbeModes { get; public set; }
    public LightmapMixedBakeModes defaultMixedLightingModes { get; public set; }
    public LightmapMixedBakeModes mixedLightingModes { get; public set; }
    public LightmapBakeType lightmapBakeTypes { get; public set; }
    public LightmapsMode lightmapsModes { get; public set; }
    [ObsoleteAttribute("Bake with the Progressive Lightmapper. The backend that uses Enlighten to bake is deprecated.", "False")]
public bool enlightenLightmapper { get; public set; }
    public bool enlighten { get; public set; }
    public bool lightProbeProxyVolumes { get; public set; }
    public bool motionVectors { get; public set; }
    public bool receiveShadows { get; public set; }
    public bool reflectionProbes { get; public set; }
    public bool reflectionProbesBlendDistance { get; public set; }
    public bool rendererPriority { get; public set; }
    public bool rendersUIOverlay { get; public set; }
    public bool overridesEnvironmentLighting { get; public set; }
    public bool overridesFog { get; public set; }
    public bool overridesRealtimeReflectionProbes { get; public set; }
    public bool overridesOtherLightingSettings { get; public set; }
    public bool editableMaterialRenderQueue { get; public set; }
    public bool overridesLODBias { get; public set; }
    public bool overridesMaximumLODLevel { get; public set; }
    public bool overridesEnableLODCrossFade { get; public set; }
    public bool rendererProbes { get; public set; }
    public bool particleSystemInstancing { get; public set; }
    public bool autoAmbientProbeBaking { get; public set; }
    public bool autoDefaultReflectionProbeBaking { get; public set; }
    public bool overridesShadowmask { get; public set; }
    public bool overridesLightProbeSystem { get; public set; }
    public bool supportsHDR { get; public set; }
    public string overridesLightProbeSystemWarningMessage { get; public set; }
    [ObsoleteAttribute("terrainDetailUnsupported is deprecated.")]
public bool terrainDetailUnsupported { get; public set; }
    private static SupportedRenderingFeatures();
    public static SupportedRenderingFeatures get_active();
    public static void set_active(SupportedRenderingFeatures value);
    [CompilerGeneratedAttribute]
public ReflectionProbeModes get_reflectionProbeModes();
    [CompilerGeneratedAttribute]
public void set_reflectionProbeModes(ReflectionProbeModes value);
    [CompilerGeneratedAttribute]
public LightmapMixedBakeModes get_defaultMixedLightingModes();
    [CompilerGeneratedAttribute]
public void set_defaultMixedLightingModes(LightmapMixedBakeModes value);
    [CompilerGeneratedAttribute]
public LightmapMixedBakeModes get_mixedLightingModes();
    [CompilerGeneratedAttribute]
public void set_mixedLightingModes(LightmapMixedBakeModes value);
    [CompilerGeneratedAttribute]
public LightmapBakeType get_lightmapBakeTypes();
    [CompilerGeneratedAttribute]
public void set_lightmapBakeTypes(LightmapBakeType value);
    [CompilerGeneratedAttribute]
public LightmapsMode get_lightmapsModes();
    [CompilerGeneratedAttribute]
public void set_lightmapsModes(LightmapsMode value);
    [CompilerGeneratedAttribute]
public bool get_enlightenLightmapper();
    [CompilerGeneratedAttribute]
public void set_enlightenLightmapper(bool value);
    [CompilerGeneratedAttribute]
public bool get_enlighten();
    [CompilerGeneratedAttribute]
public void set_enlighten(bool value);
    [CompilerGeneratedAttribute]
public bool get_lightProbeProxyVolumes();
    [CompilerGeneratedAttribute]
public void set_lightProbeProxyVolumes(bool value);
    [CompilerGeneratedAttribute]
public bool get_motionVectors();
    [CompilerGeneratedAttribute]
public void set_motionVectors(bool value);
    [CompilerGeneratedAttribute]
public bool get_receiveShadows();
    [CompilerGeneratedAttribute]
public void set_receiveShadows(bool value);
    [CompilerGeneratedAttribute]
public bool get_reflectionProbes();
    [CompilerGeneratedAttribute]
public void set_reflectionProbes(bool value);
    [CompilerGeneratedAttribute]
public bool get_reflectionProbesBlendDistance();
    [CompilerGeneratedAttribute]
public void set_reflectionProbesBlendDistance(bool value);
    [CompilerGeneratedAttribute]
public bool get_rendererPriority();
    [CompilerGeneratedAttribute]
public void set_rendererPriority(bool value);
    [CompilerGeneratedAttribute]
public bool get_rendersUIOverlay();
    [CompilerGeneratedAttribute]
public void set_rendersUIOverlay(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesEnvironmentLighting();
    [CompilerGeneratedAttribute]
public void set_overridesEnvironmentLighting(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesFog();
    [CompilerGeneratedAttribute]
public void set_overridesFog(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesRealtimeReflectionProbes();
    [CompilerGeneratedAttribute]
public void set_overridesRealtimeReflectionProbes(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesOtherLightingSettings();
    [CompilerGeneratedAttribute]
public void set_overridesOtherLightingSettings(bool value);
    [CompilerGeneratedAttribute]
public bool get_editableMaterialRenderQueue();
    [CompilerGeneratedAttribute]
public void set_editableMaterialRenderQueue(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesLODBias();
    [CompilerGeneratedAttribute]
public void set_overridesLODBias(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesMaximumLODLevel();
    [CompilerGeneratedAttribute]
public void set_overridesMaximumLODLevel(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesEnableLODCrossFade();
    [CompilerGeneratedAttribute]
public void set_overridesEnableLODCrossFade(bool value);
    [CompilerGeneratedAttribute]
public bool get_rendererProbes();
    [CompilerGeneratedAttribute]
public void set_rendererProbes(bool value);
    [CompilerGeneratedAttribute]
public bool get_particleSystemInstancing();
    [CompilerGeneratedAttribute]
public void set_particleSystemInstancing(bool value);
    [CompilerGeneratedAttribute]
public bool get_autoAmbientProbeBaking();
    [CompilerGeneratedAttribute]
public void set_autoAmbientProbeBaking(bool value);
    [CompilerGeneratedAttribute]
public bool get_autoDefaultReflectionProbeBaking();
    [CompilerGeneratedAttribute]
public void set_autoDefaultReflectionProbeBaking(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesShadowmask();
    [CompilerGeneratedAttribute]
public void set_overridesShadowmask(bool value);
    [CompilerGeneratedAttribute]
public bool get_overridesLightProbeSystem();
    [CompilerGeneratedAttribute]
public void set_overridesLightProbeSystem(bool value);
    [CompilerGeneratedAttribute]
public bool get_supportsHDR();
    [CompilerGeneratedAttribute]
public void set_supportsHDR(bool value);
    [CompilerGeneratedAttribute]
public string get_overridesLightProbeSystemWarningMessage();
    [CompilerGeneratedAttribute]
public void set_overridesLightProbeSystemWarningMessage(string value);
    internal static MixedLightingMode FallbackMixedLightingMode();
    [RequiredByNativeCodeAttribute]
internal static void FallbackMixedLightingModeByRef(IntPtr fallbackModePtr);
    internal static bool IsMixedLightingModeSupported(MixedLightingMode mixedMode);
    [RequiredByNativeCodeAttribute]
internal static void IsMixedLightingModeSupportedByRef(MixedLightingMode mixedMode, IntPtr isSupportedPtr);
    internal static bool IsLightmapBakeTypeSupported(LightmapBakeType bakeType);
    [RequiredByNativeCodeAttribute]
internal static void IsLightmapBakeTypeSupportedByRef(LightmapBakeType bakeType, IntPtr isSupportedPtr);
    internal static bool IsLightmapsModeSupported(LightmapsMode mode);
    [RequiredByNativeCodeAttribute]
internal static void IsLightmapsModeSupportedByRef(LightmapsMode mode, IntPtr isSupportedPtr);
    internal static bool IsLightmapperSupported(int lightmapper);
    [RequiredByNativeCodeAttribute]
internal static void IsLightmapperSupportedByRef(int lightmapper, IntPtr isSupportedPtr);
    [RequiredByNativeCodeAttribute]
internal static void IsUIOverlayRenderedBySRP(IntPtr isSupportedPtr);
    [RequiredByNativeCodeAttribute]
internal static void IsAutoAmbientProbeBakingSupported(IntPtr isSupportedPtr);
    [RequiredByNativeCodeAttribute]
internal static void IsAutoDefaultReflectionProbeBakingSupported(IntPtr isSupportedPtr);
    [RequiredByNativeCodeAttribute]
internal static void OverridesLightProbeSystem(IntPtr overridesPtr);
    internal static int FallbackLightmapper();
    [RequiredByNativeCodeAttribute]
internal static void FallbackLightmapperByRef(IntPtr lightmapperPtr);
    public bool get_terrainDetailUnsupported();
    public void set_terrainDetailUnsupported(bool value);
}
public enum UnityEngine.Rendering.SynchronisationStage : Enum {
    public int value__;
    public static SynchronisationStage VertexProcessing;
    public static SynchronisationStage PixelProcessing;
}
public enum UnityEngine.Rendering.SynchronisationStageFlags : Enum {
    public int value__;
    public static SynchronisationStageFlags VertexProcessing;
    public static SynchronisationStageFlags PixelProcessing;
    public static SynchronisationStageFlags ComputeProcessing;
    public static SynchronisationStageFlags AllGPUOperations;
}
public enum UnityEngine.Rendering.TextureDimension : Enum {
    public int value__;
    public static TextureDimension Unknown;
    public static TextureDimension None;
    public static TextureDimension Any;
    public static TextureDimension Tex2D;
    public static TextureDimension Tex3D;
    public static TextureDimension Cube;
    public static TextureDimension Tex2DArray;
    public static TextureDimension CubeArray;
}
[NativeHeaderAttribute("Runtime/Camera/BatchRendererGroup.h")]
public class UnityEngine.Rendering.ThreadedBatchContext : ValueType {
    public IntPtr batchRendererGroup;
    [FreeFunctionAttribute("BatchRendererGroup::AddDrawCommandBatch_Threaded")]
private static BatchID AddDrawCommandBatch(IntPtr brg, IntPtr values, int count, GraphicsBufferHandle buffer, UInt32 bufferOffset, UInt32 windowSize);
    [FreeFunctionAttribute("BatchRendererGroup::SetDrawCommandBatchBuffer_Threaded")]
private static void SetDrawCommandBatchBuffer(IntPtr brg, BatchID batchID, GraphicsBufferHandle buffer);
    [FreeFunctionAttribute("BatchRendererGroup::RemoveDrawCommandBatch_Threaded")]
private static void RemoveDrawCommandBatch(IntPtr brg, BatchID batchID);
    public BatchID AddBatch(NativeArray`1<MetadataValue> batchMetadata, GraphicsBufferHandle buffer);
    public BatchID AddBatch(NativeArray`1<MetadataValue> batchMetadata, GraphicsBufferHandle buffer, UInt32 bufferOffset, UInt32 windowSize);
    public void SetBatchBuffer(BatchID batchID, GraphicsBufferHandle buffer);
    public void RemoveBatch(BatchID batchID);
    private static void AddDrawCommandBatch_Injected(IntPtr brg, IntPtr values, int count, GraphicsBufferHandle& buffer, UInt32 bufferOffset, UInt32 windowSize, BatchID& ret);
    private static void SetDrawCommandBatchBuffer_Injected(IntPtr brg, BatchID& batchID, GraphicsBufferHandle& buffer);
    private static void RemoveDrawCommandBatch_Injected(IntPtr brg, BatchID& batchID);
}
[MovedFromAttribute("UnityEngine.Experimental.Rendering")]
public enum UnityEngine.Rendering.VertexAttribute : Enum {
    public int value__;
    public static VertexAttribute Position;
    public static VertexAttribute Normal;
    public static VertexAttribute Tangent;
    public static VertexAttribute Color;
    public static VertexAttribute TexCoord0;
    public static VertexAttribute TexCoord1;
    public static VertexAttribute TexCoord2;
    public static VertexAttribute TexCoord3;
    public static VertexAttribute TexCoord4;
    public static VertexAttribute TexCoord5;
    public static VertexAttribute TexCoord6;
    public static VertexAttribute TexCoord7;
    public static VertexAttribute BlendWeight;
    public static VertexAttribute BlendIndices;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.VertexAttributeDescriptor : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private VertexAttribute <attribute>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private VertexAttributeFormat <format>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <dimension>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <stream>k__BackingField;
    public VertexAttribute attribute { get; public set; }
    public VertexAttributeFormat format { get; public set; }
    public int dimension { get; public set; }
    public int stream { get; public set; }
    public VertexAttributeDescriptor(VertexAttribute attribute, VertexAttributeFormat format, int dimension, int stream);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public VertexAttribute get_attribute();
    [CompilerGeneratedAttribute]
public void set_attribute(VertexAttribute value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public VertexAttributeFormat get_format();
    [CompilerGeneratedAttribute]
public void set_format(VertexAttributeFormat value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_dimension();
    [CompilerGeneratedAttribute]
public void set_dimension(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_stream();
    [CompilerGeneratedAttribute]
public void set_stream(int value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(VertexAttributeDescriptor other);
    public static bool op_Equality(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs);
    public static bool op_Inequality(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs);
}
public enum UnityEngine.Rendering.VertexAttributeFormat : Enum {
    public int value__;
    public static VertexAttributeFormat Float32;
    public static VertexAttributeFormat Float16;
    public static VertexAttributeFormat UNorm8;
    public static VertexAttributeFormat SNorm8;
    public static VertexAttributeFormat UNorm16;
    public static VertexAttributeFormat SNorm16;
    public static VertexAttributeFormat UInt8;
    public static VertexAttributeFormat SInt8;
    public static VertexAttributeFormat UInt16;
    public static VertexAttributeFormat SInt16;
    public static VertexAttributeFormat UInt32;
    public static VertexAttributeFormat SInt32;
}
public enum UnityEngine.Rendering.VideoShadersIncludeMode : Enum {
    public int value__;
    public static VideoShadersIncludeMode Never;
    public static VideoShadersIncludeMode Referenced;
    public static VideoShadersIncludeMode Always;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.VisibleLight : ValueType {
    private LightType m_LightType;
    private Color m_FinalColor;
    private Rect m_ScreenRect;
    private Matrix4x4 m_LocalToWorldMatrix;
    private float m_Range;
    private float m_SpotAngle;
    private int m_InstanceId;
    private VisibleLightFlags m_Flags;
    public Light light { get; }
    public LightType lightType { get; public set; }
    public Color finalColor { get; public set; }
    public Rect screenRect { get; public set; }
    public Matrix4x4 localToWorldMatrix { get; public set; }
    public float range { get; public set; }
    public float spotAngle { get; public set; }
    public bool intersectsNearPlane { get; public set; }
    public bool intersectsFarPlane { get; public set; }
    public Light get_light();
    public LightType get_lightType();
    public void set_lightType(LightType value);
    public Color get_finalColor();
    public void set_finalColor(Color value);
    public Rect get_screenRect();
    public void set_screenRect(Rect value);
    public Matrix4x4 get_localToWorldMatrix();
    public void set_localToWorldMatrix(Matrix4x4 value);
    public float get_range();
    public void set_range(float value);
    public float get_spotAngle();
    public void set_spotAngle(float value);
    public bool get_intersectsNearPlane();
    public void set_intersectsNearPlane(bool value);
    public bool get_intersectsFarPlane();
    public void set_intersectsFarPlane(bool value);
    public sealed virtual bool Equals(VisibleLight other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VisibleLight left, VisibleLight right);
    public static bool op_Inequality(VisibleLight left, VisibleLight right);
}
[FlagsAttribute]
internal enum UnityEngine.Rendering.VisibleLightFlags : Enum {
    public int value__;
    public static VisibleLightFlags IntersectsNearPlane;
    public static VisibleLightFlags IntersectsFarPlane;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.Rendering.VisibleReflectionProbe : ValueType {
    private Bounds m_Bounds;
    private Matrix4x4 m_LocalToWorldMatrix;
    private Vector4 m_HdrData;
    private Vector3 m_Center;
    private float m_BlendDistance;
    private int m_Importance;
    private int m_BoxProjection;
    private int m_InstanceId;
    private int m_TextureId;
    public Texture texture { get; }
    public ReflectionProbe reflectionProbe { get; }
    public Bounds bounds { get; public set; }
    public Matrix4x4 localToWorldMatrix { get; public set; }
    public Vector4 hdrData { get; public set; }
    public Vector3 center { get; public set; }
    public float blendDistance { get; public set; }
    public int importance { get; public set; }
    public bool isBoxProjection { get; public set; }
    public Texture get_texture();
    public ReflectionProbe get_reflectionProbe();
    public Bounds get_bounds();
    public void set_bounds(Bounds value);
    public Matrix4x4 get_localToWorldMatrix();
    public void set_localToWorldMatrix(Matrix4x4 value);
    public Vector4 get_hdrData();
    public void set_hdrData(Vector4 value);
    public Vector3 get_center();
    public void set_center(Vector3 value);
    public float get_blendDistance();
    public void set_blendDistance(float value);
    public int get_importance();
    public void set_importance(int value);
    public bool get_isBoxProjection();
    public void set_isBoxProjection(bool value);
    public sealed virtual bool Equals(VisibleReflectionProbe other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VisibleReflectionProbe left, VisibleReflectionProbe right);
    public static bool op_Inequality(VisibleReflectionProbe left, VisibleReflectionProbe right);
}
public enum UnityEngine.RenderingPath : Enum {
    public int value__;
    public static RenderingPath UsePlayerSettings;
    public static RenderingPath VertexLit;
    public static RenderingPath Forward;
    [ObsoleteAttribute("DeferredLighting has been removed. Use DeferredShading, Forward or HDRP/URP instead.", "False")]
public static RenderingPath DeferredLighting;
    public static RenderingPath DeferredShading;
}
[IsReadOnlyAttribute]
internal class UnityEngine.RenderInstancedDataLayout : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <size>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <offsetObjectToWorld>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <offsetPrevObjectToWorld>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <offsetRenderingLayerMask>k__BackingField;
    public int size { get; }
    public int offsetObjectToWorld { get; }
    public int offsetPrevObjectToWorld { get; }
    public int offsetRenderingLayerMask { get; }
    public RenderInstancedDataLayout(Type t);
    [CompilerGeneratedAttribute]
public int get_size();
    [CompilerGeneratedAttribute]
public int get_offsetObjectToWorld();
    [CompilerGeneratedAttribute]
public int get_offsetPrevObjectToWorld();
    [CompilerGeneratedAttribute]
public int get_offsetRenderingLayerMask();
}
public class UnityEngine.RenderParams : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <layer>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private UInt32 <renderingLayerMask>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <rendererPriority>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Bounds <worldBounds>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Camera <camera>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private MotionVectorGenerationMode <motionVectorMode>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ReflectionProbeUsage <reflectionProbeUsage>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Material <material>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MaterialPropertyBlock <matProps>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ShadowCastingMode <shadowCastingMode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <receiveShadows>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private LightProbeUsage <lightProbeUsage>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private LightProbeProxyVolume <lightProbeProxyVolume>k__BackingField;
    public int layer { get; public set; }
    public UInt32 renderingLayerMask { get; public set; }
    public int rendererPriority { get; public set; }
    public Bounds worldBounds { get; public set; }
    public Camera camera { get; public set; }
    public MotionVectorGenerationMode motionVectorMode { get; public set; }
    public ReflectionProbeUsage reflectionProbeUsage { get; public set; }
    public Material material { get; public set; }
    public MaterialPropertyBlock matProps { get; public set; }
    public ShadowCastingMode shadowCastingMode { get; public set; }
    public bool receiveShadows { get; public set; }
    public LightProbeUsage lightProbeUsage { get; public set; }
    public LightProbeProxyVolume lightProbeProxyVolume { get; public set; }
    public RenderParams(Material mat);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_layer();
    [CompilerGeneratedAttribute]
public void set_layer(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public UInt32 get_renderingLayerMask();
    [CompilerGeneratedAttribute]
public void set_renderingLayerMask(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_rendererPriority();
    [CompilerGeneratedAttribute]
public void set_rendererPriority(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Bounds get_worldBounds();
    [CompilerGeneratedAttribute]
public void set_worldBounds(Bounds value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Camera get_camera();
    [CompilerGeneratedAttribute]
public void set_camera(Camera value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public MotionVectorGenerationMode get_motionVectorMode();
    [CompilerGeneratedAttribute]
public void set_motionVectorMode(MotionVectorGenerationMode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReflectionProbeUsage get_reflectionProbeUsage();
    [CompilerGeneratedAttribute]
public void set_reflectionProbeUsage(ReflectionProbeUsage value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Material get_material();
    [CompilerGeneratedAttribute]
public void set_material(Material value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MaterialPropertyBlock get_matProps();
    [CompilerGeneratedAttribute]
public void set_matProps(MaterialPropertyBlock value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ShadowCastingMode get_shadowCastingMode();
    [CompilerGeneratedAttribute]
public void set_shadowCastingMode(ShadowCastingMode value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public bool get_receiveShadows();
    [CompilerGeneratedAttribute]
public void set_receiveShadows(bool value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public LightProbeUsage get_lightProbeUsage();
    [CompilerGeneratedAttribute]
public void set_lightProbeUsage(LightProbeUsage value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public LightProbeProxyVolume get_lightProbeProxyVolume();
    [CompilerGeneratedAttribute]
public void set_lightProbeProxyVolume(LightProbeProxyVolume value);
}
[NativeHeaderAttribute("Runtime/Graphics/QualitySettingsTypes.h")]
[NativeHeaderAttribute("Runtime/Camera/RenderSettings.h")]
[StaticAccessorAttribute("GetRenderSettings()", "0")]
public class UnityEngine.RenderSettings : Object {
    [ObsoleteAttribute("Use RenderSettings.ambientIntensity instead (UnityUpgradable) -> ambientIntensity", "False")]
public static float ambientSkyboxAmount { get; public set; }
    [NativePropertyAttribute("UseFog")]
public static bool fog { get; public set; }
    [NativePropertyAttribute("LinearFogStart")]
public static float fogStartDistance { get; public set; }
    [NativePropertyAttribute("LinearFogEnd")]
public static float fogEndDistance { get; public set; }
    public static FogMode fogMode { get; public set; }
    public static Color fogColor { get; public set; }
    public static float fogDensity { get; public set; }
    public static AmbientMode ambientMode { get; public set; }
    public static Color ambientSkyColor { get; public set; }
    public static Color ambientEquatorColor { get; public set; }
    public static Color ambientGroundColor { get; public set; }
    public static float ambientIntensity { get; public set; }
    [NativePropertyAttribute("AmbientSkyColor")]
public static Color ambientLight { get; public set; }
    public static Color subtractiveShadowColor { get; public set; }
    [NativePropertyAttribute("SkyboxMaterial")]
public static Material skybox { get; public set; }
    public static Light sun { get; public set; }
    public static SphericalHarmonicsL2 ambientProbe { get; public set; }
    [ObsoleteAttribute("RenderSettings.customReflection has been deprecated in favor of RenderSettings.customReflectionTexture.", "False")]
public static Cubemap customReflection { get; public set; }
    [NativePropertyAttribute("CustomReflection")]
public static Texture customReflectionTexture { get; public set; }
    public static float reflectionIntensity { get; public set; }
    public static int reflectionBounces { get; public set; }
    [NativePropertyAttribute("GeneratedSkyboxReflection")]
internal static Cubemap defaultReflection { get; }
    public static DefaultReflectionMode defaultReflectionMode { get; public set; }
    public static int defaultReflectionResolution { get; public set; }
    public static float haloStrength { get; public set; }
    public static float flareStrength { get; public set; }
    public static float flareFadeSpeed { get; public set; }
    public static float get_ambientSkyboxAmount();
    public static void set_ambientSkyboxAmount(float value);
    public static bool get_fog();
    public static void set_fog(bool value);
    public static float get_fogStartDistance();
    public static void set_fogStartDistance(float value);
    public static float get_fogEndDistance();
    public static void set_fogEndDistance(float value);
    public static FogMode get_fogMode();
    public static void set_fogMode(FogMode value);
    public static Color get_fogColor();
    public static void set_fogColor(Color value);
    public static float get_fogDensity();
    public static void set_fogDensity(float value);
    public static AmbientMode get_ambientMode();
    public static void set_ambientMode(AmbientMode value);
    public static Color get_ambientSkyColor();
    public static void set_ambientSkyColor(Color value);
    public static Color get_ambientEquatorColor();
    public static void set_ambientEquatorColor(Color value);
    public static Color get_ambientGroundColor();
    public static void set_ambientGroundColor(Color value);
    public static float get_ambientIntensity();
    public static void set_ambientIntensity(float value);
    public static Color get_ambientLight();
    public static void set_ambientLight(Color value);
    public static Color get_subtractiveShadowColor();
    public static void set_subtractiveShadowColor(Color value);
    public static Material get_skybox();
    public static void set_skybox(Material value);
    public static Light get_sun();
    public static void set_sun(Light value);
    [NativeMethodAttribute("GetFinalAmbientProbe")]
public static SphericalHarmonicsL2 get_ambientProbe();
    public static void set_ambientProbe(SphericalHarmonicsL2 value);
    public static Cubemap get_customReflection();
    [NativeThrowsAttribute]
public static void set_customReflection(Cubemap value);
    public static Texture get_customReflectionTexture();
    [NativeThrowsAttribute]
public static void set_customReflectionTexture(Texture value);
    public static float get_reflectionIntensity();
    public static void set_reflectionIntensity(float value);
    public static int get_reflectionBounces();
    public static void set_reflectionBounces(int value);
    internal static Cubemap get_defaultReflection();
    public static DefaultReflectionMode get_defaultReflectionMode();
    public static void set_defaultReflectionMode(DefaultReflectionMode value);
    public static int get_defaultReflectionResolution();
    public static void set_defaultReflectionResolution(int value);
    public static float get_haloStrength();
    public static void set_haloStrength(float value);
    public static float get_flareStrength();
    public static void set_flareStrength(float value);
    public static float get_flareFadeSpeed();
    public static void set_flareFadeSpeed(float value);
    [FreeFunctionAttribute("GetRenderSettings")]
internal static Object GetRenderSettings();
    [StaticAccessorAttribute("RenderSettingsScripting", "2")]
internal static void Reset();
    private static void get_fogColor_Injected(Color& ret);
    private static void set_fogColor_Injected(Color& value);
    private static void get_ambientSkyColor_Injected(Color& ret);
    private static void set_ambientSkyColor_Injected(Color& value);
    private static void get_ambientEquatorColor_Injected(Color& ret);
    private static void set_ambientEquatorColor_Injected(Color& value);
    private static void get_ambientGroundColor_Injected(Color& ret);
    private static void set_ambientGroundColor_Injected(Color& value);
    private static void get_ambientLight_Injected(Color& ret);
    private static void set_ambientLight_Injected(Color& value);
    private static void get_subtractiveShadowColor_Injected(Color& ret);
    private static void set_subtractiveShadowColor_Injected(Color& value);
    private static void get_ambientProbe_Injected(SphericalHarmonicsL2& ret);
    private static void set_ambientProbe_Injected(SphericalHarmonicsL2& value);
}
public class UnityEngine.RenderTargetSetup : ValueType {
    public RenderBuffer[] color;
    public RenderBuffer depth;
    public int mipLevel;
    public CubemapFace cubemapFace;
    public int depthSlice;
    public RenderBufferLoadAction[] colorLoad;
    public RenderBufferStoreAction[] colorStore;
    public RenderBufferLoadAction depthLoad;
    public RenderBufferStoreAction depthStore;
    public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, RenderBufferLoadAction[] colorLoad, RenderBufferStoreAction[] colorStore, RenderBufferLoadAction depthLoad, RenderBufferStoreAction depthStore);
    public RenderTargetSetup(RenderBuffer color, RenderBuffer depth);
    public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel);
    public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face);
    public RenderTargetSetup(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face, int depthSlice);
    public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth);
    public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mipLevel);
    public RenderTargetSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face);
    internal static RenderBufferLoadAction[] LoadActions(RenderBuffer[] buf);
    internal static RenderBufferStoreAction[] StoreActions(RenderBuffer[] buf);
}
[NativeHeaderAttribute("Runtime/Graphics/RenderTexture.h")]
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Camera/Camera.h")]
[NativeHeaderAttribute("Runtime/Graphics/RenderBufferManager.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
public class UnityEngine.RenderTexture : Texture {
    public int width { get; public set; }
    public int height { get; public set; }
    public TextureDimension dimension { get; public set; }
    public GraphicsFormat graphicsFormat { get; public set; }
    [NativePropertyAttribute("MipMap")]
public bool useMipMap { get; public set; }
    [NativePropertyAttribute("SRGBReadWrite")]
public bool sRGB { get; }
    [NativePropertyAttribute("VRUsage")]
public VRTextureUsage vrUsage { get; public set; }
    [NativePropertyAttribute("Memoryless")]
public RenderTextureMemoryless memorylessMode { get; public set; }
    public RenderTextureFormat format { get; public set; }
    public GraphicsFormat stencilFormat { get; public set; }
    public GraphicsFormat depthStencilFormat { get; public set; }
    public bool autoGenerateMips { get; public set; }
    public int volumeDepth { get; public set; }
    public int antiAliasing { get; public set; }
    public bool bindTextureMS { get; public set; }
    public bool enableRandomWrite { get; public set; }
    public bool useDynamicScale { get; public set; }
    public bool isPowerOfTwo { get; public set; }
    public static RenderTexture active { get; public set; }
    public RenderBuffer colorBuffer { get; }
    public RenderBuffer depthBuffer { get; }
    public int depth { get; public set; }
    public RenderTextureDescriptor descriptor { get; public set; }
    [ObsoleteAttribute("Use RenderTexture.dimension instead.", "False")]
public bool isCubemap { get; public set; }
    [ObsoleteAttribute("Use RenderTexture.dimension instead.", "False")]
public bool isVolume { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("RenderTexture.enabled is always now, no need to use it.", "False")]
public static bool enabled { get; public set; }
    public RenderTexture(RenderTextureDescriptor desc);
    public RenderTexture(RenderTexture textureToCopy);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth, DefaultFormat format);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth, GraphicsFormat format);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth, GraphicsFormat format, int mipCount);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat, int mipCount);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat);
    public RenderTexture(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth, RenderTextureFormat format);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth);
    [ExcludeFromDocsAttribute]
public RenderTexture(int width, int height, int depth, RenderTextureFormat format, int mipCount);
    public virtual int get_width();
    public virtual void set_width(int value);
    public virtual int get_height();
    public virtual void set_height(int value);
    public virtual TextureDimension get_dimension();
    public virtual void set_dimension(TextureDimension value);
    [NativeNameAttribute("GetColorFormat")]
private GraphicsFormat GetColorFormat(bool suppressWarnings);
    [NativeNameAttribute("SetColorFormat")]
private void SetColorFormat(GraphicsFormat format);
    public GraphicsFormat get_graphicsFormat();
    public void set_graphicsFormat(GraphicsFormat value);
    public bool get_useMipMap();
    public void set_useMipMap(bool value);
    public bool get_sRGB();
    public VRTextureUsage get_vrUsage();
    public void set_vrUsage(VRTextureUsage value);
    public RenderTextureMemoryless get_memorylessMode();
    public void set_memorylessMode(RenderTextureMemoryless value);
    public RenderTextureFormat get_format();
    public void set_format(RenderTextureFormat value);
    public GraphicsFormat get_stencilFormat();
    public void set_stencilFormat(GraphicsFormat value);
    public GraphicsFormat get_depthStencilFormat();
    public void set_depthStencilFormat(GraphicsFormat value);
    public bool get_autoGenerateMips();
    public void set_autoGenerateMips(bool value);
    public int get_volumeDepth();
    public void set_volumeDepth(int value);
    public int get_antiAliasing();
    public void set_antiAliasing(int value);
    public bool get_bindTextureMS();
    public void set_bindTextureMS(bool value);
    public bool get_enableRandomWrite();
    public void set_enableRandomWrite(bool value);
    public bool get_useDynamicScale();
    public void set_useDynamicScale(bool value);
    private bool GetIsPowerOfTwo();
    public bool get_isPowerOfTwo();
    public void set_isPowerOfTwo(bool value);
    [FreeFunctionAttribute("RenderTexture::GetActive")]
private static RenderTexture GetActive();
    [FreeFunctionAttribute("RenderTextureScripting::SetActive")]
private static void SetActive(RenderTexture rt);
    public static RenderTexture get_active();
    public static void set_active(RenderTexture value);
    [FreeFunctionAttribute]
private RenderBuffer GetColorBuffer();
    [FreeFunctionAttribute]
private RenderBuffer GetDepthBuffer();
    private void SetMipMapCount(int count);
    private void SetShadowSamplingMode(ShadowSamplingMode samplingMode);
    public RenderBuffer get_colorBuffer();
    public RenderBuffer get_depthBuffer();
    public IntPtr GetNativeDepthBufferPtr();
    public void DiscardContents(bool discardColor, bool discardDepth);
    [ObsoleteAttribute("This function has no effect.", "False")]
public void MarkRestoreExpected();
    public void DiscardContents();
    [NativeNameAttribute("ResolveAntiAliasedSurface")]
private void ResolveAA();
    [NativeNameAttribute("ResolveAntiAliasedSurface")]
private void ResolveAATo(RenderTexture rt);
    public void ResolveAntiAliasedSurface();
    public void ResolveAntiAliasedSurface(RenderTexture target);
    [FreeFunctionAttribute]
public void SetGlobalShaderProperty(string propertyName);
    public bool Create();
    public void Release();
    public bool IsCreated();
    public void GenerateMips();
    [NativeThrowsAttribute]
public void ConvertToEquirect(RenderTexture equirect, MonoOrStereoscopicEye eye);
    internal void SetSRGBReadWrite(bool srgb);
    [FreeFunctionAttribute("RenderTextureScripting::Create")]
private static void Internal_Create(RenderTexture rt);
    [FreeFunctionAttribute("RenderTextureSupportsStencil")]
public static bool SupportsStencil(RenderTexture rt);
    [NativeNameAttribute("SetRenderTextureDescFromScript")]
private void SetRenderTextureDescriptor(RenderTextureDescriptor desc);
    [NativeNameAttribute("GetRenderTextureDesc")]
private RenderTextureDescriptor GetDescriptor();
    [FreeFunctionAttribute("GetRenderBufferManager().GetTextures().GetTempBuffer")]
private static RenderTexture GetTemporary_Internal(RenderTextureDescriptor desc);
    [FreeFunctionAttribute("GetRenderBufferManager().GetTextures().ReleaseTempBuffer")]
public static void ReleaseTemporary(RenderTexture temp);
    [FreeFunctionAttribute("RenderTextureScripting::GetDepth")]
public int get_depth();
    [FreeFunctionAttribute("RenderTextureScripting::SetDepth")]
public void set_depth(int value);
    private void Initialize(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite, int mipCount);
    internal static GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, GraphicsFormat colorFormat);
    internal static GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, RenderTextureFormat format);
    internal static GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, DefaultFormat format);
    internal static GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, bool requestedShadowMap);
    public RenderTextureDescriptor get_descriptor();
    public void set_descriptor(RenderTextureDescriptor value);
    private static void ValidateRenderTextureDesc(RenderTextureDescriptor desc);
    internal static GraphicsFormat GetDefaultColorFormat(DefaultFormat format);
    internal static GraphicsFormat GetDefaultDepthStencilFormat(DefaultFormat format, int depth);
    internal static GraphicsFormat GetCompatibleFormat(RenderTextureFormat renderTextureFormat, RenderTextureReadWrite readWrite);
    public static RenderTexture GetTemporary(RenderTextureDescriptor desc);
    private static RenderTexture GetTemporaryImpl(int width, int height, GraphicsFormat depthStencilFormat, GraphicsFormat colorFormat, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format);
    public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height, int depthBuffer);
    [ExcludeFromDocsAttribute]
public static RenderTexture GetTemporary(int width, int height);
    public bool get_isCubemap();
    public void set_isCubemap(bool value);
    public bool get_isVolume();
    public void set_isVolume(bool value);
    public static bool get_enabled();
    public static void set_enabled(bool value);
    [ObsoleteAttribute("GetTexelOffset always returns zero now, no point in using it.", "False")]
[EditorBrowsableAttribute("1")]
public Vector2 GetTexelOffset();
    private void GetColorBuffer_Injected(RenderBuffer& ret);
    private void GetDepthBuffer_Injected(RenderBuffer& ret);
    private void SetRenderTextureDescriptor_Injected(RenderTextureDescriptor& desc);
    private void GetDescriptor_Injected(RenderTextureDescriptor& ret);
    private static RenderTexture GetTemporary_Internal_Injected(RenderTextureDescriptor& desc);
}
[FlagsAttribute]
public enum UnityEngine.RenderTextureCreationFlags : Enum {
    public int value__;
    public static RenderTextureCreationFlags MipMap;
    public static RenderTextureCreationFlags AutoGenerateMips;
    public static RenderTextureCreationFlags SRGB;
    public static RenderTextureCreationFlags EyeTexture;
    public static RenderTextureCreationFlags EnableRandomWrite;
    public static RenderTextureCreationFlags CreatedFromScript;
    public static RenderTextureCreationFlags AllowVerticalFlip;
    public static RenderTextureCreationFlags NoResolvedColorSurface;
    public static RenderTextureCreationFlags DynamicallyScalable;
    public static RenderTextureCreationFlags BindMS;
}
public class UnityEngine.RenderTextureDescriptor : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <width>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <height>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <msaaSamples>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <volumeDepth>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <mipCount>k__BackingField;
    private GraphicsFormat _graphicsFormat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private GraphicsFormat <stencilFormat>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private GraphicsFormat <depthStencilFormat>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextureDimension <dimension>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ShadowSamplingMode <shadowSamplingMode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private VRTextureUsage <vrUsage>k__BackingField;
    private RenderTextureCreationFlags _flags;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private RenderTextureMemoryless <memoryless>k__BackingField;
    public int width { get; public set; }
    public int height { get; public set; }
    public int msaaSamples { get; public set; }
    public int volumeDepth { get; public set; }
    public int mipCount { get; public set; }
    public GraphicsFormat graphicsFormat { get; public set; }
    public GraphicsFormat stencilFormat { get; public set; }
    public GraphicsFormat depthStencilFormat { get; public set; }
    public RenderTextureFormat colorFormat { get; public set; }
    public bool sRGB { get; public set; }
    public int depthBufferBits { get; public set; }
    public TextureDimension dimension { get; public set; }
    public ShadowSamplingMode shadowSamplingMode { get; public set; }
    public VRTextureUsage vrUsage { get; public set; }
    public RenderTextureCreationFlags flags { get; }
    public RenderTextureMemoryless memoryless { get; public set; }
    public bool useMipMap { get; public set; }
    public bool autoGenerateMips { get; public set; }
    public bool enableRandomWrite { get; public set; }
    public bool bindMS { get; public set; }
    internal bool createdFromScript { get; internal set; }
    public bool useDynamicScale { get; public set; }
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits, int mipCount);
    public RenderTextureDescriptor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits, int mipCount, RenderTextureReadWrite readWrite);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits, int mipCount);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat);
    [ExcludeFromDocsAttribute]
public RenderTextureDescriptor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat, int mipCount);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_width();
    [CompilerGeneratedAttribute]
public void set_width(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_height();
    [CompilerGeneratedAttribute]
public void set_height(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_msaaSamples();
    [CompilerGeneratedAttribute]
public void set_msaaSamples(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_volumeDepth();
    [CompilerGeneratedAttribute]
public void set_volumeDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_mipCount();
    [CompilerGeneratedAttribute]
public void set_mipCount(int value);
    public GraphicsFormat get_graphicsFormat();
    public void set_graphicsFormat(GraphicsFormat value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public GraphicsFormat get_stencilFormat();
    [CompilerGeneratedAttribute]
public void set_stencilFormat(GraphicsFormat value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public GraphicsFormat get_depthStencilFormat();
    [CompilerGeneratedAttribute]
public void set_depthStencilFormat(GraphicsFormat value);
    public RenderTextureFormat get_colorFormat();
    public void set_colorFormat(RenderTextureFormat value);
    public bool get_sRGB();
    public void set_sRGB(bool value);
    public int get_depthBufferBits();
    public void set_depthBufferBits(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextureDimension get_dimension();
    [CompilerGeneratedAttribute]
public void set_dimension(TextureDimension value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ShadowSamplingMode get_shadowSamplingMode();
    [CompilerGeneratedAttribute]
public void set_shadowSamplingMode(ShadowSamplingMode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public VRTextureUsage get_vrUsage();
    [CompilerGeneratedAttribute]
public void set_vrUsage(VRTextureUsage value);
    public RenderTextureCreationFlags get_flags();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public RenderTextureMemoryless get_memoryless();
    [CompilerGeneratedAttribute]
public void set_memoryless(RenderTextureMemoryless value);
    private void SetOrClearRenderTextureCreationFlag(bool value, RenderTextureCreationFlags flag);
    public bool get_useMipMap();
    public void set_useMipMap(bool value);
    public bool get_autoGenerateMips();
    public void set_autoGenerateMips(bool value);
    public bool get_enableRandomWrite();
    public void set_enableRandomWrite(bool value);
    public bool get_bindMS();
    public void set_bindMS(bool value);
    internal bool get_createdFromScript();
    internal void set_createdFromScript(bool value);
    public bool get_useDynamicScale();
    public void set_useDynamicScale(bool value);
}
public enum UnityEngine.RenderTextureFormat : Enum {
    public int value__;
    public static RenderTextureFormat ARGB32;
    public static RenderTextureFormat Depth;
    public static RenderTextureFormat ARGBHalf;
    public static RenderTextureFormat Shadowmap;
    public static RenderTextureFormat RGB565;
    public static RenderTextureFormat ARGB4444;
    public static RenderTextureFormat ARGB1555;
    public static RenderTextureFormat Default;
    public static RenderTextureFormat ARGB2101010;
    public static RenderTextureFormat DefaultHDR;
    public static RenderTextureFormat ARGB64;
    public static RenderTextureFormat ARGBFloat;
    public static RenderTextureFormat RGFloat;
    public static RenderTextureFormat RGHalf;
    public static RenderTextureFormat RFloat;
    public static RenderTextureFormat RHalf;
    public static RenderTextureFormat R8;
    public static RenderTextureFormat ARGBInt;
    public static RenderTextureFormat RGInt;
    public static RenderTextureFormat RInt;
    public static RenderTextureFormat BGRA32;
    public static RenderTextureFormat RGB111110Float;
    public static RenderTextureFormat RG32;
    public static RenderTextureFormat RGBAUShort;
    public static RenderTextureFormat RG16;
    public static RenderTextureFormat BGRA10101010_XR;
    public static RenderTextureFormat BGR101010_XR;
    public static RenderTextureFormat R16;
}
[FlagsAttribute]
public enum UnityEngine.RenderTextureMemoryless : Enum {
    public int value__;
    public static RenderTextureMemoryless None;
    public static RenderTextureMemoryless Color;
    public static RenderTextureMemoryless Depth;
    public static RenderTextureMemoryless MSAA;
}
public enum UnityEngine.RenderTextureReadWrite : Enum {
    public int value__;
    public static RenderTextureReadWrite Default;
    public static RenderTextureReadWrite Linear;
    public static RenderTextureReadWrite sRGB;
}
[RequiredByNativeCodeAttribute]
[AttributeUsageAttribute("4")]
public class UnityEngine.RequireComponent : Attribute {
    public Type m_Type0;
    public Type m_Type1;
    public Type m_Type2;
    public RequireComponent(Type requiredComponent);
    public RequireComponent(Type requiredComponent, Type requiredComponent2);
    public RequireComponent(Type requiredComponent, Type requiredComponent2, Type requiredComponent3);
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.Resolution : ValueType {
    private int m_Width;
    private int m_Height;
    private RefreshRate m_RefreshRate;
    public int width { get; public set; }
    public int height { get; public set; }
    public RefreshRate refreshRateRatio { get; public set; }
    [ObsoleteAttribute("Resolution.refreshRate is obsolete. Use refreshRateRatio instead.", "False")]
[EditorBrowsableAttribute("1")]
public int refreshRate { get; public set; }
    public int get_width();
    public void set_width(int value);
    public int get_height();
    public void set_height(int value);
    public RefreshRate get_refreshRateRatio();
    public void set_refreshRateRatio(RefreshRate value);
    public int get_refreshRate();
    public void set_refreshRate(int value);
    public virtual string ToString();
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.ResourceRequest : AsyncOperation {
    internal string m_Path;
    internal Type m_Type;
    public Object asset { get; }
    protected virtual Object GetResult();
    public Object get_asset();
}
[NativeHeaderAttribute("Runtime/Export/Resources/Resources.bindings.h")]
[NativeHeaderAttribute("Runtime/Misc/ResourceManagerUtility.h")]
public class UnityEngine.Resources : object {
    internal static T[] ConvertObjects(Object[] rawObjects);
    public static Object[] FindObjectsOfTypeAll(Type type);
    public static T[] FindObjectsOfTypeAll();
    public static Object Load(string path);
    public static T Load(string path);
    public static Object Load(string path, Type systemTypeInstance);
    public static ResourceRequest LoadAsync(string path);
    public static ResourceRequest LoadAsync(string path);
    public static ResourceRequest LoadAsync(string path, Type type);
    public static Object[] LoadAll(string path, Type systemTypeInstance);
    public static Object[] LoadAll(string path);
    public static T[] LoadAll(string path);
    [FreeFunctionAttribute("GetScriptingBuiltinResource")]
[TypeInferenceRuleAttribute("0")]
public static Object GetBuiltinResource(Type type, string path);
    public static T GetBuiltinResource(string path);
    public static void UnloadAsset(Object assetToUnload);
    [FreeFunctionAttribute("Scripting::UnloadAssetFromScripting")]
private static void UnloadAssetImplResourceManager(Object assetToUnload);
    [FreeFunctionAttribute("Resources_Bindings::UnloadUnusedAssets")]
public static AsyncOperation UnloadUnusedAssets();
    [FreeFunctionAttribute("Resources_Bindings::InstanceIDToObject")]
public static Object InstanceIDToObject(int instanceID);
    [FreeFunctionAttribute("Resources_Bindings::InstanceIDToObjectList")]
private static void InstanceIDToObjectList(IntPtr instanceIDs, int instanceCount, List`1<Object> objects);
    public static void InstanceIDToObjectList(NativeArray`1<int> instanceIDs, List`1<Object> objects);
    [FreeFunctionAttribute("Resources_Bindings::InstanceIDsToValidArray")]
private static void InstanceIDsToValidArray_Internal(IntPtr instanceIDs, int instanceCount, IntPtr validArray, int validArrayCount);
    [FreeFunctionAttribute("Resources_Bindings::DoesObjectWithInstanceIDExist")]
public static bool InstanceIDIsValid(int instanceId);
    public static void InstanceIDsToValidArray(NativeArray`1<int> instanceIDs, NativeArray`1<bool> validArray);
    public static void InstanceIDsToValidArray(ReadOnlySpan`1<int> instanceIDs, Span`1<bool> validArray);
}
public class UnityEngine.ResourcesAPI : object {
    private static ResourcesAPI s_DefaultAPI;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static ResourcesAPI <overrideAPI>k__BackingField;
    internal static ResourcesAPI ActiveAPI { get; }
    public static ResourcesAPI overrideAPI { get; public set; }
    private static ResourcesAPI();
    internal static ResourcesAPI get_ActiveAPI();
    [CompilerGeneratedAttribute]
public static ResourcesAPI get_overrideAPI();
    [CompilerGeneratedAttribute]
public static void set_overrideAPI(ResourcesAPI value);
    protected internal virtual Object[] FindObjectsOfTypeAll(Type systemTypeInstance);
    protected internal virtual Shader FindShaderByName(string name);
    protected internal virtual Object Load(string path, Type systemTypeInstance);
    protected internal virtual Object[] LoadAll(string path, Type systemTypeInstance);
    protected internal virtual ResourceRequest LoadAsync(string path, Type systemTypeInstance);
    protected internal virtual void UnloadAsset(Object assetToUnload);
}
[NativeHeaderAttribute("Runtime/Misc/ResourceManagerUtility.h")]
[NativeHeaderAttribute("Runtime/Export/Resources/Resources.bindings.h")]
internal static class UnityEngine.ResourcesAPIInternal : object {
    [FreeFunctionAttribute("Resources_Bindings::FindObjectsOfTypeAll")]
[TypeInferenceRuleAttribute("2")]
public static Object[] FindObjectsOfTypeAll(Type type);
    [FreeFunctionAttribute("GetShaderNameRegistry().FindShader")]
public static Shader FindShaderByName(string name);
    [NativeThrowsAttribute]
[TypeInferenceRuleAttribute("1")]
[FreeFunctionAttribute("Resources_Bindings::Load")]
public static Object Load(string path, Type systemTypeInstance);
    [FreeFunctionAttribute("Resources_Bindings::LoadAll")]
[NativeThrowsAttribute]
public static Object[] LoadAll(string path, Type systemTypeInstance);
    [FreeFunctionAttribute("Resources_Bindings::LoadAsyncInternal")]
internal static ResourceRequest LoadAsyncInternal(string path, Type type);
    [FreeFunctionAttribute("Scripting::UnloadAssetFromScripting")]
public static void UnloadAsset(Object assetToUnload);
}
internal enum UnityEngine.RotationOrder : Enum {
    public int value__;
    public static RotationOrder OrderXYZ;
    public static RotationOrder OrderXZY;
    public static RotationOrder OrderYZX;
    public static RotationOrder OrderYXZ;
    public static RotationOrder OrderZXY;
    public static RotationOrder OrderZYX;
}
public enum UnityEngine.RuntimeInitializeLoadType : Enum {
    public int value__;
    public static RuntimeInitializeLoadType AfterSceneLoad;
    public static RuntimeInitializeLoadType BeforeSceneLoad;
    public static RuntimeInitializeLoadType AfterAssembliesLoaded;
    public static RuntimeInitializeLoadType BeforeSplashScreen;
    public static RuntimeInitializeLoadType SubsystemRegistration;
}
[AttributeUsageAttribute("64")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.RuntimeInitializeOnLoadMethodAttribute : PreserveAttribute {
    private RuntimeInitializeLoadType m_LoadType;
    public RuntimeInitializeLoadType loadType { get; private set; }
    public RuntimeInitializeOnLoadMethodAttribute(RuntimeInitializeLoadType loadType);
    public RuntimeInitializeLoadType get_loadType();
    private void set_loadType(RuntimeInitializeLoadType value);
}
public enum UnityEngine.RuntimePlatform : Enum {
    public int value__;
    public static RuntimePlatform OSXEditor;
    public static RuntimePlatform OSXPlayer;
    public static RuntimePlatform WindowsPlayer;
    [ObsoleteAttribute("WebPlayer export is no longer supported in Unity 5.4+.", "True")]
public static RuntimePlatform OSXWebPlayer;
    [ObsoleteAttribute("Dashboard widget on Mac OS X export is no longer supported in Unity 5.4+.", "True")]
public static RuntimePlatform OSXDashboardPlayer;
    [ObsoleteAttribute("WebPlayer export is no longer supported in Unity 5.4+.", "True")]
public static RuntimePlatform WindowsWebPlayer;
    public static RuntimePlatform WindowsEditor;
    public static RuntimePlatform IPhonePlayer;
    [ObsoleteAttribute("Xbox360 export is no longer supported in Unity 5.5+.")]
public static RuntimePlatform XBOX360;
    [ObsoleteAttribute("PS3 export is no longer supported in Unity >=5.5.")]
public static RuntimePlatform PS3;
    public static RuntimePlatform Android;
    [ObsoleteAttribute("NaCl export is no longer supported in Unity 5.0+.")]
public static RuntimePlatform NaCl;
    [ObsoleteAttribute("FlashPlayer export is no longer supported in Unity 5.0+.")]
public static RuntimePlatform FlashPlayer;
    public static RuntimePlatform LinuxPlayer;
    public static RuntimePlatform LinuxEditor;
    public static RuntimePlatform WebGLPlayer;
    [ObsoleteAttribute("Use WSAPlayerX86 instead")]
public static RuntimePlatform MetroPlayerX86;
    public static RuntimePlatform WSAPlayerX86;
    [ObsoleteAttribute("Use WSAPlayerX64 instead")]
public static RuntimePlatform MetroPlayerX64;
    public static RuntimePlatform WSAPlayerX64;
    [ObsoleteAttribute("Use WSAPlayerARM instead")]
public static RuntimePlatform MetroPlayerARM;
    public static RuntimePlatform WSAPlayerARM;
    [ObsoleteAttribute("Windows Phone 8 was removed in 5.3")]
public static RuntimePlatform WP8Player;
    [ObsoleteAttribute("BlackBerryPlayer export is no longer supported in Unity 5.4+.")]
public static RuntimePlatform BlackBerryPlayer;
    [ObsoleteAttribute("TizenPlayer export is no longer supported in Unity 2017.3+.")]
public static RuntimePlatform TizenPlayer;
    [ObsoleteAttribute("PSP2 is no longer supported as of Unity 2018.3")]
public static RuntimePlatform PSP2;
    public static RuntimePlatform PS4;
    [ObsoleteAttribute("PSM export is no longer supported in Unity >= 5.3")]
public static RuntimePlatform PSM;
    public static RuntimePlatform XboxOne;
    [ObsoleteAttribute("SamsungTVPlayer export is no longer supported in Unity 2017.3+.")]
public static RuntimePlatform SamsungTVPlayer;
    [ObsoleteAttribute("Wii U is no longer supported in Unity 2018.1+.")]
public static RuntimePlatform WiiU;
    public static RuntimePlatform tvOS;
    public static RuntimePlatform Switch;
    [ObsoleteAttribute("Lumin is no longer supported in Unity 2022.2")]
public static RuntimePlatform Lumin;
    public static RuntimePlatform Stadia;
    [ObsoleteAttribute("Use LinuxPlayer instead")]
public static RuntimePlatform CloudRendering;
    [ObsoleteAttribute("GameCoreScarlett is deprecated, please use GameCoreXboxSeries (UnityUpgradable) -> GameCoreXboxSeries", "False")]
public static RuntimePlatform GameCoreScarlett;
    public static RuntimePlatform GameCoreXboxSeries;
    public static RuntimePlatform GameCoreXboxOne;
    public static RuntimePlatform PS5;
    public static RuntimePlatform EmbeddedLinuxArm64;
    public static RuntimePlatform EmbeddedLinuxArm32;
    public static RuntimePlatform EmbeddedLinuxX64;
    public static RuntimePlatform EmbeddedLinuxX86;
    public static RuntimePlatform LinuxServer;
    public static RuntimePlatform WindowsServer;
    public static RuntimePlatform OSXServer;
    public static RuntimePlatform QNXArm32;
    public static RuntimePlatform QNXArm64;
    public static RuntimePlatform QNXX64;
    public static RuntimePlatform QNXX86;
    public static RuntimePlatform VisionOS;
}
[NativeHeaderAttribute("Runtime/GfxDevice/ScalableBufferManager.h")]
[StaticAccessorAttribute("ScalableBufferManager::GetInstance()", "0")]
public static class UnityEngine.ScalableBufferManager : object {
    public static float widthScaleFactor { get; }
    public static float heightScaleFactor { get; }
    public static float get_widthScaleFactor();
    public static float get_heightScaleFactor();
    public static void ResizeBuffers(float widthScale, float heightScale);
}
public class UnityEngine.SceneManagement.CreateSceneParameters : ValueType {
    [SerializeField]
private LocalPhysicsMode m_LocalPhysicsMode;
    public LocalPhysicsMode localPhysicsMode { get; public set; }
    public CreateSceneParameters(LocalPhysicsMode physicsMode);
    public LocalPhysicsMode get_localPhysicsMode();
    public void set_localPhysicsMode(LocalPhysicsMode value);
}
public enum UnityEngine.SceneManagement.LoadSceneMode : Enum {
    public int value__;
    public static LoadSceneMode Single;
    public static LoadSceneMode Additive;
}
public class UnityEngine.SceneManagement.LoadSceneParameters : ValueType {
    [SerializeField]
private LoadSceneMode m_LoadSceneMode;
    [SerializeField]
private LocalPhysicsMode m_LocalPhysicsMode;
    public LoadSceneMode loadSceneMode { get; public set; }
    public LocalPhysicsMode localPhysicsMode { get; public set; }
    public LoadSceneParameters(LoadSceneMode mode);
    public LoadSceneParameters(LoadSceneMode mode, LocalPhysicsMode physicsMode);
    public LoadSceneMode get_loadSceneMode();
    public void set_loadSceneMode(LoadSceneMode value);
    public LocalPhysicsMode get_localPhysicsMode();
    public void set_localPhysicsMode(LocalPhysicsMode value);
}
[FlagsAttribute]
public enum UnityEngine.SceneManagement.LocalPhysicsMode : Enum {
    public int value__;
    public static LocalPhysicsMode None;
    public static LocalPhysicsMode Physics2D;
    public static LocalPhysicsMode Physics3D;
}
[NativeHeaderAttribute("Runtime/Export/SceneManager/Scene.bindings.h")]
public class UnityEngine.SceneManagement.Scene : ValueType {
    [HideInInspector]
[SerializeField]
private int m_Handle;
    public int handle { get; }
    internal LoadingState loadingState { get; }
    internal string guid { get; }
    public string path { get; }
    public string name { get; public set; }
    public bool isLoaded { get; }
    public int buildIndex { get; }
    public bool isDirty { get; }
    internal int dirtyID { get; }
    public int rootCount { get; }
    public bool isSubScene { get; public set; }
    internal Scene(int handle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static bool IsValidInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static string GetPathInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static void SetPathAndGUIDInternal(int sceneHandle, string path, string guid);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static string GetNameInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
[NativeThrowsAttribute]
private static void SetNameInternal(int sceneHandle, string name);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static string GetGUIDInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static bool IsSubScene(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static void SetIsSubScene(int sceneHandle, bool value);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static bool GetIsLoadedInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static LoadingState GetLoadingStateInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static bool GetIsDirtyInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static int GetDirtyID(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static int GetBuildIndexInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static int GetRootCountInternal(int sceneHandle);
    [StaticAccessorAttribute("SceneBindings", "2")]
private static void GetRootGameObjectsInternal(int sceneHandle, object resultRootList);
    public int get_handle();
    internal LoadingState get_loadingState();
    internal string get_guid();
    public bool IsValid();
    public string get_path();
    public string get_name();
    public void set_name(string value);
    public bool get_isLoaded();
    public int get_buildIndex();
    public bool get_isDirty();
    internal int get_dirtyID();
    public int get_rootCount();
    public bool get_isSubScene();
    public void set_isSubScene(bool value);
    public GameObject[] GetRootGameObjects();
    public void GetRootGameObjects(List`1<GameObject> rootGameObjects);
    public static bool op_Equality(Scene lhs, Scene rhs);
    public static bool op_Inequality(Scene lhs, Scene rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    internal void SetPathAndGuid(string path, string guid);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Export/SceneManager/SceneManager.bindings.h")]
public class UnityEngine.SceneManagement.SceneManager : object {
    internal static bool s_AllowLoadScene;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static UnityAction`2<Scene, LoadSceneMode> sceneLoaded;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static UnityAction`1<Scene> sceneUnloaded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static UnityAction`2<Scene, Scene> activeSceneChanged;
    public static int sceneCount { get; }
    public static int loadedSceneCount { get; }
    public static int sceneCountInBuildSettings { get; }
    private static SceneManager();
    [NativeMethodAttribute("GetSceneCount")]
[NativeHeaderAttribute("Runtime/SceneManager/SceneManager.h")]
[StaticAccessorAttribute("GetSceneManager()", "0")]
public static int get_sceneCount();
    [StaticAccessorAttribute("GetSceneManager()", "0")]
[NativeMethodAttribute("GetLoadedSceneCount")]
[NativeHeaderAttribute("Runtime/SceneManager/SceneManager.h")]
public static int get_loadedSceneCount();
    public static int get_sceneCountInBuildSettings();
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
internal static bool CanSetAsActiveScene(Scene scene);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
public static Scene GetActiveScene();
    [NativeThrowsAttribute]
[StaticAccessorAttribute("SceneManagerBindings", "2")]
public static bool SetActiveScene(Scene scene);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
public static Scene GetSceneByPath(string scenePath);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
public static Scene GetSceneByName(string name);
    public static Scene GetSceneByBuildIndex(int buildIndex);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
[NativeThrowsAttribute]
public static Scene GetSceneAt(int index);
    [NativeThrowsAttribute]
[StaticAccessorAttribute("SceneManagerBindings", "2")]
public static Scene CreateScene(string sceneName, CreateSceneParameters parameters);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
[NativeThrowsAttribute]
private static bool UnloadSceneInternal(Scene scene, UnloadSceneOptions options);
    [NativeThrowsAttribute]
[StaticAccessorAttribute("SceneManagerBindings", "2")]
private static AsyncOperation UnloadSceneAsyncInternal(Scene scene, UnloadSceneOptions options);
    private static AsyncOperation LoadSceneAsyncNameIndexInternal(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame);
    private static AsyncOperation UnloadSceneNameIndexInternal(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
[NativeThrowsAttribute]
public static void MergeScenes(Scene sourceScene, Scene destinationScene);
    [StaticAccessorAttribute("SceneManagerBindings", "2")]
[NativeThrowsAttribute]
public static void MoveGameObjectToScene(GameObject go, Scene scene);
    [NativeThrowsAttribute]
[StaticAccessorAttribute("SceneManagerBindings", "2")]
private static void MoveGameObjectsToSceneByInstanceId(IntPtr instanceIds, int instanceCount, Scene scene);
    public static void MoveGameObjectsToScene(NativeArray`1<int> instanceIDs, Scene scene);
    [RequiredByNativeCodeAttribute]
internal static AsyncOperation LoadFirstScene_Internal(bool async);
    [CompilerGeneratedAttribute]
public static void add_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value);
    [CompilerGeneratedAttribute]
public static void remove_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value);
    [CompilerGeneratedAttribute]
public static void add_sceneUnloaded(UnityAction`1<Scene> value);
    [CompilerGeneratedAttribute]
public static void remove_sceneUnloaded(UnityAction`1<Scene> value);
    [CompilerGeneratedAttribute]
public static void add_activeSceneChanged(UnityAction`2<Scene, Scene> value);
    [CompilerGeneratedAttribute]
public static void remove_activeSceneChanged(UnityAction`2<Scene, Scene> value);
    [ObsoleteAttribute("Use SceneManager.sceneCount and SceneManager.GetSceneAt(int index) to loop the all scenes instead.")]
public static Scene[] GetAllScenes();
    public static Scene CreateScene(string sceneName);
    public static void LoadScene(string sceneName, LoadSceneMode mode);
    [ExcludeFromDocsAttribute]
public static void LoadScene(string sceneName);
    public static Scene LoadScene(string sceneName, LoadSceneParameters parameters);
    public static void LoadScene(int sceneBuildIndex, LoadSceneMode mode);
    [ExcludeFromDocsAttribute]
public static void LoadScene(int sceneBuildIndex);
    public static Scene LoadScene(int sceneBuildIndex, LoadSceneParameters parameters);
    public static AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneMode mode);
    [ExcludeFromDocsAttribute]
public static AsyncOperation LoadSceneAsync(int sceneBuildIndex);
    public static AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneParameters parameters);
    public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode);
    [ExcludeFromDocsAttribute]
public static AsyncOperation LoadSceneAsync(string sceneName);
    public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneParameters parameters);
    [ObsoleteAttribute("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
public static bool UnloadScene(Scene scene);
    [ObsoleteAttribute("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
public static bool UnloadScene(int sceneBuildIndex);
    [ObsoleteAttribute("Use SceneManager.UnloadSceneAsync. This function is not safe to use during triggers and under other circumstances. See Scripting reference for more details.")]
public static bool UnloadScene(string sceneName);
    public static AsyncOperation UnloadSceneAsync(int sceneBuildIndex);
    public static AsyncOperation UnloadSceneAsync(string sceneName);
    public static AsyncOperation UnloadSceneAsync(Scene scene);
    public static AsyncOperation UnloadSceneAsync(int sceneBuildIndex, UnloadSceneOptions options);
    public static AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options);
    public static AsyncOperation UnloadSceneAsync(Scene scene, UnloadSceneOptions options);
    [RequiredByNativeCodeAttribute]
private static void Internal_SceneLoaded(Scene scene, LoadSceneMode mode);
    [RequiredByNativeCodeAttribute]
private static void Internal_SceneUnloaded(Scene scene);
    [RequiredByNativeCodeAttribute]
private static void Internal_ActiveSceneChanged(Scene previousActiveScene, Scene newActiveScene);
    private static bool CanSetAsActiveScene_Injected(Scene& scene);
    private static void GetActiveScene_Injected(Scene& ret);
    private static bool SetActiveScene_Injected(Scene& scene);
    private static void GetSceneByPath_Injected(string scenePath, Scene& ret);
    private static void GetSceneByName_Injected(string name, Scene& ret);
    private static void GetSceneAt_Injected(int index, Scene& ret);
    private static void CreateScene_Injected(string sceneName, CreateSceneParameters& parameters, Scene& ret);
    private static bool UnloadSceneInternal_Injected(Scene& scene, UnloadSceneOptions options);
    private static AsyncOperation UnloadSceneAsyncInternal_Injected(Scene& scene, UnloadSceneOptions options);
    private static void MergeScenes_Injected(Scene& sourceScene, Scene& destinationScene);
    private static void MoveGameObjectToScene_Injected(GameObject go, Scene& scene);
    private static void MoveGameObjectsToSceneByInstanceId_Injected(IntPtr instanceIds, int instanceCount, Scene& scene);
}
public class UnityEngine.SceneManagement.SceneManagerAPI : object {
    private static SceneManagerAPI s_DefaultAPI;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static SceneManagerAPI <overrideAPI>k__BackingField;
    internal static SceneManagerAPI ActiveAPI { get; }
    public static SceneManagerAPI overrideAPI { get; public set; }
    private static SceneManagerAPI();
    internal static SceneManagerAPI get_ActiveAPI();
    [CompilerGeneratedAttribute]
public static SceneManagerAPI get_overrideAPI();
    [CompilerGeneratedAttribute]
public static void set_overrideAPI(SceneManagerAPI value);
    protected internal virtual int GetNumScenesInBuildSettings();
    protected internal virtual Scene GetSceneByBuildIndex(int buildIndex);
    protected internal virtual AsyncOperation LoadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame);
    protected internal virtual AsyncOperation UnloadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess);
    protected internal virtual AsyncOperation LoadFirstScene(bool mustLoadAsync);
}
[StaticAccessorAttribute("SceneManagerBindings", "2")]
[NativeHeaderAttribute("Runtime/SceneManager/SceneManager.h")]
[NativeHeaderAttribute("Runtime/Export/SceneManager/SceneManager.bindings.h")]
internal static class UnityEngine.SceneManagement.SceneManagerAPIInternal : object {
    public static int GetNumScenesInBuildSettings();
    [NativeThrowsAttribute]
public static Scene GetSceneByBuildIndex(int buildIndex);
    [NativeThrowsAttribute]
public static AsyncOperation LoadSceneAsyncNameIndexInternal(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame);
    [NativeThrowsAttribute]
public static AsyncOperation UnloadSceneNameIndexInternal(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess);
    private static void GetSceneByBuildIndex_Injected(int buildIndex, Scene& ret);
    private static AsyncOperation LoadSceneAsyncNameIndexInternal_Injected(string sceneName, int sceneBuildIndex, LoadSceneParameters& parameters, bool mustCompleteNextFrame);
}
[NativeHeaderAttribute("Runtime/Export/SceneManager/SceneUtility.bindings.h")]
public static class UnityEngine.SceneManagement.SceneUtility : object {
    [StaticAccessorAttribute("SceneUtilityBindings", "2")]
public static string GetScenePathByBuildIndex(int buildIndex);
    [StaticAccessorAttribute("SceneUtilityBindings", "2")]
public static int GetBuildIndexByScenePath(string scenePath);
}
[FlagsAttribute]
public enum UnityEngine.SceneManagement.UnloadSceneOptions : Enum {
    public int value__;
    public static UnloadSceneOptions None;
    public static UnloadSceneOptions UnloadAllEmbeddedSceneObjects;
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/WindowLayout.h")]
[StaticAccessorAttribute("GetScreenManager()", "0")]
[NativeHeaderAttribute("Runtime/Graphics/ScreenManager.h")]
public class UnityEngine.Screen : object {
    public static int width { get; }
    public static int height { get; }
    public static float dpi { get; }
    public static ScreenOrientation orientation { get; public set; }
    [NativePropertyAttribute("ScreenTimeout")]
public static int sleepTimeout { get; public set; }
    public static bool autorotateToPortrait { get; public set; }
    public static bool autorotateToPortraitUpsideDown { get; public set; }
    public static bool autorotateToLandscapeLeft { get; public set; }
    public static bool autorotateToLandscapeRight { get; public set; }
    public static Resolution currentResolution { get; }
    public static bool fullScreen { get; public set; }
    public static FullScreenMode fullScreenMode { get; public set; }
    public static Rect safeArea { get; }
    public static Rect[] cutouts { get; }
    public static Vector2Int mainWindowPosition { get; }
    public static DisplayInfo mainWindowDisplayInfo { get; }
    public static Resolution[] resolutions { get; }
    public static float brightness { get; public set; }
    [ObsoleteAttribute("Use Cursor.lockState and Cursor.visible instead.", "False")]
[EditorBrowsableAttribute("1")]
public static bool lockCursor { get; public set; }
    [NativeMethodAttribute]
public static int get_width();
    [NativeMethodAttribute]
public static int get_height();
    [NativeNameAttribute("GetDPI")]
public static float get_dpi();
    private static void RequestOrientation(ScreenOrientation orient);
    private static ScreenOrientation GetScreenOrientation();
    public static ScreenOrientation get_orientation();
    public static void set_orientation(ScreenOrientation value);
    public static int get_sleepTimeout();
    public static void set_sleepTimeout(int value);
    [NativeNameAttribute("GetIsOrientationEnabled")]
private static bool IsOrientationEnabled(EnabledOrientation orient);
    [NativeNameAttribute("SetIsOrientationEnabled")]
private static void SetOrientationEnabled(EnabledOrientation orient, bool enabled);
    public static bool get_autorotateToPortrait();
    public static void set_autorotateToPortrait(bool value);
    public static bool get_autorotateToPortraitUpsideDown();
    public static void set_autorotateToPortraitUpsideDown(bool value);
    public static bool get_autorotateToLandscapeLeft();
    public static void set_autorotateToLandscapeLeft(bool value);
    public static bool get_autorotateToLandscapeRight();
    public static void set_autorotateToLandscapeRight(bool value);
    public static Resolution get_currentResolution();
    [NativeNameAttribute("IsFullscreen")]
public static bool get_fullScreen();
    [NativeNameAttribute("RequestSetFullscreenFromScript")]
public static void set_fullScreen(bool value);
    [NativeNameAttribute("GetFullscreenMode")]
public static FullScreenMode get_fullScreenMode();
    [NativeNameAttribute("RequestSetFullscreenModeFromScript")]
public static void set_fullScreenMode(FullScreenMode value);
    public static Rect get_safeArea();
    [FreeFunctionAttribute("ScreenScripting::GetCutouts")]
public static Rect[] get_cutouts();
    [NativeNameAttribute("RequestResolution")]
public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, RefreshRate preferredRefreshRate);
    [ObsoleteAttribute("SetResolution(int, int, FullScreenMode, int) is obsolete. Use SetResolution(int, int, FullScreenMode, RefreshRate) instead.")]
[EditorBrowsableAttribute("1")]
public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate);
    public static void SetResolution(int width, int height, FullScreenMode fullscreenMode);
    [ObsoleteAttribute("SetResolution(int, int, bool, int) is obsolete. Use SetResolution(int, int, FullScreenMode, RefreshRate) instead.")]
[EditorBrowsableAttribute("1")]
public static void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate);
    public static void SetResolution(int width, int height, bool fullscreen);
    public static Vector2Int get_mainWindowPosition();
    public static DisplayInfo get_mainWindowDisplayInfo();
    public static void GetDisplayLayout(List`1<DisplayInfo> displayLayout);
    public static AsyncOperation MoveMainWindowTo(DisplayInfo& display, Vector2Int position);
    [FreeFunctionAttribute("GetMainWindowPosition")]
private static Vector2Int GetMainWindowPosition();
    [FreeFunctionAttribute("GetMainWindowDisplayInfo")]
private static DisplayInfo GetMainWindowDisplayInfo();
    [FreeFunctionAttribute("GetDisplayLayout")]
private static void GetDisplayLayoutImpl(List`1<DisplayInfo> displayLayout);
    [FreeFunctionAttribute("MoveMainWindow")]
private static AsyncOperation MoveMainWindowImpl(DisplayInfo& display, Vector2Int position);
    [FreeFunctionAttribute("ScreenScripting::GetResolutions")]
public static Resolution[] get_resolutions();
    public static float get_brightness();
    public static void set_brightness(float value);
    public static bool get_lockCursor();
    public static void set_lockCursor(bool value);
    private static void get_currentResolution_Injected(Resolution& ret);
    private static void get_safeArea_Injected(Rect& ret);
    private static void SetResolution_Injected(int width, int height, FullScreenMode fullscreenMode, RefreshRate& preferredRefreshRate);
    private static void GetMainWindowPosition_Injected(Vector2Int& ret);
    private static void GetMainWindowDisplayInfo_Injected(DisplayInfo& ret);
    private static AsyncOperation MoveMainWindowImpl_Injected(DisplayInfo& display, Vector2Int& position);
}
public enum UnityEngine.ScreenOrientation : Enum {
    public int value__;
    public static ScreenOrientation Portrait;
    public static ScreenOrientation PortraitUpsideDown;
    public static ScreenOrientation LandscapeLeft;
    public static ScreenOrientation LandscapeRight;
    public static ScreenOrientation AutoRotation;
    [ObsoleteAttribute("Enum member Unknown has been deprecated.", "False")]
public static ScreenOrientation Unknown;
    [ObsoleteAttribute("Use LandscapeLeft instead (UnityUpgradable) -> LandscapeLeft", "True")]
public static ScreenOrientation Landscape;
}
[NativeClassAttribute("")]
[ExtensionOfNativeClassAttribute]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Mono/MonoBehaviour.h")]
public class UnityEngine.ScriptableObject : Object {
    [ObsoleteAttribute("Use EditorUtility.SetDirty instead")]
[NativeConditionalAttribute("ENABLE_MONO")]
public void SetDirty();
    public static ScriptableObject CreateInstance(string className);
    public static ScriptableObject CreateInstance(Type type);
    public static T CreateInstance();
    [EditorBrowsableAttribute("1")]
internal static ScriptableObject CreateInstance(Type type, Action`1<ScriptableObject> initialize);
    [NativeMethodAttribute]
private static void CreateScriptableObject(ScriptableObject self);
    [FreeFunctionAttribute("Scripting::CreateScriptableObject")]
private static ScriptableObject CreateScriptableObjectInstanceFromName(string className);
    [NativeMethodAttribute]
internal static ScriptableObject CreateScriptableObjectInstanceFromType(Type type, bool applyDefaultsAndReset);
    [FreeFunctionAttribute("Scripting::ResetAndApplyDefaultInstances")]
internal static void ResetAndApplyDefaultInstances(Object obj);
}
[AttributeUsageAttribute("1")]
public class UnityEngine.Scripting.AlwaysLinkAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("5148")]
public class UnityEngine.Scripting.APIUpdating.MovedFromAttribute : Attribute {
    internal MovedFromAttributeData data;
    internal bool AffectsAPIUpdater { get; }
    public bool IsInDifferentAssembly { get; }
    public MovedFromAttribute(bool autoUpdateAPI, string sourceNamespace, string sourceAssembly, string sourceClassName);
    public MovedFromAttribute(string sourceNamespace);
    internal bool get_AffectsAPIUpdater();
    public bool get_IsInDifferentAssembly();
}
internal class UnityEngine.Scripting.APIUpdating.MovedFromAttributeData : ValueType {
    public string className;
    public string nameSpace;
    public string assembly;
    public bool classHasChanged;
    public bool nameSpaceHasChanged;
    public bool assemblyHasChanged;
    public bool autoUdpateAPI;
    public void Set(bool autoUpdateAPI, string sourceNamespace, string sourceAssembly, string sourceClassName);
}
[NativeHeaderAttribute("Runtime/Scripting/GarbageCollector.h")]
public static class UnityEngine.Scripting.GarbageCollector : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<Mode> GCModeChanged;
    public static Mode GCMode { get; public set; }
    public static bool isIncremental { get; }
    public static ulong incrementalTimeSliceNanoseconds { get; public set; }
    [CompilerGeneratedAttribute]
public static void add_GCModeChanged(Action`1<Mode> value);
    [CompilerGeneratedAttribute]
public static void remove_GCModeChanged(Action`1<Mode> value);
    public static Mode get_GCMode();
    public static void set_GCMode(Mode value);
    [NativeThrowsAttribute]
private static void SetMode(Mode mode);
    private static Mode GetMode();
    [NativeMethodAttribute("GetIncrementalEnabled")]
public static bool get_isIncremental();
    public static ulong get_incrementalTimeSliceNanoseconds();
    public static void set_incrementalTimeSliceNanoseconds(ulong value);
    [NativeThrowsAttribute]
[NativeMethodAttribute("CollectIncrementalWrapper")]
public static bool CollectIncremental(ulong nanoseconds);
}
[AttributeUsageAttribute("6141")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.Scripting.PreserveAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class UnityEngine.Scripting.RequireAttributeUsagesAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class UnityEngine.Scripting.RequireDerivedAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
public class UnityEngine.Scripting.RequiredInterfaceAttribute : Attribute {
    public RequiredInterfaceAttribute(Type interfaceType);
}
[AttributeUsageAttribute("992")]
public class UnityEngine.Scripting.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
public class UnityEngine.Scripting.RequireImplementorsAttribute : Attribute {
}
[VisibleToOtherModulesAttribute]
[NativeHeaderAttribute("Runtime/Export/Scripting/ScriptingRuntime.h")]
internal class UnityEngine.ScriptingRuntime : object {
    public static String[] GetAllUserAssemblies();
}
internal class UnityEngine.ScriptingUtility : object {
    [RequiredByNativeCodeAttribute]
private static bool IsManagedCodeWorking();
}
internal static class UnityEngine.ScrollWaitDefinitions : object {
    public static int firstWait;
    public static int regularWait;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.Search.SearchContextAttribute : PropertyAttribute {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <query>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private String[] <providerIds>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type[] <instantiableProviders>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private SearchViewFlags <flags>k__BackingField;
    public string query { get; private set; }
    public String[] providerIds { get; private set; }
    public Type[] instantiableProviders { get; private set; }
    public SearchViewFlags flags { get; private set; }
    public SearchContextAttribute(string query);
    public SearchContextAttribute(string query, SearchViewFlags flags);
    public SearchContextAttribute(string query, string providerIdsCommaSeparated);
    public SearchContextAttribute(string query, string providerIdsCommaSeparated, SearchViewFlags flags);
    public SearchContextAttribute(string query, Type[] instantiableProviders);
    public SearchContextAttribute(string query, SearchViewFlags flags, Type[] instantiableProviders);
    public SearchContextAttribute(string query, SearchViewFlags flags, string providerIdsCommaSeparated, Type[] instantiableProviders);
    [CompilerGeneratedAttribute]
public string get_query();
    [CompilerGeneratedAttribute]
private void set_query(string value);
    [CompilerGeneratedAttribute]
public String[] get_providerIds();
    [CompilerGeneratedAttribute]
private void set_providerIds(String[] value);
    [CompilerGeneratedAttribute]
public Type[] get_instantiableProviders();
    [CompilerGeneratedAttribute]
private void set_instantiableProviders(Type[] value);
    [CompilerGeneratedAttribute]
public SearchViewFlags get_flags();
    [CompilerGeneratedAttribute]
private void set_flags(SearchViewFlags value);
}
[FlagsAttribute]
public enum UnityEngine.Search.SearchViewFlags : Enum {
    public int value__;
    public static SearchViewFlags None;
    public static SearchViewFlags Debug;
    public static SearchViewFlags NoIndexing;
    public static SearchViewFlags Packages;
    public static SearchViewFlags OpenLeftSidePanel;
    public static SearchViewFlags OpenInspectorPreview;
    public static SearchViewFlags Centered;
    public static SearchViewFlags HideSearchBar;
    public static SearchViewFlags CompactView;
    public static SearchViewFlags ListView;
    public static SearchViewFlags GridView;
    public static SearchViewFlags TableView;
    public static SearchViewFlags EnableSearchQuery;
    public static SearchViewFlags DisableInspectorPreview;
    public static SearchViewFlags DisableSavedSearchQuery;
    public static SearchViewFlags OpenInBuilderMode;
    public static SearchViewFlags OpenInTextMode;
    public static SearchViewFlags DisableBuilderModeToggle;
    public static SearchViewFlags Borderless;
    public static SearchViewFlags DisableQueryHelpers;
    public static SearchViewFlags DisableNoResultTips;
    public static SearchViewFlags IgnoreSavedSearches;
    public static SearchViewFlags ObjectPicker;
    public static SearchViewFlags ObjectPickerAdvancedUI;
    public static SearchViewFlags ContextSwitchPreservedMask;
}
[AttributeUsageAttribute("256")]
[ObsoleteAttribute("ObjectSelectorHandlerWithLabelsAttribute has been deprecated. Use SearchContextAttribute instead.", "True")]
public class UnityEngine.SearchService.ObjectSelectorHandlerWithLabelsAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private String[] <labels>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <matchAll>k__BackingField;
    public String[] labels { get; }
    public bool matchAll { get; }
    public ObjectSelectorHandlerWithLabelsAttribute(String[] labels);
    public ObjectSelectorHandlerWithLabelsAttribute(bool matchAll, String[] labels);
    [CompilerGeneratedAttribute]
public String[] get_labels();
    [CompilerGeneratedAttribute]
public bool get_matchAll();
}
[ObsoleteAttribute("ObjectSelectorHandlerWithTagsAttribute has been deprecated. Use SearchContextAttribute instead.", "True")]
[AttributeUsageAttribute("256")]
public class UnityEngine.SearchService.ObjectSelectorHandlerWithTagsAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private String[] <tags>k__BackingField;
    public String[] tags { get; }
    public ObjectSelectorHandlerWithTagsAttribute(String[] tags);
    [CompilerGeneratedAttribute]
public String[] get_tags();
}
public class UnityEngine.SecondarySpriteTexture : ValueType {
    public string name;
    public Texture2D texture;
}
public class UnityEngine.Security : object {
    [ObsoleteAttribute("This was an internal method which is no longer used", "True")]
[EditorBrowsableAttribute("1")]
public static Assembly LoadAndVerifyAssembly(Byte[] assemblyData, string authorizationKey);
    [ObsoleteAttribute("This was an internal method which is no longer used", "True")]
[EditorBrowsableAttribute("1")]
public static Assembly LoadAndVerifyAssembly(Byte[] assemblyData);
    [ObsoleteAttribute("Security.PrefetchSocketPolicy is no longer supported, since the Unity Web Player is no longer supported by Unity.", "True")]
[ExcludeFromDocsAttribute]
public static bool PrefetchSocketPolicy(string ip, int atPort);
    [ObsoleteAttribute("Security.PrefetchSocketPolicy is no longer supported, since the Unity Web Player is no longer supported by Unity.", "True")]
public static bool PrefetchSocketPolicy(string ip, int atPort, int timeout);
}
[AttributeUsageAttribute("4")]
public class UnityEngine.SelectionBaseAttribute : Attribute {
}
public enum UnityEngine.SendMessageOptions : Enum {
    public int value__;
    public static SendMessageOptions RequireReceiver;
    public static SendMessageOptions DontRequireReceiver;
}
internal class UnityEngine.Serialization.DictionarySerializationSurrogate`2 : object {
    public sealed virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    public sealed virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.Serialization.FormerlySerializedAsAttribute : Attribute {
    private string m_oldName;
    public string oldName { get; }
    public FormerlySerializedAsAttribute(string oldName);
    public string get_oldName();
}
internal class UnityEngine.Serialization.ListSerializationSurrogate : object {
    public static ISerializationSurrogate Default;
    private static ListSerializationSurrogate();
    public sealed virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    public sealed virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
    private static Array ArrayFromGenericList(IList list);
}
[NativeHeaderAttribute("Runtime/Serialize/ManagedReferenceUtility.h")]
public class UnityEngine.Serialization.ManagedReferenceUtility : object {
    public static long RefIdUnknown;
    public static long RefIdNull;
    [NativeMethodAttribute("SetManagedReferenceIdForObject")]
private static bool SetManagedReferenceIdForObjectInternal(Object obj, object scriptObj, long refId);
    public static bool SetManagedReferenceIdForObject(Object obj, object scriptObj, long refId);
    [NativeMethodAttribute("GetManagedReferenceIdForObject")]
private static long GetManagedReferenceIdForObjectInternal(Object obj, object scriptObj);
    public static long GetManagedReferenceIdForObject(Object obj, object scriptObj);
    [NativeMethodAttribute("GetManagedReference")]
private static object GetManagedReferenceInternal(Object obj, long id);
    public static object GetManagedReference(Object obj, long id);
    [NativeMethodAttribute("GetManagedReferenceIds")]
private static Int64[] GetManagedReferenceIdsForObjectInternal(Object obj);
    public static Int64[] GetManagedReferenceIds(Object obj);
}
public class UnityEngine.Serialization.UnitySurrogateSelector : object {
    public sealed virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    public sealed virtual void ChainSelector(ISurrogateSelector selector);
    public sealed virtual ISurrogateSelector GetNextSelector();
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.SerializeField : Attribute {
}
[AttributeUsageAttribute("256")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.SerializeReference : Attribute {
}
[RequiredByNativeCodeAttribute]
internal class UnityEngine.SetupCoroutine : object {
    [SecuritySafeCriticalAttribute]
[RequiredByNativeCodeAttribute]
public static void InvokeMoveNext(IEnumerator enumerator, IntPtr returnValueAddress);
    [RequiredByNativeCodeAttribute]
public static object InvokeMember(object behaviour, string name, object variable);
    public static object InvokeStatic(Type klass, string name, object variable);
}
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/ShaderNameRegistry.h")]
[NativeHeaderAttribute("Runtime/Graphics/ShaderScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Misc/ResourceManager.h")]
[NativeHeaderAttribute("Runtime/Shaders/Shader.h")]
[NativeHeaderAttribute("Runtime/Shaders/Keywords/KeywordSpaceScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/ComputeShader.h")]
[NativeHeaderAttribute("Runtime/Shaders/GpuPrograms/ShaderVariantCollection.h")]
public class UnityEngine.Shader : Object {
    [ObsoleteAttribute("Use Graphics.activeTier instead (UnityUpgradable) -> UnityEngine.Graphics.activeTier", "False")]
public static ShaderHardwareTier globalShaderHardwareTier { get; public set; }
    [NativePropertyAttribute("MaxChunksRuntimeOverride")]
public static int maximumChunksOverride { get; public set; }
    [NativePropertyAttribute("MaximumShaderLOD")]
public int maximumLOD { get; public set; }
    [NativePropertyAttribute("GlobalMaximumShaderLOD")]
public static int globalMaximumLOD { get; public set; }
    public bool isSupported { get; }
    public static string globalRenderPipeline { get; public set; }
    public static GlobalKeyword[] enabledGlobalKeywords { get; }
    public static GlobalKeyword[] globalKeywords { get; }
    public LocalKeywordSpace keywordSpace { get; }
    public int renderQueue { get; }
    internal DisableBatchingType disableBatching { get; }
    public int passCount { get; }
    public int subshaderCount { get; }
    public static ShaderHardwareTier get_globalShaderHardwareTier();
    public static void set_globalShaderHardwareTier(ShaderHardwareTier value);
    public static Shader Find(string name);
    [FreeFunctionAttribute("GetBuiltinResource<Shader>")]
internal static Shader FindBuiltin(string name);
    public static int get_maximumChunksOverride();
    public static void set_maximumChunksOverride(int value);
    public int get_maximumLOD();
    public void set_maximumLOD(int value);
    public static int get_globalMaximumLOD();
    public static void set_globalMaximumLOD(int value);
    [NativeMethodAttribute("IsSupported")]
public bool get_isSupported();
    public static string get_globalRenderPipeline();
    public static void set_globalRenderPipeline(string value);
    public static GlobalKeyword[] get_enabledGlobalKeywords();
    public static GlobalKeyword[] get_globalKeywords();
    public LocalKeywordSpace get_keywordSpace();
    [FreeFunctionAttribute("keywords::GetEnabledGlobalKeywords")]
internal static GlobalKeyword[] GetEnabledGlobalKeywords();
    [FreeFunctionAttribute("keywords::GetAllGlobalKeywords")]
internal static GlobalKeyword[] GetAllGlobalKeywords();
    [FreeFunctionAttribute("ShaderScripting::EnableKeyword")]
public static void EnableKeyword(string keyword);
    [FreeFunctionAttribute("ShaderScripting::DisableKeyword")]
public static void DisableKeyword(string keyword);
    [FreeFunctionAttribute("ShaderScripting::IsKeywordEnabled")]
public static bool IsKeywordEnabled(string keyword);
    [FreeFunctionAttribute("ShaderScripting::EnableKeyword")]
internal static void EnableKeywordFast(GlobalKeyword keyword);
    [FreeFunctionAttribute("ShaderScripting::DisableKeyword")]
internal static void DisableKeywordFast(GlobalKeyword keyword);
    [FreeFunctionAttribute("ShaderScripting::SetKeyword")]
internal static void SetKeywordFast(GlobalKeyword keyword, bool value);
    [FreeFunctionAttribute("ShaderScripting::IsKeywordEnabled")]
internal static bool IsKeywordEnabledFast(GlobalKeyword keyword);
    public static void EnableKeyword(GlobalKeyword& keyword);
    public static void DisableKeyword(GlobalKeyword& keyword);
    public static void SetKeyword(GlobalKeyword& keyword, bool value);
    public static bool IsKeywordEnabled(GlobalKeyword& keyword);
    [FreeFunctionAttribute("ShaderScripting::GetRenderQueue")]
public int get_renderQueue();
    [FreeFunctionAttribute("ShaderScripting::GetDisableBatchingType")]
internal DisableBatchingType get_disableBatching();
    [FreeFunctionAttribute]
public static void WarmupAllShaders();
    [FreeFunctionAttribute("ShaderScripting::TagToID")]
internal static int TagToID(string name);
    [FreeFunctionAttribute("ShaderScripting::IDToTag")]
internal static string IDToTag(int name);
    [FreeFunctionAttribute]
public static int PropertyToID(string name);
    public Shader GetDependency(string name);
    [FreeFunctionAttribute]
public int get_passCount();
    [FreeFunctionAttribute]
public int get_subshaderCount();
    [FreeFunctionAttribute]
public int GetPassCountInSubshader(int subshaderIndex);
    public ShaderTagId FindPassTagValue(int passIndex, ShaderTagId tagName);
    public ShaderTagId FindPassTagValue(int subshaderIndex, int passIndex, ShaderTagId tagName);
    public ShaderTagId FindSubshaderTagValue(int subshaderIndex, ShaderTagId tagName);
    [FreeFunctionAttribute]
private int Internal_FindPassTagValue(int passIndex, int tagName);
    [FreeFunctionAttribute]
private int Internal_FindPassTagValueInSubShader(int subShaderIndex, int passIndex, int tagName);
    [FreeFunctionAttribute]
private int Internal_FindSubshaderTagValue(int subShaderIndex, int tagName);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalInt")]
private static void SetGlobalIntImpl(int name, int value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalFloat")]
private static void SetGlobalFloatImpl(int name, float value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalVector")]
private static void SetGlobalVectorImpl(int name, Vector4 value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalMatrix")]
private static void SetGlobalMatrixImpl(int name, Matrix4x4 value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalTexture")]
private static void SetGlobalTextureImpl(int name, Texture value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalRenderTexture")]
private static void SetGlobalRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalBuffer")]
private static void SetGlobalBufferImpl(int name, ComputeBuffer value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalBuffer")]
private static void SetGlobalGraphicsBufferImpl(int name, GraphicsBuffer value);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalConstantBuffer")]
private static void SetGlobalConstantBufferImpl(int name, ComputeBuffer value, int offset, int size);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalConstantBuffer")]
private static void SetGlobalConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalInt")]
private static int GetGlobalIntImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalFloat")]
private static float GetGlobalFloatImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalVector")]
private static Vector4 GetGlobalVectorImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalMatrix")]
private static Matrix4x4 GetGlobalMatrixImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalTexture")]
private static Texture GetGlobalTextureImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalFloatArray")]
private static void SetGlobalFloatArrayImpl(int name, Single[] values, int count);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalVectorArray")]
private static void SetGlobalVectorArrayImpl(int name, Vector4[] values, int count);
    [FreeFunctionAttribute("ShaderScripting::SetGlobalMatrixArray")]
private static void SetGlobalMatrixArrayImpl(int name, Matrix4x4[] values, int count);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalFloatArray")]
private static Single[] GetGlobalFloatArrayImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalVectorArray")]
private static Vector4[] GetGlobalVectorArrayImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalMatrixArray")]
private static Matrix4x4[] GetGlobalMatrixArrayImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalFloatArrayCount")]
private static int GetGlobalFloatArrayCountImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalVectorArrayCount")]
private static int GetGlobalVectorArrayCountImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::GetGlobalMatrixArrayCount")]
private static int GetGlobalMatrixArrayCountImpl(int name);
    [FreeFunctionAttribute("ShaderScripting::ExtractGlobalFloatArray")]
private static void ExtractGlobalFloatArrayImpl(int name, Single[] val);
    [FreeFunctionAttribute("ShaderScripting::ExtractGlobalVectorArray")]
private static void ExtractGlobalVectorArrayImpl(int name, Vector4[] val);
    [FreeFunctionAttribute("ShaderScripting::ExtractGlobalMatrixArray")]
private static void ExtractGlobalMatrixArrayImpl(int name, Matrix4x4[] val);
    private static void SetGlobalFloatArray(int name, Single[] values, int count);
    private static void SetGlobalVectorArray(int name, Vector4[] values, int count);
    private static void SetGlobalMatrixArray(int name, Matrix4x4[] values, int count);
    private static void ExtractGlobalFloatArray(int name, List`1<float> values);
    private static void ExtractGlobalVectorArray(int name, List`1<Vector4> values);
    private static void ExtractGlobalMatrixArray(int name, List`1<Matrix4x4> values);
    public static void SetGlobalInt(string name, int value);
    public static void SetGlobalInt(int nameID, int value);
    public static void SetGlobalFloat(string name, float value);
    public static void SetGlobalFloat(int nameID, float value);
    public static void SetGlobalInteger(string name, int value);
    public static void SetGlobalInteger(int nameID, int value);
    public static void SetGlobalVector(string name, Vector4 value);
    public static void SetGlobalVector(int nameID, Vector4 value);
    public static void SetGlobalColor(string name, Color value);
    public static void SetGlobalColor(int nameID, Color value);
    public static void SetGlobalMatrix(string name, Matrix4x4 value);
    public static void SetGlobalMatrix(int nameID, Matrix4x4 value);
    public static void SetGlobalTexture(string name, Texture value);
    public static void SetGlobalTexture(int nameID, Texture value);
    public static void SetGlobalTexture(string name, RenderTexture value, RenderTextureSubElement element);
    public static void SetGlobalTexture(int nameID, RenderTexture value, RenderTextureSubElement element);
    public static void SetGlobalBuffer(string name, ComputeBuffer value);
    public static void SetGlobalBuffer(int nameID, ComputeBuffer value);
    public static void SetGlobalBuffer(string name, GraphicsBuffer value);
    public static void SetGlobalBuffer(int nameID, GraphicsBuffer value);
    public static void SetGlobalConstantBuffer(string name, ComputeBuffer value, int offset, int size);
    public static void SetGlobalConstantBuffer(int nameID, ComputeBuffer value, int offset, int size);
    public static void SetGlobalConstantBuffer(string name, GraphicsBuffer value, int offset, int size);
    public static void SetGlobalConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size);
    public static void SetGlobalFloatArray(string name, List`1<float> values);
    public static void SetGlobalFloatArray(int nameID, List`1<float> values);
    public static void SetGlobalFloatArray(string name, Single[] values);
    public static void SetGlobalFloatArray(int nameID, Single[] values);
    public static void SetGlobalVectorArray(string name, List`1<Vector4> values);
    public static void SetGlobalVectorArray(int nameID, List`1<Vector4> values);
    public static void SetGlobalVectorArray(string name, Vector4[] values);
    public static void SetGlobalVectorArray(int nameID, Vector4[] values);
    public static void SetGlobalMatrixArray(string name, List`1<Matrix4x4> values);
    public static void SetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values);
    public static void SetGlobalMatrixArray(string name, Matrix4x4[] values);
    public static void SetGlobalMatrixArray(int nameID, Matrix4x4[] values);
    public static int GetGlobalInt(string name);
    public static int GetGlobalInt(int nameID);
    public static float GetGlobalFloat(string name);
    public static float GetGlobalFloat(int nameID);
    public static int GetGlobalInteger(string name);
    public static int GetGlobalInteger(int nameID);
    public static Vector4 GetGlobalVector(string name);
    public static Vector4 GetGlobalVector(int nameID);
    public static Color GetGlobalColor(string name);
    public static Color GetGlobalColor(int nameID);
    public static Matrix4x4 GetGlobalMatrix(string name);
    public static Matrix4x4 GetGlobalMatrix(int nameID);
    public static Texture GetGlobalTexture(string name);
    public static Texture GetGlobalTexture(int nameID);
    public static Single[] GetGlobalFloatArray(string name);
    public static Single[] GetGlobalFloatArray(int nameID);
    public static Vector4[] GetGlobalVectorArray(string name);
    public static Vector4[] GetGlobalVectorArray(int nameID);
    public static Matrix4x4[] GetGlobalMatrixArray(string name);
    public static Matrix4x4[] GetGlobalMatrixArray(int nameID);
    public static void GetGlobalFloatArray(string name, List`1<float> values);
    public static void GetGlobalFloatArray(int nameID, List`1<float> values);
    public static void GetGlobalVectorArray(string name, List`1<Vector4> values);
    public static void GetGlobalVectorArray(int nameID, List`1<Vector4> values);
    public static void GetGlobalMatrixArray(string name, List`1<Matrix4x4> values);
    public static void GetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyName")]
private static string GetPropertyName(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyNameId")]
private static int GetPropertyNameId(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyType")]
private static ShaderPropertyType GetPropertyType(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyDescription")]
private static string GetPropertyDescription(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyFlags")]
private static ShaderPropertyFlags GetPropertyFlags(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyAttributes")]
private static String[] GetPropertyAttributes(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyDefaultIntValue")]
private static int GetPropertyDefaultIntValue(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyDefaultValue")]
private static Vector4 GetPropertyDefaultValue(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyTextureDimension")]
private static TextureDimension GetPropertyTextureDimension(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::GetPropertyTextureDefaultName")]
private static string GetPropertyTextureDefaultName(Shader shader, int propertyIndex);
    [FreeFunctionAttribute("ShaderScripting::FindTextureStack")]
private static bool FindTextureStackImpl(Shader s, int propertyIdx, String& stackName, Int32& layerIndex);
    private static void CheckPropertyIndex(Shader s, int propertyIndex);
    public int GetPropertyCount();
    public int FindPropertyIndex(string propertyName);
    public string GetPropertyName(int propertyIndex);
    public int GetPropertyNameId(int propertyIndex);
    public ShaderPropertyType GetPropertyType(int propertyIndex);
    public string GetPropertyDescription(int propertyIndex);
    public ShaderPropertyFlags GetPropertyFlags(int propertyIndex);
    public String[] GetPropertyAttributes(int propertyIndex);
    public float GetPropertyDefaultFloatValue(int propertyIndex);
    public Vector4 GetPropertyDefaultVectorValue(int propertyIndex);
    public Vector2 GetPropertyRangeLimits(int propertyIndex);
    public int GetPropertyDefaultIntValue(int propertyIndex);
    public TextureDimension GetPropertyTextureDimension(int propertyIndex);
    public string GetPropertyTextureDefaultName(int propertyIndex);
    public bool FindTextureStack(int propertyIndex, String& stackName, Int32& layerIndex);
    private void get_keywordSpace_Injected(LocalKeywordSpace& ret);
    private static void EnableKeywordFast_Injected(GlobalKeyword& keyword);
    private static void DisableKeywordFast_Injected(GlobalKeyword& keyword);
    private static void SetKeywordFast_Injected(GlobalKeyword& keyword, bool value);
    private static bool IsKeywordEnabledFast_Injected(GlobalKeyword& keyword);
    private static void SetGlobalVectorImpl_Injected(int name, Vector4& value);
    private static void SetGlobalMatrixImpl_Injected(int name, Matrix4x4& value);
    private static void GetGlobalVectorImpl_Injected(int name, Vector4& ret);
    private static void GetGlobalMatrixImpl_Injected(int name, Matrix4x4& ret);
    private static void GetPropertyDefaultValue_Injected(Shader shader, int propertyIndex, Vector4& ret);
}
public class UnityEngine.ShaderVariantCollection : Object {
    public int shaderCount { get; }
    public int variantCount { get; }
    public int warmedUpVariantCount { get; }
    public bool isWarmedUp { get; }
    public int get_shaderCount();
    public int get_variantCount();
    public int get_warmedUpVariantCount();
    [NativeNameAttribute("IsWarmedUp")]
public bool get_isWarmedUp();
    private bool AddVariant(Shader shader, PassType passType, String[] keywords);
    private bool RemoveVariant(Shader shader, PassType passType, String[] keywords);
    private bool ContainsVariant(Shader shader, PassType passType, String[] keywords);
    [NativeNameAttribute("ClearVariants")]
public void Clear();
    [NativeNameAttribute("WarmupShaders")]
public void WarmUp();
    [NativeNameAttribute("WarmupShadersProgressively")]
public bool WarmUpProgressively(int variantCount);
    [NativeNameAttribute("CreateFromScript")]
private static void Internal_Create(ShaderVariantCollection svc);
    public bool Add(ShaderVariant variant);
    public bool Remove(ShaderVariant variant);
    public bool Contains(ShaderVariant variant);
}
public enum UnityEngine.ShadowmaskMode : Enum {
    public int value__;
    public static ShadowmaskMode Shadowmask;
    public static ShadowmaskMode DistanceShadowmask;
}
public enum UnityEngine.ShadowObjectsFilter : Enum {
    public int value__;
    public static ShadowObjectsFilter AllObjects;
    public static ShadowObjectsFilter DynamicOnly;
    public static ShadowObjectsFilter StaticOnly;
}
public enum UnityEngine.ShadowProjection : Enum {
    public int value__;
    public static ShadowProjection CloseFit;
    public static ShadowProjection StableFit;
}
public enum UnityEngine.ShadowQuality : Enum {
    public int value__;
    public static ShadowQuality Disable;
    public static ShadowQuality HardOnly;
    public static ShadowQuality All;
}
public enum UnityEngine.ShadowResolution : Enum {
    public int value__;
    public static ShadowResolution Low;
    public static ShadowResolution Medium;
    public static ShadowResolution High;
    public static ShadowResolution VeryHigh;
}
[NativeHeaderAttribute("Runtime/Graphics/Mesh/SkinnedMeshRenderer.h")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.SkinnedMeshRenderer : Renderer {
    public SkinQuality quality { get; public set; }
    public bool updateWhenOffscreen { get; public set; }
    public bool forceMatrixRecalculationPerRender { get; public set; }
    public Transform rootBone { get; public set; }
    public Transform[] bones { get; public set; }
    [NativePropertyAttribute("Mesh")]
public Mesh sharedMesh { get; public set; }
    [NativePropertyAttribute("SkinnedMeshMotionVectors")]
public bool skinnedMotionVectors { get; public set; }
    public Target vertexBufferTarget { get; public set; }
    public SkinQuality get_quality();
    public void set_quality(SkinQuality value);
    public bool get_updateWhenOffscreen();
    public void set_updateWhenOffscreen(bool value);
    public bool get_forceMatrixRecalculationPerRender();
    public void set_forceMatrixRecalculationPerRender(bool value);
    public Transform get_rootBone();
    public void set_rootBone(Transform value);
    public Transform[] get_bones();
    public void set_bones(Transform[] value);
    public Mesh get_sharedMesh();
    public void set_sharedMesh(Mesh value);
    public bool get_skinnedMotionVectors();
    public void set_skinnedMotionVectors(bool value);
    public float GetBlendShapeWeight(int index);
    public void SetBlendShapeWeight(int index, float value);
    public void BakeMesh(Mesh mesh);
    public void BakeMesh(Mesh mesh, bool useScale);
    public GraphicsBuffer GetVertexBuffer();
    public GraphicsBuffer GetPreviousVertexBuffer();
    [FreeFunctionAttribute]
private GraphicsBuffer GetVertexBufferImpl();
    [FreeFunctionAttribute]
private GraphicsBuffer GetPreviousVertexBufferImpl();
    public Target get_vertexBufferTarget();
    public void set_vertexBufferTarget(Target value);
}
public enum UnityEngine.SkinQuality : Enum {
    public int value__;
    public static SkinQuality Auto;
    public static SkinQuality Bone1;
    public static SkinQuality Bone2;
    public static SkinQuality Bone4;
}
public enum UnityEngine.SkinWeights : Enum {
    public int value__;
    public static SkinWeights None;
    public static SkinWeights OneBone;
    public static SkinWeights TwoBones;
    public static SkinWeights FourBones;
    public static SkinWeights Unlimited;
}
[NativeHeaderAttribute("Runtime/Camera/Skybox.h")]
public class UnityEngine.Skybox : Behaviour {
    public Material material { get; public set; }
    public Material get_material();
    public void set_material(Material value);
}
public class UnityEngine.SleepTimeout : object {
    public static int NeverSleep;
    public static int SystemSetting;
}
[FlagsAttribute]
public enum UnityEngine.SnapAxis : Enum {
    public byte value__;
    public static SnapAxis None;
    public static SnapAxis X;
    public static SnapAxis Y;
    public static SnapAxis Z;
    public static SnapAxis All;
}
[DefaultMemberAttribute("Item")]
internal class UnityEngine.SnapAxisFilter : ValueType {
    private static SnapAxis X;
    private static SnapAxis Y;
    private static SnapAxis Z;
    public static SnapAxisFilter all;
    private SnapAxis m_Mask;
    public float x { get; }
    public float y { get; }
    public float z { get; }
    public int active { get; }
    public float Item { get; public set; }
    public SnapAxisFilter(Vector3 v);
    public SnapAxisFilter(SnapAxis axis);
    private static SnapAxisFilter();
    public float get_x();
    public float get_y();
    public float get_z();
    public virtual string ToString();
    public int get_active();
    public static Vector3 op_Implicit(SnapAxisFilter mask);
    public static SnapAxisFilter op_Explicit(Vector3 v);
    public static SnapAxis op_Explicit(SnapAxisFilter mask);
    public static SnapAxisFilter op_BitwiseOr(SnapAxisFilter left, SnapAxisFilter right);
    public static SnapAxisFilter op_BitwiseAnd(SnapAxisFilter left, SnapAxisFilter right);
    public static SnapAxisFilter op_ExclusiveOr(SnapAxisFilter left, SnapAxisFilter right);
    public static SnapAxisFilter op_OnesComplement(SnapAxisFilter left);
    public static Vector3 op_Multiply(SnapAxisFilter mask, float value);
    public static Vector3 op_Multiply(SnapAxisFilter mask, Vector3 right);
    public static Vector3 op_Multiply(Quaternion rotation, SnapAxisFilter mask);
    public static bool op_Equality(SnapAxisFilter left, SnapAxisFilter right);
    public static bool op_Inequality(SnapAxisFilter left, SnapAxisFilter right);
    public float get_Item(int i);
    public void set_Item(int i, float value);
    public sealed virtual bool Equals(SnapAxisFilter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class UnityEngine.Snapping : object {
    internal static bool IsCardinalDirection(Vector3 direction);
    public static float Snap(float val, float snap);
    public static Vector2 Snap(Vector2 val, Vector2 snap);
    public static Vector3 Snap(Vector3 val, Vector3 snap, SnapAxis axis);
}
[NativeHeaderAttribute("Runtime/BaseClasses/TagManager.h")]
public class UnityEngine.SortingLayer : ValueType {
    private int m_Id;
    public static LayerCallback onLayerAdded;
    public static LayerCallback onLayerRemoved;
    public int id { get; }
    public string name { get; }
    public int value { get; }
    public static SortingLayer[] layers { get; }
    public int get_id();
    public string get_name();
    public int get_value();
    public static SortingLayer[] get_layers();
    [FreeFunctionAttribute("GetTagManager().GetSortingLayerIDs")]
private static Int32[] GetSortingLayerIDsInternal();
    [FreeFunctionAttribute("GetTagManager().GetSortingLayerValueFromUniqueID")]
public static int GetLayerValueFromID(int id);
    [FreeFunctionAttribute("GetTagManager().GetSortingLayerValueFromName")]
public static int GetLayerValueFromName(string name);
    [FreeFunctionAttribute("GetTagManager().GetSortingLayerUniqueIDFromName")]
public static int NameToID(string name);
    [FreeFunctionAttribute("GetTagManager().GetSortingLayerNameFromUniqueID")]
public static string IDToName(int id);
    [FreeFunctionAttribute("GetTagManager().IsSortingLayerUniqueIDValid")]
public static bool IsValid(int id);
}
public enum UnityEngine.Space : Enum {
    public int value__;
    public static Space World;
    public static Space Self;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.SpaceAttribute : PropertyAttribute {
    public float height;
    public SpaceAttribute(float height);
}
[NativeHeaderAttribute("Runtime/Graphics/SparseTexture.h")]
public class UnityEngine.SparseTexture : Texture {
    public int tileWidth { get; }
    public int tileHeight { get; }
    public bool isCreated { get; }
    [ExcludeFromDocsAttribute]
public SparseTexture(int width, int height, DefaultFormat format, int mipCount);
    [ExcludeFromDocsAttribute]
public SparseTexture(int width, int height, GraphicsFormat format, int mipCount);
    [ExcludeFromDocsAttribute]
public SparseTexture(int width, int height, TextureFormat textureFormat, int mipCount);
    public SparseTexture(int width, int height, TextureFormat textureFormat, int mipCount, bool linear);
    public int get_tileWidth();
    public int get_tileHeight();
    [NativeNameAttribute("IsInitialized")]
public bool get_isCreated();
    [FreeFunctionAttribute]
private static void Internal_Create(SparseTexture mono, int width, int height, GraphicsFormat format, TextureColorSpace colorSpace, int mipCount);
    [FreeFunctionAttribute]
public void UpdateTile(int tileX, int tileY, int miplevel, Color32[] data);
    [FreeFunctionAttribute]
public void UpdateTileRaw(int tileX, int tileY, int miplevel, Byte[] data);
    public void UnloadTile(int tileX, int tileY, int miplevel);
    internal bool ValidateFormat(TextureFormat format, int width, int height);
    internal bool ValidateFormat(GraphicsFormat format, int width, int height);
    internal bool ValidateSize(int width, int height, GraphicsFormat format);
    private static void ValidateIsNotCrunched(TextureFormat textureFormat);
}
internal static class UnityEngine.SpookyHash : object {
    private static bool AllowUnalignedRead;
    private static int k_NumVars;
    private static int k_BlockSize;
    private static int k_BufferSize;
    private static ulong k_DeadBeefConst;
    private static SpookyHash();
    private static bool AttemptDetectAllowUnalignedRead();
    public static void Hash(Void* message, ulong length, UInt64* hash1, UInt64* hash2);
    private static void End(UInt64* data, UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3, UInt64& h4, UInt64& h5, UInt64& h6, UInt64& h7, UInt64& h8, UInt64& h9, UInt64& h10, UInt64& h11);
    private static void EndPartial(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3, UInt64& h4, UInt64& h5, UInt64& h6, UInt64& h7, UInt64& h8, UInt64& h9, UInt64& h10, UInt64& h11);
    private static void Rot64(UInt64& x, int k);
    private static void Short(Void* message, ulong length, UInt64* hash1, UInt64* hash2);
    private static void ShortMix(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3);
    private static void ShortEnd(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3);
    private static void Mix(UInt64* data, UInt64& s0, UInt64& s1, UInt64& s2, UInt64& s3, UInt64& s4, UInt64& s5, UInt64& s6, UInt64& s7, UInt64& s8, UInt64& s9, UInt64& s10, UInt64& s11);
    private static void memset(Void* dst, int value, ulong numberOfBytes);
}
[ExcludeFromPresetAttribute]
[NativeHeaderAttribute("Runtime/2D/Common/ScriptBindings/SpritesMarshalling.h")]
[NativeHeaderAttribute("Runtime/Graphics/SpriteUtility.h")]
[NativeHeaderAttribute("Runtime/2D/Common/SpriteDataAccess.h")]
[NativeTypeAttribute("Runtime/Graphics/SpriteFrame.h")]
public class UnityEngine.Sprite : Object {
    public Bounds bounds { get; }
    public Rect rect { get; }
    public Vector4 border { get; }
    public Texture2D texture { get; }
    public float pixelsPerUnit { get; }
    public float spriteAtlasTextureScale { get; }
    public Texture2D associatedAlphaSplitTexture { get; }
    public Vector2 pivot { get; }
    public bool packed { get; }
    public SpritePackingMode packingMode { get; }
    public SpritePackingRotation packingRotation { get; }
    public Rect textureRect { get; }
    public Vector2 textureRectOffset { get; }
    public Vector2[] vertices { get; }
    public UInt16[] triangles { get; }
    public Vector2[] uv { get; }
    internal int GetPackingMode();
    internal int GetPackingRotation();
    internal int GetPacked();
    internal Rect GetTextureRect();
    internal Vector2 GetTextureRectOffset();
    internal Vector4 GetInnerUVs();
    internal Vector4 GetOuterUVs();
    internal Vector4 GetPadding();
    [FreeFunctionAttribute("SpritesBindings::CreateSpriteWithoutTextureScripting")]
internal static Sprite CreateSpriteWithoutTextureScripting(Rect rect, Vector2 pivot, float pixelsToUnits, Texture2D texture);
    [FreeFunctionAttribute("SpritesBindings::CreateSprite")]
internal static Sprite CreateSprite(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape, SecondarySpriteTexture[] secondaryTexture);
    public Bounds get_bounds();
    public Rect get_rect();
    public Vector4 get_border();
    public Texture2D get_texture();
    internal Texture2D GetSecondaryTexture(int index);
    public int GetSecondaryTextureCount();
    [FreeFunctionAttribute("SpritesBindings::GetSecondaryTextures")]
public int GetSecondaryTextures(SecondarySpriteTexture[] secondaryTexture);
    [NativeMethodAttribute("GetPixelsToUnits")]
public float get_pixelsPerUnit();
    [NativeMethodAttribute("GetSpriteAtlasTextureScale")]
public float get_spriteAtlasTextureScale();
    [NativeMethodAttribute("GetAlphaTexture")]
public Texture2D get_associatedAlphaSplitTexture();
    [NativeMethodAttribute("GetPivotInPixels")]
public Vector2 get_pivot();
    public bool get_packed();
    public SpritePackingMode get_packingMode();
    public SpritePackingRotation get_packingRotation();
    public Rect get_textureRect();
    public Vector2 get_textureRectOffset();
    [FreeFunctionAttribute("SpriteAccessLegacy::GetSpriteVertices")]
public Vector2[] get_vertices();
    [FreeFunctionAttribute("SpriteAccessLegacy::GetSpriteIndices")]
public UInt16[] get_triangles();
    [FreeFunctionAttribute("SpriteAccessLegacy::GetSpriteUVs")]
public Vector2[] get_uv();
    public int GetPhysicsShapeCount();
    public int GetPhysicsShapePointCount(int shapeIdx);
    [NativeMethodAttribute("GetPhysicsShapePointCount")]
private int Internal_GetPhysicsShapePointCount(int shapeIdx);
    public int GetPhysicsShape(int shapeIdx, List`1<Vector2> physicsShape);
    [FreeFunctionAttribute("SpritesBindings::GetPhysicsShape")]
private static void GetPhysicsShapeImpl(Sprite sprite, int shapeIdx, List`1<Vector2> physicsShape);
    public void OverridePhysicsShape(IList`1<Vector2[]> physicsShapes);
    [FreeFunctionAttribute("SpritesBindings::OverridePhysicsShapeCount")]
private static void OverridePhysicsShapeCount(Sprite sprite, int physicsShapeCount);
    [FreeFunctionAttribute("SpritesBindings::OverridePhysicsShape")]
private static void OverridePhysicsShape(Sprite sprite, Vector2[] physicsShape, int idx);
    [FreeFunctionAttribute("SpritesBindings::OverrideGeometry")]
public void OverrideGeometry(Vector2[] vertices, UInt16[] triangles);
    internal static Sprite Create(Rect rect, Vector2 pivot, float pixelsToUnits, Texture2D texture);
    internal static Sprite Create(Rect rect, Vector2 pivot, float pixelsToUnits);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape, SecondarySpriteTexture[] secondaryTextures);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit);
    public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot);
    private void GetTextureRect_Injected(Rect& ret);
    private void GetTextureRectOffset_Injected(Vector2& ret);
    private void GetInnerUVs_Injected(Vector4& ret);
    private void GetOuterUVs_Injected(Vector4& ret);
    private void GetPadding_Injected(Vector4& ret);
    private static Sprite CreateSpriteWithoutTextureScripting_Injected(Rect& rect, Vector2& pivot, float pixelsToUnits, Texture2D texture);
    private static Sprite CreateSprite_Injected(Texture2D texture, Rect& rect, Vector2& pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4& border, bool generateFallbackPhysicsShape, SecondarySpriteTexture[] secondaryTexture);
    private void get_bounds_Injected(Bounds& ret);
    private void get_rect_Injected(Rect& ret);
    private void get_border_Injected(Vector4& ret);
    private void get_pivot_Injected(Vector2& ret);
}
public enum UnityEngine.SpriteAlignment : Enum {
    public int value__;
    public static SpriteAlignment Center;
    public static SpriteAlignment TopLeft;
    public static SpriteAlignment TopCenter;
    public static SpriteAlignment TopRight;
    public static SpriteAlignment LeftCenter;
    public static SpriteAlignment RightCenter;
    public static SpriteAlignment BottomLeft;
    public static SpriteAlignment BottomCenter;
    public static SpriteAlignment BottomRight;
    public static SpriteAlignment Custom;
}
public enum UnityEngine.SpriteDrawMode : Enum {
    public int value__;
    public static SpriteDrawMode Simple;
    public static SpriteDrawMode Sliced;
    public static SpriteDrawMode Tiled;
}
public enum UnityEngine.SpriteMaskInteraction : Enum {
    public int value__;
    public static SpriteMaskInteraction None;
    public static SpriteMaskInteraction VisibleInsideMask;
    public static SpriteMaskInteraction VisibleOutsideMask;
}
public enum UnityEngine.SpriteMeshType : Enum {
    public int value__;
    public static SpriteMeshType FullRect;
    public static SpriteMeshType Tight;
}
public enum UnityEngine.SpritePackingMode : Enum {
    public int value__;
    public static SpritePackingMode Tight;
    public static SpritePackingMode Rectangle;
}
public enum UnityEngine.SpritePackingRotation : Enum {
    public int value__;
    public static SpritePackingRotation None;
    public static SpritePackingRotation FlipHorizontal;
    public static SpritePackingRotation FlipVertical;
    public static SpritePackingRotation Rotate180;
    public static SpritePackingRotation Any;
}
[NativeTypeAttribute("Runtime/Graphics/Mesh/SpriteRenderer.h")]
[RequireComponent("UnityEngine.Transform")]
public class UnityEngine.SpriteRenderer : Renderer {
    private UnityEvent`1<SpriteRenderer> m_SpriteChangeEvent;
    internal bool shouldSupportTiling { get; }
    public Sprite sprite { get; public set; }
    public SpriteDrawMode drawMode { get; public set; }
    public Vector2 size { get; public set; }
    public float adaptiveModeThreshold { get; public set; }
    public SpriteTileMode tileMode { get; public set; }
    public Color color { get; public set; }
    public SpriteMaskInteraction maskInteraction { get; public set; }
    public bool flipX { get; public set; }
    public bool flipY { get; public set; }
    public SpriteSortPoint spriteSortPoint { get; public set; }
    public void RegisterSpriteChangeCallback(UnityAction`1<SpriteRenderer> callback);
    public void UnregisterSpriteChangeCallback(UnityAction`1<SpriteRenderer> callback);
    [RequiredByNativeCodeAttribute]
private void InvokeSpriteChanged();
    [NativeMethodAttribute("ShouldSupportTiling")]
internal bool get_shouldSupportTiling();
    public Sprite get_sprite();
    public void set_sprite(Sprite value);
    public SpriteDrawMode get_drawMode();
    public void set_drawMode(SpriteDrawMode value);
    public Vector2 get_size();
    public void set_size(Vector2 value);
    public float get_adaptiveModeThreshold();
    public void set_adaptiveModeThreshold(float value);
    public SpriteTileMode get_tileMode();
    public void set_tileMode(SpriteTileMode value);
    public Color get_color();
    public void set_color(Color value);
    public SpriteMaskInteraction get_maskInteraction();
    public void set_maskInteraction(SpriteMaskInteraction value);
    public bool get_flipX();
    public void set_flipX(bool value);
    public bool get_flipY();
    public void set_flipY(bool value);
    public SpriteSortPoint get_spriteSortPoint();
    public void set_spriteSortPoint(SpriteSortPoint value);
    private IntPtr GetCurrentMeshDataPtr();
    internal MeshDataArray GetCurrentMeshData();
    [NativeMethodAttribute]
internal Bounds Internal_GetSpriteBounds(SpriteDrawMode mode);
    internal void GetSecondaryTextureProperties(MaterialPropertyBlock mbp);
    internal Bounds GetSpriteBounds();
    private void get_size_Injected(Vector2& ret);
    private void set_size_Injected(Vector2& value);
    private void get_color_Injected(Color& ret);
    private void set_color_Injected(Color& value);
    private void Internal_GetSpriteBounds_Injected(SpriteDrawMode mode, Bounds& ret);
}
public class UnityEngine.Sprites.DataUtility : object {
    public static Vector4 GetInnerUV(Sprite sprite);
    public static Vector4 GetOuterUV(Sprite sprite);
    public static Vector4 GetPadding(Sprite sprite);
    public static Vector2 GetMinSize(Sprite sprite);
}
public enum UnityEngine.SpriteSortPoint : Enum {
    public int value__;
    public static SpriteSortPoint Center;
    public static SpriteSortPoint Pivot;
}
public enum UnityEngine.SpriteTileMode : Enum {
    public int value__;
    public static SpriteTileMode Continuous;
    public static SpriteTileMode Adaptive;
}
public enum UnityEngine.StackTraceLogType : Enum {
    public int value__;
    public static StackTraceLogType None;
    public static StackTraceLogType ScriptOnly;
    public static StackTraceLogType Full;
}
public static class UnityEngine.StackTraceUtility : object {
    private static string projectFolder;
    private static StackTraceUtility();
    [RequiredByNativeCodeAttribute]
internal static void SetProjectFolder(string folder);
    [RequiredByNativeCodeAttribute]
[SecuritySafeCriticalAttribute]
public static string ExtractStackTrace();
    public static string ExtractStringFromException(object exception);
    [RequiredByNativeCodeAttribute]
[SecuritySafeCriticalAttribute]
internal static void ExtractStringFromExceptionInternal(object exceptiono, String& message, String& stackTrace);
    [SecuritySafeCriticalAttribute]
internal static string ExtractFormattedStackTrace(StackTrace stackTrace);
}
[NativeHeaderAttribute("Runtime/Graphics/Mesh/StaticBatching.h")]
internal class UnityEngine.StaticBatchingHelper : ValueType {
    [FreeFunctionAttribute("StaticBatching::CombineMeshesForStaticBatching")]
internal static void CombineMeshes(GameObject[] gos, GameObject staticBatchRoot);
}
public class UnityEngine.StaticBatchingUtility : object {
    internal static ProfilerMarker s_CombineMarker;
    private static StaticBatchingUtility();
    public static void Combine(GameObject staticBatchRoot);
    public static void Combine(GameObject[] gos, GameObject staticBatchRoot);
    private static void CombineRoot(GameObject staticBatchRoot);
}
public enum UnityEngine.StereoTargetEyeMask : Enum {
    public int value__;
    public static StereoTargetEyeMask None;
    public static StereoTargetEyeMask Left;
    public static StereoTargetEyeMask Right;
    public static StereoTargetEyeMask Both;
}
[VisibleToOtherModulesAttribute]
internal class UnityEngine.SystemClock : object {
    private static DateTime s_Epoch;
    public static DateTime now { get; }
    private static SystemClock();
    public static DateTime get_now();
    public static long ToUnixTimeMilliseconds(DateTime date);
    public static long ToUnixTimeSeconds(DateTime date);
}
[NativeHeaderAttribute("Runtime/Input/GetInput.h")]
[NativeHeaderAttribute("Runtime/Camera/RenderLoops/MotionVectorRenderLoop.h")]
[NativeHeaderAttribute("Runtime/Graphics/Mesh/MeshScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/GraphicsFormatUtility.bindings.h")]
[NativeHeaderAttribute("Runtime/Shaders/GraphicsCapsScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Misc/SystemInfo.h")]
public class UnityEngine.SystemInfo : object {
    public static string unsupportedIdentifier;
    [NativePropertyAttribute]
public static float batteryLevel { get; }
    public static BatteryStatus batteryStatus { get; }
    public static string operatingSystem { get; }
    public static OperatingSystemFamily operatingSystemFamily { get; }
    public static string processorType { get; }
    public static int processorFrequency { get; }
    public static int processorCount { get; }
    public static int systemMemorySize { get; }
    public static string deviceUniqueIdentifier { get; }
    public static string deviceName { get; }
    public static string deviceModel { get; }
    public static bool supportsAccelerometer { get; }
    public static bool supportsGyroscope { get; }
    public static bool supportsLocationService { get; }
    public static bool supportsVibration { get; }
    public static bool supportsAudio { get; }
    public static DeviceType deviceType { get; }
    public static int graphicsMemorySize { get; }
    public static string graphicsDeviceName { get; }
    public static string graphicsDeviceVendor { get; }
    public static int graphicsDeviceID { get; }
    public static int graphicsDeviceVendorID { get; }
    public static GraphicsDeviceType graphicsDeviceType { get; }
    public static bool graphicsUVStartsAtTop { get; }
    public static string graphicsDeviceVersion { get; }
    public static int graphicsShaderLevel { get; }
    public static bool graphicsMultiThreaded { get; }
    public static RenderingThreadingMode renderingThreadingMode { get; }
    public static FoveatedRenderingCaps foveatedRenderingCaps { get; }
    public static bool hasHiddenSurfaceRemovalOnGPU { get; }
    public static bool hasDynamicUniformArrayIndexingInFragmentShaders { get; }
    public static bool supportsShadows { get; }
    public static bool supportsRawShadowDepthSampling { get; }
    [ObsoleteAttribute("supportsRenderTextures always returns true, no need to call it")]
public static bool supportsRenderTextures { get; }
    public static bool supportsMotionVectors { get; }
    [ObsoleteAttribute("supportsRenderToCubemap always returns true, no need to call it")]
public static bool supportsRenderToCubemap { get; }
    [ObsoleteAttribute("supportsImageEffects always returns true, no need to call it")]
public static bool supportsImageEffects { get; }
    public static bool supports3DTextures { get; }
    public static bool supportsCompressed3DTextures { get; }
    public static bool supports2DArrayTextures { get; }
    public static bool supports3DRenderTextures { get; }
    public static bool supportsCubemapArrayTextures { get; }
    public static CopyTextureSupport copyTextureSupport { get; }
    public static bool supportsComputeShaders { get; }
    public static bool supportsGeometryShaders { get; }
    public static bool supportsTessellationShaders { get; }
    public static bool supportsRenderTargetArrayIndexFromVertexShader { get; }
    public static bool supportsInstancing { get; }
    public static bool supportsHardwareQuadTopology { get; }
    public static bool supports32bitsIndexBuffer { get; }
    public static bool supportsSparseTextures { get; }
    public static int supportedRenderTargetCount { get; }
    public static bool supportsSeparatedRenderTargetsBlend { get; }
    public static int supportedRandomWriteTargetCount { get; }
    public static int supportsMultisampledTextures { get; }
    public static bool supportsMultisampled2DArrayTextures { get; }
    public static bool supportsMultisampleAutoResolve { get; }
    public static int supportsTextureWrapMirrorOnce { get; }
    public static bool usesReversedZBuffer { get; }
    [ObsoleteAttribute("supportsStencil always returns true, no need to call it")]
public static int supportsStencil { get; }
    public static NPOTSupport npotSupport { get; }
    public static int maxTextureSize { get; }
    public static int maxTexture3DSize { get; }
    public static int maxTextureArraySlices { get; }
    public static int maxCubemapSize { get; }
    internal static int maxRenderTextureSize { get; }
    public static int maxComputeBufferInputsVertex { get; }
    public static int maxComputeBufferInputsFragment { get; }
    public static int maxComputeBufferInputsGeometry { get; }
    public static int maxComputeBufferInputsDomain { get; }
    public static int maxComputeBufferInputsHull { get; }
    public static int maxComputeBufferInputsCompute { get; }
    public static int maxComputeWorkGroupSize { get; }
    public static int maxComputeWorkGroupSizeX { get; }
    public static int maxComputeWorkGroupSizeY { get; }
    public static int maxComputeWorkGroupSizeZ { get; }
    public static int computeSubGroupSize { get; }
    public static bool supportsAsyncCompute { get; }
    public static bool supportsGpuRecorder { get; }
    public static bool supportsGraphicsFence { get; }
    public static bool supportsAsyncGPUReadback { get; }
    public static bool supportsRayTracing { get; }
    public static bool supportsSetConstantBuffer { get; }
    public static int constantBufferOffsetAlignment { get; }
    public static int maxConstantBufferSize { get; }
    public static long maxGraphicsBufferSize { get; }
    [ObsoleteAttribute("Use SystemInfo.constantBufferOffsetAlignment instead.")]
public static bool minConstantBufferOffsetAlignment { get; }
    public static bool hasMipMaxLevel { get; }
    public static bool supportsMipStreaming { get; }
    [ObsoleteAttribute("graphicsPixelFillrate is no longer supported in Unity 5.0+.")]
public static int graphicsPixelFillrate { get; }
    public static bool usesLoadStoreActions { get; }
    public static HDRDisplaySupportFlags hdrDisplaySupportFlags { get; }
    public static bool supportsConservativeRaster { get; }
    public static bool supportsMultiview { get; }
    public static bool supportsStoreAndResolveAction { get; }
    public static bool supportsMultisampleResolveDepth { get; }
    public static bool supportsMultisampleResolveStencil { get; }
    public static bool supportsIndirectArgumentsBuffer { get; }
    [ObsoleteAttribute("Vertex program support is required in Unity 5.0+")]
public static bool supportsVertexPrograms { get; }
    [ObsoleteAttribute("SystemInfo.supportsGPUFence has been deprecated, use SystemInfo.supportsGraphicsFence instead (UnityUpgradable) ->  supportsGraphicsFence", "True")]
public static bool supportsGPUFence { get; }
    public static float get_batteryLevel();
    public static BatteryStatus get_batteryStatus();
    public static string get_operatingSystem();
    public static OperatingSystemFamily get_operatingSystemFamily();
    public static string get_processorType();
    public static int get_processorFrequency();
    public static int get_processorCount();
    public static int get_systemMemorySize();
    public static string get_deviceUniqueIdentifier();
    public static string get_deviceName();
    public static string get_deviceModel();
    public static bool get_supportsAccelerometer();
    public static bool get_supportsGyroscope();
    public static bool get_supportsLocationService();
    public static bool get_supportsVibration();
    public static bool get_supportsAudio();
    public static DeviceType get_deviceType();
    public static int get_graphicsMemorySize();
    public static string get_graphicsDeviceName();
    public static string get_graphicsDeviceVendor();
    public static int get_graphicsDeviceID();
    public static int get_graphicsDeviceVendorID();
    public static GraphicsDeviceType get_graphicsDeviceType();
    public static bool get_graphicsUVStartsAtTop();
    public static string get_graphicsDeviceVersion();
    public static int get_graphicsShaderLevel();
    public static bool get_graphicsMultiThreaded();
    public static RenderingThreadingMode get_renderingThreadingMode();
    public static FoveatedRenderingCaps get_foveatedRenderingCaps();
    public static bool get_hasHiddenSurfaceRemovalOnGPU();
    public static bool get_hasDynamicUniformArrayIndexingInFragmentShaders();
    public static bool get_supportsShadows();
    public static bool get_supportsRawShadowDepthSampling();
    public static bool get_supportsRenderTextures();
    public static bool get_supportsMotionVectors();
    public static bool get_supportsRenderToCubemap();
    public static bool get_supportsImageEffects();
    public static bool get_supports3DTextures();
    public static bool get_supportsCompressed3DTextures();
    public static bool get_supports2DArrayTextures();
    public static bool get_supports3DRenderTextures();
    public static bool get_supportsCubemapArrayTextures();
    public static CopyTextureSupport get_copyTextureSupport();
    public static bool get_supportsComputeShaders();
    public static bool get_supportsGeometryShaders();
    public static bool get_supportsTessellationShaders();
    public static bool get_supportsRenderTargetArrayIndexFromVertexShader();
    public static bool get_supportsInstancing();
    public static bool get_supportsHardwareQuadTopology();
    public static bool get_supports32bitsIndexBuffer();
    public static bool get_supportsSparseTextures();
    public static int get_supportedRenderTargetCount();
    public static bool get_supportsSeparatedRenderTargetsBlend();
    public static int get_supportedRandomWriteTargetCount();
    public static int get_supportsMultisampledTextures();
    public static bool get_supportsMultisampled2DArrayTextures();
    public static bool get_supportsMultisampleAutoResolve();
    public static int get_supportsTextureWrapMirrorOnce();
    public static bool get_usesReversedZBuffer();
    public static int get_supportsStencil();
    private static bool IsValidEnumValue(Enum value);
    public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
    public static bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format);
    public static bool SupportsRandomWriteOnRenderTextureFormat(RenderTextureFormat format);
    public static bool SupportsTextureFormat(TextureFormat format);
    public static bool SupportsVertexAttributeFormat(VertexAttributeFormat format, int dimension);
    public static NPOTSupport get_npotSupport();
    public static int get_maxTextureSize();
    public static int get_maxTexture3DSize();
    public static int get_maxTextureArraySlices();
    public static int get_maxCubemapSize();
    internal static int get_maxRenderTextureSize();
    public static int get_maxComputeBufferInputsVertex();
    public static int get_maxComputeBufferInputsFragment();
    public static int get_maxComputeBufferInputsGeometry();
    public static int get_maxComputeBufferInputsDomain();
    public static int get_maxComputeBufferInputsHull();
    public static int get_maxComputeBufferInputsCompute();
    public static int get_maxComputeWorkGroupSize();
    public static int get_maxComputeWorkGroupSizeX();
    public static int get_maxComputeWorkGroupSizeY();
    public static int get_maxComputeWorkGroupSizeZ();
    public static int get_computeSubGroupSize();
    public static bool get_supportsAsyncCompute();
    public static bool get_supportsGpuRecorder();
    public static bool get_supportsGraphicsFence();
    public static bool get_supportsAsyncGPUReadback();
    public static bool get_supportsRayTracing();
    public static bool get_supportsSetConstantBuffer();
    public static int get_constantBufferOffsetAlignment();
    public static int get_maxConstantBufferSize();
    public static long get_maxGraphicsBufferSize();
    public static bool get_minConstantBufferOffsetAlignment();
    public static bool get_hasMipMaxLevel();
    public static bool get_supportsMipStreaming();
    public static int get_graphicsPixelFillrate();
    public static bool get_usesLoadStoreActions();
    public static HDRDisplaySupportFlags get_hdrDisplaySupportFlags();
    public static bool get_supportsConservativeRaster();
    public static bool get_supportsMultiview();
    public static bool get_supportsStoreAndResolveAction();
    public static bool get_supportsMultisampleResolveDepth();
    public static bool get_supportsMultisampleResolveStencil();
    public static bool get_supportsIndirectArgumentsBuffer();
    public static bool get_supportsVertexPrograms();
    [FreeFunctionAttribute("systeminfo::GetBatteryLevel")]
private static float GetBatteryLevel();
    [FreeFunctionAttribute("systeminfo::GetBatteryStatus")]
private static BatteryStatus GetBatteryStatus();
    [FreeFunctionAttribute("systeminfo::GetOperatingSystem")]
private static string GetOperatingSystem();
    [FreeFunctionAttribute("systeminfo::GetOperatingSystemFamily")]
private static OperatingSystemFamily GetOperatingSystemFamily();
    [FreeFunctionAttribute("systeminfo::GetProcessorType")]
private static string GetProcessorType();
    [FreeFunctionAttribute("systeminfo::GetProcessorFrequencyMHz")]
private static int GetProcessorFrequencyMHz();
    [FreeFunctionAttribute("systeminfo::GetProcessorCount")]
private static int GetProcessorCount();
    [FreeFunctionAttribute("systeminfo::GetPhysicalMemoryMB")]
private static int GetPhysicalMemoryMB();
    [FreeFunctionAttribute("systeminfo::GetDeviceUniqueIdentifier")]
private static string GetDeviceUniqueIdentifier();
    [FreeFunctionAttribute("systeminfo::GetDeviceName")]
private static string GetDeviceName();
    [FreeFunctionAttribute("systeminfo::GetDeviceModel")]
private static string GetDeviceModel();
    [FreeFunctionAttribute("systeminfo::SupportsAccelerometer")]
private static bool SupportsAccelerometer();
    [FreeFunctionAttribute]
private static bool IsGyroAvailable();
    [FreeFunctionAttribute("systeminfo::SupportsLocationService")]
private static bool SupportsLocationService();
    [FreeFunctionAttribute("systeminfo::SupportsVibration")]
private static bool SupportsVibration();
    [FreeFunctionAttribute("systeminfo::SupportsAudio")]
private static bool SupportsAudio();
    [FreeFunctionAttribute("systeminfo::GetDeviceType")]
private static DeviceType GetDeviceType();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsMemorySize")]
private static int GetGraphicsMemorySize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceName")]
private static string GetGraphicsDeviceName();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceVendor")]
private static string GetGraphicsDeviceVendor();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceID")]
private static int GetGraphicsDeviceID();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceVendorID")]
private static int GetGraphicsDeviceVendorID();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceType")]
private static GraphicsDeviceType GetGraphicsDeviceType();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsUVStartsAtTop")]
private static bool GetGraphicsUVStartsAtTop();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsDeviceVersion")]
private static string GetGraphicsDeviceVersion();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsShaderLevel")]
private static int GetGraphicsShaderLevel();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsMultiThreaded")]
private static bool GetGraphicsMultiThreaded();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetRenderingThreadingMode")]
private static RenderingThreadingMode GetRenderingThreadingMode();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetFoveatedRenderingCaps")]
private static FoveatedRenderingCaps GetFoveatedRenderingCaps();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::HasHiddenSurfaceRemovalOnGPU")]
private static bool HasHiddenSurfaceRemovalOnGPU();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::HasDynamicUniformArrayIndexingInFragmentShaders")]
private static bool HasDynamicUniformArrayIndexingInFragmentShaders();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsShadows")]
private static bool SupportsShadows();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsRawShadowDepthSampling")]
private static bool SupportsRawShadowDepthSampling();
    [FreeFunctionAttribute("SupportsMotionVectors")]
private static bool SupportsMotionVectors();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::Supports3DTextures")]
private static bool Supports3DTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsCompressed3DTextures")]
private static bool SupportsCompressed3DTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::Supports2DArrayTextures")]
private static bool Supports2DArrayTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::Supports3DRenderTextures")]
private static bool Supports3DRenderTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsCubemapArrayTextures")]
private static bool SupportsCubemapArrayTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetCopyTextureSupport")]
private static CopyTextureSupport GetCopyTextureSupport();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsComputeShaders")]
private static bool SupportsComputeShaders();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsGeometryShaders")]
private static bool SupportsGeometryShaders();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsTessellationShaders")]
private static bool SupportsTessellationShaders();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsRenderTargetArrayIndexFromVertexShader")]
private static bool SupportsRenderTargetArrayIndexFromVertexShader();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsInstancing")]
private static bool SupportsInstancing();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsHardwareQuadTopology")]
private static bool SupportsHardwareQuadTopology();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::Supports32bitsIndexBuffer")]
private static bool Supports32bitsIndexBuffer();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsSparseTextures")]
private static bool SupportsSparseTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportedRenderTargetCount")]
private static int SupportedRenderTargetCount();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsSeparatedRenderTargetsBlend")]
private static bool SupportsSeparatedRenderTargetsBlend();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportedRandomWriteTargetCount")]
private static int SupportedRandomWriteTargetCount();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsVertex")]
private static int MaxComputeBufferInputsVertex();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsFragment")]
private static int MaxComputeBufferInputsFragment();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsGeometry")]
private static int MaxComputeBufferInputsGeometry();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsDomain")]
private static int MaxComputeBufferInputsDomain();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsHull")]
private static int MaxComputeBufferInputsHull();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxComputeBufferInputsCompute")]
private static int MaxComputeBufferInputsCompute();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultisampledTextures")]
private static int SupportsMultisampledTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultisampled2DArrayTextures")]
private static bool SupportsMultisampled2DArrayTextures();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultisampleAutoResolve")]
private static bool SupportsMultisampleAutoResolve();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsTextureWrapMirrorOnce")]
private static int SupportsTextureWrapMirrorOnce();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::UsesReversedZBuffer")]
private static bool UsesReversedZBuffer();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::HasRenderTexture")]
private static bool HasRenderTextureNative(RenderTextureFormat format);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsBlendingOnRenderTextureFormat")]
private static bool SupportsBlendingOnRenderTextureFormatNative(RenderTextureFormat format);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsRandomWriteOnRenderTextureFormat")]
private static bool SupportsRandomWriteOnRenderTextureFormatNative(RenderTextureFormat format);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsTextureFormat")]
private static bool SupportsTextureFormatNative(TextureFormat format);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsVertexAttributeFormat")]
private static bool SupportsVertexAttributeFormatNative(VertexAttributeFormat format, int dimension);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetNPOTSupport")]
private static NPOTSupport GetNPOTSupport();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxTextureSize")]
private static int GetMaxTextureSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxTexture3DSize")]
private static int GetMaxTexture3DSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxTextureArraySlices")]
private static int GetMaxTextureArraySlices();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxCubemapSize")]
private static int GetMaxCubemapSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxRenderTextureSize")]
private static int GetMaxRenderTextureSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxComputeWorkGroupSize")]
private static int GetMaxComputeWorkGroupSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxComputeWorkGroupSizeX")]
private static int GetMaxComputeWorkGroupSizeX();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxComputeWorkGroupSizeY")]
private static int GetMaxComputeWorkGroupSizeY();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetMaxComputeWorkGroupSizeZ")]
private static int GetMaxComputeWorkGroupSizeZ();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetComputeSubGroupSize")]
private static int GetComputeSubGroupSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsAsyncCompute")]
private static bool SupportsAsyncCompute();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsGpuRecorder")]
private static bool SupportsGpuRecorder();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsGPUFence")]
private static bool SupportsGPUFence();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsAsyncGPUReadback")]
private static bool SupportsAsyncGPUReadback();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsRayTracing")]
private static bool SupportsRayTracing();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsSetConstantBuffer")]
private static bool SupportsSetConstantBuffer();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MinConstantBufferOffsetAlignment")]
private static int MinConstantBufferOffsetAlignment();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxConstantBufferSize")]
private static int MaxConstantBufferSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::MaxGraphicsBufferSize")]
private static long MaxGraphicsBufferSize();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::HasMipMaxLevel")]
private static bool HasMipMaxLevel();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMipStreaming")]
private static bool SupportsMipStreaming();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::IsFormatSupported")]
public static bool IsFormatSupported(GraphicsFormat format, FormatUsage usage);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetCompatibleFormat")]
public static GraphicsFormat GetCompatibleFormat(GraphicsFormat format, FormatUsage usage);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetGraphicsFormat")]
public static GraphicsFormat GetGraphicsFormat(DefaultFormat format);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetRenderTextureSupportedMSAASampleCount")]
public static int GetRenderTextureSupportedMSAASampleCount(RenderTextureDescriptor desc);
    [FreeFunctionAttribute("ScriptingGraphicsCaps::UsesLoadStoreActions")]
private static bool UsesLoadStoreActions();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::GetHDRDisplaySupportFlags")]
private static HDRDisplaySupportFlags GetHDRDisplaySupportFlags();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsConservativeRaster")]
private static bool SupportsConservativeRaster();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultiview")]
private static bool SupportsMultiview();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsStoreAndResolveAction")]
private static bool SupportsStoreAndResolveAction();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultisampleResolveDepth")]
private static bool SupportsMultisampleResolveDepth();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsMultisampleResolveStencil")]
private static bool SupportsMultisampleResolveStencil();
    [FreeFunctionAttribute("ScriptingGraphicsCaps::SupportsIndirectArgumentsBuffer")]
private static bool SupportsIndirectArgumentsBuffer();
    public static bool get_supportsGPUFence();
    private static int GetRenderTextureSupportedMSAASampleCount_Injected(RenderTextureDescriptor& desc);
}
public enum UnityEngine.SystemLanguage : Enum {
    public int value__;
    public static SystemLanguage Afrikaans;
    public static SystemLanguage Arabic;
    public static SystemLanguage Basque;
    public static SystemLanguage Belarusian;
    public static SystemLanguage Bulgarian;
    public static SystemLanguage Catalan;
    public static SystemLanguage Chinese;
    public static SystemLanguage Czech;
    public static SystemLanguage Danish;
    public static SystemLanguage Dutch;
    public static SystemLanguage English;
    public static SystemLanguage Estonian;
    public static SystemLanguage Faroese;
    public static SystemLanguage Finnish;
    public static SystemLanguage French;
    public static SystemLanguage German;
    public static SystemLanguage Greek;
    public static SystemLanguage Hebrew;
    public static SystemLanguage Icelandic;
    public static SystemLanguage Indonesian;
    public static SystemLanguage Italian;
    public static SystemLanguage Japanese;
    public static SystemLanguage Korean;
    public static SystemLanguage Latvian;
    public static SystemLanguage Lithuanian;
    public static SystemLanguage Norwegian;
    public static SystemLanguage Polish;
    public static SystemLanguage Portuguese;
    public static SystemLanguage Romanian;
    public static SystemLanguage Russian;
    public static SystemLanguage SerboCroatian;
    public static SystemLanguage Slovak;
    public static SystemLanguage Slovenian;
    public static SystemLanguage Spanish;
    public static SystemLanguage Swedish;
    public static SystemLanguage Thai;
    public static SystemLanguage Turkish;
    public static SystemLanguage Ukrainian;
    public static SystemLanguage Vietnamese;
    public static SystemLanguage ChineseSimplified;
    public static SystemLanguage ChineseTraditional;
    public static SystemLanguage Hindi;
    public static SystemLanguage Unknown;
    public static SystemLanguage Hungarian;
}
[FlagsAttribute]
public enum UnityEngine.TerrainQualityOverrides : Enum {
    public int value__;
    public static TerrainQualityOverrides None;
    public static TerrainQualityOverrides PixelError;
    public static TerrainQualityOverrides BasemapDistance;
    public static TerrainQualityOverrides DetailDensity;
    public static TerrainQualityOverrides DetailDistance;
    public static TerrainQualityOverrides TreeDistance;
    public static TerrainQualityOverrides BillboardStart;
    public static TerrainQualityOverrides FadeLength;
    public static TerrainQualityOverrides MaxTrees;
}
[NativeClassAttribute("ScriptingCoverage")]
[NativeTypeAttribute("Runtime/Scripting/ScriptingCoverage.h")]
public static class UnityEngine.TestTools.Coverage : object {
    public static bool enabled { get; public set; }
    public static bool get_enabled();
    public static void set_enabled(bool value);
    [FreeFunctionAttribute("ScriptingCoverageGetCoverageForMethodInfoObject")]
private static CoveredSequencePoint[] GetSequencePointsFor_Internal(MethodBase method);
    [FreeFunctionAttribute("ScriptingCoverageResetForMethodInfoObject")]
private static void ResetFor_Internal(MethodBase method);
    [FreeFunctionAttribute("ScriptingCoverageGetStatsForMethodInfoObject")]
private static CoveredMethodStats GetStatsFor_Internal(MethodBase method);
    public static CoveredSequencePoint[] GetSequencePointsFor(MethodBase method);
    public static CoveredMethodStats GetStatsFor(MethodBase method);
    public static CoveredMethodStats[] GetStatsFor(MethodBase[] methods);
    public static CoveredMethodStats[] GetStatsFor(Type type);
    [FreeFunctionAttribute("ScriptingCoverageGetStatsForAllCoveredMethodsFromScripting")]
public static CoveredMethodStats[] GetStatsForAllCoveredMethods();
    public static void ResetFor(MethodBase method);
    [FreeFunctionAttribute("ScriptingCoverageResetAllFromScripting")]
public static void ResetAll();
    private static void GetStatsFor_Internal_Injected(MethodBase method, CoveredMethodStats& ret);
}
[NativeTypeAttribute("1", "ManagedCoveredMethodStats")]
public class UnityEngine.TestTools.CoveredMethodStats : ValueType {
    public MethodBase method;
    public int totalSequencePoints;
    public int uncoveredSequencePoints;
    private string GetTypeDisplayName(Type t);
    public virtual string ToString();
}
[NativeTypeAttribute("1", "ManagedCoveredSequencePoint")]
public class UnityEngine.TestTools.CoveredSequencePoint : ValueType {
    public MethodBase method;
    public UInt32 ilOffset;
    public UInt32 hitCount;
    public string filename;
    public UInt32 line;
    public UInt32 column;
}
[AttributeUsageAttribute("109")]
[UsedByNativeCodeAttribute]
public class UnityEngine.TestTools.ExcludeFromCoverageAttribute : Attribute {
}
public enum UnityEngine.TexGenMode : Enum {
    public int value__;
    public static TexGenMode None;
    public static TexGenMode SphereMap;
    public static TexGenMode Object;
    public static TexGenMode EyeLinear;
    public static TexGenMode CubeReflect;
    public static TexGenMode CubeNormal;
}
[AttributeUsageAttribute("256")]
public class UnityEngine.TextAreaAttribute : PropertyAttribute {
    public int minLines;
    public int maxLines;
    public TextAreaAttribute(int minLines, int maxLines);
}
[NativeHeaderAttribute("Runtime/Scripting/TextAsset.h")]
public class UnityEngine.TextAsset : Object {
    public Byte[] bytes { get; }
    public string text { get; }
    public long dataSize { get; }
    public TextAsset(string text);
    internal TextAsset(CreateOptions options, string text);
    public Byte[] get_bytes();
    private Byte[] GetPreviewBytes(int maxByteCount);
    private static void Internal_CreateInstance(TextAsset self, string text);
    private IntPtr GetDataPtr();
    private long GetDataSize();
    public string get_text();
    public long get_dataSize();
    public virtual string ToString();
    public NativeArray`1<T> GetData();
    internal string GetPreview(int maxChars);
    internal static string DecodeString(Byte[] bytes);
}
[NativeHeaderAttribute("Runtime/Graphics/Texture.h")]
[NativeHeaderAttribute("Runtime/Streaming/TextureStreamingManager.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Texture : Object {
    public static int GenerateAllMips;
    [ObsoleteAttribute("masterTextureLimit has been deprecated. Use globalMipmapLimit instead (UnityUpgradable) -> globalMipmapLimit", "False")]
[NativePropertyAttribute("ActiveGlobalMipmapLimit")]
public static int masterTextureLimit { get; public set; }
    [ObsoleteAttribute("globalMipmapLimit is not supported. Use QualitySettings.globalTextureMipmapLimit or Mipmap Limit Groups instead.", "False")]
[NativePropertyAttribute("ActiveGlobalMipmapLimit")]
public static int globalMipmapLimit { get; public set; }
    public int mipmapCount { get; }
    [NativePropertyAttribute("AnisoLimit")]
public static AnisotropicFiltering anisotropicFiltering { get; public set; }
    public GraphicsFormat graphicsFormat { get; }
    public int width { get; public set; }
    public int height { get; public set; }
    public TextureDimension dimension { get; public set; }
    internal bool isNativeTexture { get; }
    public bool isReadable { get; }
    public TextureWrapMode wrapMode { get; public set; }
    public TextureWrapMode wrapModeU { get; public set; }
    public TextureWrapMode wrapModeV { get; public set; }
    public TextureWrapMode wrapModeW { get; public set; }
    public FilterMode filterMode { get; public set; }
    public int anisoLevel { get; public set; }
    public float mipMapBias { get; public set; }
    public Vector2 texelSize { get; }
    public UInt32 updateCount { get; }
    internal ColorSpace activeTextureColorSpace { get; }
    public bool isDataSRGB { get; }
    public static ulong totalTextureMemory { get; }
    public static ulong desiredTextureMemory { get; }
    public static ulong targetTextureMemory { get; }
    public static ulong currentTextureMemory { get; }
    public static ulong nonStreamingTextureMemory { get; }
    public static ulong streamingMipmapUploadCount { get; }
    public static ulong streamingRendererCount { get; }
    public static ulong streamingTextureCount { get; }
    public static ulong nonStreamingTextureCount { get; }
    public static ulong streamingTexturePendingLoadCount { get; }
    public static ulong streamingTextureLoadingCount { get; }
    public static bool streamingTextureForceLoadAll { get; public set; }
    public static bool streamingTextureDiscardUnusedMips { get; public set; }
    public static bool allowThreadedTextureCreation { get; public set; }
    private static Texture();
    public static int get_masterTextureLimit();
    public static void set_masterTextureLimit(int value);
    public static int get_globalMipmapLimit();
    public static void set_globalMipmapLimit(int value);
    [NativeNameAttribute("GetMipmapCount")]
public int get_mipmapCount();
    public static AnisotropicFiltering get_anisotropicFiltering();
    public static void set_anisotropicFiltering(AnisotropicFiltering value);
    [NativeNameAttribute("SetGlobalAnisoLimits")]
public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax);
    public virtual GraphicsFormat get_graphicsFormat();
    private int GetDataWidth();
    private int GetDataHeight();
    private TextureDimension GetDimension();
    public virtual int get_width();
    public virtual void set_width(int value);
    public virtual int get_height();
    public virtual void set_height(int value);
    public virtual TextureDimension get_dimension();
    public virtual void set_dimension(TextureDimension value);
    [NativeNameAttribute("IsNativeTexture")]
internal bool get_isNativeTexture();
    public virtual bool get_isReadable();
    [NativeNameAttribute("GetWrapModeU")]
public TextureWrapMode get_wrapMode();
    public void set_wrapMode(TextureWrapMode value);
    public TextureWrapMode get_wrapModeU();
    public void set_wrapModeU(TextureWrapMode value);
    public TextureWrapMode get_wrapModeV();
    public void set_wrapModeV(TextureWrapMode value);
    public TextureWrapMode get_wrapModeW();
    public void set_wrapModeW(TextureWrapMode value);
    public FilterMode get_filterMode();
    public void set_filterMode(FilterMode value);
    public int get_anisoLevel();
    public void set_anisoLevel(int value);
    public float get_mipMapBias();
    public void set_mipMapBias(float value);
    [NativeNameAttribute("GetTexelSize")]
public Vector2 get_texelSize();
    public IntPtr GetNativeTexturePtr();
    [ObsoleteAttribute("Use GetNativeTexturePtr instead.", "False")]
public int GetNativeTextureID();
    public UInt32 get_updateCount();
    public void IncrementUpdateCount();
    [NativeMethodAttribute("GetActiveTextureColorSpace")]
private int Internal_GetActiveTextureColorSpace();
    [VisibleToOtherModulesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ColorSpace get_activeTextureColorSpace();
    [NativeMethodAttribute("GetStoredColorSpace")]
private TextureColorSpace Internal_GetStoredColorSpace();
    public bool get_isDataSRGB();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetTotalTextureMemory")]
public static ulong get_totalTextureMemory();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetDesiredTextureMemory")]
public static ulong get_desiredTextureMemory();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetTargetTextureMemory")]
public static ulong get_targetTextureMemory();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetCurrentTextureMemory")]
public static ulong get_currentTextureMemory();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetNonStreamingTextureMemory")]
public static ulong get_nonStreamingTextureMemory();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetStreamingMipmapUploadCount")]
public static ulong get_streamingMipmapUploadCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetStreamingRendererCount")]
public static ulong get_streamingRendererCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetStreamingTextureCount")]
public static ulong get_streamingTextureCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetNonStreamingTextureCount")]
public static ulong get_nonStreamingTextureCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetStreamingTexturePendingLoadCount")]
public static ulong get_streamingTexturePendingLoadCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().GetStreamingTextureLoadingCount")]
public static ulong get_streamingTextureLoadingCount();
    [FreeFunctionAttribute("GetTextureStreamingManager().SetStreamingTextureMaterialDebugProperties")]
public static void SetStreamingTextureMaterialDebugProperties();
    [FreeFunctionAttribute]
public static bool get_streamingTextureForceLoadAll();
    [FreeFunctionAttribute]
public static void set_streamingTextureForceLoadAll(bool value);
    [FreeFunctionAttribute]
public static bool get_streamingTextureDiscardUnusedMips();
    [FreeFunctionAttribute]
public static void set_streamingTextureDiscardUnusedMips(bool value);
    [FreeFunctionAttribute]
public static bool get_allowThreadedTextureCreation();
    [FreeFunctionAttribute]
public static void set_allowThreadedTextureCreation(bool value);
    internal ulong GetPixelDataSize(int mipLevel, int element);
    internal ulong GetPixelDataOffset(int mipLevel, int element);
    internal TextureColorSpace GetTextureColorSpace(bool linear);
    internal TextureColorSpace GetTextureColorSpace(GraphicsFormat format);
    internal bool ValidateFormat(RenderTextureFormat format);
    internal bool ValidateFormat(TextureFormat format);
    internal bool ValidateFormat(GraphicsFormat format, FormatUsage usage);
    internal UnityException CreateNonReadableException(Texture t);
    internal UnityException CreateNativeArrayLengthOverflowException();
    private void get_texelSize_Injected(Vector2& ret);
}
[NativeHeaderAttribute("Runtime/Graphics/Texture2D.h")]
[NativeHeaderAttribute("Runtime/Graphics/GeneratedTextures.h")]
[HelpURLAttribute("texture-type-default")]
[ExcludeFromPresetAttribute]
[UsedByNativeCodeAttribute]
public class UnityEngine.Texture2D : Texture {
    internal static int streamingMipmapsPriorityMin;
    internal static int streamingMipmapsPriorityMax;
    public TextureFormat format { get; }
    public bool ignoreMipmapLimit { get; public set; }
    public string mipmapLimitGroup { get; }
    public int activeMipmapLimit { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D whiteTexture { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D blackTexture { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D redTexture { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D grayTexture { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D linearGrayTexture { get; }
    [StaticAccessorAttribute("builtintex", "2")]
public static Texture2D normalTexture { get; }
    public bool isReadable { get; }
    [NativeConditionalAttribute("ENABLE_VIRTUALTEXTURING && UNITY_EDITOR")]
[NativeNameAttribute("VTOnly")]
public bool vtOnly { get; }
    internal bool isPreProcessed { get; }
    public bool streamingMipmaps { get; }
    public int streamingMipmapsPriority { get; }
    public int requestedMipmapLevel { get; public set; }
    public int minimumMipmapLevel { get; public set; }
    internal bool loadAllMips { get; internal set; }
    public int calculatedMipmapLevel { get; }
    public int desiredMipmapLevel { get; }
    public int loadingMipmapLevel { get; }
    public int loadedMipmapLevel { get; }
    internal Texture2D(int width, int height, GraphicsFormat format, TextureCreationFlags flags, int mipCount, IntPtr nativeTex, string mipmapLimitGroupName);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, DefaultFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, DefaultFormat format, int mipCount, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, DefaultFormat format, int mipCount, string mipmapLimitGroupName, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, GraphicsFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, GraphicsFormat format, int mipCount, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, GraphicsFormat format, int mipCount, string mipmapLimitGroupName, TextureCreationFlags flags);
    internal Texture2D(int width, int height, TextureFormat textureFormat, int mipCount, bool linear, IntPtr nativeTex, bool createUninitialized, bool ignoreMipmapLimit, string mipmapLimitGroupName);
    public Texture2D(int width, int height, TextureFormat textureFormat, int mipCount, bool linear);
    public Texture2D(int width, int height, TextureFormat textureFormat, int mipCount, bool linear, bool createUninitialized);
    public Texture2D(int width, int height, TextureFormat textureFormat, int mipCount, bool linear, bool createUninitialized, bool ignoreMipmapLimit, string mipmapLimitGroupName);
    public Texture2D(int width, int height, TextureFormat textureFormat, bool mipChain, bool linear);
    public Texture2D(int width, int height, TextureFormat textureFormat, bool mipChain, bool linear, bool createUninitialized);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height, TextureFormat textureFormat, bool mipChain);
    [ExcludeFromDocsAttribute]
public Texture2D(int width, int height);
    [NativeNameAttribute("GetTextureFormat")]
public TextureFormat get_format();
    [NativeNameAttribute("IgnoreMipmapLimit")]
public bool get_ignoreMipmapLimit();
    [NativeNameAttribute("SetIgnoreMipmapLimitAndReload")]
public void set_ignoreMipmapLimit(bool value);
    [NativeNameAttribute("GetMipmapLimitGroupName")]
public string get_mipmapLimitGroup();
    [NativeNameAttribute("GetMipmapLimit")]
public int get_activeMipmapLimit();
    public static Texture2D get_whiteTexture();
    public static Texture2D get_blackTexture();
    public static Texture2D get_redTexture();
    public static Texture2D get_grayTexture();
    public static Texture2D get_linearGrayTexture();
    public static Texture2D get_normalTexture();
    public void Compress(bool highQuality);
    [FreeFunctionAttribute("Texture2DScripting::Create")]
private static bool Internal_CreateImpl(Texture2D mono, int w, int h, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex, string mipmapLimitGroupName);
    private static void Internal_Create(Texture2D mono, int w, int h, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex, string mipmapLimitGroupName);
    public virtual bool get_isReadable();
    public bool get_vtOnly();
    [NativeNameAttribute("Apply")]
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable);
    [NativeNameAttribute("Reinitialize")]
private bool ReinitializeImpl(int width, int height);
    [NativeNameAttribute("SetPixel")]
private void SetPixelImpl(int image, int mip, int x, int y, Color color);
    [NativeNameAttribute("GetPixel")]
private Color GetPixelImpl(int image, int mip, int x, int y);
    [NativeNameAttribute("GetPixelBilinear")]
private Color GetPixelBilinearImpl(int image, int mip, float u, float v);
    [FreeFunctionAttribute]
private bool ReinitializeWithFormatImpl(int width, int height, GraphicsFormat format, bool hasMipMap);
    [FreeFunctionAttribute]
private bool ReinitializeWithTextureFormatImpl(int width, int height, TextureFormat textureFormat, bool hasMipMap);
    [FreeFunctionAttribute]
private void ReadPixelsImpl(Rect source, int destX, int destY, bool recalculateMipMaps);
    [FreeFunctionAttribute]
private void SetPixelsImpl(int x, int y, int w, int h, Color[] pixel, int miplevel, int frame);
    [FreeFunctionAttribute]
private bool LoadRawTextureDataImpl(IntPtr data, ulong size);
    [FreeFunctionAttribute]
private bool LoadRawTextureDataImplArray(Byte[] data);
    [FreeFunctionAttribute]
private bool SetPixelDataImplArray(Array data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex);
    private IntPtr GetWritableImageData(int frame);
    private ulong GetRawImageDataSize();
    [FreeFunctionAttribute("Texture2DScripting::GenerateAtlas")]
private static void GenerateAtlasImpl(Vector2[] sizes, int padding, int atlasSize, Rect[] rect);
    internal bool get_isPreProcessed();
    public bool get_streamingMipmaps();
    public int get_streamingMipmapsPriority();
    [FreeFunctionAttribute]
public int get_requestedMipmapLevel();
    [FreeFunctionAttribute]
public void set_requestedMipmapLevel(int value);
    [FreeFunctionAttribute]
public int get_minimumMipmapLevel();
    [FreeFunctionAttribute]
public void set_minimumMipmapLevel(int value);
    [FreeFunctionAttribute]
internal bool get_loadAllMips();
    [FreeFunctionAttribute]
internal void set_loadAllMips(bool value);
    [FreeFunctionAttribute]
public int get_calculatedMipmapLevel();
    [FreeFunctionAttribute]
public int get_desiredMipmapLevel();
    [FreeFunctionAttribute]
public int get_loadingMipmapLevel();
    [FreeFunctionAttribute]
public int get_loadedMipmapLevel();
    [FreeFunctionAttribute]
public void ClearRequestedMipmapLevel();
    [FreeFunctionAttribute]
public bool IsRequestedMipmapLevelLoaded();
    [FreeFunctionAttribute]
public void ClearMinimumMipmapLevel();
    [FreeFunctionAttribute("Texture2DScripting::UpdateExternalTexture")]
public void UpdateExternalTexture(IntPtr nativeTex);
    [FreeFunctionAttribute("Texture2DScripting::SetAllPixels32")]
private void SetAllPixels32(Color32[] colors, int miplevel);
    [FreeFunctionAttribute("Texture2DScripting::SetBlockOfPixels32")]
private void SetBlockOfPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel);
    [FreeFunctionAttribute("Texture2DScripting::GetRawTextureData")]
public Byte[] GetRawTextureData();
    [FreeFunctionAttribute("Texture2DScripting::GetPixels")]
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight, int miplevel);
    [ExcludeFromDocsAttribute]
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight);
    [FreeFunctionAttribute("Texture2DScripting::GetPixels32")]
public Color32[] GetPixels32(int miplevel);
    [ExcludeFromDocsAttribute]
public Color32[] GetPixels32();
    [FreeFunctionAttribute("Texture2DScripting::PackTextures")]
public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize, bool makeNoLongerReadable);
    public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize);
    public Rect[] PackTextures(Texture2D[] textures, int padding);
    internal bool ValidateFormat(TextureFormat format, int width, int height);
    internal bool ValidateFormat(GraphicsFormat format, int width, int height);
    public static Texture2D CreateExternalTexture(int width, int height, TextureFormat format, bool mipChain, bool linear, IntPtr nativeTex);
    [ExcludeFromDocsAttribute]
public void SetPixel(int x, int y, Color color);
    public void SetPixel(int x, int y, Color color, int mipLevel);
    public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors, int miplevel);
    [ExcludeFromDocsAttribute]
public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors);
    public void SetPixels(Color[] colors, int miplevel);
    [ExcludeFromDocsAttribute]
public void SetPixels(Color[] colors);
    [ExcludeFromDocsAttribute]
public Color GetPixel(int x, int y);
    public Color GetPixel(int x, int y, int mipLevel);
    [ExcludeFromDocsAttribute]
public Color GetPixelBilinear(float u, float v);
    public Color GetPixelBilinear(float u, float v, int mipLevel);
    public void LoadRawTextureData(IntPtr data, int size);
    public void LoadRawTextureData(Byte[] data);
    public void LoadRawTextureData(NativeArray`1<T> data);
    public void SetPixelData(T[] data, int mipLevel, int sourceDataStartIndex);
    public void SetPixelData(NativeArray`1<T> data, int mipLevel, int sourceDataStartIndex);
    public NativeArray`1<T> GetPixelData(int mipLevel);
    public NativeArray`1<T> GetRawTextureData();
    public void Apply(bool updateMipmaps, bool makeNoLongerReadable);
    [ExcludeFromDocsAttribute]
public void Apply(bool updateMipmaps);
    [ExcludeFromDocsAttribute]
public void Apply();
    public bool Reinitialize(int width, int height);
    public bool Reinitialize(int width, int height, TextureFormat format, bool hasMipMap);
    public bool Reinitialize(int width, int height, GraphicsFormat format, bool hasMipMap);
    [ObsoleteAttribute("Texture2D.Resize(int, int) has been deprecated because it actually reinitializes the texture. Use Texture2D.Reinitialize(int, int) instead (UnityUpgradable) -> Reinitialize([*] System.Int32, [*] System.Int32)", "False")]
public bool Resize(int width, int height);
    [ObsoleteAttribute("Texture2D.Resize(int, int, TextureFormat, bool) has been deprecated because it actually reinitializes the texture. Use Texture2D.Reinitialize(int, int, TextureFormat, bool) instead (UnityUpgradable) -> Reinitialize([*] System.Int32, [*] System.Int32, UnityEngine.TextureFormat, [*] System.Boolean)", "False")]
public bool Resize(int width, int height, TextureFormat format, bool hasMipMap);
    [ObsoleteAttribute("Texture2D.Resize(int, int, GraphicsFormat, bool) has been deprecated because it actually reinitializes the texture. Use Texture2D.Reinitialize(int, int, GraphicsFormat, bool) instead (UnityUpgradable) -> Reinitialize([*] System.Int32, [*] System.Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, [*] System.Boolean)", "False")]
public bool Resize(int width, int height, GraphicsFormat format, bool hasMipMap);
    public void ReadPixels(Rect source, int destX, int destY, bool recalculateMipMaps);
    [ExcludeFromDocsAttribute]
public void ReadPixels(Rect source, int destX, int destY);
    public static bool GenerateAtlas(Vector2[] sizes, int padding, int atlasSize, List`1<Rect> results);
    public void SetPixels32(Color32[] colors, int miplevel);
    [ExcludeFromDocsAttribute]
public void SetPixels32(Color32[] colors);
    public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel);
    [ExcludeFromDocsAttribute]
public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors);
    public Color[] GetPixels(int miplevel);
    [ExcludeFromDocsAttribute]
public Color[] GetPixels();
    private void SetPixelImpl_Injected(int image, int mip, int x, int y, Color& color);
    private void GetPixelImpl_Injected(int image, int mip, int x, int y, Color& ret);
    private void GetPixelBilinearImpl_Injected(int image, int mip, float u, float v, Color& ret);
    private void ReadPixelsImpl_Injected(Rect& source, int destX, int destY, bool recalculateMipMaps);
}
[ExcludeFromPresetAttribute]
[NativeHeaderAttribute("Runtime/Graphics/Texture2DArray.h")]
public class UnityEngine.Texture2DArray : Texture {
    public static int allSlices { get; }
    public int depth { get; }
    public TextureFormat format { get; }
    public bool isReadable { get; }
    [ExcludeFromDocsAttribute]
public Texture2DArray(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2DArray(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags, int mipCount);
    [RequiredByNativeCodeAttribute]
public Texture2DArray(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture2DArray(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
    public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, int mipCount, bool linear, bool createUninitialized);
    public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, int mipCount, bool linear);
    public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, bool linear, bool createUninitialized);
    public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, bool linear);
    [ExcludeFromDocsAttribute]
public Texture2DArray(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);
    [NativeNameAttribute("GetAllTextureLayersIdentifier")]
public static int get_allSlices();
    [NativeNameAttribute("GetTextureLayerCount")]
public int get_depth();
    [NativeNameAttribute("GetTextureFormat")]
public TextureFormat get_format();
    public virtual bool get_isReadable();
    [FreeFunctionAttribute("Texture2DArrayScripting::Create")]
private static bool Internal_CreateImpl(Texture2DArray mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags);
    private static void Internal_Create(Texture2DArray mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags);
    [FreeFunctionAttribute]
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable);
    [FreeFunctionAttribute]
public Color[] GetPixels(int arrayElement, int miplevel);
    public Color[] GetPixels(int arrayElement);
    [FreeFunctionAttribute]
private bool SetPixelDataImplArray(Array data, int mipLevel, int element, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int element, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
public Color32[] GetPixels32(int arrayElement, int miplevel);
    public Color32[] GetPixels32(int arrayElement);
    [FreeFunctionAttribute]
public void SetPixels(Color[] colors, int arrayElement, int miplevel);
    public void SetPixels(Color[] colors, int arrayElement);
    [FreeFunctionAttribute]
public void SetPixels32(Color32[] colors, int arrayElement, int miplevel);
    public void SetPixels32(Color32[] colors, int arrayElement);
    private IntPtr GetImageDataPointer();
    internal bool ValidateFormat(TextureFormat format, int width, int height);
    internal bool ValidateFormat(GraphicsFormat format, int width, int height);
    public void Apply(bool updateMipmaps, bool makeNoLongerReadable);
    [ExcludeFromDocsAttribute]
public void Apply(bool updateMipmaps);
    [ExcludeFromDocsAttribute]
public void Apply();
    public void SetPixelData(T[] data, int mipLevel, int element, int sourceDataStartIndex);
    public void SetPixelData(NativeArray`1<T> data, int mipLevel, int element, int sourceDataStartIndex);
    public NativeArray`1<T> GetPixelData(int mipLevel, int element);
    private static void ValidateIsNotCrunched(TextureCreationFlags flags);
}
[ExcludeFromPresetAttribute]
[NativeHeaderAttribute("Runtime/Graphics/Texture3D.h")]
public class UnityEngine.Texture3D : Texture {
    public int depth { get; }
    public TextureFormat format { get; }
    public bool isReadable { get; }
    [ExcludeFromDocsAttribute]
public Texture3D(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture3D(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags, int mipCount);
    [ExcludeFromDocsAttribute]
[RequiredByNativeCodeAttribute]
public Texture3D(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
    [ExcludeFromDocsAttribute]
public Texture3D(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount);
    [ExcludeFromDocsAttribute]
public Texture3D(int width, int height, int depth, TextureFormat textureFormat, int mipCount);
    public Texture3D(int width, int height, int depth, TextureFormat textureFormat, int mipCount, IntPtr nativeTex);
    public Texture3D(int width, int height, int depth, TextureFormat textureFormat, int mipCount, IntPtr nativeTex, bool createUninitialized);
    [ExcludeFromDocsAttribute]
public Texture3D(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);
    public Texture3D(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, bool createUninitialized);
    public Texture3D(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, IntPtr nativeTex);
    [NativeNameAttribute("GetTextureLayerCount")]
public int get_depth();
    [NativeNameAttribute("GetTextureFormat")]
public TextureFormat get_format();
    public virtual bool get_isReadable();
    [NativeNameAttribute("SetPixel")]
private void SetPixelImpl(int mip, int x, int y, int z, Color color);
    [NativeNameAttribute("GetPixel")]
private Color GetPixelImpl(int mip, int x, int y, int z);
    [NativeNameAttribute("GetPixelBilinear")]
private Color GetPixelBilinearImpl(int mip, float u, float v, float w);
    [FreeFunctionAttribute("Texture3DScripting::Create")]
private static bool Internal_CreateImpl(Texture3D mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex);
    private static void Internal_Create(Texture3D mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex);
    [FreeFunctionAttribute("Texture3DScripting::UpdateExternalTexture")]
public void UpdateExternalTexture(IntPtr nativeTex);
    [FreeFunctionAttribute]
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable);
    [FreeFunctionAttribute]
public Color[] GetPixels(int miplevel);
    public Color[] GetPixels();
    [FreeFunctionAttribute]
public Color32[] GetPixels32(int miplevel);
    public Color32[] GetPixels32();
    [FreeFunctionAttribute]
public void SetPixels(Color[] colors, int miplevel);
    public void SetPixels(Color[] colors);
    [FreeFunctionAttribute]
public void SetPixels32(Color32[] colors, int miplevel);
    public void SetPixels32(Color32[] colors);
    [FreeFunctionAttribute]
private bool SetPixelDataImplArray(Array data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex);
    [FreeFunctionAttribute]
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex);
    private IntPtr GetImageDataPointer();
    public static Texture3D CreateExternalTexture(int width, int height, int depth, TextureFormat format, bool mipChain, IntPtr nativeTex);
    public void Apply(bool updateMipmaps, bool makeNoLongerReadable);
    [ExcludeFromDocsAttribute]
public void Apply(bool updateMipmaps);
    [ExcludeFromDocsAttribute]
public void Apply();
    [ExcludeFromDocsAttribute]
public void SetPixel(int x, int y, int z, Color color);
    public void SetPixel(int x, int y, int z, Color color, int mipLevel);
    [ExcludeFromDocsAttribute]
public Color GetPixel(int x, int y, int z);
    public Color GetPixel(int x, int y, int z, int mipLevel);
    [ExcludeFromDocsAttribute]
public Color GetPixelBilinear(float u, float v, float w);
    public Color GetPixelBilinear(float u, float v, float w, int mipLevel);
    public void SetPixelData(T[] data, int mipLevel, int sourceDataStartIndex);
    public void SetPixelData(NativeArray`1<T> data, int mipLevel, int sourceDataStartIndex);
    public NativeArray`1<T> GetPixelData(int mipLevel);
    private static void ValidateIsNotCrunched(TextureCreationFlags flags);
    private void SetPixelImpl_Injected(int mip, int x, int y, int z, Color& color);
    private void GetPixelImpl_Injected(int mip, int x, int y, int z, Color& ret);
    private void GetPixelBilinearImpl_Injected(int mip, float u, float v, float w, Color& ret);
}
internal enum UnityEngine.TextureColorSpace : Enum {
    public int value__;
    public static TextureColorSpace Linear;
    public static TextureColorSpace sRGB;
}
public enum UnityEngine.TextureFormat : Enum {
    public int value__;
    public static TextureFormat Alpha8;
    public static TextureFormat ARGB4444;
    public static TextureFormat RGB24;
    public static TextureFormat RGBA32;
    public static TextureFormat ARGB32;
    public static TextureFormat RGB565;
    public static TextureFormat R16;
    public static TextureFormat DXT1;
    public static TextureFormat DXT5;
    public static TextureFormat RGBA4444;
    public static TextureFormat BGRA32;
    public static TextureFormat RHalf;
    public static TextureFormat RGHalf;
    public static TextureFormat RGBAHalf;
    public static TextureFormat RFloat;
    public static TextureFormat RGFloat;
    public static TextureFormat RGBAFloat;
    public static TextureFormat YUY2;
    public static TextureFormat RGB9e5Float;
    public static TextureFormat BC4;
    public static TextureFormat BC5;
    public static TextureFormat BC6H;
    public static TextureFormat BC7;
    public static TextureFormat DXT1Crunched;
    public static TextureFormat DXT5Crunched;
    public static TextureFormat PVRTC_RGB2;
    public static TextureFormat PVRTC_RGBA2;
    public static TextureFormat PVRTC_RGB4;
    public static TextureFormat PVRTC_RGBA4;
    public static TextureFormat ETC_RGB4;
    public static TextureFormat EAC_R;
    public static TextureFormat EAC_R_SIGNED;
    public static TextureFormat EAC_RG;
    public static TextureFormat EAC_RG_SIGNED;
    public static TextureFormat ETC2_RGB;
    public static TextureFormat ETC2_RGBA1;
    public static TextureFormat ETC2_RGBA8;
    public static TextureFormat ASTC_4x4;
    public static TextureFormat ASTC_5x5;
    public static TextureFormat ASTC_6x6;
    public static TextureFormat ASTC_8x8;
    public static TextureFormat ASTC_10x10;
    public static TextureFormat ASTC_12x12;
    [ObsoleteAttribute("Nintendo 3DS is no longer supported.")]
public static TextureFormat ETC_RGB4_3DS;
    [ObsoleteAttribute("Nintendo 3DS is no longer supported.")]
public static TextureFormat ETC_RGBA8_3DS;
    public static TextureFormat RG16;
    public static TextureFormat R8;
    public static TextureFormat ETC_RGB4Crunched;
    public static TextureFormat ETC2_RGBA8Crunched;
    public static TextureFormat ASTC_HDR_4x4;
    public static TextureFormat ASTC_HDR_5x5;
    public static TextureFormat ASTC_HDR_6x6;
    public static TextureFormat ASTC_HDR_8x8;
    public static TextureFormat ASTC_HDR_10x10;
    public static TextureFormat ASTC_HDR_12x12;
    public static TextureFormat RG32;
    public static TextureFormat RGB48;
    public static TextureFormat RGBA64;
    [ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_4x4 has been deprecated. Use ASTC_4x4 instead (UnityUpgradable) -> ASTC_4x4")]
[EditorBrowsableAttribute("1")]
public static TextureFormat ASTC_RGB_4x4;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_5x5 has been deprecated. Use ASTC_5x5 instead (UnityUpgradable) -> ASTC_5x5")]
public static TextureFormat ASTC_RGB_5x5;
    [ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_6x6 has been deprecated. Use ASTC_6x6 instead (UnityUpgradable) -> ASTC_6x6")]
[EditorBrowsableAttribute("1")]
public static TextureFormat ASTC_RGB_6x6;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_8x8 has been deprecated. Use ASTC_8x8 instead (UnityUpgradable) -> ASTC_8x8")]
public static TextureFormat ASTC_RGB_8x8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_10x10 has been deprecated. Use ASTC_10x10 instead (UnityUpgradable) -> ASTC_10x10")]
public static TextureFormat ASTC_RGB_10x10;
    [ObsoleteAttribute("Enum member TextureFormat.ASTC_RGB_12x12 has been deprecated. Use ASTC_12x12 instead (UnityUpgradable) -> ASTC_12x12")]
[EditorBrowsableAttribute("1")]
public static TextureFormat ASTC_RGB_12x12;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_4x4 has been deprecated. Use ASTC_4x4 instead (UnityUpgradable) -> ASTC_4x4")]
public static TextureFormat ASTC_RGBA_4x4;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_5x5 has been deprecated. Use ASTC_5x5 instead (UnityUpgradable) -> ASTC_5x5")]
public static TextureFormat ASTC_RGBA_5x5;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_6x6 has been deprecated. Use ASTC_6x6 instead (UnityUpgradable) -> ASTC_6x6")]
public static TextureFormat ASTC_RGBA_6x6;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_8x8 has been deprecated. Use ASTC_8x8 instead (UnityUpgradable) -> ASTC_8x8")]
public static TextureFormat ASTC_RGBA_8x8;
    [ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_10x10 has been deprecated. Use ASTC_10x10 instead (UnityUpgradable) -> ASTC_10x10")]
[EditorBrowsableAttribute("1")]
public static TextureFormat ASTC_RGBA_10x10;
    [ObsoleteAttribute("Enum member TextureFormat.ASTC_RGBA_12x12 has been deprecated. Use ASTC_12x12 instead (UnityUpgradable) -> ASTC_12x12")]
[EditorBrowsableAttribute("1")]
public static TextureFormat ASTC_RGBA_12x12;
}
public enum UnityEngine.TextureMipmapLimitBiasMode : Enum {
    public int value__;
    public static TextureMipmapLimitBiasMode OffsetGlobalLimit;
    public static TextureMipmapLimitBiasMode OverrideGlobalLimit;
}
[NativeHeaderAttribute("Runtime/Graphics/QualitySettings.h")]
[StaticAccessorAttribute("GetQualitySettings()", "0")]
public static class UnityEngine.TextureMipmapLimitGroups : object {
    [NativeNameAttribute("GetTextureMipmapLimitGroupNames")]
public static String[] GetGroups();
    [NativeNameAttribute("HasTextureMipmapLimitGroup")]
public static bool HasGroup(string groupName);
}
public class UnityEngine.TextureMipmapLimitSettings : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TextureMipmapLimitBiasMode <limitBiasMode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <limitBias>k__BackingField;
    public TextureMipmapLimitBiasMode limitBiasMode { get; public set; }
    public int limitBias { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextureMipmapLimitBiasMode get_limitBiasMode();
    [CompilerGeneratedAttribute]
public void set_limitBiasMode(TextureMipmapLimitBiasMode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_limitBias();
    [CompilerGeneratedAttribute]
public void set_limitBias(int value);
}
public enum UnityEngine.TextureWrapMode : Enum {
    public int value__;
    public static TextureWrapMode Repeat;
    public static TextureWrapMode Clamp;
    public static TextureWrapMode Mirror;
    public static TextureWrapMode MirrorOnce;
}
public enum UnityEngine.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Low;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority High;
}
[NativeHeaderAttribute("Runtime/Input/TimeManager.h")]
[StaticAccessorAttribute("GetTimeManager()", "0")]
public class UnityEngine.Time : object {
    [NativePropertyAttribute("CurTime")]
public static float time { get; }
    [NativePropertyAttribute("CurTime")]
public static double timeAsDouble { get; }
    [NativePropertyAttribute("TimeSinceSceneLoad")]
public static float timeSinceLevelLoad { get; }
    [NativePropertyAttribute("TimeSinceSceneLoad")]
public static double timeSinceLevelLoadAsDouble { get; }
    public static float deltaTime { get; }
    public static float fixedTime { get; }
    [NativePropertyAttribute("FixedTime")]
public static double fixedTimeAsDouble { get; }
    public static float unscaledTime { get; }
    [NativePropertyAttribute("UnscaledTime")]
public static double unscaledTimeAsDouble { get; }
    public static float fixedUnscaledTime { get; }
    [NativePropertyAttribute("FixedUnscaledTime")]
public static double fixedUnscaledTimeAsDouble { get; }
    public static float unscaledDeltaTime { get; }
    public static float fixedUnscaledDeltaTime { get; }
    public static float fixedDeltaTime { get; public set; }
    public static float maximumDeltaTime { get; public set; }
    public static float smoothDeltaTime { get; }
    public static float maximumParticleDeltaTime { get; public set; }
    public static float timeScale { get; public set; }
    public static int frameCount { get; }
    [NativePropertyAttribute("RenderFrameCount")]
public static int renderedFrameCount { get; }
    [NativePropertyAttribute("Realtime")]
public static float realtimeSinceStartup { get; }
    [NativePropertyAttribute("Realtime")]
public static double realtimeSinceStartupAsDouble { get; }
    public static float captureDeltaTime { get; public set; }
    public static int captureFramerate { get; public set; }
    public static bool inFixedTimeStep { get; }
    public static float get_time();
    public static double get_timeAsDouble();
    public static float get_timeSinceLevelLoad();
    public static double get_timeSinceLevelLoadAsDouble();
    public static float get_deltaTime();
    public static float get_fixedTime();
    public static double get_fixedTimeAsDouble();
    public static float get_unscaledTime();
    public static double get_unscaledTimeAsDouble();
    public static float get_fixedUnscaledTime();
    public static double get_fixedUnscaledTimeAsDouble();
    public static float get_unscaledDeltaTime();
    public static float get_fixedUnscaledDeltaTime();
    public static float get_fixedDeltaTime();
    public static void set_fixedDeltaTime(float value);
    public static float get_maximumDeltaTime();
    public static void set_maximumDeltaTime(float value);
    public static float get_smoothDeltaTime();
    public static float get_maximumParticleDeltaTime();
    public static void set_maximumParticleDeltaTime(float value);
    public static float get_timeScale();
    public static void set_timeScale(float value);
    public static int get_frameCount();
    public static int get_renderedFrameCount();
    public static float get_realtimeSinceStartup();
    public static double get_realtimeSinceStartupAsDouble();
    public static float get_captureDeltaTime();
    public static void set_captureDeltaTime(float value);
    public static int get_captureFramerate();
    public static void set_captureFramerate(int value);
    [NativeNameAttribute("IsUsingFixedTimeStep")]
public static bool get_inFixedTimeStep();
}
[AttributeUsageAttribute("32767")]
public class UnityEngine.TooltipAttribute : PropertyAttribute {
    public string tooltip;
    public TooltipAttribute(string tooltip);
}
[NativeHeaderAttribute("Runtime/Input/KeyboardOnScreen.h")]
[NativeHeaderAttribute("Runtime/Export/TouchScreenKeyboard/TouchScreenKeyboard.bindings.h")]
[NativeConditionalAttribute("ENABLE_ONSCREEN_KEYBOARD")]
public class UnityEngine.TouchScreenKeyboard : object {
    internal IntPtr m_Ptr;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static bool <disableInPlaceEditing>k__BackingField;
    public static bool isSupported { get; }
    internal static bool disableInPlaceEditing { get; internal set; }
    public static bool isInPlaceEditingAllowed { get; }
    internal static bool isRequiredToForceOpen { get; }
    public string text { get; public set; }
    public static bool hideInput { get; public set; }
    public bool active { get; public set; }
    [ObsoleteAttribute("Property done is deprecated, use status instead")]
public bool done { get; }
    [ObsoleteAttribute("Property wasCanceled is deprecated, use status instead.")]
public bool wasCanceled { get; }
    public Status status { get; }
    public int characterLimit { get; public set; }
    public bool canGetSelection { get; }
    public bool canSetSelection { get; }
    public RangeInt selection { get; public set; }
    public TouchScreenKeyboardType type { get; }
    public int targetDisplay { get; public set; }
    [NativeConditionalAttribute("ENABLE_ONSCREEN_KEYBOARD", "RectT<float>()")]
public static Rect area { get; }
    public static bool visible { get; }
    public TouchScreenKeyboard(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit);
    [FreeFunctionAttribute("TouchScreenKeyboard_Destroy")]
private static void Internal_Destroy(IntPtr ptr);
    private void Destroy();
    protected virtual override void Finalize();
    [FreeFunctionAttribute("TouchScreenKeyboard_InternalConstructorHelper")]
private static IntPtr TouchScreenKeyboard_InternalConstructorHelper(TouchScreenKeyboard_InternalConstructorHelperArguments& arguments, string text, string textPlaceholder);
    public static bool get_isSupported();
    [CompilerGeneratedAttribute]
internal static bool get_disableInPlaceEditing();
    [CompilerGeneratedAttribute]
internal static void set_disableInPlaceEditing(bool value);
    public static bool get_isInPlaceEditingAllowed();
    internal static bool get_isRequiredToForceOpen();
    [FreeFunctionAttribute("TouchScreenKeyboard_IsRequiredToForceOpen")]
private static bool IsRequiredToForceOpen();
    public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType);
    [ExcludeFromDocsAttribute]
public static TouchScreenKeyboard Open(string text);
    [NativeNameAttribute("GetText")]
public string get_text();
    [NativeNameAttribute("SetText")]
public void set_text(string value);
    [NativeNameAttribute("IsInputHidden")]
public static bool get_hideInput();
    [NativeNameAttribute("SetInputHidden")]
public static void set_hideInput(bool value);
    [NativeNameAttribute("IsActive")]
public bool get_active();
    [NativeNameAttribute("SetActive")]
public void set_active(bool value);
    [FreeFunctionAttribute("TouchScreenKeyboard_GetDone")]
private static bool GetDone(IntPtr ptr);
    public bool get_done();
    [FreeFunctionAttribute("TouchScreenKeyboard_GetWasCanceled")]
private static bool GetWasCanceled(IntPtr ptr);
    public bool get_wasCanceled();
    [NativeNameAttribute("GetKeyboardStatus")]
public Status get_status();
    [NativeNameAttribute("GetCharacterLimit")]
public int get_characterLimit();
    [NativeNameAttribute("SetCharacterLimit")]
public void set_characterLimit(int value);
    [NativeNameAttribute("CanGetSelection")]
public bool get_canGetSelection();
    [NativeNameAttribute("CanSetSelection")]
public bool get_canSetSelection();
    public RangeInt get_selection();
    public void set_selection(RangeInt value);
    private static void GetSelection(Int32& start, Int32& length);
    private static void SetSelection(int start, int length);
    [NativeNameAttribute("GetKeyboardType")]
public TouchScreenKeyboardType get_type();
    public int get_targetDisplay();
    public void set_targetDisplay(int value);
    [NativeNameAttribute("GetRect")]
public static Rect get_area();
    [NativeNameAttribute("IsVisible")]
public static bool get_visible();
    private static void get_area_Injected(Rect& ret);
}
internal class UnityEngine.TouchScreenKeyboard_InternalConstructorHelperArguments : ValueType {
    public UInt32 keyboardType;
    public UInt32 autocorrection;
    public UInt32 multiline;
    public UInt32 secure;
    public UInt32 alert;
    public int characterLimit;
}
public enum UnityEngine.TouchScreenKeyboardType : Enum {
    public int value__;
    public static TouchScreenKeyboardType Default;
    public static TouchScreenKeyboardType ASCIICapable;
    public static TouchScreenKeyboardType NumbersAndPunctuation;
    public static TouchScreenKeyboardType URL;
    public static TouchScreenKeyboardType NumberPad;
    public static TouchScreenKeyboardType PhonePad;
    public static TouchScreenKeyboardType NamePhonePad;
    public static TouchScreenKeyboardType EmailAddress;
    [ObsoleteAttribute("Wii U is no longer supported as of Unity 2018.1.")]
public static TouchScreenKeyboardType NintendoNetworkAccount;
    public static TouchScreenKeyboardType Social;
    public static TouchScreenKeyboardType Search;
    public static TouchScreenKeyboardType DecimalPad;
    public static TouchScreenKeyboardType OneTimeCode;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.TrackedReference : object {
    internal IntPtr m_Ptr;
    public static bool op_Equality(TrackedReference x, TrackedReference y);
    public static bool op_Inequality(TrackedReference x, TrackedReference y);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Implicit(TrackedReference exists);
}
[NativeHeaderAttribute("Runtime/Graphics/GraphicsScriptBindings.h")]
[NativeHeaderAttribute("Runtime/Graphics/TrailRenderer.h")]
public class UnityEngine.TrailRenderer : Renderer {
    [ObsoleteAttribute("Use positionCount instead (UnityUpgradable) -> positionCount", "False")]
public int numPositions { get; }
    public float time { get; public set; }
    public float startWidth { get; public set; }
    public float endWidth { get; public set; }
    public float widthMultiplier { get; public set; }
    public bool autodestruct { get; public set; }
    public bool emitting { get; public set; }
    public int numCornerVertices { get; public set; }
    public int numCapVertices { get; public set; }
    public float minVertexDistance { get; public set; }
    public Color startColor { get; public set; }
    public Color endColor { get; public set; }
    [NativePropertyAttribute("PositionsCount")]
public int positionCount { get; }
    public Vector2 textureScale { get; public set; }
    public float shadowBias { get; public set; }
    public bool generateLightingData { get; public set; }
    public LineTextureMode textureMode { get; public set; }
    public LineAlignment alignment { get; public set; }
    public SpriteMaskInteraction maskInteraction { get; public set; }
    public AnimationCurve widthCurve { get; public set; }
    public Gradient colorGradient { get; public set; }
    public int get_numPositions();
    public float get_time();
    public void set_time(float value);
    public float get_startWidth();
    public void set_startWidth(float value);
    public float get_endWidth();
    public void set_endWidth(float value);
    public float get_widthMultiplier();
    public void set_widthMultiplier(float value);
    public bool get_autodestruct();
    public void set_autodestruct(bool value);
    public bool get_emitting();
    public void set_emitting(bool value);
    public int get_numCornerVertices();
    public void set_numCornerVertices(int value);
    public int get_numCapVertices();
    public void set_numCapVertices(int value);
    public float get_minVertexDistance();
    public void set_minVertexDistance(float value);
    public Color get_startColor();
    public void set_startColor(Color value);
    public Color get_endColor();
    public void set_endColor(Color value);
    public int get_positionCount();
    public void SetPosition(int index, Vector3 position);
    public Vector3 GetPosition(int index);
    public Vector2 get_textureScale();
    public void set_textureScale(Vector2 value);
    public float get_shadowBias();
    public void set_shadowBias(float value);
    public bool get_generateLightingData();
    public void set_generateLightingData(bool value);
    public LineTextureMode get_textureMode();
    public void set_textureMode(LineTextureMode value);
    public LineAlignment get_alignment();
    public void set_alignment(LineAlignment value);
    public SpriteMaskInteraction get_maskInteraction();
    public void set_maskInteraction(SpriteMaskInteraction value);
    public void Clear();
    public void BakeMesh(Mesh mesh, bool useTransform);
    public void BakeMesh(Mesh mesh, Camera camera, bool useTransform);
    public AnimationCurve get_widthCurve();
    public void set_widthCurve(AnimationCurve value);
    public Gradient get_colorGradient();
    public void set_colorGradient(Gradient value);
    private AnimationCurve GetWidthCurveCopy();
    private void SetWidthCurve(AnimationCurve curve);
    private Gradient GetColorGradientCopy();
    private void SetColorGradient(Gradient curve);
    [FreeFunctionAttribute]
public int GetPositions(Vector3[] positions);
    [FreeFunctionAttribute]
public int GetVisiblePositions(Vector3[] positions);
    [FreeFunctionAttribute]
public void SetPositions(Vector3[] positions);
    [FreeFunctionAttribute]
public void AddPosition(Vector3 position);
    [FreeFunctionAttribute]
public void AddPositions(Vector3[] positions);
    public void SetPositions(NativeArray`1<Vector3> positions);
    public void SetPositions(NativeSlice`1<Vector3> positions);
    public int GetPositions(NativeArray`1<Vector3> positions);
    public int GetPositions(NativeSlice`1<Vector3> positions);
    public int GetVisiblePositions(NativeArray`1<Vector3> positions);
    public int GetVisiblePositions(NativeSlice`1<Vector3> positions);
    public void AddPositions(NativeArray`1<Vector3> positions);
    public void AddPositions(NativeSlice`1<Vector3> positions);
    [FreeFunctionAttribute]
private void SetPositionsWithNativeContainer(IntPtr positions, int count);
    [FreeFunctionAttribute]
private int GetPositionsWithNativeContainer(IntPtr positions, int length);
    [FreeFunctionAttribute]
private int GetVisiblePositionsWithNativeContainer(IntPtr positions, int length);
    [FreeFunctionAttribute]
private void AddPositionsWithNativeContainer(IntPtr positions, int length);
    private void get_startColor_Injected(Color& ret);
    private void set_startColor_Injected(Color& value);
    private void get_endColor_Injected(Color& ret);
    private void set_endColor_Injected(Color& value);
    private void SetPosition_Injected(int index, Vector3& position);
    private void GetPosition_Injected(int index, Vector3& ret);
    private void get_textureScale_Injected(Vector2& ret);
    private void set_textureScale_Injected(Vector2& value);
    private void AddPosition_Injected(Vector3& position);
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/ColorGamut.h")]
public enum UnityEngine.TransferFunction : Enum {
    public int value__;
    public static TransferFunction Unknown;
    public static TransferFunction sRGB;
    public static TransferFunction BT1886;
    public static TransferFunction PQ;
    public static TransferFunction Linear;
    public static TransferFunction Gamma22;
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/Transform/ScriptBindings/TransformScriptBindings.h")]
[NativeHeaderAttribute("Configuration/UnityConfigure.h")]
[NativeHeaderAttribute("Runtime/Transform/Transform.h")]
public class UnityEngine.Transform : Component {
    public Vector3 position { get; public set; }
    public Vector3 localPosition { get; public set; }
    public Vector3 eulerAngles { get; public set; }
    public Vector3 localEulerAngles { get; public set; }
    public Vector3 right { get; public set; }
    public Vector3 up { get; public set; }
    public Vector3 forward { get; public set; }
    public Quaternion rotation { get; public set; }
    public Quaternion localRotation { get; public set; }
    [NativeConditionalAttribute("UNITY_EDITOR")]
internal RotationOrder rotationOrder { get; internal set; }
    public Vector3 localScale { get; public set; }
    public Transform parent { get; public set; }
    internal Transform parentInternal { get; internal set; }
    public Matrix4x4 worldToLocalMatrix { get; }
    public Matrix4x4 localToWorldMatrix { get; }
    public Transform root { get; }
    public int childCount { get; }
    public Vector3 lossyScale { get; }
    [NativePropertyAttribute("HasChangedDeprecated")]
public bool hasChanged { get; public set; }
    public int hierarchyCapacity { get; public set; }
    public int hierarchyCount { get; }
    [NativeConditionalAttribute("UNITY_EDITOR")]
internal bool constrainProportionsScale { get; internal set; }
    public Vector3 get_position();
    public void set_position(Vector3 value);
    public Vector3 get_localPosition();
    public void set_localPosition(Vector3 value);
    internal Vector3 GetLocalEulerAngles(RotationOrder order);
    internal void SetLocalEulerAngles(Vector3 euler, RotationOrder order);
    [NativeConditionalAttribute("UNITY_EDITOR")]
internal void SetLocalEulerHint(Vector3 euler);
    public Vector3 get_eulerAngles();
    public void set_eulerAngles(Vector3 value);
    public Vector3 get_localEulerAngles();
    public void set_localEulerAngles(Vector3 value);
    public Vector3 get_right();
    public void set_right(Vector3 value);
    public Vector3 get_up();
    public void set_up(Vector3 value);
    public Vector3 get_forward();
    public void set_forward(Vector3 value);
    public Quaternion get_rotation();
    public void set_rotation(Quaternion value);
    public Quaternion get_localRotation();
    public void set_localRotation(Quaternion value);
    internal RotationOrder get_rotationOrder();
    internal void set_rotationOrder(RotationOrder value);
    [NativeMethodAttribute("GetRotationOrder")]
[NativeConditionalAttribute("UNITY_EDITOR")]
internal int GetRotationOrderInternal();
    [NativeMethodAttribute("SetRotationOrder")]
[NativeConditionalAttribute("UNITY_EDITOR")]
internal void SetRotationOrderInternal(RotationOrder rotationOrder);
    public Vector3 get_localScale();
    public void set_localScale(Vector3 value);
    public Transform get_parent();
    public void set_parent(Transform value);
    internal Transform get_parentInternal();
    internal void set_parentInternal(Transform value);
    private Transform GetParent();
    public void SetParent(Transform p);
    [FreeFunctionAttribute("SetParent")]
public void SetParent(Transform parent, bool worldPositionStays);
    public Matrix4x4 get_worldToLocalMatrix();
    public Matrix4x4 get_localToWorldMatrix();
    public void SetPositionAndRotation(Vector3 position, Quaternion rotation);
    public void SetLocalPositionAndRotation(Vector3 localPosition, Quaternion localRotation);
    public void GetPositionAndRotation(Vector3& position, Quaternion& rotation);
    public void GetLocalPositionAndRotation(Vector3& localPosition, Quaternion& localRotation);
    public void Translate(Vector3 translation, Space relativeTo);
    public void Translate(Vector3 translation);
    public void Translate(float x, float y, float z, Space relativeTo);
    public void Translate(float x, float y, float z);
    public void Translate(Vector3 translation, Transform relativeTo);
    public void Translate(float x, float y, float z, Transform relativeTo);
    public void Rotate(Vector3 eulers, Space relativeTo);
    public void Rotate(Vector3 eulers);
    public void Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo);
    public void Rotate(float xAngle, float yAngle, float zAngle);
    [NativeMethodAttribute("RotateAround")]
internal void RotateAroundInternal(Vector3 axis, float angle);
    public void Rotate(Vector3 axis, float angle, Space relativeTo);
    public void Rotate(Vector3 axis, float angle);
    public void RotateAround(Vector3 point, Vector3 axis, float angle);
    public void LookAt(Transform target, Vector3 worldUp);
    public void LookAt(Transform target);
    public void LookAt(Vector3 worldPosition, Vector3 worldUp);
    public void LookAt(Vector3 worldPosition);
    [FreeFunctionAttribute("Internal_LookAt")]
private void Internal_LookAt(Vector3 worldPosition, Vector3 worldUp);
    public Vector3 TransformDirection(Vector3 direction);
    public Vector3 TransformDirection(float x, float y, float z);
    internal void TransformDirections(Vector3* directions, int count, Vector3* transformedDirections, int transformedCount);
    public void TransformDirections(ReadOnlySpan`1<Vector3> directions, Span`1<Vector3> transformedDirections);
    public void TransformDirections(Span`1<Vector3> directions);
    public Vector3 InverseTransformDirection(Vector3 direction);
    public Vector3 InverseTransformDirection(float x, float y, float z);
    internal void InverseTransformDirections(Vector3* directions, int count, Vector3* transformedDirections, int transformedCount);
    public void InverseTransformDirections(ReadOnlySpan`1<Vector3> directions, Span`1<Vector3> transformedDirections);
    public void InverseTransformDirections(Span`1<Vector3> directions);
    public Vector3 TransformVector(Vector3 vector);
    public Vector3 TransformVector(float x, float y, float z);
    internal void TransformVectors(Vector3* vectors, int count, Vector3* transformedVectors, int transformedCount);
    public void TransformVectors(ReadOnlySpan`1<Vector3> vectors, Span`1<Vector3> transformedVectors);
    public void TransformVectors(Span`1<Vector3> vectors);
    public Vector3 InverseTransformVector(Vector3 vector);
    public Vector3 InverseTransformVector(float x, float y, float z);
    internal void InverseTransformVectors(Vector3* vectors, int count, Vector3* transformedVectors, int transformedCount);
    public void InverseTransformVectors(ReadOnlySpan`1<Vector3> vectors, Span`1<Vector3> transformedVectors);
    public void InverseTransformVectors(Span`1<Vector3> vectors);
    public Vector3 TransformPoint(Vector3 position);
    public Vector3 TransformPoint(float x, float y, float z);
    internal void TransformPoints(Vector3* positions, int count, Vector3* transformedPositions, int transformedCount);
    public void TransformPoints(ReadOnlySpan`1<Vector3> positions, Span`1<Vector3> transformedPositions);
    public void TransformPoints(Span`1<Vector3> positions);
    public Vector3 InverseTransformPoint(Vector3 position);
    public Vector3 InverseTransformPoint(float x, float y, float z);
    internal void InverseTransformPoints(Vector3* positions, int count, Vector3* transformedPositions, int transformedCount);
    public void InverseTransformPoints(ReadOnlySpan`1<Vector3> positions, Span`1<Vector3> transformedPositions);
    public void InverseTransformPoints(Span`1<Vector3> positions);
    public Transform get_root();
    private Transform GetRoot();
    [NativeMethodAttribute("GetChildrenCount")]
public int get_childCount();
    [FreeFunctionAttribute("DetachChildren")]
public void DetachChildren();
    public void SetAsFirstSibling();
    public void SetAsLastSibling();
    public void SetSiblingIndex(int index);
    [NativeMethodAttribute("MoveAfterSiblingInternal")]
internal void MoveAfterSibling(Transform transform, bool notifyEditorAndMarkDirty);
    public int GetSiblingIndex();
    [FreeFunctionAttribute]
private static Transform FindRelativeTransformWithPath(Transform transform, string path, bool isActiveOnly);
    public Transform Find(string n);
    [NativeConditionalAttribute("UNITY_EDITOR")]
internal void SendTransformChangedScale();
    [NativeMethodAttribute("GetWorldScaleLossy")]
public Vector3 get_lossyScale();
    [FreeFunctionAttribute("Internal_IsChildOrSameTransform")]
public bool IsChildOf(Transform parent);
    public bool get_hasChanged();
    public void set_hasChanged(bool value);
    [ObsoleteAttribute("FindChild has been deprecated. Use Find instead (UnityUpgradable) -> Find([mscorlib] System.String)", "False")]
public Transform FindChild(string n);
    public sealed virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("warning use Transform.Rotate instead.")]
public void RotateAround(Vector3 axis, float angle);
    [ObsoleteAttribute("warning use Transform.Rotate instead.")]
public void RotateAroundLocal(Vector3 axis, float angle);
    [FreeFunctionAttribute("GetChild")]
[NativeThrowsAttribute]
public Transform GetChild(int index);
    [NativeMethodAttribute("GetChildrenCount")]
[ObsoleteAttribute("warning use Transform.childCount instead (UnityUpgradable) -> Transform.childCount", "False")]
public int GetChildCount();
    public int get_hierarchyCapacity();
    public void set_hierarchyCapacity(int value);
    [FreeFunctionAttribute("GetHierarchyCapacity")]
private int internal_getHierarchyCapacity();
    [FreeFunctionAttribute("SetHierarchyCapacity")]
private void internal_setHierarchyCapacity(int value);
    public int get_hierarchyCount();
    [FreeFunctionAttribute("GetHierarchyCount")]
private int internal_getHierarchyCount();
    [NativeConditionalAttribute("UNITY_EDITOR")]
[FreeFunctionAttribute("IsNonUniformScaleTransform")]
internal bool IsNonUniformScaleTransform();
    internal bool get_constrainProportionsScale();
    internal void set_constrainProportionsScale(bool value);
    [NativeConditionalAttribute("UNITY_EDITOR")]
private void SetConstrainProportionsScale(bool isLinked);
    [NativeConditionalAttribute("UNITY_EDITOR")]
private bool IsConstrainProportionsScale();
    private void get_position_Injected(Vector3& ret);
    private void set_position_Injected(Vector3& value);
    private void get_localPosition_Injected(Vector3& ret);
    private void set_localPosition_Injected(Vector3& value);
    private void GetLocalEulerAngles_Injected(RotationOrder order, Vector3& ret);
    private void SetLocalEulerAngles_Injected(Vector3& euler, RotationOrder order);
    private void SetLocalEulerHint_Injected(Vector3& euler);
    private void get_rotation_Injected(Quaternion& ret);
    private void set_rotation_Injected(Quaternion& value);
    private void get_localRotation_Injected(Quaternion& ret);
    private void set_localRotation_Injected(Quaternion& value);
    private void get_localScale_Injected(Vector3& ret);
    private void set_localScale_Injected(Vector3& value);
    private void get_worldToLocalMatrix_Injected(Matrix4x4& ret);
    private void get_localToWorldMatrix_Injected(Matrix4x4& ret);
    private void SetPositionAndRotation_Injected(Vector3& position, Quaternion& rotation);
    private void SetLocalPositionAndRotation_Injected(Vector3& localPosition, Quaternion& localRotation);
    private void RotateAroundInternal_Injected(Vector3& axis, float angle);
    private void Internal_LookAt_Injected(Vector3& worldPosition, Vector3& worldUp);
    private void TransformDirection_Injected(Vector3& direction, Vector3& ret);
    private void InverseTransformDirection_Injected(Vector3& direction, Vector3& ret);
    private void TransformVector_Injected(Vector3& vector, Vector3& ret);
    private void InverseTransformVector_Injected(Vector3& vector, Vector3& ret);
    private void TransformPoint_Injected(Vector3& position, Vector3& ret);
    private void InverseTransformPoint_Injected(Vector3& position, Vector3& ret);
    private void get_lossyScale_Injected(Vector3& ret);
    private void RotateAround_Injected(Vector3& axis, float angle);
    private void RotateAroundLocal_Injected(Vector3& axis, float angle);
}
internal class UnityEngine.TransformDispatchData : ValueType {
    public NativeArray`1<int> transformedID;
    public NativeArray`1<int> parentID;
    public NativeArray`1<Matrix4x4> localToWorldMatrices;
    public NativeArray`1<Vector3> positions;
    public NativeArray`1<Quaternion> rotations;
    public NativeArray`1<Vector3> scales;
    public sealed virtual void Dispose();
}
public enum UnityEngine.TransparencySortMode : Enum {
    public int value__;
    public static TransparencySortMode Default;
    public static TransparencySortMode Perspective;
    public static TransparencySortMode Orthographic;
    public static TransparencySortMode CustomAxis;
}
internal class UnityEngine.TypeDispatchData : ValueType {
    public Object[] changed;
    public NativeArray`1<int> changedID;
    public NativeArray`1<int> destroyedID;
    public sealed virtual void Dispose();
}
public static class UnityEngine.Types : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This was an internal method which is no longer used", "True")]
public static Type GetType(string typeName, string assemblyName);
}
public abstract class UnityEngine.U2D.Light2DBase : MonoBehaviour {
}
internal enum UnityEngine.U2D.Light2DType : Enum {
    public int value__;
    public static Light2DType Parametric;
    public static Light2DType Freeform;
    public static Light2DType Sprite;
    public static Light2DType Point;
    public static Light2DType Global;
}
[MovedFromAttribute("UnityEngine.Experimental.U2D")]
[NativeHeaderAttribute("Runtime/2D/Common/PixelSnapping.h")]
public static class UnityEngine.U2D.PixelPerfectRendering : object {
    public static float pixelSnapSpacing { get; public set; }
    [FreeFunctionAttribute("GetPixelSnapSpacing")]
public static float get_pixelSnapSpacing();
    [FreeFunctionAttribute("SetPixelSnapSpacing")]
public static void set_pixelSnapSpacing(float value);
}
[NativeTypeAttribute]
[NativeHeaderAttribute("Runtime/Graphics/SpriteFrame.h")]
public class UnityEngine.U2D.SpriteAtlas : Object {
    public bool isVariant { get; }
    public string tag { get; }
    public int spriteCount { get; }
    [NativeMethodAttribute("IsVariant")]
public bool get_isVariant();
    public string get_tag();
    public int get_spriteCount();
    public bool CanBindTo(Sprite sprite);
    public Sprite GetSprite(string name);
    public int GetSprites(Sprite[] sprites);
    public int GetSprites(Sprite[] sprites, string name);
    private int GetSpritesScripting(Sprite[] sprites);
    private int GetSpritesWithNameScripting(Sprite[] sprites, string name);
}
[StaticAccessorAttribute("GetSpriteAtlasManager()", "0")]
[NativeHeaderAttribute("Runtime/2D/SpriteAtlas/SpriteAtlas.h")]
[NativeHeaderAttribute("Runtime/2D/SpriteAtlas/SpriteAtlasManager.h")]
public class UnityEngine.U2D.SpriteAtlasManager : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`2<string, Action`1<SpriteAtlas>> atlasRequested;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<SpriteAtlas> atlasRegistered;
    [CompilerGeneratedAttribute]
public static void add_atlasRequested(Action`2<string, Action`1<SpriteAtlas>> value);
    [CompilerGeneratedAttribute]
public static void remove_atlasRequested(Action`2<string, Action`1<SpriteAtlas>> value);
    [RequiredByNativeCodeAttribute]
private static bool RequestAtlas(string tag);
    [CompilerGeneratedAttribute]
public static void add_atlasRegistered(Action`1<SpriteAtlas> value);
    [CompilerGeneratedAttribute]
public static void remove_atlasRegistered(Action`1<SpriteAtlas> value);
    [RequiredByNativeCodeAttribute]
private static void PostRegisteredAtlas(SpriteAtlas spriteAtlas);
    internal static void Register(SpriteAtlas spriteAtlas);
}
[NativeTypeAttribute("1", "ScriptingSpriteBone")]
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Runtime/2D/Common/SpriteDataMarshalling.h")]
[MovedFromAttribute("UnityEngine.Experimental.U2D")]
[NativeHeaderAttribute("Runtime/2D/Common/SpriteDataAccess.h")]
public class UnityEngine.U2D.SpriteBone : ValueType {
    [NativeNameAttribute("name")]
[SerializeField]
private string m_Name;
    [NativeNameAttribute("guid")]
[SerializeField]
private string m_Guid;
    [NativeNameAttribute("position")]
[SerializeField]
private Vector3 m_Position;
    [SerializeField]
[NativeNameAttribute("rotation")]
private Quaternion m_Rotation;
    [NativeNameAttribute("length")]
[SerializeField]
private float m_Length;
    [SerializeField]
[NativeNameAttribute("parentId")]
private int m_ParentId;
    [SerializeField]
[NativeNameAttribute("color")]
private Color32 m_Color;
    public string name { get; public set; }
    public string guid { get; public set; }
    public Vector3 position { get; public set; }
    public Quaternion rotation { get; public set; }
    public float length { get; public set; }
    public int parentId { get; public set; }
    public Color32 color { get; public set; }
    public string get_name();
    public void set_name(string value);
    public string get_guid();
    public void set_guid(string value);
    public Vector3 get_position();
    public void set_position(Vector3 value);
    public Quaternion get_rotation();
    public void set_rotation(Quaternion value);
    public float get_length();
    public void set_length(float value);
    public int get_parentId();
    public void set_parentId(int value);
    public Color32 get_color();
    public void set_color(Color32 value);
}
[VisibleToOtherModulesAttribute]
internal class UnityEngine.U2D.SpriteChannelInfo : ValueType {
    [NativeNameAttribute("buffer")]
private IntPtr m_Buffer;
    [NativeNameAttribute("count")]
private int m_Count;
    [NativeNameAttribute("offset")]
private int m_Offset;
    [NativeNameAttribute("stride")]
private int m_Stride;
    public Void* buffer { get; public set; }
    public int count { get; public set; }
    public int offset { get; public set; }
    public int stride { get; public set; }
    public Void* get_buffer();
    public void set_buffer(Void* value);
    public int get_count();
    public void set_count(int value);
    public int get_offset();
    public void set_offset(int value);
    public int get_stride();
    public void set_stride(int value);
}
[NativeHeaderAttribute("Runtime/2D/Common/SpriteDataAccess.h")]
[NativeHeaderAttribute("Runtime/Graphics/SpriteFrame.h")]
[ExtensionAttribute]
public static class UnityEngine.U2D.SpriteDataAccessExtensions : object {
    private static void CheckAttributeTypeMatchesAndThrow(VertexAttribute channel);
    [ExtensionAttribute]
public static NativeSlice`1<T> GetVertexAttribute(Sprite sprite, VertexAttribute channel);
    [ExtensionAttribute]
public static void SetVertexAttribute(Sprite sprite, VertexAttribute channel, NativeArray`1<T> src);
    [ExtensionAttribute]
public static NativeArray`1<Matrix4x4> GetBindPoses(Sprite sprite);
    [ExtensionAttribute]
public static void SetBindPoses(Sprite sprite, NativeArray`1<Matrix4x4> src);
    [ExtensionAttribute]
public static NativeArray`1<ushort> GetIndices(Sprite sprite);
    [ExtensionAttribute]
public static void SetIndices(Sprite sprite, NativeArray`1<ushort> src);
    [ExtensionAttribute]
public static SpriteBone[] GetBones(Sprite sprite);
    [ExtensionAttribute]
public static void SetBones(Sprite sprite, SpriteBone[] src);
    [ExtensionAttribute]
[NativeNameAttribute("HasChannel")]
public static bool HasVertexAttribute(Sprite sprite, VertexAttribute channel);
    [ExtensionAttribute]
public static void SetVertexCount(Sprite sprite, int count);
    [ExtensionAttribute]
public static int GetVertexCount(Sprite sprite);
    private static SpriteChannelInfo GetBindPoseInfo(Sprite sprite);
    private static void SetBindPoseData(Sprite sprite, Void* src, int count);
    private static SpriteChannelInfo GetIndicesInfo(Sprite sprite);
    private static void SetIndicesData(Sprite sprite, Void* src, int count);
    private static SpriteChannelInfo GetChannelInfo(Sprite sprite, VertexAttribute channel);
    private static void SetChannelData(Sprite sprite, VertexAttribute channel, Void* src);
    private static SpriteBone[] GetBoneInfo(Sprite sprite);
    private static void SetBoneData(Sprite sprite, SpriteBone[] src);
    internal static int GetPrimaryVertexStreamSize(Sprite sprite);
    private static void GetBindPoseInfo_Injected(Sprite sprite, SpriteChannelInfo& ret);
    private static void GetIndicesInfo_Injected(Sprite sprite, SpriteChannelInfo& ret);
    private static void GetChannelInfo_Injected(Sprite sprite, VertexAttribute channel, SpriteChannelInfo& ret);
}
[NativeHeaderAttribute("Runtime/Graphics/Mesh/SpriteRenderer.h")]
[NativeHeaderAttribute("Runtime/2D/Common/SpriteDataAccess.h")]
[ExtensionAttribute]
public static class UnityEngine.U2D.SpriteRendererDataAccessExtensions : object {
    [ExtensionAttribute]
internal static void SetDeformableBuffer(SpriteRenderer spriteRenderer, NativeArray`1<byte> src);
    [ExtensionAttribute]
internal static void SetDeformableBuffer(SpriteRenderer spriteRenderer, NativeArray`1<Vector3> src);
    internal static void SetBatchDeformableBufferAndLocalAABBArray(SpriteRenderer[] spriteRenderers, NativeArray`1<IntPtr> buffers, NativeArray`1<int> bufferSizes, NativeArray`1<Bounds> bounds);
    [ExtensionAttribute]
internal static bool IsUsingDeformableBuffer(SpriteRenderer spriteRenderer, IntPtr buffer);
    [ExtensionAttribute]
public static void DeactivateDeformableBuffer(SpriteRenderer renderer);
    [ExtensionAttribute]
internal static void SetLocalAABB(SpriteRenderer renderer, Bounds aabb);
    private static void SetDeformableBuffer(SpriteRenderer spriteRenderer, Void* src, int count);
    private static void SetBatchDeformableBufferAndLocalAABBArray(SpriteRenderer[] spriteRenderers, Void* buffers, Void* bufferSizes, Void* bounds, int count);
    private static bool IsUsingDeformableBuffer(SpriteRenderer spriteRenderer, Void* buffer);
    private static void SetLocalAABB_Injected(SpriteRenderer renderer, Bounds& aabb);
}
internal static class UnityEngine.UINumericFieldsUtils : object {
    public static string k_AllowedCharactersForFloat;
    public static string k_AllowedCharactersForInt;
    public static string k_DoubleFieldFormatString;
    public static string k_FloatFieldFormatString;
    public static string k_IntFieldFormatString;
    private static UINumericFieldsUtils();
    public static bool TryConvertStringToDouble(string str, Double& value);
    public static bool TryConvertStringToDouble(string str, Double& value, Expression& expr);
    public static bool TryConvertStringToDouble(string str, string initialValueAsString, Double& value);
    public static bool TryConvertStringToFloat(string str, string initialValueAsString, Single& value);
    public static bool TryConvertStringToLong(string str, Int64& value);
    public static bool TryConvertStringToLong(string str, Int64& value, Expression& expr);
    public static bool TryConvertStringToLong(string str, string initialValueAsString, Int64& value);
    public static bool TryConvertStringToULong(string str, UInt64& value, Expression& expr);
    public static bool TryConvertStringToULong(string str, string initialValueAsString, UInt64& value);
    public static bool TryConvertStringToInt(string str, string initialValueAsString, Int32& value);
    public static bool TryConvertStringToUInt(string str, string initialValueAsString, UInt32& value);
}
public class UnityEngine.UnassignedReferenceException : SystemException {
    private static int Result;
    private string unityStackTrace;
    public UnassignedReferenceException(string message);
    public UnassignedReferenceException(string message, Exception innerException);
    protected UnassignedReferenceException(SerializationInfo info, StreamingContext context);
}
[NativeHeaderAttribute("PlatformDependent/iPhonePlayer/IOSScriptBindings.h")]
internal class UnityEngine.UnhandledExceptionHandler : object {
    [RequiredByNativeCodeAttribute]
private static void RegisterUECatcher();
}
[AttributeUsageAttribute("1")]
public class UnityEngine.UnityAPICompatibilityVersionAttribute : Attribute {
    private string _version;
    private String[] _configurationAssembliesHashes;
    public string version { get; }
    internal String[] configurationAssembliesHashes { get; }
    [ObsoleteAttribute("This overload of the attribute has been deprecated. Use the constructor that takes the version and a boolean", "True")]
public UnityAPICompatibilityVersionAttribute(string version);
    public UnityAPICompatibilityVersionAttribute(string version, bool checkOnlyUnityVersion);
    public UnityAPICompatibilityVersionAttribute(string version, String[] configurationAssembliesHashes);
    public string get_version();
    internal String[] get_configurationAssembliesHashes();
}
[NativeHeaderAttribute("Runtime/Export/UnityEvent/UnityEventQueueSystem.bindings.h")]
public class UnityEngine.UnityEventQueueSystem : object {
    public static string GenerateEventIdForPayload(string eventPayloadName);
    [FreeFunctionAttribute]
public static IntPtr GetGlobalEventQueue();
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.UnityException : SystemException {
    private static int Result;
    private string unityStackTrace;
    public UnityException(string message);
    public UnityException(string message, Exception innerException);
    protected UnityException(SerializationInfo info, StreamingContext context);
}
[NativeHeaderAttribute("Runtime/Export/Logging/UnityLogWriter.bindings.h")]
internal class UnityEngine.UnityLogWriter : TextWriter {
    public Encoding Encoding { get; }
    [ThreadAndSerializationSafeAttribute]
public static void WriteStringToUnityLog(string s);
    [FreeFunctionAttribute]
private static void WriteStringToUnityLogImpl(string s);
    public static void Init();
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(string s);
    public virtual void Write(Char[] buffer, int index, int count);
}
internal class UnityEngine.UnitySynchronizationContext : SynchronizationContext {
    private static int kAwqInitialCapacity;
    private List`1<WorkRequest> m_AsyncWorkQueue;
    private List`1<WorkRequest> m_CurrentFrameWork;
    private int m_MainThreadID;
    private int m_TrackedCount;
    private UnitySynchronizationContext(int mainThreadID);
    private UnitySynchronizationContext(List`1<WorkRequest> queue, int mainThreadID);
    public virtual void Send(SendOrPostCallback callback, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    public virtual void Post(SendOrPostCallback callback, object state);
    public virtual SynchronizationContext CreateCopy();
    public void Exec();
    private bool HasPendingTasks();
    [RequiredByNativeCodeAttribute]
private static void InitializeSynchronizationContext();
    [RequiredByNativeCodeAttribute]
private static void ExecuteTasks();
    [RequiredByNativeCodeAttribute]
private static bool ExecutePendingTasks(long millisecondsTimeout);
}
public enum UnityEngine.UserAuthorization : Enum {
    public int value__;
    public static UserAuthorization WebCam;
    public static UserAuthorization Microphone;
}
[RequiredByNativeCodeAttribute]
[Il2CppEagerStaticClassConstructionAttribute]
[NativeClassAttribute("Vector2f")]
[DefaultMemberAttribute("Item")]
public class UnityEngine.Vector2 : ValueType {
    public float x;
    public float y;
    private static Vector2 zeroVector;
    private static Vector2 oneVector;
    private static Vector2 upVector;
    private static Vector2 downVector;
    private static Vector2 leftVector;
    private static Vector2 rightVector;
    private static Vector2 positiveInfinityVector;
    private static Vector2 negativeInfinityVector;
    public static float kEpsilon;
    public static float kEpsilonNormalSqrt;
    public float Item { get; public set; }
    public Vector2 normalized { get; }
    public float magnitude { get; }
    public float sqrMagnitude { get; }
    public static Vector2 zero { get; }
    public static Vector2 one { get; }
    public static Vector2 up { get; }
    public static Vector2 down { get; }
    public static Vector2 left { get; }
    public static Vector2 right { get; }
    public static Vector2 positiveInfinity { get; }
    public static Vector2 negativeInfinity { get; }
    public Vector2(float x, float y);
    private static Vector2();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Set(float newX, float newY);
    public static Vector2 Lerp(Vector2 a, Vector2 b, float t);
    public static Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t);
    public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);
    public static Vector2 Scale(Vector2 a, Vector2 b);
    public void Scale(Vector2 scale);
    public void Normalize();
    public Vector2 get_normalized();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Vector2 other);
    public static Vector2 Reflect(Vector2 inDirection, Vector2 inNormal);
    public static Vector2 Perpendicular(Vector2 inDirection);
    public static float Dot(Vector2 lhs, Vector2 rhs);
    public float get_magnitude();
    public float get_sqrMagnitude();
    public static float Angle(Vector2 from, Vector2 to);
    public static float SignedAngle(Vector2 from, Vector2 to);
    public static float Distance(Vector2 a, Vector2 b);
    public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);
    public static float SqrMagnitude(Vector2 a);
    public float SqrMagnitude();
    public static Vector2 Min(Vector2 lhs, Vector2 rhs);
    public static Vector2 Max(Vector2 lhs, Vector2 rhs);
    [ExcludeFromDocsAttribute]
public static Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed);
    [ExcludeFromDocsAttribute]
public static Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime);
    public static Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed, float deltaTime);
    public static Vector2 op_Addition(Vector2 a, Vector2 b);
    public static Vector2 op_Subtraction(Vector2 a, Vector2 b);
    public static Vector2 op_Multiply(Vector2 a, Vector2 b);
    public static Vector2 op_Division(Vector2 a, Vector2 b);
    public static Vector2 op_UnaryNegation(Vector2 a);
    public static Vector2 op_Multiply(Vector2 a, float d);
    public static Vector2 op_Multiply(float d, Vector2 a);
    public static Vector2 op_Division(Vector2 a, float d);
    public static bool op_Equality(Vector2 lhs, Vector2 rhs);
    public static bool op_Inequality(Vector2 lhs, Vector2 rhs);
    public static Vector2 op_Implicit(Vector3 v);
    public static Vector3 op_Implicit(Vector2 v);
    public static Vector2 get_zero();
    public static Vector2 get_one();
    public static Vector2 get_up();
    public static Vector2 get_down();
    public static Vector2 get_left();
    public static Vector2 get_right();
    public static Vector2 get_positiveInfinity();
    public static Vector2 get_negativeInfinity();
}
[UsedByNativeCodeAttribute]
[DefaultMemberAttribute("Item")]
[NativeTypeAttribute("Runtime/Math/Vector2Int.h")]
[Il2CppEagerStaticClassConstructionAttribute]
public class UnityEngine.Vector2Int : ValueType {
    private int m_X;
    private int m_Y;
    private static Vector2Int s_Zero;
    private static Vector2Int s_One;
    private static Vector2Int s_Up;
    private static Vector2Int s_Down;
    private static Vector2Int s_Left;
    private static Vector2Int s_Right;
    public int x { get; public set; }
    public int y { get; public set; }
    public int Item { get; public set; }
    public float magnitude { get; }
    public int sqrMagnitude { get; }
    public static Vector2Int zero { get; }
    public static Vector2Int one { get; }
    public static Vector2Int up { get; }
    public static Vector2Int down { get; }
    public static Vector2Int left { get; }
    public static Vector2Int right { get; }
    public Vector2Int(int x, int y);
    private static Vector2Int();
    public int get_x();
    public void set_x(int value);
    public int get_y();
    public void set_y(int value);
    public void Set(int x, int y);
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public float get_magnitude();
    public int get_sqrMagnitude();
    public static float Distance(Vector2Int a, Vector2Int b);
    public static Vector2Int Min(Vector2Int lhs, Vector2Int rhs);
    public static Vector2Int Max(Vector2Int lhs, Vector2Int rhs);
    public static Vector2Int Scale(Vector2Int a, Vector2Int b);
    public void Scale(Vector2Int scale);
    public void Clamp(Vector2Int min, Vector2Int max);
    public static Vector2 op_Implicit(Vector2Int v);
    public static Vector3Int op_Explicit(Vector2Int v);
    public static Vector2Int FloorToInt(Vector2 v);
    public static Vector2Int CeilToInt(Vector2 v);
    public static Vector2Int RoundToInt(Vector2 v);
    public static Vector2Int op_UnaryNegation(Vector2Int v);
    public static Vector2Int op_Addition(Vector2Int a, Vector2Int b);
    public static Vector2Int op_Subtraction(Vector2Int a, Vector2Int b);
    public static Vector2Int op_Multiply(Vector2Int a, Vector2Int b);
    public static Vector2Int op_Multiply(int a, Vector2Int b);
    public static Vector2Int op_Multiply(Vector2Int a, int b);
    public static Vector2Int op_Division(Vector2Int a, int b);
    public static bool op_Equality(Vector2Int lhs, Vector2Int rhs);
    public static bool op_Inequality(Vector2Int lhs, Vector2Int rhs);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Vector2Int other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector2Int get_zero();
    public static Vector2Int get_one();
    public static Vector2Int get_up();
    public static Vector2Int get_down();
    public static Vector2Int get_left();
    public static Vector2Int get_right();
}
[NativeClassAttribute("Vector3f")]
[DefaultMemberAttribute("Item")]
[NativeTypeAttribute]
[NativeHeaderAttribute("Runtime/Math/Vector3.h")]
[NativeHeaderAttribute("Runtime/Math/MathScripting.h")]
[RequiredByNativeCodeAttribute]
[Il2CppEagerStaticClassConstructionAttribute]
public class UnityEngine.Vector3 : ValueType {
    public static float kEpsilon;
    public static float kEpsilonNormalSqrt;
    public float x;
    public float y;
    public float z;
    private static Vector3 zeroVector;
    private static Vector3 oneVector;
    private static Vector3 upVector;
    private static Vector3 downVector;
    private static Vector3 leftVector;
    private static Vector3 rightVector;
    private static Vector3 forwardVector;
    private static Vector3 backVector;
    private static Vector3 positiveInfinityVector;
    private static Vector3 negativeInfinityVector;
    public float Item { get; public set; }
    public Vector3 normalized { get; }
    public float magnitude { get; }
    public float sqrMagnitude { get; }
    public static Vector3 zero { get; }
    public static Vector3 one { get; }
    public static Vector3 forward { get; }
    public static Vector3 back { get; }
    public static Vector3 up { get; }
    public static Vector3 down { get; }
    public static Vector3 left { get; }
    public static Vector3 right { get; }
    public static Vector3 positiveInfinity { get; }
    public static Vector3 negativeInfinity { get; }
    [ObsoleteAttribute("Use Vector3.forward instead.")]
public static Vector3 fwd { get; }
    public Vector3(float x, float y, float z);
    public Vector3(float x, float y);
    private static Vector3();
    [FreeFunctionAttribute("VectorScripting::Slerp")]
public static Vector3 Slerp(Vector3 a, Vector3 b, float t);
    [FreeFunctionAttribute("VectorScripting::SlerpUnclamped")]
public static Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t);
    [FreeFunctionAttribute("VectorScripting::OrthoNormalize")]
private static void OrthoNormalize2(Vector3& a, Vector3& b);
    public static void OrthoNormalize(Vector3& normal, Vector3& tangent);
    [FreeFunctionAttribute("VectorScripting::OrthoNormalize")]
private static void OrthoNormalize3(Vector3& a, Vector3& b, Vector3& c);
    public static void OrthoNormalize(Vector3& normal, Vector3& tangent, Vector3& binormal);
    [FreeFunctionAttribute]
public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta);
    public static Vector3 Lerp(Vector3 a, Vector3 b, float t);
    public static Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t);
    public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);
    [ExcludeFromDocsAttribute]
public static Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed);
    [ExcludeFromDocsAttribute]
public static Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime);
    public static Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed, float deltaTime);
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Set(float newX, float newY, float newZ);
    public static Vector3 Scale(Vector3 a, Vector3 b);
    public void Scale(Vector3 scale);
    public static Vector3 Cross(Vector3 lhs, Vector3 rhs);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Vector3 other);
    public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);
    public static Vector3 Normalize(Vector3 value);
    public void Normalize();
    public Vector3 get_normalized();
    public static float Dot(Vector3 lhs, Vector3 rhs);
    public static Vector3 Project(Vector3 vector, Vector3 onNormal);
    public static Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal);
    public static float Angle(Vector3 from, Vector3 to);
    public static float SignedAngle(Vector3 from, Vector3 to, Vector3 axis);
    public static float Distance(Vector3 a, Vector3 b);
    public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);
    public static float Magnitude(Vector3 vector);
    public float get_magnitude();
    public static float SqrMagnitude(Vector3 vector);
    public float get_sqrMagnitude();
    public static Vector3 Min(Vector3 lhs, Vector3 rhs);
    public static Vector3 Max(Vector3 lhs, Vector3 rhs);
    public static Vector3 get_zero();
    public static Vector3 get_one();
    public static Vector3 get_forward();
    public static Vector3 get_back();
    public static Vector3 get_up();
    public static Vector3 get_down();
    public static Vector3 get_left();
    public static Vector3 get_right();
    public static Vector3 get_positiveInfinity();
    public static Vector3 get_negativeInfinity();
    public static Vector3 op_Addition(Vector3 a, Vector3 b);
    public static Vector3 op_Subtraction(Vector3 a, Vector3 b);
    public static Vector3 op_UnaryNegation(Vector3 a);
    public static Vector3 op_Multiply(Vector3 a, float d);
    public static Vector3 op_Multiply(float d, Vector3 a);
    public static Vector3 op_Division(Vector3 a, float d);
    public static bool op_Equality(Vector3 lhs, Vector3 rhs);
    public static bool op_Inequality(Vector3 lhs, Vector3 rhs);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector3 get_fwd();
    [ObsoleteAttribute("Use Vector3.Angle instead. AngleBetween uses radians instead of degrees and was deprecated for this reason")]
public static float AngleBetween(Vector3 from, Vector3 to);
    [ObsoleteAttribute("Use Vector3.ProjectOnPlane instead.")]
public static Vector3 Exclude(Vector3 excludeThis, Vector3 fromThat);
    private static void Slerp_Injected(Vector3& a, Vector3& b, float t, Vector3& ret);
    private static void SlerpUnclamped_Injected(Vector3& a, Vector3& b, float t, Vector3& ret);
    private static void RotateTowards_Injected(Vector3& current, Vector3& target, float maxRadiansDelta, float maxMagnitudeDelta, Vector3& ret);
}
[UsedByNativeCodeAttribute]
[DefaultMemberAttribute("Item")]
[Il2CppEagerStaticClassConstructionAttribute]
public class UnityEngine.Vector3Int : ValueType {
    private int m_X;
    private int m_Y;
    private int m_Z;
    private static Vector3Int s_Zero;
    private static Vector3Int s_One;
    private static Vector3Int s_Up;
    private static Vector3Int s_Down;
    private static Vector3Int s_Left;
    private static Vector3Int s_Right;
    private static Vector3Int s_Forward;
    private static Vector3Int s_Back;
    public int x { get; public set; }
    public int y { get; public set; }
    public int z { get; public set; }
    public int Item { get; public set; }
    public float magnitude { get; }
    public int sqrMagnitude { get; }
    public static Vector3Int zero { get; }
    public static Vector3Int one { get; }
    public static Vector3Int up { get; }
    public static Vector3Int down { get; }
    public static Vector3Int left { get; }
    public static Vector3Int right { get; }
    public static Vector3Int forward { get; }
    public static Vector3Int back { get; }
    public Vector3Int(int x, int y);
    public Vector3Int(int x, int y, int z);
    private static Vector3Int();
    public int get_x();
    public void set_x(int value);
    public int get_y();
    public void set_y(int value);
    public int get_z();
    public void set_z(int value);
    public void Set(int x, int y, int z);
    public int get_Item(int index);
    public void set_Item(int index, int value);
    public float get_magnitude();
    public int get_sqrMagnitude();
    public static float Distance(Vector3Int a, Vector3Int b);
    public static Vector3Int Min(Vector3Int lhs, Vector3Int rhs);
    public static Vector3Int Max(Vector3Int lhs, Vector3Int rhs);
    public static Vector3Int Scale(Vector3Int a, Vector3Int b);
    public void Scale(Vector3Int scale);
    public void Clamp(Vector3Int min, Vector3Int max);
    public static Vector3 op_Implicit(Vector3Int v);
    public static Vector2Int op_Explicit(Vector3Int v);
    public static Vector3Int FloorToInt(Vector3 v);
    public static Vector3Int CeilToInt(Vector3 v);
    public static Vector3Int RoundToInt(Vector3 v);
    public static Vector3Int op_Addition(Vector3Int a, Vector3Int b);
    public static Vector3Int op_Subtraction(Vector3Int a, Vector3Int b);
    public static Vector3Int op_Multiply(Vector3Int a, Vector3Int b);
    public static Vector3Int op_UnaryNegation(Vector3Int a);
    public static Vector3Int op_Multiply(Vector3Int a, int b);
    public static Vector3Int op_Multiply(int a, Vector3Int b);
    public static Vector3Int op_Division(Vector3Int a, int b);
    public static bool op_Equality(Vector3Int lhs, Vector3Int rhs);
    public static bool op_Inequality(Vector3Int lhs, Vector3Int rhs);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Vector3Int other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector3Int get_zero();
    public static Vector3Int get_one();
    public static Vector3Int get_up();
    public static Vector3Int get_down();
    public static Vector3Int get_left();
    public static Vector3Int get_right();
    public static Vector3Int get_forward();
    public static Vector3Int get_back();
}
[RequiredByNativeCodeAttribute]
[NativeClassAttribute("Vector4f")]
[NativeHeaderAttribute("Runtime/Math/Vector4.h")]
[Il2CppEagerStaticClassConstructionAttribute]
[DefaultMemberAttribute("Item")]
public class UnityEngine.Vector4 : ValueType {
    public static float kEpsilon;
    public float x;
    public float y;
    public float z;
    public float w;
    private static Vector4 zeroVector;
    private static Vector4 oneVector;
    private static Vector4 positiveInfinityVector;
    private static Vector4 negativeInfinityVector;
    public float Item { get; public set; }
    public Vector4 normalized { get; }
    public float magnitude { get; }
    public float sqrMagnitude { get; }
    public static Vector4 zero { get; }
    public static Vector4 one { get; }
    public static Vector4 positiveInfinity { get; }
    public static Vector4 negativeInfinity { get; }
    public Vector4(float x, float y, float z, float w);
    public Vector4(float x, float y, float z);
    public Vector4(float x, float y);
    private static Vector4();
    public float get_Item(int index);
    public void set_Item(int index, float value);
    public void Set(float newX, float newY, float newZ, float newW);
    public static Vector4 Lerp(Vector4 a, Vector4 b, float t);
    public static Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t);
    public static Vector4 MoveTowards(Vector4 current, Vector4 target, float maxDistanceDelta);
    public static Vector4 Scale(Vector4 a, Vector4 b);
    public void Scale(Vector4 scale);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Vector4 other);
    public static Vector4 Normalize(Vector4 a);
    public void Normalize();
    public Vector4 get_normalized();
    public static float Dot(Vector4 a, Vector4 b);
    public static Vector4 Project(Vector4 a, Vector4 b);
    public static float Distance(Vector4 a, Vector4 b);
    public static float Magnitude(Vector4 a);
    public float get_magnitude();
    public float get_sqrMagnitude();
    public static Vector4 Min(Vector4 lhs, Vector4 rhs);
    public static Vector4 Max(Vector4 lhs, Vector4 rhs);
    public static Vector4 get_zero();
    public static Vector4 get_one();
    public static Vector4 get_positiveInfinity();
    public static Vector4 get_negativeInfinity();
    public static Vector4 op_Addition(Vector4 a, Vector4 b);
    public static Vector4 op_Subtraction(Vector4 a, Vector4 b);
    public static Vector4 op_UnaryNegation(Vector4 a);
    public static Vector4 op_Multiply(Vector4 a, float d);
    public static Vector4 op_Multiply(float d, Vector4 a);
    public static Vector4 op_Division(Vector4 a, float d);
    public static bool op_Equality(Vector4 lhs, Vector4 rhs);
    public static bool op_Inequality(Vector4 lhs, Vector4 rhs);
    public static Vector4 op_Implicit(Vector3 v);
    public static Vector3 op_Implicit(Vector4 v);
    public static Vector4 op_Implicit(Vector2 v);
    public static Vector2 op_Implicit(Vector4 v);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static float SqrMagnitude(Vector4 a);
    public float SqrMagnitude();
}
public enum UnityEngine.VRTextureUsage : Enum {
    public int value__;
    public static VRTextureUsage None;
    public static VRTextureUsage OneEye;
    public static VRTextureUsage TwoEyes;
    public static VRTextureUsage DeviceSpecific;
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.WaitForEndOfFrame : YieldInstruction {
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.WaitForFixedUpdate : YieldInstruction {
}
[RequiredByNativeCodeAttribute]
public class UnityEngine.WaitForSeconds : YieldInstruction {
    internal float m_Seconds;
    public WaitForSeconds(float seconds);
}
public class UnityEngine.WaitForSecondsRealtime : CustomYieldInstruction {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private float <waitTime>k__BackingField;
    private float m_WaitUntilTime;
    public float waitTime { get; public set; }
    public bool keepWaiting { get; }
    public WaitForSecondsRealtime(float time);
    [CompilerGeneratedAttribute]
public float get_waitTime();
    [CompilerGeneratedAttribute]
public void set_waitTime(float value);
    public virtual bool get_keepWaiting();
    public virtual void Reset();
}
public class UnityEngine.WaitUntil : CustomYieldInstruction {
    private Func`1<bool> m_Predicate;
    public bool keepWaiting { get; }
    public WaitUntil(Func`1<bool> predicate);
    public virtual bool get_keepWaiting();
}
public class UnityEngine.WaitWhile : CustomYieldInstruction {
    private Func`1<bool> m_Predicate;
    public bool keepWaiting { get; }
    public WaitWhile(Func`1<bool> predicate);
    public virtual bool get_keepWaiting();
}
public enum UnityEngine.WeightedMode : Enum {
    public int value__;
    public static WeightedMode None;
    public static WeightedMode In;
    public static WeightedMode Out;
    public static WeightedMode Both;
}
[NativeHeaderAttribute("Runtime/Graphics/ColorGamut.h")]
[UsedByNativeCodeAttribute]
public enum UnityEngine.WhitePoint : Enum {
    public int value__;
    public static WhitePoint Unknown;
    public static WhitePoint D65;
}
public static class UnityEngine.Windows.CrashReporting : object {
    public static string crashReportFolder { get; }
    [ThreadSafeAttribute]
[NativeHeaderAttribute("PlatformDependent/WinPlayer/Bindings/CrashReportingBindings.h")]
public static string get_crashReportFolder();
}
[NativeHeaderAttribute("PlatformDependent/Win/Bindings/InputBindings.h")]
public static class UnityEngine.Windows.Input : object {
    [NativeNameAttribute("ForwardRawInput")]
[StaticAccessorAttribute("", "2")]
[ThreadSafeAttribute]
private static void ForwardRawInputImpl(UInt32* rawInputHeaderIndices, UInt32* rawInputDataIndices, UInt32 indicesCount, Byte* rawInputData, UInt32 rawInputDataSize);
    public static void ForwardRawInput(IntPtr rawInputHeaderIndices, IntPtr rawInputDataIndices, UInt32 indicesCount, IntPtr rawInputData, UInt32 rawInputDataSize);
    public static void ForwardRawInput(UInt32* rawInputHeaderIndices, UInt32* rawInputDataIndices, UInt32 indicesCount, Byte* rawInputData, UInt32 rawInputDataSize);
}
public enum UnityEngine.Windows.Speech.ConfidenceLevel : Enum {
    public int value__;
    public static ConfidenceLevel High;
    public static ConfidenceLevel Medium;
    public static ConfidenceLevel Low;
    public static ConfidenceLevel Rejected;
}
public enum UnityEngine.Windows.Speech.DictationCompletionCause : Enum {
    public int value__;
    public static DictationCompletionCause Complete;
    public static DictationCompletionCause AudioQualityFailure;
    public static DictationCompletionCause Canceled;
    public static DictationCompletionCause TimeoutExceeded;
    public static DictationCompletionCause PauseLimitExceeded;
    public static DictationCompletionCause NetworkFailure;
    public static DictationCompletionCause MicrophoneUnavailable;
    public static DictationCompletionCause UnknownError;
}
public class UnityEngine.Windows.Speech.DictationRecognizer : object {
    private IntPtr m_Recognizer;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DictationHypothesisDelegate DictationHypothesis;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private DictationResultDelegate DictationResult;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private DictationCompletedDelegate DictationComplete;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private DictationErrorHandler DictationError;
    public SpeechSystemStatus Status { get; }
    public float AutoSilenceTimeoutSeconds { get; public set; }
    public float InitialSilenceTimeoutSeconds { get; public set; }
    public DictationRecognizer(ConfidenceLevel confidenceLevel);
    public DictationRecognizer(DictationTopicConstraint topic);
    public DictationRecognizer(ConfidenceLevel minimumConfidence, DictationTopicConstraint topic);
    [NativeThrowsAttribute]
[NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static IntPtr Create(object self, ConfidenceLevel minimumConfidence, DictationTopicConstraint topicConstraint);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
[NativeThrowsAttribute]
private static void Start(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void Stop(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void Destroy(IntPtr self);
    [ThreadSafeAttribute]
[NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void DestroyThreaded(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static SpeechSystemStatus GetStatus(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static float GetAutoSilenceTimeoutSeconds(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void SetAutoSilenceTimeoutSeconds(IntPtr self, float value);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static float GetInitialSilenceTimeoutSeconds(IntPtr self);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void SetInitialSilenceTimeoutSeconds(IntPtr self, float value);
    [CompilerGeneratedAttribute]
public void add_DictationHypothesis(DictationHypothesisDelegate value);
    [CompilerGeneratedAttribute]
public void remove_DictationHypothesis(DictationHypothesisDelegate value);
    [CompilerGeneratedAttribute]
public void add_DictationResult(DictationResultDelegate value);
    [CompilerGeneratedAttribute]
public void remove_DictationResult(DictationResultDelegate value);
    [CompilerGeneratedAttribute]
public void add_DictationComplete(DictationCompletedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_DictationComplete(DictationCompletedDelegate value);
    [CompilerGeneratedAttribute]
public void add_DictationError(DictationErrorHandler value);
    [CompilerGeneratedAttribute]
public void remove_DictationError(DictationErrorHandler value);
    public SpeechSystemStatus get_Status();
    public float get_AutoSilenceTimeoutSeconds();
    public void set_AutoSilenceTimeoutSeconds(float value);
    public float get_InitialSilenceTimeoutSeconds();
    public void set_InitialSilenceTimeoutSeconds(float value);
    protected virtual override void Finalize();
    public void Start();
    public void Stop();
    public sealed virtual void Dispose();
    [RequiredByNativeCodeAttribute]
private void DictationRecognizer_InvokeHypothesisGeneratedEvent(string keyword);
    [RequiredByNativeCodeAttribute]
private void DictationRecognizer_InvokeResultGeneratedEvent(string keyword, ConfidenceLevel minimumConfidence);
    [RequiredByNativeCodeAttribute]
private void DictationRecognizer_InvokeCompletedEvent(DictationCompletionCause cause);
    [RequiredByNativeCodeAttribute]
private void DictationRecognizer_InvokeErrorEvent(string error, int hresult);
}
public enum UnityEngine.Windows.Speech.DictationTopicConstraint : Enum {
    public int value__;
    public static DictationTopicConstraint WebSearch;
    public static DictationTopicConstraint Form;
    public static DictationTopicConstraint Dictation;
}
public class UnityEngine.Windows.Speech.GrammarRecognizer : PhraseRecognizer {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <GrammarFilePath>k__BackingField;
    public string GrammarFilePath { get; private set; }
    public GrammarRecognizer(string grammarFilePath);
    public GrammarRecognizer(string grammarFilePath, ConfidenceLevel minimumConfidence);
    [CompilerGeneratedAttribute]
public string get_GrammarFilePath();
    [CompilerGeneratedAttribute]
private void set_GrammarFilePath(string value);
}
public class UnityEngine.Windows.Speech.KeywordRecognizer : PhraseRecognizer {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IEnumerable`1<string> <Keywords>k__BackingField;
    public IEnumerable`1<string> Keywords { get; private set; }
    public KeywordRecognizer(String[] keywords);
    public KeywordRecognizer(String[] keywords, ConfidenceLevel minimumConfidence);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Keywords();
    [CompilerGeneratedAttribute]
private void set_Keywords(IEnumerable`1<string> value);
}
public static class UnityEngine.Windows.Speech.PhraseRecognitionSystem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static ErrorDelegate OnError;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static StatusDelegate OnStatusChanged;
    public static bool isSupported { get; }
    public static SpeechSystemStatus Status { get; }
    [ThreadSafeAttribute]
[NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
public static bool get_isSupported();
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
public static SpeechSystemStatus get_Status();
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
[NativeThrowsAttribute]
public static void Restart();
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
public static void Shutdown();
    [CompilerGeneratedAttribute]
public static void add_OnError(ErrorDelegate value);
    [CompilerGeneratedAttribute]
public static void remove_OnError(ErrorDelegate value);
    [CompilerGeneratedAttribute]
public static void add_OnStatusChanged(StatusDelegate value);
    [CompilerGeneratedAttribute]
public static void remove_OnStatusChanged(StatusDelegate value);
    [RequiredByNativeCodeAttribute]
private static void PhraseRecognitionSystem_InvokeErrorEvent(SpeechError errorCode);
    [RequiredByNativeCodeAttribute]
private static void PhraseRecognitionSystem_InvokeStatusChangedEvent(SpeechSystemStatus status);
}
public class UnityEngine.Windows.Speech.PhraseRecognizedEventArgs : ValueType {
    public ConfidenceLevel confidence;
    public SemanticMeaning[] semanticMeanings;
    public string text;
    public DateTime phraseStartTime;
    public TimeSpan phraseDuration;
    internal PhraseRecognizedEventArgs(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, DateTime phraseStartTime, TimeSpan phraseDuration);
}
public abstract class UnityEngine.Windows.Speech.PhraseRecognizer : object {
    protected IntPtr m_Recognizer;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private PhraseRecognizedDelegate OnPhraseRecognized;
    public bool IsRunning { get; }
    [NativeThrowsAttribute]
[NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
protected static IntPtr CreateFromKeywords(object self, String[] keywords, ConfidenceLevel minimumConfidence);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
[NativeThrowsAttribute]
protected static IntPtr CreateFromGrammarFile(object self, string grammarFilePath, ConfidenceLevel minimumConfidence);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
[NativeThrowsAttribute]
private static void Start_Internal(IntPtr recognizer);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void Stop_Internal(IntPtr recognizer);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static bool IsRunning_Internal(IntPtr recognizer);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
private static void Destroy(IntPtr recognizer);
    [NativeHeaderAttribute("PlatformDependent/Win/Bindings/SpeechBindings.h")]
[ThreadSafeAttribute]
private static void DestroyThreaded(IntPtr recognizer);
    [CompilerGeneratedAttribute]
public void add_OnPhraseRecognized(PhraseRecognizedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_OnPhraseRecognized(PhraseRecognizedDelegate value);
    protected virtual override void Finalize();
    public void Start();
    public void Stop();
    public sealed virtual void Dispose();
    public bool get_IsRunning();
    [RequiredByNativeCodeAttribute]
private void InvokePhraseRecognizedEvent(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, long phraseStartFileTime, long phraseDurationTicks);
    [RequiredByNativeCodeAttribute]
private static SemanticMeaning[] MarshalSemanticMeaning(IntPtr keys, IntPtr values, IntPtr valueSizes, int valueCount);
}
public class UnityEngine.Windows.Speech.SemanticMeaning : ValueType {
    public string key;
    public String[] values;
}
public enum UnityEngine.Windows.Speech.SpeechError : Enum {
    public int value__;
    public static SpeechError NoError;
    public static SpeechError TopicLanguageNotSupported;
    public static SpeechError GrammarLanguageMismatch;
    public static SpeechError GrammarCompilationFailure;
    public static SpeechError AudioQualityFailure;
    public static SpeechError PauseLimitExceeded;
    public static SpeechError TimeoutExceeded;
    public static SpeechError NetworkFailure;
    public static SpeechError MicrophoneUnavailable;
    public static SpeechError UnknownError;
}
public enum UnityEngine.Windows.Speech.SpeechSystemStatus : Enum {
    public int value__;
    public static SpeechSystemStatus Stopped;
    public static SpeechSystemStatus Running;
    public static SpeechSystemStatus Failed;
}
[NativeHeaderAttribute("PlatformDependent/Win/Webcam/CameraParameters.h")]
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
[UsedByNativeCodeAttribute]
public class UnityEngine.Windows.WebCam.CameraParameters : ValueType {
    private float m_HologramOpacity;
    private float m_FrameRate;
    private int m_CameraResolutionWidth;
    private int m_CameraResolutionHeight;
    private CapturePixelFormat m_PixelFormat;
    public float hologramOpacity { get; public set; }
    public float frameRate { get; public set; }
    public int cameraResolutionWidth { get; public set; }
    public int cameraResolutionHeight { get; public set; }
    public CapturePixelFormat pixelFormat { get; public set; }
    public CameraParameters(WebCamMode webCamMode);
    public float get_hologramOpacity();
    public void set_hologramOpacity(float value);
    public float get_frameRate();
    public void set_frameRate(float value);
    public int get_cameraResolutionWidth();
    public void set_cameraResolutionWidth(int value);
    public int get_cameraResolutionHeight();
    public void set_cameraResolutionHeight(int value);
    public CapturePixelFormat get_pixelFormat();
    public void set_pixelFormat(CapturePixelFormat value);
}
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
public enum UnityEngine.Windows.WebCam.CapturePixelFormat : Enum {
    public int value__;
    public static CapturePixelFormat BGRA32;
    public static CapturePixelFormat NV12;
    public static CapturePixelFormat JPEG;
    public static CapturePixelFormat PNG;
}
[NativeHeaderAttribute("PlatformDependent/Win/Webcam/PhotoCapture.h")]
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
[StaticAccessorAttribute("PhotoCapture", "2")]
public class UnityEngine.Windows.WebCam.PhotoCapture : object {
    internal IntPtr m_NativePtr;
    private static Resolution[] s_SupportedResolutions;
    private static long HR_SUCCESS;
    public static IEnumerable`1<Resolution> SupportedResolutions { get; }
    private PhotoCapture(IntPtr nativeCaptureObject);
    private static PhotoCaptureResult MakeCaptureResult(CaptureResultType resultType, long hResult);
    private static PhotoCaptureResult MakeCaptureResult(long hResult);
    public static IEnumerable`1<Resolution> get_SupportedResolutions();
    [NativeNameAttribute("GetSupportedResolutions")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private static Resolution[] GetSupportedResolutions_Internal();
    public static void CreateAsync(bool showHolograms, OnCaptureResourceCreatedCallback onCreatedCallback);
    public static void CreateAsync(OnCaptureResourceCreatedCallback onCreatedCallback);
    [NativeNameAttribute("Instantiate")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private static IntPtr Instantiate_Internal(bool showHolograms, OnCaptureResourceCreatedCallback onCreatedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnCreatedResourceDelegate(OnCaptureResourceCreatedCallback callback, IntPtr nativePtr);
    public void StartPhotoModeAsync(CameraParameters setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback);
    [NativeNameAttribute("StartPhotoMode")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void StartPhotoMode_Internal(CameraParameters setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnPhotoModeStartedDelegate(OnPhotoModeStartedCallback callback, long hResult);
    [NativeNameAttribute("StopPhotoMode")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
public void StopPhotoModeAsync(OnPhotoModeStoppedCallback onPhotoModeStoppedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnPhotoModeStoppedDelegate(OnPhotoModeStoppedCallback callback, long hResult);
    public void TakePhotoAsync(string filename, PhotoCaptureFileOutputFormat fileOutputFormat, OnCapturedToDiskCallback onCapturedPhotoToDiskCallback);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("CapturePhotoToDisk")]
private void CapturePhotoToDisk_Internal(string filename, PhotoCaptureFileOutputFormat fileOutputFormat, OnCapturedToDiskCallback onCapturedPhotoToDiskCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnCapturedPhotoToDiskDelegate(OnCapturedToDiskCallback callback, long hResult);
    public void TakePhotoAsync(OnCapturedToMemoryCallback onCapturedPhotoToMemoryCallback);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("CapturePhotoToMemory")]
private void CapturePhotoToMemory_Internal(OnCapturedToMemoryCallback onCapturedPhotoToMemoryCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnCapturedPhotoToMemoryDelegate(OnCapturedToMemoryCallback callback, long hResult, IntPtr photoCaptureFramePtr);
    [ThreadAndSerializationSafeAttribute]
[NativeNameAttribute("GetUnsafePointerToVideoDeviceController")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
public IntPtr GetUnsafePointerToVideoDeviceController();
    public sealed virtual void Dispose();
    [NativeNameAttribute("Dispose")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void Dispose_Internal();
    protected virtual override void Finalize();
    [ThreadAndSerializationSafeAttribute]
[NativeNameAttribute("DisposeThreaded")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void DisposeThreaded_Internal();
    private void StartPhotoMode_Internal_Injected(CameraParameters& setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback);
}
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
public enum UnityEngine.Windows.WebCam.PhotoCaptureFileOutputFormat : Enum {
    public int value__;
    public static PhotoCaptureFileOutputFormat PNG;
    public static PhotoCaptureFileOutputFormat JPG;
}
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeHeaderAttribute("PlatformDependent/Win/Webcam/PhotoCaptureFrame.h")]
public class UnityEngine.Windows.WebCam.PhotoCaptureFrame : object {
    private IntPtr m_NativePtr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <dataLength>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <hasLocationData>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private CapturePixelFormat <pixelFormat>k__BackingField;
    public int dataLength { get; private set; }
    public bool hasLocationData { get; private set; }
    public CapturePixelFormat pixelFormat { get; private set; }
    internal PhotoCaptureFrame(IntPtr nativePtr);
    [CompilerGeneratedAttribute]
public int get_dataLength();
    [CompilerGeneratedAttribute]
private void set_dataLength(int value);
    [CompilerGeneratedAttribute]
public bool get_hasLocationData();
    [CompilerGeneratedAttribute]
private void set_hasLocationData(bool value);
    [CompilerGeneratedAttribute]
public CapturePixelFormat get_pixelFormat();
    [CompilerGeneratedAttribute]
private void set_pixelFormat(CapturePixelFormat value);
    [ThreadAndSerializationSafeAttribute]
private int GetDataLength();
    [ThreadAndSerializationSafeAttribute]
private bool GetHasLocationData();
    [ThreadAndSerializationSafeAttribute]
private CapturePixelFormat GetCapturePixelFormat();
    public bool TryGetCameraToWorldMatrix(Matrix4x4& cameraToWorldMatrix);
    [NativeConditionalAttribute("PLATFORM_WIN && !PLATFORM_XBOXONE", "Matrix4x4f()")]
[ThreadAndSerializationSafeAttribute]
[NativeNameAttribute("GetCameraToWorld")]
private Matrix4x4 GetCameraToWorldMatrix();
    public bool TryGetProjectionMatrix(Matrix4x4& projectionMatrix);
    public bool TryGetProjectionMatrix(float nearClipPlane, float farClipPlane, Matrix4x4& projectionMatrix);
    [ThreadAndSerializationSafeAttribute]
[NativeConditionalAttribute("PLATFORM_WIN && !PLATFORM_XBOXONE", "Matrix4x4f()")]
private Matrix4x4 GetProjection();
    public void UploadImageDataToTexture(Texture2D targetTexture);
    [ThreadAndSerializationSafeAttribute]
[NativeNameAttribute("UploadImageDataToTexture")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void UploadImageDataToTexture_Internal(Texture2D targetTexture);
    [ThreadAndSerializationSafeAttribute]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
public IntPtr GetUnsafePointerToBuffer();
    public void CopyRawImageDataIntoBuffer(List`1<byte> byteBuffer);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[ThreadAndSerializationSafeAttribute]
[NativeNameAttribute("CopyRawImageDataIntoBuffer")]
internal void CopyRawImageDataIntoBuffer_Internal(Byte[] byteArray);
    private void Cleanup();
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("Dispose")]
[ThreadAndSerializationSafeAttribute]
private void Dispose_Internal();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void GetCameraToWorldMatrix_Injected(Matrix4x4& ret);
    private void GetProjection_Injected(Matrix4x4& ret);
}
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
[NativeHeaderAttribute("PlatformDependent/Win/Webcam/VideoCaptureBindings.h")]
[StaticAccessorAttribute("VideoCaptureBindings", "2")]
public class UnityEngine.Windows.WebCam.VideoCapture : object {
    internal IntPtr m_NativePtr;
    private static Resolution[] s_SupportedResolutions;
    private static long HR_SUCCESS;
    public static IEnumerable`1<Resolution> SupportedResolutions { get; }
    public bool IsRecording { get; }
    private VideoCapture(IntPtr nativeCaptureObject);
    private static VideoCaptureResult MakeCaptureResult(CaptureResultType resultType, long hResult);
    private static VideoCaptureResult MakeCaptureResult(long hResult);
    public static IEnumerable`1<Resolution> get_SupportedResolutions();
    [NativeNameAttribute("GetSupportedResolutions")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private static Resolution[] GetSupportedResolutions_Internal();
    public static IEnumerable`1<float> GetSupportedFrameRatesForResolution(Resolution resolution);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("GetSupportedFrameRatesForResolution")]
private static Single[] GetSupportedFrameRatesForResolution_Internal(int resolutionWidth, int resolutionHeight);
    [NativeMethodAttribute("VideoCaptureBindings::IsRecording")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
public bool get_IsRecording();
    public static void CreateAsync(bool showHolograms, OnVideoCaptureResourceCreatedCallback onCreatedCallback);
    public static void CreateAsync(OnVideoCaptureResourceCreatedCallback onCreatedCallback);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("Instantiate")]
private static void Instantiate_Internal(bool showHolograms, OnVideoCaptureResourceCreatedCallback onCreatedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnCreatedVideoCaptureResourceDelegate(OnVideoCaptureResourceCreatedCallback callback, IntPtr nativePtr);
    public void StartVideoModeAsync(CameraParameters setupParams, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback);
    [NativeMethodAttribute("VideoCaptureBindings::StartVideoMode")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void StartVideoMode_Internal(CameraParameters cameraParameters, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnVideoModeStartedDelegate(OnVideoModeStartedCallback callback, long hResult);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeMethodAttribute("VideoCaptureBindings::StopVideoMode")]
public void StopVideoModeAsync(OnVideoModeStoppedCallback onVideoModeStoppedCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnVideoModeStoppedDelegate(OnVideoModeStoppedCallback callback, long hResult);
    public void StartRecordingAsync(string filename, OnStartedRecordingVideoCallback onStartedRecordingVideoCallback);
    [NativeMethodAttribute("VideoCaptureBindings::StartRecordingVideoToDisk")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
private void StartRecordingVideoToDisk_Internal(string filename, OnStartedRecordingVideoCallback onStartedRecordingVideoCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnStartedRecordingVideoToDiskDelegate(OnStartedRecordingVideoCallback callback, long hResult);
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeMethodAttribute("VideoCaptureBindings::StopRecordingVideoToDisk")]
public void StopRecordingAsync(OnStoppedRecordingVideoCallback onStoppedRecordingVideoCallback);
    [RequiredByNativeCodeAttribute]
private static void InvokeOnStoppedRecordingVideoToDiskDelegate(OnStoppedRecordingVideoCallback callback, long hResult);
    [ThreadAndSerializationSafeAttribute]
[NativeMethodAttribute("VideoCaptureBindings::GetUnsafePointerToVideoDeviceController")]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
public IntPtr GetUnsafePointerToVideoDeviceController();
    public sealed virtual void Dispose();
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeMethodAttribute("VideoCaptureBindings::Dispose")]
private void Dispose_Internal();
    protected virtual override void Finalize();
    [ThreadAndSerializationSafeAttribute]
[NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeMethodAttribute("VideoCaptureBindings::DisposeThreaded")]
private void DisposeThreaded_Internal();
    private void StartVideoMode_Internal_Injected(CameraParameters& cameraParameters, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback);
}
[StaticAccessorAttribute("WebCam::GetInstance()", "0")]
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
[NativeHeaderAttribute("PlatformDependent/Win/Webcam/WebCam.h")]
public class UnityEngine.Windows.WebCam.WebCam : object {
    public static WebCamMode Mode { get; }
    [NativeConditionalAttribute("(PLATFORM_WIN || PLATFORM_WINRT) && !PLATFORM_XBOXONE")]
[NativeNameAttribute("GetWebCamMode")]
public static WebCamMode get_Mode();
}
[MovedFromAttribute("UnityEngine.XR.WSA.WebCam")]
public enum UnityEngine.Windows.WebCam.WebCamMode : Enum {
    public int value__;
    public static WebCamMode None;
    public static WebCamMode PhotoMode;
    public static WebCamMode VideoMode;
}
public enum UnityEngine.WrapMode : Enum {
    public int value__;
    public static WrapMode Once;
    public static WrapMode Loop;
    public static WrapMode PingPong;
    public static WrapMode Default;
    public static WrapMode ClampForever;
    public static WrapMode Clamp;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.YieldInstruction : object {
}
public class UnityEngineInternal.APIUpdaterRuntimeServices : object {
    [ObsoleteAttribute("Method is not meant to be used at runtime. Please, replace this call with GameObject.AddComponent<T>()/GameObject.AddComponent(Type).", "True")]
public static Component AddComponent(GameObject go, string sourceInfo, string name);
}
public class UnityEngineInternal.GenericStack : Stack {
}
[NativeHeaderAttribute("Runtime/Export/GI/GIDebugVisualisation.bindings.h")]
public static class UnityEngineInternal.GIDebugVisualisation : object {
    public static bool cycleMode { get; }
    public static bool pauseCycleMode { get; }
    public static GITextureType texType { get; public set; }
    [FreeFunctionAttribute]
public static void ResetRuntimeInputTextures();
    [FreeFunctionAttribute]
public static void PlayCycleMode();
    [FreeFunctionAttribute]
public static void PauseCycleMode();
    [FreeFunctionAttribute]
public static void StopCycleMode();
    [FreeFunctionAttribute]
public static void CycleSkipSystems(int skip);
    [FreeFunctionAttribute]
public static void CycleSkipInstances(int skip);
    [FreeFunctionAttribute]
public static bool get_cycleMode();
    [FreeFunctionAttribute]
public static bool get_pauseCycleMode();
    [FreeFunctionAttribute]
public static GITextureType get_texType();
    [FreeFunctionAttribute]
public static void set_texType(GITextureType value);
}
public enum UnityEngineInternal.GITextureType : Enum {
    public int value__;
    public static GITextureType Charting;
    public static GITextureType Albedo;
    public static GITextureType Emissive;
    public static GITextureType Irradiance;
    public static GITextureType Directionality;
    public static GITextureType Baked;
    public static GITextureType BakedDirectional;
    public static GITextureType InputWorkspace;
    public static GITextureType BakedShadowMask;
    public static GITextureType BakedAlbedo;
    public static GITextureType BakedEmissive;
    public static GITextureType BakedCharting;
    public static GITextureType BakedTexelValidity;
    public static GITextureType BakedUVOverlap;
    public static GITextureType BakedLightmapCulling;
}
[StaticAccessorAttribute("GraphicsDeviceDebug", "2")]
[NativeHeaderAttribute("Runtime/Export/Graphics/GraphicsDeviceDebug.bindings.h")]
internal static class UnityEngineInternal.GraphicsDeviceDebug : object {
    internal static GraphicsDeviceDebugSettings settings { get; internal set; }
    internal static GraphicsDeviceDebugSettings get_settings();
    internal static void set_settings(GraphicsDeviceDebugSettings value);
    private static void get_settings_Injected(GraphicsDeviceDebugSettings& ret);
    private static void set_settings_Injected(GraphicsDeviceDebugSettings& value);
}
internal class UnityEngineInternal.GraphicsDeviceDebugSettings : ValueType {
    public float sleepAtStartOfGraphicsJobs;
    public float sleepBeforeTextureUpload;
}
internal enum UnityEngineInternal.LightmapType : Enum {
    public int value__;
    public static LightmapType NoLightmap;
    public static LightmapType StaticLightmap;
    public static LightmapType DynamicLightmap;
}
[Il2CppEagerStaticClassConstructionAttribute]
public class UnityEngineInternal.MathfInternal : ValueType {
    public static Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinNormal;
    public static Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinDenormal;
    public static bool IsFlushToZeroEnabled;
    private static MathfInternal();
}
[NativeHeaderAttribute("Runtime/Misc/PlayerSettings.h")]
public class UnityEngineInternal.MemorylessManager : object {
    public static MemorylessMode depthMemorylessMode { get; public set; }
    public static MemorylessMode get_depthMemorylessMode();
    public static void set_depthMemorylessMode(MemorylessMode value);
    [NativeMethodAttribute]
[StaticAccessorAttribute("GetPlayerSettings()", "0")]
internal static MemorylessMode GetFramebufferDepthMemorylessMode();
    [StaticAccessorAttribute("GetPlayerSettings()", "0")]
[NativeMethodAttribute]
internal static void SetFramebufferDepthMemorylessMode(MemorylessMode mode);
}
public enum UnityEngineInternal.MemorylessMode : Enum {
    public int value__;
    public static MemorylessMode Unused;
    public static MemorylessMode Forced;
    public static MemorylessMode Automatic;
}
[AttributeUsageAttribute("64")]
public class UnityEngineInternal.TypeInferenceRuleAttribute : Attribute {
    private string _rule;
    public TypeInferenceRuleAttribute(TypeInferenceRules rule);
    public TypeInferenceRuleAttribute(string rule);
    public virtual string ToString();
}
public enum UnityEngineInternal.TypeInferenceRules : Enum {
    public int value__;
    public static TypeInferenceRules TypeReferencedByFirstArgument;
    public static TypeInferenceRules TypeReferencedBySecondArgument;
    public static TypeInferenceRules ArrayOfTypeReferencedByFirstArgument;
    public static TypeInferenceRules TypeOfFirstArgument;
}
