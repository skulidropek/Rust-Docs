public AOT.MonoPInvokeCallbackAttribute : Attribute {
public void .ctor(Type type)
}
public JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
private Type <BaseType>k__BackingField
public Type BaseType
public void .ctor(Type baseType)
public Type get_BaseType()
private void set_BaseType(Type value)
}
public JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
private string <Contract>k__BackingField
private bool <ForceFullStates>k__BackingField
public string Contract
public bool ForceFullStates
public void .ctor(string contract)
public void .ctor(string contract, bool forceFullStates)
public string get_Contract()
private void set_Contract(string value)
public bool get_ForceFullStates()
private void set_ForceFullStates(bool value)
}
public JetBrains.Annotations.ImplicitUseKindFlags : Enum {
public int value__
public ImplicitUseKindFlags Default
public ImplicitUseKindFlags Access
public ImplicitUseKindFlags Assign
public ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature
public ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature
}
public JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
public int value__
public ImplicitUseTargetFlags Default
public ImplicitUseTargetFlags Itself
public ImplicitUseTargetFlags Members
public ImplicitUseTargetFlags WithMembers
}
public JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
private bool <Required>k__BackingField
public bool Required
public void .ctor(bool required)
public bool get_Required()
private void set_Required(bool value)
}
public JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
private ImplicitUseKindFlags <UseKindFlags>k__BackingField
private ImplicitUseTargetFlags <TargetFlags>k__BackingField
public ImplicitUseKindFlags UseKindFlags
public ImplicitUseTargetFlags TargetFlags
public void .ctor(ImplicitUseKindFlags useKindFlags)
public void .ctor(ImplicitUseTargetFlags targetFlags)
public void .ctor(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags)
public ImplicitUseKindFlags get_UseKindFlags()
private void set_UseKindFlags(ImplicitUseKindFlags value)
public ImplicitUseTargetFlags get_TargetFlags()
private void set_TargetFlags(ImplicitUseTargetFlags value)
}
public JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
private void set_ParameterName(string value)
}
public JetBrains.Annotations.PathReferenceAttribute : Attribute {
private string <BasePath>k__BackingField
public string BasePath
public void .ctor(string basePath)
public string get_BasePath()
private void set_BasePath(string value)
}
public JetBrains.Annotations.PublicAPIAttribute : Attribute {
private string <Comment>k__BackingField
public string Comment
public void .ctor(string comment)
public string get_Comment()
private void set_Comment(string value)
}
public JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
private string <FormatParameterName>k__BackingField
public string FormatParameterName
public void .ctor(string formatParameterName)
public string get_FormatParameterName()
private void set_FormatParameterName(string value)
}
public JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
private ImplicitUseKindFlags <UseKindFlags>k__BackingField
private ImplicitUseTargetFlags <TargetFlags>k__BackingField
public ImplicitUseKindFlags UseKindFlags
public ImplicitUseTargetFlags TargetFlags
public void .ctor(ImplicitUseKindFlags useKindFlags)
public void .ctor(ImplicitUseTargetFlags targetFlags)
public void .ctor(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags)
public ImplicitUseKindFlags get_UseKindFlags()
private void set_UseKindFlags(ImplicitUseKindFlags value)
public ImplicitUseTargetFlags get_TargetFlags()
private void set_TargetFlags(ImplicitUseTargetFlags value)
}
public Unity.Collections.Allocator : Enum {
public int value__
public Allocator Invalid
public Allocator None
public Allocator Temp
public Allocator TempJob
public Allocator Persistent
}
public Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility : object {
public NativeArray`1<T> ConvertExistingDataToNativeArray(Void* dataPointer, int length, Allocator allocator)
public Void* GetUnsafePtr(NativeArray`1<T> nativeArray)
public Void* GetUnsafeReadOnlyPtr(NativeArray`1<T> nativeArray)
public Void* GetUnsafeBufferPointerWithoutChecks(NativeArray`1<T> nativeArray)
}
public Unity.Collections.LowLevel.Unsafe.NativeSliceUnsafeUtility : object {
public NativeSlice`1<T> ConvertExistingDataToNativeSlice(Void* dataPointer, int stride, int length)
public Void* GetUnsafePtr(NativeSlice`1<T> nativeSlice)
public Void* GetUnsafeReadOnlyPtr(NativeSlice`1<T> nativeSlice)
}
public Unity.Collections.LowLevel.Unsafe.UnsafeUtility : object {
private int GetFieldOffsetInStruct(FieldInfo field)
private int GetFieldOffsetInClass(FieldInfo field)
public int GetFieldOffset(FieldInfo field)
public Void* PinGCObjectAndGetAddress(object target, UInt64& gcHandle)
public void ReleaseGCObject(ulong gcHandle)
public void CopyObjectAddressToPtr(object target, Void* dstPtr)
public bool IsBlittable()
public Void* Malloc(long size, int alignment, Allocator allocator)
public void Free(Void* memory, Allocator allocator)
public bool IsValidAllocator(Allocator allocator)
public void MemCpy(Void* destination, Void* source, long size)
public void MemCpyReplicate(Void* destination, Void* source, int size, int count)
public void MemCpyStride(Void* destination, int destinationStride, Void* source, int sourceStride, int elementSize, int count)
public void MemMove(Void* destination, Void* source, long size)
public void MemClear(Void* destination, long size)
public int SizeOf(Type type)
public bool IsBlittable(Type type)
internal void LogError(string msg, string filename, int linenumber)
public void CopyPtrToStructure(Void* ptr, T& output)
public void CopyStructureToPtr(T& input, Void* ptr)
public T ReadArrayElement(Void* source, int index)
public T ReadArrayElementWithStride(Void* source, int index, int stride)
public void WriteArrayElement(Void* destination, int index, T value)
public void WriteArrayElementWithStride(Void* destination, int index, int stride, T value)
public Void* AddressOf(T& output)
public int SizeOf()
public int AlignOf()
}
public Unity.Collections.NativeArray`1 : ValueType {
internal Void* m_Buffer
internal int m_Length
internal Allocator m_AllocatorLabel
public int Length
public T Item
public bool IsCreated
public void .ctor(int length, Allocator allocator, NativeArrayOptions options)
public void .ctor(T[] array, Allocator allocator)
public void .ctor(NativeArray`1<T> array, Allocator allocator)
private void Allocate(int length, Allocator allocator, NativeArray`1& array)
public int get_Length()
internal void IsBlittableAndThrow()
private void CheckElementReadAccess(int index)
private void CheckElementWriteAccess(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public bool get_IsCreated()
public void Dispose()
public void CopyFrom(T[] array)
public void CopyFrom(NativeArray`1<T> array)
public void CopyTo(T[] array)
public void CopyTo(NativeArray`1<T> array)
public T[] ToArray()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal Unity.Collections.NativeArrayDebugView`1 : object {
private NativeArray`1<T> m_Array
public T[] Items
public void .ctor(NativeArray`1<T> array)
public T[] get_Items()
}
public Unity.Collections.NativeArrayOptions : Enum {
public int value__
public NativeArrayOptions UninitializedMemory
public NativeArrayOptions ClearMemory
}
public Unity.Collections.NativeFixedLengthAttribute : Attribute {
public int FixedLength
public void .ctor(int fixedLength)
}
public Unity.Collections.NativeLeakDetection : object {
private int s_NativeLeakDetectionMode
public NativeLeakDetectionMode Mode
public NativeLeakDetectionMode get_Mode()
public void set_Mode(NativeLeakDetectionMode value)
}
public Unity.Collections.NativeLeakDetectionMode : Enum {
public int value__
public NativeLeakDetectionMode Enabled
public NativeLeakDetectionMode Disabled
}
public Unity.Collections.NativeSlice`1 : ValueType {
internal Byte* m_Buffer
internal int m_Stride
internal int m_Length
public T Item
public int Stride
public int Length
public void .ctor(NativeSlice`1<T> slice, int start)
public void .ctor(NativeSlice`1<T> slice, int start, int length)
public void .ctor(NativeArray`1<T> array)
public void .ctor(NativeArray`1<T> array, int start)
public void .ctor(NativeArray`1<T> array, int start, int length)
public NativeSlice`1<T> op_Implicit(NativeArray`1<T> array)
public NativeSlice`1<U> SliceConvert()
public NativeSlice`1<U> SliceWithStride(int offset)
public NativeSlice`1<U> SliceWithStride()
private void CheckReadIndex(int index)
private void CheckWriteIndex(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public void CopyFrom(NativeSlice`1<T> slice)
public void CopyFrom(T[] array)
public void CopyTo(NativeArray`1<T> array)
public void CopyTo(T[] array)
public T[] ToArray()
public int get_Stride()
public int get_Length()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal Unity.Collections.NativeSliceDebugView`1 : object {
private NativeSlice`1<T> m_Array
public T[] Items
public void .ctor(NativeSlice`1<T> array)
public T[] get_Items()
}
public Unity.Collections.NativeSliceExtensions : object {
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray)
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start)
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start, int length)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start, int length)
}
public Unity.Jobs.IJob {
public void Execute()
}
public Unity.Jobs.IJobExtensions : object {
public JobHandle Schedule(T jobData, JobHandle dependsOn)
public void Run(T jobData)
}
public Unity.Jobs.IJobParallelFor {
public void Execute(int index)
}
public Unity.Jobs.IJobParallelForExtensions : object {
public JobHandle Schedule(T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependsOn)
public void Run(T jobData, int arrayLength)
}
public Unity.Jobs.JobHandle : ValueType {
internal IntPtr jobGroup
internal int version
public bool IsCompleted
public void Complete()
public void CompleteAll(JobHandle& job0, JobHandle& job1)
public void CompleteAll(JobHandle& job0, JobHandle& job1, JobHandle& job2)
public void CompleteAll(NativeArray`1<JobHandle> jobs)
public bool get_IsCompleted()
public void ScheduleBatchedJobs()
private void ScheduleBatchedJobsAndComplete(JobHandle& job)
private bool ScheduleBatchedJobsAndIsCompleted(JobHandle& job)
private void ScheduleBatchedJobsAndCompleteAll(Void* jobs, int count)
public JobHandle CombineDependencies(JobHandle job0, JobHandle job1)
public JobHandle CombineDependencies(JobHandle job0, JobHandle job1, JobHandle job2)
public JobHandle CombineDependencies(NativeArray`1<JobHandle> jobs)
private JobHandle CombineDependenciesInternal2(JobHandle& job0, JobHandle& job1)
private JobHandle CombineDependenciesInternal3(JobHandle& job0, JobHandle& job1, JobHandle& job2)
internal JobHandle CombineDependenciesInternalPtr(Void* jobs, int count)
public bool CheckFenceIsDependencyOrDidSyncFence(JobHandle jobHandle, JobHandle dependsOn)
private void CombineDependenciesInternal2_Injected(JobHandle& job0, JobHandle& job1, JobHandle& ret)
private void CombineDependenciesInternal3_Injected(JobHandle& job0, JobHandle& job1, JobHandle& job2, JobHandle& ret)
private void CombineDependenciesInternalPtr_Injected(Void* jobs, int count, JobHandle& ret)
private bool CheckFenceIsDependencyOrDidSyncFence_Injected(JobHandle& jobHandle, JobHandle& dependsOn)
}
public Unity.Jobs.LowLevel.Unsafe.BatchQueryJob`2 : ValueType {
internal NativeArray`1<CommandT> commands
internal NativeArray`1<ResultT> results
public void .ctor(NativeArray`1<CommandT> commands, NativeArray`1<ResultT> results)
}
public Unity.Jobs.LowLevel.Unsafe.BatchQueryJobStruct`1 : ValueType {
internal IntPtr jobReflectionData
public IntPtr Initialize()
}
public Unity.Jobs.LowLevel.Unsafe.JobHandleUnsafeUtility : object {
public JobHandle CombineDependencies(JobHandle* jobs, int count)
}
public Unity.Jobs.LowLevel.Unsafe.JobProducerTypeAttribute : Attribute {
private Type <ProducerType>k__BackingField
public Type ProducerType
public void .ctor(Type producerType)
public Type get_ProducerType()
}
public Unity.Jobs.LowLevel.Unsafe.JobRanges : ValueType {
public int BatchSize
public int NumJobs
public int TotalIterationCount
public int NumPhases
public int IndicesPerPhase
public IntPtr StartEndIndex
public IntPtr PhaseData
}
public Unity.Jobs.LowLevel.Unsafe.JobsUtility : object {
public int MaxJobThreadCount
public int CacheLineSize
public bool JobDebuggerEnabled
public bool JobCompilerEnabled
public void GetJobRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex)
public bool GetWorkStealingRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex)
public JobHandle Schedule(JobScheduleParameters& parameters)
public JobHandle ScheduleParallelFor(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount)
public JobHandle ScheduleParallelForDeferArraySize(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle)
public JobHandle ScheduleParallelForTransform(JobScheduleParameters& parameters, IntPtr transfromAccesssArray)
public void PatchBufferMinMaxRanges(IntPtr bufferRangePatchData, Void* jobdata, int startIndex, int rangeSize)
private IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, JobType jobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2)
public IntPtr CreateJobReflectionData(Type type, JobType jobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2)
public IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, JobType jobType, object managedJobFunction0)
public bool get_JobDebuggerEnabled()
public void set_JobDebuggerEnabled(bool value)
public bool get_JobCompilerEnabled()
public void set_JobCompilerEnabled(bool value)
private void Schedule_Injected(JobScheduleParameters& parameters, JobHandle& ret)
private void ScheduleParallelFor_Injected(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount, JobHandle& ret)
private void ScheduleParallelForDeferArraySize_Injected(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle, JobHandle& ret)
private void ScheduleParallelForTransform_Injected(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, JobHandle& ret)
}
public Unity.Jobs.LowLevel.Unsafe.JobType : Enum {
public int value__
public JobType Single
public JobType ParallelFor
}
public Unity.Jobs.LowLevel.Unsafe.ScheduleMode : Enum {
public int value__
public ScheduleMode Run
public ScheduleMode Batched
}
public UnityEditor.Experimental.RenderSettings : object {
public bool useRadianceAmbientProbe
public bool get_useRadianceAmbientProbe()
public void set_useRadianceAmbientProbe(bool value)
}
internal UnityEngine._AndroidJNIHelper : object {
public IntPtr CreateJavaProxy(int delegateHandle, AndroidJavaProxy proxy)
public IntPtr CreateJavaRunnable(AndroidJavaRunnable jrunnable)
public IntPtr InvokeJavaProxyMethod(AndroidJavaProxy proxy, IntPtr jmethodName, IntPtr jargs)
public jvalue[] CreateJNIArgArray(Object[] args)
public object UnboxArray(AndroidJavaObject obj)
public object Unbox(AndroidJavaObject obj)
public AndroidJavaObject Box(object obj)
public void DeleteJNIArgArray(Object[] args, jvalue[] jniArgs)
public IntPtr ConvertToJNIArray(Array array)
public ArrayType ConvertFromJNIArray(IntPtr array)
public IntPtr GetConstructorID(IntPtr jclass, Object[] args)
public IntPtr GetMethodID(IntPtr jclass, string methodName, Object[] args, bool isStatic)
public IntPtr GetMethodID(IntPtr jclass, string methodName, Object[] args, bool isStatic)
public IntPtr GetFieldID(IntPtr jclass, string fieldName, bool isStatic)
public IntPtr GetConstructorID(IntPtr jclass, string signature)
public IntPtr GetMethodID(IntPtr jclass, string methodName, string signature, bool isStatic)
private IntPtr GetMethodIDFallback(IntPtr jclass, string methodName, string signature, bool isStatic)
public IntPtr GetFieldID(IntPtr jclass, string fieldName, string signature, bool isStatic)
public string GetSignature(object obj)
public string GetSignature(Object[] args)
public string GetSignature(Object[] args)
}
public UnityEngine.AccelerationEvent : ValueType {
private float x
private float y
private float z
private float m_TimeDelta
public Vector3 acceleration
public float deltaTime
public Vector3 get_acceleration()
public float get_deltaTime()
}
public UnityEngine.AddComponentMenu : Attribute {
private string m_AddComponentMenu
private int m_Ordering
public string componentMenu
public int componentOrder
public void .ctor(string menuName)
public void .ctor(string menuName, int order)
public string get_componentMenu()
public int get_componentOrder()
}
public UnityEngine.AndroidJavaClass : AndroidJavaObject {
public void .ctor(string className)
internal void .ctor(IntPtr jclass)
private void _AndroidJavaClass(string className)
}
public UnityEngine.AndroidJavaException : Exception {
private string mJavaStackTrace
public string StackTrace
internal void .ctor(string message, string javaStackTrace)
public string get_StackTrace()
}
public UnityEngine.AndroidJavaObject : object {
private bool enableDebugPrints
internal GlobalJavaObjectRef m_jobject
internal GlobalJavaObjectRef m_jclass
private AndroidJavaClass s_JavaLangClass
protected AndroidJavaClass JavaLangClass
public void .ctor(string className, Object[] args)
internal void .ctor(IntPtr jobject)
public void Dispose()
public void Call(string methodName, Object[] args)
public void CallStatic(string methodName, Object[] args)
public FieldType Get(string fieldName)
public void Set(string fieldName, FieldType val)
public FieldType GetStatic(string fieldName)
public void SetStatic(string fieldName, FieldType val)
public IntPtr GetRawObject()
public IntPtr GetRawClass()
public ReturnType Call(string methodName, Object[] args)
public ReturnType CallStatic(string methodName, Object[] args)
protected void DebugPrint(string msg)
protected void DebugPrint(string call, string methodName, string signature, Object[] args)
private void _AndroidJavaObject(string className, Object[] args)
protected void Finalize()
protected void Dispose(bool disposing)
protected void _Dispose()
protected void _Call(string methodName, Object[] args)
protected ReturnType _Call(string methodName, Object[] args)
protected FieldType _Get(string fieldName)
protected void _Set(string fieldName, FieldType val)
protected void _CallStatic(string methodName, Object[] args)
protected ReturnType _CallStatic(string methodName, Object[] args)
protected FieldType _GetStatic(string fieldName)
protected void _SetStatic(string fieldName, FieldType val)
internal AndroidJavaObject AndroidJavaObjectDeleteLocalRef(IntPtr jobject)
internal AndroidJavaClass AndroidJavaClassDeleteLocalRef(IntPtr jclass)
protected IntPtr _GetRawObject()
protected IntPtr _GetRawClass()
protected AndroidJavaObject FindClass(string name)
protected AndroidJavaClass get_JavaLangClass()
}
public UnityEngine.AndroidJavaProxy : object {
public AndroidJavaClass javaInterface
internal AndroidJavaObject proxyObject
private GlobalJavaObjectRef s_JavaLangSystemClass
private IntPtr s_HashCodeMethodID
public void .ctor(string javaInterface)
public void .ctor(AndroidJavaClass javaInterface)
public AndroidJavaObject Invoke(string methodName, Object[] args)
public AndroidJavaObject Invoke(string methodName, AndroidJavaObject[] javaArgs)
public bool equals(AndroidJavaObject obj)
public int hashCode()
public string toString()
internal AndroidJavaObject GetProxy()
}
public UnityEngine.AndroidJavaRunnable : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal UnityEngine.AndroidJavaRunnableProxy : AndroidJavaProxy {
private AndroidJavaRunnable mRunnable
public void .ctor(AndroidJavaRunnable runnable)
public void run()
}
public UnityEngine.AndroidJNI : object {
public int AttachCurrentThread()
public int DetachCurrentThread()
public int GetVersion()
public IntPtr FindClass(string name)
private void INTERNAL_CALL_FindClass(string name, IntPtr& value)
public IntPtr FromReflectedMethod(IntPtr refMethod)
private void INTERNAL_CALL_FromReflectedMethod(IntPtr refMethod, IntPtr& value)
public IntPtr FromReflectedField(IntPtr refField)
private void INTERNAL_CALL_FromReflectedField(IntPtr refField, IntPtr& value)
public IntPtr ToReflectedMethod(IntPtr clazz, IntPtr methodID, bool isStatic)
private void INTERNAL_CALL_ToReflectedMethod(IntPtr clazz, IntPtr methodID, bool isStatic, IntPtr& value)
public IntPtr ToReflectedField(IntPtr clazz, IntPtr fieldID, bool isStatic)
private void INTERNAL_CALL_ToReflectedField(IntPtr clazz, IntPtr fieldID, bool isStatic, IntPtr& value)
public IntPtr GetSuperclass(IntPtr clazz)
private void INTERNAL_CALL_GetSuperclass(IntPtr clazz, IntPtr& value)
public bool IsAssignableFrom(IntPtr clazz1, IntPtr clazz2)
public int Throw(IntPtr obj)
public int ThrowNew(IntPtr clazz, string message)
public IntPtr ExceptionOccurred()
private void INTERNAL_CALL_ExceptionOccurred(IntPtr& value)
public void ExceptionDescribe()
public void ExceptionClear()
public void FatalError(string message)
public int PushLocalFrame(int capacity)
public IntPtr PopLocalFrame(IntPtr ptr)
private void INTERNAL_CALL_PopLocalFrame(IntPtr ptr, IntPtr& value)
public IntPtr NewGlobalRef(IntPtr obj)
private void INTERNAL_CALL_NewGlobalRef(IntPtr obj, IntPtr& value)
public void DeleteGlobalRef(IntPtr obj)
public IntPtr NewLocalRef(IntPtr obj)
private void INTERNAL_CALL_NewLocalRef(IntPtr obj, IntPtr& value)
public void DeleteLocalRef(IntPtr obj)
public bool IsSameObject(IntPtr obj1, IntPtr obj2)
public int EnsureLocalCapacity(int capacity)
public IntPtr AllocObject(IntPtr clazz)
private void INTERNAL_CALL_AllocObject(IntPtr clazz, IntPtr& value)
public IntPtr NewObject(IntPtr clazz, IntPtr methodID, jvalue[] args)
private void INTERNAL_CALL_NewObject(IntPtr clazz, IntPtr methodID, jvalue[] args, IntPtr& value)
public IntPtr GetObjectClass(IntPtr obj)
private void INTERNAL_CALL_GetObjectClass(IntPtr obj, IntPtr& value)
public bool IsInstanceOf(IntPtr obj, IntPtr clazz)
public IntPtr GetMethodID(IntPtr clazz, string name, string sig)
private void INTERNAL_CALL_GetMethodID(IntPtr clazz, string name, string sig, IntPtr& value)
public IntPtr GetFieldID(IntPtr clazz, string name, string sig)
private void INTERNAL_CALL_GetFieldID(IntPtr clazz, string name, string sig, IntPtr& value)
public IntPtr GetStaticMethodID(IntPtr clazz, string name, string sig)
private void INTERNAL_CALL_GetStaticMethodID(IntPtr clazz, string name, string sig, IntPtr& value)
public IntPtr GetStaticFieldID(IntPtr clazz, string name, string sig)
private void INTERNAL_CALL_GetStaticFieldID(IntPtr clazz, string name, string sig, IntPtr& value)
public IntPtr NewStringUTF(string bytes)
private void INTERNAL_CALL_NewStringUTF(string bytes, IntPtr& value)
public int GetStringUTFLength(IntPtr str)
public string GetStringUTFChars(IntPtr str)
public string CallStringMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public IntPtr CallObjectMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
private void INTERNAL_CALL_CallObjectMethod(IntPtr obj, IntPtr methodID, jvalue[] args, IntPtr& value)
public int CallIntMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public bool CallBooleanMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public short CallShortMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public byte CallByteMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public char CallCharMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public float CallFloatMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public double CallDoubleMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public long CallLongMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public void CallVoidMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public string GetStringField(IntPtr obj, IntPtr fieldID)
public IntPtr GetObjectField(IntPtr obj, IntPtr fieldID)
private void INTERNAL_CALL_GetObjectField(IntPtr obj, IntPtr fieldID, IntPtr& value)
public bool GetBooleanField(IntPtr obj, IntPtr fieldID)
public byte GetByteField(IntPtr obj, IntPtr fieldID)
public char GetCharField(IntPtr obj, IntPtr fieldID)
public short GetShortField(IntPtr obj, IntPtr fieldID)
public int GetIntField(IntPtr obj, IntPtr fieldID)
public long GetLongField(IntPtr obj, IntPtr fieldID)
public float GetFloatField(IntPtr obj, IntPtr fieldID)
public double GetDoubleField(IntPtr obj, IntPtr fieldID)
public void SetStringField(IntPtr obj, IntPtr fieldID, string val)
public void SetObjectField(IntPtr obj, IntPtr fieldID, IntPtr val)
public void SetBooleanField(IntPtr obj, IntPtr fieldID, bool val)
public void SetByteField(IntPtr obj, IntPtr fieldID, byte val)
public void SetCharField(IntPtr obj, IntPtr fieldID, char val)
public void SetShortField(IntPtr obj, IntPtr fieldID, short val)
public void SetIntField(IntPtr obj, IntPtr fieldID, int val)
public void SetLongField(IntPtr obj, IntPtr fieldID, long val)
public void SetFloatField(IntPtr obj, IntPtr fieldID, float val)
public void SetDoubleField(IntPtr obj, IntPtr fieldID, double val)
public string CallStaticStringMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public IntPtr CallStaticObjectMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
private void INTERNAL_CALL_CallStaticObjectMethod(IntPtr clazz, IntPtr methodID, jvalue[] args, IntPtr& value)
public int CallStaticIntMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public bool CallStaticBooleanMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public short CallStaticShortMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public byte CallStaticByteMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public char CallStaticCharMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public float CallStaticFloatMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public double CallStaticDoubleMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public long CallStaticLongMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public void CallStaticVoidMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public string GetStaticStringField(IntPtr clazz, IntPtr fieldID)
public IntPtr GetStaticObjectField(IntPtr clazz, IntPtr fieldID)
private void INTERNAL_CALL_GetStaticObjectField(IntPtr clazz, IntPtr fieldID, IntPtr& value)
public bool GetStaticBooleanField(IntPtr clazz, IntPtr fieldID)
public byte GetStaticByteField(IntPtr clazz, IntPtr fieldID)
public char GetStaticCharField(IntPtr clazz, IntPtr fieldID)
public short GetStaticShortField(IntPtr clazz, IntPtr fieldID)
public int GetStaticIntField(IntPtr clazz, IntPtr fieldID)
public long GetStaticLongField(IntPtr clazz, IntPtr fieldID)
public float GetStaticFloatField(IntPtr clazz, IntPtr fieldID)
public double GetStaticDoubleField(IntPtr clazz, IntPtr fieldID)
public void SetStaticStringField(IntPtr clazz, IntPtr fieldID, string val)
public void SetStaticObjectField(IntPtr clazz, IntPtr fieldID, IntPtr val)
public void SetStaticBooleanField(IntPtr clazz, IntPtr fieldID, bool val)
public void SetStaticByteField(IntPtr clazz, IntPtr fieldID, byte val)
public void SetStaticCharField(IntPtr clazz, IntPtr fieldID, char val)
public void SetStaticShortField(IntPtr clazz, IntPtr fieldID, short val)
public void SetStaticIntField(IntPtr clazz, IntPtr fieldID, int val)
public void SetStaticLongField(IntPtr clazz, IntPtr fieldID, long val)
public void SetStaticFloatField(IntPtr clazz, IntPtr fieldID, float val)
public void SetStaticDoubleField(IntPtr clazz, IntPtr fieldID, double val)
public IntPtr ToBooleanArray(Boolean[] array)
private void INTERNAL_CALL_ToBooleanArray(Boolean[] array, IntPtr& value)
public IntPtr ToByteArray(Byte[] array)
private void INTERNAL_CALL_ToByteArray(Byte[] array, IntPtr& value)
public IntPtr ToCharArray(Char[] array)
private void INTERNAL_CALL_ToCharArray(Char[] array, IntPtr& value)
public IntPtr ToShortArray(Int16[] array)
private void INTERNAL_CALL_ToShortArray(Int16[] array, IntPtr& value)
public IntPtr ToIntArray(Int32[] array)
private void INTERNAL_CALL_ToIntArray(Int32[] array, IntPtr& value)
public IntPtr ToLongArray(Int64[] array)
private void INTERNAL_CALL_ToLongArray(Int64[] array, IntPtr& value)
public IntPtr ToFloatArray(Single[] array)
private void INTERNAL_CALL_ToFloatArray(Single[] array, IntPtr& value)
public IntPtr ToDoubleArray(Double[] array)
private void INTERNAL_CALL_ToDoubleArray(Double[] array, IntPtr& value)
public IntPtr ToObjectArray(IntPtr[] array, IntPtr arrayClass)
private void INTERNAL_CALL_ToObjectArray(IntPtr[] array, IntPtr arrayClass, IntPtr& value)
public IntPtr ToObjectArray(IntPtr[] array)
public Boolean[] FromBooleanArray(IntPtr array)
public Byte[] FromByteArray(IntPtr array)
public Char[] FromCharArray(IntPtr array)
public Int16[] FromShortArray(IntPtr array)
public Int32[] FromIntArray(IntPtr array)
public Int64[] FromLongArray(IntPtr array)
public Single[] FromFloatArray(IntPtr array)
public Double[] FromDoubleArray(IntPtr array)
public IntPtr[] FromObjectArray(IntPtr array)
public int GetArrayLength(IntPtr array)
public IntPtr NewBooleanArray(int size)
private void INTERNAL_CALL_NewBooleanArray(int size, IntPtr& value)
public IntPtr NewByteArray(int size)
private void INTERNAL_CALL_NewByteArray(int size, IntPtr& value)
public IntPtr NewCharArray(int size)
private void INTERNAL_CALL_NewCharArray(int size, IntPtr& value)
public IntPtr NewShortArray(int size)
private void INTERNAL_CALL_NewShortArray(int size, IntPtr& value)
public IntPtr NewIntArray(int size)
private void INTERNAL_CALL_NewIntArray(int size, IntPtr& value)
public IntPtr NewLongArray(int size)
private void INTERNAL_CALL_NewLongArray(int size, IntPtr& value)
public IntPtr NewFloatArray(int size)
private void INTERNAL_CALL_NewFloatArray(int size, IntPtr& value)
public IntPtr NewDoubleArray(int size)
private void INTERNAL_CALL_NewDoubleArray(int size, IntPtr& value)
public IntPtr NewObjectArray(int size, IntPtr clazz, IntPtr obj)
private void INTERNAL_CALL_NewObjectArray(int size, IntPtr clazz, IntPtr obj, IntPtr& value)
public bool GetBooleanArrayElement(IntPtr array, int index)
public byte GetByteArrayElement(IntPtr array, int index)
public char GetCharArrayElement(IntPtr array, int index)
public short GetShortArrayElement(IntPtr array, int index)
public int GetIntArrayElement(IntPtr array, int index)
public long GetLongArrayElement(IntPtr array, int index)
public float GetFloatArrayElement(IntPtr array, int index)
public double GetDoubleArrayElement(IntPtr array, int index)
public IntPtr GetObjectArrayElement(IntPtr array, int index)
private void INTERNAL_CALL_GetObjectArrayElement(IntPtr array, int index, IntPtr& value)
public void SetBooleanArrayElement(IntPtr array, int index, byte val)
public void SetByteArrayElement(IntPtr array, int index, sbyte val)
public void SetCharArrayElement(IntPtr array, int index, char val)
public void SetShortArrayElement(IntPtr array, int index, short val)
public void SetIntArrayElement(IntPtr array, int index, int val)
public void SetLongArrayElement(IntPtr array, int index, long val)
public void SetFloatArrayElement(IntPtr array, int index, float val)
public void SetDoubleArrayElement(IntPtr array, int index, double val)
public void SetObjectArrayElement(IntPtr array, int index, IntPtr obj)
}
public UnityEngine.AndroidJNIHelper : object {
public bool debug
public bool get_debug()
public void set_debug(bool value)
public IntPtr GetConstructorID(IntPtr javaClass)
public IntPtr GetConstructorID(IntPtr javaClass, string signature)
public IntPtr GetMethodID(IntPtr javaClass, string methodName, string signature)
public IntPtr GetMethodID(IntPtr javaClass, string methodName)
public IntPtr GetMethodID(IntPtr javaClass, string methodName, string signature, bool isStatic)
public IntPtr GetFieldID(IntPtr javaClass, string fieldName, string signature)
public IntPtr GetFieldID(IntPtr javaClass, string fieldName)
public IntPtr GetFieldID(IntPtr javaClass, string fieldName, string signature, bool isStatic)
public IntPtr CreateJavaRunnable(AndroidJavaRunnable jrunnable)
public IntPtr CreateJavaProxy(AndroidJavaProxy proxy)
private void INTERNAL_CALL_CreateJavaProxy(AndroidJavaProxy proxy, IntPtr& value)
public IntPtr ConvertToJNIArray(Array array)
public jvalue[] CreateJNIArgArray(Object[] args)
public void DeleteJNIArgArray(Object[] args, jvalue[] jniArgs)
public IntPtr GetConstructorID(IntPtr jclass, Object[] args)
public IntPtr GetMethodID(IntPtr jclass, string methodName, Object[] args, bool isStatic)
public string GetSignature(object obj)
public string GetSignature(Object[] args)
public ArrayType ConvertFromJNIArray(IntPtr array)
public IntPtr GetMethodID(IntPtr jclass, string methodName, Object[] args, bool isStatic)
public IntPtr GetFieldID(IntPtr jclass, string fieldName, bool isStatic)
public string GetSignature(Object[] args)
}
internal UnityEngine.AndroidJNISafe : object {
public void CheckException()
public void DeleteGlobalRef(IntPtr globalref)
public void DeleteLocalRef(IntPtr localref)
public IntPtr NewStringUTF(string bytes)
public string GetStringUTFChars(IntPtr str)
public IntPtr GetObjectClass(IntPtr ptr)
public IntPtr GetStaticMethodID(IntPtr clazz, string name, string sig)
public IntPtr GetMethodID(IntPtr obj, string name, string sig)
public IntPtr GetFieldID(IntPtr clazz, string name, string sig)
public IntPtr GetStaticFieldID(IntPtr clazz, string name, string sig)
public IntPtr FromReflectedMethod(IntPtr refMethod)
public IntPtr FromReflectedField(IntPtr refField)
public IntPtr FindClass(string name)
public IntPtr NewObject(IntPtr clazz, IntPtr methodID, jvalue[] args)
public void SetStaticObjectField(IntPtr clazz, IntPtr fieldID, IntPtr val)
public void SetStaticStringField(IntPtr clazz, IntPtr fieldID, string val)
public void SetStaticCharField(IntPtr clazz, IntPtr fieldID, char val)
public void SetStaticDoubleField(IntPtr clazz, IntPtr fieldID, double val)
public void SetStaticFloatField(IntPtr clazz, IntPtr fieldID, float val)
public void SetStaticLongField(IntPtr clazz, IntPtr fieldID, long val)
public void SetStaticShortField(IntPtr clazz, IntPtr fieldID, short val)
public void SetStaticByteField(IntPtr clazz, IntPtr fieldID, byte val)
public void SetStaticBooleanField(IntPtr clazz, IntPtr fieldID, bool val)
public void SetStaticIntField(IntPtr clazz, IntPtr fieldID, int val)
public IntPtr GetStaticObjectField(IntPtr clazz, IntPtr fieldID)
public string GetStaticStringField(IntPtr clazz, IntPtr fieldID)
public char GetStaticCharField(IntPtr clazz, IntPtr fieldID)
public double GetStaticDoubleField(IntPtr clazz, IntPtr fieldID)
public float GetStaticFloatField(IntPtr clazz, IntPtr fieldID)
public long GetStaticLongField(IntPtr clazz, IntPtr fieldID)
public short GetStaticShortField(IntPtr clazz, IntPtr fieldID)
public byte GetStaticByteField(IntPtr clazz, IntPtr fieldID)
public bool GetStaticBooleanField(IntPtr clazz, IntPtr fieldID)
public int GetStaticIntField(IntPtr clazz, IntPtr fieldID)
public void CallStaticVoidMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public IntPtr CallStaticObjectMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public string CallStaticStringMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public char CallStaticCharMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public double CallStaticDoubleMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public float CallStaticFloatMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public long CallStaticLongMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public short CallStaticShortMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public byte CallStaticByteMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public bool CallStaticBooleanMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public int CallStaticIntMethod(IntPtr clazz, IntPtr methodID, jvalue[] args)
public void SetObjectField(IntPtr obj, IntPtr fieldID, IntPtr val)
public void SetStringField(IntPtr obj, IntPtr fieldID, string val)
public void SetCharField(IntPtr obj, IntPtr fieldID, char val)
public void SetDoubleField(IntPtr obj, IntPtr fieldID, double val)
public void SetFloatField(IntPtr obj, IntPtr fieldID, float val)
public void SetLongField(IntPtr obj, IntPtr fieldID, long val)
public void SetShortField(IntPtr obj, IntPtr fieldID, short val)
public void SetByteField(IntPtr obj, IntPtr fieldID, byte val)
public void SetBooleanField(IntPtr obj, IntPtr fieldID, bool val)
public void SetIntField(IntPtr obj, IntPtr fieldID, int val)
public IntPtr GetObjectField(IntPtr obj, IntPtr fieldID)
public string GetStringField(IntPtr obj, IntPtr fieldID)
public char GetCharField(IntPtr obj, IntPtr fieldID)
public double GetDoubleField(IntPtr obj, IntPtr fieldID)
public float GetFloatField(IntPtr obj, IntPtr fieldID)
public long GetLongField(IntPtr obj, IntPtr fieldID)
public short GetShortField(IntPtr obj, IntPtr fieldID)
public byte GetByteField(IntPtr obj, IntPtr fieldID)
public bool GetBooleanField(IntPtr obj, IntPtr fieldID)
public int GetIntField(IntPtr obj, IntPtr fieldID)
public void CallVoidMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public IntPtr CallObjectMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public string CallStringMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public char CallCharMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public double CallDoubleMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public float CallFloatMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public long CallLongMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public short CallShortMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public byte CallByteMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public bool CallBooleanMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public int CallIntMethod(IntPtr obj, IntPtr methodID, jvalue[] args)
public IntPtr[] FromObjectArray(IntPtr array)
public Char[] FromCharArray(IntPtr array)
public Double[] FromDoubleArray(IntPtr array)
public Single[] FromFloatArray(IntPtr array)
public Int64[] FromLongArray(IntPtr array)
public Int16[] FromShortArray(IntPtr array)
public Byte[] FromByteArray(IntPtr array)
public Boolean[] FromBooleanArray(IntPtr array)
public Int32[] FromIntArray(IntPtr array)
public IntPtr ToObjectArray(IntPtr[] array)
public IntPtr ToObjectArray(IntPtr[] array, IntPtr type)
public IntPtr ToCharArray(Char[] array)
public IntPtr ToDoubleArray(Double[] array)
public IntPtr ToFloatArray(Single[] array)
public IntPtr ToLongArray(Int64[] array)
public IntPtr ToShortArray(Int16[] array)
public IntPtr ToByteArray(Byte[] array)
public IntPtr ToBooleanArray(Boolean[] array)
public IntPtr ToIntArray(Int32[] array)
public IntPtr GetObjectArrayElement(IntPtr array, int index)
public int GetArrayLength(IntPtr array)
}
internal UnityEngine.AndroidReflection : object {
private string RELECTION_HELPER_CLASS_NAME
private GlobalJavaObjectRef s_ReflectionHelperClass
private IntPtr s_ReflectionHelperGetConstructorID
private IntPtr s_ReflectionHelperGetMethodID
private IntPtr s_ReflectionHelperGetFieldID
private IntPtr s_ReflectionHelperNewProxyInstance
public bool IsPrimitive(Type t)
public bool IsAssignableFrom(Type t, Type from)
private IntPtr GetStaticMethodID(string clazz, string methodName, string signature)
public IntPtr GetConstructorMember(IntPtr jclass, string signature)
public IntPtr GetMethodMember(IntPtr jclass, string methodName, string signature, bool isStatic)
public IntPtr GetFieldMember(IntPtr jclass, string fieldName, string signature, bool isStatic)
public IntPtr NewProxyInstance(int delegateHandle, IntPtr interfaze)
}
public UnityEngine.AnimationCurve : object {
internal IntPtr m_Ptr
public Keyframe[] keys
public Keyframe Item
public int length
public WrapMode preWrapMode
public WrapMode postWrapMode
public void .ctor(Keyframe[] keys)
private void Cleanup()
protected void Finalize()
public float Evaluate(float time)
public Keyframe[] get_keys()
public void set_keys(Keyframe[] value)
public int AddKey(float time, float value)
public int AddKey(Keyframe key)
private int AddKey_Internal(Keyframe key)
private int INTERNAL_CALL_AddKey_Internal(AnimationCurve self, Keyframe& key)
public int MoveKey(int index, Keyframe key)
private int INTERNAL_CALL_MoveKey(AnimationCurve self, int index, Keyframe& key)
public void RemoveKey(int index)
public Keyframe get_Item(int index)
public int get_length()
private void SetKeys(Keyframe[] keys)
private Keyframe GetKey_Internal(int index)
private void INTERNAL_CALL_GetKey_Internal(AnimationCurve self, int index, Keyframe& value)
private Keyframe[] GetKeys()
public void SmoothTangents(int index, float weight)
public AnimationCurve Constant(float timeStart, float timeEnd, float value)
public AnimationCurve Linear(float timeStart, float valueStart, float timeEnd, float valueEnd)
public AnimationCurve EaseInOut(float timeStart, float valueStart, float timeEnd, float valueEnd)
public WrapMode get_preWrapMode()
public void set_preWrapMode(WrapMode value)
public WrapMode get_postWrapMode()
public void set_postWrapMode(WrapMode value)
private void Init(Keyframe[] keys)
}
public UnityEngine.AnisotropicFiltering : Enum {
public int value__
public AnisotropicFiltering Disable
public AnisotropicFiltering Enable
public AnisotropicFiltering ForceEnable
}
public UnityEngine.Application : object {
private LowMemoryCallback lowMemory
internal AdvertisingIdentifierCallback OnAdvertisingIdentifierCallback
private LogCallback s_LogCallbackHandler
private LogCallback s_LogCallbackHandlerThreaded
private Func`1<bool> wantsToQuit
private Action quitting
private LogCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_RegisterLogCallbackDeprecated
public bool isLoadingLevel
public int streamedBytes
public bool isPlaying
public bool isFocused
public bool isEditor
public bool isWebPlayer
public RuntimePlatform platform
public string buildGUID
public bool isMobilePlatform
public bool isConsolePlatform
public bool runInBackground
public bool isPlayer
internal bool isBatchmode
internal bool isTestRun
internal bool isHumanControllingUs
public string dataPath
public string streamingAssetsPath
public string persistentDataPath
public string temporaryCachePath
public string srcValue
public string absoluteURL
public string unityVersion
public string version
public string installerName
public string identifier
public ApplicationInstallMode installMode
public ApplicationSandboxType sandboxType
public string productName
public string companyName
public string cloudProjectId
public bool webSecurityEnabled
public string webSecurityHostUrl
public int targetFrameRate
public SystemLanguage systemLanguage
public StackTraceLogType stackTraceLogType
public ThreadPriority backgroundLoadingPriority
public NetworkReachability internetReachability
public bool genuine
public bool genuineCheckAvailable
internal bool submitAnalytics
public bool isShowingSplashScreen
public int levelCount
public int loadedLevel
public string loadedLevelName
public void add_lowMemory(LowMemoryCallback value)
public void remove_lowMemory(LowMemoryCallback value)
private void CallLowMemory()
public void Quit()
public void CancelQuit()
public void Unload()
public bool get_isLoadingLevel()
private float GetStreamProgressForLevelByName(string levelName)
public float GetStreamProgressForLevel(int levelIndex)
public float GetStreamProgressForLevel(string levelName)
public int get_streamedBytes()
private bool CanStreamedLevelBeLoadedByName(string levelName)
public bool CanStreamedLevelBeLoaded(int levelIndex)
public bool CanStreamedLevelBeLoaded(string levelName)
public bool get_isPlaying()
public bool get_isFocused()
public bool get_isEditor()
public bool get_isWebPlayer()
public RuntimePlatform get_platform()
public String[] GetBuildTags()
public void SetBuildTags(String[] buildTags)
public string get_buildGUID()
public bool get_isMobilePlatform()
public bool get_isConsolePlatform()
public void CaptureScreenshot(string filename, int superSize)
public void CaptureScreenshot(string filename)
public bool get_runInBackground()
public void set_runInBackground(bool value)
public bool get_isPlayer()
public bool HasProLicense()
internal bool HasAdvancedLicense()
internal bool get_isBatchmode()
internal bool get_isTestRun()
internal bool get_isHumanControllingUs()
internal bool HasARGV(string name)
internal string GetValueForARGV(string name)
public void DontDestroyOnLoad(Object mono)
public string get_dataPath()
public string get_streamingAssetsPath()
public string get_persistentDataPath()
public string get_temporaryCachePath()
public string get_srcValue()
public string get_absoluteURL()
private string ObjectToJSString(object o)
public void ExternalCall(string functionName, Object[] args)
private string BuildInvocationForArguments(string functionName, Object[] args)
public void ExternalEval(string script)
private void Internal_ExternalCall(string script)
public string get_unityVersion()
public string get_version()
public string get_installerName()
public string get_identifier()
public ApplicationInstallMode get_installMode()
public ApplicationSandboxType get_sandboxType()
public string get_productName()
public string get_companyName()
public string get_cloudProjectId()
internal void InvokeOnAdvertisingIdentifierCallback(string advertisingId, bool trackingEnabled)
public bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod)
public bool get_webSecurityEnabled()
public string get_webSecurityHostUrl()
public void OpenURL(string url)
public void ForceCrash(int mode)
public int get_targetFrameRate()
public void set_targetFrameRate(int value)
public SystemLanguage get_systemLanguage()
public void add_logMessageReceived(LogCallback value)
public void remove_logMessageReceived(LogCallback value)
public void add_logMessageReceivedThreaded(LogCallback value)
public void remove_logMessageReceivedThreaded(LogCallback value)
private void CallLogCallback(string logString, string stackTrace, LogType type, bool invokedOnMainThread)
private void SetLogCallbackDefined(bool defined)
public StackTraceLogType get_stackTraceLogType()
public void set_stackTraceLogType(StackTraceLogType value)
public StackTraceLogType GetStackTraceLogType(LogType logType)
public void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType)
public ThreadPriority get_backgroundLoadingPriority()
public void set_backgroundLoadingPriority(ThreadPriority value)
public NetworkReachability get_internetReachability()
public bool get_genuine()
public bool get_genuineCheckAvailable()
public AsyncOperation RequestUserAuthorization(UserAuthorization mode)
public bool HasUserAuthorization(UserAuthorization mode)
internal bool get_submitAnalytics()
public bool get_isShowingSplashScreen()
public void add_onBeforeRender(UnityAction value)
public void remove_onBeforeRender(UnityAction value)
public void add_wantsToQuit(Func`1<bool> value)
public void remove_wantsToQuit(Func`1<bool> value)
public void add_quitting(Action value)
public void remove_quitting(Action value)
private bool Internal_ApplicationWantsToQuit()
private void Internal_ApplicationQuit()
internal void InvokeOnBeforeRender()
public void RegisterLogCallback(LogCallback handler)
public void RegisterLogCallbackThreaded(LogCallback handler)
private void RegisterLogCallback(LogCallback handler, bool threaded)
public int get_levelCount()
public int get_loadedLevel()
public string get_loadedLevelName()
public void LoadLevel(int index)
public void LoadLevel(string name)
public void LoadLevelAdditive(int index)
public void LoadLevelAdditive(string name)
public AsyncOperation LoadLevelAsync(int index)
public AsyncOperation LoadLevelAsync(string levelName)
public AsyncOperation LoadLevelAdditiveAsync(int index)
public AsyncOperation LoadLevelAdditiveAsync(string levelName)
public bool UnloadLevel(int index)
public bool UnloadLevel(string scenePath)
}
public UnityEngine.ApplicationInstallMode : Enum {
public int value__
public ApplicationInstallMode Unknown
public ApplicationInstallMode Store
public ApplicationInstallMode DeveloperBuild
public ApplicationInstallMode Adhoc
public ApplicationInstallMode Enterprise
public ApplicationInstallMode Editor
}
public UnityEngine.ApplicationSandboxType : Enum {
public int value__
public ApplicationSandboxType Unknown
public ApplicationSandboxType NotSandboxed
public ApplicationSandboxType Sandboxed
public ApplicationSandboxType SandboxBroken
}
public UnityEngine.Assertions.Assert : object {
internal string UNITY_ASSERTIONS
public bool raiseExceptions
private void Fail(string message, string userMessage)
public bool Equals(object obj1, object obj2)
public bool ReferenceEquals(object obj1, object obj2)
public void IsTrue(bool condition)
public void IsTrue(bool condition, string message)
public void IsFalse(bool condition)
public void IsFalse(bool condition, string message)
public void AreApproximatelyEqual(float expected, float actual)
public void AreApproximatelyEqual(float expected, float actual, string message)
public void AreApproximatelyEqual(float expected, float actual, float tolerance)
public void AreApproximatelyEqual(float expected, float actual, float tolerance, string message)
public void AreNotApproximatelyEqual(float expected, float actual)
public void AreNotApproximatelyEqual(float expected, float actual, string message)
public void AreNotApproximatelyEqual(float expected, float actual, float tolerance)
public void AreNotApproximatelyEqual(float expected, float actual, float tolerance, string message)
public void AreEqual(T expected, T actual)
public void AreEqual(T expected, T actual, string message)
public void AreEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer)
public void AreEqual(Object expected, Object actual, string message)
public void AreNotEqual(T expected, T actual)
public void AreNotEqual(T expected, T actual, string message)
public void AreNotEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer)
public void AreNotEqual(Object expected, Object actual, string message)
public void IsNull(T value)
public void IsNull(T value, string message)
public void IsNull(Object value, string message)
public void IsNotNull(T value)
public void IsNotNull(T value, string message)
public void IsNotNull(Object value, string message)
}
public UnityEngine.Assertions.AssertionException : Exception {
private string m_UserMessage
public string Message
public void .ctor(string message, string userMessage)
public string get_Message()
}
internal UnityEngine.Assertions.AssertionMessageUtil : object {
private string k_Expected
private string k_AssertionFailed
public string GetMessage(string failureMessage)
public string GetMessage(string failureMessage, string expected)
public string GetEqualityMessage(object actual, object expected, bool expectEqual)
public string NullFailureMessage(object value, bool expectNull)
public string BooleanFailureMessage(bool expected)
}
public UnityEngine.Assertions.Comparers.FloatComparer : object {
private float m_Error
private bool m_Relative
public FloatComparer s_ComparerWithDefaultTolerance
public float kEpsilon
public void .ctor(bool relative)
public void .ctor(float error)
public void .ctor(float error, bool relative)
public bool Equals(float a, float b)
public int GetHashCode(float obj)
public bool AreEqual(float expected, float actual, float error)
public bool AreEqualRelative(float expected, float actual, float error)
}
public UnityEngine.Assertions.Must.MustExtensions : object {
public void MustBeTrue(bool value)
public void MustBeTrue(bool value, string message)
public void MustBeFalse(bool value)
public void MustBeFalse(bool value, string message)
public void MustBeApproximatelyEqual(float actual, float expected)
public void MustBeApproximatelyEqual(float actual, float expected, string message)
public void MustBeApproximatelyEqual(float actual, float expected, float tolerance)
public void MustBeApproximatelyEqual(float actual, float expected, float tolerance, string message)
public void MustNotBeApproximatelyEqual(float actual, float expected)
public void MustNotBeApproximatelyEqual(float actual, float expected, string message)
public void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance)
public void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance, string message)
public void MustBeEqual(T actual, T expected)
public void MustBeEqual(T actual, T expected, string message)
public void MustNotBeEqual(T actual, T expected)
public void MustNotBeEqual(T actual, T expected, string message)
public void MustBeNull(T expected)
public void MustBeNull(T expected, string message)
public void MustNotBeNull(T expected)
public void MustNotBeNull(T expected, string message)
}
public UnityEngine.AsyncOperation : YieldInstruction {
internal IntPtr m_Ptr
private Action`1<AsyncOperation> m_completeCallback
public bool isDone
public float progress
public int priority
public bool allowSceneActivation
private void InternalDestroy()
protected void Finalize()
public bool get_isDone()
public float get_progress()
public int get_priority()
public void set_priority(int value)
public bool get_allowSceneActivation()
public void set_allowSceneActivation(bool value)
internal void InvokeCompletionEvent()
public void add_completed(Action`1<AsyncOperation> value)
public void remove_completed(Action`1<AsyncOperation> value)
}
internal UnityEngine.AttributeHelperEngine : object {
private Type GetParentTypeDisallowingMultipleInclusion(Type type)
private Type[] GetRequiredComponents(Type klass)
private bool CheckIsEditorScript(Type klass)
private int GetDefaultExecutionOrderFor(Type klass)
private T GetCustomAttributeOfType(Type klass)
}
public UnityEngine.AudioType : Enum {
public int value__
public AudioType UNKNOWN
public AudioType ACC
public AudioType AIFF
public AudioType IT
public AudioType MOD
public AudioType MPEG
public AudioType OGGVORBIS
public AudioType S3M
public AudioType WAV
public AudioType XM
public AudioType XMA
public AudioType VAG
public AudioType AUDIOQUEUE
}
public UnityEngine.BatteryStatus : Enum {
public int value__
public BatteryStatus Unknown
public BatteryStatus Charging
public BatteryStatus Discharging
public BatteryStatus NotCharging
public BatteryStatus Full
}
internal UnityEngine.BeforeRenderHelper : object {
private List`1<OrderBlock> s_OrderBlocks
private int GetUpdateOrder(UnityAction callback)
public void RegisterCallback(UnityAction callback)
public void UnregisterCallback(UnityAction callback)
public void Invoke()
}
public UnityEngine.BeforeRenderOrderAttribute : Attribute {
private int <order>k__BackingField
public int order
public void .ctor(int order)
public int get_order()
private void set_order(int value)
}
public UnityEngine.Behaviour : Component {
public bool enabled
public bool isActiveAndEnabled
public bool get_enabled()
public void set_enabled(bool value)
public bool get_isActiveAndEnabled()
}
public UnityEngine.BillboardAsset : Object {
public float width
public float height
public float bottom
public int imageCount
public int vertexCount
public int indexCount
public Material material
private void Internal_Create(BillboardAsset obj)
public float get_width()
public void set_width(float value)
public float get_height()
public void set_height(float value)
public float get_bottom()
public void set_bottom(float value)
public int get_imageCount()
public int get_vertexCount()
public int get_indexCount()
public Material get_material()
public void set_material(Material value)
public void GetImageTexCoords(List`1<Vector4> imageTexCoords)
public Vector4[] GetImageTexCoords()
internal void GetImageTexCoordsInternal(object list)
public void SetImageTexCoords(List`1<Vector4> imageTexCoords)
public void SetImageTexCoords(Vector4[] imageTexCoords)
internal void SetImageTexCoordsInternalList(object list)
public void GetVertices(List`1<Vector2> vertices)
public Vector2[] GetVertices()
internal void GetVerticesInternal(object list)
public void SetVertices(List`1<Vector2> vertices)
public void SetVertices(Vector2[] vertices)
internal void SetVerticesInternalList(object list)
public void GetIndices(List`1<ushort> indices)
public UInt16[] GetIndices()
internal void GetIndicesInternal(object list)
public void SetIndices(List`1<ushort> indices)
public void SetIndices(UInt16[] indices)
internal void SetIndicesInternalList(object list)
internal void MakeMaterialProperties(MaterialPropertyBlock properties, Camera camera)
}
public UnityEngine.BillboardRenderer : Renderer {
public BillboardAsset billboard
public BillboardAsset get_billboard()
public void set_billboard(BillboardAsset value)
}
public UnityEngine.BitStream : object {
internal IntPtr m_Ptr
public bool isReading
public bool isWriting
private void Serializeb(Int32& value)
private void Serializec(Char& value)
private void Serializes(Int16& value)
private void Serializei(Int32& value)
private void Serializef(Single& value, float maximumDelta)
private void Serializeq(Quaternion& value, float maximumDelta)
private void INTERNAL_CALL_Serializeq(BitStream self, Quaternion& value, float maximumDelta)
private void Serializev(Vector3& value, float maximumDelta)
private void INTERNAL_CALL_Serializev(BitStream self, Vector3& value, float maximumDelta)
private void Serializen(NetworkViewID& viewID)
private void INTERNAL_CALL_Serializen(BitStream self, NetworkViewID& viewID)
public void Serialize(Boolean& value)
public void Serialize(Char& value)
public void Serialize(Int16& value)
public void Serialize(Int32& value)
public void Serialize(Single& value)
public void Serialize(Single& value, float maxDelta)
public void Serialize(Quaternion& value)
public void Serialize(Quaternion& value, float maxDelta)
public void Serialize(Vector3& value)
public void Serialize(Vector3& value, float maxDelta)
public void Serialize(NetworkPlayer& value)
public void Serialize(NetworkViewID& viewID)
public bool get_isReading()
public bool get_isWriting()
private void Serialize(String& value)
}
public UnityEngine.BlendWeights : Enum {
public int value__
public BlendWeights OneBone
public BlendWeights TwoBones
public BlendWeights FourBones
}
public UnityEngine.BoneWeight : ValueType {
private float m_Weight0
private float m_Weight1
private float m_Weight2
private float m_Weight3
private int m_BoneIndex0
private int m_BoneIndex1
private int m_BoneIndex2
private int m_BoneIndex3
public float weight0
public float weight1
public float weight2
public float weight3
public int boneIndex0
public int boneIndex1
public int boneIndex2
public int boneIndex3
public float get_weight0()
public void set_weight0(float value)
public float get_weight1()
public void set_weight1(float value)
public float get_weight2()
public void set_weight2(float value)
public float get_weight3()
public void set_weight3(float value)
public int get_boneIndex0()
public void set_boneIndex0(int value)
public int get_boneIndex1()
public void set_boneIndex1(int value)
public int get_boneIndex2()
public void set_boneIndex2(int value)
public int get_boneIndex3()
public void set_boneIndex3(int value)
public int GetHashCode()
public bool Equals(object other)
public bool op_Equality(BoneWeight lhs, BoneWeight rhs)
public bool op_Inequality(BoneWeight lhs, BoneWeight rhs)
}
internal UnityEngine.BootConfigData : object {
private IntPtr m_Ptr
private void .ctor(IntPtr nativeHandle)
public void AddKey(string key)
public string Get(string key)
public string Get(string key, int index)
public void Append(string key, string value)
public void Set(string key, string value)
private string GetValue(string key, int index)
private BootConfigData WrapBootConfigData(IntPtr nativeHandle)
}
public UnityEngine.BoundingSphere : ValueType {
public Vector3 position
public float radius
public void .ctor(Vector3 pos, float rad)
public void .ctor(Vector4 packedSphere)
}
public UnityEngine.Bounds : ValueType {
private Vector3 m_Center
private Vector3 m_Extents
public Vector3 center
public Vector3 size
public Vector3 extents
public Vector3 min
public Vector3 max
public void .ctor(Vector3 center, Vector3 size)
public int GetHashCode()
public bool Equals(object other)
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_size()
public void set_size(Vector3 value)
public Vector3 get_extents()
public void set_extents(Vector3 value)
public Vector3 get_min()
public void set_min(Vector3 value)
public Vector3 get_max()
public void set_max(Vector3 value)
public bool op_Equality(Bounds lhs, Bounds rhs)
public bool op_Inequality(Bounds lhs, Bounds rhs)
public void SetMinMax(Vector3 min, Vector3 max)
public void Encapsulate(Vector3 point)
public void Encapsulate(Bounds bounds)
public void Expand(float amount)
public void Expand(Vector3 amount)
public bool Intersects(Bounds bounds)
public bool IntersectRay(Ray ray)
public bool IntersectRay(Ray ray, Single& distance)
public string ToString()
public string ToString(string format)
public bool Contains(Vector3 point)
public float SqrDistance(Vector3 point)
private bool IntersectRayAABB(Ray ray, Bounds bounds, Single& dist)
public Vector3 ClosestPoint(Vector3 point)
private bool Contains_Injected(Bounds& _unity_self, Vector3& point)
private float SqrDistance_Injected(Bounds& _unity_self, Vector3& point)
private bool IntersectRayAABB_Injected(Ray& ray, Bounds& bounds, Single& dist)
private void ClosestPoint_Injected(Bounds& _unity_self, Vector3& point, Vector3& ret)
}
public UnityEngine.BoundsInt : ValueType {
private Vector3Int m_Position
private Vector3Int m_Size
public int x
public int y
public int z
public Vector3 center
public Vector3Int min
public Vector3Int max
public int xMin
public int yMin
public int zMin
public int xMax
public int yMax
public int zMax
public Vector3Int position
public Vector3Int size
public PositionEnumerator allPositionsWithin
public void .ctor(int xMin, int yMin, int zMin, int sizeX, int sizeY, int sizeZ)
public void .ctor(Vector3Int position, Vector3Int size)
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public int get_z()
public void set_z(int value)
public Vector3 get_center()
public Vector3Int get_min()
public void set_min(Vector3Int value)
public Vector3Int get_max()
public void set_max(Vector3Int value)
public int get_xMin()
public void set_xMin(int value)
public int get_yMin()
public void set_yMin(int value)
public int get_zMin()
public void set_zMin(int value)
public int get_xMax()
public void set_xMax(int value)
public int get_yMax()
public void set_yMax(int value)
public int get_zMax()
public void set_zMax(int value)
public Vector3Int get_position()
public void set_position(Vector3Int value)
public Vector3Int get_size()
public void set_size(Vector3Int value)
public void SetMinMax(Vector3Int minPosition, Vector3Int maxPosition)
public void ClampToBounds(BoundsInt bounds)
public bool Contains(Vector3Int position)
public string ToString()
public bool op_Equality(BoundsInt lhs, BoundsInt rhs)
public bool op_Inequality(BoundsInt lhs, BoundsInt rhs)
public bool Equals(object other)
public int GetHashCode()
public PositionEnumerator get_allPositionsWithin()
}
public UnityEngine.Cache : ValueType {
private int m_Handle
internal int handle
public bool valid
public bool ready
public bool readOnly
public string path
public int index
public long spaceFree
public long maximumAvailableStorageSpace
public long spaceOccupied
public int expirationDelay
internal int get_handle()
public bool op_Equality(Cache lhs, Cache rhs)
public bool op_Inequality(Cache lhs, Cache rhs)
public int GetHashCode()
public bool Equals(object other)
public bool get_valid()
internal bool Cache_IsValid(int handle)
public bool get_ready()
internal bool Cache_IsReady(int handle)
public bool get_readOnly()
internal bool Cache_IsReadonly(int handle)
public string get_path()
internal string Cache_GetPath(int handle)
public int get_index()
internal int Cache_GetIndex(int handle)
public long get_spaceFree()
internal long Cache_GetSpaceFree(int handle)
public long get_maximumAvailableStorageSpace()
public void set_maximumAvailableStorageSpace(long value)
internal long Cache_GetMaximumDiskSpaceAvailable(int handle)
internal void Cache_SetMaximumDiskSpaceAvailable(int handle, long value)
public long get_spaceOccupied()
internal long Cache_GetCachingDiskSpaceUsed(int handle)
public int get_expirationDelay()
public void set_expirationDelay(int value)
internal int Cache_GetExpirationDelay(int handle)
internal void Cache_SetExpirationDelay(int handle, int value)
public bool ClearCache()
internal bool Cache_ClearCache(int handle)
public bool ClearCache(int expiration)
internal bool Cache_ClearCache_Expiration(int handle, int expiration)
}
public UnityEngine.CachedAssetBundle : ValueType {
private string m_Name
private Hash128 m_Hash
public string name
public Hash128 hash
public void .ctor(string name, Hash128 hash)
public string get_name()
public void set_name(string value)
public Hash128 get_hash()
public void set_hash(Hash128 value)
}
public UnityEngine.CacheIndex : ValueType {
public string name
public int bytesUsed
public int expires
}
public UnityEngine.Caching : object {
public CacheIndex[] index
public bool compressionEnabled
public bool ready
public int spaceUsed
public long spaceOccupied
public int spaceAvailable
public long spaceFree
public long maximumAvailableDiskSpace
public int expirationDelay
public int cacheCount
public Cache defaultCache
public Cache currentCacheForWriting
internal Hash128[] GetCachedVersions(string assetBundleName)
internal void GetCachedVersionsInternal(string assetBundleName, object cachedVersions)
public CacheIndex[] get_index()
public bool get_compressionEnabled()
public void set_compressionEnabled(bool value)
public bool get_ready()
public bool ClearCache()
public bool ClearCache(int expiration)
internal bool ClearCache_Int(int expiration)
public bool ClearCachedVersion(string assetBundleName, Hash128 hash)
internal bool ClearCachedVersionInternal(string assetBundleName, Hash128 hash)
public bool ClearOtherCachedVersions(string assetBundleName, Hash128 hash)
public bool ClearAllCachedVersions(string assetBundleName)
internal bool ClearCachedVersions(string assetBundleName, Hash128 hash, bool keepInputVersion)
public void GetCachedVersions(string assetBundleName, List`1<Hash128> outCachedVersions)
public bool IsVersionCached(string url, int version)
public bool IsVersionCached(string url, Hash128 hash)
public bool IsVersionCached(CachedAssetBundle cachedBundle)
internal bool IsVersionCached(string url, string assetBundleName, Hash128 hash)
public bool MarkAsUsed(string url, int version)
public bool MarkAsUsed(string url, Hash128 hash)
public bool MarkAsUsed(CachedAssetBundle cachedBundle)
internal bool MarkAsUsed(string url, string assetBundleName, Hash128 hash)
public int GetVersionFromCache(string url)
public int get_spaceUsed()
public long get_spaceOccupied()
public int get_spaceAvailable()
public long get_spaceFree()
public long get_maximumAvailableDiskSpace()
public void set_maximumAvailableDiskSpace(long value)
public int get_expirationDelay()
public void set_expirationDelay(int value)
public Cache AddCache(string cachePath)
internal Cache AddCache(string cachePath, bool isReadonly)
public Cache GetCacheAt(int cacheIndex)
public Cache GetCacheByPath(string cachePath)
public void GetAllCachePaths(List`1<string> cachePaths)
public bool RemoveCache(Cache cache)
public void MoveCacheBefore(Cache src, Cache dst)
public void MoveCacheAfter(Cache src, Cache dst)
public int get_cacheCount()
public Cache get_defaultCache()
public Cache get_currentCacheForWriting()
public void set_currentCacheForWriting(Cache value)
public bool CleanCache()
private bool ClearCachedVersionInternal_Injected(string assetBundleName, Hash128& hash)
private bool ClearCachedVersions_Injected(string assetBundleName, Hash128& hash, bool keepInputVersion)
private bool IsVersionCached_Injected(string url, string assetBundleName, Hash128& hash)
private bool MarkAsUsed_Injected(string url, string assetBundleName, Hash128& hash)
private void AddCache_Injected(string cachePath, bool isReadonly, Cache& ret)
private void GetCacheAt_Injected(int cacheIndex, Cache& ret)
private void GetCacheByPath_Injected(string cachePath, Cache& ret)
private bool RemoveCache_Injected(Cache& cache)
private void MoveCacheBefore_Injected(Cache& src, Cache& dst)
private void MoveCacheAfter_Injected(Cache& src, Cache& dst)
private void get_defaultCache_Injected(Cache& ret)
private void get_currentCacheForWriting_Injected(Cache& ret)
private void set_currentCacheForWriting_Injected(Cache& value)
}
public UnityEngine.Camera : Behaviour {
public CameraCallback onPreCull
public CameraCallback onPreRender
public CameraCallback onPostRender
internal int PreviewCullingLayer
public Scene scene
public MonoOrStereoscopicEye stereoActiveEye
public int targetDisplay
public Camera[] allCameras
public int allCamerasCount
public Single[] layerCullDistances
public float nearClipPlane
public float farClipPlane
public float fieldOfView
public RenderingPath renderingPath
public RenderingPath actualRenderingPath
public bool allowHDR
public bool allowMSAA
public bool allowDynamicResolution
public bool forceIntoRenderTexture
public float orthographicSize
public bool orthographic
public OpaqueSortMode opaqueSortMode
public TransparencySortMode transparencySortMode
public Vector3 transparencySortAxis
public float depth
public float aspect
public Vector3 velocity
public int cullingMask
public int eventMask
public bool layerCullSpherical
public CameraType cameraType
public bool useOcclusionCulling
public Matrix4x4 cullingMatrix
public Color backgroundColor
public CameraClearFlags clearFlags
public DepthTextureMode depthTextureMode
public bool clearStencilAfterLightingPass
public Rect rect
public Rect pixelRect
public int pixelWidth
public int pixelHeight
public int scaledPixelWidth
public int scaledPixelHeight
public RenderTexture targetTexture
public RenderTexture activeTexture
public Matrix4x4 cameraToWorldMatrix
public Matrix4x4 worldToCameraMatrix
public Matrix4x4 projectionMatrix
public Matrix4x4 nonJitteredProjectionMatrix
public bool useJitteredProjectionMatrixForTransparentRendering
public Matrix4x4 previousViewProjectionMatrix
public Camera main
public Camera current
public bool stereoEnabled
public float stereoSeparation
public float stereoConvergence
public bool areVRStereoViewMatricesWithinSingleCullTolerance
public StereoTargetEyeMask stereoTargetEye
public int commandBufferCount
internal String[] GetCameraBufferWarnings()
internal int get_PreviewCullingLayer()
public Scene get_scene()
public void set_scene(Scene value)
private void INTERNAL_get_scene(Scene& value)
private void INTERNAL_set_scene(Scene& value)
private void SetTargetBuffersImpl(RenderBuffer& color, RenderBuffer& depth)
private void SetTargetBuffersMRTImpl(RenderBuffer[] color, RenderBuffer& depth)
public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer)
public void SetTargetBuffers(RenderBuffer[] colorBuffer, RenderBuffer depthBuffer)
public MonoOrStereoscopicEye get_stereoActiveEye()
public int get_targetDisplay()
public void set_targetDisplay(int value)
public Camera[] get_allCameras()
public int get_allCamerasCount()
public int GetAllCameras(Camera[] cameras)
public void Render()
public void RenderWithShader(Shader shader, string replacementTag)
public void RenderDontRestore()
public void SetupCurrent(Camera cur)
public bool RenderToCubemap(Cubemap cubemap)
public bool RenderToCubemap(Cubemap cubemap, int faceMask)
public bool RenderToCubemap(RenderTexture cubemap)
public bool RenderToCubemap(RenderTexture cubemap, int faceMask)
private bool Internal_RenderToCubemapRT(RenderTexture cubemap, int faceMask)
private bool Internal_RenderToCubemapTexture(Cubemap cubemap, int faceMask)
public Single[] get_layerCullDistances()
public void set_layerCullDistances(Single[] value)
public void CopyFrom(Camera other)
internal bool IsFiltered(GameObject go)
public CommandBuffer[] GetCommandBuffers(CameraEvent evt)
internal void OnlyUsedForTesting1()
internal void OnlyUsedForTesting2()
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public RenderingPath get_renderingPath()
public void set_renderingPath(RenderingPath value)
public RenderingPath get_actualRenderingPath()
public bool get_allowHDR()
public void set_allowHDR(bool value)
public bool get_allowMSAA()
public void set_allowMSAA(bool value)
public bool get_allowDynamicResolution()
public void set_allowDynamicResolution(bool value)
public bool get_forceIntoRenderTexture()
public void set_forceIntoRenderTexture(bool value)
public float get_orthographicSize()
public void set_orthographicSize(float value)
public bool get_orthographic()
public void set_orthographic(bool value)
public OpaqueSortMode get_opaqueSortMode()
public void set_opaqueSortMode(OpaqueSortMode value)
public TransparencySortMode get_transparencySortMode()
public void set_transparencySortMode(TransparencySortMode value)
public Vector3 get_transparencySortAxis()
public void set_transparencySortAxis(Vector3 value)
public void ResetTransparencySortSettings()
public float get_depth()
public void set_depth(float value)
public float get_aspect()
public void set_aspect(float value)
public void ResetAspect()
public Vector3 get_velocity()
public int get_cullingMask()
public void set_cullingMask(int value)
public int get_eventMask()
public void set_eventMask(int value)
public bool get_layerCullSpherical()
public void set_layerCullSpherical(bool value)
public CameraType get_cameraType()
public void set_cameraType(CameraType value)
public bool get_useOcclusionCulling()
public void set_useOcclusionCulling(bool value)
public Matrix4x4 get_cullingMatrix()
public void set_cullingMatrix(Matrix4x4 value)
public void ResetCullingMatrix()
public Color get_backgroundColor()
public void set_backgroundColor(Color value)
public CameraClearFlags get_clearFlags()
public void set_clearFlags(CameraClearFlags value)
public DepthTextureMode get_depthTextureMode()
public void set_depthTextureMode(DepthTextureMode value)
public bool get_clearStencilAfterLightingPass()
public void set_clearStencilAfterLightingPass(bool value)
public void SetReplacementShader(Shader shader, string replacementTag)
public void ResetReplacementShader()
public Rect get_rect()
public void set_rect(Rect value)
public Rect get_pixelRect()
public void set_pixelRect(Rect value)
public int get_pixelWidth()
public int get_pixelHeight()
public int get_scaledPixelWidth()
public int get_scaledPixelHeight()
public RenderTexture get_targetTexture()
public void set_targetTexture(RenderTexture value)
public RenderTexture get_activeTexture()
public Matrix4x4 get_cameraToWorldMatrix()
public Matrix4x4 get_worldToCameraMatrix()
public void set_worldToCameraMatrix(Matrix4x4 value)
public Matrix4x4 get_projectionMatrix()
public void set_projectionMatrix(Matrix4x4 value)
public Matrix4x4 get_nonJitteredProjectionMatrix()
public void set_nonJitteredProjectionMatrix(Matrix4x4 value)
public bool get_useJitteredProjectionMatrixForTransparentRendering()
public void set_useJitteredProjectionMatrixForTransparentRendering(bool value)
public Matrix4x4 get_previousViewProjectionMatrix()
public void ResetWorldToCameraMatrix()
public void ResetProjectionMatrix()
public Matrix4x4 CalculateObliqueMatrix(Vector4 clipPlane)
public Vector3 WorldToScreenPoint(Vector3 position)
public Vector3 WorldToViewportPoint(Vector3 position)
public Vector3 ViewportToWorldPoint(Vector3 position)
public Vector3 ScreenToWorldPoint(Vector3 position)
public Vector3 ScreenToViewportPoint(Vector3 position)
public Vector3 ViewportToScreenPoint(Vector3 position)
private Ray ViewportPointToRay(Vector2 pos)
public Ray ViewportPointToRay(Vector3 pos)
private Ray ScreenPointToRay(Vector2 pos)
public Ray ScreenPointToRay(Vector3 pos)
internal GameObject RaycastTry(Ray ray, float distance, int layerMask)
internal GameObject RaycastTry2D(Ray ray, float distance, int layerMask)
private void CalculateFrustumCornersInternal(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
public void CalculateFrustumCorners(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
public Camera get_main()
public Camera get_current()
public bool get_stereoEnabled()
public float get_stereoSeparation()
public void set_stereoSeparation(float value)
public float get_stereoConvergence()
public void set_stereoConvergence(float value)
public bool get_areVRStereoViewMatricesWithinSingleCullTolerance()
public StereoTargetEyeMask get_stereoTargetEye()
public void set_stereoTargetEye(StereoTargetEyeMask value)
public Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye eye)
public Matrix4x4 GetStereoViewMatrix(StereoscopicEye eye)
public void CopyStereoDeviceProjectionMatrixToNonJittered(StereoscopicEye eye)
public Matrix4x4 GetStereoProjectionMatrix(StereoscopicEye eye)
public void SetStereoProjectionMatrix(StereoscopicEye eye, Matrix4x4 matrix)
public void ResetStereoProjectionMatrices()
public void SetStereoViewMatrix(StereoscopicEye eye, Matrix4x4 matrix)
public void ResetStereoViewMatrices()
public int get_commandBufferCount()
public void RemoveCommandBuffers(CameraEvent evt)
public void RemoveAllCommandBuffers()
private bool RenderToCubemapImpl(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye)
public bool RenderToCubemap(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye)
private void AddCommandBufferImpl(CameraEvent evt, CommandBuffer buffer)
private void AddCommandBufferAsyncImpl(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
private void RemoveCommandBufferImpl(CameraEvent evt, CommandBuffer buffer)
public void AddCommandBuffer(CameraEvent evt, CommandBuffer buffer)
public void AddCommandBufferAsync(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
public void RemoveCommandBuffer(CameraEvent evt, CommandBuffer buffer)
private void FireOnPreCull(Camera cam)
private void FireOnPreRender(Camera cam)
private void FireOnPostRender(Camera cam)
private void get_transparencySortAxis_Injected(Vector3& ret)
private void set_transparencySortAxis_Injected(Vector3& value)
private void get_velocity_Injected(Vector3& ret)
private void get_cullingMatrix_Injected(Matrix4x4& ret)
private void set_cullingMatrix_Injected(Matrix4x4& value)
private void get_backgroundColor_Injected(Color& ret)
private void set_backgroundColor_Injected(Color& value)
private void get_rect_Injected(Rect& ret)
private void set_rect_Injected(Rect& value)
private void get_pixelRect_Injected(Rect& ret)
private void set_pixelRect_Injected(Rect& value)
private void get_cameraToWorldMatrix_Injected(Matrix4x4& ret)
private void get_worldToCameraMatrix_Injected(Matrix4x4& ret)
private void set_worldToCameraMatrix_Injected(Matrix4x4& value)
private void get_projectionMatrix_Injected(Matrix4x4& ret)
private void set_projectionMatrix_Injected(Matrix4x4& value)
private void get_nonJitteredProjectionMatrix_Injected(Matrix4x4& ret)
private void set_nonJitteredProjectionMatrix_Injected(Matrix4x4& value)
private void get_previousViewProjectionMatrix_Injected(Matrix4x4& ret)
private void CalculateObliqueMatrix_Injected(Vector4& clipPlane, Matrix4x4& ret)
private void WorldToScreenPoint_Injected(Vector3& position, Vector3& ret)
private void WorldToViewportPoint_Injected(Vector3& position, Vector3& ret)
private void ViewportToWorldPoint_Injected(Vector3& position, Vector3& ret)
private void ScreenToWorldPoint_Injected(Vector3& position, Vector3& ret)
private void ScreenToViewportPoint_Injected(Vector3& position, Vector3& ret)
private void ViewportToScreenPoint_Injected(Vector3& position, Vector3& ret)
private void ViewportPointToRay_Injected(Vector2& pos, Ray& ret)
private void ScreenPointToRay_Injected(Vector2& pos, Ray& ret)
private GameObject RaycastTry_Injected(Ray& ray, float distance, int layerMask)
private GameObject RaycastTry2D_Injected(Ray& ray, float distance, int layerMask)
private void CalculateFrustumCornersInternal_Injected(Rect& viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
private void GetStereoNonJitteredProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void GetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void GetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void SetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix)
private void SetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix)
}
public UnityEngine.CameraClearFlags : Enum {
public int value__
public CameraClearFlags Skybox
public CameraClearFlags Color
public CameraClearFlags SolidColor
public CameraClearFlags Depth
public CameraClearFlags Nothing
}
public UnityEngine.CameraType : Enum {
public int value__
public CameraType Game
public CameraType SceneView
public CameraType Preview
public CameraType VR
public CameraType Reflection
}
internal UnityEngine.CastHelper`1 : ValueType {
public T t
public IntPtr onePointerFurtherThanT
}
internal UnityEngine.ClassLibraryInitializer : object {
private void Init()
}
public UnityEngine.Color : ValueType {
public float r
public float g
public float b
public float a
public Color red
public Color green
public Color blue
public Color white
public Color black
public Color yellow
public Color cyan
public Color magenta
public Color gray
public Color grey
public Color clear
public float grayscale
public Color linear
public Color gamma
public float maxColorComponent
public float Item
public void .ctor(float r, float g, float b, float a)
public void .ctor(float r, float g, float b)
public string ToString()
public string ToString(string format)
public int GetHashCode()
public bool Equals(object other)
public Color op_Addition(Color a, Color b)
public Color op_Subtraction(Color a, Color b)
public Color op_Multiply(Color a, Color b)
public Color op_Multiply(Color a, float b)
public Color op_Multiply(float b, Color a)
public Color op_Division(Color a, float b)
public bool op_Equality(Color lhs, Color rhs)
public bool op_Inequality(Color lhs, Color rhs)
public Color Lerp(Color a, Color b, float t)
public Color LerpUnclamped(Color a, Color b, float t)
internal Color RGBMultiplied(float multiplier)
internal Color AlphaMultiplied(float multiplier)
internal Color RGBMultiplied(Color multiplier)
public Color get_red()
public Color get_green()
public Color get_blue()
public Color get_white()
public Color get_black()
public Color get_yellow()
public Color get_cyan()
public Color get_magenta()
public Color get_gray()
public Color get_grey()
public Color get_clear()
public float get_grayscale()
public Color get_linear()
public Color get_gamma()
public float get_maxColorComponent()
public Vector4 op_Implicit(Color c)
public Color op_Implicit(Vector4 v)
public float get_Item(int index)
public void set_Item(int index, float value)
public void RGBToHSV(Color rgbColor, Single& H, Single& S, Single& V)
private void RGBToHSVHelper(float offset, float dominantcolor, float colorone, float colortwo, Single& H, Single& S, Single& V)
public Color HSVToRGB(float H, float S, float V)
public Color HSVToRGB(float H, float S, float V, bool hdr)
}
public UnityEngine.Color32 : ValueType {
private int rgba
public byte r
public byte g
public byte b
public byte a
public void .ctor(byte r, byte g, byte b, byte a)
public Color32 op_Implicit(Color c)
public Color op_Implicit(Color32 c)
public Color32 Lerp(Color32 a, Color32 b, float t)
public Color32 LerpUnclamped(Color32 a, Color32 b, float t)
public string ToString()
public string ToString(string format)
}
public UnityEngine.ColorGamut : Enum {
public int value__
public ColorGamut sRGB
public ColorGamut Rec709
public ColorGamut Rec2020
public ColorGamut DisplayP3
public ColorGamut HDR10
public ColorGamut DolbyHDR
}
public UnityEngine.ColorSpace : Enum {
public int value__
public ColorSpace Uninitialized
public ColorSpace Gamma
public ColorSpace Linear
}
public UnityEngine.ColorUsageAttribute : PropertyAttribute {
public bool showAlpha
public bool hdr
public float minBrightness
public float maxBrightness
public float minExposureValue
public float maxExposureValue
public void .ctor(bool showAlpha)
public void .ctor(bool showAlpha, bool hdr)
public void .ctor(bool showAlpha, bool hdr, float minBrightness, float maxBrightness, float minExposureValue, float maxExposureValue)
}
public UnityEngine.ColorUtility : object {
internal bool DoTryParseHtmlColor(string htmlString, Color32& color)
public bool TryParseHtmlString(string htmlString, Color& color)
public string ToHtmlStringRGB(Color color)
public string ToHtmlStringRGBA(Color color)
}
public UnityEngine.CombineInstance : ValueType {
private int m_MeshInstanceID
private int m_SubMeshIndex
private Matrix4x4 m_Transform
private Vector4 m_LightmapScaleOffset
private Vector4 m_RealtimeLightmapScaleOffset
public Mesh mesh
public int subMeshIndex
public Matrix4x4 transform
public Vector4 lightmapScaleOffset
public Vector4 realtimeLightmapScaleOffset
public Mesh get_mesh()
public void set_mesh(Mesh value)
public int get_subMeshIndex()
public void set_subMeshIndex(int value)
public Matrix4x4 get_transform()
public void set_transform(Matrix4x4 value)
public Vector4 get_lightmapScaleOffset()
public void set_lightmapScaleOffset(Vector4 value)
public Vector4 get_realtimeLightmapScaleOffset()
public void set_realtimeLightmapScaleOffset(Vector4 value)
}
public UnityEngine.Compass : object {
public float magneticHeading
public float trueHeading
public float headingAccuracy
public Vector3 rawVector
public double timestamp
public bool enabled
public float get_magneticHeading()
public float get_trueHeading()
public float get_headingAccuracy()
public Vector3 get_rawVector()
private void INTERNAL_get_rawVector(Vector3& value)
public double get_timestamp()
public bool get_enabled()
public void set_enabled(bool value)
}
public UnityEngine.Component : Object {
public Transform transform
public GameObject gameObject
public string tag
public Transform get_transform()
public GameObject get_gameObject()
public Component GetComponent(Type type)
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue)
public T GetComponent()
public Component GetComponent(string type)
public Component GetComponentInChildren(Type t, bool includeInactive)
public Component GetComponentInChildren(Type t)
public T GetComponentInChildren(bool includeInactive)
public T GetComponentInChildren()
public Component[] GetComponentsInChildren(Type t, bool includeInactive)
public Component[] GetComponentsInChildren(Type t)
public T[] GetComponentsInChildren(bool includeInactive)
public void GetComponentsInChildren(bool includeInactive, List`1<T> result)
public T[] GetComponentsInChildren()
public void GetComponentsInChildren(List`1<T> results)
public Component GetComponentInParent(Type t)
public T GetComponentInParent()
public Component[] GetComponentsInParent(Type t, bool includeInactive)
public Component[] GetComponentsInParent(Type t)
public T[] GetComponentsInParent(bool includeInactive)
public void GetComponentsInParent(bool includeInactive, List`1<T> results)
public T[] GetComponentsInParent()
public Component[] GetComponents(Type type)
private void GetComponentsForListInternal(Type searchType, object resultList)
public void GetComponents(Type type, List`1<Component> results)
public void GetComponents(List`1<T> results)
public string get_tag()
public void set_tag(string value)
public T[] GetComponents()
public bool CompareTag(string tag)
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options)
public void SendMessageUpwards(string methodName, object value)
public void SendMessageUpwards(string methodName)
public void SendMessageUpwards(string methodName, SendMessageOptions options)
public void SendMessage(string methodName, object value)
public void SendMessage(string methodName)
public void SendMessage(string methodName, object value, SendMessageOptions options)
public void SendMessage(string methodName, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter)
public void BroadcastMessage(string methodName)
public void BroadcastMessage(string methodName, SendMessageOptions options)
}
public UnityEngine.ComputeBuffer : object {
internal IntPtr m_Ptr
public int count
public int stride
public void .ctor(int count, int stride)
public void .ctor(int count, int stride, ComputeBufferType type)
internal void .ctor(int count, int stride, ComputeBufferType type, int stackDepth)
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
private void InitBuffer(ComputeBuffer buf, int count, int stride, ComputeBufferType type)
private void DestroyBuffer(ComputeBuffer buf)
public void Release()
public bool IsValid()
public int get_count()
public int get_stride()
public void SetData(Array data)
public void SetData(List`1<T> data)
public void SetData(NativeArray`1<T> data)
public void SetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
public void SetData(List`1<T> data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
public void SetData(NativeArray`1<T> data, int nativeBufferStartIndex, int computeBufferStartIndex, int count)
private void InternalSetNativeData(IntPtr data, int nativeBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
private void InternalSetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
public void GetData(Array data)
public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
private void InternalGetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
public void SetCounterValue(UInt32 counterValue)
public void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes)
public IntPtr GetNativeBufferPtr()
private void INTERNAL_CALL_GetNativeBufferPtr(ComputeBuffer self, IntPtr& value)
}
public UnityEngine.ComputeBufferType : Enum {
public int value__
public ComputeBufferType Default
public ComputeBufferType Raw
public ComputeBufferType Append
public ComputeBufferType Counter
public ComputeBufferType DrawIndirect
public ComputeBufferType IndirectArguments
public ComputeBufferType GPUMemory
}
public UnityEngine.ComputeShader : Object {
public int FindKernel(string name)
public bool HasKernel(string name)
public void GetKernelThreadGroupSizes(int kernelIndex, UInt32& x, UInt32& y, UInt32& z)
public void SetFloat(string name, float val)
public void SetFloat(int nameID, float val)
public void SetInt(string name, int val)
public void SetInt(int nameID, int val)
public void SetBool(string name, bool val)
public void SetBool(int nameID, bool val)
public void SetVector(string name, Vector4 val)
public void SetVector(int nameID, Vector4 val)
private void INTERNAL_CALL_SetVector(ComputeShader self, int nameID, Vector4& val)
public void SetVectorArray(string name, Vector4[] values)
public void SetVectorArray(int nameID, Vector4[] values)
public void SetMatrix(string name, Matrix4x4 val)
public void SetMatrix(int nameID, Matrix4x4 val)
private void INTERNAL_CALL_SetMatrix(ComputeShader self, int nameID, Matrix4x4& val)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetMatrixArray(int nameID, Matrix4x4[] values)
public void SetFloats(string name, Single[] values)
public void SetFloats(int nameID, Single[] values)
private void Internal_SetFloats(int nameID, Single[] values)
public void SetInts(string name, Int32[] values)
public void SetInts(int nameID, Int32[] values)
private void Internal_SetInts(int nameID, Int32[] values)
public void SetTexture(int kernelIndex, string name, Texture texture)
public void SetTexture(int kernelIndex, int nameID, Texture texture)
public void SetTextureFromGlobal(int kernelIndex, string name, string globalTextureName)
public void SetTextureFromGlobal(int kernelIndex, int nameID, int globalTextureNameID)
public void SetBuffer(int kernelIndex, string name, ComputeBuffer buffer)
public void SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer)
public void Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer)
public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset)
private void Internal_DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset)
}
public UnityEngine.ConnectionTesterStatus : Enum {
public int value__
public ConnectionTesterStatus Error
public ConnectionTesterStatus Undetermined
public ConnectionTesterStatus PrivateIPNoNATPunchthrough
public ConnectionTesterStatus PrivateIPHasNATPunchThrough
public ConnectionTesterStatus PublicIPIsConnectable
public ConnectionTesterStatus PublicIPPortBlocked
public ConnectionTesterStatus PublicIPNoServerStarted
public ConnectionTesterStatus LimitedNATPunchthroughPortRestricted
public ConnectionTesterStatus LimitedNATPunchthroughSymmetric
public ConnectionTesterStatus NATpunchthroughFullCone
public ConnectionTesterStatus NATpunchthroughAddressRestrictedCone
}
public UnityEngine.ContextMenu : Attribute {
public string menuItem
public bool validate
public int priority
public void .ctor(string itemName)
public void .ctor(string itemName, bool isValidateFunction)
public void .ctor(string itemName, bool isValidateFunction, int priority)
}
public UnityEngine.ContextMenuItemAttribute : PropertyAttribute {
public string name
public string function
public void .ctor(string name, string function)
}
public UnityEngine.Coroutine : YieldInstruction {
internal IntPtr m_Ptr
protected void Finalize()
private void ReleaseCoroutine(IntPtr ptr)
}
public UnityEngine.CrashReport : object {
private List`1<CrashReport> internalReports
private object reportsLock
private string id
public DateTime time
public string text
private Comparison`1<CrashReport> <>f__mg$cache0
public CrashReport[] reports
public CrashReport lastReport
private void .ctor(string id, DateTime time, string text)
private int Compare(CrashReport c1, CrashReport c2)
private void PopulateReports()
public CrashReport[] get_reports()
public CrashReport get_lastReport()
public void RemoveAll()
public void Remove()
private String[] GetReports()
private string GetReportData(string id, Double& secondsSinceUnixEpoch)
private bool RemoveReport(string id)
}
public UnityEngine.CreateAssetMenuAttribute : Attribute {
private string <menuName>k__BackingField
private string <fileName>k__BackingField
private int <order>k__BackingField
public string menuName
public string fileName
public int order
public string get_menuName()
public void set_menuName(string value)
public string get_fileName()
public void set_fileName(string value)
public int get_order()
public void set_order(int value)
}
public UnityEngine.Cubemap : Texture {
public int mipmapCount
public TextureFormat format
internal void .ctor(int ext, TextureFormat format, bool mipmap, IntPtr nativeTex)
public void .ctor(int ext, TextureFormat format, bool mipmap)
public Color[] GetPixels(CubemapFace face, int miplevel)
public Color[] GetPixels(CubemapFace face)
public void SetPixels(Color[] colors, CubemapFace face, int miplevel)
public void SetPixels(Color[] colors, CubemapFace face)
public int get_mipmapCount()
public TextureFormat get_format()
private bool Internal_CreateImpl(Cubemap mono, int ext, TextureFormat format, bool mipmap, IntPtr nativeTex)
private void Internal_Create(Cubemap mono, int ext, TextureFormat format, bool mipmap, IntPtr nativeTex)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
private bool IsReadable()
private void SetPixelImpl(int image, int x, int y, Color color)
private Color GetPixelImpl(int image, int x, int y)
public void SmoothEdges(int smoothRegionWidthInPixels)
public void SmoothEdges()
public Cubemap CreateExternalTexture(int ext, TextureFormat format, bool mipmap, IntPtr nativeTex)
public void SetPixel(CubemapFace face, int x, int y, Color color)
public Color GetPixel(CubemapFace face, int x, int y)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
private void SetPixelImpl_Injected(int image, int x, int y, Color& color)
private void GetPixelImpl_Injected(int image, int x, int y, Color& ret)
}
public UnityEngine.CubemapArray : Texture {
public int cubemapCount
public TextureFormat format
public void .ctor(int faceSize, int cubemapCount, TextureFormat format, bool mipmap, bool linear)
public void .ctor(int faceSize, int cubemapCount, TextureFormat format, bool mipmap)
public void SetPixels(Color[] colors, CubemapFace face, int arrayElement, int miplevel)
public void SetPixels(Color[] colors, CubemapFace face, int arrayElement)
public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement, int miplevel)
public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement)
public Color[] GetPixels(CubemapFace face, int arrayElement, int miplevel)
public Color[] GetPixels(CubemapFace face, int arrayElement)
public Color32[] GetPixels32(CubemapFace face, int arrayElement, int miplevel)
public Color32[] GetPixels32(CubemapFace face, int arrayElement)
public int get_cubemapCount()
public TextureFormat get_format()
private bool IsReadable()
private bool Internal_CreateImpl(CubemapArray mono, int ext, int count, TextureFormat format, bool mipmap, bool linear)
private void Internal_Create(CubemapArray mono, int ext, int count, TextureFormat format, bool mipmap, bool linear)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
}
public UnityEngine.CubemapFace : Enum {
public int value__
public CubemapFace Unknown
public CubemapFace PositiveX
public CubemapFace NegativeX
public CubemapFace PositiveY
public CubemapFace NegativeY
public CubemapFace PositiveZ
public CubemapFace NegativeZ
}
public UnityEngine.CullingGroup : object {
internal IntPtr m_Ptr
private StateChanged m_OnStateChanged
public StateChanged onStateChanged
public bool enabled
public Camera targetCamera
protected void Finalize()
public void Dispose()
public StateChanged get_onStateChanged()
public void set_onStateChanged(StateChanged value)
public bool get_enabled()
public void set_enabled(bool value)
public Camera get_targetCamera()
public void set_targetCamera(Camera value)
public void SetBoundingSpheres(BoundingSphere[] array)
public void SetBoundingSphereCount(int count)
public void EraseSwapBack(int index)
public void EraseSwapBack(int index, T[] myArray, Int32& size)
public int QueryIndices(bool visible, Int32[] result, int firstIndex)
public int QueryIndices(int distanceIndex, Int32[] result, int firstIndex)
public int QueryIndices(bool visible, int distanceIndex, Int32[] result, int firstIndex)
private int QueryIndices(bool visible, int distanceIndex, CullingQueryOptions options, Int32[] result, int firstIndex)
public bool IsVisible(int index)
public int GetDistance(int index)
public void SetBoundingDistances(Single[] distances)
public void SetDistanceReferencePoint(Vector3 point)
private void INTERNAL_CALL_SetDistanceReferencePoint(CullingGroup self, Vector3& point)
public void SetDistanceReferencePoint(Transform transform)
private void SendEvents(CullingGroup cullingGroup, IntPtr eventsPtr, int count)
private void Init()
private void FinalizerFailure()
}
public UnityEngine.CullingGroupEvent : ValueType {
private int m_Index
private byte m_PrevState
private byte m_ThisState
private byte kIsVisibleMask
private byte kDistanceMask
public int index
public bool isVisible
public bool wasVisible
public bool hasBecomeVisible
public bool hasBecomeInvisible
public int currentDistance
public int previousDistance
public int get_index()
public bool get_isVisible()
public bool get_wasVisible()
public bool get_hasBecomeVisible()
public bool get_hasBecomeInvisible()
public int get_currentDistance()
public int get_previousDistance()
}
internal UnityEngine.CullingQueryOptions : Enum {
public int value__
public CullingQueryOptions Normal
public CullingQueryOptions IgnoreVisibility
public CullingQueryOptions IgnoreDistance
}
public UnityEngine.Cursor : object {
public bool visible
public CursorLockMode lockState
private void SetCursor(Texture2D texture, CursorMode cursorMode)
public void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode)
private void INTERNAL_CALL_SetCursor(Texture2D texture, Vector2& hotspot, CursorMode cursorMode)
public bool get_visible()
public void set_visible(bool value)
public CursorLockMode get_lockState()
public void set_lockState(CursorLockMode value)
}
public UnityEngine.CursorLockMode : Enum {
public int value__
public CursorLockMode None
public CursorLockMode Locked
public CursorLockMode Confined
}
public UnityEngine.CursorMode : Enum {
public int value__
public CursorMode Auto
public CursorMode ForceSoftware
}
public UnityEngine.CustomRenderTexture : RenderTexture {
public Material material
public Material initializationMaterial
public Texture initializationTexture
public CustomRenderTextureInitializationSource initializationSource
public Color initializationColor
public CustomRenderTextureUpdateMode updateMode
public CustomRenderTextureUpdateMode initializationMode
public CustomRenderTextureUpdateZoneSpace updateZoneSpace
public int shaderPass
public UInt32 cubemapFaceMask
public bool doubleBuffered
public bool wrapUpdateZones
public void .ctor(int width, int height, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void .ctor(int width, int height, RenderTextureFormat format)
public void .ctor(int width, int height)
private void Internal_CreateCustomRenderTexture(CustomRenderTexture rt, RenderTextureReadWrite readWrite)
public void Update(int count)
public void Update()
public void Initialize()
public void ClearUpdateZones()
public Material get_material()
public void set_material(Material value)
public Material get_initializationMaterial()
public void set_initializationMaterial(Material value)
public Texture get_initializationTexture()
public void set_initializationTexture(Texture value)
private bool IsCubemapFaceEnabled(CubemapFace face)
private void EnableCubemapFace(CubemapFace face, bool value)
internal void GetUpdateZonesInternal(object updateZones)
public void GetUpdateZones(List`1<CustomRenderTextureUpdateZone> updateZones)
private void SetUpdateZonesInternal(CustomRenderTextureUpdateZone[] updateZones)
public void SetUpdateZones(CustomRenderTextureUpdateZone[] updateZones)
public CustomRenderTextureInitializationSource get_initializationSource()
public void set_initializationSource(CustomRenderTextureInitializationSource value)
public Color get_initializationColor()
public void set_initializationColor(Color value)
private void INTERNAL_get_initializationColor(Color& value)
private void INTERNAL_set_initializationColor(Color& value)
public CustomRenderTextureUpdateMode get_updateMode()
public void set_updateMode(CustomRenderTextureUpdateMode value)
public CustomRenderTextureUpdateMode get_initializationMode()
public void set_initializationMode(CustomRenderTextureUpdateMode value)
public CustomRenderTextureUpdateZoneSpace get_updateZoneSpace()
public void set_updateZoneSpace(CustomRenderTextureUpdateZoneSpace value)
public int get_shaderPass()
public void set_shaderPass(int value)
public UInt32 get_cubemapFaceMask()
public void set_cubemapFaceMask(UInt32 value)
public bool get_doubleBuffered()
public void set_doubleBuffered(bool value)
public bool get_wrapUpdateZones()
public void set_wrapUpdateZones(bool value)
}
public UnityEngine.CustomRenderTextureInitializationSource : Enum {
public int value__
public CustomRenderTextureInitializationSource TextureAndColor
public CustomRenderTextureInitializationSource Material
}
public UnityEngine.CustomRenderTextureUpdateMode : Enum {
public int value__
public CustomRenderTextureUpdateMode OnLoad
public CustomRenderTextureUpdateMode Realtime
public CustomRenderTextureUpdateMode OnDemand
}
public UnityEngine.CustomRenderTextureUpdateZone : ValueType {
public Vector3 updateZoneCenter
public Vector3 updateZoneSize
public float rotation
public int passIndex
public bool needSwap
}
public UnityEngine.CustomRenderTextureUpdateZoneSpace : Enum {
public int value__
public CustomRenderTextureUpdateZoneSpace Normalized
public CustomRenderTextureUpdateZoneSpace Pixel
}
public UnityEngine.CustomYieldInstruction : object {
public bool keepWaiting
public object Current
public bool get_keepWaiting()
public object get_Current()
public bool MoveNext()
public void Reset()
}
public UnityEngine.Debug : object {
internal ILogger s_Logger
public ILogger unityLogger
public bool developerConsoleVisible
public bool isDebugBuild
public ILogger logger
public ILogger get_unityLogger()
public void DrawLine(Vector3 start, Vector3 end, Color color, float duration)
public void DrawLine(Vector3 start, Vector3 end, Color color)
public void DrawLine(Vector3 start, Vector3 end)
public void DrawLine(Vector3 start, Vector3 end, Color color, float duration, bool depthTest)
public void DrawRay(Vector3 start, Vector3 dir, Color color, float duration)
public void DrawRay(Vector3 start, Vector3 dir, Color color)
public void DrawRay(Vector3 start, Vector3 dir)
public void DrawRay(Vector3 start, Vector3 dir, Color color, float duration, bool depthTest)
public void Break()
public void DebugBreak()
public void Log(object message)
public void Log(object message, Object context)
public void LogFormat(string format, Object[] args)
public void LogFormat(Object context, string format, Object[] args)
public void LogError(object message)
public void LogError(object message, Object context)
public void LogErrorFormat(string format, Object[] args)
public void LogErrorFormat(Object context, string format, Object[] args)
public void ClearDeveloperConsole()
public bool get_developerConsoleVisible()
public void set_developerConsoleVisible(bool value)
public void LogException(Exception exception)
public void LogException(Exception exception, Object context)
public void LogWarning(object message)
public void LogWarning(object message, Object context)
public void LogWarningFormat(string format, Object[] args)
public void LogWarningFormat(Object context, string format, Object[] args)
public void Assert(bool condition)
public void Assert(bool condition, Object context)
public void Assert(bool condition, object message)
public void Assert(bool condition, string message)
public void Assert(bool condition, object message, Object context)
public void Assert(bool condition, string message, Object context)
public void AssertFormat(bool condition, string format, Object[] args)
public void AssertFormat(bool condition, Object context, string format, Object[] args)
public void LogAssertion(object message)
public void LogAssertion(object message, Object context)
public void LogAssertionFormat(string format, Object[] args)
public void LogAssertionFormat(Object context, string format, Object[] args)
public bool get_isDebugBuild()
internal void OpenConsoleFile()
internal void GetDiagnosticSwitches(List`1<DiagnosticSwitch> results)
internal object GetDiagnosticSwitch(string name)
internal void SetDiagnosticSwitch(string name, object value, bool setPersistent)
public void Assert(bool condition, string format, Object[] args)
public ILogger get_logger()
private void DrawLine_Injected(Vector3& start, Vector3& end, Color& color, float duration, bool depthTest)
}
internal UnityEngine.DebugLogHandler : object {
internal void Internal_Log(LogType level, string msg, Object obj)
internal void Internal_LogException(Exception exception, Object obj)
public void LogFormat(LogType logType, Object context, string format, Object[] args)
public void LogException(Exception exception, Object context)
}
public UnityEngine.DefaultExecutionOrder : Attribute {
private int <order>k__BackingField
public int order
public void .ctor(int order)
public int get_order()
private void set_order(int value)
}
public UnityEngine.DepthTextureMode : Enum {
public int value__
public DepthTextureMode None
public DepthTextureMode Depth
public DepthTextureMode DepthNormals
public DepthTextureMode MotionVectors
}
public UnityEngine.DeviceOrientation : Enum {
public int value__
public DeviceOrientation Unknown
public DeviceOrientation Portrait
public DeviceOrientation PortraitUpsideDown
public DeviceOrientation LandscapeLeft
public DeviceOrientation LandscapeRight
public DeviceOrientation FaceUp
public DeviceOrientation FaceDown
}
public UnityEngine.DeviceType : Enum {
public int value__
public DeviceType Unknown
public DeviceType Handheld
public DeviceType Console
public DeviceType Desktop
}
public UnityEngine.Diagnostics.PlayerConnection : object {
public bool connected
public bool get_connected()
public void SendFile(string remoteFilePath, Byte[] data)
}
internal UnityEngine.DiagnosticSwitch : ValueType {
public string name
public string description
public DiagnosticSwitchFlags flags
public object value
public object minValue
public object maxValue
public object persistentValue
public EnumInfo enumInfo
private void AppendDiagnosticSwitchToList(List`1<DiagnosticSwitch> list, string name, string description, DiagnosticSwitchFlags flags, object value, object minValue, object maxValue, object persistentValue, EnumInfo enumInfo)
}
internal UnityEngine.DiagnosticSwitchFlags : Enum {
public int value__
public DiagnosticSwitchFlags None
public DiagnosticSwitchFlags CanChangeAfterEngineStart
}
internal UnityEngine.DisableBatchingType : Enum {
public int value__
public DisableBatchingType False
public DisableBatchingType True
public DisableBatchingType WhenLODFading
}
public UnityEngine.Display : object {
internal IntPtr nativeDisplay
public Display[] displays
private Display _mainDisplay
private DisplaysUpdatedDelegate onDisplaysUpdated
public int renderingWidth
public int renderingHeight
public int systemWidth
public int systemHeight
public RenderBuffer colorBuffer
public RenderBuffer depthBuffer
public bool active
public Display main
internal void .ctor(IntPtr nativeDisplay)
public int get_renderingWidth()
public int get_renderingHeight()
public int get_systemWidth()
public int get_systemHeight()
public RenderBuffer get_colorBuffer()
public RenderBuffer get_depthBuffer()
public bool get_active()
public void Activate()
public void Activate(int width, int height, int refreshRate)
public void SetParams(int width, int height, int x, int y)
public void SetRenderingResolution(int w, int h)
public bool MultiDisplayLicense()
public Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates)
public Display get_main()
private void RecreateDisplayList(IntPtr[] nativeDisplay)
private void FireDisplaysUpdated()
public void add_onDisplaysUpdated(DisplaysUpdatedDelegate value)
public void remove_onDisplaysUpdated(DisplaysUpdatedDelegate value)
private void GetSystemExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h)
private void GetRenderingExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h)
private void GetRenderingBuffersImpl(IntPtr nativeDisplay, RenderBuffer& color, RenderBuffer& depth)
private void SetRenderingResolutionImpl(IntPtr nativeDisplay, int w, int h)
private void ActivateDisplayImpl(IntPtr nativeDisplay, int width, int height, int refreshRate)
private void SetParamsImpl(IntPtr nativeDisplay, int width, int height, int x, int y)
private int RelativeMouseAtImpl(int x, int y, Int32& rx, Int32& ry)
private bool GetActiveImp(IntPtr nativeDisplay)
}
internal UnityEngine.DrivenPropertyManager : object {
public void RegisterProperty(Object driver, Object target, string propertyPath)
public void UnregisterProperty(Object driver, Object target, string propertyPath)
public void UnregisterProperties(Object driver)
private void RegisterPropertyPartial(Object driver, Object target, string propertyPath)
private void UnregisterPropertyPartial(Object driver, Object target, string propertyPath)
}
public UnityEngine.DrivenRectTransformTracker : ValueType {
internal bool CanRecordModifications()
public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties)
public void Clear(bool revertValues)
public void Clear()
}
public UnityEngine.DrivenTransformProperties : Enum {
public int value__
public DrivenTransformProperties None
public DrivenTransformProperties All
public DrivenTransformProperties AnchoredPositionX
public DrivenTransformProperties AnchoredPositionY
public DrivenTransformProperties AnchoredPositionZ
public DrivenTransformProperties Rotation
public DrivenTransformProperties ScaleX
public DrivenTransformProperties ScaleY
public DrivenTransformProperties ScaleZ
public DrivenTransformProperties AnchorMinX
public DrivenTransformProperties AnchorMinY
public DrivenTransformProperties AnchorMaxX
public DrivenTransformProperties AnchorMaxY
public DrivenTransformProperties SizeDeltaX
public DrivenTransformProperties SizeDeltaY
public DrivenTransformProperties PivotX
public DrivenTransformProperties PivotY
public DrivenTransformProperties AnchoredPosition
public DrivenTransformProperties AnchoredPosition3D
public DrivenTransformProperties Scale
public DrivenTransformProperties AnchorMin
public DrivenTransformProperties AnchorMax
public DrivenTransformProperties Anchors
public DrivenTransformProperties SizeDelta
public DrivenTransformProperties Pivot
}
public UnityEngine.DynamicGI : object {
public float indirectScale
public float updateThreshold
public bool synchronousMode
public bool isConverged
public float get_indirectScale()
public void set_indirectScale(float value)
public float get_updateThreshold()
public void set_updateThreshold(float value)
public void SetEmissive(Renderer renderer, Color color)
private void INTERNAL_CALL_SetEmissive(Renderer renderer, Color& color)
public void SetEnvironmentData(Single[] input)
public void UpdateMaterials(Renderer renderer)
public void UpdateMaterials(Object renderer)
public void UpdateMaterials(Object renderer, int x, int y, int width, int height)
public void UpdateEnvironment()
public bool get_synchronousMode()
public void set_synchronousMode(bool value)
public bool get_isConverged()
}
internal UnityEngine.EnabledOrientation : Enum {
public int value__
public EnabledOrientation kAutorotateToPortrait
public EnabledOrientation kAutorotateToPortraitUpsideDown
public EnabledOrientation kAutorotateToLandscapeLeft
public EnabledOrientation kAutorotateToLandscapeRight
}
internal UnityEngine.EnumInfo : object {
public String[] names
public Int32[] values
public String[] annotations
public bool isFlags
internal EnumInfo CreateEnumInfoFromNativeEnum(String[] names, Int32[] values, String[] annotations, bool isFlags)
}
internal UnityEngine.Events.ArgumentCache : object {
private Object m_ObjectArgument
private string m_ObjectArgumentAssemblyTypeName
private int m_IntArgument
private float m_FloatArgument
private string m_StringArgument
private bool m_BoolArgument
public Object unityObjectArgument
public string unityObjectArgumentAssemblyTypeName
public int intArgument
public float floatArgument
public string stringArgument
public bool boolArgument
public Object get_unityObjectArgument()
public void set_unityObjectArgument(Object value)
public string get_unityObjectArgumentAssemblyTypeName()
public int get_intArgument()
public void set_intArgument(int value)
public float get_floatArgument()
public void set_floatArgument(float value)
public string get_stringArgument()
public void set_stringArgument(string value)
public bool get_boolArgument()
public void set_boolArgument(bool value)
private void TidyAssemblyTypeName()
public void OnBeforeSerialize()
public void OnAfterDeserialize()
}
internal UnityEngine.Events.BaseInvokableCall : object {
protected void .ctor(object target, MethodInfo function)
public void Invoke(Object[] args)
protected void ThrowOnInvalidArg(object arg)
protected bool AllowInvoke(Delegate delegate)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.CachedInvokableCall`1 : InvokableCall`1<T> {
private T m_Arg1
public void .ctor(Object target, MethodInfo theFunction, T argument)
public void Invoke(Object[] args)
public void Invoke(T arg0)
}
internal UnityEngine.Events.InvokableCall : BaseInvokableCall {
private UnityAction Delegate
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction action)
private void add_Delegate(UnityAction value)
private void remove_Delegate(UnityAction value)
public void Invoke(Object[] args)
public void Invoke()
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`1 : BaseInvokableCall {
private UnityAction`1<T1> Delegate
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`1<T1> action)
protected void add_Delegate(UnityAction`1<T1> value)
protected void remove_Delegate(UnityAction`1<T1> value)
public void Invoke(Object[] args)
public void Invoke(T1 args0)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`2 : BaseInvokableCall {
private UnityAction`2<T1, T2> Delegate
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`2<T1, T2> action)
protected void add_Delegate(UnityAction`2<T1, T2> value)
protected void remove_Delegate(UnityAction`2<T1, T2> value)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`3 : BaseInvokableCall {
private UnityAction`3<T1, T2, T3> Delegate
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`3<T1, T2, T3> action)
protected void add_Delegate(UnityAction`3<T1, T2, T3> value)
protected void remove_Delegate(UnityAction`3<T1, T2, T3> value)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1, T3 args2)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`4 : BaseInvokableCall {
private UnityAction`4<T1, T2, T3, T4> Delegate
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`4<T1, T2, T3, T4> action)
protected void add_Delegate(UnityAction`4<T1, T2, T3, T4> value)
protected void remove_Delegate(UnityAction`4<T1, T2, T3, T4> value)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1, T3 args2, T4 args3)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCallList : object {
private List`1<BaseInvokableCall> m_PersistentCalls
private List`1<BaseInvokableCall> m_RuntimeCalls
private List`1<BaseInvokableCall> m_ExecutingCalls
private bool m_NeedsUpdate
public int Count
public int get_Count()
public void AddPersistentInvokableCall(BaseInvokableCall call)
public void AddListener(BaseInvokableCall call)
public void RemoveListener(object targetObj, MethodInfo method)
public void Clear()
public void ClearPersistent()
public List`1<BaseInvokableCall> PrepareInvoke()
}
internal UnityEngine.Events.PersistentCall : object {
private Object m_Target
private string m_MethodName
private PersistentListenerMode m_Mode
private ArgumentCache m_Arguments
private UnityEventCallState m_CallState
public Object target
public string methodName
public PersistentListenerMode mode
public ArgumentCache arguments
public UnityEventCallState callState
public Object get_target()
public string get_methodName()
public PersistentListenerMode get_mode()
public void set_mode(PersistentListenerMode value)
public ArgumentCache get_arguments()
public UnityEventCallState get_callState()
public void set_callState(UnityEventCallState value)
public bool IsValid()
public BaseInvokableCall GetRuntimeCall(UnityEventBase theEvent)
private BaseInvokableCall GetObjectCall(Object target, MethodInfo method, ArgumentCache arguments)
public void RegisterPersistentListener(Object ttarget, string mmethodName)
public void UnregisterPersistentListener()
}
internal UnityEngine.Events.PersistentCallGroup : object {
private List`1<PersistentCall> m_Calls
public int Count
public int get_Count()
public PersistentCall GetListener(int index)
public IEnumerable`1<PersistentCall> GetListeners()
public void AddListener()
public void AddListener(PersistentCall call)
public void RemoveListener(int index)
public void Clear()
public void RegisterEventPersistentListener(int index, Object targetObj, string methodName)
public void RegisterVoidPersistentListener(int index, Object targetObj, string methodName)
public void RegisterObjectPersistentListener(int index, Object targetObj, Object argument, string methodName)
public void RegisterIntPersistentListener(int index, Object targetObj, int argument, string methodName)
public void RegisterFloatPersistentListener(int index, Object targetObj, float argument, string methodName)
public void RegisterStringPersistentListener(int index, Object targetObj, string argument, string methodName)
public void RegisterBoolPersistentListener(int index, Object targetObj, bool argument, string methodName)
public void UnregisterPersistentListener(int index)
public void RemoveListeners(Object target, string methodName)
public void Initialize(InvokableCallList invokableList, UnityEventBase unityEventBase)
}
public UnityEngine.Events.PersistentListenerMode : Enum {
public int value__
public PersistentListenerMode EventDefined
public PersistentListenerMode Void
public PersistentListenerMode Object
public PersistentListenerMode Int
public PersistentListenerMode Float
public PersistentListenerMode String
public PersistentListenerMode Bool
}
public UnityEngine.Events.UnityAction : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0)
public IAsyncResult BeginInvoke(T0 arg0, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityEvent : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction call)
public void RemoveListener(UnityAction call)
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction action)
public void Invoke()
}
public UnityEngine.Events.UnityEvent`1 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`1<T0> call)
public void RemoveListener(UnityAction`1<T0> call)
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`1<T0> action)
public void Invoke(T0 arg0)
}
public UnityEngine.Events.UnityEvent`2 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`2<T0, T1> call)
public void RemoveListener(UnityAction`2<T0, T1> call)
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`2<T0, T1> action)
public void Invoke(T0 arg0, T1 arg1)
}
public UnityEngine.Events.UnityEvent`3 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`3<T0, T1, T2> call)
public void RemoveListener(UnityAction`3<T0, T1, T2> call)
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`3<T0, T1, T2> action)
public void Invoke(T0 arg0, T1 arg1, T2 arg2)
}
public UnityEngine.Events.UnityEvent`4 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`4<T0, T1, T2, T3> call)
public void RemoveListener(UnityAction`4<T0, T1, T2, T3> call)
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`4<T0, T1, T2, T3> action)
public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
}
public UnityEngine.Events.UnityEventBase : object {
private InvokableCallList m_Calls
private PersistentCallGroup m_PersistentCalls
private string m_TypeName
private bool m_CallsDirty
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
protected MethodInfo FindMethod_Impl(string name, object targetObj)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
internal MethodInfo FindMethod(PersistentCall call)
internal MethodInfo FindMethod(string name, object listener, PersistentListenerMode mode, Type argumentType)
public int GetPersistentEventCount()
public Object GetPersistentTarget(int index)
public string GetPersistentMethodName(int index)
private void DirtyPersistentCalls()
private void RebuildPersistentCallsIfNeeded()
public void SetPersistentListenerState(int index, UnityEventCallState state)
protected void AddListener(object targetObj, MethodInfo method)
internal void AddCall(BaseInvokableCall call)
protected void RemoveListener(object targetObj, MethodInfo method)
public void RemoveAllListeners()
internal List`1<BaseInvokableCall> PrepareInvoke()
protected void Invoke(Object[] parameters)
public string ToString()
public MethodInfo GetValidMethodInfo(object obj, string functionName, Type[] argumentTypes)
}
public UnityEngine.Events.UnityEventCallState : Enum {
public int value__
public UnityEventCallState Off
public UnityEventCallState EditorAndRuntime
public UnityEventCallState RuntimeOnly
}
public UnityEngine.Experimental.GlobalIllumination.DirectionalLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 direction
public LinearColor color
public LinearColor indirectColor
public float penumbraWidthRadian
}
public UnityEngine.Experimental.GlobalIllumination.FalloffType : Enum {
public byte value__
public FalloffType InverseSquared
public FalloffType InverseSquaredNoRangeAttenuation
public FalloffType Linear
public FalloffType Legacy
public FalloffType Undefined
}
public UnityEngine.Experimental.GlobalIllumination.LightDataGI : ValueType {
public int instanceID
public LinearColor color
public LinearColor indirectColor
public Quaternion orientation
public Vector3 position
public float range
public float coneAngle
public float innerConeAngle
public float shape0
public float shape1
public LightType type
public LightMode mode
public byte shadow
public FalloffType falloff
public void Init(DirectionalLight& light)
public void Init(PointLight& light)
public void Init(SpotLight& light)
public void Init(RectangleLight& light)
public void InitNoBake(int lightInstanceID)
}
public UnityEngine.Experimental.GlobalIllumination.LightmapperUtils : object {
public LightMode Extract(LightmapBakeType baketype)
public LinearColor ExtractIndirect(Light l)
public float ExtractInnerCone(Light l)
public void Extract(Light l, DirectionalLight& dir)
public void Extract(Light l, PointLight& point)
public void Extract(Light l, SpotLight& spot)
public void Extract(Light l, RectangleLight& rect)
}
public UnityEngine.Experimental.GlobalIllumination.Lightmapping : object {
private RequestLightsDelegate s_DefaultDelegate
private RequestLightsDelegate s_RequestLightsDelegate
public void SetDelegate(RequestLightsDelegate del)
public void ResetDelegate()
internal void RequestLights(Light[] lights, IntPtr outLightsPtr, int outLightsCount)
private void <s_DefaultDelegate>m__0(Light[] requests, NativeArray`1<LightDataGI> lightsOutput)
}
public UnityEngine.Experimental.GlobalIllumination.LightMode : Enum {
public byte value__
public LightMode Realtime
public LightMode Mixed
public LightMode Baked
public LightMode Unknown
}
public UnityEngine.Experimental.GlobalIllumination.LightType : Enum {
public byte value__
public LightType Directional
public LightType Point
public LightType Spot
public LightType Rectangle
}
public UnityEngine.Experimental.GlobalIllumination.LinearColor : ValueType {
private float m_red
private float m_green
private float m_blue
private float m_intensity
public float red
public float green
public float blue
public float intensity
public float get_red()
public void set_red(float value)
public float get_green()
public void set_green(float value)
public float get_blue()
public void set_blue(float value)
public float get_intensity()
public void set_intensity(float value)
public LinearColor Convert(Color color, float intensity)
public LinearColor Black()
}
public UnityEngine.Experimental.GlobalIllumination.PointLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public LinearColor color
public LinearColor indirectColor
public float range
public float sphereRadius
public FalloffType falloff
}
public UnityEngine.Experimental.GlobalIllumination.RectangleLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float width
public float height
}
public UnityEngine.Experimental.GlobalIllumination.SpotLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float sphereRadius
public float coneAngle
public float innerConeAngle
public FalloffType falloff
}
public UnityEngine.Experimental.LowLevel.PlayerLoop : object {
public PlayerLoopSystem GetDefaultPlayerLoop()
public void SetPlayerLoop(PlayerLoopSystem loop)
private int PlayerLoopSystemToInternal(PlayerLoopSystem sys, List`1& internalSys)
private PlayerLoopSystem InternalToPlayerLoopSystem(PlayerLoopSystemInternal[] internalSys, Int32& offset)
private PlayerLoopSystemInternal[] GetDefaultPlayerLoopInternal()
private void SetPlayerLoopInternal(PlayerLoopSystemInternal[] loop)
}
public UnityEngine.Experimental.LowLevel.PlayerLoopSystem : ValueType {
public Type type
public PlayerLoopSystem[] subSystemList
public UpdateFunction updateDelegate
public IntPtr updateFunction
public IntPtr loopConditionFunction
}
internal UnityEngine.Experimental.LowLevel.PlayerLoopSystemInternal : ValueType {
public Type type
public UpdateFunction updateDelegate
public IntPtr updateFunction
public IntPtr loopConditionFunction
public int numSubSystems
}
public UnityEngine.Experimental.Playables.CameraPlayable : ValueType {
private PlayableHandle m_Handle
internal void .ctor(PlayableHandle handle)
public CameraPlayable Create(PlayableGraph graph, Camera camera)
private PlayableHandle CreateHandle(PlayableGraph graph, Camera camera)
public PlayableHandle GetHandle()
public Playable op_Implicit(CameraPlayable playable)
public CameraPlayable op_Explicit(Playable playable)
public bool Equals(CameraPlayable other)
public Camera GetCamera()
public void SetCamera(Camera value)
private Camera GetCameraInternal(PlayableHandle& hdl)
private void SetCameraInternal(PlayableHandle& hdl, Camera camera)
private bool InternalCreateCameraPlayable(PlayableGraph& graph, Camera camera, PlayableHandle& handle)
private bool ValidateType(PlayableHandle& hdl)
}
public UnityEngine.Experimental.Playables.MaterialEffectPlayable : ValueType {
private PlayableHandle m_Handle
internal void .ctor(PlayableHandle handle)
public MaterialEffectPlayable Create(PlayableGraph graph, Material material, int pass)
private PlayableHandle CreateHandle(PlayableGraph graph, Material material, int pass)
public PlayableHandle GetHandle()
public Playable op_Implicit(MaterialEffectPlayable playable)
public MaterialEffectPlayable op_Explicit(Playable playable)
public bool Equals(MaterialEffectPlayable other)
public Material GetMaterial()
public void SetMaterial(Material value)
public int GetPass()
public void SetPass(int value)
private Material GetMaterialInternal(PlayableHandle& hdl)
private void SetMaterialInternal(PlayableHandle& hdl, Material material)
private int GetPassInternal(PlayableHandle& hdl)
private void SetPassInternal(PlayableHandle& hdl, int pass)
private bool InternalCreateMaterialEffectPlayable(PlayableGraph& graph, Material material, int pass, PlayableHandle& handle)
private bool ValidateType(PlayableHandle& hdl)
}
public UnityEngine.Experimental.Playables.TextureMixerPlayable : ValueType {
private PlayableHandle m_Handle
internal void .ctor(PlayableHandle handle)
public TextureMixerPlayable Create(PlayableGraph graph)
private PlayableHandle CreateHandle(PlayableGraph graph)
public PlayableHandle GetHandle()
public Playable op_Implicit(TextureMixerPlayable playable)
public TextureMixerPlayable op_Explicit(Playable playable)
public bool Equals(TextureMixerPlayable other)
private bool CreateTextureMixerPlayableInternal(PlayableGraph& graph, PlayableHandle& handle)
}
internal UnityEngine.Experimental.Playables.TexturePlayableGraphExtensions : object {
internal bool InternalCreateTextureOutput(PlayableGraph& graph, string name, PlayableOutputHandle& handle)
}
public UnityEngine.Experimental.Playables.TexturePlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
public TexturePlayableOutput Null
internal void .ctor(PlayableOutputHandle handle)
public TexturePlayableOutput Create(PlayableGraph graph, string name, RenderTexture target)
public TexturePlayableOutput get_Null()
public PlayableOutputHandle GetHandle()
public PlayableOutput op_Implicit(TexturePlayableOutput output)
public TexturePlayableOutput op_Explicit(PlayableOutput output)
public RenderTexture GetTarget()
public void SetTarget(RenderTexture value)
private RenderTexture InternalGetTarget(PlayableOutputHandle& output)
private void InternalSetTarget(PlayableOutputHandle& output, RenderTexture target)
}
public UnityEngine.Experimental.Rendering.AsyncGPUReadback : object {
public AsyncGPUReadbackRequest Request(ComputeBuffer src)
public AsyncGPUReadbackRequest Request(ComputeBuffer src, int size, int offset)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, TextureFormat dstFormat)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat)
private AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_1(ComputeBuffer buffer)
private AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_2(ComputeBuffer src, int size, int offset)
private AsyncGPUReadbackRequest Request_Internal_Texture_1(Texture src, int mipIndex)
private AsyncGPUReadbackRequest Request_Internal_Texture_2(Texture src, int mipIndex, TextureFormat dstFormat)
private AsyncGPUReadbackRequest Request_Internal_Texture_3(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth)
private AsyncGPUReadbackRequest Request_Internal_Texture_4(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat)
private void Request_Internal_ComputeBuffer_1_Injected(ComputeBuffer buffer, AsyncGPUReadbackRequest& ret)
private void Request_Internal_ComputeBuffer_2_Injected(ComputeBuffer src, int size, int offset, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_1_Injected(Texture src, int mipIndex, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_2_Injected(Texture src, int mipIndex, TextureFormat dstFormat, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_3_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_4_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, AsyncGPUReadbackRequest& ret)
}
public UnityEngine.Experimental.Rendering.AsyncGPUReadbackRequest : ValueType {
internal IntPtr m_Ptr
internal int m_Version
public bool done
public bool hasError
public int layerCount
public void Update()
public void WaitForCompletion()
public NativeArray`1<T> GetData(int layer)
public bool get_done()
public bool get_hasError()
public int get_layerCount()
private bool IsDone()
private bool HasError()
private int GetLayerCount()
private IntPtr GetDataRaw(int layer)
private int GetLayerDataSize()
private void Update_Injected(AsyncGPUReadbackRequest& _unity_self)
private void WaitForCompletion_Injected(AsyncGPUReadbackRequest& _unity_self)
private bool IsDone_Injected(AsyncGPUReadbackRequest& _unity_self)
private bool HasError_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetLayerCount_Injected(AsyncGPUReadbackRequest& _unity_self)
private IntPtr GetDataRaw_Injected(AsyncGPUReadbackRequest& _unity_self, int layer)
private int GetLayerDataSize_Injected(AsyncGPUReadbackRequest& _unity_self)
}
public UnityEngine.Experimental.Rendering.BlendState : ValueType {
private RenderTargetBlendState m_BlendState0
private RenderTargetBlendState m_BlendState1
private RenderTargetBlendState m_BlendState2
private RenderTargetBlendState m_BlendState3
private RenderTargetBlendState m_BlendState4
private RenderTargetBlendState m_BlendState5
private RenderTargetBlendState m_BlendState6
private RenderTargetBlendState m_BlendState7
private byte m_SeparateMRTBlendStates
private byte m_AlphaToMask
private short m_Padding
public BlendState Default
public bool separateMRTBlendStates
public bool alphaToMask
public RenderTargetBlendState blendState0
public RenderTargetBlendState blendState1
public RenderTargetBlendState blendState2
public RenderTargetBlendState blendState3
public RenderTargetBlendState blendState4
public RenderTargetBlendState blendState5
public RenderTargetBlendState blendState6
public RenderTargetBlendState blendState7
public void .ctor(bool separateMRTBlend, bool alphaToMask)
public BlendState get_Default()
public bool get_separateMRTBlendStates()
public void set_separateMRTBlendStates(bool value)
public bool get_alphaToMask()
public void set_alphaToMask(bool value)
public RenderTargetBlendState get_blendState0()
public void set_blendState0(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState1()
public void set_blendState1(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState2()
public void set_blendState2(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState3()
public void set_blendState3(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState4()
public void set_blendState4(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState5()
public void set_blendState5(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState6()
public void set_blendState6(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState7()
public void set_blendState7(RenderTargetBlendState value)
}
public UnityEngine.Experimental.Rendering.CameraProperties : ValueType {
private int kNumLayers
private Rect screenRect
private Vector3 viewDir
private float projectionNear
private float projectionFar
private float cameraNear
private float cameraFar
private float cameraAspect
private Matrix4x4 cameraToWorld
private Matrix4x4 actualWorldToClip
private Matrix4x4 cameraClipToWorld
private Matrix4x4 cameraWorldToClip
private Matrix4x4 implicitProjection
private Matrix4x4 stereoWorldToClipLeft
private Matrix4x4 stereoWorldToClipRight
private Matrix4x4 worldToCamera
private Vector3 up
private Vector3 right
private Vector3 transformDirection
private Vector3 cameraEuler
private Vector3 velocity
private float farPlaneWorldSpaceLength
private UInt32 rendererCount
private <_shadowCullPlanes>__FixedBuffer1 _shadowCullPlanes
private <_cameraCullPlanes>__FixedBuffer2 _cameraCullPlanes
private float baseFarDistance
private Vector3 shadowCullCenter
private <layerCullDistances>__FixedBuffer3 layerCullDistances
private int layerCullSpherical
private CoreCameraValues coreCameraValues
private UInt32 cameraType
public Plane GetShadowCullingPlane(int index)
public void SetShadowCullingPlane(int index, Plane plane)
public Plane GetCameraCullingPlane(int index)
public void SetCameraCullingPlane(int index, Plane plane)
}
public UnityEngine.Experimental.Rendering.CoreCameraValues : ValueType {
private int filterMode
private UInt32 cullingMask
private int guid
private int renderImmediateObjects
}
public UnityEngine.Experimental.Rendering.CullResults : ValueType {
public List`1<VisibleLight> visibleLights
public List`1<VisibleLight> visibleOffscreenVertexLights
public List`1<VisibleReflectionProbe> visibleReflectionProbes
public FilterResults visibleRenderers
internal IntPtr cullResults
private void Init()
public bool GetCullingParameters(Camera camera, ScriptableCullingParameters& cullingParameters)
public bool GetCullingParameters(Camera camera, bool stereoAware, ScriptableCullingParameters& cullingParameters)
private bool GetCullingParameters_Internal(Camera camera, bool stereoAware, ScriptableCullingParameters& cullingParameters, int managedCullingParametersSize)
internal void Internal_Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext renderLoop, CullResults& results)
private void INTERNAL_CALL_Internal_Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext& renderLoop, CullResults& results)
public CullResults Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext renderLoop)
public void Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext renderLoop, CullResults& results)
public bool Cull(Camera camera, ScriptableRenderContext renderLoop, CullResults& results)
public bool GetShadowCasterBounds(int lightIndex, Bounds& outBounds)
private bool GetShadowCasterBounds(IntPtr cullResults, int lightIndex, Bounds& bounds)
public int GetLightIndicesCount()
private int GetLightIndicesCount(IntPtr cullResults)
public void FillLightIndices(ComputeBuffer computeBuffer)
private void FillLightIndices(IntPtr cullResults, ComputeBuffer computeBuffer)
public Int32[] GetLightIndexMap()
private Int32[] GetLightIndexMap(IntPtr cullResults)
public void SetLightIndexMap(Int32[] mapping)
private void SetLightIndexMap(IntPtr cullResults, Int32[] mapping)
public bool ComputeSpotShadowMatricesAndCullingPrimitives(int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool ComputeSpotShadowMatricesAndCullingPrimitives(IntPtr cullResults, int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
public bool ComputePointShadowMatricesAndCullingPrimitives(int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool ComputePointShadowMatricesAndCullingPrimitives(IntPtr cullResults, int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
public bool ComputeDirectionalShadowMatricesAndCullingPrimitives(int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool ComputeDirectionalShadowMatricesAndCullingPrimitives(IntPtr cullResults, int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool INTERNAL_CALL_ComputeDirectionalShadowMatricesAndCullingPrimitives(IntPtr cullResults, int activeLightIndex, int splitIndex, int splitCount, Vector3& splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
}
public UnityEngine.Experimental.Rendering.DepthState : ValueType {
private byte m_WriteEnabled
private sbyte m_CompareFunction
public DepthState Default
public bool writeEnabled
public CompareFunction compareFunction
public void .ctor(bool writeEnabled, CompareFunction compareFunction)
public DepthState get_Default()
public bool get_writeEnabled()
public void set_writeEnabled(bool value)
public CompareFunction get_compareFunction()
public void set_compareFunction(CompareFunction value)
}
public UnityEngine.Experimental.Rendering.DrawRendererFlags : Enum {
public int value__
public DrawRendererFlags None
public DrawRendererFlags EnableDynamicBatching
public DrawRendererFlags EnableInstancing
}
public UnityEngine.Experimental.Rendering.DrawRendererSettings : ValueType {
private int kMaxShaderPasses
public int maxShaderPasses
public DrawRendererSortSettings sorting
private <shaderPassNames>__FixedBuffer0 shaderPassNames
public RendererConfiguration rendererConfiguration
public DrawRendererFlags flags
private int m_OverrideMaterialInstanceId
private int m_OverrideMaterialPassIdx
public void .ctor(Camera camera, ShaderPassName shaderPassName)
public void SetOverrideMaterial(Material mat, int passIndex)
public void SetShaderPassName(int index, ShaderPassName shaderPassName)
private void InitializeSortSettings(Camera camera, DrawRendererSortSettings& sortSettings)
}
public UnityEngine.Experimental.Rendering.DrawRendererSortSettings : ValueType {
public Matrix4x4 worldToCameraMatrix
public Vector3 cameraPosition
public SortFlags flags
private int _sortOrthographic
private Matrix4x4 _previousVPMatrix
private Matrix4x4 _nonJitteredVPMatrix
public bool sortOrthographic
public bool get_sortOrthographic()
public void set_sortOrthographic(bool value)
}
public UnityEngine.Experimental.Rendering.DrawShadowsSettings : ValueType {
private IntPtr _cullResults
public int lightIndex
public ShadowSplitData splitData
public CullResults cullResults
public void .ctor(CullResults cullResults, int lightIndex)
public void set_cullResults(CullResults value)
}
public UnityEngine.Experimental.Rendering.FilterRenderersSettings : ValueType {
private RenderQueueRange m_RenderQueueRange
private int m_LayerMask
private UInt32 m_RenderingLayerMask
public RenderQueueRange renderQueueRange
public int layerMask
public UInt32 renderingLayerMask
public void .ctor(bool initializeValues)
public RenderQueueRange get_renderQueueRange()
public void set_renderQueueRange(RenderQueueRange value)
public int get_layerMask()
public void set_layerMask(int value)
public UInt32 get_renderingLayerMask()
public void set_renderingLayerMask(UInt32 value)
}
public UnityEngine.Experimental.Rendering.FilterResults : ValueType {
internal IntPtr m_CullResults
}
public UnityEngine.Experimental.Rendering.IRenderPipeline {
public bool disposed
public bool get_disposed()
public void Render(ScriptableRenderContext renderContext, Camera[] cameras)
}
public UnityEngine.Experimental.Rendering.IRenderPipelineAsset {
public void DestroyCreatedInstances()
public IRenderPipeline CreatePipeline()
}
public UnityEngine.Experimental.Rendering.LODParameters : ValueType {
private int m_IsOrthographic
private Vector3 m_CameraPosition
private float m_FieldOfView
private float m_OrthoSize
private int m_CameraPixelHeight
public bool isOrthographic
public Vector3 cameraPosition
public float fieldOfView
public float orthoSize
public int cameraPixelHeight
public bool get_isOrthographic()
public void set_isOrthographic(bool value)
public Vector3 get_cameraPosition()
public void set_cameraPosition(Vector3 value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public float get_orthoSize()
public void set_orthoSize(float value)
public int get_cameraPixelHeight()
public void set_cameraPixelHeight(int value)
}
public UnityEngine.Experimental.Rendering.RasterState : ValueType {
public RasterState Default
private CullMode m_CullingMode
private int m_OffsetUnits
private float m_OffsetFactor
private byte m_DepthClip
public CullMode cullingMode
public bool depthClip
public int offsetUnits
public float offsetFactor
public void .ctor(CullMode cullingMode, int offsetUnits, float offsetFactor, bool depthClip)
public CullMode get_cullingMode()
public void set_cullingMode(CullMode value)
public bool get_depthClip()
public void set_depthClip(bool value)
public int get_offsetUnits()
public void set_offsetUnits(int value)
public float get_offsetFactor()
public void set_offsetFactor(float value)
}
public UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions : Enum {
public int value__
public ReflectionProbeSortOptions None
public ReflectionProbeSortOptions Importance
public ReflectionProbeSortOptions Size
public ReflectionProbeSortOptions ImportanceThenSize
}
public UnityEngine.Experimental.Rendering.RendererConfiguration : Enum {
public int value__
public RendererConfiguration None
public RendererConfiguration PerObjectLightProbe
public RendererConfiguration PerObjectReflectionProbes
public RendererConfiguration PerObjectLightProbeProxyVolume
public RendererConfiguration PerObjectLightmaps
public RendererConfiguration ProvideLightIndices
public RendererConfiguration PerObjectMotionVectors
public RendererConfiguration PerObjectLightIndices8
public RendererConfiguration ProvideReflectionProbeIndices
public RendererConfiguration PerObjectOcclusionProbe
public RendererConfiguration PerObjectOcclusionProbeProxyVolume
public RendererConfiguration PerObjectShadowMask
}
public UnityEngine.Experimental.Rendering.RenderPass : object {
private RenderPassAttachment[] <colorAttachments>k__BackingField
private RenderPassAttachment <depthAttachment>k__BackingField
private int <width>k__BackingField
private int <height>k__BackingField
private int <sampleCount>k__BackingField
private ScriptableRenderContext <context>k__BackingField
public RenderPassAttachment[] colorAttachments
public RenderPassAttachment depthAttachment
public int width
public int height
public int sampleCount
public ScriptableRenderContext context
public void .ctor(ScriptableRenderContext ctx, int w, int h, int samples, RenderPassAttachment[] colors, RenderPassAttachment depth)
public RenderPassAttachment[] get_colorAttachments()
private void set_colorAttachments(RenderPassAttachment[] value)
public RenderPassAttachment get_depthAttachment()
private void set_depthAttachment(RenderPassAttachment value)
public int get_width()
private void set_width(int value)
public int get_height()
private void set_height(int value)
public int get_sampleCount()
private void set_sampleCount(int value)
public ScriptableRenderContext get_context()
private void set_context(ScriptableRenderContext value)
public void Dispose()
}
public UnityEngine.Experimental.Rendering.RenderPassAttachment : Object {
public RenderBufferLoadAction loadAction
public RenderBufferStoreAction storeAction
public RenderTextureFormat format
private RenderTargetIdentifier loadStoreTarget
private RenderTargetIdentifier resolveTarget
public Color clearColor
public float clearDepth
public UInt32 clearStencil
public void .ctor(RenderTextureFormat fmt)
public RenderBufferLoadAction get_loadAction()
private void set_loadAction(RenderBufferLoadAction value)
public RenderBufferStoreAction get_storeAction()
private void set_storeAction(RenderBufferStoreAction value)
public RenderTextureFormat get_format()
private void set_format(RenderTextureFormat value)
private RenderTargetIdentifier get_loadStoreTarget()
private void set_loadStoreTarget(RenderTargetIdentifier value)
private RenderTargetIdentifier get_resolveTarget()
private void set_resolveTarget(RenderTargetIdentifier value)
public Color get_clearColor()
private void set_clearColor(Color value)
public float get_clearDepth()
private void set_clearDepth(float value)
public UInt32 get_clearStencil()
private void set_clearStencil(UInt32 value)
public void BindSurface(RenderTargetIdentifier tgt, bool loadExistingContents, bool storeResults)
public void BindResolveSurface(RenderTargetIdentifier tgt)
public void Clear(Color clearCol, float clearDep, UInt32 clearStenc)
public void Internal_CreateAttachment(RenderPassAttachment self)
private void get_loadStoreTarget_Injected(RenderTargetIdentifier& ret)
private void set_loadStoreTarget_Injected(RenderTargetIdentifier& value)
private void get_resolveTarget_Injected(RenderTargetIdentifier& ret)
private void set_resolveTarget_Injected(RenderTargetIdentifier& value)
private void get_clearColor_Injected(Color& ret)
private void set_clearColor_Injected(Color& value)
}
public UnityEngine.Experimental.Rendering.RenderPipeline : object {
private Action`1<Camera[]> beginFrameRendering
private Action`1<Camera> beginCameraRendering
private bool <disposed>k__BackingField
public bool disposed
public void add_beginFrameRendering(Action`1<Camera[]> value)
public void remove_beginFrameRendering(Action`1<Camera[]> value)
public void add_beginCameraRendering(Action`1<Camera> value)
public void remove_beginCameraRendering(Action`1<Camera> value)
public void Render(ScriptableRenderContext renderContext, Camera[] cameras)
public bool get_disposed()
private void set_disposed(bool value)
public void Dispose()
public void BeginFrameRendering(Camera[] cameras)
public void BeginCameraRendering(Camera camera)
}
public UnityEngine.Experimental.Rendering.RenderPipelineAsset : ScriptableObject {
private List`1<IRenderPipeline> m_CreatedPipelines
public void DestroyCreatedInstances()
public IRenderPipeline CreatePipeline()
public Material GetDefaultMaterial()
public Material GetDefaultParticleMaterial()
public Material GetDefaultLineMaterial()
public Material GetDefaultTerrainMaterial()
public Material GetDefaultUIMaterial()
public Material GetDefaultUIOverdrawMaterial()
public Material GetDefaultUIETC1SupportedMaterial()
public Material GetDefault2DMaterial()
public Shader GetDefaultShader()
protected IRenderPipeline InternalCreatePipeline()
protected IEnumerable`1<IRenderPipeline> CreatedInstances()
protected void OnValidate()
protected void OnDisable()
}
public UnityEngine.Experimental.Rendering.RenderPipelineManager : object {
private IRenderPipelineAsset s_CurrentPipelineAsset
private IRenderPipeline <currentPipeline>k__BackingField
public IRenderPipeline currentPipeline
public IRenderPipeline get_currentPipeline()
private void set_currentPipeline(IRenderPipeline value)
internal void CleanupRenderPipeline()
private void DoRenderLoop_Internal(IRenderPipelineAsset pipe, Camera[] cameras, IntPtr loopPtr)
private void PrepareRenderPipeline(IRenderPipelineAsset pipe)
}
public UnityEngine.Experimental.Rendering.RenderQueueRange : ValueType {
public int min
public int max
public RenderQueueRange all
public RenderQueueRange opaque
public RenderQueueRange transparent
public RenderQueueRange get_all()
public RenderQueueRange get_opaque()
public RenderQueueRange get_transparent()
}
public UnityEngine.Experimental.Rendering.RenderStateBlock : ValueType {
private BlendState m_BlendState
private RasterState m_RasterState
private DepthState m_DepthState
private StencilState m_StencilState
private int m_StencilReference
private RenderStateMask m_Mask
public BlendState blendState
public RasterState rasterState
public DepthState depthState
public StencilState stencilState
public int stencilReference
public RenderStateMask mask
public void .ctor(RenderStateMask mask)
public BlendState get_blendState()
public void set_blendState(BlendState value)
public RasterState get_rasterState()
public void set_rasterState(RasterState value)
public DepthState get_depthState()
public void set_depthState(DepthState value)
public StencilState get_stencilState()
public void set_stencilState(StencilState value)
public int get_stencilReference()
public void set_stencilReference(int value)
public RenderStateMask get_mask()
public void set_mask(RenderStateMask value)
}
public UnityEngine.Experimental.Rendering.RenderStateMapping : ValueType {
private int m_RenderTypeID
private RenderStateBlock m_StateBlock
public string renderType
public RenderStateBlock stateBlock
public void .ctor(string renderType, RenderStateBlock stateBlock)
public void .ctor(RenderStateBlock stateBlock)
public string get_renderType()
public void set_renderType(string value)
public RenderStateBlock get_stateBlock()
public void set_stateBlock(RenderStateBlock value)
}
public UnityEngine.Experimental.Rendering.RenderStateMask : Enum {
public int value__
public RenderStateMask Nothing
public RenderStateMask Blend
public RenderStateMask Raster
public RenderStateMask Depth
public RenderStateMask Stencil
public RenderStateMask Everything
}
public UnityEngine.Experimental.Rendering.RenderTargetBlendState : ValueType {
private byte m_WriteMask
private byte m_SourceColorBlendMode
private byte m_DestinationColorBlendMode
private byte m_SourceAlphaBlendMode
private byte m_DestinationAlphaBlendMode
private byte m_ColorBlendOperation
private byte m_AlphaBlendOperation
private byte m_Padding
public RenderTargetBlendState Default
public ColorWriteMask writeMask
public BlendMode sourceColorBlendMode
public BlendMode destinationColorBlendMode
public BlendMode sourceAlphaBlendMode
public BlendMode destinationAlphaBlendMode
public BlendOp colorBlendOperation
public BlendOp alphaBlendOperation
public void .ctor(ColorWriteMask writeMask, BlendMode sourceColorBlendMode, BlendMode destinationColorBlendMode, BlendMode sourceAlphaBlendMode, BlendMode destinationAlphaBlendMode, BlendOp colorBlendOperation, BlendOp alphaBlendOperation)
public RenderTargetBlendState get_Default()
public ColorWriteMask get_writeMask()
public void set_writeMask(ColorWriteMask value)
public BlendMode get_sourceColorBlendMode()
public void set_sourceColorBlendMode(BlendMode value)
public BlendMode get_destinationColorBlendMode()
public void set_destinationColorBlendMode(BlendMode value)
public BlendMode get_sourceAlphaBlendMode()
public void set_sourceAlphaBlendMode(BlendMode value)
public BlendMode get_destinationAlphaBlendMode()
public void set_destinationAlphaBlendMode(BlendMode value)
public BlendOp get_colorBlendOperation()
public void set_colorBlendOperation(BlendOp value)
public BlendOp get_alphaBlendOperation()
public void set_alphaBlendOperation(BlendOp value)
}
public UnityEngine.Experimental.Rendering.ScriptableCullingParameters : ValueType {
private int m_IsOrthographic
private LODParameters m_LodParameters
private <m_CullingPlanes>__FixedBuffer4 m_CullingPlanes
private int m_CullingPlaneCount
private int m_CullingMask
private long m_SceneMask
private <m_LayerFarCullDistances>__FixedBuffer5 m_LayerFarCullDistances
private int m_LayerCull
private Matrix4x4 m_CullingMatrix
private Vector3 m_Position
private float m_shadowDistance
private int m_CullingFlags
private ReflectionProbeSortOptions m_ReflectionProbeSortOptions
private CameraProperties m_CameraProperties
public Matrix4x4 cullStereoView
public Matrix4x4 cullStereoProj
public float cullStereoSeparation
private int padding2
public int cullingPlaneCount
public bool isOrthographic
public LODParameters lodParameters
public int cullingMask
public long sceneMask
public int layerCull
public Matrix4x4 cullingMatrix
public Vector3 position
public float shadowDistance
public int cullingFlags
public ReflectionProbeSortOptions reflectionProbeSortOptions
public CameraProperties cameraProperties
public int get_cullingPlaneCount()
public void set_cullingPlaneCount(int value)
public bool get_isOrthographic()
public void set_isOrthographic(bool value)
public LODParameters get_lodParameters()
public void set_lodParameters(LODParameters value)
public int get_cullingMask()
public void set_cullingMask(int value)
public long get_sceneMask()
public void set_sceneMask(long value)
public int get_layerCull()
public void set_layerCull(int value)
public Matrix4x4 get_cullingMatrix()
public void set_cullingMatrix(Matrix4x4 value)
public Vector3 get_position()
public void set_position(Vector3 value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public int get_cullingFlags()
public void set_cullingFlags(int value)
public ReflectionProbeSortOptions get_reflectionProbeSortOptions()
public void set_reflectionProbeSortOptions(ReflectionProbeSortOptions value)
public CameraProperties get_cameraProperties()
public void set_cameraProperties(CameraProperties value)
public float GetLayerCullDistance(int layerIndex)
public void SetLayerCullDistance(int layerIndex, float distance)
public Plane GetCullingPlane(int index)
public void SetCullingPlane(int index, Plane plane)
}
public UnityEngine.Experimental.Rendering.ScriptableRenderContext : ValueType {
private IntPtr m_Ptr
internal void .ctor(IntPtr ptr)
private void Submit_Internal()
private void DrawRenderers_Internal(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings)
private void INTERNAL_CALL_DrawRenderers_Internal(ScriptableRenderContext& self, FilterResults& renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings& filterSettings)
private void DrawRenderers_StateBlock_Internal(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings, RenderStateBlock stateBlock)
private void INTERNAL_CALL_DrawRenderers_StateBlock_Internal(ScriptableRenderContext& self, FilterResults& renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings& filterSettings, RenderStateBlock& stateBlock)
private void DrawRenderers_StateMap_Internal(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings, Array stateMap, int stateMapLength)
private void INTERNAL_CALL_DrawRenderers_StateMap_Internal(ScriptableRenderContext& self, FilterResults& renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings& filterSettings, Array stateMap, int stateMapLength)
private void DrawShadows_Internal(DrawShadowsSettings& settings)
private void ExecuteCommandBuffer_Internal(CommandBuffer commandBuffer)
private void ExecuteCommandBufferAsync_Internal(CommandBuffer commandBuffer, ComputeQueueType queueType)
private void SetupCameraProperties_Internal(Camera camera, bool stereoSetup)
private void StereoEndRender_Internal(Camera camera)
private void StartMultiEye_Internal(Camera camera)
private void StopMultiEye_Internal(Camera camera)
private void DrawSkybox_Internal(Camera camera)
internal IntPtr Internal_GetPtr()
public void BeginRenderPassInternal(IntPtr _self, int w, int h, int samples, RenderPassAttachment[] colors, RenderPassAttachment depth)
public void BeginSubPassInternal(IntPtr _self, RenderPassAttachment[] colors, RenderPassAttachment[] inputs, bool readOnlyDepth)
public void EndRenderPassInternal(IntPtr _self)
public void Submit()
public void DrawRenderers(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings)
public void DrawRenderers(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings, RenderStateBlock stateBlock)
public void DrawRenderers(FilterResults renderers, DrawRendererSettings& drawSettings, FilterRenderersSettings filterSettings, List`1<RenderStateMapping> stateMap)
public void DrawShadows(DrawShadowsSettings& settings)
public void ExecuteCommandBuffer(CommandBuffer commandBuffer)
public void ExecuteCommandBufferAsync(CommandBuffer commandBuffer, ComputeQueueType queueType)
public void SetupCameraProperties(Camera camera)
public void SetupCameraProperties(Camera camera, bool stereoSetup)
public void StereoEndRender(Camera camera)
public void StartMultiEye(Camera camera)
public void StopMultiEye(Camera camera)
public void DrawSkybox(Camera camera)
internal void CheckValid()
}
public UnityEngine.Experimental.Rendering.ShaderPassName : ValueType {
private int m_NameIndex
internal int nameIndex
public void .ctor(string name)
private int Init(string name)
internal int get_nameIndex()
}
public UnityEngine.Experimental.Rendering.ShadowSplitData : ValueType {
public int cullingPlaneCount
private <_cullingPlanes>__FixedBuffer6 _cullingPlanes
public Vector4 cullingSphere
public Plane GetCullingPlane(int index)
public void SetCullingPlane(int index, Plane plane)
}
public UnityEngine.Experimental.Rendering.SortFlags : Enum {
public int value__
public SortFlags None
public SortFlags SortingLayer
public SortFlags RenderQueue
public SortFlags BackToFront
public SortFlags QuantizedFrontToBack
public SortFlags OptimizeStateChanges
public SortFlags CanvasOrder
public SortFlags CommonOpaque
public SortFlags CommonTransparent
}
public UnityEngine.Experimental.Rendering.StencilState : ValueType {
private byte m_Enabled
private byte m_ReadMask
private byte m_WriteMask
private byte m_Padding
private byte m_CompareFunctionFront
private byte m_PassOperationFront
private byte m_FailOperationFront
private byte m_ZFailOperationFront
private byte m_CompareFunctionBack
private byte m_PassOperationBack
private byte m_FailOperationBack
private byte m_ZFailOperationBack
public StencilState Default
public bool enabled
public byte readMask
public byte writeMask
public CompareFunction compareFunction
public StencilOp passOperation
public StencilOp failOperation
public StencilOp zFailOperation
public CompareFunction compareFunctionFront
public StencilOp passOperationFront
public StencilOp failOperationFront
public StencilOp zFailOperationFront
public CompareFunction compareFunctionBack
public StencilOp passOperationBack
public StencilOp failOperationBack
public StencilOp zFailOperationBack
public void .ctor(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunction, StencilOp passOperation, StencilOp failOperation, StencilOp zFailOperation)
public void .ctor(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunctionFront, StencilOp passOperationFront, StencilOp failOperationFront, StencilOp zFailOperationFront, CompareFunction compareFunctionBack, StencilOp passOperationBack, StencilOp failOperationBack, StencilOp zFailOperationBack)
public StencilState get_Default()
public bool get_enabled()
public void set_enabled(bool value)
public byte get_readMask()
public void set_readMask(byte value)
public byte get_writeMask()
public void set_writeMask(byte value)
public void set_compareFunction(CompareFunction value)
public void set_passOperation(StencilOp value)
public void set_failOperation(StencilOp value)
public void set_zFailOperation(StencilOp value)
public CompareFunction get_compareFunctionFront()
public void set_compareFunctionFront(CompareFunction value)
public StencilOp get_passOperationFront()
public void set_passOperationFront(StencilOp value)
public StencilOp get_failOperationFront()
public void set_failOperationFront(StencilOp value)
public StencilOp get_zFailOperationFront()
public void set_zFailOperationFront(StencilOp value)
public CompareFunction get_compareFunctionBack()
public void set_compareFunctionBack(CompareFunction value)
public StencilOp get_passOperationBack()
public void set_passOperationBack(StencilOp value)
public StencilOp get_failOperationBack()
public void set_failOperationBack(StencilOp value)
public StencilOp get_zFailOperationBack()
public void set_zFailOperationBack(StencilOp value)
}
public UnityEngine.Experimental.Rendering.SupportedRenderingFeatures : object {
private SupportedRenderingFeatures s_Active
private ReflectionProbeSupportFlags <reflectionProbeSupportFlags>k__BackingField
private LightmapMixedBakeMode <defaultMixedLightingMode>k__BackingField
private LightmapMixedBakeMode <supportedMixedLightingModes>k__BackingField
private LightmapBakeType <supportedLightmapBakeTypes>k__BackingField
private LightmapsMode <supportedLightmapsModes>k__BackingField
private bool <rendererSupportsLightProbeProxyVolumes>k__BackingField
private bool <rendererSupportsMotionVectors>k__BackingField
private bool <rendererSupportsReceiveShadows>k__BackingField
private bool <rendererSupportsReflectionProbes>k__BackingField
public SupportedRenderingFeatures active
public ReflectionProbeSupportFlags reflectionProbeSupportFlags
public LightmapMixedBakeMode defaultMixedLightingMode
public LightmapMixedBakeMode supportedMixedLightingModes
public LightmapBakeType supportedLightmapBakeTypes
public LightmapsMode supportedLightmapsModes
public bool rendererSupportsLightProbeProxyVolumes
public bool rendererSupportsMotionVectors
public bool rendererSupportsReceiveShadows
public bool rendererSupportsReflectionProbes
public SupportedRenderingFeatures get_active()
public void set_active(SupportedRenderingFeatures value)
public ReflectionProbeSupportFlags get_reflectionProbeSupportFlags()
public void set_reflectionProbeSupportFlags(ReflectionProbeSupportFlags value)
public LightmapMixedBakeMode get_defaultMixedLightingMode()
public void set_defaultMixedLightingMode(LightmapMixedBakeMode value)
public LightmapMixedBakeMode get_supportedMixedLightingModes()
public void set_supportedMixedLightingModes(LightmapMixedBakeMode value)
public LightmapBakeType get_supportedLightmapBakeTypes()
public void set_supportedLightmapBakeTypes(LightmapBakeType value)
public LightmapsMode get_supportedLightmapsModes()
public void set_supportedLightmapsModes(LightmapsMode value)
public bool get_rendererSupportsLightProbeProxyVolumes()
public void set_rendererSupportsLightProbeProxyVolumes(bool value)
public bool get_rendererSupportsMotionVectors()
public void set_rendererSupportsMotionVectors(bool value)
public bool get_rendererSupportsReceiveShadows()
public void set_rendererSupportsReceiveShadows(bool value)
public bool get_rendererSupportsReflectionProbes()
public void set_rendererSupportsReflectionProbes(bool value)
internal MixedLightingMode FallbackMixedLightingMode()
internal void FallbackMixedLightingModeByRef(IntPtr fallbackModePtr)
internal bool IsMixedLightingModeSupported(MixedLightingMode mixedMode)
internal void IsMixedLightingModeSupportedByRef(MixedLightingMode mixedMode, IntPtr isSupportedPtr)
internal bool IsLightmapBakeTypeSupported(LightmapBakeType bakeType)
internal void IsLightmapBakeTypeSupportedByRef(LightmapBakeType bakeType, IntPtr isSupportedPtr)
internal bool IsLightmapsModeSupported(LightmapsMode mode)
internal void IsLightmapsModeSupportedByRef(LightmapsMode mode, IntPtr isSupportedPtr)
}
public UnityEngine.Experimental.Rendering.VertexAttribute : Enum {
public int value__
public VertexAttribute Position
public VertexAttribute Normal
public VertexAttribute Tangent
public VertexAttribute Color
public VertexAttribute TexCoord0
public VertexAttribute TexCoord1
public VertexAttribute TexCoord2
public VertexAttribute TexCoord3
public VertexAttribute TexCoord4
public VertexAttribute TexCoord5
public VertexAttribute TexCoord6
public VertexAttribute TexCoord7
}
public UnityEngine.Experimental.Rendering.VisibleLight : ValueType {
public LightType lightType
public Color finalColor
public Rect screenRect
public Matrix4x4 localToWorld
public float range
public float spotAngle
private int instanceId
public VisibleLightFlags flags
public Light light
public Light get_light()
private Light GetLightObject(int instanceId)
}
public UnityEngine.Experimental.Rendering.VisibleLightFlags : Enum {
public int value__
public VisibleLightFlags None
public VisibleLightFlags IntersectsNearPlane
public VisibleLightFlags IntersectsFarPlane
}
public UnityEngine.Experimental.Rendering.VisibleReflectionProbe : ValueType {
public Bounds bounds
public Matrix4x4 localToWorld
public Vector4 hdr
public Vector3 center
public float blendDistance
public int importance
public int boxProjection
private int instanceId
private int textureId
public Texture texture
public ReflectionProbe probe
public Texture get_texture()
private Texture GetTextureObject(int textureId)
public ReflectionProbe get_probe()
private ReflectionProbe GetReflectionProbeObject(int instanceId)
}
public UnityEngine.Experimental.U2D.SpriteBone : ValueType {
private string m_Name
private Vector3 m_Position
private Quaternion m_Rotation
private float m_Length
private int m_ParentId
public string name
public Vector3 position
public Quaternion rotation
public float length
public int parentId
public string get_name()
public void set_name(string value)
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public float get_length()
public void set_length(float value)
public int get_parentId()
public void set_parentId(int value)
}
internal UnityEngine.Experimental.U2D.SpriteChannelInfo : ValueType {
private IntPtr m_Buffer
private int m_Count
private int m_Offset
private int m_Stride
public Void* buffer
public int count
public int offset
public int stride
public Void* get_buffer()
public void set_buffer(Void* value)
public int get_count()
public void set_count(int value)
public int get_offset()
public void set_offset(int value)
public int get_stride()
public void set_stride(int value)
}
public UnityEngine.Experimental.U2D.SpriteDataAccessExtensions : object {
private void CheckAttributeTypeMatchesAndThrow(VertexAttribute channel)
public NativeSlice`1<T> GetVertexAttribute(Sprite sprite, VertexAttribute channel)
public void SetVertexAttribute(Sprite sprite, VertexAttribute channel, NativeArray`1<T> src)
public NativeArray`1<Matrix4x4> GetBindPoses(Sprite sprite)
public void SetBindPoses(Sprite sprite, NativeArray`1<Matrix4x4> src)
public NativeArray`1<ushort> GetIndices(Sprite sprite)
public void SetIndices(Sprite sprite, NativeArray`1<ushort> src)
public NativeArray`1<BoneWeight> GetBoneWeights(Sprite sprite)
public void SetBoneWeights(Sprite sprite, NativeArray`1<BoneWeight> src)
public SpriteBone[] GetBones(Sprite sprite)
public void SetBones(Sprite sprite, SpriteBone[] src)
public bool HasVertexAttribute(Sprite sprite, VertexAttribute channel)
public void SetVertexCount(Sprite sprite, int count)
public int GetVertexCount(Sprite sprite)
private SpriteChannelInfo GetBindPoseInfo(Sprite sprite)
private void SetBindPoseData(Sprite sprite, Void* src, int count)
private SpriteChannelInfo GetIndicesInfo(Sprite sprite)
private void SetIndicesData(Sprite sprite, Void* src, int count)
private SpriteChannelInfo GetChannelInfo(Sprite sprite, VertexAttribute channel)
private void SetChannelData(Sprite sprite, VertexAttribute channel, Void* src)
private SpriteBone[] GetBoneInfo(Sprite sprite)
private void SetBoneData(Sprite sprite, SpriteBone[] src)
private SpriteChannelInfo GetBoneWeightsInfo(Sprite sprite)
private void SetBoneWeightsData(Sprite sprite, Void* src, int count)
private void GetBindPoseInfo_Injected(Sprite sprite, SpriteChannelInfo& ret)
private void GetIndicesInfo_Injected(Sprite sprite, SpriteChannelInfo& ret)
private void GetChannelInfo_Injected(Sprite sprite, VertexAttribute channel, SpriteChannelInfo& ret)
private void GetBoneWeightsInfo_Injected(Sprite sprite, SpriteChannelInfo& ret)
}
public UnityEngine.Experimental.U2D.SpriteRendererDataAccessExtensions : object {
public NativeArray`1<Vector3> GetDeformableVertices(SpriteRenderer spriteRenderer)
public void DeactivateDeformableBuffer(SpriteRenderer renderer)
public void UpdateDeformableBuffer(SpriteRenderer spriteRenderer, JobHandle fence)
private SpriteChannelInfo GetDeformableChannelInfo(SpriteRenderer sprite, VertexAttribute channel)
internal void SetLocalAABB(SpriteRenderer renderer, Bounds aabb)
private void UpdateDeformableBuffer_Injected(SpriteRenderer spriteRenderer, JobHandle& fence)
private void GetDeformableChannelInfo_Injected(SpriteRenderer sprite, VertexAttribute channel, SpriteChannelInfo& ret)
private void SetLocalAABB_Injected(SpriteRenderer renderer, Bounds& aabb)
}
public UnityEngine.ExposedPropertyResolver : ValueType {
internal IntPtr table
internal Object ResolveReferenceInternal(IntPtr ptr, PropertyName name, Boolean& isValid)
private Object ResolveReferenceBindingsInternal(IntPtr ptr, PropertyName name, Boolean& isValid)
private Object ResolveReferenceBindingsInternal_Injected(IntPtr ptr, PropertyName& name, Boolean& isValid)
}
public UnityEngine.ExposedReference`1 : ValueType {
public PropertyName exposedName
public Object defaultValue
public T Resolve(IExposedPropertyTable resolver)
}
public UnityEngine.FilterMode : Enum {
public int value__
public FilterMode Point
public FilterMode Bilinear
public FilterMode Trilinear
}
public UnityEngine.Flare : Object {
private void Internal_Create(Flare self)
}
public UnityEngine.FogMode : Enum {
public int value__
public FogMode Linear
public FogMode Exponential
public FogMode ExponentialSquared
}
public UnityEngine.FrameTiming : ValueType {
public ulong cpuTimePresentCalled
public double cpuFrameTime
public ulong cpuTimeFrameComplete
public double gpuFrameTime
public float heightScale
public float widthScale
public UInt32 syncInterval
}
public UnityEngine.FrameTimingManager : object {
public void CaptureFrameTimings()
public UInt32 GetLatestTimings(UInt32 numFrames, FrameTiming[] timings)
public float GetVSyncsPerSecond()
public ulong GetGpuTimerFrequency()
public ulong GetCpuTimerFrequency()
}
public UnityEngine.FrustumPlanes : ValueType {
public float left
public float right
public float bottom
public float top
public float zNear
public float zFar
}
public UnityEngine.FullScreenMode : Enum {
public int value__
public FullScreenMode ExclusiveFullScreen
public FullScreenMode FullScreenWindow
public FullScreenMode MaximizedWindow
public FullScreenMode Windowed
}
public UnityEngine.GameObject : Object {
public Transform transform
public int layer
public bool active
public bool activeSelf
public bool activeInHierarchy
public bool isStatic
internal bool isStaticBatchable
public string tag
public Scene scene
public GameObject gameObject
public void .ctor(string name)
public void .ctor(string name, Type[] components)
public GameObject CreatePrimitive(PrimitiveType type)
public Component GetComponent(Type type)
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue)
public T GetComponent()
internal Component GetComponentByName(string type)
public Component GetComponent(string type)
public Component GetComponentInChildren(Type type, bool includeInactive)
public Component GetComponentInChildren(Type type)
public T GetComponentInChildren()
public T GetComponentInChildren(bool includeInactive)
public Component GetComponentInParent(Type type)
public T GetComponentInParent()
public Component[] GetComponents(Type type)
public T[] GetComponents()
public void GetComponents(Type type, List`1<Component> results)
public void GetComponents(List`1<T> results)
public Component[] GetComponentsInChildren(Type type)
public Component[] GetComponentsInChildren(Type type, bool includeInactive)
public T[] GetComponentsInChildren(bool includeInactive)
public void GetComponentsInChildren(bool includeInactive, List`1<T> results)
public T[] GetComponentsInChildren()
public void GetComponentsInChildren(List`1<T> results)
public Component[] GetComponentsInParent(Type type)
public Component[] GetComponentsInParent(Type type, bool includeInactive)
public void GetComponentsInParent(bool includeInactive, List`1<T> results)
public T[] GetComponentsInParent(bool includeInactive)
public T[] GetComponentsInParent()
private Array GetComponentsInternal(Type type, bool useSearchTypeAsArrayReturnType, bool recursive, bool includeInactive, bool reverse, object resultList)
internal Component AddComponentInternal(string className)
public Transform get_transform()
public int get_layer()
public void set_layer(int value)
public bool get_active()
public void set_active(bool value)
public void SetActive(bool value)
public bool get_activeSelf()
public bool get_activeInHierarchy()
public void SetActiveRecursively(bool state)
public bool get_isStatic()
public void set_isStatic(bool value)
internal bool get_isStaticBatchable()
public string get_tag()
public void set_tag(string value)
public bool CompareTag(string tag)
public GameObject FindGameObjectWithTag(string tag)
public GameObject FindWithTag(string tag)
public GameObject[] FindGameObjectsWithTag(string tag)
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options)
public void SendMessageUpwards(string methodName, object value)
public void SendMessageUpwards(string methodName)
public void SendMessageUpwards(string methodName, SendMessageOptions options)
public void SendMessage(string methodName, object value, SendMessageOptions options)
public void SendMessage(string methodName, object value)
public void SendMessage(string methodName)
public void SendMessage(string methodName, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter)
public void BroadcastMessage(string methodName)
public void BroadcastMessage(string methodName, SendMessageOptions options)
private Component Internal_AddComponentWithType(Type componentType)
public Component AddComponent(Type componentType)
public T AddComponent()
private void Internal_CreateGameObject(GameObject mono, string name)
public GameObject Find(string name)
public Scene get_scene()
private void INTERNAL_get_scene(Scene& value)
public GameObject get_gameObject()
}
public UnityEngine.GeometryUtility : object {
public Plane[] CalculateFrustumPlanes(Camera camera)
public Plane[] CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix)
public void CalculateFrustumPlanes(Camera camera, Plane[] planes)
public void CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix, Plane[] planes)
public Bounds CalculateBounds(Vector3[] positions, Matrix4x4 transform)
public bool TryCreatePlaneFromPolygon(Vector3[] vertices, Plane& plane)
private void Internal_ExtractPlanes(Plane[] planes, Matrix4x4 worldToProjectionMatrix)
public bool TestPlanesAABB(Plane[] planes, Bounds bounds)
private Bounds Internal_CalculateBounds(Vector3[] positions, Matrix4x4 transform)
private void Internal_ExtractPlanes_Injected(Plane[] planes, Matrix4x4& worldToProjectionMatrix)
private bool TestPlanesAABB_Injected(Plane[] planes, Bounds& bounds)
private void Internal_CalculateBounds_Injected(Vector3[] positions, Matrix4x4& transform, Bounds& ret)
}
public UnityEngine.Gizmos : object {
public Color color
public Matrix4x4 matrix
public void DrawRay(Ray r)
public void DrawRay(Vector3 from, Vector3 direction)
public void DrawLine(Vector3 from, Vector3 to)
private void INTERNAL_CALL_DrawLine(Vector3& from, Vector3& to)
public void DrawWireSphere(Vector3 center, float radius)
private void INTERNAL_CALL_DrawWireSphere(Vector3& center, float radius)
public void DrawSphere(Vector3 center, float radius)
private void INTERNAL_CALL_DrawSphere(Vector3& center, float radius)
public void DrawWireCube(Vector3 center, Vector3 size)
private void INTERNAL_CALL_DrawWireCube(Vector3& center, Vector3& size)
public void DrawCube(Vector3 center, Vector3 size)
private void INTERNAL_CALL_DrawCube(Vector3& center, Vector3& size)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawMesh(Mesh mesh, Vector3 position)
public void DrawMesh(Mesh mesh)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position)
public void DrawMesh(Mesh mesh, int submeshIndex)
private void INTERNAL_CALL_DrawMesh(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale)
public void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawWireMesh(Mesh mesh, Vector3 position)
public void DrawWireMesh(Mesh mesh)
public void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position)
public void DrawWireMesh(Mesh mesh, int submeshIndex)
private void INTERNAL_CALL_DrawWireMesh(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale)
public void DrawIcon(Vector3 center, string name, bool allowScaling)
public void DrawIcon(Vector3 center, string name)
private void INTERNAL_CALL_DrawIcon(Vector3& center, string name, bool allowScaling)
public void DrawGUITexture(Rect screenRect, Texture texture)
public void DrawGUITexture(Rect screenRect, Texture texture, Material mat)
public void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
private void INTERNAL_CALL_DrawGUITexture(Rect& screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public Color get_color()
public void set_color(Color value)
private void INTERNAL_get_color(Color& value)
private void INTERNAL_set_color(Color& value)
public Matrix4x4 get_matrix()
public void set_matrix(Matrix4x4 value)
private void INTERNAL_get_matrix(Matrix4x4& value)
private void INTERNAL_set_matrix(Matrix4x4& value)
public void DrawFrustum(Vector3 center, float fov, float maxRange, float minRange, float aspect)
private void INTERNAL_CALL_DrawFrustum(Vector3& center, float fov, float maxRange, float minRange, float aspect)
}
public UnityEngine.GL : object {
public int TRIANGLES
public int TRIANGLE_STRIP
public int QUADS
public int LINES
public int LINE_STRIP
public bool wireframe
public bool sRGBWrite
public bool invertCulling
public Matrix4x4 modelview
public void Vertex3(float x, float y, float z)
public void Vertex(Vector3 v)
public void TexCoord3(float x, float y, float z)
public void TexCoord(Vector3 v)
public void TexCoord2(float x, float y)
public void MultiTexCoord3(int unit, float x, float y, float z)
public void MultiTexCoord(int unit, Vector3 v)
public void MultiTexCoord2(int unit, float x, float y)
private void ImmediateColor(float r, float g, float b, float a)
public void Color(Color c)
public bool get_wireframe()
public void set_wireframe(bool value)
public bool get_sRGBWrite()
public void set_sRGBWrite(bool value)
public bool get_invertCulling()
public void set_invertCulling(bool value)
public void Flush()
public void RenderTargetBarrier()
private Matrix4x4 GetWorldViewMatrix()
private void SetViewMatrix(Matrix4x4 m)
public Matrix4x4 get_modelview()
public void set_modelview(Matrix4x4 value)
public void MultMatrix(Matrix4x4 m)
public void IssuePluginEvent(int eventID)
public void SetRevertBackfacing(bool revertBackFaces)
public void PushMatrix()
public void PopMatrix()
public void LoadIdentity()
public void LoadOrtho()
public void LoadPixelMatrix()
public void LoadProjectionMatrix(Matrix4x4 mat)
public void InvalidateState()
public Matrix4x4 GetGPUProjectionMatrix(Matrix4x4 proj, bool renderIntoTexture)
private void GLLoadPixelMatrixScript(float left, float right, float bottom, float top)
public void LoadPixelMatrix(float left, float right, float bottom, float top)
private void GLIssuePluginEvent(IntPtr callback, int eventID)
public void IssuePluginEvent(IntPtr callback, int eventID)
public void Begin(int mode)
public void End()
private void GLClear(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void Clear(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void Clear(bool clearDepth, bool clearColor, Color backgroundColor)
public void Viewport(Rect pixelRect)
public void ClearWithSkybox(bool clearDepth, Camera camera)
private void GetWorldViewMatrix_Injected(Matrix4x4& ret)
private void SetViewMatrix_Injected(Matrix4x4& m)
private void MultMatrix_Injected(Matrix4x4& m)
private void LoadProjectionMatrix_Injected(Matrix4x4& mat)
private void GetGPUProjectionMatrix_Injected(Matrix4x4& proj, bool renderIntoTexture, Matrix4x4& ret)
private void GLClear_Injected(bool clearDepth, bool clearColor, Color& backgroundColor, float depth)
private void Viewport_Injected(Rect& pixelRect)
}
internal UnityEngine.GlobalJavaObjectRef : object {
private bool m_disposed
protected IntPtr m_jobject
public void .ctor(IntPtr jobject)
protected void Finalize()
public IntPtr op_Implicit(GlobalJavaObjectRef obj)
public void Dispose()
}
public UnityEngine.Gradient : object {
internal IntPtr m_Ptr
public GradientColorKey[] colorKeys
public GradientAlphaKey[] alphaKeys
public GradientMode mode
private void Init()
private void Cleanup()
protected void Finalize()
public Color Evaluate(float time)
private void INTERNAL_CALL_Evaluate(Gradient self, float time, Color& value)
public GradientColorKey[] get_colorKeys()
public void set_colorKeys(GradientColorKey[] value)
public GradientAlphaKey[] get_alphaKeys()
public void set_alphaKeys(GradientAlphaKey[] value)
public GradientMode get_mode()
public void set_mode(GradientMode value)
public void SetKeys(GradientColorKey[] colorKeys, GradientAlphaKey[] alphaKeys)
}
public UnityEngine.GradientAlphaKey : ValueType {
public float alpha
public float time
public void .ctor(float alpha, float time)
}
public UnityEngine.GradientColorKey : ValueType {
public Color color
public float time
public void .ctor(Color col, float time)
}
public UnityEngine.GradientMode : Enum {
public int value__
public GradientMode Blend
public GradientMode Fixed
}
public UnityEngine.Graphics : object {
internal int kMaxDrawMeshInstanceCount
public RenderBuffer activeColorBuffer
public RenderBuffer activeDepthBuffer
public GraphicsTier activeTier
public ColorGamut activeColorGamut
private void Internal_DrawMeshNow1(Mesh mesh, int subsetIndex, Vector3 position, Quaternion rotation)
private void INTERNAL_CALL_Internal_DrawMeshNow1(Mesh mesh, int subsetIndex, Vector3& position, Quaternion& rotation)
private void Internal_DrawMeshNow2(Mesh mesh, int subsetIndex, Matrix4x4 matrix)
private void INTERNAL_CALL_Internal_DrawMeshNow2(Mesh mesh, int subsetIndex, Matrix4x4& matrix)
public void DrawProcedural(MeshTopology topology, int vertexCount, int instanceCount)
public void DrawProcedural(MeshTopology topology, int vertexCount)
public void DrawProceduralIndirect(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(MeshTopology topology, ComputeBuffer bufferWithArgs)
private int Internal_GetMaxDrawMeshInstanceCount()
public void DrawTexture(Rect screenRect, Texture texture, Material mat)
public void DrawTexture(Rect screenRect, Texture texture)
public void DrawTexture(Rect screenRect, Texture texture, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass)
internal void Internal_DrawTexture(Internal_DrawTextureArguments& args)
public GPUFence CreateGPUFence()
public GPUFence CreateGPUFence(SynchronisationStage stage)
private IntPtr Internal_CreateGPUFence(SynchronisationStage stage)
private void INTERNAL_CALL_Internal_CreateGPUFence(SynchronisationStage stage, IntPtr& value)
public void WaitOnGPUFence(GPUFence fence)
public void WaitOnGPUFence(GPUFence fence, SynchronisationStage stage)
private void WaitOnGPUFence_Internal(IntPtr fencePtr, SynchronisationStage stage)
public void ExecuteCommandBuffer(CommandBuffer buffer)
public void ExecuteCommandBufferAsync(CommandBuffer buffer, ComputeQueueType queueType)
private void Internal_SetNullRT()
private void Internal_SetRTSimple(RenderBuffer& color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice)
private void Internal_SetMRTFullSetup(RenderBuffer[] colorSA, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice, RenderBufferLoadAction[] colorLoadSA, RenderBufferStoreAction[] colorStoreSA, RenderBufferLoadAction depthLoad, RenderBufferStoreAction depthStore)
private void Internal_SetMRTSimple(RenderBuffer[] colorSA, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice)
public RenderBuffer get_activeColorBuffer()
public RenderBuffer get_activeDepthBuffer()
private void GetActiveColorBuffer(RenderBuffer& res)
private void GetActiveDepthBuffer(RenderBuffer& res)
public void SetRandomWriteTarget(int index, RenderTexture uav)
public void SetRandomWriteTarget(int index, ComputeBuffer uav)
public void SetRandomWriteTarget(int index, ComputeBuffer uav, bool preserveCounterValue)
public void ClearRandomWriteTargets()
private void Internal_SetRandomWriteTargetRT(int index, RenderTexture uav)
private void Internal_SetRandomWriteTargetBuffer(int index, ComputeBuffer uav, bool preserveCounterValue)
public GraphicsTier get_activeTier()
public void set_activeTier(GraphicsTier value)
public ColorGamut get_activeColorGamut()
private void CopyTexture_Full(Texture src, Texture dst)
private void CopyTexture_Slice_AllMips(Texture src, int srcElement, Texture dst, int dstElement)
private void CopyTexture_Slice(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip)
private void CopyTexture_Region(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY)
private bool ConvertTexture_Full(Texture src, Texture dst)
private bool ConvertTexture_Slice(Texture src, int srcElement, Texture dst, int dstElement)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
internal void Internal_DrawMesh(Mesh mesh, int submeshIndex, Matrix4x4 matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
internal void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
internal void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_BlitMaterial(Texture source, RenderTexture dest, Material mat, int pass, bool setRT)
private void Internal_BlitMultiTap(Texture source, RenderTexture dest, Material mat, Vector2[] offsets)
private void Blit2(Texture source, RenderTexture dest)
private void Blit4(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset)
internal void CheckLoadActionValid(RenderBufferLoadAction load, string bufferType)
internal void CheckStoreActionValid(RenderBufferStoreAction store, string bufferType)
internal void SetRenderTargetImpl(RenderTargetSetup setup)
internal void SetRenderTargetImpl(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
internal void SetRenderTargetImpl(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice)
internal void SetRenderTargetImpl(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderTexture rt)
public void SetRenderTarget(RenderTexture rt, int mipLevel)
public void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face)
public void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer)
public void SetRenderTarget(RenderTargetSetup setup)
public void CopyTexture(Texture src, Texture dst)
public void CopyTexture(Texture src, int srcElement, Texture dst, int dstElement)
public void CopyTexture(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip)
public void CopyTexture(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY)
public bool ConvertTexture(Texture src, Texture dst)
public bool ConvertTexture(Texture src, int srcElement, Texture dst, int dstElement)
private void DrawTextureImpl(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass)
public void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex)
public void DrawMeshNow(Mesh mesh, Matrix4x4 matrix)
public void DrawMeshNow(Mesh mesh, Matrix4x4 matrix, int materialIndex)
public void Blit(Texture source, RenderTexture dest)
public void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset)
public void Blit(Texture source, RenderTexture dest, Material mat, int pass)
public void Blit(Texture source, RenderTexture dest, Material mat)
public void Blit(Texture source, Material mat, int pass)
public void Blit(Texture source, Material mat)
public void BlitMultiTap(Texture source, RenderTexture dest, Material mat, Vector2[] offsets)
private void Internal_DrawMesh_Injected(Mesh mesh, int submeshIndex, Matrix4x4& matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedIndirect_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Blit4_Injected(Texture source, RenderTexture dest, Vector2& scale, Vector2& offset)
}
public UnityEngine.GUIElement : Behaviour {
public bool HitTest(Vector3 screenPosition, Camera camera)
public bool HitTest(Vector3 screenPosition)
private bool INTERNAL_CALL_HitTest(GUIElement self, Vector3& screenPosition, Camera camera)
public Rect GetScreenRect(Camera camera)
public Rect GetScreenRect()
private void INTERNAL_CALL_GetScreenRect(GUIElement self, Camera camera, Rect& value)
}
public UnityEngine.GUILayer : Behaviour {
public GUIElement HitTest(Vector3 screenPosition)
private GUIElement INTERNAL_CALL_HitTest(GUILayer self, Vector3& screenPosition)
}
public UnityEngine.GUITexture : GUIElement {
public Color color
public Texture texture
public Rect pixelInset
public RectOffset border
public Color get_color()
public void set_color(Color value)
private void INTERNAL_get_color(Color& value)
private void INTERNAL_set_color(Color& value)
public Texture get_texture()
public void set_texture(Texture value)
public Rect get_pixelInset()
public void set_pixelInset(Rect value)
private void INTERNAL_get_pixelInset(Rect& value)
private void INTERNAL_set_pixelInset(Rect& value)
public RectOffset get_border()
public void set_border(RectOffset value)
}
public UnityEngine.Gyroscope : object {
private int m_GyroIndex
public Vector3 rotationRate
public Vector3 rotationRateUnbiased
public Vector3 gravity
public Vector3 userAcceleration
public Quaternion attitude
public bool enabled
public float updateInterval
internal void .ctor(int index)
private Vector3 rotationRate_Internal(int idx)
private void INTERNAL_CALL_rotationRate_Internal(int idx, Vector3& value)
private Vector3 rotationRateUnbiased_Internal(int idx)
private void INTERNAL_CALL_rotationRateUnbiased_Internal(int idx, Vector3& value)
private Vector3 gravity_Internal(int idx)
private void INTERNAL_CALL_gravity_Internal(int idx, Vector3& value)
private Vector3 userAcceleration_Internal(int idx)
private void INTERNAL_CALL_userAcceleration_Internal(int idx, Vector3& value)
private Quaternion attitude_Internal(int idx)
private void INTERNAL_CALL_attitude_Internal(int idx, Quaternion& value)
private bool getEnabled_Internal(int idx)
private void setEnabled_Internal(int idx, bool enabled)
private float getUpdateInterval_Internal(int idx)
private void setUpdateInterval_Internal(int idx, float interval)
public Vector3 get_rotationRate()
public Vector3 get_rotationRateUnbiased()
public Vector3 get_gravity()
public Vector3 get_userAcceleration()
public Quaternion get_attitude()
public bool get_enabled()
public void set_enabled(bool value)
public float get_updateInterval()
public void set_updateInterval(float value)
}
public UnityEngine.Hash128 : ValueType {
private UInt32 m_u32_0
private UInt32 m_u32_1
private UInt32 m_u32_2
private UInt32 m_u32_3
public bool isValid
public void .ctor(UInt32 u32_0, UInt32 u32_1, UInt32 u32_2, UInt32 u32_3)
public bool get_isValid()
public string ToString()
public Hash128 Parse(string hashString)
internal string Internal_Hash128ToString(Hash128 hash128)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(Hash128 hash1, Hash128 hash2)
public bool op_Inequality(Hash128 hash1, Hash128 hash2)
private void Parse_Injected(string hashString, Hash128& ret)
private string Internal_Hash128ToString_Injected(Hash128& hash128)
}
public UnityEngine.HeaderAttribute : PropertyAttribute {
public string header
public void .ctor(string header)
}
public UnityEngine.HelpURLAttribute : Attribute {
internal string m_Url
public string URL
public void .ctor(string url)
public string get_URL()
}
public UnityEngine.HideFlags : Enum {
public int value__
public HideFlags None
public HideFlags HideInHierarchy
public HideFlags HideInInspector
public HideFlags DontSaveInEditor
public HideFlags NotEditable
public HideFlags DontSaveInBuild
public HideFlags DontUnloadUnusedAsset
public HideFlags DontSave
public HideFlags HideAndDontSave
}
public UnityEngine.HostData : object {
private int m_Nat
private string m_GameType
private string m_GameName
private int m_ConnectedPlayers
private int m_PlayerLimit
private String[] m_IP
private int m_Port
private int m_PasswordProtected
private string m_Comment
private string m_GUID
public bool useNat
public string gameType
public string gameName
public int connectedPlayers
public int playerLimit
public String[] ip
public int port
public bool passwordProtected
public string comment
public string guid
public bool get_useNat()
public void set_useNat(bool value)
public string get_gameType()
public void set_gameType(string value)
public string get_gameName()
public void set_gameName(string value)
public int get_connectedPlayers()
public void set_connectedPlayers(int value)
public int get_playerLimit()
public void set_playerLimit(int value)
public String[] get_ip()
public void set_ip(String[] value)
public int get_port()
public void set_port(int value)
public bool get_passwordProtected()
public void set_passwordProtected(bool value)
public string get_comment()
public void set_comment(string value)
public string get_guid()
public void set_guid(string value)
}
public UnityEngine.IExposedPropertyTable {
public void SetReferenceValue(PropertyName id, Object value)
public Object GetReferenceValue(PropertyName id, Boolean& idValid)
public void ClearReferenceValue(PropertyName id)
}
public UnityEngine.ILogger {
public ILogHandler logHandler
public bool logEnabled
public LogType filterLogType
public ILogHandler get_logHandler()
public void set_logHandler(ILogHandler value)
public bool get_logEnabled()
public void set_logEnabled(bool value)
public LogType get_filterLogType()
public void set_filterLogType(LogType value)
public bool IsLogTypeAllowed(LogType logType)
public void Log(LogType logType, object message)
public void Log(LogType logType, object message, Object context)
public void Log(LogType logType, string tag, object message)
public void Log(LogType logType, string tag, object message, Object context)
public void Log(object message)
public void Log(string tag, object message)
public void Log(string tag, object message, Object context)
public void LogWarning(string tag, object message)
public void LogWarning(string tag, object message, Object context)
public void LogError(string tag, object message)
public void LogError(string tag, object message, Object context)
public void LogFormat(LogType logType, string format, Object[] args)
public void LogException(Exception exception)
}
public UnityEngine.ILogHandler {
public void LogFormat(LogType logType, Object context, string format, Object[] args)
public void LogException(Exception exception, Object context)
}
public UnityEngine.IMECompositionMode : Enum {
public int value__
public IMECompositionMode Auto
public IMECompositionMode On
public IMECompositionMode Off
}
public UnityEngine.Input : object {
private Gyroscope m_MainGyro
private LocationService locationServiceInstance
private Compass compassInstance
public bool compensateSensors
public bool isGyroAvailable
public Gyroscope gyro
public Vector3 mousePosition
public Vector2 mouseScrollDelta
public bool mousePresent
public bool simulateMouseWithTouches
public bool anyKey
public bool anyKeyDown
public string inputString
public Vector3 acceleration
public AccelerationEvent[] accelerationEvents
public int accelerationEventCount
public Touch[] touches
public int touchCount
public bool eatKeyPressOnTextFieldFocus
public bool touchPressureSupported
public bool stylusTouchSupported
public bool touchSupported
public bool multiTouchEnabled
public LocationService location
public Compass compass
public DeviceOrientation deviceOrientation
public IMECompositionMode imeCompositionMode
public string compositionString
public bool imeIsSelected
public Vector2 compositionCursorPos
public bool backButtonLeavesApp
private int mainGyroIndex_Internal()
private bool GetKeyInt(int key)
private bool GetKeyString(string name)
private bool GetKeyUpInt(int key)
private bool GetKeyUpString(string name)
private bool GetKeyDownInt(int key)
private bool GetKeyDownString(string name)
public float GetAxis(string axisName)
public float GetAxisRaw(string axisName)
public bool GetButton(string buttonName)
public bool get_compensateSensors()
public void set_compensateSensors(bool value)
public bool get_isGyroAvailable()
public Gyroscope get_gyro()
public bool GetButtonDown(string buttonName)
public bool GetButtonUp(string buttonName)
public bool GetKey(string name)
public bool GetKey(KeyCode key)
public bool GetKeyDown(string name)
public bool GetKeyDown(KeyCode key)
public bool GetKeyUp(string name)
public bool GetKeyUp(KeyCode key)
public String[] GetJoystickNames()
public bool GetMouseButton(int button)
public bool GetMouseButtonDown(int button)
public bool GetMouseButtonUp(int button)
public void ResetInputAxes()
public Vector3 get_mousePosition()
private void INTERNAL_get_mousePosition(Vector3& value)
public Vector2 get_mouseScrollDelta()
private void INTERNAL_get_mouseScrollDelta(Vector2& value)
public bool get_mousePresent()
public bool get_simulateMouseWithTouches()
public void set_simulateMouseWithTouches(bool value)
public bool get_anyKey()
public bool get_anyKeyDown()
public string get_inputString()
public Vector3 get_acceleration()
private void INTERNAL_get_acceleration(Vector3& value)
public AccelerationEvent[] get_accelerationEvents()
public AccelerationEvent GetAccelerationEvent(int index)
private void INTERNAL_CALL_GetAccelerationEvent(int index, AccelerationEvent& value)
public int get_accelerationEventCount()
public Touch[] get_touches()
public Touch GetTouch(int index)
private void INTERNAL_CALL_GetTouch(int index, Touch& value)
public int get_touchCount()
public bool get_eatKeyPressOnTextFieldFocus()
public void set_eatKeyPressOnTextFieldFocus(bool value)
public bool get_touchPressureSupported()
public bool get_stylusTouchSupported()
public bool get_touchSupported()
public bool get_multiTouchEnabled()
public void set_multiTouchEnabled(bool value)
public LocationService get_location()
public Compass get_compass()
public DeviceOrientation get_deviceOrientation()
public IMECompositionMode get_imeCompositionMode()
public void set_imeCompositionMode(IMECompositionMode value)
public string get_compositionString()
public bool get_imeIsSelected()
public Vector2 get_compositionCursorPos()
public void set_compositionCursorPos(Vector2 value)
private void INTERNAL_get_compositionCursorPos(Vector2& value)
private void INTERNAL_set_compositionCursorPos(Vector2& value)
public bool get_backButtonLeavesApp()
public void set_backButtonLeavesApp(bool value)
}
internal UnityEngine.Internal_DrawTextureArguments : ValueType {
public Rect screenRect
public Rect sourceRect
public int leftBorder
public int rightBorder
public int topBorder
public int bottomBorder
public Color32 color
public Vector4 borderWidths
public Vector4 cornerRadiuses
public int pass
public Texture texture
public Material mat
}
public UnityEngine.Internal.DefaultValueAttribute : Attribute {
private object DefaultValue
public object Value
public void .ctor(string value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
}
internal UnityEngine.InternalStaticBatchingUtility : object {
private int MaxVerticesInBatch
private string CombinedMeshPrefix
private Func`2<Material, bool> <>f__am$cache0
public void CombineRoot(GameObject staticBatchRoot)
public void Combine(GameObject staticBatchRoot, bool combineOnlyStatic, bool isEditorPostprocessScene)
public void CombineGameObjects(GameObject[] gos, GameObject staticBatchRoot, bool isEditorPostprocessScene)
private void MakeBatch(List`1<MeshContainer> meshes, Transform staticBatchRootTransform, int batchIndex)
private bool <CombineGameObjects>m__0(Material m)
}
internal UnityEngine.IPlayerEditorConnectionNative {
public void Initialize()
public void DisconnectAll()
public void SendMessage(Guid messageId, Byte[] data, int playerId)
public void Poll()
public void RegisterInternal(Guid messageId)
public void UnregisterInternal(Guid messageId)
public bool IsConnected()
}
public UnityEngine.ISerializationCallbackReceiver {
public void OnBeforeSerialize()
public void OnAfterDeserialize()
}
public UnityEngine.Jobs.IJobParallelForTransform {
public void Execute(int index, TransformAccess transform)
}
public UnityEngine.Jobs.IJobParallelForTransformExtensions : object {
public JobHandle Schedule(T jobData, TransformAccessArray transforms, JobHandle dependsOn)
}
public UnityEngine.Jobs.TransformAccess : ValueType {
private IntPtr hierarchy
private int index
public Vector3 position
public Quaternion rotation
public Vector3 localPosition
public Quaternion localRotation
public Vector3 localScale
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Vector3 get_localPosition()
public void set_localPosition(Vector3 value)
public Quaternion get_localRotation()
public void set_localRotation(Quaternion value)
public Vector3 get_localScale()
public void set_localScale(Vector3 value)
private void GetPosition(TransformAccess& access, Vector3& p)
private void SetPosition(TransformAccess& access, Vector3& p)
private void GetRotation(TransformAccess& access, Quaternion& r)
private void SetRotation(TransformAccess& access, Quaternion& r)
private void GetLocalPosition(TransformAccess& access, Vector3& p)
private void SetLocalPosition(TransformAccess& access, Vector3& p)
private void GetLocalRotation(TransformAccess& access, Quaternion& r)
private void SetLocalRotation(TransformAccess& access, Quaternion& r)
private void GetLocalScale(TransformAccess& access, Vector3& r)
private void SetLocalScale(TransformAccess& access, Vector3& r)
}
public UnityEngine.Jobs.TransformAccessArray : ValueType {
private IntPtr m_TransformArray
public bool isCreated
public Transform Item
public int capacity
public int length
public void .ctor(Transform[] transforms, int desiredJobCount)
public void .ctor(int capacity, int desiredJobCount)
public void Allocate(int capacity, int desiredJobCount, TransformAccessArray& array)
public bool get_isCreated()
public void Dispose()
internal IntPtr GetTransformAccessArrayForSchedule()
public Transform get_Item(int index)
public void set_Item(int index, Transform value)
public int get_capacity()
public void set_capacity(int value)
public int get_length()
public void Add(Transform transform)
public void RemoveAtSwapBack(int index)
public void SetTransforms(Transform[] transforms)
private IntPtr Create(int capacity, int desiredJobCount)
private void DestroyTransformAccessArray(IntPtr transformArray)
private void SetTransforms(IntPtr transformArrayIntPtr, Transform[] transforms)
private void Add(IntPtr transformArrayIntPtr, Transform transform)
private void RemoveAtSwapBack(IntPtr transformArrayIntPtr, int index)
internal IntPtr GetSortedTransformAccess(IntPtr transformArrayIntPtr)
internal IntPtr GetSortedToUserIndex(IntPtr transformArrayIntPtr)
internal int GetLength(IntPtr transformArrayIntPtr)
internal int GetCapacity(IntPtr transformArrayIntPtr)
internal void SetCapacity(IntPtr transformArrayIntPtr, int capacity)
internal Transform GetTransform(IntPtr transformArrayIntPtr, int index)
internal void SetTransform(IntPtr transformArrayIntPtr, int index, Transform transform)
}
public UnityEngine.jvalue : ValueType {
public bool z
public byte b
public char c
public short s
public int i
public long j
public float f
public double d
public IntPtr l
}
public UnityEngine.KeyCode : Enum {
public int value__
public KeyCode None
public KeyCode Backspace
public KeyCode Delete
public KeyCode Tab
public KeyCode Clear
public KeyCode Return
public KeyCode Pause
public KeyCode Escape
public KeyCode Space
public KeyCode Keypad0
public KeyCode Keypad1
public KeyCode Keypad2
public KeyCode Keypad3
public KeyCode Keypad4
public KeyCode Keypad5
public KeyCode Keypad6
public KeyCode Keypad7
public KeyCode Keypad8
public KeyCode Keypad9
public KeyCode KeypadPeriod
public KeyCode KeypadDivide
public KeyCode KeypadMultiply
public KeyCode KeypadMinus
public KeyCode KeypadPlus
public KeyCode KeypadEnter
public KeyCode KeypadEquals
public KeyCode UpArrow
public KeyCode DownArrow
public KeyCode RightArrow
public KeyCode LeftArrow
public KeyCode Insert
public KeyCode Home
public KeyCode End
public KeyCode PageUp
public KeyCode PageDown
public KeyCode F1
public KeyCode F2
public KeyCode F3
public KeyCode F4
public KeyCode F5
public KeyCode F6
public KeyCode F7
public KeyCode F8
public KeyCode F9
public KeyCode F10
public KeyCode F11
public KeyCode F12
public KeyCode F13
public KeyCode F14
public KeyCode F15
public KeyCode Alpha0
public KeyCode Alpha1
public KeyCode Alpha2
public KeyCode Alpha3
public KeyCode Alpha4
public KeyCode Alpha5
public KeyCode Alpha6
public KeyCode Alpha7
public KeyCode Alpha8
public KeyCode Alpha9
public KeyCode Exclaim
public KeyCode DoubleQuote
public KeyCode Hash
public KeyCode Dollar
public KeyCode Ampersand
public KeyCode Quote
public KeyCode LeftParen
public KeyCode RightParen
public KeyCode Asterisk
public KeyCode Plus
public KeyCode Comma
public KeyCode Minus
public KeyCode Period
public KeyCode Slash
public KeyCode Colon
public KeyCode Semicolon
public KeyCode Less
public KeyCode Equals
public KeyCode Greater
public KeyCode Question
public KeyCode At
public KeyCode LeftBracket
public KeyCode Backslash
public KeyCode RightBracket
public KeyCode Caret
public KeyCode Underscore
public KeyCode BackQuote
public KeyCode A
public KeyCode B
public KeyCode C
public KeyCode D
public KeyCode E
public KeyCode F
public KeyCode G
public KeyCode H
public KeyCode I
public KeyCode J
public KeyCode K
public KeyCode L
public KeyCode M
public KeyCode N
public KeyCode O
public KeyCode P
public KeyCode Q
public KeyCode R
public KeyCode S
public KeyCode T
public KeyCode U
public KeyCode V
public KeyCode W
public KeyCode X
public KeyCode Y
public KeyCode Z
public KeyCode Numlock
public KeyCode CapsLock
public KeyCode ScrollLock
public KeyCode RightShift
public KeyCode LeftShift
public KeyCode RightControl
public KeyCode LeftControl
public KeyCode RightAlt
public KeyCode LeftAlt
public KeyCode LeftCommand
public KeyCode LeftApple
public KeyCode LeftWindows
public KeyCode RightCommand
public KeyCode RightApple
public KeyCode RightWindows
public KeyCode AltGr
public KeyCode Help
public KeyCode Print
public KeyCode SysReq
public KeyCode Break
public KeyCode Menu
public KeyCode Mouse0
public KeyCode Mouse1
public KeyCode Mouse2
public KeyCode Mouse3
public KeyCode Mouse4
public KeyCode Mouse5
public KeyCode Mouse6
public KeyCode JoystickButton0
public KeyCode JoystickButton1
public KeyCode JoystickButton2
public KeyCode JoystickButton3
public KeyCode JoystickButton4
public KeyCode JoystickButton5
public KeyCode JoystickButton6
public KeyCode JoystickButton7
public KeyCode JoystickButton8
public KeyCode JoystickButton9
public KeyCode JoystickButton10
public KeyCode JoystickButton11
public KeyCode JoystickButton12
public KeyCode JoystickButton13
public KeyCode JoystickButton14
public KeyCode JoystickButton15
public KeyCode JoystickButton16
public KeyCode JoystickButton17
public KeyCode JoystickButton18
public KeyCode JoystickButton19
public KeyCode Joystick1Button0
public KeyCode Joystick1Button1
public KeyCode Joystick1Button2
public KeyCode Joystick1Button3
public KeyCode Joystick1Button4
public KeyCode Joystick1Button5
public KeyCode Joystick1Button6
public KeyCode Joystick1Button7
public KeyCode Joystick1Button8
public KeyCode Joystick1Button9
public KeyCode Joystick1Button10
public KeyCode Joystick1Button11
public KeyCode Joystick1Button12
public KeyCode Joystick1Button13
public KeyCode Joystick1Button14
public KeyCode Joystick1Button15
public KeyCode Joystick1Button16
public KeyCode Joystick1Button17
public KeyCode Joystick1Button18
public KeyCode Joystick1Button19
public KeyCode Joystick2Button0
public KeyCode Joystick2Button1
public KeyCode Joystick2Button2
public KeyCode Joystick2Button3
public KeyCode Joystick2Button4
public KeyCode Joystick2Button5
public KeyCode Joystick2Button6
public KeyCode Joystick2Button7
public KeyCode Joystick2Button8
public KeyCode Joystick2Button9
public KeyCode Joystick2Button10
public KeyCode Joystick2Button11
public KeyCode Joystick2Button12
public KeyCode Joystick2Button13
public KeyCode Joystick2Button14
public KeyCode Joystick2Button15
public KeyCode Joystick2Button16
public KeyCode Joystick2Button17
public KeyCode Joystick2Button18
public KeyCode Joystick2Button19
public KeyCode Joystick3Button0
public KeyCode Joystick3Button1
public KeyCode Joystick3Button2
public KeyCode Joystick3Button3
public KeyCode Joystick3Button4
public KeyCode Joystick3Button5
public KeyCode Joystick3Button6
public KeyCode Joystick3Button7
public KeyCode Joystick3Button8
public KeyCode Joystick3Button9
public KeyCode Joystick3Button10
public KeyCode Joystick3Button11
public KeyCode Joystick3Button12
public KeyCode Joystick3Button13
public KeyCode Joystick3Button14
public KeyCode Joystick3Button15
public KeyCode Joystick3Button16
public KeyCode Joystick3Button17
public KeyCode Joystick3Button18
public KeyCode Joystick3Button19
public KeyCode Joystick4Button0
public KeyCode Joystick4Button1
public KeyCode Joystick4Button2
public KeyCode Joystick4Button3
public KeyCode Joystick4Button4
public KeyCode Joystick4Button5
public KeyCode Joystick4Button6
public KeyCode Joystick4Button7
public KeyCode Joystick4Button8
public KeyCode Joystick4Button9
public KeyCode Joystick4Button10
public KeyCode Joystick4Button11
public KeyCode Joystick4Button12
public KeyCode Joystick4Button13
public KeyCode Joystick4Button14
public KeyCode Joystick4Button15
public KeyCode Joystick4Button16
public KeyCode Joystick4Button17
public KeyCode Joystick4Button18
public KeyCode Joystick4Button19
public KeyCode Joystick5Button0
public KeyCode Joystick5Button1
public KeyCode Joystick5Button2
public KeyCode Joystick5Button3
public KeyCode Joystick5Button4
public KeyCode Joystick5Button5
public KeyCode Joystick5Button6
public KeyCode Joystick5Button7
public KeyCode Joystick5Button8
public KeyCode Joystick5Button9
public KeyCode Joystick5Button10
public KeyCode Joystick5Button11
public KeyCode Joystick5Button12
public KeyCode Joystick5Button13
public KeyCode Joystick5Button14
public KeyCode Joystick5Button15
public KeyCode Joystick5Button16
public KeyCode Joystick5Button17
public KeyCode Joystick5Button18
public KeyCode Joystick5Button19
public KeyCode Joystick6Button0
public KeyCode Joystick6Button1
public KeyCode Joystick6Button2
public KeyCode Joystick6Button3
public KeyCode Joystick6Button4
public KeyCode Joystick6Button5
public KeyCode Joystick6Button6
public KeyCode Joystick6Button7
public KeyCode Joystick6Button8
public KeyCode Joystick6Button9
public KeyCode Joystick6Button10
public KeyCode Joystick6Button11
public KeyCode Joystick6Button12
public KeyCode Joystick6Button13
public KeyCode Joystick6Button14
public KeyCode Joystick6Button15
public KeyCode Joystick6Button16
public KeyCode Joystick6Button17
public KeyCode Joystick6Button18
public KeyCode Joystick6Button19
public KeyCode Joystick7Button0
public KeyCode Joystick7Button1
public KeyCode Joystick7Button2
public KeyCode Joystick7Button3
public KeyCode Joystick7Button4
public KeyCode Joystick7Button5
public KeyCode Joystick7Button6
public KeyCode Joystick7Button7
public KeyCode Joystick7Button8
public KeyCode Joystick7Button9
public KeyCode Joystick7Button10
public KeyCode Joystick7Button11
public KeyCode Joystick7Button12
public KeyCode Joystick7Button13
public KeyCode Joystick7Button14
public KeyCode Joystick7Button15
public KeyCode Joystick7Button16
public KeyCode Joystick7Button17
public KeyCode Joystick7Button18
public KeyCode Joystick7Button19
public KeyCode Joystick8Button0
public KeyCode Joystick8Button1
public KeyCode Joystick8Button2
public KeyCode Joystick8Button3
public KeyCode Joystick8Button4
public KeyCode Joystick8Button5
public KeyCode Joystick8Button6
public KeyCode Joystick8Button7
public KeyCode Joystick8Button8
public KeyCode Joystick8Button9
public KeyCode Joystick8Button10
public KeyCode Joystick8Button11
public KeyCode Joystick8Button12
public KeyCode Joystick8Button13
public KeyCode Joystick8Button14
public KeyCode Joystick8Button15
public KeyCode Joystick8Button16
public KeyCode Joystick8Button17
public KeyCode Joystick8Button18
public KeyCode Joystick8Button19
}
public UnityEngine.Keyframe : ValueType {
private float m_Time
private float m_Value
private float m_InTangent
private float m_OutTangent
private int m_WeightedMode
private float m_InWeight
private float m_OutWeight
public float time
public float value
public float inTangent
public float outTangent
public float inWeight
public float outWeight
public WeightedMode weightedMode
public int tangentMode
internal int tangentModeInternal
public void .ctor(float time, float value)
public void .ctor(float time, float value, float inTangent, float outTangent)
public void .ctor(float time, float value, float inTangent, float outTangent, float inWeight, float outWeight)
public float get_time()
public void set_time(float value)
public float get_value()
public void set_value(float value)
public float get_inTangent()
public void set_inTangent(float value)
public float get_outTangent()
public void set_outTangent(float value)
public float get_inWeight()
public void set_inWeight(float value)
public float get_outWeight()
public void set_outWeight(float value)
public WeightedMode get_weightedMode()
public void set_weightedMode(WeightedMode value)
public int get_tangentMode()
public void set_tangentMode(int value)
internal int get_tangentModeInternal()
internal void set_tangentModeInternal(int value)
}
public UnityEngine.LayerMask : ValueType {
private int m_Mask
public int value
public int op_Implicit(LayerMask mask)
public LayerMask op_Implicit(int intVal)
public int get_value()
public void set_value(int value)
public string LayerToName(int layer)
public int NameToLayer(string layerName)
public int GetMask(String[] layerNames)
}
public UnityEngine.LensFlare : Behaviour {
public float brightness
public float fadeSpeed
public Color color
public Flare flare
public float get_brightness()
public void set_brightness(float value)
public float get_fadeSpeed()
public void set_fadeSpeed(float value)
public Color get_color()
public void set_color(Color value)
public Flare get_flare()
public void set_flare(Flare value)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
}
public UnityEngine.Light : Behaviour {
private int m_BakedIndex
public LightShadows shadows
public float shadowStrength
public LightShadowResolution shadowResolution
public float shadowSoftness
public float shadowSoftnessFade
public float cookieSize
public Texture cookie
public LightRenderMode renderMode
public int bakedIndex
public int commandBufferCount
public int pixelLightCount
public float shadowConstantBias
public float shadowObjectSizeBias
public bool attenuate
public LightType type
public float spotAngle
public Color color
public float colorTemperature
public float intensity
public float bounceIntensity
public int shadowCustomResolution
public float shadowBias
public float shadowNormalBias
public float shadowNearPlane
public float range
public Flare flare
public LightBakingOutput bakingOutput
public int cullingMask
public LightShadows get_shadows()
public void set_shadows(LightShadows value)
public float get_shadowStrength()
public void set_shadowStrength(float value)
public LightShadowResolution get_shadowResolution()
public void set_shadowResolution(LightShadowResolution value)
public float get_shadowSoftness()
public void set_shadowSoftness(float value)
public float get_shadowSoftnessFade()
public void set_shadowSoftnessFade(float value)
public float get_cookieSize()
public void set_cookieSize(float value)
public Texture get_cookie()
public void set_cookie(Texture value)
public LightRenderMode get_renderMode()
public void set_renderMode(LightRenderMode value)
public int get_bakedIndex()
public void set_bakedIndex(int value)
private void SetFalloffTable(Single[] input)
private void SetAllLightsFalloffToInverseSquared()
private void SetAllLightsFalloffToUnityLegacy()
public void SetLightDirty()
public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer)
public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask)
public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask, ComputeQueueType queueType)
public void RemoveCommandBuffer(LightEvent evt, CommandBuffer buffer)
public void RemoveCommandBuffers(LightEvent evt)
public void RemoveAllCommandBuffers()
public CommandBuffer[] GetCommandBuffers(LightEvent evt)
public int get_commandBufferCount()
public int get_pixelLightCount()
public void set_pixelLightCount(int value)
public Light[] GetLights(LightType type, int layer)
public float get_shadowConstantBias()
public void set_shadowConstantBias(float value)
public float get_shadowObjectSizeBias()
public void set_shadowObjectSizeBias(float value)
public bool get_attenuate()
public void set_attenuate(bool value)
public LightType get_type()
public void set_type(LightType value)
public float get_spotAngle()
public void set_spotAngle(float value)
public Color get_color()
public void set_color(Color value)
public float get_colorTemperature()
public void set_colorTemperature(float value)
public float get_intensity()
public void set_intensity(float value)
public float get_bounceIntensity()
public void set_bounceIntensity(float value)
public int get_shadowCustomResolution()
public void set_shadowCustomResolution(int value)
public float get_shadowBias()
public void set_shadowBias(float value)
public float get_shadowNormalBias()
public void set_shadowNormalBias(float value)
public float get_shadowNearPlane()
public void set_shadowNearPlane(float value)
public float get_range()
public void set_range(float value)
public Flare get_flare()
public void set_flare(Flare value)
public LightBakingOutput get_bakingOutput()
public void set_bakingOutput(LightBakingOutput value)
public int get_cullingMask()
public void set_cullingMask(int value)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
private void get_bakingOutput_Injected(LightBakingOutput& ret)
private void set_bakingOutput_Injected(LightBakingOutput& value)
}
public UnityEngine.LightBakingOutput : ValueType {
public int probeOcclusionLightIndex
public int occlusionMaskChannel
public LightmapBakeType lightmapBakeType
public MixedLightingMode mixedLightingMode
public bool isBaked
}
public UnityEngine.LightmapBakeType : Enum {
public int value__
public LightmapBakeType Realtime
public LightmapBakeType Baked
public LightmapBakeType Mixed
}
public UnityEngine.LightmapData : object {
internal Texture2D m_Light
internal Texture2D m_Dir
internal Texture2D m_ShadowMask
public Texture2D lightmapLight
public Texture2D lightmapColor
public Texture2D lightmapDir
public Texture2D shadowMask
public Texture2D get_lightmapLight()
public void set_lightmapLight(Texture2D value)
public Texture2D get_lightmapColor()
public void set_lightmapColor(Texture2D value)
public Texture2D get_lightmapDir()
public void set_lightmapDir(Texture2D value)
public Texture2D get_shadowMask()
public void set_shadowMask(Texture2D value)
}
public UnityEngine.LightmapSettings : Object {
public LightmapData[] lightmaps
public LightmapsMode lightmapsMode
public LightProbes lightProbes
public LightmapsModeLegacy lightmapsModeLegacy
public ColorSpace bakedColorSpace
public LightmapData[] get_lightmaps()
public void set_lightmaps(LightmapData[] value)
public LightmapsMode get_lightmapsMode()
public void set_lightmapsMode(LightmapsMode value)
public LightProbes get_lightProbes()
public void set_lightProbes(LightProbes value)
internal void Reset()
public LightmapsModeLegacy get_lightmapsModeLegacy()
public void set_lightmapsModeLegacy(LightmapsModeLegacy value)
public ColorSpace get_bakedColorSpace()
public void set_bakedColorSpace(ColorSpace value)
}
public UnityEngine.LightmapsMode : Enum {
public int value__
public LightmapsMode NonDirectional
public LightmapsMode CombinedDirectional
}
public UnityEngine.LightmapsModeLegacy : Enum {
public int value__
public LightmapsModeLegacy Single
public LightmapsModeLegacy Dual
public LightmapsModeLegacy Directional
}
public UnityEngine.LightProbeGroup : Behaviour {
public Vector3[] probePositions
public Vector3[] get_probePositions()
public void set_probePositions(Vector3[] value)
}
public UnityEngine.LightProbeProxyVolume : Behaviour {
public Bounds boundsGlobal
public Vector3 sizeCustom
public Vector3 originCustom
public BoundingBoxMode boundingBoxMode
public ResolutionMode resolutionMode
public ProbePositionMode probePositionMode
public RefreshMode refreshMode
public float probeDensity
public int gridResolutionX
public int gridResolutionY
public int gridResolutionZ
public bool isFeatureSupported
public Bounds get_boundsGlobal()
private void INTERNAL_get_boundsGlobal(Bounds& value)
public Vector3 get_sizeCustom()
public void set_sizeCustom(Vector3 value)
private void INTERNAL_get_sizeCustom(Vector3& value)
private void INTERNAL_set_sizeCustom(Vector3& value)
public Vector3 get_originCustom()
public void set_originCustom(Vector3 value)
private void INTERNAL_get_originCustom(Vector3& value)
private void INTERNAL_set_originCustom(Vector3& value)
public BoundingBoxMode get_boundingBoxMode()
public void set_boundingBoxMode(BoundingBoxMode value)
public ResolutionMode get_resolutionMode()
public void set_resolutionMode(ResolutionMode value)
public ProbePositionMode get_probePositionMode()
public void set_probePositionMode(ProbePositionMode value)
public RefreshMode get_refreshMode()
public void set_refreshMode(RefreshMode value)
public float get_probeDensity()
public void set_probeDensity(float value)
public int get_gridResolutionX()
public void set_gridResolutionX(int value)
public int get_gridResolutionY()
public void set_gridResolutionY(int value)
public int get_gridResolutionZ()
public void set_gridResolutionZ(int value)
public void Update()
public bool get_isFeatureSupported()
}
public UnityEngine.LightProbes : Object {
public Vector3[] positions
public SphericalHarmonicsL2[] bakedProbes
public int count
public int cellCount
public Single[] coefficients
public void GetInterpolatedProbe(Vector3 position, Renderer renderer, SphericalHarmonicsL2& probe)
private void INTERNAL_CALL_GetInterpolatedProbe(Vector3& position, Renderer renderer, SphericalHarmonicsL2& probe)
public void CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes)
public void CalculateInterpolatedLightAndOcclusionProbes(List`1<Vector3> positions, List`1<SphericalHarmonicsL2> lightProbes, List`1<Vector4> occlusionProbes)
internal void Internal_CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, int count, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes)
public Vector3[] get_positions()
public SphericalHarmonicsL2[] get_bakedProbes()
public void set_bakedProbes(SphericalHarmonicsL2[] value)
public int get_count()
public int get_cellCount()
internal bool AreLightProbesAllowed(Renderer renderer)
public void GetInterpolatedLightProbe(Vector3 position, Renderer renderer, Single[] coefficients)
public Single[] get_coefficients()
public void set_coefficients(Single[] value)
}
public UnityEngine.LightRenderMode : Enum {
public int value__
public LightRenderMode Auto
public LightRenderMode ForcePixel
public LightRenderMode ForceVertex
}
public UnityEngine.LightShadows : Enum {
public int value__
public LightShadows None
public LightShadows Hard
public LightShadows Soft
}
public UnityEngine.LightType : Enum {
public int value__
public LightType Spot
public LightType Directional
public LightType Point
public LightType Area
}
public UnityEngine.LineAlignment : Enum {
public int value__
public LineAlignment View
public LineAlignment Local
}
public UnityEngine.LineRenderer : Renderer {
public int numPositions
public float startWidth
public float endWidth
public float widthMultiplier
public int numCornerVertices
public int numCapVertices
public bool useWorldSpace
public bool loop
public Color startColor
public Color endColor
public int positionCount
public bool generateLightingData
public LineTextureMode textureMode
public LineAlignment alignment
public AnimationCurve widthCurve
public Gradient colorGradient
public void SetWidth(float start, float end)
public void SetColors(Color start, Color end)
public void SetVertexCount(int count)
public int get_numPositions()
public void set_numPositions(int value)
public float get_startWidth()
public void set_startWidth(float value)
public float get_endWidth()
public void set_endWidth(float value)
public float get_widthMultiplier()
public void set_widthMultiplier(float value)
public int get_numCornerVertices()
public void set_numCornerVertices(int value)
public int get_numCapVertices()
public void set_numCapVertices(int value)
public bool get_useWorldSpace()
public void set_useWorldSpace(bool value)
public bool get_loop()
public void set_loop(bool value)
public Color get_startColor()
public void set_startColor(Color value)
public Color get_endColor()
public void set_endColor(Color value)
public int get_positionCount()
public void set_positionCount(int value)
public void SetPosition(int index, Vector3 position)
public Vector3 GetPosition(int index)
public bool get_generateLightingData()
public void set_generateLightingData(bool value)
public LineTextureMode get_textureMode()
public void set_textureMode(LineTextureMode value)
public LineAlignment get_alignment()
public void set_alignment(LineAlignment value)
public void Simplify(float tolerance)
public AnimationCurve get_widthCurve()
public void set_widthCurve(AnimationCurve value)
public Gradient get_colorGradient()
public void set_colorGradient(Gradient value)
private AnimationCurve GetWidthCurveCopy()
private void SetWidthCurve(AnimationCurve curve)
private Gradient GetColorGradientCopy()
private void SetColorGradient(Gradient curve)
public int GetPositions(Vector3[] positions)
public void SetPositions(Vector3[] positions)
private void get_startColor_Injected(Color& ret)
private void set_startColor_Injected(Color& value)
private void get_endColor_Injected(Color& ret)
private void set_endColor_Injected(Color& value)
private void SetPosition_Injected(int index, Vector3& position)
private void GetPosition_Injected(int index, Vector3& ret)
}
public UnityEngine.LineTextureMode : Enum {
public int value__
public LineTextureMode Stretch
public LineTextureMode Tile
public LineTextureMode DistributePerSegment
public LineTextureMode RepeatPerSegment
}
public UnityEngine.LineUtility : object {
internal void GeneratePointsToKeep3D(object pointsList, float tolerance, object pointsToKeepList)
internal void GeneratePointsToKeep2D(object pointsList, float tolerance, object pointsToKeepList)
internal void GenerateSimplifiedPoints3D(object pointsList, float tolerance, object simplifiedPoints)
internal void GenerateSimplifiedPoints2D(object pointsList, float tolerance, object simplifiedPoints)
public void Simplify(List`1<Vector3> points, float tolerance, List`1<int> pointsToKeep)
public void Simplify(List`1<Vector3> points, float tolerance, List`1<Vector3> simplifiedPoints)
public void Simplify(List`1<Vector2> points, float tolerance, List`1<int> pointsToKeep)
public void Simplify(List`1<Vector2> points, float tolerance, List`1<Vector2> simplifiedPoints)
}
public UnityEngine.LocationInfo : ValueType {
private double m_Timestamp
private float m_Latitude
private float m_Longitude
private float m_Altitude
private float m_HorizontalAccuracy
private float m_VerticalAccuracy
public float latitude
public float longitude
public float altitude
public float horizontalAccuracy
public float verticalAccuracy
public double timestamp
public float get_latitude()
public float get_longitude()
public float get_altitude()
public float get_horizontalAccuracy()
public float get_verticalAccuracy()
public double get_timestamp()
}
public UnityEngine.LocationService : object {
public bool isEnabledByUser
public LocationServiceStatus status
public LocationInfo lastData
public bool get_isEnabledByUser()
public LocationServiceStatus get_status()
public LocationInfo get_lastData()
public void Start(float desiredAccuracyInMeters, float updateDistanceInMeters)
public void Start(float desiredAccuracyInMeters)
public void Start()
public void Stop()
}
public UnityEngine.LocationServiceStatus : Enum {
public int value__
public LocationServiceStatus Stopped
public LocationServiceStatus Initializing
public LocationServiceStatus Running
public LocationServiceStatus Failed
}
public UnityEngine.LOD : ValueType {
public float screenRelativeTransitionHeight
public float fadeTransitionWidth
public Renderer[] renderers
public void .ctor(float screenRelativeTransitionHeight, Renderer[] renderers)
}
public UnityEngine.LODFadeMode : Enum {
public int value__
public LODFadeMode None
public LODFadeMode CrossFade
public LODFadeMode SpeedTree
}
public UnityEngine.LODGroup : Component {
public Vector3 localReferencePoint
public float size
public int lodCount
public LODFadeMode fadeMode
public bool animateCrossFading
public bool enabled
public float crossFadeAnimationDuration
public Vector3 get_localReferencePoint()
public void set_localReferencePoint(Vector3 value)
private void INTERNAL_get_localReferencePoint(Vector3& value)
private void INTERNAL_set_localReferencePoint(Vector3& value)
public float get_size()
public void set_size(float value)
public int get_lodCount()
public LODFadeMode get_fadeMode()
public void set_fadeMode(LODFadeMode value)
public bool get_animateCrossFading()
public void set_animateCrossFading(bool value)
public bool get_enabled()
public void set_enabled(bool value)
public void RecalculateBounds()
public LOD[] GetLODs()
public void SetLODS(LOD[] lods)
public void SetLODs(LOD[] lods)
public void ForceLOD(int index)
public float get_crossFadeAnimationDuration()
public void set_crossFadeAnimationDuration(float value)
}
public UnityEngine.Logger : object {
private string kNoTagFormat
private string kTagFormat
private ILogHandler <logHandler>k__BackingField
private bool <logEnabled>k__BackingField
private LogType <filterLogType>k__BackingField
public ILogHandler logHandler
public bool logEnabled
public LogType filterLogType
public void .ctor(ILogHandler logHandler)
public ILogHandler get_logHandler()
public void set_logHandler(ILogHandler value)
public bool get_logEnabled()
public void set_logEnabled(bool value)
public LogType get_filterLogType()
public void set_filterLogType(LogType value)
public bool IsLogTypeAllowed(LogType logType)
private string GetString(object message)
public void Log(LogType logType, object message)
public void Log(LogType logType, object message, Object context)
public void Log(LogType logType, string tag, object message)
public void Log(LogType logType, string tag, object message, Object context)
public void Log(object message)
public void Log(string tag, object message)
public void Log(string tag, object message, Object context)
public void LogWarning(string tag, object message)
public void LogWarning(string tag, object message, Object context)
public void LogError(string tag, object message)
public void LogError(string tag, object message, Object context)
public void LogFormat(LogType logType, string format, Object[] args)
public void LogException(Exception exception)
public void LogFormat(LogType logType, Object context, string format, Object[] args)
public void LogException(Exception exception, Object context)
}
public UnityEngine.LogType : Enum {
public int value__
public LogType Error
public LogType Assert
public LogType Warning
public LogType Log
public LogType Exception
}
internal UnityEngine.ManagedStreamHelpers : object {
internal void ValidateLoadFromStream(Stream stream)
internal void ManagedStreamRead(Byte[] buffer, int offset, int count, Stream stream, IntPtr returnValueAddress)
internal void ManagedStreamSeek(long offset, UInt32 origin, Stream stream, IntPtr returnValueAddress)
internal void ManagedStreamLength(Stream stream, IntPtr returnValueAddress)
}
public UnityEngine.MasterServer : object {
public string ipAddress
public int port
public int updateRate
public bool dedicatedServer
public string get_ipAddress()
public void set_ipAddress(string value)
public int get_port()
public void set_port(int value)
public void RequestHostList(string gameTypeName)
public HostData[] PollHostList()
public void RegisterHost(string gameTypeName, string gameName, string comment)
public void RegisterHost(string gameTypeName, string gameName)
public void UnregisterHost()
public void ClearHostList()
public int get_updateRate()
public void set_updateRate(int value)
public bool get_dedicatedServer()
public void set_dedicatedServer(bool value)
}
public UnityEngine.MasterServerEvent : Enum {
public int value__
public MasterServerEvent RegistrationFailedGameName
public MasterServerEvent RegistrationFailedGameType
public MasterServerEvent RegistrationFailedNoServer
public MasterServerEvent RegistrationSucceeded
public MasterServerEvent HostListReceived
}
public UnityEngine.Material : Object {
public String[] shaderKeywords
public Shader shader
public Color color
public Texture mainTexture
public Vector2 mainTextureOffset
public Vector2 mainTextureScale
public int renderQueue
public MaterialGlobalIlluminationFlags globalIlluminationFlags
public bool doubleSidedGI
public bool enableInstancing
public int passCount
public void .ctor(Shader shader)
public void .ctor(Material source)
public void .ctor(string contents)
public void Lerp(Material start, Material end, float t)
public bool SetPass(int pass)
public Material Create(string scriptContents)
public void CopyPropertiesFromMaterial(Material mat)
public String[] get_shaderKeywords()
public void set_shaderKeywords(String[] value)
private void CreateWithShader(Material self, Shader shader)
private void CreateWithMaterial(Material self, Material source)
private void CreateWithString(Material self)
internal Material GetDefaultMaterial()
internal Material GetDefaultParticleMaterial()
internal Material GetDefaultLineMaterial()
public Shader get_shader()
public void set_shader(Shader value)
public Color get_color()
public void set_color(Color value)
public Texture get_mainTexture()
public void set_mainTexture(Texture value)
public Vector2 get_mainTextureOffset()
public void set_mainTextureOffset(Vector2 value)
public Vector2 get_mainTextureScale()
public void set_mainTextureScale(Vector2 value)
public bool HasProperty(int name)
public bool HasProperty(string name)
public int get_renderQueue()
public void set_renderQueue(int value)
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
public bool IsKeywordEnabled(string keyword)
public MaterialGlobalIlluminationFlags get_globalIlluminationFlags()
public void set_globalIlluminationFlags(MaterialGlobalIlluminationFlags value)
public bool get_doubleSidedGI()
public void set_doubleSidedGI(bool value)
public bool get_enableInstancing()
public void set_enableInstancing(bool value)
public int get_passCount()
public void SetShaderPassEnabled(string passName, bool enabled)
public bool GetShaderPassEnabled(string passName)
public string GetPassName(int pass)
public int FindPass(string passName)
public void SetOverrideTag(string tag, string val)
private string GetTagImpl(string tag, bool currentSubShaderOnly, string defaultValue)
public string GetTag(string tag, bool searchFallbacks, string defaultValue)
public string GetTag(string tag, bool searchFallbacks)
private void SetFloatImpl(int name, float value)
private void SetColorImpl(int name, Color value)
private void SetMatrixImpl(int name, Matrix4x4 value)
private void SetTextureImpl(int name, Texture value)
private void SetBufferImpl(int name, ComputeBuffer value)
private float GetFloatImpl(int name)
private Color GetColorImpl(int name)
private Matrix4x4 GetMatrixImpl(int name)
private Texture GetTextureImpl(int name)
private void SetFloatArrayImpl(int name, Single[] values, int count)
private void SetVectorArrayImpl(int name, Vector4[] values, int count)
private void SetColorArrayImpl(int name, Color[] values, int count)
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetFloatArrayImpl(int name)
private Vector4[] GetVectorArrayImpl(int name)
private Color[] GetColorArrayImpl(int name)
private Matrix4x4[] GetMatrixArrayImpl(int name)
private int GetFloatArrayCountImpl(int name)
private int GetVectorArrayCountImpl(int name)
private int GetColorArrayCountImpl(int name)
private int GetMatrixArrayCountImpl(int name)
private void ExtractFloatArrayImpl(int name, Single[] val)
private void ExtractVectorArrayImpl(int name, Vector4[] val)
private void ExtractColorArrayImpl(int name, Color[] val)
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val)
private Vector4 GetTextureScaleAndOffsetImpl(int name)
private void SetTextureOffsetImpl(int name, Vector2 offset)
private void SetTextureScaleImpl(int name, Vector2 scale)
private void SetFloatArray(int name, Single[] values, int count)
private void SetVectorArray(int name, Vector4[] values, int count)
private void SetColorArray(int name, Color[] values, int count)
private void SetMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractFloatArray(int name, List`1<float> values)
private void ExtractVectorArray(int name, List`1<Vector4> values)
private void ExtractColorArray(int name, List`1<Color> values)
private void ExtractMatrixArray(int name, List`1<Matrix4x4> values)
public void SetFloat(string name, float value)
public void SetFloat(int name, float value)
public void SetInt(string name, int value)
public void SetInt(int name, int value)
public void SetColor(string name, Color value)
public void SetColor(int name, Color value)
public void SetVector(string name, Vector4 value)
public void SetVector(int name, Vector4 value)
public void SetMatrix(string name, Matrix4x4 value)
public void SetMatrix(int name, Matrix4x4 value)
public void SetTexture(string name, Texture value)
public void SetTexture(int name, Texture value)
public void SetBuffer(string name, ComputeBuffer value)
public void SetBuffer(int name, ComputeBuffer value)
public void SetFloatArray(string name, List`1<float> values)
public void SetFloatArray(int name, List`1<float> values)
public void SetFloatArray(string name, Single[] values)
public void SetFloatArray(int name, Single[] values)
public void SetColorArray(string name, List`1<Color> values)
public void SetColorArray(int name, List`1<Color> values)
public void SetColorArray(string name, Color[] values)
public void SetColorArray(int name, Color[] values)
public void SetVectorArray(string name, List`1<Vector4> values)
public void SetVectorArray(int name, List`1<Vector4> values)
public void SetVectorArray(string name, Vector4[] values)
public void SetVectorArray(int name, Vector4[] values)
public void SetMatrixArray(string name, List`1<Matrix4x4> values)
public void SetMatrixArray(int name, List`1<Matrix4x4> values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetMatrixArray(int name, Matrix4x4[] values)
public float GetFloat(string name)
public float GetFloat(int name)
public int GetInt(string name)
public int GetInt(int name)
public Color GetColor(string name)
public Color GetColor(int name)
public Vector4 GetVector(string name)
public Vector4 GetVector(int name)
public Matrix4x4 GetMatrix(string name)
public Matrix4x4 GetMatrix(int name)
public Texture GetTexture(string name)
public Texture GetTexture(int name)
public Single[] GetFloatArray(string name)
public Single[] GetFloatArray(int name)
public Color[] GetColorArray(string name)
public Color[] GetColorArray(int name)
public Vector4[] GetVectorArray(string name)
public Vector4[] GetVectorArray(int name)
public Matrix4x4[] GetMatrixArray(string name)
public Matrix4x4[] GetMatrixArray(int name)
public void GetFloatArray(string name, List`1<float> values)
public void GetFloatArray(int name, List`1<float> values)
public void GetColorArray(string name, List`1<Color> values)
public void GetColorArray(int name, List`1<Color> values)
public void GetVectorArray(string name, List`1<Vector4> values)
public void GetVectorArray(int name, List`1<Vector4> values)
public void GetMatrixArray(string name, List`1<Matrix4x4> values)
public void GetMatrixArray(int name, List`1<Matrix4x4> values)
public void SetTextureOffset(string name, Vector2 value)
public void SetTextureOffset(int name, Vector2 value)
public void SetTextureScale(string name, Vector2 value)
public void SetTextureScale(int name, Vector2 value)
public Vector2 GetTextureOffset(string name)
public Vector2 GetTextureOffset(int name)
public Vector2 GetTextureScale(string name)
public Vector2 GetTextureScale(int name)
private void SetColorImpl_Injected(int name, Color& value)
private void SetMatrixImpl_Injected(int name, Matrix4x4& value)
private void GetColorImpl_Injected(int name, Color& ret)
private void GetMatrixImpl_Injected(int name, Matrix4x4& ret)
private void GetTextureScaleAndOffsetImpl_Injected(int name, Vector4& ret)
private void SetTextureOffsetImpl_Injected(int name, Vector2& offset)
private void SetTextureScaleImpl_Injected(int name, Vector2& scale)
}
public UnityEngine.MaterialGlobalIlluminationFlags : Enum {
public int value__
public MaterialGlobalIlluminationFlags None
public MaterialGlobalIlluminationFlags RealtimeEmissive
public MaterialGlobalIlluminationFlags BakedEmissive
public MaterialGlobalIlluminationFlags EmissiveIsBlack
public MaterialGlobalIlluminationFlags AnyEmissive
}
public UnityEngine.MaterialPropertyBlock : object {
internal IntPtr m_Ptr
public bool isEmpty
public void AddFloat(string name, float value)
public void AddFloat(int nameID, float value)
public void AddVector(string name, Vector4 value)
public void AddVector(int nameID, Vector4 value)
public void AddColor(string name, Color value)
public void AddColor(int nameID, Color value)
public void AddMatrix(string name, Matrix4x4 value)
public void AddMatrix(int nameID, Matrix4x4 value)
public void AddTexture(string name, Texture value)
public void AddTexture(int nameID, Texture value)
private float GetFloatImpl(int name)
private Vector4 GetVectorImpl(int name)
private Color GetColorImpl(int name)
private Matrix4x4 GetMatrixImpl(int name)
private Texture GetTextureImpl(int name)
private void SetFloatImpl(int name, float value)
private void SetVectorImpl(int name, Vector4 value)
private void SetColorImpl(int name, Color value)
private void SetMatrixImpl(int name, Matrix4x4 value)
private void SetTextureImpl(int name, Texture value)
private void SetBufferImpl(int name, ComputeBuffer value)
private void SetFloatArrayImpl(int name, Single[] values, int count)
private void SetVectorArrayImpl(int name, Vector4[] values, int count)
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetFloatArrayImpl(int name)
private Vector4[] GetVectorArrayImpl(int name)
private Matrix4x4[] GetMatrixArrayImpl(int name)
private int GetFloatArrayCountImpl(int name)
private int GetVectorArrayCountImpl(int name)
private int GetMatrixArrayCountImpl(int name)
private void ExtractFloatArrayImpl(int name, Single[] val)
private void ExtractVectorArrayImpl(int name, Vector4[] val)
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val)
internal void Internal_CopySHCoefficientArraysFrom(MaterialPropertyBlock properties, SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count)
internal void Internal_CopyProbeOcclusionArrayFrom(MaterialPropertyBlock properties, Vector4[] occlusionProbes, int sourceStart, int destStart, int count)
private IntPtr CreateImpl()
private void DestroyImpl(IntPtr mpb)
public bool get_isEmpty()
private void Clear(bool keepMemory)
public void Clear()
private void SetFloatArray(int name, Single[] values, int count)
private void SetVectorArray(int name, Vector4[] values, int count)
private void SetMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractFloatArray(int name, List`1<float> values)
private void ExtractVectorArray(int name, List`1<Vector4> values)
private void ExtractMatrixArray(int name, List`1<Matrix4x4> values)
protected void Finalize()
private void Dispose()
public void SetFloat(string name, float value)
public void SetFloat(int name, float value)
public void SetVector(string name, Vector4 value)
public void SetVector(int name, Vector4 value)
public void SetColor(string name, Color value)
public void SetColor(int name, Color value)
public void SetMatrix(string name, Matrix4x4 value)
public void SetMatrix(int name, Matrix4x4 value)
public void SetBuffer(string name, ComputeBuffer value)
public void SetBuffer(int name, ComputeBuffer value)
public void SetTexture(string name, Texture value)
public void SetTexture(int name, Texture value)
public void SetFloatArray(string name, List`1<float> values)
public void SetFloatArray(int name, List`1<float> values)
public void SetFloatArray(string name, Single[] values)
public void SetFloatArray(int name, Single[] values)
public void SetVectorArray(string name, List`1<Vector4> values)
public void SetVectorArray(int name, List`1<Vector4> values)
public void SetVectorArray(string name, Vector4[] values)
public void SetVectorArray(int name, Vector4[] values)
public void SetMatrixArray(string name, List`1<Matrix4x4> values)
public void SetMatrixArray(int name, List`1<Matrix4x4> values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetMatrixArray(int name, Matrix4x4[] values)
public float GetFloat(string name)
public float GetFloat(int name)
public Vector4 GetVector(string name)
public Vector4 GetVector(int name)
public Color GetColor(string name)
public Color GetColor(int name)
public Matrix4x4 GetMatrix(string name)
public Matrix4x4 GetMatrix(int name)
public Texture GetTexture(string name)
public Texture GetTexture(int name)
public Single[] GetFloatArray(string name)
public Single[] GetFloatArray(int name)
public Vector4[] GetVectorArray(string name)
public Vector4[] GetVectorArray(int name)
public Matrix4x4[] GetMatrixArray(string name)
public Matrix4x4[] GetMatrixArray(int name)
public void GetFloatArray(string name, List`1<float> values)
public void GetFloatArray(int name, List`1<float> values)
public void GetVectorArray(string name, List`1<Vector4> values)
public void GetVectorArray(int name, List`1<Vector4> values)
public void GetMatrixArray(string name, List`1<Matrix4x4> values)
public void GetMatrixArray(int name, List`1<Matrix4x4> values)
public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes)
public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes)
public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes, int sourceStart, int destStart, int count)
public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count)
public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes)
public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes)
public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes, int sourceStart, int destStart, int count)
public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes, int sourceStart, int destStart, int count)
private void GetVectorImpl_Injected(int name, Vector4& ret)
private void GetColorImpl_Injected(int name, Color& ret)
private void GetMatrixImpl_Injected(int name, Matrix4x4& ret)
private void SetVectorImpl_Injected(int name, Vector4& value)
private void SetColorImpl_Injected(int name, Color& value)
private void SetMatrixImpl_Injected(int name, Matrix4x4& value)
}
public UnityEngine.Mathf : ValueType {
public float PI
public float Infinity
public float NegativeInfinity
public float Deg2Rad
public float Rad2Deg
public float Epsilon
public int ClosestPowerOfTwo(int value)
public bool IsPowerOfTwo(int value)
public int NextPowerOfTwo(int value)
public float GammaToLinearSpace(float value)
public float LinearToGammaSpace(float value)
public Color CorrelatedColorTemperatureToRGB(float kelvin)
public ushort FloatToHalf(float val)
public float HalfToFloat(ushort val)
public float PerlinNoise(float x, float y)
public float Sin(float f)
public float Cos(float f)
public float Tan(float f)
public float Asin(float f)
public float Acos(float f)
public float Atan(float f)
public float Atan2(float y, float x)
public float Sqrt(float f)
public float Abs(float f)
public int Abs(int value)
public float Min(float a, float b)
public float Min(Single[] values)
public int Min(int a, int b)
public int Min(Int32[] values)
public float Max(float a, float b)
public float Max(Single[] values)
public int Max(int a, int b)
public int Max(Int32[] values)
public float Pow(float f, float p)
public float Exp(float power)
public float Log(float f, float p)
public float Log(float f)
public float Log10(float f)
public float Ceil(float f)
public float Floor(float f)
public float Round(float f)
public int CeilToInt(float f)
public int FloorToInt(float f)
public int RoundToInt(float f)
public float Sign(float f)
public float Clamp(float value, float min, float max)
public int Clamp(int value, int min, int max)
public float Clamp01(float value)
public float Lerp(float a, float b, float t)
public float LerpUnclamped(float a, float b, float t)
public float LerpAngle(float a, float b, float t)
public float MoveTowards(float current, float target, float maxDelta)
public float MoveTowardsAngle(float current, float target, float maxDelta)
public float SmoothStep(float from, float to, float t)
public float Gamma(float value, float absmax, float gamma)
public bool Approximately(float a, float b)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float Repeat(float t, float length)
public float PingPong(float t, float length)
public float InverseLerp(float a, float b, float value)
public float DeltaAngle(float current, float target)
internal bool LineIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result)
internal bool LineSegmentIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result)
internal long RandomToLong(Random r)
private void CorrelatedColorTemperatureToRGB_Injected(float kelvin, Color& ret)
}
public UnityEngine.Matrix4x4 : ValueType {
public float m00
public float m10
public float m20
public float m30
public float m01
public float m11
public float m21
public float m31
public float m02
public float m12
public float m22
public float m32
public float m03
public float m13
public float m23
public float m33
private Matrix4x4 zeroMatrix
private Matrix4x4 identityMatrix
public Quaternion rotation
public Vector3 lossyScale
public bool isIdentity
public float determinant
public FrustumPlanes decomposeProjection
public Matrix4x4 inverse
public Matrix4x4 transpose
public float Item
public float Item
public Matrix4x4 zero
public Matrix4x4 identity
public void .ctor(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3)
private Quaternion GetRotation()
private Vector3 GetLossyScale()
private bool IsIdentity()
private float GetDeterminant()
private FrustumPlanes DecomposeProjection()
public Quaternion get_rotation()
public Vector3 get_lossyScale()
public bool get_isIdentity()
public float get_determinant()
public FrustumPlanes get_decomposeProjection()
public bool ValidTRS()
public float Determinant(Matrix4x4 m)
public Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s)
public void SetTRS(Vector3 pos, Quaternion q, Vector3 s)
public Matrix4x4 Inverse(Matrix4x4 m)
public Matrix4x4 get_inverse()
public Matrix4x4 Transpose(Matrix4x4 m)
public Matrix4x4 get_transpose()
public Matrix4x4 Ortho(float left, float right, float bottom, float top, float zNear, float zFar)
public Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar)
public Matrix4x4 LookAt(Vector3 from, Vector3 to, Vector3 up)
public Matrix4x4 Frustum(float left, float right, float bottom, float top, float zNear, float zFar)
public Matrix4x4 Frustum(FrustumPlanes fp)
public float get_Item(int row, int column)
public void set_Item(int row, int column, float value)
public float get_Item(int index)
public void set_Item(int index, float value)
public int GetHashCode()
public bool Equals(object other)
public Matrix4x4 op_Multiply(Matrix4x4 lhs, Matrix4x4 rhs)
public Vector4 op_Multiply(Matrix4x4 lhs, Vector4 vector)
public bool op_Equality(Matrix4x4 lhs, Matrix4x4 rhs)
public bool op_Inequality(Matrix4x4 lhs, Matrix4x4 rhs)
public Vector4 GetColumn(int index)
public Vector4 GetRow(int index)
public void SetColumn(int index, Vector4 column)
public void SetRow(int index, Vector4 row)
public Vector3 MultiplyPoint(Vector3 point)
public Vector3 MultiplyPoint3x4(Vector3 point)
public Vector3 MultiplyVector(Vector3 vector)
public Plane TransformPlane(Plane plane)
public Matrix4x4 Scale(Vector3 vector)
public Matrix4x4 Translate(Vector3 vector)
public Matrix4x4 Rotate(Quaternion q)
public Matrix4x4 get_zero()
public Matrix4x4 get_identity()
public string ToString()
public string ToString(string format)
private void GetRotation_Injected(Matrix4x4& _unity_self, Quaternion& ret)
private void GetLossyScale_Injected(Matrix4x4& _unity_self, Vector3& ret)
private bool IsIdentity_Injected(Matrix4x4& _unity_self)
private float GetDeterminant_Injected(Matrix4x4& _unity_self)
private void DecomposeProjection_Injected(Matrix4x4& _unity_self, FrustumPlanes& ret)
private bool ValidTRS_Injected(Matrix4x4& _unity_self)
private void TRS_Injected(Vector3& pos, Quaternion& q, Vector3& s, Matrix4x4& ret)
private void Inverse_Injected(Matrix4x4& m, Matrix4x4& ret)
private void Transpose_Injected(Matrix4x4& m, Matrix4x4& ret)
private void Ortho_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret)
private void Perspective_Injected(float fov, float aspect, float zNear, float zFar, Matrix4x4& ret)
private void LookAt_Injected(Vector3& from, Vector3& to, Vector3& up, Matrix4x4& ret)
private void Frustum_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret)
}
public UnityEngine.Mesh : Object {
public IndexFormat indexFormat
public int vertexBufferCount
public int blendShapeCount
public BoneWeight[] boneWeights
public Matrix4x4[] bindposes
public bool isReadable
internal bool canAccess
public int vertexCount
public int subMeshCount
public Bounds bounds
public Vector3[] vertices
public Vector3[] normals
public Vector4[] tangents
public Vector2[] uv
public Vector2[] uv2
public Vector2[] uv3
public Vector2[] uv4
public Color[] colors
public Color32[] colors32
public Int32[] triangles
private void Internal_Create(Mesh mono)
internal Mesh FromInstanceID(int id)
public IndexFormat get_indexFormat()
public void set_indexFormat(IndexFormat value)
private UInt32 GetIndexStartImpl(int submesh)
private UInt32 GetIndexCountImpl(int submesh)
private UInt32 GetBaseVertexImpl(int submesh)
private Int32[] GetTrianglesImpl(int submesh, bool applyBaseVertex)
private Int32[] GetIndicesImpl(int submesh, bool applyBaseVertex)
private void SetIndicesImpl(int submesh, MeshTopology topology, Array indices, int arraySize, bool calculateBounds, int baseVertex)
private void GetTrianglesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex)
private void GetIndicesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex)
private void PrintErrorCantAccessChannel(InternalShaderChannel ch)
internal bool HasChannel(InternalShaderChannel ch)
private void SetArrayForChannelImpl(InternalShaderChannel channel, InternalVertexChannelType format, int dim, Array values, int arraySize)
private Array GetAllocArrayFromChannelImpl(InternalShaderChannel channel, InternalVertexChannelType format, int dim)
private void GetArrayFromChannelImpl(InternalShaderChannel channel, InternalVertexChannelType format, int dim, Array values)
public int get_vertexBufferCount()
public IntPtr GetNativeVertexBufferPtr(int index)
public IntPtr GetNativeIndexBufferPtr()
public int get_blendShapeCount()
public void ClearBlendShapes()
public string GetBlendShapeName(int shapeIndex)
public int GetBlendShapeIndex(string blendShapeName)
public int GetBlendShapeFrameCount(int shapeIndex)
public float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex)
public void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)
public void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)
private int GetBoneWeightCount()
public BoneWeight[] get_boneWeights()
public void set_boneWeights(BoneWeight[] value)
private int GetBindposeCount()
public Matrix4x4[] get_bindposes()
public void set_bindposes(Matrix4x4[] value)
private void GetBoneWeightsNonAllocImpl(BoneWeight[] values)
private void GetBindposesNonAllocImpl(Matrix4x4[] values)
public bool get_isReadable()
internal bool get_canAccess()
public int get_vertexCount()
public int get_subMeshCount()
public void set_subMeshCount(int value)
public Bounds get_bounds()
public void set_bounds(Bounds value)
private void ClearImpl(bool keepVertexLayout)
private void RecalculateBoundsImpl()
private void RecalculateNormalsImpl()
private void RecalculateTangentsImpl()
private void MarkDynamicImpl()
private void UploadMeshDataImpl(bool markNoLongerReadable)
private MeshTopology GetTopologyImpl(int submesh)
private void CombineMeshesImpl(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData)
internal InternalShaderChannel GetUVChannel(int uvIndex)
internal int DefaultDimensionForChannel(InternalShaderChannel channel)
private T[] GetAllocArrayFromChannel(InternalShaderChannel channel, InternalVertexChannelType format, int dim)
private T[] GetAllocArrayFromChannel(InternalShaderChannel channel)
private void SetSizedArrayForChannel(InternalShaderChannel channel, InternalVertexChannelType format, int dim, Array values, int valuesCount)
private void SetArrayForChannel(InternalShaderChannel channel, InternalVertexChannelType format, int dim, T[] values)
private void SetArrayForChannel(InternalShaderChannel channel, T[] values)
private void SetListForChannel(InternalShaderChannel channel, InternalVertexChannelType format, int dim, List`1<T> values)
private void SetListForChannel(InternalShaderChannel channel, List`1<T> values)
private void GetListForChannel(List`1<T> buffer, int capacity, InternalShaderChannel channel, int dim)
private void GetListForChannel(List`1<T> buffer, int capacity, InternalShaderChannel channel, int dim, InternalVertexChannelType channelType)
public Vector3[] get_vertices()
public void set_vertices(Vector3[] value)
public Vector3[] get_normals()
public void set_normals(Vector3[] value)
public Vector4[] get_tangents()
public void set_tangents(Vector4[] value)
public Vector2[] get_uv()
public void set_uv(Vector2[] value)
public Vector2[] get_uv2()
public void set_uv2(Vector2[] value)
public Vector2[] get_uv3()
public void set_uv3(Vector2[] value)
public Vector2[] get_uv4()
public void set_uv4(Vector2[] value)
public Color[] get_colors()
public void set_colors(Color[] value)
public Color32[] get_colors32()
public void set_colors32(Color32[] value)
public void GetVertices(List`1<Vector3> vertices)
public void SetVertices(List`1<Vector3> inVertices)
public void GetNormals(List`1<Vector3> normals)
public void SetNormals(List`1<Vector3> inNormals)
public void GetTangents(List`1<Vector4> tangents)
public void SetTangents(List`1<Vector4> inTangents)
public void GetColors(List`1<Color> colors)
public void SetColors(List`1<Color> inColors)
public void GetColors(List`1<Color32> colors)
public void SetColors(List`1<Color32> inColors)
private void SetUvsImpl(int uvIndex, int dim, List`1<T> uvs)
public void SetUVs(int channel, List`1<Vector2> uvs)
public void SetUVs(int channel, List`1<Vector3> uvs)
public void SetUVs(int channel, List`1<Vector4> uvs)
private void GetUVsImpl(int uvIndex, List`1<T> uvs, int dim)
public void GetUVs(int channel, List`1<Vector2> uvs)
public void GetUVs(int channel, List`1<Vector3> uvs)
public void GetUVs(int channel, List`1<Vector4> uvs)
private void PrintErrorCantAccessIndices()
private bool CheckCanAccessSubmesh(int submesh, bool errorAboutTriangles)
private bool CheckCanAccessSubmeshTriangles(int submesh)
private bool CheckCanAccessSubmeshIndices(int submesh)
public Int32[] get_triangles()
public void set_triangles(Int32[] value)
public Int32[] GetTriangles(int submesh)
public Int32[] GetTriangles(int submesh, bool applyBaseVertex)
public void GetTriangles(List`1<int> triangles, int submesh)
public void GetTriangles(List`1<int> triangles, int submesh, bool applyBaseVertex)
public Int32[] GetIndices(int submesh)
public Int32[] GetIndices(int submesh, bool applyBaseVertex)
public void GetIndices(List`1<int> indices, int submesh)
public void GetIndices(List`1<int> indices, int submesh, bool applyBaseVertex)
public UInt32 GetIndexStart(int submesh)
public UInt32 GetIndexCount(int submesh)
public UInt32 GetBaseVertex(int submesh)
private void SetTrianglesImpl(int submesh, Array triangles, int arraySize, bool calculateBounds, int baseVertex)
public void SetTriangles(Int32[] triangles, int submesh)
public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds)
public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(List`1<int> triangles, int submesh)
public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds)
public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void GetBindposes(List`1<Matrix4x4> bindposes)
public void GetBoneWeights(List`1<BoneWeight> boneWeights)
public void Clear(bool keepVertexLayout)
public void Clear()
public void RecalculateBounds()
public void RecalculateNormals()
public void RecalculateTangents()
public void MarkDynamic()
public void UploadMeshData(bool markNoLongerReadable)
public MeshTopology GetTopology(int submesh)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes)
public void CombineMeshes(CombineInstance[] combine)
public void Optimize()
private void get_bounds_Injected(Bounds& ret)
private void set_bounds_Injected(Bounds& value)
}
public UnityEngine.MeshFilter : Component {
public Mesh sharedMesh
public Mesh mesh
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public UnityEngine.MeshRenderer : Renderer {
public Mesh additionalVertexStreams
public int subMeshStartIndex
public Mesh get_additionalVertexStreams()
public void set_additionalVertexStreams(Mesh value)
public int get_subMeshStartIndex()
}
public UnityEngine.MeshTopology : Enum {
public int value__
public MeshTopology Triangles
public MeshTopology Quads
public MeshTopology Lines
public MeshTopology LineStrip
public MeshTopology Points
}
public UnityEngine.MissingComponentException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public UnityEngine.MissingReferenceException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public UnityEngine.MixedLightingMode : Enum {
public int value__
public MixedLightingMode IndirectOnly
public MixedLightingMode Shadowmask
public MixedLightingMode Subtractive
}
public UnityEngine.MonoBehaviour : Behaviour {
public bool useGUILayout
public bool IsInvoking()
public void CancelInvoke()
public void Invoke(string methodName, float time)
public void InvokeRepeating(string methodName, float time, float repeatRate)
public void CancelInvoke(string methodName)
public bool IsInvoking(string methodName)
public Coroutine StartCoroutine(string methodName)
public Coroutine StartCoroutine(string methodName, object value)
public Coroutine StartCoroutine(IEnumerator routine)
public Coroutine StartCoroutine_Auto(IEnumerator routine)
public void StopCoroutine(IEnumerator routine)
public void StopCoroutine(Coroutine routine)
public void StopCoroutine(string methodName)
public void StopAllCoroutines()
public bool get_useGUILayout()
public void set_useGUILayout(bool value)
public void print(object message)
private void Internal_CancelInvokeAll(MonoBehaviour self)
private bool Internal_IsInvokingAll(MonoBehaviour self)
private void InvokeDelayed(MonoBehaviour self, string methodName, float time, float repeatRate)
private void CancelInvoke(MonoBehaviour self, string methodName)
private bool IsInvoking(MonoBehaviour self, string methodName)
private bool IsObjectMonoBehaviour(Object obj)
private Coroutine StartCoroutineManaged(string methodName, object value)
private Coroutine StartCoroutineManaged2(IEnumerator enumerator)
private void StopCoroutineManaged(Coroutine routine)
private void StopCoroutineFromEnumeratorManaged(IEnumerator routine)
internal string GetScriptClassName()
}
public UnityEngine.MotionVectorGenerationMode : Enum {
public int value__
public MotionVectorGenerationMode Camera
public MotionVectorGenerationMode Object
public MotionVectorGenerationMode ForceNoMotion
}
public UnityEngine.MultilineAttribute : PropertyAttribute {
public int lines
public void .ctor(int lines)
}
public UnityEngine.NativeClassAttribute : Attribute {
private string <QualifiedNativeName>k__BackingField
public string QualifiedNativeName
public void .ctor(string qualifiedCppName)
public string get_QualifiedNativeName()
private void set_QualifiedNativeName(string value)
}
public UnityEngine.Network : object {
public string incomingPassword
public NetworkLogLevel logLevel
public NetworkPlayer[] connections
public NetworkPlayer player
public bool isClient
public bool isServer
public NetworkPeerType peerType
public float sendRate
public bool isMessageQueueRunning
public double time
public int minimumAllocatableViewIDs
public bool useNat
public string natFacilitatorIP
public int natFacilitatorPort
public string connectionTesterIP
public int connectionTesterPort
public int maxConnections
public string proxyIP
public int proxyPort
public bool useProxy
public string proxyPassword
public NetworkConnectionError InitializeServer(int connections, int listenPort, bool useNat)
private NetworkConnectionError Internal_InitializeServerDeprecated(int connections, int listenPort)
public NetworkConnectionError InitializeServer(int connections, int listenPort)
public string get_incomingPassword()
public void set_incomingPassword(string value)
public NetworkLogLevel get_logLevel()
public void set_logLevel(NetworkLogLevel value)
public void InitializeSecurity()
private NetworkConnectionError Internal_ConnectToSingleIP(string IP, int remotePort, int localPort, string password)
private NetworkConnectionError Internal_ConnectToSingleIP(string IP, int remotePort, int localPort)
private NetworkConnectionError Internal_ConnectToGuid(string guid, string password)
private NetworkConnectionError Internal_ConnectToIPs(String[] IP, int remotePort, int localPort, string password)
private NetworkConnectionError Internal_ConnectToIPs(String[] IP, int remotePort, int localPort)
public NetworkConnectionError Connect(string IP, int remotePort)
public NetworkConnectionError Connect(string IP, int remotePort, string password)
public NetworkConnectionError Connect(String[] IPs, int remotePort)
public NetworkConnectionError Connect(String[] IPs, int remotePort, string password)
public NetworkConnectionError Connect(string GUID)
public NetworkConnectionError Connect(string GUID, string password)
public NetworkConnectionError Connect(HostData hostData)
public NetworkConnectionError Connect(HostData hostData, string password)
public void Disconnect(int timeout)
public void Disconnect()
public void CloseConnection(NetworkPlayer target, bool sendDisconnectionNotification)
private void INTERNAL_CALL_CloseConnection(NetworkPlayer& target, bool sendDisconnectionNotification)
public NetworkPlayer[] get_connections()
private int Internal_GetPlayer()
public NetworkPlayer get_player()
private void Internal_AllocateViewID(NetworkViewID& viewID)
public NetworkViewID AllocateViewID()
public Object Instantiate(Object prefab, Vector3 position, Quaternion rotation, int group)
private Object INTERNAL_CALL_Instantiate(Object prefab, Vector3& position, Quaternion& rotation, int group)
public void Destroy(NetworkViewID viewID)
private void INTERNAL_CALL_Destroy(NetworkViewID& viewID)
public void Destroy(GameObject gameObject)
public void DestroyPlayerObjects(NetworkPlayer playerID)
private void INTERNAL_CALL_DestroyPlayerObjects(NetworkPlayer& playerID)
private void Internal_RemoveRPCs(NetworkPlayer playerID, NetworkViewID viewID, UInt32 channelMask)
private void INTERNAL_CALL_Internal_RemoveRPCs(NetworkPlayer& playerID, NetworkViewID& viewID, UInt32 channelMask)
public void RemoveRPCs(NetworkPlayer playerID)
public void RemoveRPCs(NetworkPlayer playerID, int group)
public void RemoveRPCs(NetworkViewID viewID)
public void RemoveRPCsInGroup(int group)
public bool get_isClient()
public bool get_isServer()
public NetworkPeerType get_peerType()
public void SetLevelPrefix(int prefix)
public int GetLastPing(NetworkPlayer player)
private int INTERNAL_CALL_GetLastPing(NetworkPlayer& player)
public int GetAveragePing(NetworkPlayer player)
private int INTERNAL_CALL_GetAveragePing(NetworkPlayer& player)
public float get_sendRate()
public void set_sendRate(float value)
public bool get_isMessageQueueRunning()
public void set_isMessageQueueRunning(bool value)
public void SetReceivingEnabled(NetworkPlayer player, int group, bool enabled)
private void INTERNAL_CALL_SetReceivingEnabled(NetworkPlayer& player, int group, bool enabled)
private void Internal_SetSendingGlobal(int group, bool enabled)
private void Internal_SetSendingSpecific(NetworkPlayer player, int group, bool enabled)
private void INTERNAL_CALL_Internal_SetSendingSpecific(NetworkPlayer& player, int group, bool enabled)
public void SetSendingEnabled(int group, bool enabled)
public void SetSendingEnabled(NetworkPlayer player, int group, bool enabled)
private void Internal_GetTime(Double& t)
public double get_time()
public int get_minimumAllocatableViewIDs()
public void set_minimumAllocatableViewIDs(int value)
public bool get_useNat()
public void set_useNat(bool value)
public string get_natFacilitatorIP()
public void set_natFacilitatorIP(string value)
public int get_natFacilitatorPort()
public void set_natFacilitatorPort(int value)
public ConnectionTesterStatus TestConnection(bool forceTest)
public ConnectionTesterStatus TestConnection()
public ConnectionTesterStatus TestConnectionNAT(bool forceTest)
public ConnectionTesterStatus TestConnectionNAT()
public string get_connectionTesterIP()
public void set_connectionTesterIP(string value)
public int get_connectionTesterPort()
public void set_connectionTesterPort(int value)
public bool HavePublicAddress()
public int get_maxConnections()
public void set_maxConnections(int value)
public string get_proxyIP()
public void set_proxyIP(string value)
public int get_proxyPort()
public void set_proxyPort(int value)
public bool get_useProxy()
public void set_useProxy(bool value)
public string get_proxyPassword()
public void set_proxyPassword(string value)
}
public UnityEngine.NetworkConnectionError : Enum {
public int value__
public NetworkConnectionError NoError
public NetworkConnectionError RSAPublicKeyMismatch
public NetworkConnectionError InvalidPassword
public NetworkConnectionError ConnectionFailed
public NetworkConnectionError TooManyConnectedPlayers
public NetworkConnectionError ConnectionBanned
public NetworkConnectionError AlreadyConnectedToServer
public NetworkConnectionError AlreadyConnectedToAnotherServer
public NetworkConnectionError CreateSocketOrThreadFailure
public NetworkConnectionError IncorrectParameters
public NetworkConnectionError EmptyConnectTarget
public NetworkConnectionError InternalDirectConnectFailed
public NetworkConnectionError NATTargetNotConnected
public NetworkConnectionError NATTargetConnectionLost
public NetworkConnectionError NATPunchthroughFailed
}
public UnityEngine.NetworkDisconnection : Enum {
public int value__
public NetworkDisconnection LostConnection
public NetworkDisconnection Disconnected
}
internal UnityEngine.Networking.PlayerConnection.IEditorPlayerConnection {
public void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void DisconnectAll()
public void RegisterConnection(UnityAction`1<int> callback)
public void RegisterDisconnection(UnityAction`1<int> callback)
public void Send(Guid messageId, Byte[] data)
}
public UnityEngine.Networking.PlayerConnection.MessageEventArgs : object {
public int playerId
public Byte[] data
}
public UnityEngine.Networking.PlayerConnection.PlayerConnection : ScriptableObject {
internal IPlayerEditorConnectionNative connectionNative
private PlayerEditorConnectionEvents m_PlayerEditorConnectionEvents
private List`1<int> m_connectedPlayers
private bool m_IsInitilized
private PlayerConnection s_Instance
public PlayerConnection instance
public bool isConnected
public PlayerConnection get_instance()
public bool get_isConnected()
private PlayerConnection CreateInstance()
public void OnEnable()
private IPlayerEditorConnectionNative GetConnectionNativeApi()
public void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void RegisterConnection(UnityAction`1<int> callback)
public void RegisterDisconnection(UnityAction`1<int> callback)
public void Send(Guid messageId, Byte[] data)
public bool BlockUntilRecvMsg(Guid messageId, int timeout)
public void DisconnectAll()
private void MessageCallbackInternal(IntPtr data, ulong size, ulong guid, string messageId)
private void ConnectedCallbackInternal(int playerId)
private void DisconnectedCallback(int playerId)
}
internal UnityEngine.Networking.PlayerConnection.PlayerEditorConnectionEvents : object {
public List`1<MessageTypeSubscribers> messageTypeSubscribers
public ConnectionChangeEvent connectionEvent
public ConnectionChangeEvent disconnectionEvent
public void InvokeMessageIdSubscribers(Guid messageId, Byte[] data, int playerId)
public UnityEvent`1<MessageEventArgs> AddAndCreate(Guid messageId)
public void UnregisterManagedCallback(Guid messageId, UnityAction`1<MessageEventArgs> callback)
}
public UnityEngine.NetworkLogLevel : Enum {
public int value__
public NetworkLogLevel Off
public NetworkLogLevel Informational
public NetworkLogLevel Full
}
public UnityEngine.NetworkMessageInfo : ValueType {
private double m_TimeStamp
private NetworkPlayer m_Sender
private NetworkViewID m_ViewID
public double timestamp
public NetworkPlayer sender
public NetworkView networkView
public double get_timestamp()
public NetworkPlayer get_sender()
public NetworkView get_networkView()
internal NetworkView NullNetworkView()
}
public UnityEngine.NetworkPeerType : Enum {
public int value__
public NetworkPeerType Disconnected
public NetworkPeerType Server
public NetworkPeerType Client
public NetworkPeerType Connecting
}
public UnityEngine.NetworkPlayer : ValueType {
internal int index
public string ipAddress
public int port
public string guid
public string externalIP
public int externalPort
internal NetworkPlayer unassigned
public void .ctor(string ip, int port)
private string Internal_GetIPAddress(int index)
private int Internal_GetPort(int index)
private string Internal_GetExternalIP()
private int Internal_GetExternalPort()
private string Internal_GetLocalIP()
private int Internal_GetLocalPort()
private int Internal_GetPlayerIndex()
private string Internal_GetGUID(int index)
private string Internal_GetLocalGUID()
public bool op_Equality(NetworkPlayer lhs, NetworkPlayer rhs)
public bool op_Inequality(NetworkPlayer lhs, NetworkPlayer rhs)
public int GetHashCode()
public bool Equals(object other)
public string get_ipAddress()
public int get_port()
public string get_guid()
public string ToString()
public string get_externalIP()
public int get_externalPort()
internal NetworkPlayer get_unassigned()
}
public UnityEngine.NetworkReachability : Enum {
public int value__
public NetworkReachability NotReachable
public NetworkReachability ReachableViaCarrierDataNetwork
public NetworkReachability ReachableViaLocalAreaNetwork
}
public UnityEngine.NetworkStateSynchronization : Enum {
public int value__
public NetworkStateSynchronization Off
public NetworkStateSynchronization ReliableDeltaCompressed
public NetworkStateSynchronization Unreliable
}
public UnityEngine.NetworkView : Behaviour {
public Component observed
public NetworkStateSynchronization stateSynchronization
public NetworkViewID viewID
public int group
public bool isMine
public NetworkPlayer owner
private void Internal_RPC(NetworkView view, string name, RPCMode mode, Object[] args)
private void Internal_RPC_Target(NetworkView view, string name, NetworkPlayer target, Object[] args)
private void INTERNAL_CALL_Internal_RPC_Target(NetworkView view, string name, NetworkPlayer& target, Object[] args)
public void RPC(string name, RPCMode mode, Object[] args)
public void RPC(string name, NetworkPlayer target, Object[] args)
public Component get_observed()
public void set_observed(Component value)
public NetworkStateSynchronization get_stateSynchronization()
public void set_stateSynchronization(NetworkStateSynchronization value)
private void Internal_GetViewID(NetworkViewID& viewID)
private void Internal_SetViewID(NetworkViewID viewID)
private void INTERNAL_CALL_Internal_SetViewID(NetworkView self, NetworkViewID& viewID)
public NetworkViewID get_viewID()
public void set_viewID(NetworkViewID value)
public int get_group()
public void set_group(int value)
public bool get_isMine()
public NetworkPlayer get_owner()
public bool SetScope(NetworkPlayer player, bool relevancy)
private bool INTERNAL_CALL_SetScope(NetworkView self, NetworkPlayer& player, bool relevancy)
public NetworkView Find(NetworkViewID viewID)
private NetworkView INTERNAL_CALL_Find(NetworkViewID& viewID)
}
public UnityEngine.NetworkViewID : ValueType {
private int a
private int b
private int c
public NetworkViewID unassigned
public bool isMine
public NetworkPlayer owner
public NetworkViewID get_unassigned()
private void INTERNAL_get_unassigned(NetworkViewID& value)
internal bool Internal_IsMine(NetworkViewID value)
private bool INTERNAL_CALL_Internal_IsMine(NetworkViewID& value)
internal void Internal_GetOwner(NetworkViewID value, NetworkPlayer& player)
private void INTERNAL_CALL_Internal_GetOwner(NetworkViewID& value, NetworkPlayer& player)
internal string Internal_GetString(NetworkViewID value)
private string INTERNAL_CALL_Internal_GetString(NetworkViewID& value)
internal bool Internal_Compare(NetworkViewID lhs, NetworkViewID rhs)
private bool INTERNAL_CALL_Internal_Compare(NetworkViewID& lhs, NetworkViewID& rhs)
public bool op_Equality(NetworkViewID lhs, NetworkViewID rhs)
public bool op_Inequality(NetworkViewID lhs, NetworkViewID rhs)
public int GetHashCode()
public bool Equals(object other)
public bool get_isMine()
public NetworkPlayer get_owner()
public string ToString()
}
internal UnityEngine.NoAllocHelpers : object {
internal void Internal_ResizeList(object list, int size)
public Array ExtractArrayFromList(object list)
public int SafeLength(Array values)
public int SafeLength(List`1<T> values)
public void ResizeList(List`1<T> list, int size)
public T[] ExtractArrayFromListT(List`1<T> list)
public void EnsureListElemCount(List`1<T> list, int count)
}
public UnityEngine.NPOTSupport : Enum {
public int value__
public NPOTSupport None
public NPOTSupport Restricted
public NPOTSupport Full
}
public UnityEngine.Object : object {
private IntPtr m_CachedPtr
internal int OffsetOfInstanceIDInCPlusPlusObject
public string name
public HideFlags hideFlags
public int GetInstanceID()
public int GetHashCode()
public bool Equals(object other)
public bool op_Implicit(Object exists)
private bool CompareBaseObjects(Object lhs, Object rhs)
private void EnsureRunningOnMainThread()
private bool IsNativeObjectAlive(Object o)
private IntPtr GetCachedPtr()
public string get_name()
public void set_name(string value)
public Object Instantiate(Object original, Vector3 position, Quaternion rotation)
public Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent)
public Object Instantiate(Object original)
public Object Instantiate(Object original, Transform parent)
public Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace)
public T Instantiate(T original)
public T Instantiate(T original, Vector3 position, Quaternion rotation)
public T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent)
public T Instantiate(T original, Transform parent)
public T Instantiate(T original, Transform parent, bool worldPositionStays)
public void Destroy(Object obj, float t)
public void Destroy(Object obj)
public void DestroyImmediate(Object obj, bool allowDestroyingAssets)
public void DestroyImmediate(Object obj)
public Object[] FindObjectsOfType(Type type)
public void DontDestroyOnLoad(Object target)
public HideFlags get_hideFlags()
public void set_hideFlags(HideFlags value)
public void DestroyObject(Object obj, float t)
public void DestroyObject(Object obj)
public Object[] FindSceneObjectsOfType(Type type)
public Object[] FindObjectsOfTypeIncludingAssets(Type type)
public T[] FindObjectsOfType()
public T FindObjectOfType()
public Object[] FindObjectsOfTypeAll(Type type)
private void CheckNullArgument(object arg, string message)
public Object FindObjectOfType(Type type)
public string ToString()
public bool op_Equality(Object x, Object y)
public bool op_Inequality(Object x, Object y)
private int GetOffsetOfInstanceIDInCPlusPlusObject()
private bool CurrentThreadIsMainThread()
private Object Internal_CloneSingle(Object data)
private Object Internal_CloneSingleWithParent(Object data, Transform parent, bool worldPositionStays)
private Object Internal_InstantiateSingle(Object data, Vector3 pos, Quaternion rot)
private Object Internal_InstantiateSingleWithParent(Object data, Transform parent, Vector3 pos, Quaternion rot)
private string ToString(Object obj)
private string GetName(Object obj)
private void SetName(Object obj, string name)
internal bool DoesObjectWithInstanceIDExist(int instanceID)
internal Object FindObjectFromInstanceID(int instanceID)
private Object Internal_InstantiateSingle_Injected(Object data, Vector3& pos, Quaternion& rot)
private Object Internal_InstantiateSingleWithParent_Injected(Object data, Transform parent, Vector3& pos, Quaternion& rot)
}
public UnityEngine.OcclusionArea : Component {
public Vector3 center
public Vector3 size
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_size()
public void set_size(Vector3 value)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
private void get_size_Injected(Vector3& ret)
private void set_size_Injected(Vector3& value)
}
public UnityEngine.OcclusionPortal : Component {
public bool open
public bool get_open()
public void set_open(bool value)
}
public UnityEngine.OperatingSystemFamily : Enum {
public int value__
public OperatingSystemFamily Other
public OperatingSystemFamily MacOSX
public OperatingSystemFamily Windows
public OperatingSystemFamily Linux
}
public UnityEngine.Ping : object {
internal IntPtr m_Ptr
public bool isDone
public int time
public string ip
public void .ctor(string address)
protected void Finalize()
public void DestroyPing()
private void Internal_Destroy(IntPtr ptr)
private IntPtr Internal_Create(string address)
public bool get_isDone()
private bool Internal_IsDone()
public int get_time()
public string get_ip()
}
public UnityEngine.Plane : ValueType {
private Vector3 m_Normal
private float m_Distance
public Vector3 normal
public float distance
public Plane flipped
public void .ctor(Vector3 inNormal, Vector3 inPoint)
public void .ctor(Vector3 inNormal, float d)
public void .ctor(Vector3 a, Vector3 b, Vector3 c)
public Vector3 get_normal()
public void set_normal(Vector3 value)
public float get_distance()
public void set_distance(float value)
public void SetNormalAndPosition(Vector3 inNormal, Vector3 inPoint)
public void Set3Points(Vector3 a, Vector3 b, Vector3 c)
public void Flip()
public Plane get_flipped()
public void Translate(Vector3 translation)
public Plane Translate(Plane plane, Vector3 translation)
public Vector3 ClosestPointOnPlane(Vector3 point)
public float GetDistanceToPoint(Vector3 point)
public bool GetSide(Vector3 point)
public bool SameSide(Vector3 inPt0, Vector3 inPt1)
public bool Raycast(Ray ray, Single& enter)
public string ToString()
public string ToString(string format)
}
public UnityEngine.Playables.DataStreamType : Enum {
public int value__
public DataStreamType Animation
public DataStreamType Audio
public DataStreamType Texture
public DataStreamType None
}
public UnityEngine.Playables.DirectorUpdateMode : Enum {
public int value__
public DirectorUpdateMode DSPClock
public DirectorUpdateMode GameTime
public DirectorUpdateMode UnscaledGameTime
public DirectorUpdateMode Manual
}
public UnityEngine.Playables.FrameData : ValueType {
internal ulong m_FrameID
internal double m_DeltaTime
internal float m_Weight
internal float m_EffectiveWeight
internal double m_EffectiveParentDelay
internal float m_EffectiveParentSpeed
internal float m_EffectiveSpeed
internal Flags m_Flags
public ulong frameId
public float deltaTime
public float weight
public float effectiveWeight
public double effectiveParentDelay
public float effectiveParentSpeed
public float effectiveSpeed
public EvaluationType evaluationType
public bool seekOccurred
public bool timeLooped
public bool timeHeld
public ulong get_frameId()
public float get_deltaTime()
public float get_weight()
public float get_effectiveWeight()
public double get_effectiveParentDelay()
public float get_effectiveParentSpeed()
public float get_effectiveSpeed()
public EvaluationType get_evaluationType()
public bool get_seekOccurred()
public bool get_timeLooped()
public bool get_timeHeld()
}
public UnityEngine.Playables.IPlayable {
public PlayableHandle GetHandle()
}
public UnityEngine.Playables.IPlayableAsset {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
}
public UnityEngine.Playables.IPlayableBehaviour {
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
}
public UnityEngine.Playables.IPlayableOutput {
public PlayableOutputHandle GetHandle()
}
public UnityEngine.Playables.Playable : ValueType {
private PlayableHandle m_Handle
private Playable m_NullPlayable
public Playable Null
internal void .ctor(PlayableHandle handle)
public Playable get_Null()
public Playable Create(PlayableGraph graph, int inputCount)
public PlayableHandle GetHandle()
public bool IsPlayableOfType()
public Type GetPlayableType()
public bool Equals(Playable other)
}
public UnityEngine.Playables.PlayableAsset : ScriptableObject {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
internal void Internal_CreatePlayable(PlayableAsset asset, PlayableGraph graph, GameObject go, IntPtr ptr)
internal void Internal_GetPlayableAssetDuration(PlayableAsset asset, IntPtr ptrToDouble)
}
public UnityEngine.Playables.PlayableBehaviour : object {
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourDelay(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareData(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
public object Clone()
}
public UnityEngine.Playables.PlayableBinding : ValueType {
public PlayableBinding[] None
public double DefaultDuration
private string <streamName>k__BackingField
private DataStreamType <streamType>k__BackingField
private Object <sourceObject>k__BackingField
private Type <sourceBindingType>k__BackingField
public string streamName
public DataStreamType streamType
public Object sourceObject
public Type sourceBindingType
public string get_streamName()
public void set_streamName(string value)
public DataStreamType get_streamType()
public void set_streamType(DataStreamType value)
public Object get_sourceObject()
public void set_sourceObject(Object value)
public Type get_sourceBindingType()
public void set_sourceBindingType(Type value)
}
public UnityEngine.Playables.PlayableExtensions : object {
public bool IsValid(U playable)
public void Destroy(U playable)
public PlayableGraph GetGraph(U playable)
public void SetPlayState(U playable, PlayState value)
public PlayState GetPlayState(U playable)
public void Play(U playable)
public void Pause(U playable)
public void SetSpeed(U playable, double value)
public double GetSpeed(U playable)
public void SetDuration(U playable, double value)
public double GetDuration(U playable)
public void SetTime(U playable, double value)
public double GetTime(U playable)
public double GetPreviousTime(U playable)
public void SetDone(U playable, bool value)
public bool IsDone(U playable)
public void SetPropagateSetTime(U playable, bool value)
public bool GetPropagateSetTime(U playable)
public bool CanChangeInputs(U playable)
public bool CanSetWeights(U playable)
public bool CanDestroy(U playable)
public void SetInputCount(U playable, int value)
public int GetInputCount(U playable)
public void SetOutputCount(U playable, int value)
public int GetOutputCount(U playable)
public Playable GetInput(U playable, int inputPort)
public Playable GetOutput(U playable, int outputPort)
public void SetInputWeight(U playable, int inputIndex, float weight)
public void SetInputWeight(U playable, V input, float weight)
public float GetInputWeight(U playable, int inputIndex)
public void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex)
public void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex, float weight)
public int AddInput(U playable, V sourcePlayable, int sourceOutputIndex, float weight)
public void SetDelay(U playable, double delay)
public double GetDelay(U playable)
public bool IsDelayed(U playable)
public void SetLeadTime(U playable, float value)
public float GetLeadTime(U playable)
}
public UnityEngine.Playables.PlayableGraph : ValueType {
internal IntPtr m_Handle
internal int m_Version
public Playable GetRootPlayable(int index)
public bool Connect(U source, int sourceOutputPort, V destination, int destinationInputPort)
public void Disconnect(U input, int inputPort)
public void DestroyPlayable(U playable)
public void DestroySubgraph(U playable)
public void DestroyOutput(U output)
public int GetOutputCountByType()
public PlayableOutput GetOutput(int index)
public PlayableOutput GetOutputByType(int index)
public void Evaluate()
public PlayableGraph Create()
public PlayableGraph Create(string name)
public void Destroy()
public bool IsValid()
public bool IsPlaying()
public bool IsDone()
public void Play()
public void Stop()
public void Evaluate(float deltaTime)
public DirectorUpdateMode GetTimeUpdateMode()
public void SetTimeUpdateMode(DirectorUpdateMode value)
public IExposedPropertyTable GetResolver()
public void SetResolver(IExposedPropertyTable value)
public int GetPlayableCount()
public int GetRootPlayableCount()
public int GetOutputCount()
internal PlayableHandle CreatePlayableHandle()
internal bool CreateScriptOutputInternal(string name, PlayableOutputHandle& handle)
internal PlayableHandle GetRootPlayableInternal(int index)
internal void DestroyOutputInternal(PlayableOutputHandle handle)
private bool GetOutputInternal(int index, PlayableOutputHandle& handle)
private int GetOutputCountByTypeInternal(Type outputType)
private bool GetOutputByTypeInternal(Type outputType, int index, PlayableOutputHandle& handle)
private bool ConnectInternal(PlayableHandle source, int sourceOutputPort, PlayableHandle destination, int destinationInputPort)
private void DisconnectInternal(PlayableHandle playable, int inputPort)
private void DestroyPlayableInternal(PlayableHandle playable)
private void DestroySubgraphInternal(PlayableHandle playable)
private void Create_Injected(string name, PlayableGraph& ret)
private void Destroy_Injected(PlayableGraph& _unity_self)
private bool IsValid_Injected(PlayableGraph& _unity_self)
private bool IsPlaying_Injected(PlayableGraph& _unity_self)
private bool IsDone_Injected(PlayableGraph& _unity_self)
private void Play_Injected(PlayableGraph& _unity_self)
private void Stop_Injected(PlayableGraph& _unity_self)
private void Evaluate_Injected(PlayableGraph& _unity_self, float deltaTime)
private DirectorUpdateMode GetTimeUpdateMode_Injected(PlayableGraph& _unity_self)
private void SetTimeUpdateMode_Injected(PlayableGraph& _unity_self, DirectorUpdateMode value)
private IExposedPropertyTable GetResolver_Injected(PlayableGraph& _unity_self)
private void SetResolver_Injected(PlayableGraph& _unity_self, IExposedPropertyTable value)
private int GetPlayableCount_Injected(PlayableGraph& _unity_self)
private int GetRootPlayableCount_Injected(PlayableGraph& _unity_self)
private int GetOutputCount_Injected(PlayableGraph& _unity_self)
private void CreatePlayableHandle_Injected(PlayableGraph& _unity_self, PlayableHandle& ret)
private bool CreateScriptOutputInternal_Injected(PlayableGraph& _unity_self, string name, PlayableOutputHandle& handle)
private void GetRootPlayableInternal_Injected(PlayableGraph& _unity_self, int index, PlayableHandle& ret)
private void DestroyOutputInternal_Injected(PlayableGraph& _unity_self, PlayableOutputHandle& handle)
private bool GetOutputInternal_Injected(PlayableGraph& _unity_self, int index, PlayableOutputHandle& handle)
private int GetOutputCountByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType)
private bool GetOutputByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType, int index, PlayableOutputHandle& handle)
private bool ConnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& source, int sourceOutputPort, PlayableHandle& destination, int destinationInputPort)
private void DisconnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable, int inputPort)
private void DestroyPlayableInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable)
private void DestroySubgraphInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable)
}
public UnityEngine.Playables.PlayableHandle : ValueType {
internal IntPtr m_Handle
internal int m_Version
public PlayableHandle Null
internal T GetObject()
internal bool IsPlayableOfType()
public PlayableHandle get_Null()
internal Playable GetInput(int inputPort)
internal Playable GetOutput(int outputPort)
internal bool SetInputWeight(int inputIndex, float weight)
internal float GetInputWeight(int inputIndex)
internal void Destroy()
public bool op_Equality(PlayableHandle x, PlayableHandle y)
public bool op_Inequality(PlayableHandle x, PlayableHandle y)
public bool Equals(object p)
public int GetHashCode()
internal bool CompareVersion(PlayableHandle lhs, PlayableHandle rhs)
internal bool CheckInputBounds(int inputIndex)
internal bool CheckInputBounds(int inputIndex, bool acceptAny)
internal bool IsValid()
internal Type GetPlayableType()
internal void SetScriptInstance(object scriptInstance)
internal bool CanChangeInputs()
internal bool CanSetWeights()
internal bool CanDestroy()
internal PlayState GetPlayState()
internal void Play()
internal void Pause()
internal double GetSpeed()
internal void SetSpeed(double value)
internal double GetTime()
internal void SetTime(double value)
internal bool IsDone()
internal void SetDone(bool value)
internal double GetDuration()
internal void SetDuration(double value)
internal bool GetPropagateSetTime()
internal void SetPropagateSetTime(bool value)
internal PlayableGraph GetGraph()
internal int GetInputCount()
internal void SetInputCount(int value)
internal int GetOutputCount()
internal void SetOutputCount(int value)
internal void SetInputWeight(PlayableHandle input, float weight)
internal void SetDelay(double delay)
internal double GetDelay()
internal bool IsDelayed()
internal double GetPreviousTime()
internal void SetLeadTime(float value)
internal float GetLeadTime()
private object GetScriptInstance()
private PlayableHandle GetInputHandle(int index)
private PlayableHandle GetOutputHandle(int index)
private void SetInputWeightFromIndex(int index, float weight)
private float GetInputWeightFromIndex(int index)
private bool IsValid_Injected(PlayableHandle& _unity_self)
private Type GetPlayableType_Injected(PlayableHandle& _unity_self)
private void SetScriptInstance_Injected(PlayableHandle& _unity_self, object scriptInstance)
private bool CanChangeInputs_Injected(PlayableHandle& _unity_self)
private bool CanSetWeights_Injected(PlayableHandle& _unity_self)
private bool CanDestroy_Injected(PlayableHandle& _unity_self)
private PlayState GetPlayState_Injected(PlayableHandle& _unity_self)
private void Play_Injected(PlayableHandle& _unity_self)
private void Pause_Injected(PlayableHandle& _unity_self)
private double GetSpeed_Injected(PlayableHandle& _unity_self)
private void SetSpeed_Injected(PlayableHandle& _unity_self, double value)
private double GetTime_Injected(PlayableHandle& _unity_self)
private void SetTime_Injected(PlayableHandle& _unity_self, double value)
private bool IsDone_Injected(PlayableHandle& _unity_self)
private void SetDone_Injected(PlayableHandle& _unity_self, bool value)
private double GetDuration_Injected(PlayableHandle& _unity_self)
private void SetDuration_Injected(PlayableHandle& _unity_self, double value)
private bool GetPropagateSetTime_Injected(PlayableHandle& _unity_self)
private void SetPropagateSetTime_Injected(PlayableHandle& _unity_self, bool value)
private void GetGraph_Injected(PlayableHandle& _unity_self, PlayableGraph& ret)
private int GetInputCount_Injected(PlayableHandle& _unity_self)
private void SetInputCount_Injected(PlayableHandle& _unity_self, int value)
private int GetOutputCount_Injected(PlayableHandle& _unity_self)
private void SetOutputCount_Injected(PlayableHandle& _unity_self, int value)
private void SetInputWeight_Injected(PlayableHandle& _unity_self, PlayableHandle& input, float weight)
private void SetDelay_Injected(PlayableHandle& _unity_self, double delay)
private double GetDelay_Injected(PlayableHandle& _unity_self)
private bool IsDelayed_Injected(PlayableHandle& _unity_self)
private double GetPreviousTime_Injected(PlayableHandle& _unity_self)
private void SetLeadTime_Injected(PlayableHandle& _unity_self, float value)
private float GetLeadTime_Injected(PlayableHandle& _unity_self)
private object GetScriptInstance_Injected(PlayableHandle& _unity_self)
private void GetInputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret)
private void GetOutputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret)
private void SetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index, float weight)
private float GetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index)
}
public UnityEngine.Playables.PlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
private PlayableOutput m_NullPlayableOutput
public PlayableOutput Null
internal void .ctor(PlayableOutputHandle handle)
public PlayableOutput get_Null()
public PlayableOutputHandle GetHandle()
public bool IsPlayableOutputOfType()
public Type GetPlayableOutputType()
public bool Equals(PlayableOutput other)
}
public UnityEngine.Playables.PlayableOutputExtensions : object {
public bool IsOutputValid(U output)
public Object GetReferenceObject(U output)
public void SetReferenceObject(U output, Object value)
public Object GetUserData(U output)
public void SetUserData(U output, Object value)
public Playable GetSourcePlayable(U output)
public void SetSourcePlayable(U output, V value)
public int GetSourceInputPort(U output)
public void SetSourceInputPort(U output, int value)
public float GetWeight(U output)
public void SetWeight(U output, float value)
}
public UnityEngine.Playables.PlayableOutputHandle : ValueType {
internal IntPtr m_Handle
internal int m_Version
public PlayableOutputHandle Null
public PlayableOutputHandle get_Null()
internal bool IsPlayableOutputOfType()
public int GetHashCode()
public bool op_Equality(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
public bool op_Inequality(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
public bool Equals(object p)
internal bool CompareVersion(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
internal bool IsValid()
internal Type GetPlayableOutputType()
internal Object GetReferenceObject()
internal void SetReferenceObject(Object target)
internal Object GetUserData()
internal void SetUserData(Object target)
internal PlayableHandle GetSourcePlayable()
internal void SetSourcePlayable(PlayableHandle target)
internal int GetSourceInputPort()
internal void SetSourceInputPort(int port)
internal float GetWeight()
internal void SetWeight(float weight)
private bool IsValid_Injected(PlayableOutputHandle& _unity_self)
private Type GetPlayableOutputType_Injected(PlayableOutputHandle& _unity_self)
private Object GetReferenceObject_Injected(PlayableOutputHandle& _unity_self)
private void SetReferenceObject_Injected(PlayableOutputHandle& _unity_self, Object target)
private Object GetUserData_Injected(PlayableOutputHandle& _unity_self)
private void SetUserData_Injected(PlayableOutputHandle& _unity_self, Object target)
private void GetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& ret)
private void SetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& target)
private int GetSourceInputPort_Injected(PlayableOutputHandle& _unity_self)
private void SetSourceInputPort_Injected(PlayableOutputHandle& _unity_self, int port)
private float GetWeight_Injected(PlayableOutputHandle& _unity_self)
private void SetWeight_Injected(PlayableOutputHandle& _unity_self, float weight)
}
public UnityEngine.Playables.PlayState : Enum {
public int value__
public PlayState Paused
public PlayState Playing
public PlayState Delayed
}
public UnityEngine.Playables.ScriptPlayable`1 : ValueType {
private PlayableHandle m_Handle
private ScriptPlayable`1<T> m_NullPlayable
public ScriptPlayable`1<T> Null
internal void .ctor(PlayableHandle handle)
public ScriptPlayable`1<T> get_Null()
public ScriptPlayable`1<T> Create(PlayableGraph graph, int inputCount)
public ScriptPlayable`1<T> Create(PlayableGraph graph, T template, int inputCount)
private PlayableHandle CreateHandle(PlayableGraph graph, T template, int inputCount)
private object CreateScriptInstance()
private object CloneScriptInstance(IPlayableBehaviour source)
private object CloneScriptInstanceFromEngineObject(Object source)
private object CloneScriptInstanceFromIClonable(ICloneable source)
public PlayableHandle GetHandle()
public T GetBehaviour()
public Playable op_Implicit(ScriptPlayable`1<T> playable)
public ScriptPlayable`1<T> op_Explicit(Playable playable)
public bool Equals(ScriptPlayable`1<T> other)
}
public UnityEngine.Playables.ScriptPlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
public ScriptPlayableOutput Null
internal void .ctor(PlayableOutputHandle handle)
public ScriptPlayableOutput Create(PlayableGraph graph, string name)
public ScriptPlayableOutput get_Null()
public PlayableOutputHandle GetHandle()
public PlayableOutput op_Implicit(ScriptPlayableOutput output)
public ScriptPlayableOutput op_Explicit(PlayableOutput output)
}
internal UnityEngine.PlayerConnectionInternal : object {
private void UnityEngine.IPlayerEditorConnectionNative.SendMessage(Guid messageId, Byte[] data, int playerId)
private void UnityEngine.IPlayerEditorConnectionNative.Poll()
private void UnityEngine.IPlayerEditorConnectionNative.RegisterInternal(Guid messageId)
private void UnityEngine.IPlayerEditorConnectionNative.UnregisterInternal(Guid messageId)
private void UnityEngine.IPlayerEditorConnectionNative.Initialize()
private bool UnityEngine.IPlayerEditorConnectionNative.IsConnected()
private void UnityEngine.IPlayerEditorConnectionNative.DisconnectAll()
public bool IsConnected()
public void Initialize()
public void RegisterInternal(string messageId)
public void UnregisterInternal(string messageId)
public void SendMessage(string messageId, Byte[] data, int playerId)
public void PollInternal()
public void DisconnectAll()
}
public UnityEngine.PlayerPrefs : object {
private bool TrySetInt(string key, int value)
private bool TrySetFloat(string key, float value)
private bool TrySetSetString(string key, string value)
public void SetInt(string key, int value)
public int GetInt(string key, int defaultValue)
public int GetInt(string key)
public void SetFloat(string key, float value)
public float GetFloat(string key, float defaultValue)
public float GetFloat(string key)
public void SetString(string key, string value)
public string GetString(string key, string defaultValue)
public string GetString(string key)
public bool HasKey(string key)
public void DeleteKey(string key)
public void DeleteAll()
public void Save()
}
public UnityEngine.PlayerPrefsException : Exception {
public void .ctor(string error)
}
public UnityEngine.Pose : ValueType {
public Vector3 position
public Quaternion rotation
private Pose k_Identity
public Vector3 forward
public Vector3 right
public Vector3 up
public Pose identity
public void .ctor(Vector3 position, Quaternion rotation)
public string ToString()
public string ToString(string format)
public Pose GetTransformedBy(Pose lhs)
public Pose GetTransformedBy(Transform lhs)
public Vector3 get_forward()
public Vector3 get_right()
public Vector3 get_up()
public Pose get_identity()
}
public UnityEngine.PrimitiveType : Enum {
public int value__
public PrimitiveType Sphere
public PrimitiveType Capsule
public PrimitiveType Cylinder
public PrimitiveType Cube
public PrimitiveType Plane
public PrimitiveType Quad
}
public UnityEngine.Profiling.CustomSampler : Sampler {
internal CustomSampler s_InvalidCustomSampler
public CustomSampler Create(string name)
private CustomSampler CreateInternal(string name)
public void Begin()
public void Begin(Object targetObject)
private void BeginWithObject(Object targetObject)
public void End()
}
public UnityEngine.Profiling.Profiler : object {
public bool supported
public string logFile
public bool enableBinaryLog
public bool enabled
public int maxNumberOfSamplesPerFrame
public UInt32 usedHeapSize
public long usedHeapSizeLong
public bool get_supported()
public string get_logFile()
public void set_logFile(string value)
public bool get_enableBinaryLog()
public void set_enableBinaryLog(bool value)
public bool get_enabled()
public void set_enabled(bool value)
public void AddFramesFromFile(string file)
public void BeginThreadProfiling(string threadGroupName, string threadName)
public void EndThreadProfiling()
public void BeginSample(string name)
public void BeginSample(string name, Object targetObject)
private void BeginSampleOnly(string name)
public void EndSample()
public int get_maxNumberOfSamplesPerFrame()
public void set_maxNumberOfSamplesPerFrame(int value)
public UInt32 get_usedHeapSize()
public long get_usedHeapSizeLong()
public int GetRuntimeMemorySize(Object o)
public long GetRuntimeMemorySizeLong(Object o)
public UInt32 GetMonoHeapSize()
public long GetMonoHeapSizeLong()
public UInt32 GetMonoUsedSize()
public long GetMonoUsedSizeLong()
public bool SetTempAllocatorRequestedSize(UInt32 size)
public UInt32 GetTempAllocatorSize()
public UInt32 GetTotalAllocatedMemory()
public long GetTotalAllocatedMemoryLong()
public UInt32 GetTotalUnusedReservedMemory()
public long GetTotalUnusedReservedMemoryLong()
public UInt32 GetTotalReservedMemory()
public long GetTotalReservedMemoryLong()
public long GetAllocatedMemoryForGraphicsDriver()
}
public UnityEngine.Profiling.Recorder : object {
internal IntPtr m_Ptr
internal Recorder s_InvalidRecorder
public bool isValid
public bool enabled
public long elapsedNanoseconds
public int sampleBlockCount
protected void Finalize()
public Recorder Get(string samplerName)
private Recorder GetInternal(string samplerName)
public bool get_isValid()
private void DisposeNative()
public bool get_enabled()
public void set_enabled(bool value)
public long get_elapsedNanoseconds()
public int get_sampleBlockCount()
}
public UnityEngine.Profiling.Sampler : object {
internal IntPtr m_Ptr
internal Sampler s_InvalidSampler
public bool isValid
public string name
public bool get_isValid()
public Recorder GetRecorder()
public Sampler Get(string name)
public int GetNames(List`1<string> names)
public string get_name()
private Recorder GetRecorderInternal()
private Sampler GetSamplerInternal(string name)
private int GetSamplerNamesInternal(object namesScriptingPtr)
}
public UnityEngine.Projector : Behaviour {
public float nearClipPlane
public float farClipPlane
public float fieldOfView
public float aspectRatio
public bool orthographic
public float orthographicSize
public int ignoreLayers
public Material material
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public float get_aspectRatio()
public void set_aspectRatio(float value)
public bool get_orthographic()
public void set_orthographic(bool value)
public float get_orthographicSize()
public void set_orthographicSize(float value)
public int get_ignoreLayers()
public void set_ignoreLayers(int value)
public Material get_material()
public void set_material(Material value)
}
public UnityEngine.PropertyAttribute : Attribute {
private int <order>k__BackingField
public int order
public int get_order()
public void set_order(int value)
}
public UnityEngine.PropertyName : ValueType {
internal int id
public void .ctor(string name)
public void .ctor(PropertyName other)
public void .ctor(int id)
public bool IsNullOrEmpty(PropertyName prop)
public bool op_Equality(PropertyName lhs, PropertyName rhs)
public bool op_Inequality(PropertyName lhs, PropertyName rhs)
public int GetHashCode()
public bool Equals(object other)
public PropertyName op_Implicit(string name)
public PropertyName op_Implicit(int id)
public string ToString()
}
internal UnityEngine.PropertyNameUtils : object {
public PropertyName PropertyNameFromString(string name)
private void PropertyNameFromString_Injected(string name, PropertyName& ret)
}
public UnityEngine.QualityLevel : Enum {
public int value__
public QualityLevel Fastest
public QualityLevel Fast
public QualityLevel Simple
public QualityLevel Good
public QualityLevel Beautiful
public QualityLevel Fantastic
}
public UnityEngine.QualitySettings : Object {
public QualityLevel currentLevel
public int pixelLightCount
public ShadowQuality shadows
public ShadowProjection shadowProjection
public int shadowCascades
public float shadowDistance
public ShadowResolution shadowResolution
public ShadowmaskMode shadowmaskMode
public float shadowNearPlaneOffset
public float shadowCascade2Split
public Vector3 shadowCascade4Split
public float lodBias
public AnisotropicFiltering anisotropicFiltering
public int masterTextureLimit
public int maximumLODLevel
public int particleRaycastBudget
public bool softParticles
public bool softVegetation
public int vSyncCount
public int antiAliasing
public int asyncUploadTimeSlice
public int asyncUploadBufferSize
public bool realtimeReflectionProbes
public bool billboardsFaceCameraPosition
public float resolutionScalingFixedDPIFactor
public BlendWeights blendWeights
public String[] names
public int maxQueuedFrames
public ColorSpace desiredColorSpace
public ColorSpace activeColorSpace
public void IncreaseLevel(bool applyExpensiveChanges)
public void DecreaseLevel(bool applyExpensiveChanges)
public void SetQualityLevel(int index)
public void IncreaseLevel()
public void DecreaseLevel()
public QualityLevel get_currentLevel()
public void set_currentLevel(QualityLevel value)
public int get_pixelLightCount()
public void set_pixelLightCount(int value)
public ShadowQuality get_shadows()
public void set_shadows(ShadowQuality value)
public ShadowProjection get_shadowProjection()
public void set_shadowProjection(ShadowProjection value)
public int get_shadowCascades()
public void set_shadowCascades(int value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public ShadowResolution get_shadowResolution()
public void set_shadowResolution(ShadowResolution value)
public ShadowmaskMode get_shadowmaskMode()
public void set_shadowmaskMode(ShadowmaskMode value)
public float get_shadowNearPlaneOffset()
public void set_shadowNearPlaneOffset(float value)
public float get_shadowCascade2Split()
public void set_shadowCascade2Split(float value)
public Vector3 get_shadowCascade4Split()
public void set_shadowCascade4Split(Vector3 value)
public float get_lodBias()
public void set_lodBias(float value)
public AnisotropicFiltering get_anisotropicFiltering()
public void set_anisotropicFiltering(AnisotropicFiltering value)
public int get_masterTextureLimit()
public void set_masterTextureLimit(int value)
public int get_maximumLODLevel()
public void set_maximumLODLevel(int value)
public int get_particleRaycastBudget()
public void set_particleRaycastBudget(int value)
public bool get_softParticles()
public void set_softParticles(bool value)
public bool get_softVegetation()
public void set_softVegetation(bool value)
public int get_vSyncCount()
public void set_vSyncCount(int value)
public int get_antiAliasing()
public void set_antiAliasing(int value)
public int get_asyncUploadTimeSlice()
public void set_asyncUploadTimeSlice(int value)
public int get_asyncUploadBufferSize()
public void set_asyncUploadBufferSize(int value)
public bool get_realtimeReflectionProbes()
public void set_realtimeReflectionProbes(bool value)
public bool get_billboardsFaceCameraPosition()
public void set_billboardsFaceCameraPosition(bool value)
public float get_resolutionScalingFixedDPIFactor()
public void set_resolutionScalingFixedDPIFactor(float value)
public BlendWeights get_blendWeights()
public void set_blendWeights(BlendWeights value)
public int GetQualityLevel()
public void SetQualityLevel(int index, bool applyExpensiveChanges)
public String[] get_names()
public int get_maxQueuedFrames()
public void set_maxQueuedFrames(int value)
public ColorSpace get_desiredColorSpace()
public ColorSpace get_activeColorSpace()
private void get_shadowCascade4Split_Injected(Vector3& ret)
private void set_shadowCascade4Split_Injected(Vector3& value)
}
public UnityEngine.Quaternion : ValueType {
public float x
public float y
public float z
public float w
private Quaternion identityQuaternion
public float kEpsilon
public float Item
public Quaternion identity
public Vector3 eulerAngles
public void .ctor(float x, float y, float z, float w)
public Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection)
public Quaternion Inverse(Quaternion rotation)
public Quaternion Slerp(Quaternion a, Quaternion b, float t)
public Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t)
public Quaternion Lerp(Quaternion a, Quaternion b, float t)
public Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t)
private Quaternion Internal_FromEulerRad(Vector3 euler)
private Vector3 Internal_ToEulerRad(Quaternion rotation)
private void Internal_ToAxisAngleRad(Quaternion q, Vector3& axis, Single& angle)
public Quaternion AngleAxis(float angle, Vector3 axis)
public Quaternion LookRotation(Vector3 forward, Vector3 upwards)
public Quaternion LookRotation(Vector3 forward)
public float get_Item(int index)
public void set_Item(int index, float value)
public void Set(float newX, float newY, float newZ, float newW)
public Quaternion get_identity()
public Quaternion op_Multiply(Quaternion lhs, Quaternion rhs)
public Vector3 op_Multiply(Quaternion rotation, Vector3 point)
private bool IsEqualUsingDot(float dot)
public bool op_Equality(Quaternion lhs, Quaternion rhs)
public bool op_Inequality(Quaternion lhs, Quaternion rhs)
public float Dot(Quaternion a, Quaternion b)
public void SetLookRotation(Vector3 view)
public void SetLookRotation(Vector3 view, Vector3 up)
public float Angle(Quaternion a, Quaternion b)
private Vector3 Internal_MakePositive(Vector3 euler)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public Quaternion Euler(float x, float y, float z)
public Quaternion Euler(Vector3 euler)
public void ToAngleAxis(Single& angle, Vector3& axis)
public void SetFromToRotation(Vector3 fromDirection, Vector3 toDirection)
public Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta)
public int GetHashCode()
public bool Equals(object other)
public string ToString()
public string ToString(string format)
public Quaternion EulerRotation(float x, float y, float z)
public Quaternion EulerRotation(Vector3 euler)
public void SetEulerRotation(float x, float y, float z)
public void SetEulerRotation(Vector3 euler)
public Vector3 ToEuler()
public Quaternion EulerAngles(float x, float y, float z)
public Quaternion EulerAngles(Vector3 euler)
public void ToAxisAngle(Vector3& axis, Single& angle)
public void SetEulerAngles(float x, float y, float z)
public void SetEulerAngles(Vector3 euler)
public Vector3 ToEulerAngles(Quaternion rotation)
public Vector3 ToEulerAngles()
public void SetAxisAngle(Vector3 axis, float angle)
public Quaternion AxisAngle(Vector3 axis, float angle)
private void FromToRotation_Injected(Vector3& fromDirection, Vector3& toDirection, Quaternion& ret)
private void Inverse_Injected(Quaternion& rotation, Quaternion& ret)
private void Slerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void SlerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void Lerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void LerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void Internal_FromEulerRad_Injected(Vector3& euler, Quaternion& ret)
private void Internal_ToEulerRad_Injected(Quaternion& rotation, Vector3& ret)
private void Internal_ToAxisAngleRad_Injected(Quaternion& q, Vector3& axis, Single& angle)
private void AngleAxis_Injected(float angle, Vector3& axis, Quaternion& ret)
private void LookRotation_Injected(Vector3& forward, Vector3& upwards, Quaternion& ret)
}
public UnityEngine.Random : object {
public int seed
public State state
public float value
public Vector3 insideUnitSphere
public Vector2 insideUnitCircle
public Vector3 onUnitSphere
public Quaternion rotation
public Quaternion rotationUniform
public int get_seed()
public void set_seed(int value)
public void InitState(int seed)
public State get_state()
public void set_state(State value)
public float Range(float min, float max)
public int Range(int min, int max)
private int RandomRangeInt(int min, int max)
public float get_value()
public Vector3 get_insideUnitSphere()
private void GetRandomUnitCircle(Vector2& output)
public Vector2 get_insideUnitCircle()
public Vector3 get_onUnitSphere()
public Quaternion get_rotation()
public Quaternion get_rotationUniform()
public float RandomRange(float min, float max)
public int RandomRange(int min, int max)
public Color ColorHSV()
public Color ColorHSV(float hueMin, float hueMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax, float alphaMin, float alphaMax)
private void get_state_Injected(State& ret)
private void set_state_Injected(State& value)
private void get_insideUnitSphere_Injected(Vector3& ret)
private void get_onUnitSphere_Injected(Vector3& ret)
private void get_rotation_Injected(Quaternion& ret)
private void get_rotationUniform_Injected(Quaternion& ret)
}
public UnityEngine.RangeAttribute : PropertyAttribute {
public float min
public float max
public void .ctor(float min, float max)
}
public UnityEngine.RangeInt : ValueType {
public int start
public int length
public int end
public void .ctor(int start, int length)
public int get_end()
}
public UnityEngine.Ray : ValueType {
private Vector3 m_Origin
private Vector3 m_Direction
public Vector3 origin
public Vector3 direction
public void .ctor(Vector3 origin, Vector3 direction)
public Vector3 get_origin()
public void set_origin(Vector3 value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public Vector3 GetPoint(float distance)
public string ToString()
public string ToString(string format)
}
public UnityEngine.Ray2D : ValueType {
private Vector2 m_Origin
private Vector2 m_Direction
public Vector2 origin
public Vector2 direction
public void .ctor(Vector2 origin, Vector2 direction)
public Vector2 get_origin()
public void set_origin(Vector2 value)
public Vector2 get_direction()
public void set_direction(Vector2 value)
public Vector2 GetPoint(float distance)
public string ToString()
public string ToString(string format)
}
public UnityEngine.Rect : ValueType {
private float m_XMin
private float m_YMin
private float m_Width
private float m_Height
public Rect zero
public float x
public float y
public Vector2 position
public Vector2 center
public Vector2 min
public Vector2 max
public float width
public float height
public Vector2 size
public float xMin
public float yMin
public float xMax
public float yMax
public float left
public float right
public float top
public float bottom
public void .ctor(float x, float y, float width, float height)
public void .ctor(Vector2 position, Vector2 size)
public void .ctor(Rect source)
public Rect get_zero()
public Rect MinMaxRect(float xmin, float ymin, float xmax, float ymax)
public void Set(float x, float y, float width, float height)
public float get_x()
public void set_x(float value)
public float get_y()
public void set_y(float value)
public Vector2 get_position()
public void set_position(Vector2 value)
public Vector2 get_center()
public void set_center(Vector2 value)
public Vector2 get_min()
public void set_min(Vector2 value)
public Vector2 get_max()
public void set_max(Vector2 value)
public float get_width()
public void set_width(float value)
public float get_height()
public void set_height(float value)
public Vector2 get_size()
public void set_size(Vector2 value)
public float get_xMin()
public void set_xMin(float value)
public float get_yMin()
public void set_yMin(float value)
public float get_xMax()
public void set_xMax(float value)
public float get_yMax()
public void set_yMax(float value)
public bool Contains(Vector2 point)
public bool Contains(Vector3 point)
public bool Contains(Vector3 point, bool allowInverse)
private Rect OrderMinMax(Rect rect)
public bool Overlaps(Rect other)
public bool Overlaps(Rect other, bool allowInverse)
public Vector2 NormalizedToPoint(Rect rectangle, Vector2 normalizedRectCoordinates)
public Vector2 PointToNormalized(Rect rectangle, Vector2 point)
public bool op_Inequality(Rect lhs, Rect rhs)
public bool op_Equality(Rect lhs, Rect rhs)
public int GetHashCode()
public bool Equals(object other)
public string ToString()
public string ToString(string format)
public float get_left()
public float get_right()
public float get_top()
public float get_bottom()
}
public UnityEngine.RectInt : ValueType {
private int m_XMin
private int m_YMin
private int m_Width
private int m_Height
public int x
public int y
public Vector2 center
public Vector2Int min
public Vector2Int max
public int width
public int height
public int xMin
public int yMin
public int xMax
public int yMax
public Vector2Int position
public Vector2Int size
public PositionEnumerator allPositionsWithin
public void .ctor(int xMin, int yMin, int width, int height)
public void .ctor(Vector2Int position, Vector2Int size)
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public Vector2 get_center()
public Vector2Int get_min()
public void set_min(Vector2Int value)
public Vector2Int get_max()
public void set_max(Vector2Int value)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_xMin()
public void set_xMin(int value)
public int get_yMin()
public void set_yMin(int value)
public int get_xMax()
public void set_xMax(int value)
public int get_yMax()
public void set_yMax(int value)
public Vector2Int get_position()
public void set_position(Vector2Int value)
public Vector2Int get_size()
public void set_size(Vector2Int value)
public void SetMinMax(Vector2Int minPosition, Vector2Int maxPosition)
public void ClampToBounds(RectInt bounds)
public bool Contains(Vector2Int position)
public string ToString()
public PositionEnumerator get_allPositionsWithin()
}
public UnityEngine.RectOffset : object {
internal IntPtr m_Ptr
private object m_SourceStyle
public int left
public int right
public int top
public int bottom
public int horizontal
public int vertical
internal void .ctor(object sourceStyle, IntPtr source)
public void .ctor(int left, int right, int top, int bottom)
private void Init()
private void Cleanup()
public int get_left()
public void set_left(int value)
public int get_right()
public void set_right(int value)
public int get_top()
public void set_top(int value)
public int get_bottom()
public void set_bottom(int value)
public int get_horizontal()
public int get_vertical()
public Rect Add(Rect rect)
private void INTERNAL_CALL_Add(RectOffset self, Rect& rect, Rect& value)
public Rect Remove(Rect rect)
private void INTERNAL_CALL_Remove(RectOffset self, Rect& rect, Rect& value)
protected void Finalize()
public string ToString()
}
public UnityEngine.RectTransform : Transform {
private ReapplyDrivenProperties reapplyDrivenProperties
public Rect rect
public Vector2 anchorMin
public Vector2 anchorMax
public Vector3 anchoredPosition3D
public Vector2 anchoredPosition
public Vector2 sizeDelta
public Vector2 pivot
internal Object drivenByObject
internal DrivenTransformProperties drivenProperties
public Vector2 offsetMin
public Vector2 offsetMax
public Rect get_rect()
private void INTERNAL_get_rect(Rect& value)
public Vector2 get_anchorMin()
public void set_anchorMin(Vector2 value)
private void INTERNAL_get_anchorMin(Vector2& value)
private void INTERNAL_set_anchorMin(Vector2& value)
public Vector2 get_anchorMax()
public void set_anchorMax(Vector2 value)
private void INTERNAL_get_anchorMax(Vector2& value)
private void INTERNAL_set_anchorMax(Vector2& value)
public Vector3 get_anchoredPosition3D()
public void set_anchoredPosition3D(Vector3 value)
public Vector2 get_anchoredPosition()
public void set_anchoredPosition(Vector2 value)
private void INTERNAL_get_anchoredPosition(Vector2& value)
private void INTERNAL_set_anchoredPosition(Vector2& value)
public Vector2 get_sizeDelta()
public void set_sizeDelta(Vector2 value)
private void INTERNAL_get_sizeDelta(Vector2& value)
private void INTERNAL_set_sizeDelta(Vector2& value)
public Vector2 get_pivot()
public void set_pivot(Vector2 value)
private void INTERNAL_get_pivot(Vector2& value)
private void INTERNAL_set_pivot(Vector2& value)
internal Object get_drivenByObject()
internal void set_drivenByObject(Object value)
internal DrivenTransformProperties get_drivenProperties()
internal void set_drivenProperties(DrivenTransformProperties value)
public void add_reapplyDrivenProperties(ReapplyDrivenProperties value)
public void remove_reapplyDrivenProperties(ReapplyDrivenProperties value)
internal void SendReapplyDrivenProperties(RectTransform driven)
public void GetLocalCorners(Vector3[] fourCornersArray)
public void GetWorldCorners(Vector3[] fourCornersArray)
internal Rect GetRectInParentSpace()
public Vector2 get_offsetMin()
public void set_offsetMin(Vector2 value)
public Vector2 get_offsetMax()
public void set_offsetMax(Vector2 value)
public void SetInsetAndSizeFromParentEdge(Edge edge, float inset, float size)
public void SetSizeWithCurrentAnchors(Axis axis, float size)
private Vector2 GetParentSize()
public void ForceUpdateRectTransforms()
}
public UnityEngine.ReflectionProbe : Behaviour {
public ReflectionProbeType type
public bool hdr
public Vector3 size
public Vector3 center
public float nearClipPlane
public float farClipPlane
public float shadowDistance
public int resolution
public int cullingMask
public ReflectionProbeClearFlags clearFlags
public Color backgroundColor
public float intensity
public float blendDistance
public bool boxProjection
public Bounds bounds
public ReflectionProbeMode mode
public int importance
public ReflectionProbeRefreshMode refreshMode
public ReflectionProbeTimeSlicingMode timeSlicingMode
public Texture bakedTexture
public Texture customBakedTexture
public Texture texture
public Vector4 textureHDRDecodeValues
public int minBakedCubemapResolution
public int maxBakedCubemapResolution
public Vector4 defaultTextureHDRDecodeValues
public Texture defaultTexture
public ReflectionProbeType get_type()
public void set_type(ReflectionProbeType value)
public bool get_hdr()
public void set_hdr(bool value)
public Vector3 get_size()
public void set_size(Vector3 value)
private void INTERNAL_get_size(Vector3& value)
private void INTERNAL_set_size(Vector3& value)
public Vector3 get_center()
public void set_center(Vector3 value)
private void INTERNAL_get_center(Vector3& value)
private void INTERNAL_set_center(Vector3& value)
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public int get_resolution()
public void set_resolution(int value)
public int get_cullingMask()
public void set_cullingMask(int value)
public ReflectionProbeClearFlags get_clearFlags()
public void set_clearFlags(ReflectionProbeClearFlags value)
public Color get_backgroundColor()
public void set_backgroundColor(Color value)
private void INTERNAL_get_backgroundColor(Color& value)
private void INTERNAL_set_backgroundColor(Color& value)
public float get_intensity()
public void set_intensity(float value)
public float get_blendDistance()
public void set_blendDistance(float value)
public bool get_boxProjection()
public void set_boxProjection(bool value)
public Bounds get_bounds()
private void INTERNAL_get_bounds(Bounds& value)
public ReflectionProbeMode get_mode()
public void set_mode(ReflectionProbeMode value)
public int get_importance()
public void set_importance(int value)
public ReflectionProbeRefreshMode get_refreshMode()
public void set_refreshMode(ReflectionProbeRefreshMode value)
public ReflectionProbeTimeSlicingMode get_timeSlicingMode()
public void set_timeSlicingMode(ReflectionProbeTimeSlicingMode value)
public Texture get_bakedTexture()
public void set_bakedTexture(Texture value)
public Texture get_customBakedTexture()
public void set_customBakedTexture(Texture value)
public Texture get_texture()
public Vector4 get_textureHDRDecodeValues()
private void INTERNAL_get_textureHDRDecodeValues(Vector4& value)
public int RenderProbe(RenderTexture targetTexture)
public int RenderProbe()
public bool IsFinishedRendering(int renderId)
public bool BlendCubemap(Texture src, Texture dst, float blend, RenderTexture target)
public int get_minBakedCubemapResolution()
public int get_maxBakedCubemapResolution()
public Vector4 get_defaultTextureHDRDecodeValues()
private void INTERNAL_get_defaultTextureHDRDecodeValues(Vector4& value)
public Texture get_defaultTexture()
}
public UnityEngine.RenderBuffer : ValueType {
internal int m_RenderTextureInstanceID
internal IntPtr m_BufferPtr
internal RenderBufferLoadAction loadAction
internal RenderBufferStoreAction storeAction
internal void SetLoadAction(RenderBufferLoadAction action)
internal void SetStoreAction(RenderBufferStoreAction action)
internal RenderBufferLoadAction get_loadAction()
internal void set_loadAction(RenderBufferLoadAction value)
internal RenderBufferStoreAction get_storeAction()
internal void set_storeAction(RenderBufferStoreAction value)
public IntPtr GetNativeRenderBufferPtr()
}
internal UnityEngine.RenderBufferHelper : ValueType {
internal int GetLoadAction(RenderBuffer& b)
internal void SetLoadAction(RenderBuffer& b, int a)
internal int GetStoreAction(RenderBuffer& b)
internal void SetStoreAction(RenderBuffer& b, int a)
internal IntPtr GetNativeRenderBufferPtr(IntPtr rb)
private void INTERNAL_CALL_GetNativeRenderBufferPtr(IntPtr rb, IntPtr& value)
}
public UnityEngine.Renderer : Component {
public bool castShadows
public bool motionVectors
public bool useLightProbes
public Bounds bounds
public bool enabled
public bool isVisible
public ShadowCastingMode shadowCastingMode
public bool receiveShadows
public MotionVectorGenerationMode motionVectorGenerationMode
public LightProbeUsage lightProbeUsage
public ReflectionProbeUsage reflectionProbeUsage
public UInt32 renderingLayerMask
public string sortingLayerName
public int sortingLayerID
public int sortingOrder
internal int sortingGroupID
internal int sortingGroupOrder
public bool allowOcclusionWhenDynamic
internal Transform staticBatchRootTransform
internal int staticBatchIndex
public bool isPartOfStaticBatch
public Matrix4x4 worldToLocalMatrix
public Matrix4x4 localToWorldMatrix
public GameObject lightProbeProxyVolumeOverride
public Transform probeAnchor
public int lightmapIndex
public int realtimeLightmapIndex
public Vector4 lightmapScaleOffset
public Vector4 realtimeLightmapScaleOffset
public Material[] materials
public Material material
public Material sharedMaterial
public Material[] sharedMaterials
public bool get_castShadows()
public void set_castShadows(bool value)
public bool get_motionVectors()
public void set_motionVectors(bool value)
public bool get_useLightProbes()
public void set_useLightProbes(bool value)
public Bounds get_bounds()
private void SetStaticLightmapST(Vector4 st)
private Material GetMaterial()
private Material GetSharedMaterial()
private void SetMaterial(Material m)
private Material[] GetMaterialArray()
private Material[] GetSharedMaterialArray()
private void SetMaterialArray(Material[] m)
internal void Internal_SetPropertyBlock(MaterialPropertyBlock properties)
internal void Internal_GetPropertyBlock(MaterialPropertyBlock dest)
internal void Internal_SetPropertyBlockMaterialIndex(MaterialPropertyBlock properties, int materialIndex)
internal void Internal_GetPropertyBlockMaterialIndex(MaterialPropertyBlock dest, int materialIndex)
public bool HasPropertyBlock()
public void SetPropertyBlock(MaterialPropertyBlock properties)
public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex)
public void GetPropertyBlock(MaterialPropertyBlock properties)
public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex)
private void GetClosestReflectionProbesInternal(object result)
public bool get_enabled()
public void set_enabled(bool value)
public bool get_isVisible()
public ShadowCastingMode get_shadowCastingMode()
public void set_shadowCastingMode(ShadowCastingMode value)
public bool get_receiveShadows()
public void set_receiveShadows(bool value)
public MotionVectorGenerationMode get_motionVectorGenerationMode()
public void set_motionVectorGenerationMode(MotionVectorGenerationMode value)
public LightProbeUsage get_lightProbeUsage()
public void set_lightProbeUsage(LightProbeUsage value)
public ReflectionProbeUsage get_reflectionProbeUsage()
public void set_reflectionProbeUsage(ReflectionProbeUsage value)
public UInt32 get_renderingLayerMask()
public void set_renderingLayerMask(UInt32 value)
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
internal int get_sortingGroupID()
internal void set_sortingGroupID(int value)
internal int get_sortingGroupOrder()
internal void set_sortingGroupOrder(int value)
public bool get_allowOcclusionWhenDynamic()
public void set_allowOcclusionWhenDynamic(bool value)
internal Transform get_staticBatchRootTransform()
internal void set_staticBatchRootTransform(Transform value)
internal int get_staticBatchIndex()
internal void SetStaticBatchInfo(int firstSubMesh, int subMeshCount)
public bool get_isPartOfStaticBatch()
public Matrix4x4 get_worldToLocalMatrix()
public Matrix4x4 get_localToWorldMatrix()
public GameObject get_lightProbeProxyVolumeOverride()
public void set_lightProbeProxyVolumeOverride(GameObject value)
public Transform get_probeAnchor()
public void set_probeAnchor(Transform value)
private int GetLightmapIndex(LightmapType lt)
private void SetLightmapIndex(int index, LightmapType lt)
private Vector4 GetLightmapST(LightmapType lt)
private void SetLightmapST(Vector4 st, LightmapType lt)
public int get_lightmapIndex()
public void set_lightmapIndex(int value)
public int get_realtimeLightmapIndex()
public void set_realtimeLightmapIndex(int value)
public Vector4 get_lightmapScaleOffset()
public void set_lightmapScaleOffset(Vector4 value)
public Vector4 get_realtimeLightmapScaleOffset()
public void set_realtimeLightmapScaleOffset(Vector4 value)
public Material[] get_materials()
public void set_materials(Material[] value)
public Material get_material()
public void set_material(Material value)
public Material get_sharedMaterial()
public void set_sharedMaterial(Material value)
public Material[] get_sharedMaterials()
public void set_sharedMaterials(Material[] value)
public void GetClosestReflectionProbes(List`1<ReflectionProbeBlendInfo> result)
private void get_bounds_Injected(Bounds& ret)
private void SetStaticLightmapST_Injected(Vector4& st)
private void get_worldToLocalMatrix_Injected(Matrix4x4& ret)
private void get_localToWorldMatrix_Injected(Matrix4x4& ret)
private void GetLightmapST_Injected(LightmapType lt, Vector4& ret)
private void SetLightmapST_Injected(Vector4& st, LightmapType lt)
}
public UnityEngine.RendererExtensions : object {
public void UpdateGIMaterials(Renderer renderer)
internal void UpdateGIMaterialsForRenderer(Renderer renderer)
}
public UnityEngine.Rendering.AmbientMode : Enum {
public int value__
public AmbientMode Skybox
public AmbientMode Trilight
public AmbientMode Flat
public AmbientMode Custom
}
public UnityEngine.Rendering.BlendMode : Enum {
public int value__
public BlendMode Zero
public BlendMode One
public BlendMode DstColor
public BlendMode SrcColor
public BlendMode OneMinusDstColor
public BlendMode SrcAlpha
public BlendMode OneMinusSrcColor
public BlendMode DstAlpha
public BlendMode OneMinusDstAlpha
public BlendMode SrcAlphaSaturate
public BlendMode OneMinusSrcAlpha
}
public UnityEngine.Rendering.BlendOp : Enum {
public int value__
public BlendOp Add
public BlendOp Subtract
public BlendOp ReverseSubtract
public BlendOp Min
public BlendOp Max
public BlendOp LogicalClear
public BlendOp LogicalSet
public BlendOp LogicalCopy
public BlendOp LogicalCopyInverted
public BlendOp LogicalNoop
public BlendOp LogicalInvert
public BlendOp LogicalAnd
public BlendOp LogicalNand
public BlendOp LogicalOr
public BlendOp LogicalNor
public BlendOp LogicalXor
public BlendOp LogicalEquivalence
public BlendOp LogicalAndReverse
public BlendOp LogicalAndInverted
public BlendOp LogicalOrReverse
public BlendOp LogicalOrInverted
public BlendOp Multiply
public BlendOp Screen
public BlendOp Overlay
public BlendOp Darken
public BlendOp Lighten
public BlendOp ColorDodge
public BlendOp ColorBurn
public BlendOp HardLight
public BlendOp SoftLight
public BlendOp Difference
public BlendOp Exclusion
public BlendOp HSLHue
public BlendOp HSLSaturation
public BlendOp HSLColor
public BlendOp HSLLuminosity
}
public UnityEngine.Rendering.BuiltinRenderTextureType : Enum {
public int value__
public BuiltinRenderTextureType PropertyName
public BuiltinRenderTextureType BufferPtr
public BuiltinRenderTextureType RenderTexture
public BuiltinRenderTextureType BindableTexture
public BuiltinRenderTextureType None
public BuiltinRenderTextureType CurrentActive
public BuiltinRenderTextureType CameraTarget
public BuiltinRenderTextureType Depth
public BuiltinRenderTextureType DepthNormals
public BuiltinRenderTextureType ResolvedDepth
public BuiltinRenderTextureType PrepassNormalsSpec
public BuiltinRenderTextureType PrepassLight
public BuiltinRenderTextureType PrepassLightSpec
public BuiltinRenderTextureType GBuffer0
public BuiltinRenderTextureType GBuffer1
public BuiltinRenderTextureType GBuffer2
public BuiltinRenderTextureType GBuffer3
public BuiltinRenderTextureType Reflections
public BuiltinRenderTextureType MotionVectors
public BuiltinRenderTextureType GBuffer4
public BuiltinRenderTextureType GBuffer5
public BuiltinRenderTextureType GBuffer6
public BuiltinRenderTextureType GBuffer7
}
public UnityEngine.Rendering.BuiltinShaderDefine : Enum {
public int value__
public BuiltinShaderDefine UNITY_NO_DXT5nm
public BuiltinShaderDefine UNITY_NO_RGBM
public BuiltinShaderDefine UNITY_USE_NATIVE_HDR
public BuiltinShaderDefine UNITY_ENABLE_REFLECTION_BUFFERS
public BuiltinShaderDefine UNITY_FRAMEBUFFER_FETCH_AVAILABLE
public BuiltinShaderDefine UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS
public BuiltinShaderDefine UNITY_METAL_SHADOWS_USE_POINT_FILTERING
public BuiltinShaderDefine UNITY_NO_CUBEMAP_ARRAY
public BuiltinShaderDefine UNITY_NO_SCREENSPACE_SHADOWS
public BuiltinShaderDefine UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS
public BuiltinShaderDefine UNITY_PBS_USE_BRDF1
public BuiltinShaderDefine UNITY_PBS_USE_BRDF2
public BuiltinShaderDefine UNITY_PBS_USE_BRDF3
public BuiltinShaderDefine UNITY_NO_FULL_STANDARD_SHADER
public BuiltinShaderDefine UNITY_SPECCUBE_BOX_PROJECTION
public BuiltinShaderDefine UNITY_SPECCUBE_BLENDING
public BuiltinShaderDefine UNITY_ENABLE_DETAIL_NORMALMAP
public BuiltinShaderDefine SHADER_API_MOBILE
public BuiltinShaderDefine SHADER_API_DESKTOP
public BuiltinShaderDefine UNITY_HARDWARE_TIER1
public BuiltinShaderDefine UNITY_HARDWARE_TIER2
public BuiltinShaderDefine UNITY_HARDWARE_TIER3
public BuiltinShaderDefine UNITY_COLORSPACE_GAMMA
public BuiltinShaderDefine UNITY_LIGHT_PROBE_PROXY_VOLUME
public BuiltinShaderDefine UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
public BuiltinShaderDefine UNITY_LIGHTMAP_DLDR_ENCODING
public BuiltinShaderDefine UNITY_LIGHTMAP_RGBM_ENCODING
public BuiltinShaderDefine UNITY_LIGHTMAP_FULL_HDR
}
public UnityEngine.Rendering.BuiltinShaderMode : Enum {
public int value__
public BuiltinShaderMode Disabled
public BuiltinShaderMode UseBuiltin
public BuiltinShaderMode UseCustom
}
public UnityEngine.Rendering.BuiltinShaderType : Enum {
public int value__
public BuiltinShaderType DeferredShading
public BuiltinShaderType DeferredReflections
public BuiltinShaderType LegacyDeferredLighting
public BuiltinShaderType ScreenSpaceShadows
public BuiltinShaderType DepthNormals
public BuiltinShaderType MotionVectors
public BuiltinShaderType LightHalo
public BuiltinShaderType LensFlare
}
public UnityEngine.Rendering.CameraEvent : Enum {
public int value__
public CameraEvent BeforeDepthTexture
public CameraEvent AfterDepthTexture
public CameraEvent BeforeDepthNormalsTexture
public CameraEvent AfterDepthNormalsTexture
public CameraEvent BeforeGBuffer
public CameraEvent AfterGBuffer
public CameraEvent BeforeLighting
public CameraEvent AfterLighting
public CameraEvent BeforeFinalPass
public CameraEvent AfterFinalPass
public CameraEvent BeforeForwardOpaque
public CameraEvent AfterForwardOpaque
public CameraEvent BeforeImageEffectsOpaque
public CameraEvent AfterImageEffectsOpaque
public CameraEvent BeforeSkybox
public CameraEvent AfterSkybox
public CameraEvent BeforeForwardAlpha
public CameraEvent AfterForwardAlpha
public CameraEvent BeforeImageEffects
public CameraEvent AfterImageEffects
public CameraEvent AfterEverything
public CameraEvent BeforeReflections
public CameraEvent AfterReflections
public CameraEvent BeforeHaloAndLensFlares
public CameraEvent AfterHaloAndLensFlares
}
public UnityEngine.Rendering.CameraHDRMode : Enum {
public int value__
public CameraHDRMode FP16
public CameraHDRMode R11G11B10
}
public UnityEngine.Rendering.ColorWriteMask : Enum {
public int value__
public ColorWriteMask Alpha
public ColorWriteMask Blue
public ColorWriteMask Green
public ColorWriteMask Red
public ColorWriteMask All
}
public UnityEngine.Rendering.CommandBuffer : object {
internal IntPtr m_Ptr
public string name
public int sizeInBytes
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
private void InitBuffer(CommandBuffer buf)
private IntPtr CreateGPUFence_Internal(SynchronisationStage stage)
private void INTERNAL_CALL_CreateGPUFence_Internal(CommandBuffer self, SynchronisationStage stage, IntPtr& value)
private void WaitOnGPUFence_Internal(IntPtr fencePtr, SynchronisationStage stage)
private void ReleaseBuffer()
public void Release()
public GPUFence CreateGPUFence()
public GPUFence CreateGPUFence(SynchronisationStage stage)
public void WaitOnGPUFence(GPUFence fence)
public void WaitOnGPUFence(GPUFence fence, SynchronisationStage stage)
public void SetComputeFloatParam(ComputeShader computeShader, string name, float val)
public void SetComputeFloatParam(ComputeShader computeShader, int nameID, float val)
public void SetComputeIntParam(ComputeShader computeShader, string name, int val)
public void SetComputeIntParam(ComputeShader computeShader, int nameID, int val)
public void SetComputeVectorParam(ComputeShader computeShader, string name, Vector4 val)
public void SetComputeVectorParam(ComputeShader computeShader, int nameID, Vector4 val)
private void INTERNAL_CALL_SetComputeVectorParam(CommandBuffer self, ComputeShader computeShader, int nameID, Vector4& val)
public void SetComputeVectorArrayParam(ComputeShader computeShader, string name, Vector4[] values)
public void SetComputeVectorArrayParam(ComputeShader computeShader, int nameID, Vector4[] values)
public void SetComputeMatrixParam(ComputeShader computeShader, string name, Matrix4x4 val)
public void SetComputeMatrixParam(ComputeShader computeShader, int nameID, Matrix4x4 val)
private void INTERNAL_CALL_SetComputeMatrixParam(CommandBuffer self, ComputeShader computeShader, int nameID, Matrix4x4& val)
public void SetComputeMatrixArrayParam(ComputeShader computeShader, string name, Matrix4x4[] values)
public void SetComputeMatrixArrayParam(ComputeShader computeShader, int nameID, Matrix4x4[] values)
public void SetComputeFloatParams(ComputeShader computeShader, string name, Single[] values)
public void SetComputeFloatParams(ComputeShader computeShader, int nameID, Single[] values)
private void Internal_SetComputeFloats(ComputeShader computeShader, int nameID, Single[] values)
public void SetComputeIntParams(ComputeShader computeShader, string name, Int32[] values)
public void SetComputeIntParams(ComputeShader computeShader, int nameID, Int32[] values)
private void Internal_SetComputeInts(ComputeShader computeShader, int nameID, Int32[] values)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt)
private void Internal_SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier& rt)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, ComputeBuffer buffer)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer)
public void DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
private void Internal_DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
public void DispatchCompute(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset)
private void Internal_DispatchComputeIndirect(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset)
public void GenerateMips(RenderTexture rt)
private void Internal_GenerateMips(RenderTexture rt)
public void CopyCounterValue(ComputeBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes)
public string get_name()
public void set_name(string value)
public int get_sizeInBytes()
public void Clear()
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
private void Internal_DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
private void INTERNAL_CALL_Internal_DrawMesh(CommandBuffer self, Mesh mesh, Matrix4x4& matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
public void DrawRenderer(Renderer renderer, Material material, int submeshIndex)
public void DrawRenderer(Renderer renderer, Material material)
public void DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass)
private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass)
private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex)
private void Internal_DrawRenderer(Renderer renderer, Material material)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
private void Internal_DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
private void INTERNAL_CALL_Internal_DrawProcedural(CommandBuffer self, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void INTERNAL_CALL_Internal_DrawProceduralIndirect(CommandBuffer self, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void SetRenderTarget(RenderTargetIdentifier rt)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth)
private void SetRenderTarget_Single(RenderTargetIdentifier& rt, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void SetRenderTarget_ColDepth(RenderTargetIdentifier& color, RenderTargetIdentifier& depth, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void SetRenderTarget_Multiple(RenderTargetIdentifier[] color, RenderTargetIdentifier& depth)
public void SetRandomWriteTarget(int index, RenderTargetIdentifier rt)
private void SetRandomWriteTarget_Texture(int index, RenderTargetIdentifier& rt)
public void SetRandomWriteTarget(int index, ComputeBuffer buffer)
public void SetRandomWriteTarget(int index, ComputeBuffer buffer, bool preserveCounterValue)
private void SetRandomWriteTarget_Buffer(int index, ComputeBuffer uav, bool preserveCounterValue)
public void ClearRandomWriteTargets()
public void CopyTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, RenderTargetIdentifier dst, int dstElement, int dstMip)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier dst, int dstElement, int dstMip, int dstX, int dstY)
public void SetViewport(Rect pixelRect)
private void INTERNAL_CALL_SetViewport(CommandBuffer self, Rect& pixelRect)
public void EnableScissorRect(Rect scissor)
private void INTERNAL_CALL_EnableScissorRect(CommandBuffer self, Rect& scissor)
public void DisableScissorRect()
private void CopyTexture_Internal(RenderTargetIdentifier& src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier& dst, int dstElement, int dstMip, int dstX, int dstY, int mode)
public void Blit(Texture source, RenderTargetIdentifier dest)
public void Blit(Texture source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset)
public void Blit(Texture source, RenderTargetIdentifier dest, Material mat)
public void Blit(Texture source, RenderTargetIdentifier dest, Material mat, int pass)
private void Blit_Texture(Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset)
private void INTERNAL_CALL_Blit_Texture(CommandBuffer self, Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass)
private void Blit_Identifier(RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset)
private void INTERNAL_CALL_Blit_Identifier(CommandBuffer self, RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer)
public void GetTemporaryRT(int nameID, int width, int height)
public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter)
public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc)
private void INTERNAL_CALL_GetTemporaryRT(CommandBuffer self, int nameID, RenderTextureDescriptor& desc, FilterMode filter)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, bool useDynamicScale)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices)
public void ReleaseTemporaryRT(int nameID)
public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor)
private void INTERNAL_CALL_ClearRenderTarget(CommandBuffer self, bool clearDepth, bool clearColor, Color& backgroundColor, float depth)
public void SetGlobalFloat(string name, float value)
public void SetGlobalFloat(int nameID, float value)
public void SetGlobalInt(string name, int value)
public void SetGlobalInt(int nameID, int value)
public void SetGlobalVector(string name, Vector4 value)
public void SetGlobalVector(int nameID, Vector4 value)
private void INTERNAL_CALL_SetGlobalVector(CommandBuffer self, int nameID, Vector4& value)
public void SetGlobalColor(string name, Color value)
public void SetGlobalColor(int nameID, Color value)
private void INTERNAL_CALL_SetGlobalColor(CommandBuffer self, int nameID, Color& value)
public void SetGlobalMatrix(string name, Matrix4x4 value)
public void SetGlobalMatrix(int nameID, Matrix4x4 value)
private void INTERNAL_CALL_SetGlobalMatrix(CommandBuffer self, int nameID, Matrix4x4& value)
public void EnableShaderKeyword(string keyword)
public void DisableShaderKeyword(string keyword)
public void SetViewMatrix(Matrix4x4 view)
private void INTERNAL_CALL_SetViewMatrix(CommandBuffer self, Matrix4x4& view)
public void SetProjectionMatrix(Matrix4x4 proj)
private void INTERNAL_CALL_SetProjectionMatrix(CommandBuffer self, Matrix4x4& proj)
public void SetViewProjectionMatrices(Matrix4x4 view, Matrix4x4 proj)
private void INTERNAL_CALL_SetViewProjectionMatrices(CommandBuffer self, Matrix4x4& view, Matrix4x4& proj)
public void SetGlobalDepthBias(float bias, float slopeBias)
public void SetGlobalFloatArray(string propertyName, List`1<float> values)
public void SetGlobalFloatArray(int nameID, List`1<float> values)
private void SetGlobalFloatArrayListImpl(int nameID, object values)
public void SetGlobalFloatArray(string propertyName, Single[] values)
public void SetGlobalFloatArray(int nameID, Single[] values)
public void SetGlobalVectorArray(string propertyName, List`1<Vector4> values)
public void SetGlobalVectorArray(int nameID, List`1<Vector4> values)
private void SetGlobalVectorArrayListImpl(int nameID, object values)
public void SetGlobalVectorArray(string propertyName, Vector4[] values)
public void SetGlobalVectorArray(int nameID, Vector4[] values)
public void SetGlobalMatrixArray(string propertyName, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values)
private void SetGlobalMatrixArrayListImpl(int nameID, object values)
public void SetGlobalMatrixArray(string propertyName, Matrix4x4[] values)
public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values)
public void SetGlobalTexture(string name, RenderTargetIdentifier value)
public void SetGlobalTexture(int nameID, RenderTargetIdentifier value)
private void SetGlobalTexture_Impl(int nameID, RenderTargetIdentifier& rt)
public void SetGlobalBuffer(string name, ComputeBuffer value)
public void SetGlobalBuffer(int nameID, ComputeBuffer value)
public void SetShadowSamplingMode(RenderTargetIdentifier shadowmap, ShadowSamplingMode mode)
private void SetShadowSamplingMode_Impl(RenderTargetIdentifier& shadowmap, ShadowSamplingMode mode)
public void IssuePluginEvent(IntPtr callback, int eventID)
private void IssuePluginEventInternal(IntPtr callback, int eventID)
public void BeginSample(string name)
public void EndSample(string name)
public void IssuePluginEventAndData(IntPtr callback, int eventID, IntPtr data)
private void IssuePluginEventAndDataInternal(IntPtr callback, int eventID, IntPtr data)
public void IssuePluginCustomBlit(IntPtr callback, UInt32 command, RenderTargetIdentifier source, RenderTargetIdentifier dest, UInt32 commandParam, UInt32 commandFlags)
private void IssuePluginCustomBlitInternal(IntPtr callback, UInt32 command, RenderTargetIdentifier& source, RenderTargetIdentifier& dest, UInt32 commandParam, UInt32 commandFlags)
private void IssuePluginCustomTextureUpdateInternal(IntPtr callback, Texture targetTexture, UInt32 userData)
public void IssuePluginCustomTextureUpdate(IntPtr callback, Texture targetTexture, UInt32 userData)
public void ConvertTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst)
public void ConvertTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
private void ConvertTexture_Internal(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
private void ConvertTexture_Internal_Injected(RenderTargetIdentifier& src, int srcElement, RenderTargetIdentifier& dst, int dstElement)
}
public UnityEngine.Rendering.CompareFunction : Enum {
public int value__
public CompareFunction Disabled
public CompareFunction Never
public CompareFunction Less
public CompareFunction Equal
public CompareFunction LessEqual
public CompareFunction Greater
public CompareFunction NotEqual
public CompareFunction GreaterEqual
public CompareFunction Always
}
public UnityEngine.Rendering.ComputeQueueType : Enum {
public int value__
public ComputeQueueType Default
public ComputeQueueType Background
public ComputeQueueType Urgent
}
public UnityEngine.Rendering.CopyTextureSupport : Enum {
public int value__
public CopyTextureSupport None
public CopyTextureSupport Basic
public CopyTextureSupport Copy3D
public CopyTextureSupport DifferentTypes
public CopyTextureSupport TextureToRT
public CopyTextureSupport RTToTexture
}
public UnityEngine.Rendering.CullMode : Enum {
public int value__
public CullMode Off
public CullMode Front
public CullMode Back
}
public UnityEngine.Rendering.DefaultReflectionMode : Enum {
public int value__
public DefaultReflectionMode Skybox
public DefaultReflectionMode Custom
}
public UnityEngine.Rendering.GPUFence : ValueType {
internal IntPtr m_Ptr
internal int m_Version
public bool passed
public bool get_passed()
private bool HasFencePassed_Internal(IntPtr fencePtr)
internal void InitPostAllocation()
internal bool IsFencePending()
internal void Validate()
private int GetPlatformNotSupportedVersion()
private int GetVersionNumber(IntPtr fencePtr)
}
public UnityEngine.Rendering.GraphicsDeviceType : Enum {
public int value__
public GraphicsDeviceType OpenGL2
public GraphicsDeviceType Direct3D9
public GraphicsDeviceType Direct3D11
public GraphicsDeviceType PlayStation3
public GraphicsDeviceType Null
public GraphicsDeviceType Xbox360
public GraphicsDeviceType OpenGLES2
public GraphicsDeviceType OpenGLES3
public GraphicsDeviceType PlayStationVita
public GraphicsDeviceType PlayStation4
public GraphicsDeviceType XboxOne
public GraphicsDeviceType PlayStationMobile
public GraphicsDeviceType Metal
public GraphicsDeviceType OpenGLCore
public GraphicsDeviceType Direct3D12
public GraphicsDeviceType N3DS
public GraphicsDeviceType Vulkan
public GraphicsDeviceType XboxOneD3D12
}
public UnityEngine.Rendering.GraphicsSettings : Object {
public RenderPipelineAsset renderPipelineAsset
private ScriptableObject INTERNAL_renderPipelineAsset
public TransparencySortMode transparencySortMode
public Vector3 transparencySortAxis
public bool lightsUseLinearIntensity
public bool lightsUseColorTemperature
public void SetShaderMode(BuiltinShaderType type, BuiltinShaderMode mode)
public BuiltinShaderMode GetShaderMode(BuiltinShaderType type)
public RenderPipelineAsset get_renderPipelineAsset()
public void set_renderPipelineAsset(RenderPipelineAsset value)
private ScriptableObject get_INTERNAL_renderPipelineAsset()
private void set_INTERNAL_renderPipelineAsset(ScriptableObject value)
public void SetCustomShader(BuiltinShaderType type, Shader shader)
public Shader GetCustomShader(BuiltinShaderType type)
internal Object GetGraphicsSettings()
public TransparencySortMode get_transparencySortMode()
public void set_transparencySortMode(TransparencySortMode value)
public Vector3 get_transparencySortAxis()
public void set_transparencySortAxis(Vector3 value)
private void INTERNAL_get_transparencySortAxis(Vector3& value)
private void INTERNAL_set_transparencySortAxis(Vector3& value)
public bool get_lightsUseLinearIntensity()
public void set_lightsUseLinearIntensity(bool value)
public bool get_lightsUseColorTemperature()
public void set_lightsUseColorTemperature(bool value)
private bool HasShaderDefineImpl(GraphicsTier tier, BuiltinShaderDefine defineHash)
public bool HasShaderDefine(GraphicsTier tier, BuiltinShaderDefine defineHash)
public bool HasShaderDefine(BuiltinShaderDefine defineHash)
}
public UnityEngine.Rendering.GraphicsTier : Enum {
public int value__
public GraphicsTier Tier1
public GraphicsTier Tier2
public GraphicsTier Tier3
}
public UnityEngine.Rendering.IndexFormat : Enum {
public int value__
public IndexFormat UInt16
public IndexFormat UInt32
}
public UnityEngine.Rendering.LightEvent : Enum {
public int value__
public LightEvent BeforeShadowMap
public LightEvent AfterShadowMap
public LightEvent BeforeScreenspaceMask
public LightEvent AfterScreenspaceMask
public LightEvent BeforeShadowMapPass
public LightEvent AfterShadowMapPass
}
public UnityEngine.Rendering.LightProbeUsage : Enum {
public int value__
public LightProbeUsage Off
public LightProbeUsage BlendProbes
public LightProbeUsage UseProxyVolume
public LightProbeUsage CustomProvided
}
public UnityEngine.Rendering.LightShadowResolution : Enum {
public int value__
public LightShadowResolution FromQualitySettings
public LightShadowResolution Low
public LightShadowResolution Medium
public LightShadowResolution High
public LightShadowResolution VeryHigh
}
public UnityEngine.Rendering.OpaqueSortMode : Enum {
public int value__
public OpaqueSortMode Default
public OpaqueSortMode FrontToBack
public OpaqueSortMode NoDistanceSort
}
public UnityEngine.Rendering.PassType : Enum {
public int value__
public PassType Normal
public PassType Vertex
public PassType VertexLM
public PassType VertexLMRGBM
public PassType ForwardBase
public PassType ForwardAdd
public PassType LightPrePassBase
public PassType LightPrePassFinal
public PassType ShadowCaster
public PassType Deferred
public PassType Meta
public PassType MotionVectors
}
public UnityEngine.Rendering.RealtimeGICPUUsage : Enum {
public int value__
public RealtimeGICPUUsage Low
public RealtimeGICPUUsage Medium
public RealtimeGICPUUsage High
public RealtimeGICPUUsage Unlimited
}
public UnityEngine.Rendering.ReflectionCubemapCompression : Enum {
public int value__
public ReflectionCubemapCompression Uncompressed
public ReflectionCubemapCompression Compressed
public ReflectionCubemapCompression Auto
}
public UnityEngine.Rendering.ReflectionProbeBlendInfo : ValueType {
public ReflectionProbe probe
public float weight
}
public UnityEngine.Rendering.ReflectionProbeClearFlags : Enum {
public int value__
public ReflectionProbeClearFlags Skybox
public ReflectionProbeClearFlags SolidColor
}
public UnityEngine.Rendering.ReflectionProbeMode : Enum {
public int value__
public ReflectionProbeMode Baked
public ReflectionProbeMode Realtime
public ReflectionProbeMode Custom
}
public UnityEngine.Rendering.ReflectionProbeRefreshMode : Enum {
public int value__
public ReflectionProbeRefreshMode OnAwake
public ReflectionProbeRefreshMode EveryFrame
public ReflectionProbeRefreshMode ViaScripting
}
public UnityEngine.Rendering.ReflectionProbeTimeSlicingMode : Enum {
public int value__
public ReflectionProbeTimeSlicingMode AllFacesAtOnce
public ReflectionProbeTimeSlicingMode IndividualFaces
public ReflectionProbeTimeSlicingMode NoTimeSlicing
}
public UnityEngine.Rendering.ReflectionProbeType : Enum {
public int value__
public ReflectionProbeType Cube
public ReflectionProbeType Card
}
public UnityEngine.Rendering.ReflectionProbeUsage : Enum {
public int value__
public ReflectionProbeUsage Off
public ReflectionProbeUsage BlendProbes
public ReflectionProbeUsage BlendProbesAndSkybox
public ReflectionProbeUsage Simple
}
public UnityEngine.Rendering.RenderBufferLoadAction : Enum {
public int value__
public RenderBufferLoadAction Load
public RenderBufferLoadAction Clear
public RenderBufferLoadAction DontCare
}
public UnityEngine.Rendering.RenderBufferStoreAction : Enum {
public int value__
public RenderBufferStoreAction Store
public RenderBufferStoreAction Resolve
public RenderBufferStoreAction StoreAndResolve
public RenderBufferStoreAction DontCare
}
public UnityEngine.Rendering.RenderQueue : Enum {
public int value__
public RenderQueue Background
public RenderQueue Geometry
public RenderQueue AlphaTest
public RenderQueue GeometryLast
public RenderQueue Transparent
public RenderQueue Overlay
}
public UnityEngine.Rendering.RenderTargetIdentifier : ValueType {
private BuiltinRenderTextureType m_Type
private int m_NameID
private int m_InstanceID
private IntPtr m_BufferPointer
private int m_MipLevel
private CubemapFace m_CubeFace
private int m_DepthSlice
public void .ctor(BuiltinRenderTextureType type)
public void .ctor(string name)
public void .ctor(string name, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(int nameID)
public void .ctor(int nameID, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(Texture tex)
public void .ctor(Texture tex, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(RenderBuffer buf, int mipLevel, CubemapFace cubeFace, int depthSlice)
public RenderTargetIdentifier op_Implicit(BuiltinRenderTextureType type)
public RenderTargetIdentifier op_Implicit(string name)
public RenderTargetIdentifier op_Implicit(int nameID)
public RenderTargetIdentifier op_Implicit(Texture tex)
public RenderTargetIdentifier op_Implicit(RenderBuffer buf)
public string ToString()
public int GetHashCode()
public bool Equals(RenderTargetIdentifier rhs)
public bool Equals(object obj)
public bool op_Equality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs)
public bool op_Inequality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs)
}
public UnityEngine.Rendering.ShaderHardwareTier : Enum {
public int value__
public ShaderHardwareTier Tier1
public ShaderHardwareTier Tier2
public ShaderHardwareTier Tier3
}
public UnityEngine.Rendering.ShadowCastingMode : Enum {
public int value__
public ShadowCastingMode Off
public ShadowCastingMode On
public ShadowCastingMode TwoSided
public ShadowCastingMode ShadowsOnly
}
public UnityEngine.Rendering.ShadowMapPass : Enum {
public int value__
public ShadowMapPass PointlightPositiveX
public ShadowMapPass PointlightNegativeX
public ShadowMapPass PointlightPositiveY
public ShadowMapPass PointlightNegativeY
public ShadowMapPass PointlightPositiveZ
public ShadowMapPass PointlightNegativeZ
public ShadowMapPass DirectionalCascade0
public ShadowMapPass DirectionalCascade1
public ShadowMapPass DirectionalCascade2
public ShadowMapPass DirectionalCascade3
public ShadowMapPass Spotlight
public ShadowMapPass Pointlight
public ShadowMapPass Directional
public ShadowMapPass All
}
public UnityEngine.Rendering.ShadowSamplingMode : Enum {
public int value__
public ShadowSamplingMode CompareDepths
public ShadowSamplingMode RawDepth
public ShadowSamplingMode None
}
public UnityEngine.Rendering.SortingGroup : Behaviour {
public string sortingLayerName
public int sortingLayerID
public int sortingOrder
internal int sortingGroupID
internal int sortingGroupOrder
internal int index
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
internal int get_sortingGroupID()
internal int get_sortingGroupOrder()
internal int get_index()
}
public UnityEngine.Rendering.SphericalHarmonicsL2 : ValueType {
private float shr0
private float shr1
private float shr2
private float shr3
private float shr4
private float shr5
private float shr6
private float shr7
private float shr8
private float shg0
private float shg1
private float shg2
private float shg3
private float shg4
private float shg5
private float shg6
private float shg7
private float shg8
private float shb0
private float shb1
private float shb2
private float shb3
private float shb4
private float shb5
private float shb6
private float shb7
private float shb8
public float Item
public void Clear()
private void ClearInternal(SphericalHarmonicsL2& sh)
private void INTERNAL_CALL_ClearInternal(SphericalHarmonicsL2& sh)
public void AddAmbientLight(Color color)
private void AddAmbientLightInternal(Color color, SphericalHarmonicsL2& sh)
private void INTERNAL_CALL_AddAmbientLightInternal(Color& color, SphericalHarmonicsL2& sh)
public void AddDirectionalLight(Vector3 direction, Color color, float intensity)
private void AddDirectionalLightInternal(Vector3 direction, Color color, SphericalHarmonicsL2& sh)
private void INTERNAL_CALL_AddDirectionalLightInternal(Vector3& direction, Color& color, SphericalHarmonicsL2& sh)
public void Evaluate(Vector3[] directions, Color[] results)
public float get_Item(int rgb, int coefficient)
public void set_Item(int rgb, int coefficient, float value)
public int GetHashCode()
public bool Equals(object other)
public SphericalHarmonicsL2 op_Multiply(SphericalHarmonicsL2 lhs, float rhs)
public SphericalHarmonicsL2 op_Multiply(float lhs, SphericalHarmonicsL2 rhs)
public SphericalHarmonicsL2 op_Addition(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
public bool op_Equality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
public bool op_Inequality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
}
public UnityEngine.Rendering.SplashScreen : object {
public bool isFinished
public bool get_isFinished()
public void Begin()
public void Draw()
}
public UnityEngine.Rendering.StencilOp : Enum {
public int value__
public StencilOp Keep
public StencilOp Zero
public StencilOp Replace
public StencilOp IncrementSaturate
public StencilOp DecrementSaturate
public StencilOp Invert
public StencilOp IncrementWrap
public StencilOp DecrementWrap
}
public UnityEngine.Rendering.SynchronisationStage : Enum {
public int value__
public SynchronisationStage VertexProcessing
public SynchronisationStage PixelProcessing
}
public UnityEngine.Rendering.TextureDimension : Enum {
public int value__
public TextureDimension Unknown
public TextureDimension None
public TextureDimension Any
public TextureDimension Tex2D
public TextureDimension Tex3D
public TextureDimension Cube
public TextureDimension Tex2DArray
public TextureDimension CubeArray
}
public UnityEngine.RenderingPath : Enum {
public int value__
public RenderingPath UsePlayerSettings
public RenderingPath VertexLit
public RenderingPath Forward
public RenderingPath DeferredLighting
public RenderingPath DeferredShading
}
public UnityEngine.RenderSettings : Object {
public float ambientSkyboxAmount
public bool fog
public float fogStartDistance
public float fogEndDistance
public FogMode fogMode
public Color fogColor
public float fogDensity
public AmbientMode ambientMode
public Color ambientSkyColor
public Color ambientEquatorColor
public Color ambientGroundColor
public float ambientIntensity
public Color ambientLight
public Color subtractiveShadowColor
public Material skybox
public Light sun
public SphericalHarmonicsL2 ambientProbe
public Cubemap customReflection
public float reflectionIntensity
public int reflectionBounces
public DefaultReflectionMode defaultReflectionMode
public int defaultReflectionResolution
public float haloStrength
public float flareStrength
public float flareFadeSpeed
public float get_ambientSkyboxAmount()
public void set_ambientSkyboxAmount(float value)
public bool get_fog()
public void set_fog(bool value)
public float get_fogStartDistance()
public void set_fogStartDistance(float value)
public float get_fogEndDistance()
public void set_fogEndDistance(float value)
public FogMode get_fogMode()
public void set_fogMode(FogMode value)
public Color get_fogColor()
public void set_fogColor(Color value)
public float get_fogDensity()
public void set_fogDensity(float value)
public AmbientMode get_ambientMode()
public void set_ambientMode(AmbientMode value)
public Color get_ambientSkyColor()
public void set_ambientSkyColor(Color value)
public Color get_ambientEquatorColor()
public void set_ambientEquatorColor(Color value)
public Color get_ambientGroundColor()
public void set_ambientGroundColor(Color value)
public float get_ambientIntensity()
public void set_ambientIntensity(float value)
public Color get_ambientLight()
public void set_ambientLight(Color value)
public Color get_subtractiveShadowColor()
public void set_subtractiveShadowColor(Color value)
public Material get_skybox()
public void set_skybox(Material value)
public Light get_sun()
public void set_sun(Light value)
public SphericalHarmonicsL2 get_ambientProbe()
public void set_ambientProbe(SphericalHarmonicsL2 value)
public Cubemap get_customReflection()
public void set_customReflection(Cubemap value)
public float get_reflectionIntensity()
public void set_reflectionIntensity(float value)
public int get_reflectionBounces()
public void set_reflectionBounces(int value)
public DefaultReflectionMode get_defaultReflectionMode()
public void set_defaultReflectionMode(DefaultReflectionMode value)
public int get_defaultReflectionResolution()
public void set_defaultReflectionResolution(int value)
public float get_haloStrength()
public void set_haloStrength(float value)
public float get_flareStrength()
public void set_flareStrength(float value)
public float get_flareFadeSpeed()
public void set_flareFadeSpeed(float value)
internal Object GetRenderSettings()
internal void Reset()
private void get_fogColor_Injected(Color& ret)
private void set_fogColor_Injected(Color& value)
private void get_ambientSkyColor_Injected(Color& ret)
private void set_ambientSkyColor_Injected(Color& value)
private void get_ambientEquatorColor_Injected(Color& ret)
private void set_ambientEquatorColor_Injected(Color& value)
private void get_ambientGroundColor_Injected(Color& ret)
private void set_ambientGroundColor_Injected(Color& value)
private void get_ambientLight_Injected(Color& ret)
private void set_ambientLight_Injected(Color& value)
private void get_subtractiveShadowColor_Injected(Color& ret)
private void set_subtractiveShadowColor_Injected(Color& value)
private void get_ambientProbe_Injected(SphericalHarmonicsL2& ret)
private void set_ambientProbe_Injected(SphericalHarmonicsL2& value)
}
public UnityEngine.RenderTargetSetup : ValueType {
public RenderBuffer[] color
public RenderBuffer depth
public int mipLevel
public CubemapFace cubemapFace
public int depthSlice
public RenderBufferLoadAction[] colorLoad
public RenderBufferStoreAction[] colorStore
public RenderBufferLoadAction depthLoad
public RenderBufferStoreAction depthStore
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, RenderBufferLoadAction[] colorLoad, RenderBufferStoreAction[] colorStore, RenderBufferLoadAction depthLoad, RenderBufferStoreAction depthStore)
public void .ctor(RenderBuffer color, RenderBuffer depth)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face, int depthSlice)
public void .ctor(RenderBuffer[] color, RenderBuffer depth)
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mipLevel)
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face)
internal RenderBufferLoadAction[] LoadActions(RenderBuffer[] buf)
internal RenderBufferStoreAction[] StoreActions(RenderBuffer[] buf)
}
public UnityEngine.RenderTexture : Texture {
public int depth
public RenderBuffer colorBuffer
public RenderBuffer depthBuffer
public RenderTexture active
public bool enabled
public int width
public int height
public TextureDimension dimension
public bool useMipMap
public bool sRGB
public RenderTextureFormat format
public VRTextureUsage vrUsage
public RenderTextureMemoryless memorylessMode
public bool autoGenerateMips
public int volumeDepth
public int antiAliasing
public bool bindTextureMS
public bool enableRandomWrite
public bool useDynamicScale
public bool isPowerOfTwo
public bool isCubemap
public bool isVolume
public RenderTextureDescriptor descriptor
public void .ctor(RenderTextureDescriptor desc)
public void .ctor(RenderTexture textureToCopy)
public void .ctor(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void .ctor(int width, int height, int depth, RenderTextureFormat format)
public void .ctor(int width, int height, int depth)
private void SetRenderTextureDescriptor(RenderTextureDescriptor desc)
private void INTERNAL_CALL_SetRenderTextureDescriptor(RenderTexture self, RenderTextureDescriptor& desc)
private RenderTextureDescriptor GetDescriptor()
private void INTERNAL_CALL_GetDescriptor(RenderTexture self, RenderTextureDescriptor& value)
private RenderTexture GetTemporary_Internal(RenderTextureDescriptor desc)
private RenderTexture INTERNAL_CALL_GetTemporary_Internal(RenderTextureDescriptor& desc)
public void ReleaseTemporary(RenderTexture temp)
public void ResolveAntiAliasedSurface()
public void ResolveAntiAliasedSurface(RenderTexture target)
private void Internal_ResolveAntiAliasedSurface(RenderTexture target)
public int get_depth()
public void set_depth(int value)
public void DiscardContents()
private void INTERNAL_CALL_DiscardContents(RenderTexture self)
public void DiscardContents(bool discardColor, bool discardDepth)
public void MarkRestoreExpected()
private void INTERNAL_CALL_MarkRestoreExpected(RenderTexture self)
public RenderBuffer get_colorBuffer()
public RenderBuffer get_depthBuffer()
private void GetColorBuffer(RenderBuffer& res)
private void GetDepthBuffer(RenderBuffer& res)
public IntPtr GetNativeDepthBufferPtr()
private void INTERNAL_CALL_GetNativeDepthBufferPtr(RenderTexture self, IntPtr& value)
public void SetGlobalShaderProperty(string propertyName)
public RenderTexture get_active()
public void set_active(RenderTexture value)
public bool get_enabled()
public void set_enabled(bool value)
public Vector2 GetTexelOffset()
public bool SupportsStencil(RenderTexture rt)
private VRTextureUsage GetActiveVRUsage()
public void SetBorderColor(Color color)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public bool get_useMipMap()
public void set_useMipMap(bool value)
public bool get_sRGB()
public RenderTextureFormat get_format()
public void set_format(RenderTextureFormat value)
public VRTextureUsage get_vrUsage()
public void set_vrUsage(VRTextureUsage value)
public RenderTextureMemoryless get_memorylessMode()
public void set_memorylessMode(RenderTextureMemoryless value)
public bool get_autoGenerateMips()
public void set_autoGenerateMips(bool value)
public int get_volumeDepth()
public void set_volumeDepth(int value)
public int get_antiAliasing()
public void set_antiAliasing(int value)
public bool get_bindTextureMS()
public void set_bindTextureMS(bool value)
public bool get_enableRandomWrite()
public void set_enableRandomWrite(bool value)
public bool get_useDynamicScale()
public void set_useDynamicScale(bool value)
private bool GetIsPowerOfTwo()
public bool get_isPowerOfTwo()
public void set_isPowerOfTwo(bool value)
public bool Create()
public void Release()
public bool IsCreated()
public void GenerateMips()
public void ConvertToEquirect(RenderTexture equirect, MonoOrStereoscopicEye eye)
internal void SetSRGBReadWrite(bool srgb)
private void Internal_Create(RenderTexture rt)
public bool get_isCubemap()
public void set_isCubemap(bool value)
public bool get_isVolume()
public void set_isVolume(bool value)
public RenderTextureDescriptor get_descriptor()
public void set_descriptor(RenderTextureDescriptor value)
private void ValidateRenderTextureDesc(RenderTextureDescriptor desc)
public RenderTexture GetTemporary(RenderTextureDescriptor desc)
private RenderTexture GetTemporaryImpl(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format)
public RenderTexture GetTemporary(int width, int height, int depthBuffer)
public RenderTexture GetTemporary(int width, int height)
}
public UnityEngine.RenderTextureCreationFlags : Enum {
public int value__
public RenderTextureCreationFlags MipMap
public RenderTextureCreationFlags AutoGenerateMips
public RenderTextureCreationFlags SRGB
public RenderTextureCreationFlags EyeTexture
public RenderTextureCreationFlags EnableRandomWrite
public RenderTextureCreationFlags CreatedFromScript
public RenderTextureCreationFlags AllowVerticalFlip
public RenderTextureCreationFlags NoResolvedColorSurface
public RenderTextureCreationFlags DynamicallyScalable
}
public UnityEngine.RenderTextureDescriptor : ValueType {
private int <width>k__BackingField
private int <height>k__BackingField
private int <msaaSamples>k__BackingField
private int <volumeDepth>k__BackingField
private int _bindMS
private RenderTextureFormat <colorFormat>k__BackingField
private int _depthBufferBits
private Int32[] depthFormatBits
private TextureDimension <dimension>k__BackingField
private ShadowSamplingMode <shadowSamplingMode>k__BackingField
private VRTextureUsage <vrUsage>k__BackingField
private RenderTextureCreationFlags _flags
private RenderTextureMemoryless <memoryless>k__BackingField
public int width
public int height
public int msaaSamples
public int volumeDepth
public bool bindMS
public RenderTextureFormat colorFormat
public int depthBufferBits
public TextureDimension dimension
public ShadowSamplingMode shadowSamplingMode
public VRTextureUsage vrUsage
public RenderTextureCreationFlags flags
public RenderTextureMemoryless memoryless
public bool sRGB
public bool useMipMap
public bool autoGenerateMips
public bool enableRandomWrite
internal bool createdFromScript
internal bool useDynamicScale
public void .ctor(int width, int height)
public void .ctor(int width, int height, RenderTextureFormat colorFormat)
public void .ctor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_msaaSamples()
public void set_msaaSamples(int value)
public int get_volumeDepth()
public void set_volumeDepth(int value)
public bool get_bindMS()
public void set_bindMS(bool value)
public RenderTextureFormat get_colorFormat()
public void set_colorFormat(RenderTextureFormat value)
public int get_depthBufferBits()
public void set_depthBufferBits(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public ShadowSamplingMode get_shadowSamplingMode()
public void set_shadowSamplingMode(ShadowSamplingMode value)
public VRTextureUsage get_vrUsage()
public void set_vrUsage(VRTextureUsage value)
public RenderTextureCreationFlags get_flags()
public RenderTextureMemoryless get_memoryless()
public void set_memoryless(RenderTextureMemoryless value)
private void SetOrClearRenderTextureCreationFlag(bool value, RenderTextureCreationFlags flag)
public bool get_sRGB()
public void set_sRGB(bool value)
public bool get_useMipMap()
public void set_useMipMap(bool value)
public bool get_autoGenerateMips()
public void set_autoGenerateMips(bool value)
public bool get_enableRandomWrite()
public void set_enableRandomWrite(bool value)
internal bool get_createdFromScript()
internal void set_createdFromScript(bool value)
internal bool get_useDynamicScale()
internal void set_useDynamicScale(bool value)
}
public UnityEngine.RenderTextureFormat : Enum {
public int value__
public RenderTextureFormat ARGB32
public RenderTextureFormat Depth
public RenderTextureFormat ARGBHalf
public RenderTextureFormat Shadowmap
public RenderTextureFormat RGB565
public RenderTextureFormat ARGB4444
public RenderTextureFormat ARGB1555
public RenderTextureFormat Default
public RenderTextureFormat ARGB2101010
public RenderTextureFormat DefaultHDR
public RenderTextureFormat ARGB64
public RenderTextureFormat ARGBFloat
public RenderTextureFormat RGFloat
public RenderTextureFormat RGHalf
public RenderTextureFormat RFloat
public RenderTextureFormat RHalf
public RenderTextureFormat R8
public RenderTextureFormat ARGBInt
public RenderTextureFormat RGInt
public RenderTextureFormat RInt
public RenderTextureFormat BGRA32
public RenderTextureFormat RGB111110Float
public RenderTextureFormat RG32
public RenderTextureFormat RGBAUShort
public RenderTextureFormat RG16
public RenderTextureFormat BGRA10101010_XR
public RenderTextureFormat BGR101010_XR
}
public UnityEngine.RenderTextureMemoryless : Enum {
public int value__
public RenderTextureMemoryless None
public RenderTextureMemoryless Color
public RenderTextureMemoryless Depth
public RenderTextureMemoryless MSAA
}
public UnityEngine.RenderTextureReadWrite : Enum {
public int value__
public RenderTextureReadWrite Default
public RenderTextureReadWrite Linear
public RenderTextureReadWrite sRGB
}
public UnityEngine.RequireComponent : Attribute {
public Type m_Type0
public Type m_Type1
public Type m_Type2
public void .ctor(Type requiredComponent)
public void .ctor(Type requiredComponent, Type requiredComponent2)
public void .ctor(Type requiredComponent, Type requiredComponent2, Type requiredComponent3)
}
public UnityEngine.Resolution : ValueType {
private int m_Width
private int m_Height
private int m_RefreshRate
public int width
public int height
public int refreshRate
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_refreshRate()
public void set_refreshRate(int value)
public string ToString()
}
public UnityEngine.ResourceRequest : AsyncOperation {
internal string m_Path
internal Type m_Type
public Object asset
public Object get_asset()
}
public UnityEngine.Resources : object {
internal T[] ConvertObjects(Object[] rawObjects)
public Object[] FindObjectsOfTypeAll(Type type)
public T[] FindObjectsOfTypeAll()
public Object Load(string path)
public T Load(string path)
public Object Load(string path, Type systemTypeInstance)
public ResourceRequest LoadAsync(string path)
public ResourceRequest LoadAsync(string path)
public ResourceRequest LoadAsync(string path, Type type)
internal ResourceRequest LoadAsyncInternal(string path, Type type)
public Object[] LoadAll(string path, Type systemTypeInstance)
public Object[] LoadAll(string path)
public T[] LoadAll(string path)
public Object GetBuiltinResource(Type type, string path)
public T GetBuiltinResource(string path)
public void UnloadAsset(Object assetToUnload)
public AsyncOperation UnloadUnusedAssets()
}
internal UnityEngine.RotationOrder : Enum {
public int value__
public RotationOrder OrderXYZ
public RotationOrder OrderXZY
public RotationOrder OrderYZX
public RotationOrder OrderYXZ
public RotationOrder OrderZXY
public RotationOrder OrderZYX
}
public UnityEngine.RPCMode : Enum {
public int value__
public RPCMode Server
public RPCMode Others
public RPCMode OthersBuffered
public RPCMode All
public RPCMode AllBuffered
}
public UnityEngine.RuntimeInitializeLoadType : Enum {
public int value__
public RuntimeInitializeLoadType AfterSceneLoad
public RuntimeInitializeLoadType BeforeSceneLoad
}
public UnityEngine.RuntimeInitializeOnLoadMethodAttribute : PreserveAttribute {
private RuntimeInitializeLoadType <loadType>k__BackingField
public RuntimeInitializeLoadType loadType
public void .ctor(RuntimeInitializeLoadType loadType)
public RuntimeInitializeLoadType get_loadType()
private void set_loadType(RuntimeInitializeLoadType value)
}
public UnityEngine.RuntimePlatform : Enum {
public int value__
public RuntimePlatform OSXEditor
public RuntimePlatform OSXPlayer
public RuntimePlatform WindowsPlayer
public RuntimePlatform OSXWebPlayer
public RuntimePlatform OSXDashboardPlayer
public RuntimePlatform WindowsWebPlayer
public RuntimePlatform WindowsEditor
public RuntimePlatform IPhonePlayer
public RuntimePlatform XBOX360
public RuntimePlatform PS3
public RuntimePlatform Android
public RuntimePlatform NaCl
public RuntimePlatform FlashPlayer
public RuntimePlatform LinuxPlayer
public RuntimePlatform LinuxEditor
public RuntimePlatform WebGLPlayer
public RuntimePlatform MetroPlayerX86
public RuntimePlatform WSAPlayerX86
public RuntimePlatform MetroPlayerX64
public RuntimePlatform WSAPlayerX64
public RuntimePlatform MetroPlayerARM
public RuntimePlatform WSAPlayerARM
public RuntimePlatform WP8Player
public RuntimePlatform BlackBerryPlayer
public RuntimePlatform TizenPlayer
public RuntimePlatform PSP2
public RuntimePlatform PS4
public RuntimePlatform PSM
public RuntimePlatform XboxOne
public RuntimePlatform SamsungTVPlayer
public RuntimePlatform WiiU
public RuntimePlatform tvOS
public RuntimePlatform Switch
}
internal UnityEngine.RuntimeUndo : object {
public void SetTransformParent(Transform transform, Transform newParent, string name)
public void RecordObject(Object objectToUndo, string name)
public void RecordObjects(Object[] objectsToUndo, string name)
}
public UnityEngine.ScalableBufferManager : object {
public float widthScaleFactor
public float heightScaleFactor
public float get_widthScaleFactor()
public float get_heightScaleFactor()
public void ResizeBuffers(float widthScale, float heightScale)
}
public UnityEngine.SceneManagement.LoadSceneMode : Enum {
public int value__
public LoadSceneMode Single
public LoadSceneMode Additive
}
public UnityEngine.SceneManagement.Scene : ValueType {
private int m_Handle
internal int handle
internal LoadingState loadingState
public string path
public string name
internal string guid
public bool isLoaded
public int buildIndex
public bool isDirty
public int rootCount
internal int get_handle()
internal LoadingState get_loadingState()
public bool IsValid()
public string get_path()
public string get_name()
internal void set_name(string value)
internal string get_guid()
public bool get_isLoaded()
public int get_buildIndex()
public bool get_isDirty()
public int get_rootCount()
public GameObject[] GetRootGameObjects()
public void GetRootGameObjects(List`1<GameObject> rootGameObjects)
public bool op_Equality(Scene lhs, Scene rhs)
public bool op_Inequality(Scene lhs, Scene rhs)
public int GetHashCode()
public bool Equals(object other)
private bool IsValidInternal(int sceneHandle)
private string GetPathInternal(int sceneHandle)
private string GetNameInternal(int sceneHandle)
private void SetNameInternal(int sceneHandle, string name)
private string GetGUIDInternal(int sceneHandle)
private bool GetIsLoadedInternal(int sceneHandle)
private LoadingState GetLoadingStateInternal(int sceneHandle)
private bool GetIsDirtyInternal(int sceneHandle)
private int GetBuildIndexInternal(int sceneHandle)
private int GetRootCountInternal(int sceneHandle)
private void GetRootGameObjectsInternal(int sceneHandle, object resultRootList)
}
public UnityEngine.SceneManagement.SceneManager : object {
private UnityAction`2<Scene, LoadSceneMode> sceneLoaded
private UnityAction`1<Scene> sceneUnloaded
private UnityAction`2<Scene, Scene> activeSceneChanged
public int sceneCount
public int sceneCountInBuildSettings
public int get_sceneCount()
public int get_sceneCountInBuildSettings()
public Scene GetActiveScene()
private void INTERNAL_CALL_GetActiveScene(Scene& value)
public bool SetActiveScene(Scene scene)
private bool INTERNAL_CALL_SetActiveScene(Scene& scene)
public Scene GetSceneByPath(string scenePath)
private void INTERNAL_CALL_GetSceneByPath(string scenePath, Scene& value)
public Scene GetSceneByName(string name)
private void INTERNAL_CALL_GetSceneByName(string name, Scene& value)
public Scene GetSceneByBuildIndex(int buildIndex)
private void INTERNAL_CALL_GetSceneByBuildIndex(int buildIndex, Scene& value)
public Scene GetSceneAt(int index)
private void INTERNAL_CALL_GetSceneAt(int index, Scene& value)
public Scene[] GetAllScenes()
public void LoadScene(string sceneName)
public void LoadScene(string sceneName, LoadSceneMode mode)
public void LoadScene(int sceneBuildIndex)
public void LoadScene(int sceneBuildIndex, LoadSceneMode mode)
public AsyncOperation LoadSceneAsync(string sceneName)
public AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode)
public AsyncOperation LoadSceneAsync(int sceneBuildIndex)
public AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneMode mode)
private AsyncOperation LoadSceneAsyncNameIndexInternal(string sceneName, int sceneBuildIndex, bool isAdditive, bool mustCompleteNextFrame)
public Scene CreateScene(string sceneName)
private void INTERNAL_CALL_CreateScene(string sceneName, Scene& value)
public bool UnloadScene(Scene scene)
private bool UnloadSceneInternal(Scene scene)
private bool INTERNAL_CALL_UnloadSceneInternal(Scene& scene)
public bool UnloadScene(int sceneBuildIndex)
public bool UnloadScene(string sceneName)
public AsyncOperation UnloadSceneAsync(int sceneBuildIndex)
public AsyncOperation UnloadSceneAsync(string sceneName)
public AsyncOperation UnloadSceneAsync(Scene scene)
private AsyncOperation UnloadSceneAsyncInternal(Scene scene)
private AsyncOperation INTERNAL_CALL_UnloadSceneAsyncInternal(Scene& scene)
private AsyncOperation UnloadSceneNameIndexInternal(string sceneName, int sceneBuildIndex, bool immediately, Boolean& outSuccess)
public void MergeScenes(Scene sourceScene, Scene destinationScene)
private void INTERNAL_CALL_MergeScenes(Scene& sourceScene, Scene& destinationScene)
public void MoveGameObjectToScene(GameObject go, Scene scene)
private void INTERNAL_CALL_MoveGameObjectToScene(GameObject go, Scene& scene)
public void add_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value)
public void remove_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value)
private void Internal_SceneLoaded(Scene scene, LoadSceneMode mode)
public void add_sceneUnloaded(UnityAction`1<Scene> value)
public void remove_sceneUnloaded(UnityAction`1<Scene> value)
private void Internal_SceneUnloaded(Scene scene)
public void add_activeSceneChanged(UnityAction`2<Scene, Scene> value)
public void remove_activeSceneChanged(UnityAction`2<Scene, Scene> value)
private void Internal_ActiveSceneChanged(Scene previousActiveScene, Scene newActiveScene)
}
public UnityEngine.SceneManagement.SceneUtility : object {
public string GetScenePathByBuildIndex(int buildIndex)
public int GetBuildIndexByScenePath(string scenePath)
}
public UnityEngine.Screen : object {
public int width
public int height
public float dpi
public ScreenOrientation orientation
public int sleepTimeout
public bool autorotateToPortrait
public bool autorotateToPortraitUpsideDown
public bool autorotateToLandscapeLeft
public bool autorotateToLandscapeRight
public Resolution currentResolution
public bool fullScreen
public FullScreenMode fullScreenMode
public Rect safeArea
public Resolution[] resolutions
public bool lockCursor
public int get_width()
public int get_height()
public float get_dpi()
private void RequestOrientation(ScreenOrientation orient)
private ScreenOrientation GetScreenOrientation()
public ScreenOrientation get_orientation()
public void set_orientation(ScreenOrientation value)
public int get_sleepTimeout()
public void set_sleepTimeout(int value)
private bool IsOrientationEnabled(EnabledOrientation orient)
private void SetOrientationEnabled(EnabledOrientation orient, bool enabled)
public bool get_autorotateToPortrait()
public void set_autorotateToPortrait(bool value)
public bool get_autorotateToPortraitUpsideDown()
public void set_autorotateToPortraitUpsideDown(bool value)
public bool get_autorotateToLandscapeLeft()
public void set_autorotateToLandscapeLeft(bool value)
public bool get_autorotateToLandscapeRight()
public void set_autorotateToLandscapeRight(bool value)
public Resolution get_currentResolution()
public bool get_fullScreen()
public void set_fullScreen(bool value)
public FullScreenMode get_fullScreenMode()
public void set_fullScreenMode(FullScreenMode value)
public Rect get_safeArea()
public void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate)
public void SetResolution(int width, int height, FullScreenMode fullscreenMode)
public void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate)
public void SetResolution(int width, int height, bool fullscreen)
public Resolution[] get_resolutions()
public bool get_lockCursor()
public void set_lockCursor(bool value)
private void get_currentResolution_Injected(Resolution& ret)
private void get_safeArea_Injected(Rect& ret)
}
public UnityEngine.ScreenOrientation : Enum {
public int value__
public ScreenOrientation Unknown
public ScreenOrientation Portrait
public ScreenOrientation PortraitUpsideDown
public ScreenOrientation LandscapeLeft
public ScreenOrientation LandscapeRight
public ScreenOrientation AutoRotation
public ScreenOrientation Landscape
}
public UnityEngine.ScriptableObject : Object {
public void SetDirty()
public ScriptableObject CreateInstance(string className)
public ScriptableObject CreateInstance(Type type)
public T CreateInstance()
private void CreateScriptableObject(ScriptableObject self)
private ScriptableObject CreateScriptableObjectInstanceFromName(string className)
private ScriptableObject CreateScriptableObjectInstanceFromType(Type type)
}
public UnityEngine.Scripting.APIUpdating.MovedFromAttribute : Attribute {
private string <Namespace>k__BackingField
private bool <IsInDifferentAssembly>k__BackingField
public string Namespace
public bool IsInDifferentAssembly
public void .ctor(string sourceNamespace)
public void .ctor(string sourceNamespace, bool isInDifferentAssembly)
public string get_Namespace()
private void set_Namespace(string value)
public bool get_IsInDifferentAssembly()
private void set_IsInDifferentAssembly(bool value)
}
internal UnityEngine.ScriptingRuntime : object {
public String[] GetAllUserAssemblies()
}
internal UnityEngine.ScrollWaitDefinitions : object {
public int firstWait
public int regularWait
}
public UnityEngine.Security : object {
public bool PrefetchSocketPolicy(string ip, int atPort)
public bool PrefetchSocketPolicy(string ip, int atPort, int timeout)
public Assembly LoadAndVerifyAssembly(Byte[] assemblyData, string authorizationKey)
public Assembly LoadAndVerifyAssembly(Byte[] assemblyData)
}
public UnityEngine.SendMessageOptions : Enum {
public int value__
public SendMessageOptions RequireReceiver
public SendMessageOptions DontRequireReceiver
}
internal UnityEngine.SendMouseEvents : object {
private int m_HitIndexGUI
private int m_HitIndexPhysics3D
private int m_HitIndexPhysics2D
private bool s_MouseUsed
private HitInfo[] m_LastHit
private HitInfo[] m_MouseDownHit
private HitInfo[] m_CurrentHit
private Camera[] m_Cameras
private void SetMouseMoved()
private void HitTestLegacyGUI(Camera camera, Vector3 mousePosition, HitInfo& hitInfo)
private void DoSendMouseEvents(int skipRTCameras)
private void SendEvents(int i, HitInfo hit)
}
internal UnityEngine.Serialization.DictionarySerializationSurrogate`2 : object {
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
}
public UnityEngine.Serialization.FormerlySerializedAsAttribute : Attribute {
private string m_oldName
public string oldName
public void .ctor(string oldName)
public string get_oldName()
}
internal UnityEngine.Serialization.ListSerializationSurrogate : object {
public ISerializationSurrogate Default
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
private Array ArrayFromGenericList(IList list)
}
public UnityEngine.Serialization.UnitySurrogateSelector : object {
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
}
internal UnityEngine.SetupCoroutine : object {
public void InvokeMoveNext(IEnumerator enumerator, IntPtr returnValueAddress)
public object InvokeMember(object behaviour, string name, object variable)
public object InvokeStatic(Type klass, string name, object variable)
}
public UnityEngine.Shader : Object {
public ShaderHardwareTier globalShaderHardwareTier
public int maximumLOD
public int globalMaximumLOD
public bool isSupported
public string globalRenderPipeline
public int renderQueue
internal DisableBatchingType disableBatching
public int PropertyToID(string name)
public ShaderHardwareTier get_globalShaderHardwareTier()
public void set_globalShaderHardwareTier(ShaderHardwareTier value)
public Shader Find(string name)
internal Shader FindBuiltin(string name)
public int get_maximumLOD()
public void set_maximumLOD(int value)
public int get_globalMaximumLOD()
public void set_globalMaximumLOD(int value)
public bool get_isSupported()
public string get_globalRenderPipeline()
public void set_globalRenderPipeline(string value)
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
public bool IsKeywordEnabled(string keyword)
public int get_renderQueue()
internal DisableBatchingType get_disableBatching()
public void WarmupAllShaders()
internal int TagToID(string name)
internal string IDToTag(int name)
private void SetGlobalFloatImpl(int name, float value)
private void SetGlobalVectorImpl(int name, Vector4 value)
private void SetGlobalMatrixImpl(int name, Matrix4x4 value)
private void SetGlobalTextureImpl(int name, Texture value)
private void SetGlobalBufferImpl(int name, ComputeBuffer value)
private float GetGlobalFloatImpl(int name)
private Vector4 GetGlobalVectorImpl(int name)
private Matrix4x4 GetGlobalMatrixImpl(int name)
private Texture GetGlobalTextureImpl(int name)
private void SetGlobalFloatArrayImpl(int name, Single[] values, int count)
private void SetGlobalVectorArrayImpl(int name, Vector4[] values, int count)
private void SetGlobalMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetGlobalFloatArrayImpl(int name)
private Vector4[] GetGlobalVectorArrayImpl(int name)
private Matrix4x4[] GetGlobalMatrixArrayImpl(int name)
private int GetGlobalFloatArrayCountImpl(int name)
private int GetGlobalVectorArrayCountImpl(int name)
private int GetGlobalMatrixArrayCountImpl(int name)
private void ExtractGlobalFloatArrayImpl(int name, Single[] val)
private void ExtractGlobalVectorArrayImpl(int name, Vector4[] val)
private void ExtractGlobalMatrixArrayImpl(int name, Matrix4x4[] val)
private void SetGlobalFloatArray(int name, Single[] values, int count)
private void SetGlobalVectorArray(int name, Vector4[] values, int count)
private void SetGlobalMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractGlobalFloatArray(int name, List`1<float> values)
private void ExtractGlobalVectorArray(int name, List`1<Vector4> values)
private void ExtractGlobalMatrixArray(int name, List`1<Matrix4x4> values)
public void SetGlobalFloat(string name, float value)
public void SetGlobalFloat(int name, float value)
public void SetGlobalInt(string name, int value)
public void SetGlobalInt(int name, int value)
public void SetGlobalVector(string name, Vector4 value)
public void SetGlobalVector(int name, Vector4 value)
public void SetGlobalColor(string name, Color value)
public void SetGlobalColor(int name, Color value)
public void SetGlobalMatrix(string name, Matrix4x4 value)
public void SetGlobalMatrix(int name, Matrix4x4 value)
public void SetGlobalTexture(string name, Texture value)
public void SetGlobalTexture(int name, Texture value)
public void SetGlobalBuffer(string name, ComputeBuffer value)
public void SetGlobalBuffer(int name, ComputeBuffer value)
public void SetGlobalFloatArray(string name, List`1<float> values)
public void SetGlobalFloatArray(int name, List`1<float> values)
public void SetGlobalFloatArray(string name, Single[] values)
public void SetGlobalFloatArray(int name, Single[] values)
public void SetGlobalVectorArray(string name, List`1<Vector4> values)
public void SetGlobalVectorArray(int name, List`1<Vector4> values)
public void SetGlobalVectorArray(string name, Vector4[] values)
public void SetGlobalVectorArray(int name, Vector4[] values)
public void SetGlobalMatrixArray(string name, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(int name, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(string name, Matrix4x4[] values)
public void SetGlobalMatrixArray(int name, Matrix4x4[] values)
public float GetGlobalFloat(string name)
public float GetGlobalFloat(int name)
public int GetGlobalInt(string name)
public int GetGlobalInt(int name)
public Vector4 GetGlobalVector(string name)
public Vector4 GetGlobalVector(int name)
public Color GetGlobalColor(string name)
public Color GetGlobalColor(int name)
public Matrix4x4 GetGlobalMatrix(string name)
public Matrix4x4 GetGlobalMatrix(int name)
public Texture GetGlobalTexture(string name)
public Texture GetGlobalTexture(int name)
public Single[] GetGlobalFloatArray(string name)
public Single[] GetGlobalFloatArray(int name)
public Vector4[] GetGlobalVectorArray(string name)
public Vector4[] GetGlobalVectorArray(int name)
public Matrix4x4[] GetGlobalMatrixArray(string name)
public Matrix4x4[] GetGlobalMatrixArray(int name)
public void GetGlobalFloatArray(string name, List`1<float> values)
public void GetGlobalFloatArray(int name, List`1<float> values)
public void GetGlobalVectorArray(string name, List`1<Vector4> values)
public void GetGlobalVectorArray(int name, List`1<Vector4> values)
public void GetGlobalMatrixArray(string name, List`1<Matrix4x4> values)
public void GetGlobalMatrixArray(int name, List`1<Matrix4x4> values)
private void SetGlobalVectorImpl_Injected(int name, Vector4& value)
private void SetGlobalMatrixImpl_Injected(int name, Matrix4x4& value)
private void GetGlobalVectorImpl_Injected(int name, Vector4& ret)
private void GetGlobalMatrixImpl_Injected(int name, Matrix4x4& ret)
}
public UnityEngine.ShaderVariantCollection : Object {
public int shaderCount
public int variantCount
public bool isWarmedUp
public int get_shaderCount()
public int get_variantCount()
public bool get_isWarmedUp()
private bool AddVariant(Shader shader, PassType passType, String[] keywords)
private bool RemoveVariant(Shader shader, PassType passType, String[] keywords)
private bool ContainsVariant(Shader shader, PassType passType, String[] keywords)
public void Clear()
public void WarmUp()
private void Internal_Create(ShaderVariantCollection svc)
public bool Add(ShaderVariant variant)
public bool Remove(ShaderVariant variant)
public bool Contains(ShaderVariant variant)
}
public UnityEngine.ShadowmaskMode : Enum {
public int value__
public ShadowmaskMode Shadowmask
public ShadowmaskMode DistanceShadowmask
}
public UnityEngine.ShadowProjection : Enum {
public int value__
public ShadowProjection CloseFit
public ShadowProjection StableFit
}
public UnityEngine.ShadowQuality : Enum {
public int value__
public ShadowQuality Disable
public ShadowQuality HardOnly
public ShadowQuality All
}
public UnityEngine.ShadowResolution : Enum {
public int value__
public ShadowResolution Low
public ShadowResolution Medium
public ShadowResolution High
public ShadowResolution VeryHigh
}
public UnityEngine.SkinnedMeshRenderer : Renderer {
public SkinQuality quality
public bool updateWhenOffscreen
public Transform rootBone
public Transform[] bones
public Mesh sharedMesh
public bool skinnedMotionVectors
public Bounds localBounds
public SkinQuality get_quality()
public void set_quality(SkinQuality value)
public bool get_updateWhenOffscreen()
public void set_updateWhenOffscreen(bool value)
public Transform get_rootBone()
public void set_rootBone(Transform value)
public Transform[] get_bones()
public void set_bones(Transform[] value)
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public bool get_skinnedMotionVectors()
public void set_skinnedMotionVectors(bool value)
public float GetBlendShapeWeight(int index)
public void SetBlendShapeWeight(int index, float value)
public void BakeMesh(Mesh mesh)
private Bounds GetLocalAABB()
private void SetLocalAABB(Bounds b)
public Bounds get_localBounds()
public void set_localBounds(Bounds value)
private void GetLocalAABB_Injected(Bounds& ret)
private void SetLocalAABB_Injected(Bounds& b)
}
public UnityEngine.SkinQuality : Enum {
public int value__
public SkinQuality Auto
public SkinQuality Bone1
public SkinQuality Bone2
public SkinQuality Bone4
}
public UnityEngine.Skybox : Behaviour {
public Material material
public Material get_material()
public void set_material(Material value)
}
public UnityEngine.SleepTimeout : object {
public int NeverSleep
public int SystemSetting
}
public UnityEngine.SortingLayer : ValueType {
private int m_Id
public int id
public string name
public int value
public SortingLayer[] layers
public int get_id()
public string get_name()
public int get_value()
public SortingLayer[] get_layers()
private Int32[] GetSortingLayerIDsInternal()
public int GetLayerValueFromID(int id)
public int GetLayerValueFromName(string name)
public int NameToID(string name)
public string IDToName(int id)
public bool IsValid(int id)
}
public UnityEngine.Space : Enum {
public int value__
public Space World
public Space Self
}
public UnityEngine.SpaceAttribute : PropertyAttribute {
public float height
public void .ctor(float height)
}
public UnityEngine.SparseTexture : Texture {
public int tileWidth
public int tileHeight
public bool isCreated
public void .ctor(int width, int height, TextureFormat format, int mipCount)
public void .ctor(int width, int height, TextureFormat format, int mipCount, bool linear)
public int get_tileWidth()
public int get_tileHeight()
public bool get_isCreated()
private void Internal_Create(SparseTexture mono, int width, int height, TextureFormat format, int mipCount, bool linear)
public void UpdateTile(int tileX, int tileY, int miplevel, Color32[] data)
public void UpdateTileRaw(int tileX, int tileY, int miplevel, Byte[] data)
public void UnloadTile(int tileX, int tileY, int miplevel)
}
public UnityEngine.Sprite : Object {
public Bounds bounds
public Rect rect
public Texture2D texture
public Texture2D associatedAlphaSplitTexture
public Rect textureRect
public Vector2 textureRectOffset
public bool packed
public SpritePackingMode packingMode
public SpritePackingRotation packingRotation
public Vector2 pivot
public Vector4 border
public Vector2[] vertices
public UInt16[] triangles
public Vector2[] uv
public float pixelsPerUnit
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot)
private Sprite INTERNAL_CALL_Create(Texture2D texture, Rect& rect, Vector2& pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4& border, bool generateFallbackPhysicsShape)
public Bounds get_bounds()
private void INTERNAL_get_bounds(Bounds& value)
public Rect get_rect()
private void INTERNAL_get_rect(Rect& value)
public Texture2D get_texture()
public Texture2D get_associatedAlphaSplitTexture()
public Rect get_textureRect()
private void INTERNAL_get_textureRect(Rect& value)
public Vector2 get_textureRectOffset()
public bool get_packed()
public SpritePackingMode get_packingMode()
public SpritePackingRotation get_packingRotation()
private void Internal_GetTextureRectOffset(Sprite sprite, Vector2& output)
private void Internal_GetPivot(Sprite sprite, Vector2& output)
public Vector2 get_pivot()
public Vector4 get_border()
private void INTERNAL_get_border(Vector4& value)
public Vector2[] get_vertices()
public UInt16[] get_triangles()
public Vector2[] get_uv()
public void OverrideGeometry(Vector2[] vertices, UInt16[] triangles)
public float get_pixelsPerUnit()
public int GetPhysicsShapeCount()
public int GetPhysicsShapePointCount(int shapeIdx)
private int Internal_GetPhysicsShapePointCount(int shapeIdx)
public int GetPhysicsShape(int shapeIdx, List`1<Vector2> physicsShape)
private void GetPhysicsShapeImpl(Sprite sprite, int shapeIdx, List`1<Vector2> physicsShape)
public void OverridePhysicsShape(IList`1<Vector2[]> physicsShapes)
internal Sprite Create(Rect rect, Vector2 pivot, float pixelsToUnits, Texture2D texture)
private void OverridePhysicsShapeCount(Sprite sprite, int physicsShapeCount)
private void OverridePhysicsShape(Sprite sprite, Vector2[] physicsShape, int idx)
private Sprite Create_Injected(Rect& rect, Vector2& pivot, float pixelsToUnits, Texture2D texture)
}
public UnityEngine.SpriteAlignment : Enum {
public int value__
public SpriteAlignment Center
public SpriteAlignment TopLeft
public SpriteAlignment TopCenter
public SpriteAlignment TopRight
public SpriteAlignment LeftCenter
public SpriteAlignment RightCenter
public SpriteAlignment BottomLeft
public SpriteAlignment BottomCenter
public SpriteAlignment BottomRight
public SpriteAlignment Custom
}
public UnityEngine.SpriteDrawMode : Enum {
public int value__
public SpriteDrawMode Simple
public SpriteDrawMode Sliced
public SpriteDrawMode Tiled
}
public UnityEngine.SpriteMaskInteraction : Enum {
public int value__
public SpriteMaskInteraction None
public SpriteMaskInteraction VisibleInsideMask
public SpriteMaskInteraction VisibleOutsideMask
}
public UnityEngine.SpriteMeshType : Enum {
public int value__
public SpriteMeshType FullRect
public SpriteMeshType Tight
}
public UnityEngine.SpritePackingMode : Enum {
public int value__
public SpritePackingMode Tight
public SpritePackingMode Rectangle
}
public UnityEngine.SpritePackingRotation : Enum {
public int value__
public SpritePackingRotation None
public SpritePackingRotation Any
}
public UnityEngine.SpriteRenderer : Renderer {
public Sprite sprite
public SpriteDrawMode drawMode
internal bool shouldSupportTiling
public Vector2 size
public float adaptiveModeThreshold
public SpriteTileMode tileMode
public Color color
public bool flipX
public bool flipY
public SpriteMaskInteraction maskInteraction
public Sprite get_sprite()
public void set_sprite(Sprite value)
public SpriteDrawMode get_drawMode()
public void set_drawMode(SpriteDrawMode value)
internal bool get_shouldSupportTiling()
public Vector2 get_size()
public void set_size(Vector2 value)
private void INTERNAL_get_size(Vector2& value)
private void INTERNAL_set_size(Vector2& value)
public float get_adaptiveModeThreshold()
public void set_adaptiveModeThreshold(float value)
public SpriteTileMode get_tileMode()
public void set_tileMode(SpriteTileMode value)
private Sprite GetSprite_INTERNAL()
private void SetSprite_INTERNAL(Sprite sprite)
public Color get_color()
public void set_color(Color value)
private void INTERNAL_get_color(Color& value)
private void INTERNAL_set_color(Color& value)
public bool get_flipX()
public void set_flipX(bool value)
public bool get_flipY()
public void set_flipY(bool value)
public SpriteMaskInteraction get_maskInteraction()
public void set_maskInteraction(SpriteMaskInteraction value)
internal Bounds GetSpriteBounds()
private void INTERNAL_CALL_GetSpriteBounds(SpriteRenderer self, Bounds& value)
}
public UnityEngine.Sprites.DataUtility : object {
public Vector4 GetInnerUV(Sprite sprite)
private void INTERNAL_CALL_GetInnerUV(Sprite sprite, Vector4& value)
public Vector4 GetOuterUV(Sprite sprite)
private void INTERNAL_CALL_GetOuterUV(Sprite sprite, Vector4& value)
public Vector4 GetPadding(Sprite sprite)
private void INTERNAL_CALL_GetPadding(Sprite sprite, Vector4& value)
public Vector2 GetMinSize(Sprite sprite)
private void Internal_GetMinSize(Sprite sprite, Vector2& output)
}
public UnityEngine.SpriteTileMode : Enum {
public int value__
public SpriteTileMode Continuous
public SpriteTileMode Adaptive
}
public UnityEngine.StackTraceLogType : Enum {
public int value__
public StackTraceLogType None
public StackTraceLogType ScriptOnly
public StackTraceLogType Full
}
public UnityEngine.StackTraceUtility : object {
private string projectFolder
internal void SetProjectFolder(string folder)
public string ExtractStackTrace()
private bool IsSystemStacktraceType(object name)
public string ExtractStringFromException(object exception)
internal void ExtractStringFromExceptionInternal(object exceptiono, String& message, String& stackTrace)
internal string PostprocessStacktrace(string oldString, bool stripEngineInternalInformation)
internal string ExtractFormattedStackTrace(StackTrace stackTrace)
}
internal UnityEngine.StaticBatchingHelper : ValueType {
internal Mesh InternalCombineVertices(MeshInstance[] meshes, string meshName)
internal void InternalCombineIndices(SubMeshInstance[] submeshes, Mesh combinedMesh)
}
public UnityEngine.StaticBatchingUtility : object {
public void Combine(GameObject staticBatchRoot)
public void Combine(GameObject[] gos, GameObject staticBatchRoot)
}
public UnityEngine.StereoTargetEyeMask : Enum {
public int value__
public StereoTargetEyeMask None
public StereoTargetEyeMask Left
public StereoTargetEyeMask Right
public StereoTargetEyeMask Both
}
internal UnityEngine.SystemClock : object {
private DateTime s_Epoch
public DateTime now
public DateTime get_now()
public long ToUnixTimeMilliseconds(DateTime date)
public long ToUnixTimeSeconds(DateTime date)
}
public UnityEngine.SystemInfo : object {
public string unsupportedIdentifier
public float batteryLevel
public BatteryStatus batteryStatus
public string operatingSystem
public OperatingSystemFamily operatingSystemFamily
public string processorType
public int processorFrequency
public int processorCount
public int systemMemorySize
public string deviceUniqueIdentifier
public string deviceName
public string deviceModel
public bool supportsAccelerometer
public bool supportsGyroscope
public bool supportsLocationService
public bool supportsVibration
public bool supportsAudio
public DeviceType deviceType
public int graphicsMemorySize
public string graphicsDeviceName
public string graphicsDeviceVendor
public int graphicsDeviceID
public int graphicsDeviceVendorID
public GraphicsDeviceType graphicsDeviceType
public bool graphicsUVStartsAtTop
public string graphicsDeviceVersion
public int graphicsShaderLevel
public bool graphicsMultiThreaded
public bool supportsShadows
public bool supportsRawShadowDepthSampling
public bool supportsRenderTextures
public bool supportsMotionVectors
public bool supportsRenderToCubemap
public bool supportsImageEffects
public bool supports3DTextures
public bool supports2DArrayTextures
public bool supports3DRenderTextures
public bool supportsCubemapArrayTextures
public CopyTextureSupport copyTextureSupport
public bool supportsComputeShaders
public bool supportsInstancing
public bool supportsHardwareQuadTopology
public bool supports32bitsIndexBuffer
public bool supportsSparseTextures
public int supportedRenderTargetCount
public int supportsMultisampledTextures
public int supportsTextureWrapMirrorOnce
public bool usesReversedZBuffer
public int supportsStencil
public NPOTSupport npotSupport
public int maxTextureSize
public int maxCubemapSize
internal int maxRenderTextureSize
public bool supportsAsyncCompute
public bool supportsGPUFence
public bool supportsAsyncGPUReadback
public int graphicsPixelFillrate
public bool supportsVertexPrograms
public float get_batteryLevel()
public BatteryStatus get_batteryStatus()
public string get_operatingSystem()
public OperatingSystemFamily get_operatingSystemFamily()
public string get_processorType()
public int get_processorFrequency()
public int get_processorCount()
public int get_systemMemorySize()
public string get_deviceUniqueIdentifier()
public string get_deviceName()
public string get_deviceModel()
public bool get_supportsAccelerometer()
public bool get_supportsGyroscope()
public bool get_supportsLocationService()
public bool get_supportsVibration()
public bool get_supportsAudio()
public DeviceType get_deviceType()
public int get_graphicsMemorySize()
public string get_graphicsDeviceName()
public string get_graphicsDeviceVendor()
public int get_graphicsDeviceID()
public int get_graphicsDeviceVendorID()
public GraphicsDeviceType get_graphicsDeviceType()
public bool get_graphicsUVStartsAtTop()
public string get_graphicsDeviceVersion()
public int get_graphicsShaderLevel()
public bool get_graphicsMultiThreaded()
public bool get_supportsShadows()
public bool get_supportsRawShadowDepthSampling()
public bool get_supportsRenderTextures()
public bool get_supportsMotionVectors()
public bool get_supportsRenderToCubemap()
public bool get_supportsImageEffects()
public bool get_supports3DTextures()
public bool get_supports2DArrayTextures()
public bool get_supports3DRenderTextures()
public bool get_supportsCubemapArrayTextures()
public CopyTextureSupport get_copyTextureSupport()
public bool get_supportsComputeShaders()
public bool get_supportsInstancing()
public bool get_supportsHardwareQuadTopology()
public bool get_supports32bitsIndexBuffer()
public bool get_supportsSparseTextures()
public int get_supportedRenderTargetCount()
public int get_supportsMultisampledTextures()
public int get_supportsTextureWrapMirrorOnce()
public bool get_usesReversedZBuffer()
public int get_supportsStencil()
public bool SupportsRenderTextureFormat(RenderTextureFormat format)
public bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format)
public bool SupportsTextureFormat(TextureFormat format)
public NPOTSupport get_npotSupport()
public int get_maxTextureSize()
public int get_maxCubemapSize()
internal int get_maxRenderTextureSize()
public bool get_supportsAsyncCompute()
public bool get_supportsGPUFence()
public bool get_supportsAsyncGPUReadback()
public int get_graphicsPixelFillrate()
public bool get_supportsVertexPrograms()
private float GetBatteryLevel()
private BatteryStatus GetBatteryStatus()
private string GetOperatingSystem()
private OperatingSystemFamily GetOperatingSystemFamily()
private string GetProcessorType()
private int GetProcessorFrequencyMHz()
private int GetProcessorCount()
private int GetPhysicalMemoryMB()
private string GetDeviceUniqueIdentifier()
private string GetDeviceName()
private string GetDeviceModel()
private bool SupportsAccelerometer()
private bool IsGyroAvailable()
private bool SupportsLocationService()
private bool SupportsVibration()
private bool SupportsAudio()
private DeviceType GetDeviceType()
private int GetGraphicsMemorySize()
private string GetGraphicsDeviceName()
private string GetGraphicsDeviceVendor()
private int GetGraphicsDeviceID()
private int GetGraphicsDeviceVendorID()
private GraphicsDeviceType GetGraphicsDeviceType()
private bool GetGraphicsUVStartsAtTop()
private string GetGraphicsDeviceVersion()
private int GetGraphicsShaderLevel()
private bool GetGraphicsMultiThreaded()
private bool SupportsShadows()
private bool SupportsRawShadowDepthSampling()
private bool SupportsMotionVectors()
private bool SupportsRenderToCubemap()
private bool SupportsImageEffects()
private bool Supports3DTextures()
private bool Supports2DArrayTextures()
private bool Supports3DRenderTextures()
private bool SupportsCubemapArrayTextures()
private CopyTextureSupport GetCopyTextureSupport()
private bool SupportsComputeShaders()
private bool SupportsInstancing()
private bool SupportsHardwareQuadTopology()
private bool Supports32bitsIndexBuffer()
private bool SupportsSparseTextures()
private int SupportedRenderTargetCount()
private int SupportsMultisampledTextures()
private int SupportsTextureWrapMirrorOnce()
private bool UsesReversedZBuffer()
private bool HasRenderTextureNative(RenderTextureFormat format)
private bool SupportsBlendingOnRenderTextureFormatNative(RenderTextureFormat format)
private bool SupportsTextureFormatNative(TextureFormat format)
private NPOTSupport GetNPOTSupport()
private int GetMaxTextureSize()
private int GetMaxCubemapSize()
private int GetMaxRenderTextureSize()
private bool SupportsAsyncCompute()
private bool SupportsGPUFence()
private bool SupportsAsyncGPUReadback()
}
public UnityEngine.SystemLanguage : Enum {
public int value__
public SystemLanguage Afrikaans
public SystemLanguage Arabic
public SystemLanguage Basque
public SystemLanguage Belarusian
public SystemLanguage Bulgarian
public SystemLanguage Catalan
public SystemLanguage Chinese
public SystemLanguage Czech
public SystemLanguage Danish
public SystemLanguage Dutch
public SystemLanguage English
public SystemLanguage Estonian
public SystemLanguage Faroese
public SystemLanguage Finnish
public SystemLanguage French
public SystemLanguage German
public SystemLanguage Greek
public SystemLanguage Hebrew
public SystemLanguage Icelandic
public SystemLanguage Indonesian
public SystemLanguage Italian
public SystemLanguage Japanese
public SystemLanguage Korean
public SystemLanguage Latvian
public SystemLanguage Lithuanian
public SystemLanguage Norwegian
public SystemLanguage Polish
public SystemLanguage Portuguese
public SystemLanguage Romanian
public SystemLanguage Russian
public SystemLanguage SerboCroatian
public SystemLanguage Slovak
public SystemLanguage Slovenian
public SystemLanguage Spanish
public SystemLanguage Swedish
public SystemLanguage Thai
public SystemLanguage Turkish
public SystemLanguage Ukrainian
public SystemLanguage Vietnamese
public SystemLanguage ChineseSimplified
public SystemLanguage ChineseTraditional
public SystemLanguage Unknown
public SystemLanguage Hungarian
}
public UnityEngine.TexGenMode : Enum {
public int value__
public TexGenMode None
public TexGenMode SphereMap
public TexGenMode Object
public TexGenMode EyeLinear
public TexGenMode CubeReflect
public TexGenMode CubeNormal
}
public UnityEngine.TextAreaAttribute : PropertyAttribute {
public int minLines
public int maxLines
public void .ctor(int minLines, int maxLines)
}
public UnityEngine.TextAsset : Object {
public string text
public Byte[] bytes
public void .ctor(string text)
public string get_text()
public Byte[] get_bytes()
public string ToString()
private void Internal_CreateInstance(TextAsset self, string text)
}
public UnityEngine.Texture : Object {
public UInt32 updateCount
public int masterTextureLimit
public AnisotropicFiltering anisotropicFiltering
public int width
public int height
public TextureDimension dimension
public TextureWrapMode wrapMode
public TextureWrapMode wrapModeU
public TextureWrapMode wrapModeV
public TextureWrapMode wrapModeW
public FilterMode filterMode
public int anisoLevel
public float mipMapBias
public Vector2 texelSize
public UInt32 get_updateCount()
public void IncrementUpdateCount()
public int get_masterTextureLimit()
public void set_masterTextureLimit(int value)
public AnisotropicFiltering get_anisotropicFiltering()
public void set_anisotropicFiltering(AnisotropicFiltering value)
public void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax)
private int GetDataWidth()
private int GetDataHeight()
private TextureDimension GetDimension()
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public TextureWrapMode get_wrapMode()
public void set_wrapMode(TextureWrapMode value)
public TextureWrapMode get_wrapModeU()
public void set_wrapModeU(TextureWrapMode value)
public TextureWrapMode get_wrapModeV()
public void set_wrapModeV(TextureWrapMode value)
public TextureWrapMode get_wrapModeW()
public void set_wrapModeW(TextureWrapMode value)
public FilterMode get_filterMode()
public void set_filterMode(FilterMode value)
public int get_anisoLevel()
public void set_anisoLevel(int value)
public float get_mipMapBias()
public void set_mipMapBias(float value)
public Vector2 get_texelSize()
public IntPtr GetNativeTexturePtr()
public int GetNativeTextureID()
internal UnityException CreateNonReadableException(Texture t)
private void get_texelSize_Injected(Vector2& ret)
}
public UnityEngine.Texture2D : Texture {
public int mipmapCount
public TextureFormat format
public Texture2D whiteTexture
public Texture2D blackTexture
internal void .ctor(int width, int height, TextureFormat format, bool mipmap, bool linear, IntPtr nativeTex)
public void .ctor(int width, int height, TextureFormat format, bool mipmap, bool linear)
public void .ctor(int width, int height, TextureFormat format, bool mipmap)
public void .ctor(int width, int height)
public void UpdateExternalTexture(IntPtr nativeTex)
private void SetAllPixels32(Color32[] colors, int miplevel)
private void SetBlockOfPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel)
public void SetPixels32(Color32[] colors)
public void SetPixels32(Color32[] colors, int miplevel)
public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors)
public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel)
public Byte[] GetRawTextureData()
public Color[] GetPixels()
public Color[] GetPixels(int miplevel)
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight, int miplevel)
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight)
public Color32[] GetPixels32(int miplevel)
public Color32[] GetPixels32()
public bool Resize(int width, int height, TextureFormat format, bool hasMipMap)
public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize, bool makeNoLongerReadable)
public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize)
public Rect[] PackTextures(Texture2D[] textures, int padding)
public bool GenerateAtlas(Vector2[] sizes, int padding, int atlasSize, List`1<Rect> results)
private void GenerateAtlasInternal(Vector2[] sizes, int padding, int atlasSize, object resultList)
public void ReadPixels(Rect source, int destX, int destY, bool recalculateMipMaps)
public void ReadPixels(Rect source, int destX, int destY)
private void INTERNAL_CALL_ReadPixels(Texture2D self, Rect& source, int destX, int destY, bool recalculateMipMaps)
public int get_mipmapCount()
public TextureFormat get_format()
public Texture2D get_whiteTexture()
public Texture2D get_blackTexture()
public void Compress(bool highQuality)
private bool Internal_CreateImpl(Texture2D mono, int w, int h, TextureFormat format, bool mipmap, bool linear, IntPtr nativeTex)
private void Internal_Create(Texture2D mono, int w, int h, TextureFormat format, bool mipmap, bool linear, IntPtr nativeTex)
private bool IsReadable()
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
private bool ResizeImpl(int width, int height)
private void SetPixelImpl(int image, int x, int y, Color color)
private Color GetPixelImpl(int image, int x, int y)
private Color GetPixelBilinearImpl(int image, float x, float y)
private void SetPixelsImpl(int x, int y, int w, int h, Color[] pixel, int miplevel, int frame)
private bool LoadRawTextureDataImpl(IntPtr data, int size)
private bool LoadRawTextureDataImplArray(Byte[] data)
public Texture2D CreateExternalTexture(int width, int height, TextureFormat format, bool mipmap, bool linear, IntPtr nativeTex)
public void SetPixel(int x, int y, Color color)
public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors, int miplevel)
public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors)
public void SetPixels(Color[] colors, int miplevel)
public void SetPixels(Color[] colors)
public Color GetPixel(int x, int y)
public Color GetPixelBilinear(float x, float y)
public void LoadRawTextureData(IntPtr data, int size)
public void LoadRawTextureData(Byte[] data)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
public bool Resize(int width, int height)
private void SetPixelImpl_Injected(int image, int x, int y, Color& color)
private void GetPixelImpl_Injected(int image, int x, int y, Color& ret)
private void GetPixelBilinearImpl_Injected(int image, float x, float y, Color& ret)
}
public UnityEngine.Texture2DArray : Texture {
public int depth
public TextureFormat format
public void .ctor(int width, int height, int depth, TextureFormat format, bool mipmap, bool linear)
public void .ctor(int width, int height, int depth, TextureFormat format, bool mipmap)
public void SetPixels(Color[] colors, int arrayElement, int miplevel)
public void SetPixels(Color[] colors, int arrayElement)
public void SetPixels32(Color32[] colors, int arrayElement, int miplevel)
public void SetPixels32(Color32[] colors, int arrayElement)
public Color[] GetPixels(int arrayElement, int miplevel)
public Color[] GetPixels(int arrayElement)
public Color32[] GetPixels32(int arrayElement, int miplevel)
public Color32[] GetPixels32(int arrayElement)
public int get_depth()
public TextureFormat get_format()
private bool IsReadable()
private bool Internal_CreateImpl(Texture2DArray mono, int w, int h, int d, TextureFormat format, bool mipmap, bool linear)
private void Internal_Create(Texture2DArray mono, int w, int h, int d, TextureFormat format, bool mipmap, bool linear)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
}
public UnityEngine.Texture3D : Texture {
public int depth
public TextureFormat format
public void .ctor(int width, int height, int depth, TextureFormat format, bool mipmap)
public Color[] GetPixels(int miplevel)
public Color[] GetPixels()
public Color32[] GetPixels32(int miplevel)
public Color32[] GetPixels32()
public void SetPixels(Color[] colors, int miplevel)
public void SetPixels(Color[] colors)
public void SetPixels32(Color32[] colors, int miplevel)
public void SetPixels32(Color32[] colors)
public int get_depth()
public TextureFormat get_format()
private bool IsReadable()
private bool Internal_CreateImpl(Texture3D mono, int w, int h, int d, TextureFormat format, bool mipmap)
private void Internal_Create(Texture3D mono, int w, int h, int d, TextureFormat format, bool mipmap)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
}
public UnityEngine.TextureFormat : Enum {
public int value__
public TextureFormat Alpha8
public TextureFormat ARGB4444
public TextureFormat RGB24
public TextureFormat RGBA32
public TextureFormat ARGB32
public TextureFormat RGB565
public TextureFormat R16
public TextureFormat DXT1
public TextureFormat DXT5
public TextureFormat RGBA4444
public TextureFormat BGRA32
public TextureFormat RHalf
public TextureFormat RGHalf
public TextureFormat RGBAHalf
public TextureFormat RFloat
public TextureFormat RGFloat
public TextureFormat RGBAFloat
public TextureFormat YUY2
public TextureFormat RGB9e5Float
public TextureFormat BC4
public TextureFormat BC5
public TextureFormat BC6H
public TextureFormat BC7
public TextureFormat DXT1Crunched
public TextureFormat DXT5Crunched
public TextureFormat PVRTC_RGB2
public TextureFormat PVRTC_RGBA2
public TextureFormat PVRTC_RGB4
public TextureFormat PVRTC_RGBA4
public TextureFormat ETC_RGB4
public TextureFormat EAC_R
public TextureFormat EAC_R_SIGNED
public TextureFormat EAC_RG
public TextureFormat EAC_RG_SIGNED
public TextureFormat ETC2_RGB
public TextureFormat ETC2_RGBA1
public TextureFormat ETC2_RGBA8
public TextureFormat ASTC_RGB_4x4
public TextureFormat ASTC_RGB_5x5
public TextureFormat ASTC_RGB_6x6
public TextureFormat ASTC_RGB_8x8
public TextureFormat ASTC_RGB_10x10
public TextureFormat ASTC_RGB_12x12
public TextureFormat ASTC_RGBA_4x4
public TextureFormat ASTC_RGBA_5x5
public TextureFormat ASTC_RGBA_6x6
public TextureFormat ASTC_RGBA_8x8
public TextureFormat ASTC_RGBA_10x10
public TextureFormat ASTC_RGBA_12x12
public TextureFormat ETC_RGB4_3DS
public TextureFormat ETC_RGBA8_3DS
public TextureFormat RG16
public TextureFormat R8
public TextureFormat ETC_RGB4Crunched
public TextureFormat ETC2_RGBA8Crunched
}
public UnityEngine.TextureWrapMode : Enum {
public int value__
public TextureWrapMode Repeat
public TextureWrapMode Clamp
public TextureWrapMode Mirror
public TextureWrapMode MirrorOnce
}
public UnityEngine.ThreadPriority : Enum {
public int value__
public ThreadPriority Low
public ThreadPriority BelowNormal
public ThreadPriority Normal
public ThreadPriority High
}
public UnityEngine.Time : object {
public float time
public float timeSinceLevelLoad
public float deltaTime
public float fixedTime
public float unscaledTime
public float fixedUnscaledTime
public float unscaledDeltaTime
public float fixedUnscaledDeltaTime
public float fixedDeltaTime
public float maximumDeltaTime
public float smoothDeltaTime
public float maximumParticleDeltaTime
public float timeScale
public int frameCount
public int renderedFrameCount
public float realtimeSinceStartup
public int captureFramerate
public bool inFixedTimeStep
public float get_time()
public float get_timeSinceLevelLoad()
public float get_deltaTime()
public float get_fixedTime()
public float get_unscaledTime()
public float get_fixedUnscaledTime()
public float get_unscaledDeltaTime()
public float get_fixedUnscaledDeltaTime()
public float get_fixedDeltaTime()
public void set_fixedDeltaTime(float value)
public float get_maximumDeltaTime()
public void set_maximumDeltaTime(float value)
public float get_smoothDeltaTime()
public float get_maximumParticleDeltaTime()
public void set_maximumParticleDeltaTime(float value)
public float get_timeScale()
public void set_timeScale(float value)
public int get_frameCount()
public int get_renderedFrameCount()
public float get_realtimeSinceStartup()
public int get_captureFramerate()
public void set_captureFramerate(int value)
public bool get_inFixedTimeStep()
}
public UnityEngine.Tizen.Window : object {
public IntPtr windowHandle
public IntPtr evasGL
public IntPtr get_windowHandle()
public IntPtr get_evasGL()
}
public UnityEngine.TooltipAttribute : PropertyAttribute {
public string tooltip
public void .ctor(string tooltip)
}
public UnityEngine.Touch : ValueType {
private int m_FingerId
private Vector2 m_Position
private Vector2 m_RawPosition
private Vector2 m_PositionDelta
private float m_TimeDelta
private int m_TapCount
private TouchPhase m_Phase
private TouchType m_Type
private float m_Pressure
private float m_maximumPossiblePressure
private float m_Radius
private float m_RadiusVariance
private float m_AltitudeAngle
private float m_AzimuthAngle
public int fingerId
public Vector2 position
public Vector2 rawPosition
public Vector2 deltaPosition
public float deltaTime
public int tapCount
public TouchPhase phase
public float pressure
public float maximumPossiblePressure
public TouchType type
public float altitudeAngle
public float azimuthAngle
public float radius
public float radiusVariance
public int get_fingerId()
public void set_fingerId(int value)
public Vector2 get_position()
public void set_position(Vector2 value)
public Vector2 get_rawPosition()
public void set_rawPosition(Vector2 value)
public Vector2 get_deltaPosition()
public void set_deltaPosition(Vector2 value)
public float get_deltaTime()
public void set_deltaTime(float value)
public int get_tapCount()
public void set_tapCount(int value)
public TouchPhase get_phase()
public void set_phase(TouchPhase value)
public float get_pressure()
public void set_pressure(float value)
public float get_maximumPossiblePressure()
public void set_maximumPossiblePressure(float value)
public TouchType get_type()
public void set_type(TouchType value)
public float get_altitudeAngle()
public void set_altitudeAngle(float value)
public float get_azimuthAngle()
public void set_azimuthAngle(float value)
public float get_radius()
public void set_radius(float value)
public float get_radiusVariance()
public void set_radiusVariance(float value)
}
public UnityEngine.TouchPhase : Enum {
public int value__
public TouchPhase Began
public TouchPhase Moved
public TouchPhase Stationary
public TouchPhase Ended
public TouchPhase Canceled
}
public UnityEngine.TouchScreenKeyboard : object {
public string text
public bool hideInput
public bool active
public bool done
public bool wasCanceled
public Status status
private Rect area
private bool visible
public bool isSupported
public int characterLimit
public bool canGetSelection
public bool canSetSelection
public RangeInt selection
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType)
public TouchScreenKeyboard Open(string text)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit)
public string get_text()
public void set_text(string value)
public bool get_hideInput()
public void set_hideInput(bool value)
public bool get_active()
public void set_active(bool value)
public bool get_done()
public bool get_wasCanceled()
public Status get_status()
private Rect get_area()
private bool get_visible()
public bool get_isSupported()
public int get_characterLimit()
public void set_characterLimit(int value)
public bool get_canGetSelection()
public bool get_canSetSelection()
public RangeInt get_selection()
public void set_selection(RangeInt value)
}
public UnityEngine.TouchScreenKeyboardType : Enum {
public int value__
public TouchScreenKeyboardType Default
public TouchScreenKeyboardType ASCIICapable
public TouchScreenKeyboardType NumbersAndPunctuation
public TouchScreenKeyboardType URL
public TouchScreenKeyboardType NumberPad
public TouchScreenKeyboardType PhonePad
public TouchScreenKeyboardType NamePhonePad
public TouchScreenKeyboardType EmailAddress
public TouchScreenKeyboardType NintendoNetworkAccount
public TouchScreenKeyboardType Social
public TouchScreenKeyboardType Search
}
public UnityEngine.TouchType : Enum {
public int value__
public TouchType Direct
public TouchType Indirect
public TouchType Stylus
}
public UnityEngine.TrackedReference : object {
internal IntPtr m_Ptr
public bool op_Equality(TrackedReference x, TrackedReference y)
public bool op_Inequality(TrackedReference x, TrackedReference y)
public bool Equals(object o)
public int GetHashCode()
public bool op_Implicit(TrackedReference exists)
}
public UnityEngine.TrailRenderer : Renderer {
public int numPositions
public float time
public float startWidth
public float endWidth
public float widthMultiplier
public bool autodestruct
public int numCornerVertices
public int numCapVertices
public float minVertexDistance
public Color startColor
public Color endColor
public int positionCount
public bool generateLightingData
public LineTextureMode textureMode
public LineAlignment alignment
public AnimationCurve widthCurve
public Gradient colorGradient
public int get_numPositions()
public float get_time()
public void set_time(float value)
public float get_startWidth()
public void set_startWidth(float value)
public float get_endWidth()
public void set_endWidth(float value)
public float get_widthMultiplier()
public void set_widthMultiplier(float value)
public bool get_autodestruct()
public void set_autodestruct(bool value)
public int get_numCornerVertices()
public void set_numCornerVertices(int value)
public int get_numCapVertices()
public void set_numCapVertices(int value)
public float get_minVertexDistance()
public void set_minVertexDistance(float value)
public Color get_startColor()
public void set_startColor(Color value)
public Color get_endColor()
public void set_endColor(Color value)
public int get_positionCount()
public Vector3 GetPosition(int index)
public bool get_generateLightingData()
public void set_generateLightingData(bool value)
public LineTextureMode get_textureMode()
public void set_textureMode(LineTextureMode value)
public LineAlignment get_alignment()
public void set_alignment(LineAlignment value)
public void Clear()
public AnimationCurve get_widthCurve()
public void set_widthCurve(AnimationCurve value)
public Gradient get_colorGradient()
public void set_colorGradient(Gradient value)
private AnimationCurve GetWidthCurveCopy()
private void SetWidthCurve(AnimationCurve curve)
private Gradient GetColorGradientCopy()
private void SetColorGradient(Gradient curve)
public int GetPositions(Vector3[] positions)
private void get_startColor_Injected(Color& ret)
private void set_startColor_Injected(Color& value)
private void get_endColor_Injected(Color& ret)
private void set_endColor_Injected(Color& value)
private void GetPosition_Injected(int index, Vector3& ret)
}
public UnityEngine.Transform : Component {
public Vector3 position
public Vector3 localPosition
public Vector3 eulerAngles
public Vector3 localEulerAngles
public Vector3 right
public Vector3 up
public Vector3 forward
public Quaternion rotation
public Quaternion localRotation
public Vector3 localScale
public Transform parent
internal Transform parentInternal
public Matrix4x4 worldToLocalMatrix
public Matrix4x4 localToWorldMatrix
public Transform root
public int childCount
public Vector3 lossyScale
public bool hasChanged
public int hierarchyCapacity
public int hierarchyCount
public Vector3 get_position()
public void set_position(Vector3 value)
private void INTERNAL_get_position(Vector3& value)
private void INTERNAL_set_position(Vector3& value)
public Vector3 get_localPosition()
public void set_localPosition(Vector3 value)
private void INTERNAL_get_localPosition(Vector3& value)
private void INTERNAL_set_localPosition(Vector3& value)
internal Vector3 GetLocalEulerAngles(RotationOrder order)
private void INTERNAL_CALL_GetLocalEulerAngles(Transform self, RotationOrder order, Vector3& value)
internal void SetLocalEulerAngles(Vector3 euler, RotationOrder order)
private void INTERNAL_CALL_SetLocalEulerAngles(Transform self, Vector3& euler, RotationOrder order)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public Vector3 get_localEulerAngles()
public void set_localEulerAngles(Vector3 value)
public Vector3 get_right()
public void set_right(Vector3 value)
public Vector3 get_up()
public void set_up(Vector3 value)
public Vector3 get_forward()
public void set_forward(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
private void INTERNAL_get_rotation(Quaternion& value)
private void INTERNAL_set_rotation(Quaternion& value)
public Quaternion get_localRotation()
public void set_localRotation(Quaternion value)
private void INTERNAL_get_localRotation(Quaternion& value)
private void INTERNAL_set_localRotation(Quaternion& value)
public Vector3 get_localScale()
public void set_localScale(Vector3 value)
private void INTERNAL_get_localScale(Vector3& value)
private void INTERNAL_set_localScale(Vector3& value)
public Transform get_parent()
public void set_parent(Transform value)
internal Transform get_parentInternal()
internal void set_parentInternal(Transform value)
public void SetParent(Transform parent)
public void SetParent(Transform parent, bool worldPositionStays)
public Matrix4x4 get_worldToLocalMatrix()
private void INTERNAL_get_worldToLocalMatrix(Matrix4x4& value)
public Matrix4x4 get_localToWorldMatrix()
private void INTERNAL_get_localToWorldMatrix(Matrix4x4& value)
public void SetPositionAndRotation(Vector3 position, Quaternion rotation)
private void INTERNAL_CALL_SetPositionAndRotation(Transform self, Vector3& position, Quaternion& rotation)
public void Translate(Vector3 translation)
public void Translate(Vector3 translation, Space relativeTo)
public void Translate(float x, float y, float z)
public void Translate(float x, float y, float z, Space relativeTo)
public void Translate(Vector3 translation, Transform relativeTo)
public void Translate(float x, float y, float z, Transform relativeTo)
public void Rotate(Vector3 eulerAngles)
public void Rotate(Vector3 eulerAngles, Space relativeTo)
public void Rotate(float xAngle, float yAngle, float zAngle)
public void Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo)
internal void RotateAroundInternal(Vector3 axis, float angle)
private void INTERNAL_CALL_RotateAroundInternal(Transform self, Vector3& axis, float angle)
public void Rotate(Vector3 axis, float angle)
public void Rotate(Vector3 axis, float angle, Space relativeTo)
public void RotateAround(Vector3 point, Vector3 axis, float angle)
public void LookAt(Transform target)
public void LookAt(Transform target, Vector3 worldUp)
public void LookAt(Vector3 worldPosition, Vector3 worldUp)
public void LookAt(Vector3 worldPosition)
private void INTERNAL_CALL_LookAt(Transform self, Vector3& worldPosition, Vector3& worldUp)
public Vector3 TransformDirection(Vector3 direction)
private void INTERNAL_CALL_TransformDirection(Transform self, Vector3& direction, Vector3& value)
public Vector3 TransformDirection(float x, float y, float z)
public Vector3 InverseTransformDirection(Vector3 direction)
private void INTERNAL_CALL_InverseTransformDirection(Transform self, Vector3& direction, Vector3& value)
public Vector3 InverseTransformDirection(float x, float y, float z)
public Vector3 TransformVector(Vector3 vector)
private void INTERNAL_CALL_TransformVector(Transform self, Vector3& vector, Vector3& value)
public Vector3 TransformVector(float x, float y, float z)
public Vector3 InverseTransformVector(Vector3 vector)
private void INTERNAL_CALL_InverseTransformVector(Transform self, Vector3& vector, Vector3& value)
public Vector3 InverseTransformVector(float x, float y, float z)
public Vector3 TransformPoint(Vector3 position)
private void INTERNAL_CALL_TransformPoint(Transform self, Vector3& position, Vector3& value)
public Vector3 TransformPoint(float x, float y, float z)
public Vector3 InverseTransformPoint(Vector3 position)
private void INTERNAL_CALL_InverseTransformPoint(Transform self, Vector3& position, Vector3& value)
public Vector3 InverseTransformPoint(float x, float y, float z)
public Transform get_root()
public int get_childCount()
public void DetachChildren()
public void SetAsFirstSibling()
public void SetAsLastSibling()
public void SetSiblingIndex(int index)
public int GetSiblingIndex()
public Transform Find(string name)
public Vector3 get_lossyScale()
private void INTERNAL_get_lossyScale(Vector3& value)
public bool IsChildOf(Transform parent)
public bool get_hasChanged()
public void set_hasChanged(bool value)
public Transform FindChild(string name)
public IEnumerator GetEnumerator()
public void RotateAround(Vector3 axis, float angle)
private void INTERNAL_CALL_RotateAround(Transform self, Vector3& axis, float angle)
public void RotateAroundLocal(Vector3 axis, float angle)
private void INTERNAL_CALL_RotateAroundLocal(Transform self, Vector3& axis, float angle)
public Transform GetChild(int index)
public int GetChildCount()
public int get_hierarchyCapacity()
public void set_hierarchyCapacity(int value)
public int get_hierarchyCount()
}
public UnityEngine.TransparencySortMode : Enum {
public int value__
public TransparencySortMode Default
public TransparencySortMode Perspective
public TransparencySortMode Orthographic
public TransparencySortMode CustomAxis
}
public UnityEngine.Types : object {
public Type GetType(string typeName, string assemblyName)
}
public UnityEngine.U2D.SpriteAtlas : Object {
public bool isVariant
public string tag
public int spriteCount
public bool get_isVariant()
public string get_tag()
public int get_spriteCount()
public int GetSprites(Sprite[] sprites)
public int GetSprites(Sprite[] sprites, string name)
internal int GetSpritesByName(Sprite[] sprites, string name)
public Sprite GetSprite(string name)
}
public UnityEngine.U2D.SpriteAtlasManager : object {
private RequestAtlasCallback atlasRequested
private Action`1<SpriteAtlas> <>f__mg$cache0
public void add_atlasRequested(RequestAtlasCallback value)
public void remove_atlasRequested(RequestAtlasCallback value)
private bool RequestAtlas(string tag)
internal void Register(SpriteAtlas spriteAtlas)
}
public UnityEngine.UnassignedReferenceException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public UnityEngine.UnityAPICompatibilityVersionAttribute : Attribute {
private string _version
public string version
public void .ctor(string version)
public string get_version()
}
public UnityEngine.UnityEventQueueSystem : object {
public string GenerateEventIdForPayload(string eventPayloadName)
public IntPtr GetGlobalEventQueue()
}
public UnityEngine.UnityException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal UnityEngine.UnityLogWriter : TextWriter {
public Encoding Encoding
public void WriteStringToUnityLog(string s)
private void WriteStringToUnityLogImpl(string s)
public void Init()
public Encoding get_Encoding()
public void Write(char value)
public void Write(string s)
public void Write(Char[] buffer, int index, int count)
}
internal UnityEngine.UnitySynchronizationContext : SynchronizationContext {
private int kAwqInitialCapacity
private Queue`1<WorkRequest> m_AsyncWorkQueue
private int m_MainThreadID
public void Send(SendOrPostCallback callback, object state)
public void Post(SendOrPostCallback callback, object state)
private void Exec()
private void InitializeSynchronizationContext()
private void ExecuteTasks()
}
public UnityEngine.UserAuthorization : Enum {
public int value__
public UserAuthorization WebCam
public UserAuthorization Microphone
}
public UnityEngine.Vector2 : ValueType {
public float x
public float y
private Vector2 zeroVector
private Vector2 oneVector
private Vector2 upVector
private Vector2 downVector
private Vector2 leftVector
private Vector2 rightVector
private Vector2 positiveInfinityVector
private Vector2 negativeInfinityVector
public float kEpsilon
public float Item
public Vector2 normalized
public float magnitude
public float sqrMagnitude
public Vector2 zero
public Vector2 one
public Vector2 up
public Vector2 down
public Vector2 left
public Vector2 right
public Vector2 positiveInfinity
public Vector2 negativeInfinity
public void .ctor(float x, float y)
public float get_Item(int index)
public void set_Item(int index, float value)
public void Set(float newX, float newY)
public Vector2 Lerp(Vector2 a, Vector2 b, float t)
public Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t)
public Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta)
public Vector2 Scale(Vector2 a, Vector2 b)
public void Scale(Vector2 scale)
public void Normalize()
public Vector2 get_normalized()
public string ToString()
public string ToString(string format)
public int GetHashCode()
public bool Equals(object other)
public Vector2 Reflect(Vector2 inDirection, Vector2 inNormal)
public Vector2 Perpendicular(Vector2 inDirection)
public float Dot(Vector2 lhs, Vector2 rhs)
public float get_magnitude()
public float get_sqrMagnitude()
public float Angle(Vector2 from, Vector2 to)
public float SignedAngle(Vector2 from, Vector2 to)
public float Distance(Vector2 a, Vector2 b)
public Vector2 ClampMagnitude(Vector2 vector, float maxLength)
public float SqrMagnitude(Vector2 a)
public float SqrMagnitude()
public Vector2 Min(Vector2 lhs, Vector2 rhs)
public Vector2 Max(Vector2 lhs, Vector2 rhs)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public Vector2 op_Addition(Vector2 a, Vector2 b)
public Vector2 op_Subtraction(Vector2 a, Vector2 b)
public Vector2 op_Multiply(Vector2 a, Vector2 b)
public Vector2 op_Division(Vector2 a, Vector2 b)
public Vector2 op_UnaryNegation(Vector2 a)
public Vector2 op_Multiply(Vector2 a, float d)
public Vector2 op_Multiply(float d, Vector2 a)
public Vector2 op_Division(Vector2 a, float d)
public bool op_Equality(Vector2 lhs, Vector2 rhs)
public bool op_Inequality(Vector2 lhs, Vector2 rhs)
public Vector2 op_Implicit(Vector3 v)
public Vector3 op_Implicit(Vector2 v)
public Vector2 get_zero()
public Vector2 get_one()
public Vector2 get_up()
public Vector2 get_down()
public Vector2 get_left()
public Vector2 get_right()
public Vector2 get_positiveInfinity()
public Vector2 get_negativeInfinity()
}
public UnityEngine.Vector2Int : ValueType {
private int m_X
private int m_Y
private Vector2Int s_Zero
private Vector2Int s_One
private Vector2Int s_Up
private Vector2Int s_Down
private Vector2Int s_Left
private Vector2Int s_Right
public int x
public int y
public int Item
public float magnitude
public int sqrMagnitude
public Vector2Int zero
public Vector2Int one
public Vector2Int up
public Vector2Int down
public Vector2Int left
public Vector2Int right
public void .ctor(int x, int y)
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public void Set(int x, int y)
public int get_Item(int index)
public void set_Item(int index, int value)
public float get_magnitude()
public int get_sqrMagnitude()
public float Distance(Vector2Int a, Vector2Int b)
public Vector2Int Min(Vector2Int lhs, Vector2Int rhs)
public Vector2Int Max(Vector2Int lhs, Vector2Int rhs)
public Vector2Int Scale(Vector2Int a, Vector2Int b)
public void Scale(Vector2Int scale)
public void Clamp(Vector2Int min, Vector2Int max)
public Vector2 op_Implicit(Vector2Int v)
public Vector2Int FloorToInt(Vector2 v)
public Vector2Int CeilToInt(Vector2 v)
public Vector2Int RoundToInt(Vector2 v)
public Vector2Int op_Addition(Vector2Int a, Vector2Int b)
public Vector2Int op_Subtraction(Vector2Int a, Vector2Int b)
public Vector2Int op_Multiply(Vector2Int a, Vector2Int b)
public Vector2Int op_Multiply(Vector2Int a, int b)
public bool op_Equality(Vector2Int lhs, Vector2Int rhs)
public bool op_Inequality(Vector2Int lhs, Vector2Int rhs)
public bool Equals(object other)
public int GetHashCode()
public string ToString()
public Vector2Int get_zero()
public Vector2Int get_one()
public Vector2Int get_up()
public Vector2Int get_down()
public Vector2Int get_left()
public Vector2Int get_right()
}
public UnityEngine.Vector3 : ValueType {
public float kEpsilon
public float x
public float y
public float z
private Vector3 zeroVector
private Vector3 oneVector
private Vector3 upVector
private Vector3 downVector
private Vector3 leftVector
private Vector3 rightVector
private Vector3 forwardVector
private Vector3 backVector
private Vector3 positiveInfinityVector
private Vector3 negativeInfinityVector
public float Item
public Vector3 normalized
public float magnitude
public float sqrMagnitude
public Vector3 zero
public Vector3 one
public Vector3 forward
public Vector3 back
public Vector3 up
public Vector3 down
public Vector3 left
public Vector3 right
public Vector3 positiveInfinity
public Vector3 negativeInfinity
public Vector3 fwd
public void .ctor(float x, float y, float z)
public void .ctor(float x, float y)
public Vector3 Slerp(Vector3 a, Vector3 b, float t)
public Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t)
private void OrthoNormalize2(Vector3& a, Vector3& b)
public void OrthoNormalize(Vector3& normal, Vector3& tangent)
private void OrthoNormalize3(Vector3& a, Vector3& b, Vector3& c)
public void OrthoNormalize(Vector3& normal, Vector3& tangent, Vector3& binormal)
public Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)
public Vector3 Lerp(Vector3 a, Vector3 b, float t)
public Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t)
public Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float get_Item(int index)
public void set_Item(int index, float value)
public void Set(float newX, float newY, float newZ)
public Vector3 Scale(Vector3 a, Vector3 b)
public void Scale(Vector3 scale)
public Vector3 Cross(Vector3 lhs, Vector3 rhs)
public int GetHashCode()
public bool Equals(object other)
public Vector3 Reflect(Vector3 inDirection, Vector3 inNormal)
public Vector3 Normalize(Vector3 value)
public void Normalize()
public Vector3 get_normalized()
public float Dot(Vector3 lhs, Vector3 rhs)
public Vector3 Project(Vector3 vector, Vector3 onNormal)
public Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal)
public float Angle(Vector3 from, Vector3 to)
public float SignedAngle(Vector3 from, Vector3 to, Vector3 axis)
public float Distance(Vector3 a, Vector3 b)
public Vector3 ClampMagnitude(Vector3 vector, float maxLength)
public float Magnitude(Vector3 vector)
public float get_magnitude()
public float SqrMagnitude(Vector3 vector)
public float get_sqrMagnitude()
public Vector3 Min(Vector3 lhs, Vector3 rhs)
public Vector3 Max(Vector3 lhs, Vector3 rhs)
public Vector3 get_zero()
public Vector3 get_one()
public Vector3 get_forward()
public Vector3 get_back()
public Vector3 get_up()
public Vector3 get_down()
public Vector3 get_left()
public Vector3 get_right()
public Vector3 get_positiveInfinity()
public Vector3 get_negativeInfinity()
public Vector3 op_Addition(Vector3 a, Vector3 b)
public Vector3 op_Subtraction(Vector3 a, Vector3 b)
public Vector3 op_UnaryNegation(Vector3 a)
public Vector3 op_Multiply(Vector3 a, float d)
public Vector3 op_Multiply(float d, Vector3 a)
public Vector3 op_Division(Vector3 a, float d)
public bool op_Equality(Vector3 lhs, Vector3 rhs)
public bool op_Inequality(Vector3 lhs, Vector3 rhs)
public string ToString()
public string ToString(string format)
public Vector3 get_fwd()
public float AngleBetween(Vector3 from, Vector3 to)
public Vector3 Exclude(Vector3 excludeThis, Vector3 fromThat)
private void Slerp_Injected(Vector3& a, Vector3& b, float t, Vector3& ret)
private void SlerpUnclamped_Injected(Vector3& a, Vector3& b, float t, Vector3& ret)
private void RotateTowards_Injected(Vector3& current, Vector3& target, float maxRadiansDelta, float maxMagnitudeDelta, Vector3& ret)
}
public UnityEngine.Vector3Int : ValueType {
private int m_X
private int m_Y
private int m_Z
private Vector3Int s_Zero
private Vector3Int s_One
private Vector3Int s_Up
private Vector3Int s_Down
private Vector3Int s_Left
private Vector3Int s_Right
public int x
public int y
public int z
public int Item
public float magnitude
public int sqrMagnitude
public Vector3Int zero
public Vector3Int one
public Vector3Int up
public Vector3Int down
public Vector3Int left
public Vector3Int right
public void .ctor(int x, int y, int z)
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public int get_z()
public void set_z(int value)
public void Set(int x, int y, int z)
public int get_Item(int index)
public void set_Item(int index, int value)
public float get_magnitude()
public int get_sqrMagnitude()
public float Distance(Vector3Int a, Vector3Int b)
public Vector3Int Min(Vector3Int lhs, Vector3Int rhs)
public Vector3Int Max(Vector3Int lhs, Vector3Int rhs)
public Vector3Int Scale(Vector3Int a, Vector3Int b)
public void Scale(Vector3Int scale)
public void Clamp(Vector3Int min, Vector3Int max)
public Vector3 op_Implicit(Vector3Int v)
public Vector3Int FloorToInt(Vector3 v)
public Vector3Int CeilToInt(Vector3 v)
public Vector3Int RoundToInt(Vector3 v)
public Vector3Int op_Addition(Vector3Int a, Vector3Int b)
public Vector3Int op_Subtraction(Vector3Int a, Vector3Int b)
public Vector3Int op_Multiply(Vector3Int a, Vector3Int b)
public Vector3Int op_Multiply(Vector3Int a, int b)
public bool op_Equality(Vector3Int lhs, Vector3Int rhs)
public bool op_Inequality(Vector3Int lhs, Vector3Int rhs)
public bool Equals(object other)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public Vector3Int get_zero()
public Vector3Int get_one()
public Vector3Int get_up()
public Vector3Int get_down()
public Vector3Int get_left()
public Vector3Int get_right()
}
public UnityEngine.Vector4 : ValueType {
public float kEpsilon
public float x
public float y
public float z
public float w
private Vector4 zeroVector
private Vector4 oneVector
private Vector4 positiveInfinityVector
private Vector4 negativeInfinityVector
public float Item
public Vector4 normalized
public float magnitude
public float sqrMagnitude
public Vector4 zero
public Vector4 one
public Vector4 positiveInfinity
public Vector4 negativeInfinity
public void .ctor(float x, float y, float z, float w)
public void .ctor(float x, float y, float z)
public void .ctor(float x, float y)
public float get_Item(int index)
public void set_Item(int index, float value)
public void Set(float newX, float newY, float newZ, float newW)
public Vector4 Lerp(Vector4 a, Vector4 b, float t)
public Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t)
public Vector4 MoveTowards(Vector4 current, Vector4 target, float maxDistanceDelta)
public Vector4 Scale(Vector4 a, Vector4 b)
public void Scale(Vector4 scale)
public int GetHashCode()
public bool Equals(object other)
public Vector4 Normalize(Vector4 a)
public void Normalize()
public Vector4 get_normalized()
public float Dot(Vector4 a, Vector4 b)
public Vector4 Project(Vector4 a, Vector4 b)
public float Distance(Vector4 a, Vector4 b)
public float Magnitude(Vector4 a)
public float get_magnitude()
public float get_sqrMagnitude()
public Vector4 Min(Vector4 lhs, Vector4 rhs)
public Vector4 Max(Vector4 lhs, Vector4 rhs)
public Vector4 get_zero()
public Vector4 get_one()
public Vector4 get_positiveInfinity()
public Vector4 get_negativeInfinity()
public Vector4 op_Addition(Vector4 a, Vector4 b)
public Vector4 op_Subtraction(Vector4 a, Vector4 b)
public Vector4 op_UnaryNegation(Vector4 a)
public Vector4 op_Multiply(Vector4 a, float d)
public Vector4 op_Multiply(float d, Vector4 a)
public Vector4 op_Division(Vector4 a, float d)
public bool op_Equality(Vector4 lhs, Vector4 rhs)
public bool op_Inequality(Vector4 lhs, Vector4 rhs)
public Vector4 op_Implicit(Vector3 v)
public Vector3 op_Implicit(Vector4 v)
public Vector4 op_Implicit(Vector2 v)
public Vector2 op_Implicit(Vector4 v)
public string ToString()
public string ToString(string format)
public float SqrMagnitude(Vector4 a)
public float SqrMagnitude()
}
public UnityEngine.VRTextureUsage : Enum {
public int value__
public VRTextureUsage None
public VRTextureUsage OneEye
public VRTextureUsage TwoEyes
}
public UnityEngine.WaitForSeconds : YieldInstruction {
internal float m_Seconds
public void .ctor(float seconds)
}
public UnityEngine.WaitForSecondsRealtime : CustomYieldInstruction {
private float waitTime
public bool keepWaiting
public void .ctor(float time)
public bool get_keepWaiting()
}
public UnityEngine.WaitUntil : CustomYieldInstruction {
private Func`1<bool> m_Predicate
public bool keepWaiting
public void .ctor(Func`1<bool> predicate)
public bool get_keepWaiting()
}
public UnityEngine.WaitWhile : CustomYieldInstruction {
private Func`1<bool> m_Predicate
public bool keepWaiting
public void .ctor(Func`1<bool> predicate)
public bool get_keepWaiting()
}
public UnityEngine.WeightedMode : Enum {
public int value__
public WeightedMode None
public WeightedMode In
public WeightedMode Out
public WeightedMode Both
}
public UnityEngine.Windows.CrashReporting : object {
public string crashReportFolder
public string get_crashReportFolder()
}
public UnityEngine.Windows.Speech.ConfidenceLevel : Enum {
public int value__
public ConfidenceLevel High
public ConfidenceLevel Medium
public ConfidenceLevel Low
public ConfidenceLevel Rejected
}
public UnityEngine.Windows.Speech.DictationCompletionCause : Enum {
public int value__
public DictationCompletionCause Complete
public DictationCompletionCause AudioQualityFailure
public DictationCompletionCause Canceled
public DictationCompletionCause TimeoutExceeded
public DictationCompletionCause PauseLimitExceeded
public DictationCompletionCause NetworkFailure
public DictationCompletionCause MicrophoneUnavailable
public DictationCompletionCause UnknownError
}
public UnityEngine.Windows.Speech.DictationRecognizer : object {
private IntPtr m_Recognizer
private DictationHypothesisDelegate DictationHypothesis
private DictationResultDelegate DictationResult
private DictationCompletedDelegate DictationComplete
private DictationErrorHandler DictationError
public SpeechSystemStatus Status
public float AutoSilenceTimeoutSeconds
public float InitialSilenceTimeoutSeconds
public void .ctor(ConfidenceLevel confidenceLevel)
public void .ctor(DictationTopicConstraint topic)
public void .ctor(ConfidenceLevel minimumConfidence, DictationTopicConstraint topic)
private IntPtr Create(ConfidenceLevel minimumConfidence, DictationTopicConstraint topicConstraint)
private void INTERNAL_CALL_Create(DictationRecognizer self, ConfidenceLevel minimumConfidence, DictationTopicConstraint topicConstraint, IntPtr& value)
private void Start(IntPtr self)
private void Stop(IntPtr self)
private void Destroy(IntPtr self)
private void DestroyThreaded(IntPtr self)
private SpeechSystemStatus GetStatus(IntPtr self)
private float GetAutoSilenceTimeoutSeconds(IntPtr self)
private void SetAutoSilenceTimeoutSeconds(IntPtr self, float value)
private float GetInitialSilenceTimeoutSeconds(IntPtr self)
private void SetInitialSilenceTimeoutSeconds(IntPtr self, float value)
public void add_DictationHypothesis(DictationHypothesisDelegate value)
public void remove_DictationHypothesis(DictationHypothesisDelegate value)
public void add_DictationResult(DictationResultDelegate value)
public void remove_DictationResult(DictationResultDelegate value)
public void add_DictationComplete(DictationCompletedDelegate value)
public void remove_DictationComplete(DictationCompletedDelegate value)
public void add_DictationError(DictationErrorHandler value)
public void remove_DictationError(DictationErrorHandler value)
public SpeechSystemStatus get_Status()
public float get_AutoSilenceTimeoutSeconds()
public void set_AutoSilenceTimeoutSeconds(float value)
public float get_InitialSilenceTimeoutSeconds()
public void set_InitialSilenceTimeoutSeconds(float value)
protected void Finalize()
public void Start()
public void Stop()
public void Dispose()
private void DictationRecognizer_InvokeHypothesisGeneratedEvent(string keyword)
private void DictationRecognizer_InvokeResultGeneratedEvent(string keyword, ConfidenceLevel minimumConfidence)
private void DictationRecognizer_InvokeCompletedEvent(DictationCompletionCause cause)
private void DictationRecognizer_InvokeErrorEvent(string error, int hresult)
}
public UnityEngine.Windows.Speech.DictationTopicConstraint : Enum {
public int value__
public DictationTopicConstraint WebSearch
public DictationTopicConstraint Form
public DictationTopicConstraint Dictation
}
public UnityEngine.Windows.Speech.GrammarRecognizer : PhraseRecognizer {
private string <GrammarFilePath>k__BackingField
public string GrammarFilePath
public void .ctor(string grammarFilePath)
public void .ctor(string grammarFilePath, ConfidenceLevel minimumConfidence)
public string get_GrammarFilePath()
private void set_GrammarFilePath(string value)
}
public UnityEngine.Windows.Speech.KeywordRecognizer : PhraseRecognizer {
private IEnumerable`1<string> <Keywords>k__BackingField
public IEnumerable`1<string> Keywords
public void .ctor(String[] keywords)
public void .ctor(String[] keywords, ConfidenceLevel minimumConfidence)
public IEnumerable`1<string> get_Keywords()
private void set_Keywords(IEnumerable`1<string> value)
}
public UnityEngine.Windows.Speech.PhraseRecognitionSystem : object {
private ErrorDelegate OnError
private StatusDelegate OnStatusChanged
public bool isSupported
public SpeechSystemStatus Status
public bool get_isSupported()
public SpeechSystemStatus get_Status()
public void Restart()
public void Shutdown()
public void add_OnError(ErrorDelegate value)
public void remove_OnError(ErrorDelegate value)
public void add_OnStatusChanged(StatusDelegate value)
public void remove_OnStatusChanged(StatusDelegate value)
private void PhraseRecognitionSystem_InvokeErrorEvent(SpeechError errorCode)
private void PhraseRecognitionSystem_InvokeStatusChangedEvent(SpeechSystemStatus status)
}
public UnityEngine.Windows.Speech.PhraseRecognizedEventArgs : ValueType {
public ConfidenceLevel confidence
public SemanticMeaning[] semanticMeanings
public string text
public DateTime phraseStartTime
public TimeSpan phraseDuration
internal void .ctor(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, DateTime phraseStartTime, TimeSpan phraseDuration)
}
public UnityEngine.Windows.Speech.PhraseRecognizer : object {
protected IntPtr m_Recognizer
private PhraseRecognizedDelegate OnPhraseRecognized
public bool IsRunning
protected IntPtr CreateFromKeywords(String[] keywords, ConfidenceLevel minimumConfidence)
private void INTERNAL_CALL_CreateFromKeywords(PhraseRecognizer self, String[] keywords, ConfidenceLevel minimumConfidence, IntPtr& value)
protected IntPtr CreateFromGrammarFile(string grammarFilePath, ConfidenceLevel minimumConfidence)
private void INTERNAL_CALL_CreateFromGrammarFile(PhraseRecognizer self, string grammarFilePath, ConfidenceLevel minimumConfidence, IntPtr& value)
private void Start_Internal(IntPtr recognizer)
private void Stop_Internal(IntPtr recognizer)
private bool IsRunning_Internal(IntPtr recognizer)
private void Destroy(IntPtr recognizer)
private void DestroyThreaded(IntPtr recognizer)
public void add_OnPhraseRecognized(PhraseRecognizedDelegate value)
public void remove_OnPhraseRecognized(PhraseRecognizedDelegate value)
protected void Finalize()
public void Start()
public void Stop()
public void Dispose()
public bool get_IsRunning()
private void InvokePhraseRecognizedEvent(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, long phraseStartFileTime, long phraseDurationTicks)
private SemanticMeaning[] MarshalSemanticMeaning(IntPtr keys, IntPtr values, IntPtr valueSizes, int valueCount)
}
public UnityEngine.Windows.Speech.SemanticMeaning : ValueType {
public string key
public String[] values
}
public UnityEngine.Windows.Speech.SpeechError : Enum {
public int value__
public SpeechError NoError
public SpeechError TopicLanguageNotSupported
public SpeechError GrammarLanguageMismatch
public SpeechError GrammarCompilationFailure
public SpeechError AudioQualityFailure
public SpeechError PauseLimitExceeded
public SpeechError TimeoutExceeded
public SpeechError NetworkFailure
public SpeechError MicrophoneUnavailable
public SpeechError UnknownError
}
public UnityEngine.Windows.Speech.SpeechSystemStatus : Enum {
public int value__
public SpeechSystemStatus Stopped
public SpeechSystemStatus Running
public SpeechSystemStatus Failed
}
public UnityEngine.WrapMode : Enum {
public int value__
public WrapMode Once
public WrapMode Loop
public WrapMode PingPong
public WrapMode Default
public WrapMode ClampForever
public WrapMode Clamp
}
public UnityEngineInternal.APIUpdaterRuntimeServices : object {
public Component AddComponent(GameObject go, string sourceInfo, string name)
}
public UnityEngineInternal.FastCallExceptionHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(Exception ex)
public IAsyncResult BeginInvoke(Exception ex, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngineInternal.GetMethodDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public MethodInfo Invoke(Type classType, string methodName, bool searchBaseTypes, bool instanceMethod, Type[] methodParamTypes)
public IAsyncResult BeginInvoke(Type classType, string methodName, bool searchBaseTypes, bool instanceMethod, Type[] methodParamTypes, AsyncCallback callback, object object)
public MethodInfo EndInvoke(IAsyncResult result)
}
public UnityEngineInternal.GIDebugVisualisation : object {
public bool cycleMode
public bool pauseCycleMode
public GITextureType texType
public void ResetRuntimeInputTextures()
public void PlayCycleMode()
public void PauseCycleMode()
public void StopCycleMode()
public bool get_cycleMode()
public bool get_pauseCycleMode()
public GITextureType get_texType()
public void set_texType(GITextureType value)
public void CycleSkipInstances(int skip)
public void CycleSkipSystems(int skip)
}
public UnityEngineInternal.GITextureType : Enum {
public int value__
public GITextureType Charting
public GITextureType Albedo
public GITextureType Emissive
public GITextureType Irradiance
public GITextureType Directionality
public GITextureType Baked
public GITextureType BakedDirectional
public GITextureType InputWorkspace
public GITextureType BakedShadowMask
public GITextureType BakedAlbedo
public GITextureType BakedEmissive
public GITextureType BakedCharting
public GITextureType BakedTexelValidity
public GITextureType BakedUVOverlap
}
internal UnityEngineInternal.LightmapType : Enum {
public int value__
public LightmapType NoLightmap
public LightmapType StaticLightmap
public LightmapType DynamicLightmap
}
public UnityEngineInternal.MathfInternal : ValueType {
public Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinNormal
public Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinDenormal
public bool IsFlushToZeroEnabled
}
internal UnityEngineInternal.NetFxCoreExtensions : object {
public Delegate CreateDelegate(MethodInfo self, Type delegateType, object target)
public MethodInfo GetMethodInfo(Delegate self)
}
public UnityEngineInternal.ScriptingUtils : object {
public Delegate CreateDelegate(Type type, MethodInfo methodInfo)
}
public UnityEngineInternal.TypeInferenceRuleAttribute : Attribute {
private string _rule
public void .ctor(TypeInferenceRules rule)
public void .ctor(string rule)
public string ToString()
}
public UnityEngineInternal.TypeInferenceRules : Enum {
public int value__
public TypeInferenceRules TypeReferencedByFirstArgument
public TypeInferenceRules TypeReferencedBySecondArgument
public TypeInferenceRules ArrayOfTypeReferencedByFirstArgument
public TypeInferenceRules TypeOfFirstArgument
}
