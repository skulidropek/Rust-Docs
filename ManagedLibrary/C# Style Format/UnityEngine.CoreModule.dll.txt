public AOT.MonoPInvokeCallbackAttribute : Attribute {
public void .ctor(Type type)
}
public JetBrains.Annotations.AssertionConditionAttribute : Attribute {
private AssertionConditionType <ConditionType>k__BackingField
public AssertionConditionType ConditionType
public void .ctor(AssertionConditionType conditionType)
public AssertionConditionType get_ConditionType()
}
public JetBrains.Annotations.AssertionConditionType : Enum {
public int value__
public AssertionConditionType IS_TRUE
public AssertionConditionType IS_FALSE
public AssertionConditionType IS_NULL
public AssertionConditionType IS_NOT_NULL
}
public JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
private Type <BaseType>k__BackingField
public Type BaseType
public void .ctor(Type baseType)
public Type get_BaseType()
}
public JetBrains.Annotations.CollectionAccessAttribute : Attribute {
private CollectionAccessType <CollectionAccessType>k__BackingField
public CollectionAccessType CollectionAccessType
public void .ctor(CollectionAccessType collectionAccessType)
public CollectionAccessType get_CollectionAccessType()
}
public JetBrains.Annotations.CollectionAccessType : Enum {
public int value__
public CollectionAccessType None
public CollectionAccessType Read
public CollectionAccessType ModifyExistingContent
public CollectionAccessType UpdatedContent
}
public JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
private string <Contract>k__BackingField
private bool <ForceFullStates>k__BackingField
public string Contract
public bool ForceFullStates
public void .ctor(string contract)
public void .ctor(string contract, bool forceFullStates)
public string get_Contract()
public bool get_ForceFullStates()
}
public JetBrains.Annotations.ImplicitUseKindFlags : Enum {
public int value__
public ImplicitUseKindFlags Default
public ImplicitUseKindFlags Access
public ImplicitUseKindFlags Assign
public ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature
public ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature
}
public JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
public int value__
public ImplicitUseTargetFlags Default
public ImplicitUseTargetFlags Itself
public ImplicitUseTargetFlags Members
public ImplicitUseTargetFlags WithMembers
}
public JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
private bool <Required>k__BackingField
public bool Required
public void .ctor(bool required)
public bool get_Required()
}
public JetBrains.Annotations.MacroAttribute : Attribute {
private string <Expression>k__BackingField
private int <Editable>k__BackingField
private string <Target>k__BackingField
public string Expression
public int Editable
public string Target
public string get_Expression()
public void set_Expression(string value)
public int get_Editable()
public void set_Editable(int value)
public string get_Target()
public void set_Target(string value)
}
public JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
private ImplicitUseKindFlags <UseKindFlags>k__BackingField
private ImplicitUseTargetFlags <TargetFlags>k__BackingField
public ImplicitUseKindFlags UseKindFlags
public ImplicitUseTargetFlags TargetFlags
public void .ctor(ImplicitUseKindFlags useKindFlags)
public void .ctor(ImplicitUseTargetFlags targetFlags)
public void .ctor(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags)
public ImplicitUseKindFlags get_UseKindFlags()
public ImplicitUseTargetFlags get_TargetFlags()
}
public JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
private string <Justification>k__BackingField
public string Justification
public void .ctor(string justification)
public string get_Justification()
}
public JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
public JetBrains.Annotations.PathReferenceAttribute : Attribute {
private string <BasePath>k__BackingField
public string BasePath
public void .ctor(string basePath)
public string get_BasePath()
}
public JetBrains.Annotations.PublicAPIAttribute : Attribute {
private string <Comment>k__BackingField
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
public JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
private string <FormatParameterName>k__BackingField
public string FormatParameterName
public void .ctor(string formatParameterName)
public string get_FormatParameterName()
}
public JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
private ImplicitUseKindFlags <UseKindFlags>k__BackingField
private ImplicitUseTargetFlags <TargetFlags>k__BackingField
public ImplicitUseKindFlags UseKindFlags
public ImplicitUseTargetFlags TargetFlags
public void .ctor(ImplicitUseKindFlags useKindFlags)
public void .ctor(ImplicitUseTargetFlags targetFlags)
public void .ctor(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags)
public ImplicitUseKindFlags get_UseKindFlags()
public ImplicitUseTargetFlags get_TargetFlags()
}
public JetBrains.Annotations.ValueProviderAttribute : Attribute {
private string <Name>k__BackingField
public string Name
public void .ctor(string name)
public string get_Name()
}
internal Unity.Baselib.BaselibException : Exception {
private ErrorState errorState
public Baselib_ErrorCode ErrorCode
internal void .ctor(ErrorState errorState)
public Baselib_ErrorCode get_ErrorCode()
}
internal Unity.Baselib.ErrorState : ValueType {
private Baselib_ErrorState nativeErrorState
public Baselib_ErrorCode ErrorCode
public Baselib_ErrorState* NativeErrorStatePtr
public void ThrowIfFailed()
public Baselib_ErrorCode get_ErrorCode()
public Baselib_ErrorState* get_NativeErrorStatePtr()
public string Explain(Baselib_ErrorState_ExplainVerbosity verbosity)
}
internal Unity.Baselib.LowLevel.Binding : object {
public UIntPtr Baselib_Memory_MaxAlignment
public UIntPtr Baselib_Memory_MinGuaranteedAlignment
public UInt32 Baselib_NetworkAddress_IpMaxStringLength
public IntPtr Baselib_RegisteredNetwork_Buffer_Id_Invalid
public UInt32 Baselib_RegisteredNetwork_Endpoint_MaxSize
public IntPtr Baselib_Thread_InvalidId
public UIntPtr Baselib_Thread_MaxThreadNameLength
public UInt32 Baselib_TLS_MinimumGuaranteedSlots
public ulong Baselib_SecondsPerMinute
public ulong Baselib_MillisecondsPerSecond
public ulong Baselib_MillisecondsPerMinute
public ulong Baselib_MicrosecondsPerMillisecond
public ulong Baselib_MicrosecondsPerSecond
public ulong Baselib_MicrosecondsPerMinute
public ulong Baselib_NanosecondsPerMicrosecond
public ulong Baselib_NanosecondsPerMillisecond
public ulong Baselib_NanosecondsPerSecond
public ulong Baselib_NanosecondsPerMinute
public ulong Baselib_Timer_MaxNumberOfNanosecondsPerTick
public double Baselib_Timer_MinNumberOfNanosecondsPerTick
public Baselib_Memory_PageAllocation Baselib_Memory_PageAllocation_Invalid
public Baselib_RegisteredNetwork_Socket_UDP Baselib_RegisteredNetwork_Socket_UDP_Invalid
public Baselib_Socket_Handle Baselib_Socket_Handle_Invalid
public Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_Handle_Invalid
public Baselib_FileIO_EventQueue Baselib_FileIO_EventQueue_Invalid
public Baselib_FileIO_AsyncFile Baselib_FileIO_AsyncFile_Invalid
public Baselib_FileIO_SyncFile Baselib_FileIO_SyncFile_Invalid
public Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenUtf8(Byte* pathnameUtf8, Baselib_ErrorState* errorState)
public Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenUtf16(Char* pathnameUtf16, Baselib_ErrorState* errorState)
public Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_OpenProgramHandle(Baselib_ErrorState* errorState)
public Baselib_DynamicLibrary_Handle Baselib_DynamicLibrary_FromNativeHandle(ulong handle, UInt32 type, Baselib_ErrorState* errorState)
public IntPtr Baselib_DynamicLibrary_GetFunction(Baselib_DynamicLibrary_Handle handle, Byte* functionName, Baselib_ErrorState* errorState)
public void Baselib_DynamicLibrary_Close(Baselib_DynamicLibrary_Handle handle)
public UInt32 Baselib_ErrorState_Explain(Baselib_ErrorState* errorState, Byte* buffer, UInt32 bufferLen, Baselib_ErrorState_ExplainVerbosity verbosity)
public Baselib_FileIO_EventQueue Baselib_FileIO_EventQueue_Create()
public void Baselib_FileIO_EventQueue_Free(Baselib_FileIO_EventQueue eq)
public ulong Baselib_FileIO_EventQueue_Dequeue(Baselib_FileIO_EventQueue eq, Baselib_FileIO_EventQueue_Result* results, ulong count, UInt32 timeoutInMilliseconds)
public void Baselib_FileIO_EventQueue_Shutdown(Baselib_FileIO_EventQueue eq, UInt32 threadCount)
public Baselib_FileIO_AsyncFile Baselib_FileIO_AsyncOpen(Baselib_FileIO_EventQueue eq, Byte* pathname, ulong userdata, Baselib_FileIO_Priority priority)
public void Baselib_FileIO_AsyncRead(Baselib_FileIO_AsyncFile file, Baselib_FileIO_ReadRequest* requests, ulong count, ulong userdata, Baselib_FileIO_Priority priority)
public void Baselib_FileIO_AsyncClose(Baselib_FileIO_AsyncFile file)
public Baselib_FileIO_SyncFile Baselib_FileIO_SyncOpen(Byte* pathname, Baselib_FileIO_OpenFlags openFlags, Baselib_ErrorState* errorState)
public Baselib_FileIO_SyncFile Baselib_FileIO_SyncFileFromNativeHandle(ulong handle, UInt32 type)
public ulong Baselib_FileIO_SyncRead(Baselib_FileIO_SyncFile file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState)
public ulong Baselib_FileIO_SyncWrite(Baselib_FileIO_SyncFile file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState)
public void Baselib_FileIO_SyncFlush(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState)
public void Baselib_FileIO_SyncSetFileSize(Baselib_FileIO_SyncFile file, ulong size, Baselib_ErrorState* errorState)
public ulong Baselib_FileIO_SyncGetFileSize(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState)
public void Baselib_FileIO_SyncClose(Baselib_FileIO_SyncFile file, Baselib_ErrorState* errorState)
public void Baselib_Memory_GetPageSizeInfo(Baselib_Memory_PageSizeInfo* outPagesSizeInfo)
public IntPtr Baselib_Memory_Allocate(UIntPtr size)
public IntPtr Baselib_Memory_Reallocate(IntPtr ptr, UIntPtr newSize)
public void Baselib_Memory_Free(IntPtr ptr)
public IntPtr Baselib_Memory_AlignedAllocate(UIntPtr size, UIntPtr alignment)
public IntPtr Baselib_Memory_AlignedReallocate(IntPtr ptr, UIntPtr newSize, UIntPtr alignment)
public void Baselib_Memory_AlignedFree(IntPtr ptr)
public Baselib_Memory_PageAllocation Baselib_Memory_AllocatePages(ulong pageSize, ulong pageCount, ulong alignmentInMultipleOfPageSize, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState)
public void Baselib_Memory_ReleasePages(Baselib_Memory_PageAllocation pageAllocation, Baselib_ErrorState* errorState)
public void Baselib_Memory_SetPageState(IntPtr addressOfFirstPage, ulong pageSize, ulong pageCount, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState)
public void Baselib_NetworkAddress_Encode(Baselib_NetworkAddress* dstAddress, Baselib_NetworkAddress_Family family, Byte* ip, ushort port, Baselib_ErrorState* errorState)
public void Baselib_NetworkAddress_Decode(Baselib_NetworkAddress* srcAddress, Baselib_NetworkAddress_Family* family, Byte* ipAddressBuffer, UInt32 ipAddressBufferLen, UInt16* port, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_Buffer Baselib_RegisteredNetwork_Buffer_Register(Baselib_Memory_PageAllocation pageAllocation, Baselib_ErrorState* errorState)
public void Baselib_RegisteredNetwork_Buffer_Deregister(Baselib_RegisteredNetwork_Buffer buffer)
public Baselib_RegisteredNetwork_BufferSlice Baselib_RegisteredNetwork_BufferSlice_Create(Baselib_RegisteredNetwork_Buffer buffer, UInt32 offset, UInt32 size)
public Baselib_RegisteredNetwork_BufferSlice Baselib_RegisteredNetwork_BufferSlice_Empty()
public Baselib_RegisteredNetwork_Endpoint Baselib_RegisteredNetwork_Endpoint_Create(Baselib_NetworkAddress* srcAddress, Baselib_RegisteredNetwork_BufferSlice dstSlice, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_Endpoint Baselib_RegisteredNetwork_Endpoint_Empty()
public void Baselib_RegisteredNetwork_Endpoint_GetNetworkAddress(Baselib_RegisteredNetwork_Endpoint endpoint, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_Socket_UDP Baselib_RegisteredNetwork_Socket_UDP_Create(Baselib_NetworkAddress* bindAddress, Baselib_NetworkAddress_AddressReuse endpointReuse, UInt32 sendQueueSize, UInt32 recvQueueSize, Baselib_ErrorState* errorState)
public UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState)
public UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedRecv(Baselib_RegisteredNetwork_Socket_UDP socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState)
public Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedSend(Baselib_RegisteredNetwork_Socket_UDP socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState)
public UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueRecv(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState)
public UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueSend(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState)
public void Baselib_RegisteredNetwork_Socket_UDP_GetNetworkAddress(Baselib_RegisteredNetwork_Socket_UDP socket, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState)
public void Baselib_RegisteredNetwork_Socket_UDP_Close(Baselib_RegisteredNetwork_Socket_UDP socket)
public Baselib_Socket_Handle Baselib_Socket_Create(Baselib_NetworkAddress_Family family, Baselib_Socket_Protocol protocol, Baselib_ErrorState* errorState)
public void Baselib_Socket_Bind(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState)
public void Baselib_Socket_TCP_Connect(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState)
public void Baselib_Socket_Poll(Baselib_Socket_PollFd* sockets, UInt32 socketsCount, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState)
public void Baselib_Socket_GetAddress(Baselib_Socket_Handle socket, Baselib_NetworkAddress* address, Baselib_ErrorState* errorState)
public void Baselib_Socket_TCP_Listen(Baselib_Socket_Handle socket, Baselib_ErrorState* errorState)
public Baselib_Socket_Handle Baselib_Socket_TCP_Accept(Baselib_Socket_Handle socket, Baselib_ErrorState* errorState)
public UInt32 Baselib_Socket_UDP_Send(Baselib_Socket_Handle socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState)
public UInt32 Baselib_Socket_TCP_Send(Baselib_Socket_Handle socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState)
public UInt32 Baselib_Socket_UDP_Recv(Baselib_Socket_Handle socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState)
public UInt32 Baselib_Socket_TCP_Recv(Baselib_Socket_Handle socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState)
public void Baselib_Socket_Close(Baselib_Socket_Handle socket)
public void Baselib_Thread_YieldExecution()
public IntPtr Baselib_Thread_GetCurrentThreadId()
public UIntPtr Baselib_TLS_Alloc()
public void Baselib_TLS_Free(UIntPtr handle)
public void Baselib_TLS_Set(UIntPtr handle, UIntPtr value)
public UIntPtr Baselib_TLS_Get(UIntPtr handle)
public Baselib_Timer_TickToNanosecondConversionRatio Baselib_Timer_GetTicksToNanosecondsConversionRatio()
public ulong Baselib_Timer_GetHighPrecisionTimerTicks()
public void Baselib_Timer_WaitForAtLeast(UInt32 timeInMilliseconds)
public double Baselib_Timer_GetTimeSinceStartupInSeconds()
private void Baselib_DynamicLibrary_OpenUtf8_Injected(Byte* pathnameUtf8, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret)
private void Baselib_DynamicLibrary_OpenUtf16_Injected(Char* pathnameUtf16, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret)
private void Baselib_DynamicLibrary_OpenProgramHandle_Injected(Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret)
private void Baselib_DynamicLibrary_FromNativeHandle_Injected(ulong handle, UInt32 type, Baselib_ErrorState* errorState, Baselib_DynamicLibrary_Handle& ret)
private IntPtr Baselib_DynamicLibrary_GetFunction_Injected(Baselib_DynamicLibrary_Handle& handle, Byte* functionName, Baselib_ErrorState* errorState)
private void Baselib_DynamicLibrary_Close_Injected(Baselib_DynamicLibrary_Handle& handle)
private void Baselib_FileIO_EventQueue_Create_Injected(Baselib_FileIO_EventQueue& ret)
private void Baselib_FileIO_EventQueue_Free_Injected(Baselib_FileIO_EventQueue& eq)
private ulong Baselib_FileIO_EventQueue_Dequeue_Injected(Baselib_FileIO_EventQueue& eq, Baselib_FileIO_EventQueue_Result* results, ulong count, UInt32 timeoutInMilliseconds)
private void Baselib_FileIO_EventQueue_Shutdown_Injected(Baselib_FileIO_EventQueue& eq, UInt32 threadCount)
private void Baselib_FileIO_AsyncOpen_Injected(Baselib_FileIO_EventQueue& eq, Byte* pathname, ulong userdata, Baselib_FileIO_Priority priority, Baselib_FileIO_AsyncFile& ret)
private void Baselib_FileIO_AsyncRead_Injected(Baselib_FileIO_AsyncFile& file, Baselib_FileIO_ReadRequest* requests, ulong count, ulong userdata, Baselib_FileIO_Priority priority)
private void Baselib_FileIO_AsyncClose_Injected(Baselib_FileIO_AsyncFile& file)
private void Baselib_FileIO_SyncOpen_Injected(Byte* pathname, Baselib_FileIO_OpenFlags openFlags, Baselib_ErrorState* errorState, Baselib_FileIO_SyncFile& ret)
private void Baselib_FileIO_SyncFileFromNativeHandle_Injected(ulong handle, UInt32 type, Baselib_FileIO_SyncFile& ret)
private ulong Baselib_FileIO_SyncRead_Injected(Baselib_FileIO_SyncFile& file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState)
private ulong Baselib_FileIO_SyncWrite_Injected(Baselib_FileIO_SyncFile& file, ulong offset, IntPtr buffer, ulong size, Baselib_ErrorState* errorState)
private void Baselib_FileIO_SyncFlush_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState)
private void Baselib_FileIO_SyncSetFileSize_Injected(Baselib_FileIO_SyncFile& file, ulong size, Baselib_ErrorState* errorState)
private ulong Baselib_FileIO_SyncGetFileSize_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState)
private void Baselib_FileIO_SyncClose_Injected(Baselib_FileIO_SyncFile& file, Baselib_ErrorState* errorState)
private void Baselib_Memory_AllocatePages_Injected(ulong pageSize, ulong pageCount, ulong alignmentInMultipleOfPageSize, Baselib_Memory_PageState pageState, Baselib_ErrorState* errorState, Baselib_Memory_PageAllocation& ret)
private void Baselib_Memory_ReleasePages_Injected(Baselib_Memory_PageAllocation& pageAllocation, Baselib_ErrorState* errorState)
private void Baselib_RegisteredNetwork_Buffer_Register_Injected(Baselib_Memory_PageAllocation& pageAllocation, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Buffer& ret)
private void Baselib_RegisteredNetwork_Buffer_Deregister_Injected(Baselib_RegisteredNetwork_Buffer& buffer)
private void Baselib_RegisteredNetwork_BufferSlice_Create_Injected(Baselib_RegisteredNetwork_Buffer& buffer, UInt32 offset, UInt32 size, Baselib_RegisteredNetwork_BufferSlice& ret)
private void Baselib_RegisteredNetwork_BufferSlice_Empty_Injected(Baselib_RegisteredNetwork_BufferSlice& ret)
private void Baselib_RegisteredNetwork_Endpoint_Create_Injected(Baselib_NetworkAddress* srcAddress, Baselib_RegisteredNetwork_BufferSlice& dstSlice, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Endpoint& ret)
private void Baselib_RegisteredNetwork_Endpoint_Empty_Injected(Baselib_RegisteredNetwork_Endpoint& ret)
private void Baselib_RegisteredNetwork_Endpoint_GetNetworkAddress_Injected(Baselib_RegisteredNetwork_Endpoint& endpoint, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState)
private void Baselib_RegisteredNetwork_Socket_UDP_Create_Injected(Baselib_NetworkAddress* bindAddress, Baselib_NetworkAddress_AddressReuse endpointReuse, UInt32 sendQueueSize, UInt32 recvQueueSize, Baselib_ErrorState* errorState, Baselib_RegisteredNetwork_Socket_UDP& ret)
private UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState)
private UInt32 Baselib_RegisteredNetwork_Socket_UDP_ScheduleSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_Request* requests, UInt32 requestsCount, Baselib_ErrorState* errorState)
private Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_ErrorState* errorState)
private Baselib_RegisteredNetwork_ProcessStatus Baselib_RegisteredNetwork_Socket_UDP_ProcessSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_ErrorState* errorState)
private Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState)
private Baselib_RegisteredNetwork_CompletionQueueStatus Baselib_RegisteredNetwork_Socket_UDP_WaitForCompletedSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, UInt32 timeoutInMilliseconds, Baselib_ErrorState* errorState)
private UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueRecv_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState)
private UInt32 Baselib_RegisteredNetwork_Socket_UDP_DequeueSend_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_RegisteredNetwork_CompletionResult* results, UInt32 resultsCount, Baselib_ErrorState* errorState)
private void Baselib_RegisteredNetwork_Socket_UDP_GetNetworkAddress_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket, Baselib_NetworkAddress* dstAddress, Baselib_ErrorState* errorState)
private void Baselib_RegisteredNetwork_Socket_UDP_Close_Injected(Baselib_RegisteredNetwork_Socket_UDP& socket)
private void Baselib_Socket_Create_Injected(Baselib_NetworkAddress_Family family, Baselib_Socket_Protocol protocol, Baselib_ErrorState* errorState, Baselib_Socket_Handle& ret)
private void Baselib_Socket_Bind_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState)
private void Baselib_Socket_TCP_Connect_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_NetworkAddress_AddressReuse addressReuse, Baselib_ErrorState* errorState)
private void Baselib_Socket_GetAddress_Injected(Baselib_Socket_Handle& socket, Baselib_NetworkAddress* address, Baselib_ErrorState* errorState)
private void Baselib_Socket_TCP_Listen_Injected(Baselib_Socket_Handle& socket, Baselib_ErrorState* errorState)
private void Baselib_Socket_TCP_Accept_Injected(Baselib_Socket_Handle& socket, Baselib_ErrorState* errorState, Baselib_Socket_Handle& ret)
private UInt32 Baselib_Socket_UDP_Send_Injected(Baselib_Socket_Handle& socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState)
private UInt32 Baselib_Socket_TCP_Send_Injected(Baselib_Socket_Handle& socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState)
private UInt32 Baselib_Socket_UDP_Recv_Injected(Baselib_Socket_Handle& socket, Baselib_Socket_Message* messages, UInt32 messagesCount, Baselib_ErrorState* errorState)
private UInt32 Baselib_Socket_TCP_Recv_Injected(Baselib_Socket_Handle& socket, IntPtr data, UInt32 dataLen, Baselib_ErrorState* errorState)
private void Baselib_Socket_Close_Injected(Baselib_Socket_Handle& socket)
private void Baselib_Timer_GetTicksToNanosecondsConversionRatio_Injected(Baselib_Timer_TickToNanosecondConversionRatio& ret)
}
internal Unity.Burst.LowLevel.BurstCompilerService : object {
public bool IsInitialized
private string InitializeInternal(string path, ExtractCompilerFlags extractCompilerFlags)
public string GetDisassembly(MethodInfo m, string compilerOptions)
public int CompileAsyncDelegateMethod(object delegateMethod, string compilerOptions)
public Void* GetAsyncCompiledAsyncDelegateMethod(int userID)
public Void* GetOrCreateSharedMemory(Hash128& key, UInt32 size_of, UInt32 alignment)
public string GetMethodSignature(MethodInfo method)
public bool get_IsInitialized()
public void SetCurrentExecutionMode(UInt32 environment)
public UInt32 GetCurrentExecutionMode()
public void Log(Void* userData, BurstLogType logType, Byte* message, Byte* filename, int lineNumber)
public bool LoadBurstLibrary(string fullPathToLibBurstGenerated)
public void Initialize(string folderRuntime, ExtractCompilerFlags extractCompilerFlags)
}
public Unity.Collections.Allocator : Enum {
public int value__
public Allocator Invalid
public Allocator None
public Allocator Temp
public Allocator TempJob
public Allocator Persistent
public Allocator AudioKernel
}
internal Unity.Collections.LeakCategory : Enum {
public int value__
public LeakCategory Invalid
public LeakCategory Malloc
public LeakCategory TempJob
public LeakCategory Persistent
public LeakCategory LightProbesQuery
public LeakCategory NativeTest
public LeakCategory MeshDataArray
public LeakCategory TransformAccessArray
public LeakCategory NavMeshQuery
}
internal Unity.Collections.LowLevel.Unsafe.BurstLike : object {
internal int NativeFunctionCall_Int_IntPtr_IntPtr(IntPtr function, IntPtr p0, IntPtr p1, Int32& error)
internal IntPtr StaticDataGetOrCreate(int key, int sizeInBytes, Int32& error)
}
public Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility : object {
private void CheckConvertArguments(int length, Allocator allocator)
public NativeArray`1<T> ConvertExistingDataToNativeArray(Void* dataPointer, int length, Allocator allocator)
public Void* GetUnsafePtr(NativeArray`1<T> nativeArray)
public Void* GetUnsafeReadOnlyPtr(NativeArray`1<T> nativeArray)
public Void* GetUnsafeReadOnlyPtr(ReadOnly<T> nativeArray)
public Void* GetUnsafeBufferPointerWithoutChecks(NativeArray`1<T> nativeArray)
}
public Unity.Collections.LowLevel.Unsafe.NativeSliceUnsafeUtility : object {
public NativeSlice`1<T> ConvertExistingDataToNativeSlice(Void* dataPointer, int stride, int length)
public Void* GetUnsafePtr(NativeSlice`1<T> nativeSlice)
public Void* GetUnsafeReadOnlyPtr(NativeSlice`1<T> nativeSlice)
}
public Unity.Collections.LowLevel.Unsafe.UnsafeUtility : object {
private int GetFieldOffsetInStruct(FieldInfo field)
private int GetFieldOffsetInClass(FieldInfo field)
public int GetFieldOffset(FieldInfo field)
public Void* PinGCObjectAndGetAddress(object target, UInt64& gcHandle)
public Void* PinGCArrayAndGetDataAddress(Array target, UInt64& gcHandle)
private Void* PinSystemArrayAndGetAddress(object target, UInt64& gcHandle)
private Void* PinSystemObjectAndGetAddress(object target, UInt64& gcHandle)
public void ReleaseGCObject(ulong gcHandle)
public void CopyObjectAddressToPtr(object target, Void* dstPtr)
public bool IsBlittable()
public int CheckForLeaks()
public int ForgiveLeaks()
public NativeLeakDetectionMode GetLeakDetectionMode()
public void SetLeakDetectionMode(NativeLeakDetectionMode value)
internal int LeakRecord(IntPtr handle, LeakCategory category, int callstacksToSkip)
internal int LeakErase(IntPtr handle, LeakCategory category)
public Void* MallocTracked(long size, int alignment, Allocator allocator, int callstacksToSkip)
public void FreeTracked(Void* memory, Allocator allocator)
public Void* Malloc(long size, int alignment, Allocator allocator)
public void Free(Void* memory, Allocator allocator)
public bool IsValidAllocator(Allocator allocator)
public void MemCpy(Void* destination, Void* source, long size)
public void MemCpyReplicate(Void* destination, Void* source, int size, int count)
public void MemCpyStride(Void* destination, int destinationStride, Void* source, int sourceStride, int elementSize, int count)
public void MemMove(Void* destination, Void* source, long size)
public void MemSet(Void* destination, byte value, long size)
public void MemClear(Void* destination, long size)
public int MemCmp(Void* ptr1, Void* ptr2, long size)
public int SizeOf(Type type)
public bool IsBlittable(Type type)
public bool IsUnmanaged(Type type)
public bool IsValidNativeContainerElementType(Type type)
internal void LogError(string msg, string filename, int linenumber)
private bool IsBlittableValueType(Type t)
private string GetReasonForTypeNonBlittableImpl(Type t, string name)
internal bool IsArrayBlittable(Array arr)
internal bool IsGenericListBlittable()
internal string GetReasonForArrayNonBlittable(Array arr)
internal string GetReasonForGenericListNonBlittable()
internal string GetReasonForTypeNonBlittable(Type t)
internal string GetReasonForValueTypeNonBlittable()
public bool IsUnmanaged()
public bool IsValidNativeContainerElementType()
public int AlignOf()
public void CopyPtrToStructure(Void* ptr, T& output)
private void InternalCopyPtrToStructure(Void* ptr, T& output)
public void CopyStructureToPtr(T& input, Void* ptr)
private void InternalCopyStructureToPtr(T& input, Void* ptr)
public T ReadArrayElement(Void* source, int index)
public T ReadArrayElementWithStride(Void* source, int index, int stride)
public void WriteArrayElement(Void* destination, int index, T value)
public void WriteArrayElementWithStride(Void* destination, int index, int stride, T value)
public Void* AddressOf(T& output)
public int SizeOf()
public T& As(U& from)
public T& AsRef(Void* ptr)
public T& ArrayElementAsRef(Void* ptr, int index)
public int EnumToInt(T enumValue)
private void InternalEnumToInt(T& enumValue, Int32& intValue)
public bool EnumEquals(T lhs, T rhs)
}
public Unity.Collections.NativeArray`1 : ValueType {
internal Void* m_Buffer
internal int m_Length
internal Allocator m_AllocatorLabel
public int Length
public T Item
public bool IsCreated
public void .ctor(int length, Allocator allocator, NativeArrayOptions options)
public void .ctor(T[] array, Allocator allocator)
public void .ctor(NativeArray`1<T> array, Allocator allocator)
private void CheckAllocateArguments(int length, Allocator allocator, long totalSize)
private void Allocate(int length, Allocator allocator, NativeArray`1& array)
public int get_Length()
internal void IsUnmanagedAndThrow()
private void CheckElementReadAccess(int index)
private void CheckElementWriteAccess(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public bool get_IsCreated()
public void Dispose()
public JobHandle Dispose(JobHandle inputDeps)
public void CopyFrom(T[] array)
public void CopyFrom(NativeArray`1<T> array)
public void CopyTo(T[] array)
public void CopyTo(NativeArray`1<T> array)
public T[] ToArray()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Equals(NativeArray`1<T> other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(NativeArray`1<T> left, NativeArray`1<T> right)
public bool op_Inequality(NativeArray`1<T> left, NativeArray`1<T> right)
private void CheckCopyLengths(int srcLength, int dstLength)
public void Copy(NativeArray`1<T> src, NativeArray`1<T> dst)
public void Copy(ReadOnly<T> src, NativeArray`1<T> dst)
public void Copy(T[] src, NativeArray`1<T> dst)
public void Copy(NativeArray`1<T> src, T[] dst)
public void Copy(ReadOnly<T> src, T[] dst)
public void Copy(NativeArray`1<T> src, NativeArray`1<T> dst, int length)
public void Copy(ReadOnly<T> src, NativeArray`1<T> dst, int length)
public void Copy(T[] src, NativeArray`1<T> dst, int length)
public void Copy(NativeArray`1<T> src, T[] dst, int length)
public void Copy(ReadOnly<T> src, T[] dst, int length)
private void CheckCopyArguments(int srcLength, int srcIndex, int dstLength, int dstIndex, int length)
public void Copy(NativeArray`1<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length)
public void Copy(ReadOnly<T> src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length)
public void Copy(T[] src, int srcIndex, NativeArray`1<T> dst, int dstIndex, int length)
public void Copy(NativeArray`1<T> src, int srcIndex, T[] dst, int dstIndex, int length)
public void Copy(ReadOnly<T> src, int srcIndex, T[] dst, int dstIndex, int length)
private void CheckReinterpretLoadRange(int sourceIndex)
private void CheckReinterpretStoreRange(int destIndex)
public U ReinterpretLoad(int sourceIndex)
public void ReinterpretStore(int destIndex, U data)
private NativeArray`1<U> InternalReinterpret(int length)
private void CheckReinterpretSize()
public NativeArray`1<U> Reinterpret()
private void CheckReinterpretSize(long tSize, long uSize, int expectedTypeSize, long byteLen, long uLen)
public NativeArray`1<U> Reinterpret(int expectedTypeSize)
private void CheckGetSubArrayArguments(int start, int length)
public NativeArray`1<T> GetSubArray(int start, int length)
public ReadOnly<T> AsReadOnly()
}
internal Unity.Collections.NativeArrayDebugView`1 : object {
private NativeArray`1<T> m_Array
public T[] Items
public void .ctor(NativeArray`1<T> array)
public T[] get_Items()
}
internal Unity.Collections.NativeArrayDispose : ValueType {
internal Void* m_Buffer
internal Allocator m_AllocatorLabel
public void Dispose()
}
internal Unity.Collections.NativeArrayDisposeJob : ValueType {
internal NativeArrayDispose Data
public void Execute()
}
public Unity.Collections.NativeArrayOptions : Enum {
public int value__
public NativeArrayOptions UninitializedMemory
public NativeArrayOptions ClearMemory
}
internal Unity.Collections.NativeArrayReadOnlyDebugView`1 : object {
private ReadOnly<T> m_Array
public T[] Items
public void .ctor(ReadOnly<T> array)
public T[] get_Items()
}
public Unity.Collections.NativeFixedLengthAttribute : Attribute {
public int FixedLength
public void .ctor(int fixedLength)
}
public Unity.Collections.NativeLeakDetection : object {
private int s_NativeLeakDetectionMode
private string kNativeLeakDetectionModePrefsString
public NativeLeakDetectionMode Mode
private void Initialize()
public NativeLeakDetectionMode get_Mode()
public void set_Mode(NativeLeakDetectionMode value)
}
public Unity.Collections.NativeLeakDetectionMode : Enum {
public int value__
public NativeLeakDetectionMode EnabledWithStackTrace
public NativeLeakDetectionMode Enabled
public NativeLeakDetectionMode Disabled
}
public Unity.Collections.NativeSlice`1 : ValueType {
internal Byte* m_Buffer
internal int m_Stride
internal int m_Length
public T Item
public int Stride
public int Length
public void .ctor(NativeSlice`1<T> slice, int start)
public void .ctor(NativeSlice`1<T> slice, int start, int length)
public void .ctor(NativeArray`1<T> array)
public void .ctor(NativeArray`1<T> array, int start)
public NativeSlice`1<T> op_Implicit(NativeArray`1<T> array)
public void .ctor(NativeArray`1<T> array, int start, int length)
public NativeSlice`1<U> SliceConvert()
public NativeSlice`1<U> SliceWithStride(int offset)
public NativeSlice`1<U> SliceWithStride()
private void CheckReadIndex(int index)
private void CheckWriteIndex(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
public void CopyFrom(NativeSlice`1<T> slice)
public void CopyFrom(T[] array)
public void CopyTo(NativeArray`1<T> array)
public void CopyTo(T[] array)
public T[] ToArray()
public int get_Stride()
public int get_Length()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Equals(NativeSlice`1<T> other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(NativeSlice`1<T> left, NativeSlice`1<T> right)
public bool op_Inequality(NativeSlice`1<T> left, NativeSlice`1<T> right)
}
internal Unity.Collections.NativeSliceDebugView`1 : object {
private NativeSlice`1<T> m_Array
public T[] Items
public void .ctor(NativeSlice`1<T> array)
public T[] get_Items()
}
public Unity.Collections.NativeSliceExtensions : object {
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray)
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start)
public NativeSlice`1<T> Slice(NativeArray`1<T> thisArray, int start, int length)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start)
public NativeSlice`1<T> Slice(NativeSlice`1<T> thisSlice, int start, int length)
}
public Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem : Enum {
public int value__
public AssetLoadingSubsystem Other
public AssetLoadingSubsystem Texture
public AssetLoadingSubsystem VirtualTexture
public AssetLoadingSubsystem Mesh
public AssetLoadingSubsystem Audio
public AssetLoadingSubsystem Scripts
public AssetLoadingSubsystem EntitiesScene
public AssetLoadingSubsystem EntitiesStreamBinaryReader
public AssetLoadingSubsystem FileInfo
}
public Unity.IO.LowLevel.Unsafe.AsyncReadManager : object {
private ReadHandle ReadInternal(string filename, Void* cmds, UInt32 cmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem)
public ReadHandle Read(string filename, ReadCommand* readCmds, UInt32 readCmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem)
private ReadHandle GetFileInfoInternal(string filename, Void* cmd)
public ReadHandle GetFileInfo(string filename, FileInfoResult* result)
private ReadHandle ReadWithHandlesInternal_NativePtr(FileHandle& fileHandle, Void* readCmdArray, JobHandle dependency)
private ReadHandle ReadWithHandlesInternal_NativeCopy(FileHandle& fileHandle, Void* readCmdArray)
public ReadHandle ReadDeferred(FileHandle& fileHandle, ReadCommandArray* readCmdArray, JobHandle dependency)
public ReadHandle Read(FileHandle& fileHandle, ReadCommandArray readCmdArray)
private FileHandle OpenFileAsync_Internal(string fileName)
public FileHandle OpenFileAsync(string fileName)
internal JobHandle CloseFileAsync(FileHandle& fileHandle, JobHandle dependency)
public JobHandle CloseCachedFileAsync(string fileName, JobHandle dependency)
private void ReadInternal_Injected(string filename, Void* cmds, UInt32 cmdCount, string assetName, ulong typeID, AssetLoadingSubsystem subsystem, ReadHandle& ret)
private void GetFileInfoInternal_Injected(string filename, Void* cmd, ReadHandle& ret)
private void ReadWithHandlesInternal_NativePtr_Injected(FileHandle& fileHandle, Void* readCmdArray, JobHandle& dependency, ReadHandle& ret)
private void ReadWithHandlesInternal_NativeCopy_Injected(FileHandle& fileHandle, Void* readCmdArray, ReadHandle& ret)
private void OpenFileAsync_Internal_Injected(string fileName, FileHandle& ret)
private void CloseFileAsync_Injected(FileHandle& fileHandle, JobHandle& dependency, JobHandle& ret)
private void CloseCachedFileAsync_Injected(string fileName, JobHandle& dependency, JobHandle& ret)
}
public Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics : object {
public bool IsEnabled()
private void ClearMetrics_Internal()
public void ClearCompletedMetrics()
internal AsyncReadManagerRequestMetric[] GetMetrics_Internal(bool clear)
internal void GetMetrics_NoAlloc_Internal(List`1<AsyncReadManagerRequestMetric> metrics, bool clear)
internal AsyncReadManagerRequestMetric[] GetMetrics_Filtered_Internal(AsyncReadManagerMetricsFilters filters, bool clear)
internal void GetMetrics_NoAlloc_Filtered_Internal(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters filters, bool clear)
public AsyncReadManagerRequestMetric[] GetMetrics(AsyncReadManagerMetricsFilters filters, Flags flags)
public void GetMetrics(List`1<AsyncReadManagerRequestMetric> outMetrics, AsyncReadManagerMetricsFilters filters, Flags flags)
public AsyncReadManagerRequestMetric[] GetMetrics(Flags flags)
public void GetMetrics(List`1<AsyncReadManagerRequestMetric> outMetrics, Flags flags)
public void StartCollectingMetrics()
public void StopCollectingMetrics()
internal AsyncReadManagerSummaryMetrics GetSummaryMetrics_Internal(bool clear)
public AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(Flags flags)
internal AsyncReadManagerSummaryMetrics GetSummaryMetricsWithFilters_Internal(AsyncReadManagerMetricsFilters metricsFilters, bool clear)
public AsyncReadManagerSummaryMetrics GetCurrentSummaryMetrics(AsyncReadManagerMetricsFilters metricsFilters, Flags flags)
internal AsyncReadManagerSummaryMetrics GetSummaryOfMetrics_Internal(AsyncReadManagerRequestMetric[] metrics)
public AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics)
internal AsyncReadManagerSummaryMetrics GetSummaryOfMetrics_FromContainer_Internal(List`1<AsyncReadManagerRequestMetric> metrics)
public AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List`1<AsyncReadManagerRequestMetric> metrics)
internal AsyncReadManagerSummaryMetrics GetSummaryOfMetricsWithFilters_Internal(AsyncReadManagerRequestMetric[] metrics, AsyncReadManagerMetricsFilters metricsFilters)
public AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(AsyncReadManagerRequestMetric[] metrics, AsyncReadManagerMetricsFilters metricsFilters)
internal AsyncReadManagerSummaryMetrics GetSummaryOfMetricsWithFilters_FromContainer_Internal(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters metricsFilters)
public AsyncReadManagerSummaryMetrics GetSummaryOfMetrics(List`1<AsyncReadManagerRequestMetric> metrics, AsyncReadManagerMetricsFilters metricsFilters)
public ulong GetTotalSizeOfNonASRMReadsBytes(bool emptyAfterRead)
}
public Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters : object {
internal UInt64[] TypeIDs
internal ProcessingState[] States
internal FileReadType[] ReadTypes
internal Priority[] PriorityLevels
internal AssetLoadingSubsystem[] Subsystems
public void .ctor(ulong typeID)
public void .ctor(ProcessingState state)
public void .ctor(FileReadType readType)
public void .ctor(Priority priorityLevel)
public void .ctor(AssetLoadingSubsystem subsystem)
public void .ctor(UInt64[] typeIDs)
public void .ctor(ProcessingState[] states)
public void .ctor(FileReadType[] readTypes)
public void .ctor(Priority[] priorityLevels)
public void .ctor(AssetLoadingSubsystem[] subsystems)
public void .ctor(UInt64[] typeIDs, ProcessingState[] states, FileReadType[] readTypes, Priority[] priorityLevels, AssetLoadingSubsystem[] subsystems)
public void SetTypeIDFilter(UInt64[] _typeIDs)
public void SetStateFilter(ProcessingState[] _states)
public void SetReadTypeFilter(FileReadType[] _readTypes)
public void SetPriorityFilter(Priority[] _priorityLevels)
public void SetSubsystemFilter(AssetLoadingSubsystem[] _subsystems)
public void SetTypeIDFilter(ulong _typeID)
public void SetStateFilter(ProcessingState _state)
public void SetReadTypeFilter(FileReadType _readType)
public void SetPriorityFilter(Priority _priorityLevel)
public void SetSubsystemFilter(AssetLoadingSubsystem _subsystem)
public void RemoveTypeIDFilter()
public void RemoveStateFilter()
public void RemoveReadTypeFilter()
public void RemovePriorityFilter()
public void RemoveSubsystemFilter()
public void ClearFilters()
}
public Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric : ValueType {
private string <AssetName>k__BackingField
private string <FileName>k__BackingField
private ulong <OffsetBytes>k__BackingField
private ulong <SizeBytes>k__BackingField
private ulong <AssetTypeId>k__BackingField
private ulong <CurrentBytesRead>k__BackingField
private UInt32 <BatchReadCount>k__BackingField
private bool <IsBatchRead>k__BackingField
private ProcessingState <State>k__BackingField
private FileReadType <ReadType>k__BackingField
private Priority <PriorityLevel>k__BackingField
private AssetLoadingSubsystem <Subsystem>k__BackingField
private double <RequestTimeMicroseconds>k__BackingField
private double <TimeInQueueMicroseconds>k__BackingField
private double <TotalTimeMicroseconds>k__BackingField
public string AssetName
public string FileName
public ulong OffsetBytes
public ulong SizeBytes
public ulong AssetTypeId
public ulong CurrentBytesRead
public UInt32 BatchReadCount
public bool IsBatchRead
public ProcessingState State
public FileReadType ReadType
public Priority PriorityLevel
public AssetLoadingSubsystem Subsystem
public double RequestTimeMicroseconds
public double TimeInQueueMicroseconds
public double TotalTimeMicroseconds
public string get_AssetName()
public string get_FileName()
public ulong get_OffsetBytes()
public ulong get_SizeBytes()
public ulong get_AssetTypeId()
public ulong get_CurrentBytesRead()
public UInt32 get_BatchReadCount()
public bool get_IsBatchRead()
public ProcessingState get_State()
public FileReadType get_ReadType()
public Priority get_PriorityLevel()
public AssetLoadingSubsystem get_Subsystem()
public double get_RequestTimeMicroseconds()
public double get_TimeInQueueMicroseconds()
public double get_TotalTimeMicroseconds()
}
public Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics : object {
private ulong <TotalBytesRead>k__BackingField
private float <AverageBandwidthMBPerSecond>k__BackingField
private float <AverageReadSizeInBytes>k__BackingField
private float <AverageWaitTimeMicroseconds>k__BackingField
private float <AverageReadTimeMicroseconds>k__BackingField
private float <AverageTotalRequestTimeMicroseconds>k__BackingField
private float <AverageThroughputMBPerSecond>k__BackingField
private float <LongestWaitTimeMicroseconds>k__BackingField
private float <LongestReadTimeMicroseconds>k__BackingField
private ulong <LongestReadAssetType>k__BackingField
private ulong <LongestWaitAssetType>k__BackingField
private AssetLoadingSubsystem <LongestReadSubsystem>k__BackingField
private AssetLoadingSubsystem <LongestWaitSubsystem>k__BackingField
private int <NumberOfInProgressRequests>k__BackingField
private int <NumberOfCompletedRequests>k__BackingField
private int <NumberOfFailedRequests>k__BackingField
private int <NumberOfWaitingRequests>k__BackingField
private int <NumberOfCanceledRequests>k__BackingField
private int <TotalNumberOfRequests>k__BackingField
private int <NumberOfCachedReads>k__BackingField
private int <NumberOfAsyncReads>k__BackingField
private int <NumberOfSyncReads>k__BackingField
public ulong TotalBytesRead
public float AverageBandwidthMBPerSecond
public float AverageReadSizeInBytes
public float AverageWaitTimeMicroseconds
public float AverageReadTimeMicroseconds
public float AverageTotalRequestTimeMicroseconds
public float AverageThroughputMBPerSecond
public float LongestWaitTimeMicroseconds
public float LongestReadTimeMicroseconds
public ulong LongestReadAssetType
public ulong LongestWaitAssetType
public AssetLoadingSubsystem LongestReadSubsystem
public AssetLoadingSubsystem LongestWaitSubsystem
public int NumberOfInProgressRequests
public int NumberOfCompletedRequests
public int NumberOfFailedRequests
public int NumberOfWaitingRequests
public int NumberOfCanceledRequests
public int TotalNumberOfRequests
public int NumberOfCachedReads
public int NumberOfAsyncReads
public int NumberOfSyncReads
public ulong get_TotalBytesRead()
public float get_AverageBandwidthMBPerSecond()
public float get_AverageReadSizeInBytes()
public float get_AverageWaitTimeMicroseconds()
public float get_AverageReadTimeMicroseconds()
public float get_AverageTotalRequestTimeMicroseconds()
public float get_AverageThroughputMBPerSecond()
public float get_LongestWaitTimeMicroseconds()
public float get_LongestReadTimeMicroseconds()
public ulong get_LongestReadAssetType()
public ulong get_LongestWaitAssetType()
public AssetLoadingSubsystem get_LongestReadSubsystem()
public AssetLoadingSubsystem get_LongestWaitSubsystem()
public int get_NumberOfInProgressRequests()
public int get_NumberOfCompletedRequests()
public int get_NumberOfFailedRequests()
public int get_NumberOfWaitingRequests()
public int get_NumberOfCanceledRequests()
public int get_TotalNumberOfRequests()
public int get_NumberOfCachedReads()
public int get_NumberOfAsyncReads()
public int get_NumberOfSyncReads()
}
public Unity.IO.LowLevel.Unsafe.FileHandle : ValueType {
internal IntPtr fileCommandPtr
internal int version
public FileStatus Status
public JobHandle JobHandle
public FileStatus get_Status()
public JobHandle get_JobHandle()
public bool IsValid()
public JobHandle Close(JobHandle dependency)
private bool IsFileHandleValid(FileHandle& handle)
private FileStatus GetFileStatus_Internal(FileHandle& handle)
private JobHandle GetJobHandle_Internal(FileHandle& handle)
private void GetJobHandle_Internal_Injected(FileHandle& handle, JobHandle& ret)
}
public Unity.IO.LowLevel.Unsafe.FileInfoResult : ValueType {
public long FileSize
public FileState FileState
}
public Unity.IO.LowLevel.Unsafe.FileReadType : Enum {
public int value__
public FileReadType Sync
public FileReadType Async
}
public Unity.IO.LowLevel.Unsafe.FileState : Enum {
public int value__
public FileState Absent
public FileState Exists
}
public Unity.IO.LowLevel.Unsafe.FileStatus : Enum {
public int value__
public FileStatus Closed
public FileStatus Pending
public FileStatus Open
public FileStatus OpenFailed
}
public Unity.IO.LowLevel.Unsafe.Priority : Enum {
public int value__
public Priority PriorityLow
public Priority PriorityHigh
}
public Unity.IO.LowLevel.Unsafe.ProcessingState : Enum {
public int value__
public ProcessingState Unknown
public ProcessingState InQueue
public ProcessingState Reading
public ProcessingState Completed
public ProcessingState Failed
public ProcessingState Canceled
}
public Unity.IO.LowLevel.Unsafe.ReadCommand : ValueType {
public Void* Buffer
public long Offset
public long Size
}
public Unity.IO.LowLevel.Unsafe.ReadCommandArray : ValueType {
public ReadCommand* ReadCommands
public int CommandCount
}
public Unity.IO.LowLevel.Unsafe.ReadHandle : ValueType {
internal IntPtr ptr
internal int version
public JobHandle JobHandle
public ReadStatus Status
public long ReadCount
public bool IsValid()
public void Dispose()
public void Cancel()
private void CancelInternal(ReadHandle handle)
public JobHandle get_JobHandle()
public ReadStatus get_Status()
public long get_ReadCount()
public long GetBytesRead()
public long GetBytesRead(UInt32 readCommandIndex)
public UInt64* GetBytesReadArray()
private ReadStatus GetReadStatus(ReadHandle handle)
private long GetReadCount(ReadHandle handle)
private long GetBytesRead(ReadHandle handle)
private long GetBytesReadForCommand(ReadHandle handle, UInt32 readCommandIndex)
private UInt64* GetBytesReadArray(ReadHandle handle)
private void ReleaseReadHandle(ReadHandle handle)
private bool IsReadHandleValid(ReadHandle handle)
private JobHandle GetJobHandle(ReadHandle handle)
private void CancelInternal_Injected(ReadHandle& handle)
private ReadStatus GetReadStatus_Injected(ReadHandle& handle)
private long GetReadCount_Injected(ReadHandle& handle)
private long GetBytesRead_Injected(ReadHandle& handle)
private long GetBytesReadForCommand_Injected(ReadHandle& handle, UInt32 readCommandIndex)
private UInt64* GetBytesReadArray_Injected(ReadHandle& handle)
private void ReleaseReadHandle_Injected(ReadHandle& handle)
private bool IsReadHandleValid_Injected(ReadHandle& handle)
private void GetJobHandle_Injected(ReadHandle& handle, JobHandle& ret)
}
public Unity.IO.LowLevel.Unsafe.ReadStatus : Enum {
public int value__
public ReadStatus Complete
public ReadStatus InProgress
public ReadStatus Failed
public ReadStatus Truncated
public ReadStatus Canceled
}
public Unity.IO.LowLevel.Unsafe.VirtualFileSystem : object {
public bool GetLocalFileSystemName(string vfsFileName, String& localFileName, UInt64& localFileOffset, UInt64& localFileSize)
}
public Unity.Jobs.IJob {
public void Execute()
}
public Unity.Jobs.IJobExtensions : object {
public JobHandle Schedule(T jobData, JobHandle dependsOn)
public void Run(T jobData)
}
public Unity.Jobs.IJobFor {
public void Execute(int index)
}
public Unity.Jobs.IJobForExtensions : object {
public JobHandle Schedule(T jobData, int arrayLength, JobHandle dependency)
public JobHandle ScheduleParallel(T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependency)
public void Run(T jobData, int arrayLength)
}
public Unity.Jobs.IJobParallelFor {
public void Execute(int index)
}
public Unity.Jobs.IJobParallelForExtensions : object {
public JobHandle Schedule(T jobData, int arrayLength, int innerloopBatchCount, JobHandle dependsOn)
public void Run(T jobData, int arrayLength)
}
public Unity.Jobs.JobHandle : ValueType {
internal IntPtr jobGroup
internal int version
public bool IsCompleted
public void Complete()
public void CompleteAll(JobHandle& job0, JobHandle& job1)
public void CompleteAll(JobHandle& job0, JobHandle& job1, JobHandle& job2)
public void CompleteAll(NativeArray`1<JobHandle> jobs)
public bool get_IsCompleted()
public void ScheduleBatchedJobs()
private void ScheduleBatchedJobsAndComplete(JobHandle& job)
private bool ScheduleBatchedJobsAndIsCompleted(JobHandle& job)
private void ScheduleBatchedJobsAndCompleteAll(Void* jobs, int count)
public JobHandle CombineDependencies(JobHandle job0, JobHandle job1)
public JobHandle CombineDependencies(JobHandle job0, JobHandle job1, JobHandle job2)
public JobHandle CombineDependencies(NativeArray`1<JobHandle> jobs)
public JobHandle CombineDependencies(NativeSlice`1<JobHandle> jobs)
private JobHandle CombineDependenciesInternal2(JobHandle& job0, JobHandle& job1)
private JobHandle CombineDependenciesInternal3(JobHandle& job0, JobHandle& job1, JobHandle& job2)
internal JobHandle CombineDependenciesInternalPtr(Void* jobs, int count)
public bool CheckFenceIsDependencyOrDidSyncFence(JobHandle jobHandle, JobHandle dependsOn)
private void CombineDependenciesInternal2_Injected(JobHandle& job0, JobHandle& job1, JobHandle& ret)
private void CombineDependenciesInternal3_Injected(JobHandle& job0, JobHandle& job1, JobHandle& job2, JobHandle& ret)
private void CombineDependenciesInternalPtr_Injected(Void* jobs, int count, JobHandle& ret)
private bool CheckFenceIsDependencyOrDidSyncFence_Injected(JobHandle& jobHandle, JobHandle& dependsOn)
}
public Unity.Jobs.LowLevel.Unsafe.BatchQueryJob`2 : ValueType {
internal NativeArray`1<CommandT> commands
internal NativeArray`1<ResultT> results
public void .ctor(NativeArray`1<CommandT> commands, NativeArray`1<ResultT> results)
}
public Unity.Jobs.LowLevel.Unsafe.BatchQueryJobStruct`1 : ValueType {
internal IntPtr jobReflectionData
public IntPtr Initialize()
}
public Unity.Jobs.LowLevel.Unsafe.JobHandleUnsafeUtility : object {
public JobHandle CombineDependencies(JobHandle* jobs, int count)
}
public Unity.Jobs.LowLevel.Unsafe.JobProducerTypeAttribute : Attribute {
private Type <ProducerType>k__BackingField
public Type ProducerType
public Type get_ProducerType()
public void .ctor(Type producerType)
}
public Unity.Jobs.LowLevel.Unsafe.JobRanges : ValueType {
internal int BatchSize
internal int NumJobs
public int TotalIterationCount
internal int NumPhases
internal IntPtr StartEndIndex
internal IntPtr PhaseData
}
public Unity.Jobs.LowLevel.Unsafe.JobsUtility : object {
public int MaxJobThreadCount
public int CacheLineSize
internal PanicFunction_ PanicFunction
public bool IsExecutingJob
public bool JobDebuggerEnabled
public bool JobCompilerEnabled
public int JobWorkerMaximumCount
public int JobWorkerCount
public void GetJobRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex)
public bool GetWorkStealingRange(JobRanges& ranges, int jobIndex, Int32& beginIndex, Int32& endIndex)
public JobHandle Schedule(JobScheduleParameters& parameters)
public JobHandle ScheduleParallelFor(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount)
public JobHandle ScheduleParallelForDeferArraySize(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle)
public JobHandle ScheduleParallelForTransform(JobScheduleParameters& parameters, IntPtr transfromAccesssArray)
public JobHandle ScheduleParallelForTransformReadOnly(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, int innerloopBatchCount)
public void PatchBufferMinMaxRanges(IntPtr bufferRangePatchData, Void* jobdata, int startIndex, int rangeSize)
private IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2)
public IntPtr CreateJobReflectionData(Type type, JobType jobType, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2)
public IntPtr CreateJobReflectionData(Type type, object managedJobFunction0, object managedJobFunction1, object managedJobFunction2)
public IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, JobType jobType, object managedJobFunction0)
public IntPtr CreateJobReflectionData(Type wrapperJobType, Type userJobType, object managedJobFunction0)
public bool get_IsExecutingJob()
public bool get_JobDebuggerEnabled()
public void set_JobDebuggerEnabled(bool value)
public bool get_JobCompilerEnabled()
public void set_JobCompilerEnabled(bool value)
private int GetJobQueueWorkerThreadCount()
private void SetJobQueueMaximumActiveThreadCount(int count)
public int get_JobWorkerMaximumCount()
public void ResetJobWorkerCount()
public int get_JobWorkerCount()
public void set_JobWorkerCount(int value)
internal IntPtr GetSystemIdCellPtr()
internal void ClearSystemIds()
internal int GetSystemIdMappings(JobHandle* handles, Int32* systemIds, int maxCount)
private void InvokePanicFunction()
private void Schedule_Injected(JobScheduleParameters& parameters, JobHandle& ret)
private void ScheduleParallelFor_Injected(JobScheduleParameters& parameters, int arrayLength, int innerloopBatchCount, JobHandle& ret)
private void ScheduleParallelForDeferArraySize_Injected(JobScheduleParameters& parameters, int innerloopBatchCount, Void* listData, Void* listDataAtomicSafetyHandle, JobHandle& ret)
private void ScheduleParallelForTransform_Injected(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, JobHandle& ret)
private void ScheduleParallelForTransformReadOnly_Injected(JobScheduleParameters& parameters, IntPtr transfromAccesssArray, int innerloopBatchCount, JobHandle& ret)
}
public Unity.Jobs.LowLevel.Unsafe.JobType : Enum {
public int value__
public JobType Single
public JobType ParallelFor
}
public Unity.Jobs.LowLevel.Unsafe.ScheduleMode : Enum {
public int value__
public ScheduleMode Run
public ScheduleMode Batched
public ScheduleMode Parallel
public ScheduleMode Single
}
public Unity.Profiling.LowLevel.MarkerFlags : Enum {
public ushort value__
public MarkerFlags Default
public MarkerFlags Script
public MarkerFlags ScriptInvoke
public MarkerFlags ScriptDeepProfiler
public MarkerFlags AvailabilityEditor
public MarkerFlags AvailabilityNonDevelopment
public MarkerFlags Warning
public MarkerFlags Counter
public MarkerFlags SampleGPU
}
public Unity.Profiling.LowLevel.ProfilerMarkerDataType : Enum {
public byte value__
public ProfilerMarkerDataType Int32
public ProfilerMarkerDataType UInt32
public ProfilerMarkerDataType Int64
public ProfilerMarkerDataType UInt64
public ProfilerMarkerDataType Float
public ProfilerMarkerDataType Double
public ProfilerMarkerDataType String16
public ProfilerMarkerDataType Blob8
}
public Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription : ValueType {
public ushort Id
public ushort Flags
public Color32 Color
private int reserved0
public int NameUtf8Len
public Byte* NameUtf8
public string Name
public string get_Name()
}
public Unity.Profiling.LowLevel.Unsafe.ProfilerMarkerData : ValueType {
public byte Type
private byte reserved0
private ushort reserved1
public UInt32 Size
public Void* Ptr
}
public Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription : ValueType {
private ProfilerCategory category
private MarkerFlags flags
private ProfilerMarkerDataType dataType
private ProfilerMarkerDataUnit unitType
private int reserved0
private int nameUtf8Len
private Byte* nameUtf8
public ProfilerCategory Category
public MarkerFlags Flags
public ProfilerMarkerDataType DataType
public ProfilerMarkerDataUnit UnitType
public int NameUtf8Len
public Byte* NameUtf8
public string Name
public ProfilerCategory get_Category()
public MarkerFlags get_Flags()
public ProfilerMarkerDataType get_DataType()
public ProfilerMarkerDataUnit get_UnitType()
public int get_NameUtf8Len()
public Byte* get_NameUtf8()
public string get_Name()
}
public Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle : ValueType {
private ulong k_InvalidHandle
internal ulong handle
public bool Valid
internal void .ctor(ulong handle)
public bool get_Valid()
internal ProfilerRecorderHandle Get(ProfilerMarker marker)
internal ProfilerRecorderHandle Get(ProfilerCategory category, string statName)
public ProfilerRecorderDescription GetDescription(ProfilerRecorderHandle handle)
public void GetAvailable(List`1<ProfilerRecorderHandle> outRecorderHandleList)
internal ProfilerRecorderHandle GetByName(ProfilerCategory category, string name)
internal ProfilerRecorderHandle GetByName__Unmanaged(ProfilerCategory category, Byte* name, int nameLen)
internal ProfilerRecorderHandle GetByName(ProfilerCategory category, Char* name, int nameLen)
private ProfilerRecorderHandle GetByName_Unsafe(ProfilerCategory category, Char* name, int nameLen)
private ProfilerRecorderDescription GetDescriptionInternal(ProfilerRecorderHandle handle)
private void GetByName_Injected(ProfilerCategory& category, string name, ProfilerRecorderHandle& ret)
private void GetByName__Unmanaged_Injected(ProfilerCategory& category, Byte* name, int nameLen, ProfilerRecorderHandle& ret)
private void GetByName_Unsafe_Injected(ProfilerCategory& category, Char* name, int nameLen, ProfilerRecorderHandle& ret)
private void GetDescriptionInternal_Injected(ProfilerRecorderHandle& handle, ProfilerRecorderDescription& ret)
}
public Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility : object {
public ushort CategoryRender
public ushort CategoryScripts
public ushort CategoryGUI
public ushort CategoryPhysics
public ushort CategoryAnimation
public ushort CategoryAi
public ushort CategoryAudio
public ushort CategoryVideo
public ushort CategoryParticles
public ushort CategoryLighting
public ushort CategoryLightning
public ushort CategoryNetwork
public ushort CategoryLoading
public ushort CategoryOther
public ushort CategoryVr
public ushort CategoryAllocation
public ushort CategoryInternal
public ushort CategoryFileIO
public ushort CategoryInput
public ushort CategoryVirtualTexturing
internal ushort CategoryGPU
internal ushort CategoryAny
public long Timestamp
public TimestampConversionRatio TimestampToNanosecondsConversionRatio
internal ushort CreateCategory(string name, ProfilerCategoryColor colorIndex)
internal ushort CreateCategory__Unmanaged(Byte* name, int nameLen, ProfilerCategoryColor colorIndex)
public ushort CreateCategory(Char* name, int nameLen, ProfilerCategoryColor colorIndex)
private ushort CreateCategory_Unsafe(Char* name, int nameLen, ProfilerCategoryColor colorIndex)
public ushort GetCategoryByName(Char* name, int nameLen)
private ushort GetCategoryByName_Unsafe(Char* name, int nameLen)
public ProfilerCategoryDescription GetCategoryDescription(ushort categoryId)
internal Color32 GetCategoryColor(ProfilerCategoryColor colorIndex)
public IntPtr CreateMarker(string name, ushort categoryId, MarkerFlags flags, int metadataCount)
internal IntPtr CreateMarker__Unmanaged(Byte* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount)
public IntPtr CreateMarker(Char* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount)
private IntPtr CreateMarker_Unsafe(Char* name, int nameLen, ushort categoryId, MarkerFlags flags, int metadataCount)
internal IntPtr GetMarker(string name)
public void SetMarkerMetadata(IntPtr markerPtr, int index, string name, byte type, byte unit)
internal void SetMarkerMetadata__Unmanaged(IntPtr markerPtr, int index, Byte* name, int nameLen, byte type, byte unit)
public void SetMarkerMetadata(IntPtr markerPtr, int index, Char* name, int nameLen, byte type, byte unit)
private void SetMarkerMetadata_Unsafe(IntPtr markerPtr, int index, Char* name, int nameLen, byte type, byte unit)
public void BeginSample(IntPtr markerPtr)
public void BeginSampleWithMetadata(IntPtr markerPtr, int metadataCount, Void* metadata)
public void EndSample(IntPtr markerPtr)
public void SingleSampleWithMetadata(IntPtr markerPtr, int metadataCount, Void* metadata)
public Void* CreateCounterValue(IntPtr& counterPtr, string name, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions)
internal Void* CreateCounterValue__Unmanaged(IntPtr& counterPtr, Byte* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions)
public Void* CreateCounterValue(IntPtr& counterPtr, Char* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions)
private Void* CreateCounterValue_Unsafe(IntPtr& counterPtr, Char* name, int nameLen, ushort categoryId, MarkerFlags flags, byte dataType, byte dataUnit, int dataSize, ProfilerCounterOptions counterOptions)
public void FlushCounterValue(Void* counterValuePtr)
internal string Utf8ToString(Byte* chars, int charsLen)
public UInt32 CreateFlow(ushort categoryId)
public void FlowEvent(UInt32 flowId, ProfilerFlowEventType flowEventType)
internal void Internal_BeginWithObject(IntPtr markerPtr, Object contextUnityObject)
internal string Internal_GetName(IntPtr markerPtr)
public long get_Timestamp()
public TimestampConversionRatio get_TimestampToNanosecondsConversionRatio()
private void GetCategoryDescription_Injected(ushort categoryId, ProfilerCategoryDescription& ret)
private void GetCategoryColor_Injected(ProfilerCategoryColor colorIndex, Color32& ret)
private void get_TimestampToNanosecondsConversionRatio_Injected(TimestampConversionRatio& ret)
}
public Unity.Profiling.ProfilerCategory : ValueType {
private ushort m_CategoryId
public string Name
public Color32 Color
public ProfilerCategory Render
public ProfilerCategory Scripts
public ProfilerCategory Gui
public ProfilerCategory Physics
public ProfilerCategory Animation
public ProfilerCategory Ai
public ProfilerCategory Audio
public ProfilerCategory Video
public ProfilerCategory Particles
public ProfilerCategory Lighting
public ProfilerCategory Network
public ProfilerCategory Loading
public ProfilerCategory Vr
public ProfilerCategory Input
public ProfilerCategory Memory
public ProfilerCategory VirtualTexturing
public ProfilerCategory FileIO
public ProfilerCategory Internal
internal ProfilerCategory Any
internal ProfilerCategory GPU
public void .ctor(string categoryName)
public void .ctor(string categoryName, ProfilerCategoryColor color)
internal void .ctor(ushort category)
public string get_Name()
public Color32 get_Color()
public string ToString()
public ProfilerCategory get_Render()
public ProfilerCategory get_Scripts()
public ProfilerCategory get_Gui()
public ProfilerCategory get_Physics()
public ProfilerCategory get_Animation()
public ProfilerCategory get_Ai()
public ProfilerCategory get_Audio()
public ProfilerCategory get_Video()
public ProfilerCategory get_Particles()
public ProfilerCategory get_Lighting()
public ProfilerCategory get_Network()
public ProfilerCategory get_Loading()
public ProfilerCategory get_Vr()
public ProfilerCategory get_Input()
public ProfilerCategory get_Memory()
public ProfilerCategory get_VirtualTexturing()
public ProfilerCategory get_FileIO()
public ProfilerCategory get_Internal()
internal ProfilerCategory get_Any()
internal ProfilerCategory get_GPU()
public ushort op_Implicit(ProfilerCategory category)
}
public Unity.Profiling.ProfilerCategoryColor : Enum {
public ushort value__
public ProfilerCategoryColor Render
public ProfilerCategoryColor Scripts
public ProfilerCategoryColor BurstJobs
public ProfilerCategoryColor Other
public ProfilerCategoryColor Physics
public ProfilerCategoryColor Animation
public ProfilerCategoryColor Audio
public ProfilerCategoryColor AudioJob
public ProfilerCategoryColor AudioUpdateJob
public ProfilerCategoryColor Lighting
public ProfilerCategoryColor GC
public ProfilerCategoryColor VSync
public ProfilerCategoryColor Memory
public ProfilerCategoryColor Internal
public ProfilerCategoryColor UI
public ProfilerCategoryColor Build
public ProfilerCategoryColor Input
}
public Unity.Profiling.ProfilerCategoryFlags : Enum {
public ushort value__
public ProfilerCategoryFlags None
public ProfilerCategoryFlags Builtin
}
public Unity.Profiling.ProfilerCounterOptions : Enum {
public ushort value__
public ProfilerCounterOptions None
public ProfilerCounterOptions FlushOnEndOfFrame
public ProfilerCounterOptions ResetToZeroOnFlush
}
public Unity.Profiling.ProfilerFlowEventType : Enum {
public byte value__
public ProfilerFlowEventType Begin
public ProfilerFlowEventType ParallelNext
public ProfilerFlowEventType End
public ProfilerFlowEventType Next
}
public Unity.Profiling.ProfilerMarker : ValueType {
internal IntPtr m_Ptr
public IntPtr Handle
public IntPtr get_Handle()
public void .ctor(string name)
public void .ctor(Char* name, int nameLen)
public void .ctor(ProfilerCategory category, string name)
public void .ctor(ProfilerCategory category, Char* name, int nameLen)
public void .ctor(ProfilerCategory category, string name, MarkerFlags flags)
public void .ctor(ProfilerCategory category, Char* name, int nameLen, MarkerFlags flags)
public void Begin()
public void Begin(Object contextUnityObject)
public void End()
internal void GetName(String& name)
public AutoScope Auto()
}
public Unity.Profiling.ProfilerMarkerDataUnit : Enum {
public byte value__
public ProfilerMarkerDataUnit Undefined
public ProfilerMarkerDataUnit TimeNanoseconds
public ProfilerMarkerDataUnit Bytes
public ProfilerMarkerDataUnit Count
public ProfilerMarkerDataUnit Percent
public ProfilerMarkerDataUnit FrequencyHz
}
internal Unity.Profiling.ProfilerMarkerWithStringData : ValueType {
private MethodImplOptions AggressiveInlining
private IntPtr _marker
public ProfilerMarkerWithStringData Create(string name, string parameterName)
public AutoScope Auto(bool enabled, Func`1<string> parameterValue)
public AutoScope Auto(string value)
}
public Unity.Profiling.ProfilerRecorder : ValueType {
internal ulong handle
internal ProfilerRecorderOptions SharedRecorder
public bool Valid
public ProfilerMarkerDataType DataType
public ProfilerMarkerDataUnit UnitType
public long CurrentValue
public double CurrentValueAsDouble
public long LastValue
public double LastValueAsDouble
public int Capacity
public int Count
public bool IsRunning
public bool WrappedAround
internal void .ctor(ProfilerRecorderOptions options)
public void .ctor(string statName, int capacity, ProfilerRecorderOptions options)
public void .ctor(string categoryName, string statName, int capacity, ProfilerRecorderOptions options)
public void .ctor(ProfilerCategory category, string statName, int capacity, ProfilerRecorderOptions options)
public void .ctor(ProfilerCategory category, Char* statName, int statNameLen, int capacity, ProfilerRecorderOptions options)
public void .ctor(ProfilerMarker marker, int capacity, ProfilerRecorderOptions options)
public void .ctor(ProfilerRecorderHandle statHandle, int capacity, ProfilerRecorderOptions options)
public ProfilerRecorder StartNew(ProfilerCategory category, string statName, int capacity, ProfilerRecorderOptions options)
public ProfilerRecorder StartNew(ProfilerMarker marker, int capacity, ProfilerRecorderOptions options)
internal ProfilerRecorder StartNew()
public bool get_Valid()
public ProfilerMarkerDataType get_DataType()
public ProfilerMarkerDataUnit get_UnitType()
public void Start()
public void Stop()
public void Reset()
public long get_CurrentValue()
public double get_CurrentValueAsDouble()
public long get_LastValue()
public double get_LastValueAsDouble()
public int get_Capacity()
public int get_Count()
public bool get_IsRunning()
public bool get_WrappedAround()
public ProfilerRecorderSample GetSample(int index)
public void CopyTo(List`1<ProfilerRecorderSample> outSamples, bool reset)
public int CopyTo(ProfilerRecorderSample* dest, int destSize, bool reset)
public ProfilerRecorderSample[] ToArray()
internal void FilterToCurrentThread()
internal void CollectFromAllThreads()
private ProfilerRecorder Create(ProfilerRecorderHandle statHandle, int maxSampleCount, ProfilerRecorderOptions options)
private void Control(ProfilerRecorder handle, ControlOptions options)
private ProfilerMarkerDataUnit GetValueUnitType(ProfilerRecorder handle)
private ProfilerMarkerDataType GetValueDataType(ProfilerRecorder handle)
private long GetCurrentValue(ProfilerRecorder handle)
private double GetCurrentValueAsDouble(ProfilerRecorder handle)
private long GetLastValue(ProfilerRecorder handle)
private double GetLastValueAsDouble(ProfilerRecorder handle)
private int GetCount(ProfilerRecorder handle, CountOptions countOptions)
private bool GetValid(ProfilerRecorder handle)
private bool GetWrapped(ProfilerRecorder handle)
private bool GetRunning(ProfilerRecorder handle)
private ProfilerRecorderSample GetSampleInternal(ProfilerRecorder handle, int index)
private void CopyTo_List(ProfilerRecorder handle, List`1<ProfilerRecorderSample> outSamples, bool reset)
private int CopyTo_Pointer(ProfilerRecorder handle, ProfilerRecorderSample* outSamples, int outSamplesSize, bool reset)
public void Dispose()
private void CheckInitializedWithParamsAndThrow(ProfilerRecorderSample* dest)
private void CheckInitializedAndThrow()
private void Create_Injected(ProfilerRecorderHandle& statHandle, int maxSampleCount, ProfilerRecorderOptions options, ProfilerRecorder& ret)
private void Control_Injected(ProfilerRecorder& handle, ControlOptions options)
private ProfilerMarkerDataUnit GetValueUnitType_Injected(ProfilerRecorder& handle)
private ProfilerMarkerDataType GetValueDataType_Injected(ProfilerRecorder& handle)
private long GetCurrentValue_Injected(ProfilerRecorder& handle)
private double GetCurrentValueAsDouble_Injected(ProfilerRecorder& handle)
private long GetLastValue_Injected(ProfilerRecorder& handle)
private double GetLastValueAsDouble_Injected(ProfilerRecorder& handle)
private int GetCount_Injected(ProfilerRecorder& handle, CountOptions countOptions)
private bool GetValid_Injected(ProfilerRecorder& handle)
private bool GetWrapped_Injected(ProfilerRecorder& handle)
private bool GetRunning_Injected(ProfilerRecorder& handle)
private void GetSampleInternal_Injected(ProfilerRecorder& handle, int index, ProfilerRecorderSample& ret)
private void CopyTo_List_Injected(ProfilerRecorder& handle, List`1<ProfilerRecorderSample> outSamples, bool reset)
private int CopyTo_Pointer_Injected(ProfilerRecorder& handle, ProfilerRecorderSample* outSamples, int outSamplesSize, bool reset)
}
internal Unity.Profiling.ProfilerRecorderDebugView : object {
private ProfilerRecorder m_Recorder
public ProfilerRecorderSample[] Items
public void .ctor(ProfilerRecorder r)
public ProfilerRecorderSample[] get_Items()
}
public Unity.Profiling.ProfilerRecorderOptions : Enum {
public int value__
public ProfilerRecorderOptions None
public ProfilerRecorderOptions StartImmediately
public ProfilerRecorderOptions KeepAliveDuringDomainReload
public ProfilerRecorderOptions CollectOnlyOnCurrentThread
public ProfilerRecorderOptions WrapAroundWhenCapacityReached
public ProfilerRecorderOptions SumAllSamplesInFrame
public ProfilerRecorderOptions GpuRecorder
public ProfilerRecorderOptions Default
}
public Unity.Profiling.ProfilerRecorderSample : ValueType {
private long value
private long count
private long refValue
public long Value
public long Count
public long get_Value()
public long get_Count()
}
public Unity.Rendering.HybridV2.DOTSInstancingCbuffer : ValueType {
public int NameID
public int CbufferIndex
public int SizeBytes
}
public Unity.Rendering.HybridV2.DOTSInstancingProperty : ValueType {
public int MetadataNameID
public int ConstantNameID
public int CbufferIndex
public int MetadataOffset
public int SizeBytes
public DOTSInstancingPropertyType ConstantType
public int Cols
public int Rows
}
public Unity.Rendering.HybridV2.DOTSInstancingPropertyType : Enum {
public int value__
public DOTSInstancingPropertyType Unknown
public DOTSInstancingPropertyType Float
public DOTSInstancingPropertyType Half
public DOTSInstancingPropertyType Int
public DOTSInstancingPropertyType Short
public DOTSInstancingPropertyType Uint
public DOTSInstancingPropertyType Bool
public DOTSInstancingPropertyType Struct
}
public Unity.Rendering.HybridV2.HybridV2ShaderReflection : object {
private IntPtr GetDOTSInstancingCbuffersPointer(Shader shader, Int32& cbufferCount)
private IntPtr GetDOTSInstancingPropertiesPointer(Shader shader, Int32& propertyCount)
public UInt32 GetDOTSReflectionVersionNumber()
public NativeArray`1<DOTSInstancingCbuffer> GetDOTSInstancingCbuffers(Shader shader)
public NativeArray`1<DOTSInstancingProperty> GetDOTSInstancingProperties(Shader shader)
}
public UnityEditor.Experimental.RenderSettings : object {
private bool <useRadianceAmbientProbe>k__BackingField
public bool useRadianceAmbientProbe
public bool get_useRadianceAmbientProbe()
public void set_useRadianceAmbientProbe(bool value)
}
internal UnityEngine._Scripting.APIUpdating.APIUpdaterRuntimeHelpers : object {
internal bool GetMovedFromAttributeDataForType(Type sourceType, String& assembly, String& nsp, String& klass)
internal bool GetObsoleteTypeRedirection(Type sourceType, String& assemblyName, String& nsp, String& className)
}
public UnityEngine.AddComponentMenu : Attribute {
private string m_AddComponentMenu
private int m_Ordering
public string componentMenu
public int componentOrder
public void .ctor(string menuName)
public void .ctor(string menuName, int order)
public string get_componentMenu()
public int get_componentOrder()
}
public UnityEngine.AnimationCurve : object {
internal IntPtr m_Ptr
public Keyframe[] keys
public Keyframe Item
public int length
public WrapMode preWrapMode
public WrapMode postWrapMode
private void Internal_Destroy(IntPtr ptr)
private IntPtr Internal_Create(Keyframe[] keys)
private bool Internal_Equals(IntPtr other)
protected void Finalize()
public float Evaluate(float time)
public Keyframe[] get_keys()
public void set_keys(Keyframe[] value)
public int AddKey(float time, float value)
public int AddKey(Keyframe key)
private int AddKey_Internal(Keyframe key)
public int MoveKey(int index, Keyframe key)
public void RemoveKey(int index)
public Keyframe get_Item(int index)
public int get_length()
private void SetKeys(Keyframe[] keys)
private Keyframe GetKey(int index)
private Keyframe[] GetKeys()
public void SmoothTangents(int index, float weight)
public AnimationCurve Constant(float timeStart, float timeEnd, float value)
public AnimationCurve Linear(float timeStart, float valueStart, float timeEnd, float valueEnd)
public AnimationCurve EaseInOut(float timeStart, float valueStart, float timeEnd, float valueEnd)
public WrapMode get_preWrapMode()
public void set_preWrapMode(WrapMode value)
public WrapMode get_postWrapMode()
public void set_postWrapMode(WrapMode value)
public void .ctor(Keyframe[] keys)
public bool Equals(object o)
public bool Equals(AnimationCurve other)
public int GetHashCode()
private int AddKey_Internal_Injected(Keyframe& key)
private int MoveKey_Injected(int index, Keyframe& key)
private void GetKey_Injected(int index, Keyframe& ret)
}
public UnityEngine.AnisotropicFiltering : Enum {
public int value__
public AnisotropicFiltering Disable
public AnisotropicFiltering Enable
public AnisotropicFiltering ForceEnable
}
public UnityEngine.Apple.FrameCapture : object {
private bool IsDestinationSupportedImpl(FrameCaptureDestination dest)
private void BeginCaptureImpl(FrameCaptureDestination dest, string path)
private void EndCaptureImpl()
private void CaptureNextFrameImpl(FrameCaptureDestination dest, string path)
public bool IsDestinationSupported(FrameCaptureDestination dest)
public void BeginCaptureToXcode()
public void BeginCaptureToFile(string path)
public void EndCapture()
public void CaptureNextFrameToXcode()
public void CaptureNextFrameToFile(string path)
}
public UnityEngine.Apple.FrameCaptureDestination : Enum {
public int value__
public FrameCaptureDestination DevTools
public FrameCaptureDestination GPUTraceDocument
}
public UnityEngine.Application : object {
private LowMemoryCallback lowMemory
private LogCallback s_LogCallbackHandler
private LogCallback s_LogCallbackHandlerThreaded
internal AdvertisingIdentifierCallback OnAdvertisingIdentifierCallback
private Action`1<bool> focusChanged
private Action`1<string> deepLinkActivated
private Func`1<bool> wantsToQuit
private Action quitting
private Action unloading
private LogCallback modreq(System.Runtime.CompilerServices.IsVolatile) s_RegisterLogCallbackDeprecated
public bool isLoadingLevel
public int streamedBytes
public bool webSecurityEnabled
public bool isPlaying
public bool isFocused
public string buildGUID
public bool runInBackground
public bool isBatchMode
internal bool isTestRun
internal bool isHumanControllingUs
public string dataPath
public string streamingAssetsPath
public string persistentDataPath
public string temporaryCachePath
public string absoluteURL
public string unityVersion
internal int unityVersionVer
internal int unityVersionMaj
internal int unityVersionMin
public string version
public string installerName
public string identifier
public ApplicationInstallMode installMode
public ApplicationSandboxType sandboxType
public string productName
public string companyName
public string cloudProjectId
public int targetFrameRate
public StackTraceLogType stackTraceLogType
public string consoleLogPath
public ThreadPriority backgroundLoadingPriority
public bool genuine
public bool genuineCheckAvailable
internal bool submitAnalytics
public bool isShowingSplashScreen
public RuntimePlatform platform
public bool isMobilePlatform
public bool isConsolePlatform
public SystemLanguage systemLanguage
public NetworkReachability internetReachability
public bool isPlayer
public int levelCount
public int loadedLevel
public string loadedLevelName
public bool isEditor
public void Quit(int exitCode)
public void Quit()
public void CancelQuit()
public void Unload()
public bool get_isLoadingLevel()
public float GetStreamProgressForLevel(int levelIndex)
public float GetStreamProgressForLevel(string levelName)
public int get_streamedBytes()
public bool get_webSecurityEnabled()
public bool CanStreamedLevelBeLoaded(int levelIndex)
public bool CanStreamedLevelBeLoaded(string levelName)
public bool get_isPlaying()
public bool IsPlaying(Object obj)
public bool get_isFocused()
public String[] GetBuildTags()
public void SetBuildTags(String[] buildTags)
public string get_buildGUID()
public bool get_runInBackground()
public void set_runInBackground(bool value)
public bool HasProLicense()
public bool get_isBatchMode()
internal bool get_isTestRun()
internal bool get_isHumanControllingUs()
internal bool HasARGV(string name)
internal string GetValueForARGV(string name)
public string get_dataPath()
public string get_streamingAssetsPath()
public string get_persistentDataPath()
public string get_temporaryCachePath()
public string get_absoluteURL()
public void ExternalEval(string script)
private void Internal_ExternalCall(string script)
public string get_unityVersion()
internal int get_unityVersionVer()
internal int get_unityVersionMaj()
internal int get_unityVersionMin()
public string get_version()
public string get_installerName()
public string get_identifier()
public ApplicationInstallMode get_installMode()
public ApplicationSandboxType get_sandboxType()
public string get_productName()
public string get_companyName()
public string get_cloudProjectId()
public bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod)
public void OpenURL(string url)
public void ForceCrash(int mode)
public int get_targetFrameRate()
public void set_targetFrameRate(int value)
private void SetLogCallbackDefined(bool defined)
public StackTraceLogType get_stackTraceLogType()
public void set_stackTraceLogType(StackTraceLogType value)
public StackTraceLogType GetStackTraceLogType(LogType logType)
public void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType)
public string get_consoleLogPath()
public ThreadPriority get_backgroundLoadingPriority()
public void set_backgroundLoadingPriority(ThreadPriority value)
public bool get_genuine()
public bool get_genuineCheckAvailable()
public AsyncOperation RequestUserAuthorization(UserAuthorization mode)
public bool HasUserAuthorization(UserAuthorization mode)
internal bool get_submitAnalytics()
public bool get_isShowingSplashScreen()
public RuntimePlatform get_platform()
public bool get_isMobilePlatform()
public bool get_isConsolePlatform()
public SystemLanguage get_systemLanguage()
public NetworkReachability get_internetReachability()
public void add_lowMemory(LowMemoryCallback value)
public void remove_lowMemory(LowMemoryCallback value)
internal void CallLowMemory()
public void add_logMessageReceived(LogCallback value)
public void remove_logMessageReceived(LogCallback value)
public void add_logMessageReceivedThreaded(LogCallback value)
public void remove_logMessageReceivedThreaded(LogCallback value)
private void CallLogCallback(string logString, string stackTrace, LogType type, bool invokedOnMainThread)
internal void InvokeOnAdvertisingIdentifierCallback(string advertisingId, bool trackingEnabled)
private string ObjectToJSString(object o)
public void ExternalCall(string functionName, Object[] args)
private string BuildInvocationForArguments(string functionName, Object[] args)
public bool get_isPlayer()
public void DontDestroyOnLoad(Object o)
public void CaptureScreenshot(string filename, int superSize)
public void CaptureScreenshot(string filename)
public void add_onBeforeRender(UnityAction value)
public void remove_onBeforeRender(UnityAction value)
public void add_focusChanged(Action`1<bool> value)
public void remove_focusChanged(Action`1<bool> value)
public void add_deepLinkActivated(Action`1<string> value)
public void remove_deepLinkActivated(Action`1<string> value)
public void add_wantsToQuit(Func`1<bool> value)
public void remove_wantsToQuit(Func`1<bool> value)
public void add_quitting(Action value)
public void remove_quitting(Action value)
public void add_unloading(Action value)
public void remove_unloading(Action value)
private bool Internal_ApplicationWantsToQuit()
private void Internal_ApplicationQuit()
private void Internal_ApplicationUnload()
internal void InvokeOnBeforeRender()
internal void InvokeFocusChanged(bool focus)
internal void InvokeDeepLinkActivated(string url)
public void RegisterLogCallback(LogCallback handler)
public void RegisterLogCallbackThreaded(LogCallback handler)
private void RegisterLogCallback(LogCallback handler, bool threaded)
public int get_levelCount()
public int get_loadedLevel()
public string get_loadedLevelName()
public void LoadLevel(int index)
public void LoadLevel(string name)
public void LoadLevelAdditive(int index)
public void LoadLevelAdditive(string name)
public AsyncOperation LoadLevelAsync(int index)
public AsyncOperation LoadLevelAsync(string levelName)
public AsyncOperation LoadLevelAdditiveAsync(int index)
public AsyncOperation LoadLevelAdditiveAsync(string levelName)
public bool UnloadLevel(int index)
public bool UnloadLevel(string scenePath)
public bool get_isEditor()
}
public UnityEngine.ApplicationInstallMode : Enum {
public int value__
public ApplicationInstallMode Unknown
public ApplicationInstallMode Store
public ApplicationInstallMode DeveloperBuild
public ApplicationInstallMode Adhoc
public ApplicationInstallMode Enterprise
public ApplicationInstallMode Editor
}
public UnityEngine.ApplicationSandboxType : Enum {
public int value__
public ApplicationSandboxType Unknown
public ApplicationSandboxType NotSandboxed
public ApplicationSandboxType Sandboxed
public ApplicationSandboxType SandboxBroken
}
public UnityEngine.Assertions.Assert : object {
internal string UNITY_ASSERTIONS
public bool raiseExceptions
private void Fail(string message, string userMessage)
public bool Equals(object obj1, object obj2)
public bool ReferenceEquals(object obj1, object obj2)
public void IsTrue(bool condition)
public void IsTrue(bool condition, string message)
public void IsFalse(bool condition)
public void IsFalse(bool condition, string message)
public void AreApproximatelyEqual(float expected, float actual)
public void AreApproximatelyEqual(float expected, float actual, string message)
public void AreApproximatelyEqual(float expected, float actual, float tolerance)
public void AreApproximatelyEqual(float expected, float actual, float tolerance, string message)
public void AreNotApproximatelyEqual(float expected, float actual)
public void AreNotApproximatelyEqual(float expected, float actual, string message)
public void AreNotApproximatelyEqual(float expected, float actual, float tolerance)
public void AreNotApproximatelyEqual(float expected, float actual, float tolerance, string message)
public void AreEqual(T expected, T actual)
public void AreEqual(T expected, T actual, string message)
public void AreEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer)
public void AreEqual(Object expected, Object actual, string message)
public void AreNotEqual(T expected, T actual)
public void AreNotEqual(T expected, T actual, string message)
public void AreNotEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer)
public void AreNotEqual(Object expected, Object actual, string message)
public void IsNull(T value)
public void IsNull(T value, string message)
public void IsNull(Object value, string message)
public void IsNotNull(T value)
public void IsNotNull(T value, string message)
public void IsNotNull(Object value, string message)
public void AreEqual(sbyte expected, sbyte actual)
public void AreEqual(sbyte expected, sbyte actual, string message)
public void AreNotEqual(sbyte expected, sbyte actual)
public void AreNotEqual(sbyte expected, sbyte actual, string message)
public void AreEqual(byte expected, byte actual)
public void AreEqual(byte expected, byte actual, string message)
public void AreNotEqual(byte expected, byte actual)
public void AreNotEqual(byte expected, byte actual, string message)
public void AreEqual(char expected, char actual)
public void AreEqual(char expected, char actual, string message)
public void AreNotEqual(char expected, char actual)
public void AreNotEqual(char expected, char actual, string message)
public void AreEqual(short expected, short actual)
public void AreEqual(short expected, short actual, string message)
public void AreNotEqual(short expected, short actual)
public void AreNotEqual(short expected, short actual, string message)
public void AreEqual(ushort expected, ushort actual)
public void AreEqual(ushort expected, ushort actual, string message)
public void AreNotEqual(ushort expected, ushort actual)
public void AreNotEqual(ushort expected, ushort actual, string message)
public void AreEqual(int expected, int actual)
public void AreEqual(int expected, int actual, string message)
public void AreNotEqual(int expected, int actual)
public void AreNotEqual(int expected, int actual, string message)
public void AreEqual(UInt32 expected, UInt32 actual)
public void AreEqual(UInt32 expected, UInt32 actual, string message)
public void AreNotEqual(UInt32 expected, UInt32 actual)
public void AreNotEqual(UInt32 expected, UInt32 actual, string message)
public void AreEqual(long expected, long actual)
public void AreEqual(long expected, long actual, string message)
public void AreNotEqual(long expected, long actual)
public void AreNotEqual(long expected, long actual, string message)
public void AreEqual(ulong expected, ulong actual)
public void AreEqual(ulong expected, ulong actual, string message)
public void AreNotEqual(ulong expected, ulong actual)
public void AreNotEqual(ulong expected, ulong actual, string message)
}
public UnityEngine.Assertions.AssertionException : Exception {
private string m_UserMessage
public string Message
public void .ctor(string message, string userMessage)
public string get_Message()
}
internal UnityEngine.Assertions.AssertionMessageUtil : object {
private string k_Expected
private string k_AssertionFailed
public string GetMessage(string failureMessage)
public string GetMessage(string failureMessage, string expected)
public string GetEqualityMessage(object actual, object expected, bool expectEqual)
public string NullFailureMessage(object value, bool expectNull)
public string BooleanFailureMessage(bool expected)
}
public UnityEngine.Assertions.Comparers.FloatComparer : object {
private float m_Error
private bool m_Relative
public FloatComparer s_ComparerWithDefaultTolerance
public float kEpsilon
public void .ctor(bool relative)
public void .ctor(float error)
public void .ctor(float error, bool relative)
public bool Equals(float a, float b)
public int GetHashCode(float obj)
public bool AreEqual(float expected, float actual, float error)
public bool AreEqualRelative(float expected, float actual, float error)
}
public UnityEngine.Assertions.Must.MustExtensions : object {
public void MustBeTrue(bool value)
public void MustBeTrue(bool value, string message)
public void MustBeFalse(bool value)
public void MustBeFalse(bool value, string message)
public void MustBeApproximatelyEqual(float actual, float expected)
public void MustBeApproximatelyEqual(float actual, float expected, string message)
public void MustBeApproximatelyEqual(float actual, float expected, float tolerance)
public void MustBeApproximatelyEqual(float actual, float expected, float tolerance, string message)
public void MustNotBeApproximatelyEqual(float actual, float expected)
public void MustNotBeApproximatelyEqual(float actual, float expected, string message)
public void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance)
public void MustNotBeApproximatelyEqual(float actual, float expected, float tolerance, string message)
public void MustBeEqual(T actual, T expected)
public void MustBeEqual(T actual, T expected, string message)
public void MustNotBeEqual(T actual, T expected)
public void MustNotBeEqual(T actual, T expected, string message)
public void MustBeNull(T expected)
public void MustBeNull(T expected, string message)
public void MustNotBeNull(T expected)
public void MustNotBeNull(T expected, string message)
}
public UnityEngine.AsyncOperation : YieldInstruction {
internal IntPtr m_Ptr
private Action`1<AsyncOperation> m_completeCallback
public bool isDone
public float progress
public int priority
public bool allowSceneActivation
private void InternalDestroy(IntPtr ptr)
public bool get_isDone()
public float get_progress()
public int get_priority()
public void set_priority(int value)
public bool get_allowSceneActivation()
public void set_allowSceneActivation(bool value)
protected void Finalize()
internal void InvokeCompletionEvent()
public void add_completed(Action`1<AsyncOperation> value)
public void remove_completed(Action`1<AsyncOperation> value)
}
internal UnityEngine.AttributeHelperEngine : object {
private Type GetParentTypeDisallowingMultipleInclusion(Type type)
private Type[] GetRequiredComponents(Type klass)
private int GetExecuteMode(Type klass)
private int CheckIsEditorScript(Type klass)
private int GetDefaultExecutionOrderFor(Type klass)
private T GetCustomAttributeOfType(Type klass)
}
public UnityEngine.AudioType : Enum {
public int value__
public AudioType UNKNOWN
public AudioType ACC
public AudioType AIFF
public AudioType IT
public AudioType MOD
public AudioType MPEG
public AudioType OGGVORBIS
public AudioType S3M
public AudioType WAV
public AudioType XM
public AudioType XMA
public AudioType VAG
public AudioType AUDIOQUEUE
}
public UnityEngine.BatteryStatus : Enum {
public int value__
public BatteryStatus Unknown
public BatteryStatus Charging
public BatteryStatus Discharging
public BatteryStatus NotCharging
public BatteryStatus Full
}
internal UnityEngine.BeforeRenderHelper : object {
private List`1<OrderBlock> s_OrderBlocks
private int GetUpdateOrder(UnityAction callback)
public void RegisterCallback(UnityAction callback)
public void UnregisterCallback(UnityAction callback)
public void Invoke()
}
public UnityEngine.BeforeRenderOrderAttribute : Attribute {
private int <order>k__BackingField
public int order
public int get_order()
private void set_order(int value)
public void .ctor(int order)
}
public UnityEngine.Behaviour : Component {
public bool enabled
public bool isActiveAndEnabled
public bool get_enabled()
public void set_enabled(bool value)
public bool get_isActiveAndEnabled()
}
public UnityEngine.BillboardAsset : Object {
public float width
public float height
public float bottom
public int imageCount
public int vertexCount
public int indexCount
public Material material
private void Internal_Create(BillboardAsset obj)
public float get_width()
public void set_width(float value)
public float get_height()
public void set_height(float value)
public float get_bottom()
public void set_bottom(float value)
public int get_imageCount()
public int get_vertexCount()
public int get_indexCount()
public Material get_material()
public void set_material(Material value)
public void GetImageTexCoords(List`1<Vector4> imageTexCoords)
public Vector4[] GetImageTexCoords()
internal void GetImageTexCoordsInternal(object list)
public void SetImageTexCoords(List`1<Vector4> imageTexCoords)
public void SetImageTexCoords(Vector4[] imageTexCoords)
internal void SetImageTexCoordsInternalList(object list)
public void GetVertices(List`1<Vector2> vertices)
public Vector2[] GetVertices()
internal void GetVerticesInternal(object list)
public void SetVertices(List`1<Vector2> vertices)
public void SetVertices(Vector2[] vertices)
internal void SetVerticesInternalList(object list)
public void GetIndices(List`1<ushort> indices)
public UInt16[] GetIndices()
internal void GetIndicesInternal(object list)
public void SetIndices(List`1<ushort> indices)
public void SetIndices(UInt16[] indices)
internal void SetIndicesInternalList(object list)
internal void MakeMaterialProperties(MaterialPropertyBlock properties, Camera camera)
}
public UnityEngine.BillboardRenderer : Renderer {
public BillboardAsset billboard
public BillboardAsset get_billboard()
public void set_billboard(BillboardAsset value)
}
public UnityEngine.BlendWeights : Enum {
public int value__
public BlendWeights OneBone
public BlendWeights TwoBones
public BlendWeights FourBones
}
public UnityEngine.BoneWeight : ValueType {
private float m_Weight0
private float m_Weight1
private float m_Weight2
private float m_Weight3
private int m_BoneIndex0
private int m_BoneIndex1
private int m_BoneIndex2
private int m_BoneIndex3
public float weight0
public float weight1
public float weight2
public float weight3
public int boneIndex0
public int boneIndex1
public int boneIndex2
public int boneIndex3
public float get_weight0()
public void set_weight0(float value)
public float get_weight1()
public void set_weight1(float value)
public float get_weight2()
public void set_weight2(float value)
public float get_weight3()
public void set_weight3(float value)
public int get_boneIndex0()
public void set_boneIndex0(int value)
public int get_boneIndex1()
public void set_boneIndex1(int value)
public int get_boneIndex2()
public void set_boneIndex2(int value)
public int get_boneIndex3()
public void set_boneIndex3(int value)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(BoneWeight other)
public bool op_Equality(BoneWeight lhs, BoneWeight rhs)
public bool op_Inequality(BoneWeight lhs, BoneWeight rhs)
}
public UnityEngine.BoneWeight1 : ValueType {
private float m_Weight
private int m_BoneIndex
public float weight
public int boneIndex
public float get_weight()
public void set_weight(float value)
public int get_boneIndex()
public void set_boneIndex(int value)
public bool Equals(object other)
public bool Equals(BoneWeight1 other)
public int GetHashCode()
public bool op_Equality(BoneWeight1 lhs, BoneWeight1 rhs)
public bool op_Inequality(BoneWeight1 lhs, BoneWeight1 rhs)
}
internal UnityEngine.BootConfigData : object {
private IntPtr m_Ptr
public void AddKey(string key)
public string Get(string key)
public string Get(string key, int index)
public void Append(string key, string value)
public void Set(string key, string value)
private string GetValue(string key, int index)
private BootConfigData WrapBootConfigData(IntPtr nativeHandle)
private void .ctor(IntPtr nativeHandle)
}
public UnityEngine.BoundingSphere : ValueType {
public Vector3 position
public float radius
public void .ctor(Vector3 pos, float rad)
public void .ctor(Vector4 packedSphere)
}
public UnityEngine.Bounds : ValueType {
private Vector3 m_Center
private Vector3 m_Extents
public Vector3 center
public Vector3 size
public Vector3 extents
public Vector3 min
public Vector3 max
public void .ctor(Vector3 center, Vector3 size)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Bounds other)
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_size()
public void set_size(Vector3 value)
public Vector3 get_extents()
public void set_extents(Vector3 value)
public Vector3 get_min()
public void set_min(Vector3 value)
public Vector3 get_max()
public void set_max(Vector3 value)
public bool op_Equality(Bounds lhs, Bounds rhs)
public bool op_Inequality(Bounds lhs, Bounds rhs)
public void SetMinMax(Vector3 min, Vector3 max)
public void Encapsulate(Vector3 point)
public void Encapsulate(Bounds bounds)
public void Expand(float amount)
public void Expand(Vector3 amount)
public bool Intersects(Bounds bounds)
public bool IntersectRay(Ray ray)
public bool IntersectRay(Ray ray, Single& distance)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public bool Contains(Vector3 point)
public float SqrDistance(Vector3 point)
private bool IntersectRayAABB(Ray ray, Bounds bounds, Single& dist)
public Vector3 ClosestPoint(Vector3 point)
private bool Contains_Injected(Bounds& _unity_self, Vector3& point)
private float SqrDistance_Injected(Bounds& _unity_self, Vector3& point)
private bool IntersectRayAABB_Injected(Ray& ray, Bounds& bounds, Single& dist)
private void ClosestPoint_Injected(Bounds& _unity_self, Vector3& point, Vector3& ret)
}
public UnityEngine.BoundsInt : ValueType {
private Vector3Int m_Position
private Vector3Int m_Size
public int x
public int y
public int z
public Vector3 center
public Vector3Int min
public Vector3Int max
public int xMin
public int yMin
public int zMin
public int xMax
public int yMax
public int zMax
public Vector3Int position
public Vector3Int size
public PositionEnumerator allPositionsWithin
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public int get_z()
public void set_z(int value)
public Vector3 get_center()
public Vector3Int get_min()
public void set_min(Vector3Int value)
public Vector3Int get_max()
public void set_max(Vector3Int value)
public int get_xMin()
public void set_xMin(int value)
public int get_yMin()
public void set_yMin(int value)
public int get_zMin()
public void set_zMin(int value)
public int get_xMax()
public void set_xMax(int value)
public int get_yMax()
public void set_yMax(int value)
public int get_zMax()
public void set_zMax(int value)
public Vector3Int get_position()
public void set_position(Vector3Int value)
public Vector3Int get_size()
public void set_size(Vector3Int value)
public void .ctor(int xMin, int yMin, int zMin, int sizeX, int sizeY, int sizeZ)
public void .ctor(Vector3Int position, Vector3Int size)
public void SetMinMax(Vector3Int minPosition, Vector3Int maxPosition)
public void ClampToBounds(BoundsInt bounds)
public bool Contains(Vector3Int position)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public bool op_Equality(BoundsInt lhs, BoundsInt rhs)
public bool op_Inequality(BoundsInt lhs, BoundsInt rhs)
public bool Equals(object other)
public bool Equals(BoundsInt other)
public int GetHashCode()
public PositionEnumerator get_allPositionsWithin()
}
public UnityEngine.Cache : ValueType {
private int m_Handle
internal int handle
public bool valid
public bool ready
public bool readOnly
public string path
public int index
public long spaceFree
public long maximumAvailableStorageSpace
public long spaceOccupied
public int expirationDelay
internal int get_handle()
public bool op_Equality(Cache lhs, Cache rhs)
public bool op_Inequality(Cache lhs, Cache rhs)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Cache other)
public bool get_valid()
internal bool Cache_IsValid(int handle)
public bool get_ready()
internal bool Cache_IsReady(int handle)
public bool get_readOnly()
internal bool Cache_IsReadonly(int handle)
public string get_path()
internal string Cache_GetPath(int handle)
public int get_index()
internal int Cache_GetIndex(int handle)
public long get_spaceFree()
internal long Cache_GetSpaceFree(int handle)
public long get_maximumAvailableStorageSpace()
public void set_maximumAvailableStorageSpace(long value)
internal long Cache_GetMaximumDiskSpaceAvailable(int handle)
internal void Cache_SetMaximumDiskSpaceAvailable(int handle, long value)
public long get_spaceOccupied()
internal long Cache_GetCachingDiskSpaceUsed(int handle)
public int get_expirationDelay()
public void set_expirationDelay(int value)
internal int Cache_GetExpirationDelay(int handle)
internal void Cache_SetExpirationDelay(int handle, int value)
public bool ClearCache()
internal bool Cache_ClearCache(int handle)
public bool ClearCache(int expiration)
internal bool Cache_ClearCache_Expiration(int handle, int expiration)
}
public UnityEngine.CachedAssetBundle : ValueType {
private string m_Name
private Hash128 m_Hash
public string name
public Hash128 hash
public void .ctor(string name, Hash128 hash)
public string get_name()
public void set_name(string value)
public Hash128 get_hash()
public void set_hash(Hash128 value)
}
public UnityEngine.CacheIndex : ValueType {
public string name
public int bytesUsed
public int expires
}
public UnityEngine.Caching : object {
public bool compressionEnabled
public bool ready
public int spaceUsed
public long spaceOccupied
public int spaceAvailable
public long spaceFree
public long maximumAvailableDiskSpace
public int expirationDelay
public int cacheCount
public Cache defaultCache
public Cache currentCacheForWriting
public bool get_compressionEnabled()
public void set_compressionEnabled(bool value)
public bool get_ready()
public bool ClearCache()
public bool ClearCache(int expiration)
internal bool ClearCache_Int(int expiration)
public bool ClearCachedVersion(string assetBundleName, Hash128 hash)
internal bool ClearCachedVersionInternal(string assetBundleName, Hash128 hash)
public bool ClearOtherCachedVersions(string assetBundleName, Hash128 hash)
public bool ClearAllCachedVersions(string assetBundleName)
internal bool ClearCachedVersions(string assetBundleName, Hash128 hash, bool keepInputVersion)
internal Hash128[] GetCachedVersions(string assetBundleName)
public void GetCachedVersions(string assetBundleName, List`1<Hash128> outCachedVersions)
public bool IsVersionCached(string url, int version)
public bool IsVersionCached(string url, Hash128 hash)
public bool IsVersionCached(CachedAssetBundle cachedBundle)
internal bool IsVersionCached(string url, string assetBundleName, Hash128 hash)
public bool MarkAsUsed(string url, int version)
public bool MarkAsUsed(string url, Hash128 hash)
public bool MarkAsUsed(CachedAssetBundle cachedBundle)
internal bool MarkAsUsed(string url, string assetBundleName, Hash128 hash)
public int GetVersionFromCache(string url)
public int get_spaceUsed()
public long get_spaceOccupied()
public int get_spaceAvailable()
public long get_spaceFree()
public long get_maximumAvailableDiskSpace()
public void set_maximumAvailableDiskSpace(long value)
public int get_expirationDelay()
public void set_expirationDelay(int value)
public Cache AddCache(string cachePath)
internal Cache AddCache(string cachePath, bool isReadonly)
public Cache GetCacheAt(int cacheIndex)
public Cache GetCacheByPath(string cachePath)
public void GetAllCachePaths(List`1<string> cachePaths)
public bool RemoveCache(Cache cache)
public void MoveCacheBefore(Cache src, Cache dst)
public void MoveCacheAfter(Cache src, Cache dst)
public int get_cacheCount()
public Cache get_defaultCache()
public Cache get_currentCacheForWriting()
public void set_currentCacheForWriting(Cache value)
public bool CleanCache()
private bool ClearCachedVersionInternal_Injected(string assetBundleName, Hash128& hash)
private bool ClearCachedVersions_Injected(string assetBundleName, Hash128& hash, bool keepInputVersion)
private bool IsVersionCached_Injected(string url, string assetBundleName, Hash128& hash)
private bool MarkAsUsed_Injected(string url, string assetBundleName, Hash128& hash)
private void AddCache_Injected(string cachePath, bool isReadonly, Cache& ret)
private void GetCacheAt_Injected(int cacheIndex, Cache& ret)
private void GetCacheByPath_Injected(string cachePath, Cache& ret)
private bool RemoveCache_Injected(Cache& cache)
private void MoveCacheBefore_Injected(Cache& src, Cache& dst)
private void MoveCacheAfter_Injected(Cache& src, Cache& dst)
private void get_defaultCache_Injected(Cache& ret)
private void get_currentCacheForWriting_Injected(Cache& ret)
private void set_currentCacheForWriting_Injected(Cache& value)
}
public UnityEngine.Camera : Behaviour {
public CameraCallback onPreCull
public CameraCallback onPreRender
public CameraCallback onPostRender
public float nearClipPlane
public float farClipPlane
public float fieldOfView
public RenderingPath renderingPath
public RenderingPath actualRenderingPath
public bool allowHDR
public bool allowMSAA
public bool allowDynamicResolution
public bool forceIntoRenderTexture
public float orthographicSize
public bool orthographic
public OpaqueSortMode opaqueSortMode
public TransparencySortMode transparencySortMode
public Vector3 transparencySortAxis
public float depth
public float aspect
public Vector3 velocity
public int cullingMask
public int eventMask
public bool layerCullSpherical
public CameraType cameraType
internal Material skyboxMaterial
public ulong overrideSceneCullingMask
internal ulong sceneCullingMask
public Single[] layerCullDistances
internal int PreviewCullingLayer
public bool useOcclusionCulling
public Matrix4x4 cullingMatrix
public Color backgroundColor
public CameraClearFlags clearFlags
public DepthTextureMode depthTextureMode
public bool clearStencilAfterLightingPass
internal ProjectionMatrixMode projectionMatrixMode
public bool usePhysicalProperties
public Vector2 sensorSize
public Vector2 lensShift
public float focalLength
public GateFitMode gateFit
public Rect rect
public Rect pixelRect
public int pixelWidth
public int pixelHeight
public int scaledPixelWidth
public int scaledPixelHeight
public RenderTexture targetTexture
public RenderTexture activeTexture
public int targetDisplay
public Matrix4x4 cameraToWorldMatrix
public Matrix4x4 worldToCameraMatrix
public Matrix4x4 projectionMatrix
public Matrix4x4 nonJitteredProjectionMatrix
public bool useJitteredProjectionMatrixForTransparentRendering
public Matrix4x4 previousViewProjectionMatrix
public Camera main
public Camera current
public Scene scene
public bool stereoEnabled
public float stereoSeparation
public float stereoConvergence
public bool areVRStereoViewMatricesWithinSingleCullTolerance
public StereoTargetEyeMask stereoTargetEye
public MonoOrStereoscopicEye stereoActiveEye
public int allCamerasCount
public Camera[] allCameras
public SceneViewFilterMode sceneViewFilterMode
public int commandBufferCount
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public RenderingPath get_renderingPath()
public void set_renderingPath(RenderingPath value)
public RenderingPath get_actualRenderingPath()
public void Reset()
public bool get_allowHDR()
public void set_allowHDR(bool value)
public bool get_allowMSAA()
public void set_allowMSAA(bool value)
public bool get_allowDynamicResolution()
public void set_allowDynamicResolution(bool value)
public bool get_forceIntoRenderTexture()
public void set_forceIntoRenderTexture(bool value)
public float get_orthographicSize()
public void set_orthographicSize(float value)
public bool get_orthographic()
public void set_orthographic(bool value)
public OpaqueSortMode get_opaqueSortMode()
public void set_opaqueSortMode(OpaqueSortMode value)
public TransparencySortMode get_transparencySortMode()
public void set_transparencySortMode(TransparencySortMode value)
public Vector3 get_transparencySortAxis()
public void set_transparencySortAxis(Vector3 value)
public void ResetTransparencySortSettings()
public float get_depth()
public void set_depth(float value)
public float get_aspect()
public void set_aspect(float value)
public void ResetAspect()
public Vector3 get_velocity()
public int get_cullingMask()
public void set_cullingMask(int value)
public int get_eventMask()
public void set_eventMask(int value)
public bool get_layerCullSpherical()
public void set_layerCullSpherical(bool value)
public CameraType get_cameraType()
public void set_cameraType(CameraType value)
internal Material get_skyboxMaterial()
public ulong get_overrideSceneCullingMask()
public void set_overrideSceneCullingMask(ulong value)
internal ulong get_sceneCullingMask()
private Single[] GetLayerCullDistances()
private void SetLayerCullDistances(Single[] d)
public Single[] get_layerCullDistances()
public void set_layerCullDistances(Single[] value)
internal int get_PreviewCullingLayer()
public bool get_useOcclusionCulling()
public void set_useOcclusionCulling(bool value)
public Matrix4x4 get_cullingMatrix()
public void set_cullingMatrix(Matrix4x4 value)
public void ResetCullingMatrix()
public Color get_backgroundColor()
public void set_backgroundColor(Color value)
public CameraClearFlags get_clearFlags()
public void set_clearFlags(CameraClearFlags value)
public DepthTextureMode get_depthTextureMode()
public void set_depthTextureMode(DepthTextureMode value)
public bool get_clearStencilAfterLightingPass()
public void set_clearStencilAfterLightingPass(bool value)
public void SetReplacementShader(Shader shader, string replacementTag)
public void ResetReplacementShader()
internal ProjectionMatrixMode get_projectionMatrixMode()
public bool get_usePhysicalProperties()
public void set_usePhysicalProperties(bool value)
public Vector2 get_sensorSize()
public void set_sensorSize(Vector2 value)
public Vector2 get_lensShift()
public void set_lensShift(Vector2 value)
public float get_focalLength()
public void set_focalLength(float value)
public GateFitMode get_gateFit()
public void set_gateFit(GateFitMode value)
public float GetGateFittedFieldOfView()
public Vector2 GetGateFittedLensShift()
internal Vector3 GetLocalSpaceAim()
public Rect get_rect()
public void set_rect(Rect value)
public Rect get_pixelRect()
public void set_pixelRect(Rect value)
public int get_pixelWidth()
public int get_pixelHeight()
public int get_scaledPixelWidth()
public int get_scaledPixelHeight()
public RenderTexture get_targetTexture()
public void set_targetTexture(RenderTexture value)
public RenderTexture get_activeTexture()
public int get_targetDisplay()
public void set_targetDisplay(int value)
private void SetTargetBuffersImpl(RenderBuffer color, RenderBuffer depth)
public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer)
private void SetTargetBuffersMRTImpl(RenderBuffer[] color, RenderBuffer depth)
public void SetTargetBuffers(RenderBuffer[] colorBuffer, RenderBuffer depthBuffer)
internal String[] GetCameraBufferWarnings()
public Matrix4x4 get_cameraToWorldMatrix()
public Matrix4x4 get_worldToCameraMatrix()
public void set_worldToCameraMatrix(Matrix4x4 value)
public Matrix4x4 get_projectionMatrix()
public void set_projectionMatrix(Matrix4x4 value)
public Matrix4x4 get_nonJitteredProjectionMatrix()
public void set_nonJitteredProjectionMatrix(Matrix4x4 value)
public bool get_useJitteredProjectionMatrixForTransparentRendering()
public void set_useJitteredProjectionMatrixForTransparentRendering(bool value)
public Matrix4x4 get_previousViewProjectionMatrix()
public void ResetWorldToCameraMatrix()
public void ResetProjectionMatrix()
public Matrix4x4 CalculateObliqueMatrix(Vector4 clipPlane)
public Vector3 WorldToScreenPoint(Vector3 position, MonoOrStereoscopicEye eye)
public Vector3 WorldToViewportPoint(Vector3 position, MonoOrStereoscopicEye eye)
public Vector3 ViewportToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye)
public Vector3 ScreenToWorldPoint(Vector3 position, MonoOrStereoscopicEye eye)
public Vector3 WorldToScreenPoint(Vector3 position)
public Vector3 WorldToViewportPoint(Vector3 position)
public Vector3 ViewportToWorldPoint(Vector3 position)
public Vector3 ScreenToWorldPoint(Vector3 position)
public Vector3 ScreenToViewportPoint(Vector3 position)
public Vector3 ViewportToScreenPoint(Vector3 position)
internal Vector2 GetFrustumPlaneSizeAt(float distance)
private Ray ViewportPointToRay(Vector2 pos, MonoOrStereoscopicEye eye)
public Ray ViewportPointToRay(Vector3 pos, MonoOrStereoscopicEye eye)
public Ray ViewportPointToRay(Vector3 pos)
private Ray ScreenPointToRay(Vector2 pos, MonoOrStereoscopicEye eye)
public Ray ScreenPointToRay(Vector3 pos, MonoOrStereoscopicEye eye)
public Ray ScreenPointToRay(Vector3 pos)
private void CalculateFrustumCornersInternal(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
public void CalculateFrustumCorners(Rect viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
private void CalculateProjectionMatrixFromPhysicalPropertiesInternal(Matrix4x4& output, float focalLength, Vector2 sensorSize, Vector2 lensShift, float nearClip, float farClip, float gateAspect, GateFitMode gateFitMode)
public void CalculateProjectionMatrixFromPhysicalProperties(Matrix4x4& output, float focalLength, Vector2 sensorSize, Vector2 lensShift, float nearClip, float farClip, GateFitParameters gateFitParameters)
public float FocalLengthToFieldOfView(float focalLength, float sensorSize)
public float FieldOfViewToFocalLength(float fieldOfView, float sensorSize)
public float HorizontalToVerticalFieldOfView(float horizontalFieldOfView, float aspectRatio)
public float VerticalToHorizontalFieldOfView(float verticalFieldOfView, float aspectRatio)
public Camera get_main()
public Camera get_current()
public Scene get_scene()
public void set_scene(Scene value)
public bool get_stereoEnabled()
public float get_stereoSeparation()
public void set_stereoSeparation(float value)
public float get_stereoConvergence()
public void set_stereoConvergence(float value)
public bool get_areVRStereoViewMatricesWithinSingleCullTolerance()
public StereoTargetEyeMask get_stereoTargetEye()
public void set_stereoTargetEye(StereoTargetEyeMask value)
public MonoOrStereoscopicEye get_stereoActiveEye()
public Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye eye)
public Matrix4x4 GetStereoViewMatrix(StereoscopicEye eye)
public void CopyStereoDeviceProjectionMatrixToNonJittered(StereoscopicEye eye)
public Matrix4x4 GetStereoProjectionMatrix(StereoscopicEye eye)
public void SetStereoProjectionMatrix(StereoscopicEye eye, Matrix4x4 matrix)
public void ResetStereoProjectionMatrices()
public void SetStereoViewMatrix(StereoscopicEye eye, Matrix4x4 matrix)
public void ResetStereoViewMatrices()
private int GetAllCamerasCount()
private int GetAllCamerasImpl(Camera[] cam)
public int get_allCamerasCount()
public Camera[] get_allCameras()
public int GetAllCameras(Camera[] cameras)
private bool RenderToCubemapImpl(Texture tex, int faceMask)
public bool RenderToCubemap(Cubemap cubemap, int faceMask)
public bool RenderToCubemap(Cubemap cubemap)
public bool RenderToCubemap(RenderTexture cubemap, int faceMask)
public bool RenderToCubemap(RenderTexture cubemap)
private int GetFilterMode()
public SceneViewFilterMode get_sceneViewFilterMode()
private bool RenderToCubemapEyeImpl(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye)
public bool RenderToCubemap(RenderTexture cubemap, int faceMask, MonoOrStereoscopicEye stereoEye)
public void Render()
public void RenderWithShader(Shader shader, string replacementTag)
public void RenderDontRestore()
public void SubmitRenderRequests(List`1<RenderRequest> renderRequests)
private void SubmitRenderRequestsInternal(object requests)
public void SetupCurrent(Camera cur)
public void CopyFrom(Camera other)
public int get_commandBufferCount()
public void RemoveCommandBuffers(CameraEvent evt)
public void RemoveAllCommandBuffers()
private void AddCommandBufferImpl(CameraEvent evt, CommandBuffer buffer)
private void AddCommandBufferAsyncImpl(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
private void RemoveCommandBufferImpl(CameraEvent evt, CommandBuffer buffer)
public void AddCommandBuffer(CameraEvent evt, CommandBuffer buffer)
public void AddCommandBufferAsync(CameraEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
public void RemoveCommandBuffer(CameraEvent evt, CommandBuffer buffer)
public CommandBuffer[] GetCommandBuffers(CameraEvent evt)
private void FireOnPreCull(Camera cam)
private void FireOnPreRender(Camera cam)
private void FireOnPostRender(Camera cam)
internal void OnlyUsedForTesting1()
internal void OnlyUsedForTesting2()
public bool TryGetCullingParameters(ScriptableCullingParameters& cullingParameters)
public bool TryGetCullingParameters(bool stereoAware, ScriptableCullingParameters& cullingParameters)
private bool GetCullingParameters_Internal(Camera camera, bool stereoAware, ScriptableCullingParameters& cullingParameters, int managedCullingParametersSize)
private void get_transparencySortAxis_Injected(Vector3& ret)
private void set_transparencySortAxis_Injected(Vector3& value)
private void get_velocity_Injected(Vector3& ret)
private void get_cullingMatrix_Injected(Matrix4x4& ret)
private void set_cullingMatrix_Injected(Matrix4x4& value)
private void get_backgroundColor_Injected(Color& ret)
private void set_backgroundColor_Injected(Color& value)
private void get_sensorSize_Injected(Vector2& ret)
private void set_sensorSize_Injected(Vector2& value)
private void get_lensShift_Injected(Vector2& ret)
private void set_lensShift_Injected(Vector2& value)
private void GetGateFittedLensShift_Injected(Vector2& ret)
private void GetLocalSpaceAim_Injected(Vector3& ret)
private void get_rect_Injected(Rect& ret)
private void set_rect_Injected(Rect& value)
private void get_pixelRect_Injected(Rect& ret)
private void set_pixelRect_Injected(Rect& value)
private void SetTargetBuffersImpl_Injected(RenderBuffer& color, RenderBuffer& depth)
private void SetTargetBuffersMRTImpl_Injected(RenderBuffer[] color, RenderBuffer& depth)
private void get_cameraToWorldMatrix_Injected(Matrix4x4& ret)
private void get_worldToCameraMatrix_Injected(Matrix4x4& ret)
private void set_worldToCameraMatrix_Injected(Matrix4x4& value)
private void get_projectionMatrix_Injected(Matrix4x4& ret)
private void set_projectionMatrix_Injected(Matrix4x4& value)
private void get_nonJitteredProjectionMatrix_Injected(Matrix4x4& ret)
private void set_nonJitteredProjectionMatrix_Injected(Matrix4x4& value)
private void get_previousViewProjectionMatrix_Injected(Matrix4x4& ret)
private void CalculateObliqueMatrix_Injected(Vector4& clipPlane, Matrix4x4& ret)
private void WorldToScreenPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret)
private void WorldToViewportPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret)
private void ViewportToWorldPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret)
private void ScreenToWorldPoint_Injected(Vector3& position, MonoOrStereoscopicEye eye, Vector3& ret)
private void ScreenToViewportPoint_Injected(Vector3& position, Vector3& ret)
private void ViewportToScreenPoint_Injected(Vector3& position, Vector3& ret)
private void GetFrustumPlaneSizeAt_Injected(float distance, Vector2& ret)
private void ViewportPointToRay_Injected(Vector2& pos, MonoOrStereoscopicEye eye, Ray& ret)
private void ScreenPointToRay_Injected(Vector2& pos, MonoOrStereoscopicEye eye, Ray& ret)
private void CalculateFrustumCornersInternal_Injected(Rect& viewport, float z, MonoOrStereoscopicEye eye, Vector3[] outCorners)
private void CalculateProjectionMatrixFromPhysicalPropertiesInternal_Injected(Matrix4x4& output, float focalLength, Vector2& sensorSize, Vector2& lensShift, float nearClip, float farClip, float gateAspect, GateFitMode gateFitMode)
private void get_scene_Injected(Scene& ret)
private void set_scene_Injected(Scene& value)
private void GetStereoNonJitteredProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void GetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void GetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& ret)
private void SetStereoProjectionMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix)
private void SetStereoViewMatrix_Injected(StereoscopicEye eye, Matrix4x4& matrix)
}
public UnityEngine.CameraClearFlags : Enum {
public int value__
public CameraClearFlags Skybox
public CameraClearFlags Color
public CameraClearFlags SolidColor
public CameraClearFlags Depth
public CameraClearFlags Nothing
}
public UnityEngine.CameraType : Enum {
public int value__
public CameraType Game
public CameraType SceneView
public CameraType Preview
public CameraType VR
public CameraType Reflection
}
internal UnityEngine.CastHelper`1 : ValueType {
public T t
public IntPtr onePointerFurtherThanT
}
internal UnityEngine.ClassLibraryInitializer : object {
private void Init()
}
public UnityEngine.Color : ValueType {
public float r
public float g
public float b
public float a
public Color red
public Color green
public Color blue
public Color white
public Color black
public Color yellow
public Color cyan
public Color magenta
public Color gray
public Color grey
public Color clear
public float grayscale
public Color linear
public Color gamma
public float maxColorComponent
public float Item
public void .ctor(float r, float g, float b, float a)
public void .ctor(float r, float g, float b)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Color other)
public Color op_Addition(Color a, Color b)
public Color op_Subtraction(Color a, Color b)
public Color op_Multiply(Color a, Color b)
public Color op_Multiply(Color a, float b)
public Color op_Multiply(float b, Color a)
public Color op_Division(Color a, float b)
public bool op_Equality(Color lhs, Color rhs)
public bool op_Inequality(Color lhs, Color rhs)
public Color Lerp(Color a, Color b, float t)
public Color LerpUnclamped(Color a, Color b, float t)
internal Color RGBMultiplied(float multiplier)
internal Color AlphaMultiplied(float multiplier)
internal Color RGBMultiplied(Color multiplier)
public Color get_red()
public Color get_green()
public Color get_blue()
public Color get_white()
public Color get_black()
public Color get_yellow()
public Color get_cyan()
public Color get_magenta()
public Color get_gray()
public Color get_grey()
public Color get_clear()
public float get_grayscale()
public Color get_linear()
public Color get_gamma()
public float get_maxColorComponent()
public Vector4 op_Implicit(Color c)
public Color op_Implicit(Vector4 v)
public float get_Item(int index)
public void set_Item(int index, float value)
public void RGBToHSV(Color rgbColor, Single& H, Single& S, Single& V)
private void RGBToHSVHelper(float offset, float dominantcolor, float colorone, float colortwo, Single& H, Single& S, Single& V)
public Color HSVToRGB(float H, float S, float V)
public Color HSVToRGB(float H, float S, float V, bool hdr)
}
public UnityEngine.Color32 : ValueType {
private int rgba
public byte r
public byte g
public byte b
public byte a
public byte Item
public void .ctor(byte r, byte g, byte b, byte a)
public Color32 op_Implicit(Color c)
public Color op_Implicit(Color32 c)
public Color32 Lerp(Color32 a, Color32 b, float t)
public Color32 LerpUnclamped(Color32 a, Color32 b, float t)
public byte get_Item(int index)
public void set_Item(int index, byte value)
internal bool InternalEquals(Color32 other)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
}
public UnityEngine.ColorGamut : Enum {
public int value__
public ColorGamut sRGB
public ColorGamut Rec709
public ColorGamut Rec2020
public ColorGamut DisplayP3
public ColorGamut HDR10
public ColorGamut DolbyHDR
}
public UnityEngine.ColorSpace : Enum {
public int value__
public ColorSpace Uninitialized
public ColorSpace Gamma
public ColorSpace Linear
}
public UnityEngine.ColorUsageAttribute : PropertyAttribute {
public bool showAlpha
public bool hdr
public float minBrightness
public float maxBrightness
public float minExposureValue
public float maxExposureValue
public void .ctor(bool showAlpha)
public void .ctor(bool showAlpha, bool hdr)
public void .ctor(bool showAlpha, bool hdr, float minBrightness, float maxBrightness, float minExposureValue, float maxExposureValue)
}
public UnityEngine.ColorUtility : object {
internal bool DoTryParseHtmlColor(string htmlString, Color32& color)
public bool TryParseHtmlString(string htmlString, Color& color)
public string ToHtmlStringRGB(Color color)
public string ToHtmlStringRGBA(Color color)
}
public UnityEngine.CombineInstance : ValueType {
private int m_MeshInstanceID
private int m_SubMeshIndex
private Matrix4x4 m_Transform
private Vector4 m_LightmapScaleOffset
private Vector4 m_RealtimeLightmapScaleOffset
public Mesh mesh
public int subMeshIndex
public Matrix4x4 transform
public Vector4 lightmapScaleOffset
public Vector4 realtimeLightmapScaleOffset
public Mesh get_mesh()
public void set_mesh(Mesh value)
public int get_subMeshIndex()
public void set_subMeshIndex(int value)
public Matrix4x4 get_transform()
public void set_transform(Matrix4x4 value)
public Vector4 get_lightmapScaleOffset()
public void set_lightmapScaleOffset(Vector4 value)
public Vector4 get_realtimeLightmapScaleOffset()
public void set_realtimeLightmapScaleOffset(Vector4 value)
}
public UnityEngine.Component : Object {
public Transform transform
public GameObject gameObject
public string tag
public Transform get_transform()
public GameObject get_gameObject()
public Component GetComponent(Type type)
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue)
public T GetComponent()
public bool TryGetComponent(Type type, Component& component)
public bool TryGetComponent(T& component)
public Component GetComponent(string type)
public Component GetComponentInChildren(Type t, bool includeInactive)
public Component GetComponentInChildren(Type t)
public T GetComponentInChildren(bool includeInactive)
public T GetComponentInChildren()
public Component[] GetComponentsInChildren(Type t, bool includeInactive)
public Component[] GetComponentsInChildren(Type t)
public T[] GetComponentsInChildren(bool includeInactive)
public void GetComponentsInChildren(bool includeInactive, List`1<T> result)
public T[] GetComponentsInChildren()
public void GetComponentsInChildren(List`1<T> results)
public Component GetComponentInParent(Type t, bool includeInactive)
public Component GetComponentInParent(Type t)
public T GetComponentInParent(bool includeInactive)
public T GetComponentInParent()
public Component[] GetComponentsInParent(Type t, bool includeInactive)
public Component[] GetComponentsInParent(Type t)
public T[] GetComponentsInParent(bool includeInactive)
public void GetComponentsInParent(bool includeInactive, List`1<T> results)
public T[] GetComponentsInParent()
public Component[] GetComponents(Type type)
private void GetComponentsForListInternal(Type searchType, object resultList)
public void GetComponents(Type type, List`1<Component> results)
public void GetComponents(List`1<T> results)
public string get_tag()
public void set_tag(string value)
public T[] GetComponents()
public bool CompareTag(string tag)
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options)
public void SendMessageUpwards(string methodName, object value)
public void SendMessageUpwards(string methodName)
public void SendMessageUpwards(string methodName, SendMessageOptions options)
public void SendMessage(string methodName, object value)
public void SendMessage(string methodName)
public void SendMessage(string methodName, object value, SendMessageOptions options)
public void SendMessage(string methodName, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter)
public void BroadcastMessage(string methodName)
public void BroadcastMessage(string methodName, SendMessageOptions options)
}
public UnityEngine.ComputeBuffer : object {
internal IntPtr m_Ptr
public int count
public int stride
private ComputeBufferMode usage
public string name
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
private IntPtr InitBuffer(int count, int stride, ComputeBufferType type, ComputeBufferMode usage)
private void DestroyBuffer(ComputeBuffer buf)
public void .ctor(int count, int stride)
public void .ctor(int count, int stride, ComputeBufferType type)
public void .ctor(int count, int stride, ComputeBufferType type, ComputeBufferMode usage)
private void .ctor(int count, int stride, ComputeBufferType type, ComputeBufferMode usage, int stackDepth)
public void Release()
private bool IsValidBuffer(ComputeBuffer buf)
public bool IsValid()
public int get_count()
public int get_stride()
private ComputeBufferMode get_usage()
public void SetData(Array data)
public void SetData(List`1<T> data)
public void SetData(NativeArray`1<T> data)
public void SetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
public void SetData(List`1<T> data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
public void SetData(NativeArray`1<T> data, int nativeBufferStartIndex, int computeBufferStartIndex, int count)
private void InternalSetNativeData(IntPtr data, int nativeBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
private void InternalSetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
public void GetData(Array data)
public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
private void InternalGetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
private Void* BeginBufferWrite(int offset, int size)
public NativeArray`1<T> BeginWrite(int computeBufferStartIndex, int count)
private void EndBufferWrite(int bytesWritten)
public void EndWrite(int countWritten)
public void set_name(string value)
private void SetName(string name)
public void SetCounterValue(UInt32 counterValue)
public void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes)
public IntPtr GetNativeBufferPtr()
}
public UnityEngine.ComputeBufferMode : Enum {
public int value__
public ComputeBufferMode Immutable
public ComputeBufferMode Dynamic
public ComputeBufferMode Circular
public ComputeBufferMode StreamOut
public ComputeBufferMode SubUpdates
}
public UnityEngine.ComputeBufferType : Enum {
public int value__
public ComputeBufferType Default
public ComputeBufferType Raw
public ComputeBufferType Append
public ComputeBufferType Counter
public ComputeBufferType Constant
public ComputeBufferType Structured
public ComputeBufferType DrawIndirect
public ComputeBufferType IndirectArguments
public ComputeBufferType GPUMemory
}
public UnityEngine.ComputeShader : Object {
public LocalKeywordSpace keywordSpace
public String[] shaderKeywords
public LocalKeyword[] enabledKeywords
public int FindKernel(string name)
public bool HasKernel(string name)
public void SetFloat(int nameID, float val)
public void SetInt(int nameID, int val)
public void SetVector(int nameID, Vector4 val)
public void SetMatrix(int nameID, Matrix4x4 val)
private void SetFloatArray(int nameID, Single[] values)
private void SetIntArray(int nameID, Int32[] values)
public void SetVectorArray(int nameID, Vector4[] values)
public void SetMatrixArray(int nameID, Matrix4x4[] values)
public void SetTexture(int kernelIndex, int nameID, Texture texture, int mipLevel)
private void SetRenderTexture(int kernelIndex, int nameID, RenderTexture texture, int mipLevel, RenderTextureSubElement element)
public void SetTextureFromGlobal(int kernelIndex, int nameID, int globalTextureNameID)
private void Internal_SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer)
private void Internal_SetGraphicsBuffer(int kernelIndex, int nameID, GraphicsBuffer buffer)
public void SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer)
public void SetBuffer(int kernelIndex, int nameID, GraphicsBuffer buffer)
private void SetConstantComputeBuffer(int nameID, ComputeBuffer buffer, int offset, int size)
private void SetConstantGraphicsBuffer(int nameID, GraphicsBuffer buffer, int offset, int size)
public void GetKernelThreadGroupSizes(int kernelIndex, UInt32& x, UInt32& y, UInt32& z)
public void Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
private void Internal_DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset)
private void Internal_DispatchIndirectGraphicsBuffer(int kernelIndex, GraphicsBuffer argsBuffer, UInt32 argsOffset)
public LocalKeywordSpace get_keywordSpace()
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
public bool IsKeywordEnabled(string keyword)
private void EnableLocalKeyword(LocalKeyword keyword)
private void DisableLocalKeyword(LocalKeyword keyword)
private void SetLocalKeyword(LocalKeyword keyword, bool value)
private bool IsLocalKeywordEnabled(LocalKeyword keyword)
public void EnableKeyword(LocalKeyword& keyword)
public void DisableKeyword(LocalKeyword& keyword)
public void SetKeyword(LocalKeyword& keyword, bool value)
public bool IsKeywordEnabled(LocalKeyword& keyword)
public bool IsSupported(int kernelIndex)
private String[] GetShaderKeywords()
private void SetShaderKeywords(String[] names)
public String[] get_shaderKeywords()
public void set_shaderKeywords(String[] value)
private LocalKeyword[] GetEnabledKeywords()
private void SetEnabledKeywords(LocalKeyword[] keywords)
public LocalKeyword[] get_enabledKeywords()
public void set_enabledKeywords(LocalKeyword[] value)
public void SetFloat(string name, float val)
public void SetInt(string name, int val)
public void SetVector(string name, Vector4 val)
public void SetMatrix(string name, Matrix4x4 val)
public void SetVectorArray(string name, Vector4[] values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetFloats(string name, Single[] values)
public void SetFloats(int nameID, Single[] values)
public void SetInts(string name, Int32[] values)
public void SetInts(int nameID, Int32[] values)
public void SetBool(string name, bool val)
public void SetBool(int nameID, bool val)
public void SetTexture(int kernelIndex, int nameID, Texture texture)
public void SetTexture(int kernelIndex, string name, Texture texture)
public void SetTexture(int kernelIndex, string name, Texture texture, int mipLevel)
public void SetTexture(int kernelIndex, int nameID, RenderTexture texture, int mipLevel, RenderTextureSubElement element)
public void SetTexture(int kernelIndex, string name, RenderTexture texture, int mipLevel, RenderTextureSubElement element)
public void SetTextureFromGlobal(int kernelIndex, string name, string globalTextureName)
public void SetBuffer(int kernelIndex, string name, ComputeBuffer buffer)
public void SetBuffer(int kernelIndex, string name, GraphicsBuffer buffer)
public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size)
public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size)
public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size)
public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size)
public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, UInt32 argsOffset)
public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer)
public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer, UInt32 argsOffset)
public void DispatchIndirect(int kernelIndex, GraphicsBuffer argsBuffer)
private void SetVector_Injected(int nameID, Vector4& val)
private void SetMatrix_Injected(int nameID, Matrix4x4& val)
private void get_keywordSpace_Injected(LocalKeywordSpace& ret)
private void EnableLocalKeyword_Injected(LocalKeyword& keyword)
private void DisableLocalKeyword_Injected(LocalKeyword& keyword)
private void SetLocalKeyword_Injected(LocalKeyword& keyword, bool value)
private bool IsLocalKeywordEnabled_Injected(LocalKeyword& keyword)
}
public UnityEngine.ContextMenu : Attribute {
public string menuItem
public bool validate
public int priority
public void .ctor(string itemName)
public void .ctor(string itemName, bool isValidateFunction)
public void .ctor(string itemName, bool isValidateFunction, int priority)
}
public UnityEngine.ContextMenuItemAttribute : PropertyAttribute {
public string name
public string function
public void .ctor(string name, string function)
}
public UnityEngine.Coroutine : YieldInstruction {
internal IntPtr m_Ptr
protected void Finalize()
private void ReleaseCoroutine(IntPtr ptr)
}
public UnityEngine.CrashReport : object {
private List`1<CrashReport> internalReports
private object reportsLock
private string id
public DateTime time
public string text
public CrashReport[] reports
public CrashReport lastReport
private int Compare(CrashReport c1, CrashReport c2)
private void PopulateReports()
public CrashReport[] get_reports()
public CrashReport get_lastReport()
public void RemoveAll()
private void .ctor(string id, DateTime time, string text)
public void Remove()
private String[] GetReports()
private string GetReportData(string id, Double& secondsSinceUnixEpoch)
private bool RemoveReport(string id)
}
public UnityEngine.CreateAssetMenuAttribute : Attribute {
private string <menuName>k__BackingField
private string <fileName>k__BackingField
private int <order>k__BackingField
public string menuName
public string fileName
public int order
public string get_menuName()
public void set_menuName(string value)
public string get_fileName()
public void set_fileName(string value)
public int get_order()
public void set_order(int value)
}
public UnityEngine.Cubemap : Texture {
public TextureFormat format
public bool isReadable
internal bool isPreProcessed
public bool streamingMipmaps
public int streamingMipmapsPriority
public int requestedMipmapLevel
internal bool loadAllMips
public int desiredMipmapLevel
public int loadingMipmapLevel
public int loadedMipmapLevel
public TextureFormat get_format()
private bool Internal_CreateImpl(Cubemap mono, int ext, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
private void Internal_Create(Cubemap mono, int ext, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public void UpdateExternalTexture(IntPtr nativeTexture)
public bool get_isReadable()
private void SetPixelImpl(int image, int mip, int x, int y, Color color)
private Color GetPixelImpl(int image, int mip, int x, int y)
public void SmoothEdges(int smoothRegionWidthInPixels)
public void SmoothEdges()
public Color[] GetPixels(CubemapFace face, int miplevel)
public Color[] GetPixels(CubemapFace face)
public void SetPixels(Color[] colors, CubemapFace face, int miplevel)
private bool SetPixelDataImplArray(Array data, int mipLevel, int face, int elementSize, int dataArraySize, int sourceDataStartIndex)
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int face, int elementSize, int dataArraySize, int sourceDataStartIndex)
public void SetPixels(Color[] colors, CubemapFace face)
private IntPtr GetWritableImageData(int frame)
internal bool get_isPreProcessed()
public bool get_streamingMipmaps()
public int get_streamingMipmapsPriority()
public int get_requestedMipmapLevel()
public void set_requestedMipmapLevel(int value)
internal bool get_loadAllMips()
internal void set_loadAllMips(bool value)
public int get_desiredMipmapLevel()
public int get_loadingMipmapLevel()
public int get_loadedMipmapLevel()
public void ClearRequestedMipmapLevel()
public bool IsRequestedMipmapLevelLoaded()
internal bool ValidateFormat(TextureFormat format, int width)
internal bool ValidateFormat(GraphicsFormat format, int width)
public void .ctor(int width, DefaultFormat format, TextureCreationFlags flags)
public void .ctor(int width, GraphicsFormat format, TextureCreationFlags flags)
public void .ctor(int width, TextureFormat format, int mipCount)
public void .ctor(int width, GraphicsFormat format, TextureCreationFlags flags, int mipCount)
internal void .ctor(int width, TextureFormat textureFormat, int mipCount, IntPtr nativeTex)
internal void .ctor(int width, TextureFormat textureFormat, bool mipChain, IntPtr nativeTex)
public void .ctor(int width, TextureFormat textureFormat, bool mipChain)
public Cubemap CreateExternalTexture(int width, TextureFormat format, bool mipmap, IntPtr nativeTex)
public void SetPixelData(T[] data, int mipLevel, CubemapFace face, int sourceDataStartIndex)
public void SetPixelData(NativeArray`1<T> data, int mipLevel, CubemapFace face, int sourceDataStartIndex)
public NativeArray`1<T> GetPixelData(int mipLevel, CubemapFace face)
public void SetPixel(CubemapFace face, int x, int y, Color color)
public void SetPixel(CubemapFace face, int x, int y, Color color, int mip)
public Color GetPixel(CubemapFace face, int x, int y)
public Color GetPixel(CubemapFace face, int x, int y, int mip)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
private void ValidateIsNotCrunched(TextureCreationFlags flags)
private void SetPixelImpl_Injected(int image, int mip, int x, int y, Color& color)
private void GetPixelImpl_Injected(int image, int mip, int x, int y, Color& ret)
}
public UnityEngine.CubemapArray : Texture {
public int cubemapCount
public TextureFormat format
public bool isReadable
public int get_cubemapCount()
public TextureFormat get_format()
public bool get_isReadable()
private bool Internal_CreateImpl(CubemapArray mono, int ext, int count, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags)
private void Internal_Create(CubemapArray mono, int ext, int count, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public Color[] GetPixels(CubemapFace face, int arrayElement, int miplevel)
public Color[] GetPixels(CubemapFace face, int arrayElement)
public Color32[] GetPixels32(CubemapFace face, int arrayElement, int miplevel)
public Color32[] GetPixels32(CubemapFace face, int arrayElement)
public void SetPixels(Color[] colors, CubemapFace face, int arrayElement, int miplevel)
public void SetPixels(Color[] colors, CubemapFace face, int arrayElement)
public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement, int miplevel)
public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement)
private bool SetPixelDataImplArray(Array data, int mipLevel, int face, int element, int elementSize, int dataArraySize, int sourceDataStartIndex)
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int face, int element, int elementSize, int dataArraySize, int sourceDataStartIndex)
private IntPtr GetImageDataPointer()
public void .ctor(int width, int cubemapCount, DefaultFormat format, TextureCreationFlags flags)
public void .ctor(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags)
public void .ctor(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags, int mipCount)
public void .ctor(int width, int cubemapCount, TextureFormat textureFormat, int mipCount, bool linear)
public void .ctor(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain, bool linear)
public void .ctor(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
public void SetPixelData(T[] data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex)
public void SetPixelData(NativeArray`1<T> data, int mipLevel, CubemapFace face, int element, int sourceDataStartIndex)
public NativeArray`1<T> GetPixelData(int mipLevel, CubemapFace face, int element)
private void ValidateIsNotCrunched(TextureCreationFlags flags)
}
public UnityEngine.CubemapFace : Enum {
public int value__
public CubemapFace Unknown
public CubemapFace PositiveX
public CubemapFace NegativeX
public CubemapFace PositiveY
public CubemapFace NegativeY
public CubemapFace PositiveZ
public CubemapFace NegativeZ
}
public UnityEngine.CullingGroup : object {
internal IntPtr m_Ptr
private StateChanged m_OnStateChanged
public StateChanged onStateChanged
public bool enabled
public Camera targetCamera
protected void Finalize()
private void DisposeInternal()
public void Dispose()
public StateChanged get_onStateChanged()
public void set_onStateChanged(StateChanged value)
public bool get_enabled()
public void set_enabled(bool value)
public Camera get_targetCamera()
public void set_targetCamera(Camera value)
public void SetBoundingSpheres(BoundingSphere[] array)
public void SetBoundingSphereCount(int count)
public void EraseSwapBack(int index)
public void EraseSwapBack(int index, T[] myArray, Int32& size)
public int QueryIndices(bool visible, Int32[] result, int firstIndex)
public int QueryIndices(int distanceIndex, Int32[] result, int firstIndex)
public int QueryIndices(bool visible, int distanceIndex, Int32[] result, int firstIndex)
private int QueryIndices(bool visible, int distanceIndex, CullingQueryOptions options, Int32[] result, int firstIndex)
public bool IsVisible(int index)
public int GetDistance(int index)
public void SetBoundingDistances(Single[] distances)
private void SetDistanceReferencePoint_InternalVector3(Vector3 point)
private void SetDistanceReferencePoint_InternalTransform(Transform transform)
public void SetDistanceReferencePoint(Vector3 point)
public void SetDistanceReferencePoint(Transform transform)
private void SendEvents(CullingGroup cullingGroup, IntPtr eventsPtr, int count)
private IntPtr Init(object scripting)
private void FinalizerFailure()
private void SetDistanceReferencePoint_InternalVector3_Injected(Vector3& point)
}
public UnityEngine.CullingGroupEvent : ValueType {
private int m_Index
private byte m_PrevState
private byte m_ThisState
private byte kIsVisibleMask
private byte kDistanceMask
public int index
public bool isVisible
public bool wasVisible
public bool hasBecomeVisible
public bool hasBecomeInvisible
public int currentDistance
public int previousDistance
public int get_index()
public bool get_isVisible()
public bool get_wasVisible()
public bool get_hasBecomeVisible()
public bool get_hasBecomeInvisible()
public int get_currentDistance()
public int get_previousDistance()
}
internal UnityEngine.CullingQueryOptions : Enum {
public int value__
public CullingQueryOptions Normal
public CullingQueryOptions IgnoreVisibility
public CullingQueryOptions IgnoreDistance
}
public UnityEngine.Cursor : object {
public bool visible
public CursorLockMode lockState
private void SetCursor(Texture2D texture, CursorMode cursorMode)
public void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode)
public bool get_visible()
public void set_visible(bool value)
public CursorLockMode get_lockState()
public void set_lockState(CursorLockMode value)
private void SetCursor_Injected(Texture2D texture, Vector2& hotspot, CursorMode cursorMode)
}
public UnityEngine.CursorLockMode : Enum {
public int value__
public CursorLockMode None
public CursorLockMode Locked
public CursorLockMode Confined
}
public UnityEngine.CursorMode : Enum {
public int value__
public CursorMode Auto
public CursorMode ForceSoftware
}
public UnityEngine.CustomRenderTexture : RenderTexture {
public Material material
public Material initializationMaterial
public Texture initializationTexture
public CustomRenderTextureInitializationSource initializationSource
public Color initializationColor
public CustomRenderTextureUpdateMode updateMode
public CustomRenderTextureUpdateMode initializationMode
public CustomRenderTextureUpdateZoneSpace updateZoneSpace
public int shaderPass
public UInt32 cubemapFaceMask
public bool doubleBuffered
public bool wrapUpdateZones
public float updatePeriod
private void Internal_CreateCustomRenderTexture(CustomRenderTexture rt)
private void TriggerUpdate(int count)
public void Update(int count)
public void Update()
private void TriggerInitialization()
public void Initialize()
public void ClearUpdateZones()
public Material get_material()
public void set_material(Material value)
public Material get_initializationMaterial()
public void set_initializationMaterial(Material value)
public Texture get_initializationTexture()
public void set_initializationTexture(Texture value)
internal void GetUpdateZonesInternal(object updateZones)
public void GetUpdateZones(List`1<CustomRenderTextureUpdateZone> updateZones)
private void SetUpdateZonesInternal(CustomRenderTextureUpdateZone[] updateZones)
public RenderTexture GetDoubleBufferRenderTexture()
public void EnsureDoubleBufferConsistency()
public void SetUpdateZones(CustomRenderTextureUpdateZone[] updateZones)
public CustomRenderTextureInitializationSource get_initializationSource()
public void set_initializationSource(CustomRenderTextureInitializationSource value)
public Color get_initializationColor()
public void set_initializationColor(Color value)
public CustomRenderTextureUpdateMode get_updateMode()
public void set_updateMode(CustomRenderTextureUpdateMode value)
public CustomRenderTextureUpdateMode get_initializationMode()
public void set_initializationMode(CustomRenderTextureUpdateMode value)
public CustomRenderTextureUpdateZoneSpace get_updateZoneSpace()
public void set_updateZoneSpace(CustomRenderTextureUpdateZoneSpace value)
public int get_shaderPass()
public void set_shaderPass(int value)
public UInt32 get_cubemapFaceMask()
public void set_cubemapFaceMask(UInt32 value)
public bool get_doubleBuffered()
public void set_doubleBuffered(bool value)
public bool get_wrapUpdateZones()
public void set_wrapUpdateZones(bool value)
public float get_updatePeriod()
public void set_updatePeriod(float value)
public void .ctor(int width, int height, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void .ctor(int width, int height, RenderTextureFormat format)
public void .ctor(int width, int height)
public void .ctor(int width, int height, DefaultFormat defaultFormat)
public void .ctor(int width, int height, GraphicsFormat format)
private void get_initializationColor_Injected(Color& ret)
private void set_initializationColor_Injected(Color& value)
}
public UnityEngine.CustomRenderTextureInitializationSource : Enum {
public int value__
public CustomRenderTextureInitializationSource TextureAndColor
public CustomRenderTextureInitializationSource Material
}
public UnityEngine.CustomRenderTextureManager : object {
private Action`1<CustomRenderTexture> textureLoaded
private Action`1<CustomRenderTexture> textureUnloaded
private Action`2<CustomRenderTexture, int> updateTriggered
private Action`1<CustomRenderTexture> initializeTriggered
public void add_textureLoaded(Action`1<CustomRenderTexture> value)
public void remove_textureLoaded(Action`1<CustomRenderTexture> value)
private void InvokeOnTextureLoaded_Internal(CustomRenderTexture source)
public void add_textureUnloaded(Action`1<CustomRenderTexture> value)
public void remove_textureUnloaded(Action`1<CustomRenderTexture> value)
private void InvokeOnTextureUnloaded_Internal(CustomRenderTexture source)
public void GetAllCustomRenderTextures(List`1<CustomRenderTexture> currentCustomRenderTextures)
public void add_updateTriggered(Action`2<CustomRenderTexture, int> value)
public void remove_updateTriggered(Action`2<CustomRenderTexture, int> value)
internal void InvokeTriggerUpdate(CustomRenderTexture crt, int updateCount)
public void add_initializeTriggered(Action`1<CustomRenderTexture> value)
public void remove_initializeTriggered(Action`1<CustomRenderTexture> value)
internal void InvokeTriggerInitialize(CustomRenderTexture crt)
}
public UnityEngine.CustomRenderTextureUpdateMode : Enum {
public int value__
public CustomRenderTextureUpdateMode OnLoad
public CustomRenderTextureUpdateMode Realtime
public CustomRenderTextureUpdateMode OnDemand
}
public UnityEngine.CustomRenderTextureUpdateZone : ValueType {
public Vector3 updateZoneCenter
public Vector3 updateZoneSize
public float rotation
public int passIndex
public bool needSwap
}
public UnityEngine.CustomRenderTextureUpdateZoneSpace : Enum {
public int value__
public CustomRenderTextureUpdateZoneSpace Normalized
public CustomRenderTextureUpdateZoneSpace Pixel
}
public UnityEngine.CustomYieldInstruction : object {
public bool keepWaiting
public object Current
public bool get_keepWaiting()
public object get_Current()
public bool MoveNext()
public void Reset()
}
public UnityEngine.D3DHDRDisplayBitDepth : Enum {
public int value__
public D3DHDRDisplayBitDepth D3DHDRDisplayBitDepth10
public D3DHDRDisplayBitDepth D3DHDRDisplayBitDepth16
}
public UnityEngine.Debug : object {
internal ILogger s_DefaultLogger
internal ILogger s_Logger
public ILogger unityLogger
public bool developerConsoleVisible
public bool isDebugBuild
internal DiagnosticSwitch[] diagnosticSwitches
public ILogger logger
public ILogger get_unityLogger()
public void DrawLine(Vector3 start, Vector3 end, Color color, float duration)
public void DrawLine(Vector3 start, Vector3 end, Color color)
public void DrawLine(Vector3 start, Vector3 end)
public void DrawLine(Vector3 start, Vector3 end, Color color, float duration, bool depthTest)
public void DrawRay(Vector3 start, Vector3 dir, Color color, float duration)
public void DrawRay(Vector3 start, Vector3 dir, Color color)
public void DrawRay(Vector3 start, Vector3 dir)
public void DrawRay(Vector3 start, Vector3 dir, Color color, float duration, bool depthTest)
public void Break()
public void DebugBreak()
public int ExtractStackTraceNoAlloc(Byte* buffer, int bufferMax, string projectFolder)
public void Log(object message)
public void Log(object message, Object context)
public void LogFormat(string format, Object[] args)
public void LogFormat(Object context, string format, Object[] args)
public void LogFormat(LogType logType, LogOption logOptions, Object context, string format, Object[] args)
public void LogError(object message)
public void LogError(object message, Object context)
public void LogErrorFormat(string format, Object[] args)
public void LogErrorFormat(Object context, string format, Object[] args)
public void ClearDeveloperConsole()
public bool get_developerConsoleVisible()
public void set_developerConsoleVisible(bool value)
public void LogException(Exception exception)
public void LogException(Exception exception, Object context)
public void LogWarning(object message)
public void LogWarning(object message, Object context)
public void LogWarningFormat(string format, Object[] args)
public void LogWarningFormat(Object context, string format, Object[] args)
public void Assert(bool condition)
public void Assert(bool condition, Object context)
public void Assert(bool condition, object message)
public void Assert(bool condition, string message)
public void Assert(bool condition, object message, Object context)
public void Assert(bool condition, string message, Object context)
public void AssertFormat(bool condition, string format, Object[] args)
public void AssertFormat(bool condition, Object context, string format, Object[] args)
public void LogAssertion(object message)
public void LogAssertion(object message, Object context)
public void LogAssertionFormat(string format, Object[] args)
public void LogAssertionFormat(Object context, string format, Object[] args)
public bool get_isDebugBuild()
internal void OpenConsoleFile()
internal DiagnosticSwitch[] get_diagnosticSwitches()
internal DiagnosticSwitch GetDiagnosticSwitch(string name)
internal bool CallOverridenDebugHandler(Exception exception, Object obj)
internal bool IsLoggingEnabled()
public void Assert(bool condition, string format, Object[] args)
public ILogger get_logger()
private void DrawLine_Injected(Vector3& start, Vector3& end, Color& color, float duration, bool depthTest)
}
internal UnityEngine.DebugLogHandler : object {
internal void Internal_Log(LogType level, LogOption options, string msg, Object obj)
internal void Internal_LogException(Exception ex, Object obj)
public void LogFormat(LogType logType, Object context, string format, Object[] args)
public void LogFormat(LogType logType, LogOption logOptions, Object context, string format, Object[] args)
public void LogException(Exception exception, Object context)
}
public UnityEngine.DefaultExecutionOrder : Attribute {
private int m_Order
public int order
public void .ctor(int order)
public int get_order()
}
public UnityEngine.DepthTextureMode : Enum {
public int value__
public DepthTextureMode None
public DepthTextureMode Depth
public DepthTextureMode DepthNormals
public DepthTextureMode MotionVectors
}
public UnityEngine.Device.Application : object {
public string absoluteURL
public ThreadPriority backgroundLoadingPriority
public string buildGUID
public string cloudProjectId
public string companyName
public string consoleLogPath
public string dataPath
public bool genuine
public bool genuineCheckAvailable
public string identifier
public string installerName
public ApplicationInstallMode installMode
public NetworkReachability internetReachability
public bool isBatchMode
public bool isConsolePlatform
public bool isEditor
public bool isFocused
public bool isMobilePlatform
public bool isPlaying
public string persistentDataPath
public RuntimePlatform platform
public string productName
public bool runInBackground
public ApplicationSandboxType sandboxType
public string streamingAssetsPath
public SystemLanguage systemLanguage
public int targetFrameRate
public string temporaryCachePath
public string unityVersion
public string version
public string get_absoluteURL()
public ThreadPriority get_backgroundLoadingPriority()
public void set_backgroundLoadingPriority(ThreadPriority value)
public string get_buildGUID()
public string get_cloudProjectId()
public string get_companyName()
public string get_consoleLogPath()
public string get_dataPath()
public bool get_genuine()
public bool get_genuineCheckAvailable()
public string get_identifier()
public string get_installerName()
public ApplicationInstallMode get_installMode()
public NetworkReachability get_internetReachability()
public bool get_isBatchMode()
public bool get_isConsolePlatform()
public bool get_isEditor()
public bool get_isFocused()
public bool get_isMobilePlatform()
public bool get_isPlaying()
public string get_persistentDataPath()
public RuntimePlatform get_platform()
public string get_productName()
public bool get_runInBackground()
public void set_runInBackground(bool value)
public ApplicationSandboxType get_sandboxType()
public string get_streamingAssetsPath()
public SystemLanguage get_systemLanguage()
public int get_targetFrameRate()
public void set_targetFrameRate(int value)
public string get_temporaryCachePath()
public string get_unityVersion()
public string get_version()
public void add_deepLinkActivated(Action`1<string> value)
public void remove_deepLinkActivated(Action`1<string> value)
public void add_focusChanged(Action`1<bool> value)
public void remove_focusChanged(Action`1<bool> value)
public void add_logMessageReceived(LogCallback value)
public void remove_logMessageReceived(LogCallback value)
public void add_logMessageReceivedThreaded(LogCallback value)
public void remove_logMessageReceivedThreaded(LogCallback value)
public void add_lowMemory(LowMemoryCallback value)
public void remove_lowMemory(LowMemoryCallback value)
public void add_onBeforeRender(UnityAction value)
public void remove_onBeforeRender(UnityAction value)
public void add_quitting(Action value)
public void remove_quitting(Action value)
public void add_wantsToQuit(Func`1<bool> value)
public void remove_wantsToQuit(Func`1<bool> value)
public void add_unloading(Action value)
public void remove_unloading(Action value)
public bool CanStreamedLevelBeLoaded(int levelIndex)
public bool CanStreamedLevelBeLoaded(string levelName)
public String[] GetBuildTags()
public StackTraceLogType GetStackTraceLogType(LogType logType)
public bool HasProLicense()
public bool HasUserAuthorization(UserAuthorization mode)
public bool IsPlaying(Object obj)
public void OpenURL(string url)
public void Quit()
public void Quit(int exitCode)
public bool RequestAdvertisingIdentifierAsync(AdvertisingIdentifierCallback delegateMethod)
public AsyncOperation RequestUserAuthorization(UserAuthorization mode)
public void SetBuildTags(String[] buildTags)
public void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType)
public void Unload()
}
public UnityEngine.Device.Screen : object {
public float brightness
public bool autorotateToLandscapeLeft
public bool autorotateToLandscapeRight
public bool autorotateToPortrait
public bool autorotateToPortraitUpsideDown
public Resolution currentResolution
public Rect[] cutouts
public float dpi
public bool fullScreen
public FullScreenMode fullScreenMode
public int height
public int width
public ScreenOrientation orientation
public Resolution[] resolutions
public Rect safeArea
public int sleepTimeout
public Vector2Int mainWindowPosition
public DisplayInfo mainWindowDisplayInfo
public float get_brightness()
public void set_brightness(float value)
public bool get_autorotateToLandscapeLeft()
public void set_autorotateToLandscapeLeft(bool value)
public bool get_autorotateToLandscapeRight()
public void set_autorotateToLandscapeRight(bool value)
public bool get_autorotateToPortrait()
public void set_autorotateToPortrait(bool value)
public bool get_autorotateToPortraitUpsideDown()
public void set_autorotateToPortraitUpsideDown(bool value)
public Resolution get_currentResolution()
public Rect[] get_cutouts()
public float get_dpi()
public bool get_fullScreen()
public void set_fullScreen(bool value)
public FullScreenMode get_fullScreenMode()
public void set_fullScreenMode(FullScreenMode value)
public int get_height()
public int get_width()
public ScreenOrientation get_orientation()
public void set_orientation(ScreenOrientation value)
public Resolution[] get_resolutions()
public Rect get_safeArea()
public int get_sleepTimeout()
public void set_sleepTimeout(int value)
public void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate)
public void SetResolution(int width, int height, FullScreenMode fullscreenMode)
public void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate)
public void SetResolution(int width, int height, bool fullscreen)
public Vector2Int get_mainWindowPosition()
public DisplayInfo get_mainWindowDisplayInfo()
public void GetDisplayLayout(List`1<DisplayInfo> displayLayout)
public AsyncOperation MoveMainWindowTo(DisplayInfo& display, Vector2Int position)
}
public UnityEngine.Device.SystemInfo : object {
public string unsupportedIdentifier
public float batteryLevel
public BatteryStatus batteryStatus
public string operatingSystem
public OperatingSystemFamily operatingSystemFamily
public string processorType
public int processorFrequency
public int processorCount
public int systemMemorySize
public string deviceUniqueIdentifier
public string deviceName
public string deviceModel
public bool supportsAccelerometer
public bool supportsGyroscope
public bool supportsLocationService
public bool supportsVibration
public bool supportsAudio
public DeviceType deviceType
public int graphicsMemorySize
public string graphicsDeviceName
public string graphicsDeviceVendor
public int graphicsDeviceID
public int graphicsDeviceVendorID
public GraphicsDeviceType graphicsDeviceType
public bool graphicsUVStartsAtTop
public string graphicsDeviceVersion
public int graphicsShaderLevel
public bool graphicsMultiThreaded
public RenderingThreadingMode renderingThreadingMode
public bool hasHiddenSurfaceRemovalOnGPU
public bool hasDynamicUniformArrayIndexingInFragmentShaders
public bool supportsShadows
public bool supportsRawShadowDepthSampling
public bool supportsMotionVectors
public bool supports3DTextures
public bool supportsCompressed3DTextures
public bool supports2DArrayTextures
public bool supports3DRenderTextures
public bool supportsCubemapArrayTextures
public bool supportsAnisotropicFilter
public CopyTextureSupport copyTextureSupport
public bool supportsComputeShaders
public bool supportsGeometryShaders
public bool supportsTessellationShaders
public bool supportsRenderTargetArrayIndexFromVertexShader
public bool supportsInstancing
public bool supportsHardwareQuadTopology
public bool supports32bitsIndexBuffer
public bool supportsSparseTextures
public int supportedRenderTargetCount
public bool supportsSeparatedRenderTargetsBlend
public int supportedRandomWriteTargetCount
public int supportsMultisampledTextures
public bool supportsMultisampled2DArrayTextures
public bool supportsMultisampleAutoResolve
public int supportsTextureWrapMirrorOnce
public bool usesReversedZBuffer
public NPOTSupport npotSupport
public int maxTextureSize
public int maxTexture3DSize
public int maxTextureArraySlices
public int maxCubemapSize
public int maxAnisotropyLevel
public int maxComputeBufferInputsVertex
public int maxComputeBufferInputsFragment
public int maxComputeBufferInputsGeometry
public int maxComputeBufferInputsDomain
public int maxComputeBufferInputsHull
public int maxComputeBufferInputsCompute
public int maxComputeWorkGroupSize
public int maxComputeWorkGroupSizeX
public int maxComputeWorkGroupSizeY
public int maxComputeWorkGroupSizeZ
public int computeSubGroupSize
public bool supportsAsyncCompute
public bool supportsGpuRecorder
public bool supportsGraphicsFence
public bool supportsAsyncGPUReadback
public bool supportsRayTracing
public bool supportsSetConstantBuffer
public int constantBufferOffsetAlignment
public long maxGraphicsBufferSize
public bool hasMipMaxLevel
public bool supportsMipStreaming
public bool usesLoadStoreActions
public HDRDisplaySupportFlags hdrDisplaySupportFlags
public bool supportsConservativeRaster
public bool supportsMultiview
public bool supportsStoreAndResolveAction
public bool supportsMultisampleResolveDepth
public float get_batteryLevel()
public BatteryStatus get_batteryStatus()
public string get_operatingSystem()
public OperatingSystemFamily get_operatingSystemFamily()
public string get_processorType()
public int get_processorFrequency()
public int get_processorCount()
public int get_systemMemorySize()
public string get_deviceUniqueIdentifier()
public string get_deviceName()
public string get_deviceModel()
public bool get_supportsAccelerometer()
public bool get_supportsGyroscope()
public bool get_supportsLocationService()
public bool get_supportsVibration()
public bool get_supportsAudio()
public DeviceType get_deviceType()
public int get_graphicsMemorySize()
public string get_graphicsDeviceName()
public string get_graphicsDeviceVendor()
public int get_graphicsDeviceID()
public int get_graphicsDeviceVendorID()
public GraphicsDeviceType get_graphicsDeviceType()
public bool get_graphicsUVStartsAtTop()
public string get_graphicsDeviceVersion()
public int get_graphicsShaderLevel()
public bool get_graphicsMultiThreaded()
public RenderingThreadingMode get_renderingThreadingMode()
public bool get_hasHiddenSurfaceRemovalOnGPU()
public bool get_hasDynamicUniformArrayIndexingInFragmentShaders()
public bool get_supportsShadows()
public bool get_supportsRawShadowDepthSampling()
public bool get_supportsMotionVectors()
public bool get_supports3DTextures()
public bool get_supportsCompressed3DTextures()
public bool get_supports2DArrayTextures()
public bool get_supports3DRenderTextures()
public bool get_supportsCubemapArrayTextures()
public bool get_supportsAnisotropicFilter()
public CopyTextureSupport get_copyTextureSupport()
public bool get_supportsComputeShaders()
public bool get_supportsGeometryShaders()
public bool get_supportsTessellationShaders()
public bool get_supportsRenderTargetArrayIndexFromVertexShader()
public bool get_supportsInstancing()
public bool get_supportsHardwareQuadTopology()
public bool get_supports32bitsIndexBuffer()
public bool get_supportsSparseTextures()
public int get_supportedRenderTargetCount()
public bool get_supportsSeparatedRenderTargetsBlend()
public int get_supportedRandomWriteTargetCount()
public int get_supportsMultisampledTextures()
public bool get_supportsMultisampled2DArrayTextures()
public bool get_supportsMultisampleAutoResolve()
public int get_supportsTextureWrapMirrorOnce()
public bool get_usesReversedZBuffer()
public bool SupportsRenderTextureFormat(RenderTextureFormat format)
public bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format)
public bool SupportsTextureFormat(TextureFormat format)
public bool SupportsVertexAttributeFormat(VertexAttributeFormat format, int dimension)
public NPOTSupport get_npotSupport()
public int get_maxTextureSize()
public int get_maxTexture3DSize()
public int get_maxTextureArraySlices()
public int get_maxCubemapSize()
public int get_maxAnisotropyLevel()
public int get_maxComputeBufferInputsVertex()
public int get_maxComputeBufferInputsFragment()
public int get_maxComputeBufferInputsGeometry()
public int get_maxComputeBufferInputsDomain()
public int get_maxComputeBufferInputsHull()
public int get_maxComputeBufferInputsCompute()
public int get_maxComputeWorkGroupSize()
public int get_maxComputeWorkGroupSizeX()
public int get_maxComputeWorkGroupSizeY()
public int get_maxComputeWorkGroupSizeZ()
public int get_computeSubGroupSize()
public bool get_supportsAsyncCompute()
public bool get_supportsGpuRecorder()
public bool get_supportsGraphicsFence()
public bool get_supportsAsyncGPUReadback()
public bool get_supportsRayTracing()
public bool get_supportsSetConstantBuffer()
public int get_constantBufferOffsetAlignment()
public long get_maxGraphicsBufferSize()
public bool get_hasMipMaxLevel()
public bool get_supportsMipStreaming()
public bool get_usesLoadStoreActions()
public HDRDisplaySupportFlags get_hdrDisplaySupportFlags()
public bool get_supportsConservativeRaster()
public bool get_supportsMultiview()
public bool get_supportsStoreAndResolveAction()
public bool get_supportsMultisampleResolveDepth()
public bool IsFormatSupported(GraphicsFormat format, FormatUsage usage)
public GraphicsFormat GetCompatibleFormat(GraphicsFormat format, FormatUsage usage)
public GraphicsFormat GetGraphicsFormat(DefaultFormat format)
public int GetRenderTextureSupportedMSAASampleCount(RenderTextureDescriptor desc)
public bool SupportsRandomWriteOnRenderTextureFormat(RenderTextureFormat format)
}
public UnityEngine.DeviceType : Enum {
public int value__
public DeviceType Unknown
public DeviceType Handheld
public DeviceType Console
public DeviceType Desktop
}
public UnityEngine.Diagnostics.ForcedCrashCategory : Enum {
public int value__
public ForcedCrashCategory AccessViolation
public ForcedCrashCategory FatalError
public ForcedCrashCategory Abort
public ForcedCrashCategory PureVirtualFunction
public ForcedCrashCategory MonoAbort
}
public UnityEngine.Diagnostics.PlayerConnection : object {
public bool connected
public bool get_connected()
public void SendFile(string remoteFilePath, Byte[] data)
}
public UnityEngine.Diagnostics.Utils : object {
public void ForceCrash(ForcedCrashCategory crashCategory)
public void NativeAssert(string message)
public void NativeError(string message)
public void NativeWarning(string message)
}
internal UnityEngine.DiagnosticSwitch : object {
private IntPtr m_Ptr
public string name
public string description
public string owningModule
public Flags flags
public object value
public object defaultValue
public object minValue
public object maxValue
public object persistentValue
public EnumInfo enumInfo
public bool isSetToDefault
public bool needsRestart
public string get_name()
public string get_description()
public string get_owningModule()
public Flags get_flags()
public object get_value()
public void set_value(object value)
public object get_defaultValue()
public object get_minValue()
public object get_maxValue()
public object get_persistentValue()
public void set_persistentValue(object value)
public EnumInfo get_enumInfo()
private object GetScriptingValue()
private object GetScriptingPersistentValue()
private void SetScriptingValue(object value, bool setPersistent)
public bool get_isSetToDefault()
public bool get_needsRestart()
}
internal UnityEngine.DisableBatchingType : Enum {
public int value__
public DisableBatchingType False
public DisableBatchingType True
public DisableBatchingType WhenLODFading
}
public UnityEngine.Display : object {
internal IntPtr nativeDisplay
public Display[] displays
private Display _mainDisplay
private int m_ActiveEditorGameViewTarget
private DisplaysUpdatedDelegate onDisplaysUpdated
public int renderingWidth
public int renderingHeight
public int systemWidth
public int systemHeight
public RenderBuffer colorBuffer
public RenderBuffer depthBuffer
public bool active
public bool requiresBlitToBackbuffer
public bool requiresSrgbBlitToBackbuffer
public Display main
public int activeEditorGameViewTarget
internal void .ctor(IntPtr nativeDisplay)
public int get_renderingWidth()
public int get_renderingHeight()
public int get_systemWidth()
public int get_systemHeight()
public RenderBuffer get_colorBuffer()
public RenderBuffer get_depthBuffer()
public bool get_active()
public bool get_requiresBlitToBackbuffer()
public bool get_requiresSrgbBlitToBackbuffer()
public void Activate()
public void Activate(int width, int height, int refreshRate)
public void SetParams(int width, int height, int x, int y)
public void SetRenderingResolution(int w, int h)
public bool MultiDisplayLicense()
public Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates)
public Display get_main()
public int get_activeEditorGameViewTarget()
internal void set_activeEditorGameViewTarget(int value)
private void RecreateDisplayList(IntPtr[] nativeDisplay)
private void FireDisplaysUpdated()
public void add_onDisplaysUpdated(DisplaysUpdatedDelegate value)
public void remove_onDisplaysUpdated(DisplaysUpdatedDelegate value)
private void GetSystemExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h)
private void GetRenderingExtImpl(IntPtr nativeDisplay, Int32& w, Int32& h)
private void GetRenderingBuffersImpl(IntPtr nativeDisplay, RenderBuffer& color, RenderBuffer& depth)
private void SetRenderingResolutionImpl(IntPtr nativeDisplay, int w, int h)
private void ActivateDisplayImpl(IntPtr nativeDisplay, int width, int height, int refreshRate)
private void SetParamsImpl(IntPtr nativeDisplay, int width, int height, int x, int y)
private int RelativeMouseAtImpl(int x, int y, Int32& rx, Int32& ry)
private bool GetActiveImpl(IntPtr nativeDisplay)
private bool RequiresBlitToBackbufferImpl(IntPtr nativeDisplay)
private bool RequiresSrgbBlitToBackbufferImpl(IntPtr nativeDisplay)
}
public UnityEngine.DisplayInfo : ValueType {
internal ulong handle
public int width
public int height
public RefreshRate refreshRate
public RectInt workArea
public string name
public bool Equals(DisplayInfo other)
}
internal UnityEngine.DrivenPropertyManager : object {
public void RegisterProperty(Object driver, Object target, string propertyPath)
public void TryRegisterProperty(Object driver, Object target, string propertyPath)
public void UnregisterProperty(Object driver, Object target, string propertyPath)
public void UnregisterProperties(Object driver)
private void RegisterPropertyPartial(Object driver, Object target, string propertyPath)
private void TryRegisterPropertyPartial(Object driver, Object target, string propertyPath)
private void UnregisterPropertyPartial(Object driver, Object target, string propertyPath)
}
public UnityEngine.DrivenRectTransformTracker : ValueType {
internal bool CanRecordModifications()
public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties)
public void Clear(bool revertValues)
public void Clear()
}
public UnityEngine.DrivenTransformProperties : Enum {
public int value__
public DrivenTransformProperties None
public DrivenTransformProperties All
public DrivenTransformProperties AnchoredPositionX
public DrivenTransformProperties AnchoredPositionY
public DrivenTransformProperties AnchoredPositionZ
public DrivenTransformProperties Rotation
public DrivenTransformProperties ScaleX
public DrivenTransformProperties ScaleY
public DrivenTransformProperties ScaleZ
public DrivenTransformProperties AnchorMinX
public DrivenTransformProperties AnchorMinY
public DrivenTransformProperties AnchorMaxX
public DrivenTransformProperties AnchorMaxY
public DrivenTransformProperties SizeDeltaX
public DrivenTransformProperties SizeDeltaY
public DrivenTransformProperties PivotX
public DrivenTransformProperties PivotY
public DrivenTransformProperties AnchoredPosition
public DrivenTransformProperties AnchoredPosition3D
public DrivenTransformProperties Scale
public DrivenTransformProperties AnchorMin
public DrivenTransformProperties AnchorMax
public DrivenTransformProperties Anchors
public DrivenTransformProperties SizeDelta
public DrivenTransformProperties Pivot
}
public UnityEngine.DynamicGI : object {
public float indirectScale
public float updateThreshold
public int materialUpdateTimeSlice
public bool synchronousMode
public bool isConverged
internal int scheduledMaterialUpdatesCount
internal bool asyncMaterialUpdates
public float get_indirectScale()
public void set_indirectScale(float value)
public float get_updateThreshold()
public void set_updateThreshold(float value)
public int get_materialUpdateTimeSlice()
public void set_materialUpdateTimeSlice(int value)
public void SetEmissive(Renderer renderer, Color color)
public void SetEnvironmentData(Single[] input)
public bool get_synchronousMode()
public void set_synchronousMode(bool value)
public bool get_isConverged()
internal int get_scheduledMaterialUpdatesCount()
internal bool get_asyncMaterialUpdates()
internal void set_asyncMaterialUpdates(bool value)
public void UpdateEnvironment()
public void UpdateMaterials(Renderer renderer)
public void UpdateMaterials(Object renderer)
public void UpdateMaterials(Object renderer, int x, int y, int width, int height)
private void SetEmissive_Injected(Renderer renderer, Color& color)
}
internal UnityEngine.EnabledOrientation : Enum {
public int value__
public EnabledOrientation kAutorotateToPortrait
public EnabledOrientation kAutorotateToPortraitUpsideDown
public EnabledOrientation kAutorotateToLandscapeLeft
public EnabledOrientation kAutorotateToLandscapeRight
}
internal UnityEngine.EnumData : ValueType {
public Enum[] values
public Int32[] flagValues
public String[] displayNames
public String[] names
public String[] tooltip
public bool flags
public Type underlyingType
public bool unsigned
public bool serializable
}
internal UnityEngine.EnumDataUtility : object {
private Dictionary`2<Type, EnumData> s_NonObsoleteEnumData
private Dictionary`2<Type, EnumData> s_EnumData
internal EnumData GetCachedEnumData(Type enumType, bool excludeObsolete, Func`2<string, string> nicifyName)
internal int EnumFlagsToInt(EnumData enumData, Enum enumValue)
internal Enum IntToEnumFlags(Type enumType, int value)
private bool CheckObsoleteAddition(FieldInfo field, bool excludeObsolete)
private string EnumTooltipFromEnumField(FieldInfo field)
private string EnumNameFromEnumField(FieldInfo field, Func`2<string, string> nicifyName)
internal string <EnumNameFromEnumField>g__NicifyName|7_0(<>c__DisplayClass7_0& )
}
internal UnityEngine.EnumInfo : object {
public String[] names
public Int32[] values
public String[] annotations
public bool isFlags
internal EnumInfo CreateEnumInfoFromNativeEnum(String[] names, Int32[] values, String[] annotations, bool isFlags)
}
internal UnityEngine.Events.ArgumentCache : object {
private Object m_ObjectArgument
private string m_ObjectArgumentAssemblyTypeName
private int m_IntArgument
private float m_FloatArgument
private string m_StringArgument
private bool m_BoolArgument
public Object unityObjectArgument
public string unityObjectArgumentAssemblyTypeName
public int intArgument
public float floatArgument
public string stringArgument
public bool boolArgument
public Object get_unityObjectArgument()
public void set_unityObjectArgument(Object value)
public string get_unityObjectArgumentAssemblyTypeName()
public int get_intArgument()
public void set_intArgument(int value)
public float get_floatArgument()
public void set_floatArgument(float value)
public string get_stringArgument()
public void set_stringArgument(string value)
public bool get_boolArgument()
public void set_boolArgument(bool value)
public void OnBeforeSerialize()
public void OnAfterDeserialize()
}
internal UnityEngine.Events.BaseInvokableCall : object {
protected void .ctor(object target, MethodInfo function)
public void Invoke(Object[] args)
protected void ThrowOnInvalidArg(object arg)
protected bool AllowInvoke(Delegate delegate)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.CachedInvokableCall`1 : InvokableCall`1<T> {
private T m_Arg1
public void .ctor(Object target, MethodInfo theFunction, T argument)
public void Invoke(Object[] args)
public void Invoke(T arg0)
}
internal UnityEngine.Events.InvokableCall : BaseInvokableCall {
private UnityAction Delegate
private void add_Delegate(UnityAction value)
private void remove_Delegate(UnityAction value)
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction action)
public void Invoke(Object[] args)
public void Invoke()
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`1 : BaseInvokableCall {
private UnityAction`1<T1> Delegate
protected void add_Delegate(UnityAction`1<T1> value)
protected void remove_Delegate(UnityAction`1<T1> value)
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`1<T1> action)
public void Invoke(Object[] args)
public void Invoke(T1 args0)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`2 : BaseInvokableCall {
private UnityAction`2<T1, T2> Delegate
protected void add_Delegate(UnityAction`2<T1, T2> value)
protected void remove_Delegate(UnityAction`2<T1, T2> value)
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`2<T1, T2> action)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`3 : BaseInvokableCall {
private UnityAction`3<T1, T2, T3> Delegate
protected void add_Delegate(UnityAction`3<T1, T2, T3> value)
protected void remove_Delegate(UnityAction`3<T1, T2, T3> value)
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`3<T1, T2, T3> action)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1, T3 args2)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCall`4 : BaseInvokableCall {
private UnityAction`4<T1, T2, T3, T4> Delegate
protected void add_Delegate(UnityAction`4<T1, T2, T3, T4> value)
protected void remove_Delegate(UnityAction`4<T1, T2, T3, T4> value)
public void .ctor(object target, MethodInfo theFunction)
public void .ctor(UnityAction`4<T1, T2, T3, T4> action)
public void Invoke(Object[] args)
public void Invoke(T1 args0, T2 args1, T3 args2, T4 args3)
public bool Find(object targetObj, MethodInfo method)
}
internal UnityEngine.Events.InvokableCallList : object {
private List`1<BaseInvokableCall> m_PersistentCalls
private List`1<BaseInvokableCall> m_RuntimeCalls
private List`1<BaseInvokableCall> m_ExecutingCalls
private bool m_NeedsUpdate
public int Count
public int get_Count()
public void AddPersistentInvokableCall(BaseInvokableCall call)
public void AddListener(BaseInvokableCall call)
public void RemoveListener(object targetObj, MethodInfo method)
public void Clear()
public void ClearPersistent()
public List`1<BaseInvokableCall> PrepareInvoke()
}
internal UnityEngine.Events.PersistentCall : object {
private Object m_Target
private string m_TargetAssemblyTypeName
private string m_MethodName
private PersistentListenerMode m_Mode
private ArgumentCache m_Arguments
private UnityEventCallState m_CallState
public Object target
public string targetAssemblyTypeName
public string methodName
public PersistentListenerMode mode
public ArgumentCache arguments
public UnityEventCallState callState
public Object get_target()
public string get_targetAssemblyTypeName()
public string get_methodName()
public PersistentListenerMode get_mode()
public void set_mode(PersistentListenerMode value)
public ArgumentCache get_arguments()
public UnityEventCallState get_callState()
public void set_callState(UnityEventCallState value)
public bool IsValid()
public BaseInvokableCall GetRuntimeCall(UnityEventBase theEvent)
private BaseInvokableCall GetObjectCall(Object target, MethodInfo method, ArgumentCache arguments)
public void RegisterPersistentListener(Object ttarget, Type targetType, string mmethodName)
public void UnregisterPersistentListener()
public void OnBeforeSerialize()
public void OnAfterDeserialize()
}
internal UnityEngine.Events.PersistentCallGroup : object {
private List`1<PersistentCall> m_Calls
public int Count
public int get_Count()
public PersistentCall GetListener(int index)
public IEnumerable`1<PersistentCall> GetListeners()
public void AddListener()
public void AddListener(PersistentCall call)
public void RemoveListener(int index)
public void Clear()
public void RegisterEventPersistentListener(int index, Object targetObj, Type targetObjType, string methodName)
public void RegisterVoidPersistentListener(int index, Object targetObj, Type targetObjType, string methodName)
public void RegisterObjectPersistentListener(int index, Object targetObj, Type targetObjType, Object argument, string methodName)
public void RegisterIntPersistentListener(int index, Object targetObj, Type targetObjType, int argument, string methodName)
public void RegisterFloatPersistentListener(int index, Object targetObj, Type targetObjType, float argument, string methodName)
public void RegisterStringPersistentListener(int index, Object targetObj, Type targetObjType, string argument, string methodName)
public void RegisterBoolPersistentListener(int index, Object targetObj, Type targetObjType, bool argument, string methodName)
public void UnregisterPersistentListener(int index)
public void RemoveListeners(Object target, string methodName)
public void Initialize(InvokableCallList invokableList, UnityEventBase unityEventBase)
}
public UnityEngine.Events.PersistentListenerMode : Enum {
public int value__
public PersistentListenerMode EventDefined
public PersistentListenerMode Void
public PersistentListenerMode Object
public PersistentListenerMode Int
public PersistentListenerMode Float
public PersistentListenerMode String
public PersistentListenerMode Bool
}
public UnityEngine.Events.UnityAction : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0)
public IAsyncResult BeginInvoke(T0 arg0, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`3 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1, T2 arg2)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityAction`4 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
public IAsyncResult BeginInvoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public UnityEngine.Events.UnityEvent : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction call)
public void RemoveListener(UnityAction call)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction action)
public void Invoke()
}
public UnityEngine.Events.UnityEvent`1 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`1<T0> call)
public void RemoveListener(UnityAction`1<T0> call)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`1<T0> action)
public void Invoke(T0 arg0)
}
public UnityEngine.Events.UnityEvent`2 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`2<T0, T1> call)
public void RemoveListener(UnityAction`2<T0, T1> call)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`2<T0, T1> action)
public void Invoke(T0 arg0, T1 arg1)
}
public UnityEngine.Events.UnityEvent`3 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`3<T0, T1, T2> call)
public void RemoveListener(UnityAction`3<T0, T1, T2> call)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`3<T0, T1, T2> action)
public void Invoke(T0 arg0, T1 arg1, T2 arg2)
}
public UnityEngine.Events.UnityEvent`4 : UnityEventBase {
private Object[] m_InvokeArray
public void AddListener(UnityAction`4<T0, T1, T2, T3> call)
public void RemoveListener(UnityAction`4<T0, T1, T2, T3> call)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
private BaseInvokableCall GetDelegate(UnityAction`4<T0, T1, T2, T3> action)
public void Invoke(T0 arg0, T1 arg1, T2 arg2, T3 arg3)
}
public UnityEngine.Events.UnityEventBase : object {
private InvokableCallList m_Calls
private PersistentCallGroup m_PersistentCalls
private bool m_CallsDirty
private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize()
private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize()
protected MethodInfo FindMethod_Impl(string name, object targetObj)
protected MethodInfo FindMethod_Impl(string name, Type targetObjType)
internal BaseInvokableCall GetDelegate(object target, MethodInfo theFunction)
internal MethodInfo FindMethod(PersistentCall call)
internal MethodInfo FindMethod(string name, Type listenerType, PersistentListenerMode mode, Type argumentType)
public int GetPersistentEventCount()
public Object GetPersistentTarget(int index)
public string GetPersistentMethodName(int index)
private void DirtyPersistentCalls()
private void RebuildPersistentCallsIfNeeded()
public void SetPersistentListenerState(int index, UnityEventCallState state)
public UnityEventCallState GetPersistentListenerState(int index)
protected void AddListener(object targetObj, MethodInfo method)
internal void AddCall(BaseInvokableCall call)
protected void RemoveListener(object targetObj, MethodInfo method)
public void RemoveAllListeners()
internal List`1<BaseInvokableCall> PrepareInvoke()
protected void Invoke(Object[] parameters)
public string ToString()
public MethodInfo GetValidMethodInfo(object obj, string functionName, Type[] argumentTypes)
public MethodInfo GetValidMethodInfo(Type objectType, string functionName, Type[] argumentTypes)
}
public UnityEngine.Events.UnityEventCallState : Enum {
public int value__
public UnityEventCallState Off
public UnityEventCallState EditorAndRuntime
public UnityEventCallState RuntimeOnly
}
internal UnityEngine.Events.UnityEventTools : object {
internal string TidyAssemblyTypeName(string assemblyTypeName)
}
public UnityEngine.Experimental.GlobalIllumination.AngularFalloffType : Enum {
public byte value__
public AngularFalloffType LUT
public AngularFalloffType AnalyticAndInnerAngle
}
public UnityEngine.Experimental.GlobalIllumination.Cookie : ValueType {
public int instanceID
public float scale
public Vector2 sizes
public Cookie Defaults()
}
public UnityEngine.Experimental.GlobalIllumination.DirectionalLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float penumbraWidthRadian
public Vector3 direction
}
public UnityEngine.Experimental.GlobalIllumination.DiscLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float radius
public FalloffType falloff
}
public UnityEngine.Experimental.GlobalIllumination.FalloffType : Enum {
public byte value__
public FalloffType InverseSquared
public FalloffType InverseSquaredNoRangeAttenuation
public FalloffType Linear
public FalloffType Legacy
public FalloffType Undefined
}
public UnityEngine.Experimental.GlobalIllumination.LightDataGI : ValueType {
public int instanceID
public int cookieID
public float cookieScale
public LinearColor color
public LinearColor indirectColor
public Quaternion orientation
public Vector3 position
public float range
public float coneAngle
public float innerConeAngle
public float shape0
public float shape1
public LightType type
public LightMode mode
public byte shadow
public FalloffType falloff
public void Init(DirectionalLight& light, Cookie& cookie)
public void Init(PointLight& light, Cookie& cookie)
public void Init(SpotLight& light, Cookie& cookie)
public void Init(RectangleLight& light, Cookie& cookie)
public void Init(DiscLight& light, Cookie& cookie)
public void Init(SpotLightBoxShape& light, Cookie& cookie)
public void Init(SpotLightPyramidShape& light, Cookie& cookie)
public void Init(DirectionalLight& light)
public void Init(PointLight& light)
public void Init(SpotLight& light)
public void Init(RectangleLight& light)
public void Init(DiscLight& light)
public void Init(SpotLightBoxShape& light)
public void Init(SpotLightPyramidShape& light)
public void InitNoBake(int lightInstanceID)
}
public UnityEngine.Experimental.GlobalIllumination.LightmapperUtils : object {
public LightMode Extract(LightmapBakeType baketype)
public LinearColor ExtractIndirect(Light l)
public float ExtractInnerCone(Light l)
private Color ExtractColorTemperature(Light l)
private void ApplyColorTemperature(Color cct, LinearColor& lightColor)
public void Extract(Light l, DirectionalLight& dir)
public void Extract(Light l, PointLight& point)
public void Extract(Light l, SpotLight& spot)
public void Extract(Light l, RectangleLight& rect)
public void Extract(Light l, DiscLight& disc)
public void Extract(Light l, Cookie& cookie)
}
public UnityEngine.Experimental.GlobalIllumination.Lightmapping : object {
private RequestLightsDelegate s_DefaultDelegate
private RequestLightsDelegate s_RequestLightsDelegate
public void SetDelegate(RequestLightsDelegate del)
public RequestLightsDelegate GetDelegate()
public void ResetDelegate()
internal void RequestLights(Light[] lights, IntPtr outLightsPtr, int outLightsCount)
}
public UnityEngine.Experimental.GlobalIllumination.LightMode : Enum {
public byte value__
public LightMode Realtime
public LightMode Mixed
public LightMode Baked
public LightMode Unknown
}
public UnityEngine.Experimental.GlobalIllumination.LightType : Enum {
public byte value__
public LightType Directional
public LightType Point
public LightType Spot
public LightType Rectangle
public LightType Disc
public LightType SpotPyramidShape
public LightType SpotBoxShape
}
public UnityEngine.Experimental.GlobalIllumination.LinearColor : ValueType {
private float m_red
private float m_green
private float m_blue
private float m_intensity
public float red
public float green
public float blue
public float intensity
public float get_red()
public void set_red(float value)
public float get_green()
public void set_green(float value)
public float get_blue()
public void set_blue(float value)
public float get_intensity()
public void set_intensity(float value)
public LinearColor Convert(Color color, float intensity)
public LinearColor Black()
}
public UnityEngine.Experimental.GlobalIllumination.PointLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float sphereRadius
public FalloffType falloff
}
public UnityEngine.Experimental.GlobalIllumination.RectangleLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float width
public float height
public FalloffType falloff
}
public UnityEngine.Experimental.GlobalIllumination.RenderSettings : object {
public bool useRadianceAmbientProbe
public bool get_useRadianceAmbientProbe()
public void set_useRadianceAmbientProbe(bool value)
}
public UnityEngine.Experimental.GlobalIllumination.SpotLight : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float sphereRadius
public float coneAngle
public float innerConeAngle
public FalloffType falloff
public AngularFalloffType angularFalloff
}
public UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float width
public float height
}
public UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape : ValueType {
public int instanceID
public bool shadow
public LightMode mode
public Vector3 position
public Quaternion orientation
public LinearColor color
public LinearColor indirectColor
public float range
public float angle
public float aspectRatio
public FalloffType falloff
}
public UnityEngine.Experimental.Playables.CameraPlayable : ValueType {
private PlayableHandle m_Handle
public CameraPlayable Create(PlayableGraph graph, Camera camera)
private PlayableHandle CreateHandle(PlayableGraph graph, Camera camera)
internal void .ctor(PlayableHandle handle)
public PlayableHandle GetHandle()
public Playable op_Implicit(CameraPlayable playable)
public CameraPlayable op_Explicit(Playable playable)
public bool Equals(CameraPlayable other)
public Camera GetCamera()
public void SetCamera(Camera value)
private Camera GetCameraInternal(PlayableHandle& hdl)
private void SetCameraInternal(PlayableHandle& hdl, Camera camera)
private bool InternalCreateCameraPlayable(PlayableGraph& graph, Camera camera, PlayableHandle& handle)
private bool ValidateType(PlayableHandle& hdl)
}
public UnityEngine.Experimental.Playables.MaterialEffectPlayable : ValueType {
private PlayableHandle m_Handle
public MaterialEffectPlayable Create(PlayableGraph graph, Material material, int pass)
private PlayableHandle CreateHandle(PlayableGraph graph, Material material, int pass)
internal void .ctor(PlayableHandle handle)
public PlayableHandle GetHandle()
public Playable op_Implicit(MaterialEffectPlayable playable)
public MaterialEffectPlayable op_Explicit(Playable playable)
public bool Equals(MaterialEffectPlayable other)
public Material GetMaterial()
public void SetMaterial(Material value)
public int GetPass()
public void SetPass(int value)
private Material GetMaterialInternal(PlayableHandle& hdl)
private void SetMaterialInternal(PlayableHandle& hdl, Material material)
private int GetPassInternal(PlayableHandle& hdl)
private void SetPassInternal(PlayableHandle& hdl, int pass)
private bool InternalCreateMaterialEffectPlayable(PlayableGraph& graph, Material material, int pass, PlayableHandle& handle)
private bool ValidateType(PlayableHandle& hdl)
}
public UnityEngine.Experimental.Playables.TextureMixerPlayable : ValueType {
private PlayableHandle m_Handle
public TextureMixerPlayable Create(PlayableGraph graph)
private PlayableHandle CreateHandle(PlayableGraph graph)
internal void .ctor(PlayableHandle handle)
public PlayableHandle GetHandle()
public Playable op_Implicit(TextureMixerPlayable playable)
public TextureMixerPlayable op_Explicit(Playable playable)
public bool Equals(TextureMixerPlayable other)
private bool CreateTextureMixerPlayableInternal(PlayableGraph& graph, PlayableHandle& handle)
}
public UnityEngine.Experimental.Playables.TexturePlayableBinding : object {
public PlayableBinding Create(string name, Object key)
private PlayableOutput CreateTextureOutput(PlayableGraph graph, string name)
}
internal UnityEngine.Experimental.Playables.TexturePlayableGraphExtensions : object {
internal bool InternalCreateTextureOutput(PlayableGraph& graph, string name, PlayableOutputHandle& handle)
}
public UnityEngine.Experimental.Playables.TexturePlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
public TexturePlayableOutput Null
public TexturePlayableOutput Create(PlayableGraph graph, string name, RenderTexture target)
internal void .ctor(PlayableOutputHandle handle)
public TexturePlayableOutput get_Null()
public PlayableOutputHandle GetHandle()
public PlayableOutput op_Implicit(TexturePlayableOutput output)
public TexturePlayableOutput op_Explicit(PlayableOutput output)
public RenderTexture GetTarget()
public void SetTarget(RenderTexture value)
private RenderTexture InternalGetTarget(PlayableOutputHandle& output)
private void InternalSetTarget(PlayableOutputHandle& output, RenderTexture target)
}
internal UnityEngine.Experimental.Rendering.BuiltinRuntimeReflectionSystem : object {
public bool TickRealtimeProbes()
public void Dispose()
private void Dispose(bool disposing)
private bool BuiltinUpdate()
private BuiltinRuntimeReflectionSystem Internal_BuiltinRuntimeReflectionSystem_New()
}
public UnityEngine.Experimental.Rendering.DefaultFormat : Enum {
public int value__
public DefaultFormat LDR
public DefaultFormat HDR
public DefaultFormat DepthStencil
public DefaultFormat Shadow
public DefaultFormat Video
}
public UnityEngine.Experimental.Rendering.ExternalGPUProfiler : object {
public void BeginGPUCapture()
public void EndGPUCapture()
public bool IsAttached()
}
public UnityEngine.Experimental.Rendering.FormatUsage : Enum {
public int value__
public FormatUsage Sample
public FormatUsage Linear
public FormatUsage Sparse
public FormatUsage Render
public FormatUsage Blend
public FormatUsage GetPixels
public FormatUsage SetPixels
public FormatUsage SetPixels32
public FormatUsage ReadPixels
public FormatUsage LoadStore
public FormatUsage MSAA2x
public FormatUsage MSAA4x
public FormatUsage MSAA8x
public FormatUsage StencilSampling
}
public UnityEngine.Experimental.Rendering.GraphicsDeviceSettings : object {
public WaitForPresentSyncPoint waitForPresentSyncPoint
public GraphicsJobsSyncPoint graphicsJobsSyncPoint
public WaitForPresentSyncPoint get_waitForPresentSyncPoint()
public void set_waitForPresentSyncPoint(WaitForPresentSyncPoint value)
public GraphicsJobsSyncPoint get_graphicsJobsSyncPoint()
public void set_graphicsJobsSyncPoint(GraphicsJobsSyncPoint value)
}
public UnityEngine.Experimental.Rendering.GraphicsFormat : Enum {
public int value__
public GraphicsFormat None
public GraphicsFormat R8_SRGB
public GraphicsFormat R8G8_SRGB
public GraphicsFormat R8G8B8_SRGB
public GraphicsFormat R8G8B8A8_SRGB
public GraphicsFormat R8_UNorm
public GraphicsFormat R8G8_UNorm
public GraphicsFormat R8G8B8_UNorm
public GraphicsFormat R8G8B8A8_UNorm
public GraphicsFormat R8_SNorm
public GraphicsFormat R8G8_SNorm
public GraphicsFormat R8G8B8_SNorm
public GraphicsFormat R8G8B8A8_SNorm
public GraphicsFormat R8_UInt
public GraphicsFormat R8G8_UInt
public GraphicsFormat R8G8B8_UInt
public GraphicsFormat R8G8B8A8_UInt
public GraphicsFormat R8_SInt
public GraphicsFormat R8G8_SInt
public GraphicsFormat R8G8B8_SInt
public GraphicsFormat R8G8B8A8_SInt
public GraphicsFormat R16_UNorm
public GraphicsFormat R16G16_UNorm
public GraphicsFormat R16G16B16_UNorm
public GraphicsFormat R16G16B16A16_UNorm
public GraphicsFormat R16_SNorm
public GraphicsFormat R16G16_SNorm
public GraphicsFormat R16G16B16_SNorm
public GraphicsFormat R16G16B16A16_SNorm
public GraphicsFormat R16_UInt
public GraphicsFormat R16G16_UInt
public GraphicsFormat R16G16B16_UInt
public GraphicsFormat R16G16B16A16_UInt
public GraphicsFormat R16_SInt
public GraphicsFormat R16G16_SInt
public GraphicsFormat R16G16B16_SInt
public GraphicsFormat R16G16B16A16_SInt
public GraphicsFormat R32_UInt
public GraphicsFormat R32G32_UInt
public GraphicsFormat R32G32B32_UInt
public GraphicsFormat R32G32B32A32_UInt
public GraphicsFormat R32_SInt
public GraphicsFormat R32G32_SInt
public GraphicsFormat R32G32B32_SInt
public GraphicsFormat R32G32B32A32_SInt
public GraphicsFormat R16_SFloat
public GraphicsFormat R16G16_SFloat
public GraphicsFormat R16G16B16_SFloat
public GraphicsFormat R16G16B16A16_SFloat
public GraphicsFormat R32_SFloat
public GraphicsFormat R32G32_SFloat
public GraphicsFormat R32G32B32_SFloat
public GraphicsFormat R32G32B32A32_SFloat
public GraphicsFormat B8G8R8_SRGB
public GraphicsFormat B8G8R8A8_SRGB
public GraphicsFormat B8G8R8_UNorm
public GraphicsFormat B8G8R8A8_UNorm
public GraphicsFormat B8G8R8_SNorm
public GraphicsFormat B8G8R8A8_SNorm
public GraphicsFormat B8G8R8_UInt
public GraphicsFormat B8G8R8A8_UInt
public GraphicsFormat B8G8R8_SInt
public GraphicsFormat B8G8R8A8_SInt
public GraphicsFormat R4G4B4A4_UNormPack16
public GraphicsFormat B4G4R4A4_UNormPack16
public GraphicsFormat R5G6B5_UNormPack16
public GraphicsFormat B5G6R5_UNormPack16
public GraphicsFormat R5G5B5A1_UNormPack16
public GraphicsFormat B5G5R5A1_UNormPack16
public GraphicsFormat A1R5G5B5_UNormPack16
public GraphicsFormat E5B9G9R9_UFloatPack32
public GraphicsFormat B10G11R11_UFloatPack32
public GraphicsFormat A2B10G10R10_UNormPack32
public GraphicsFormat A2B10G10R10_UIntPack32
public GraphicsFormat A2B10G10R10_SIntPack32
public GraphicsFormat A2R10G10B10_UNormPack32
public GraphicsFormat A2R10G10B10_UIntPack32
public GraphicsFormat A2R10G10B10_SIntPack32
public GraphicsFormat A2R10G10B10_XRSRGBPack32
public GraphicsFormat A2R10G10B10_XRUNormPack32
public GraphicsFormat R10G10B10_XRSRGBPack32
public GraphicsFormat R10G10B10_XRUNormPack32
public GraphicsFormat A10R10G10B10_XRSRGBPack32
public GraphicsFormat A10R10G10B10_XRUNormPack32
public GraphicsFormat D16_UNorm
public GraphicsFormat D24_UNorm
public GraphicsFormat D24_UNorm_S8_UInt
public GraphicsFormat D32_SFloat
public GraphicsFormat D32_SFloat_S8_UInt
public GraphicsFormat S8_UInt
public GraphicsFormat RGB_DXT1_SRGB
public GraphicsFormat RGBA_DXT1_SRGB
public GraphicsFormat RGB_DXT1_UNorm
public GraphicsFormat RGBA_DXT1_UNorm
public GraphicsFormat RGBA_DXT3_SRGB
public GraphicsFormat RGBA_DXT3_UNorm
public GraphicsFormat RGBA_DXT5_SRGB
public GraphicsFormat RGBA_DXT5_UNorm
public GraphicsFormat R_BC4_UNorm
public GraphicsFormat R_BC4_SNorm
public GraphicsFormat RG_BC5_UNorm
public GraphicsFormat RG_BC5_SNorm
public GraphicsFormat RGB_BC6H_UFloat
public GraphicsFormat RGB_BC6H_SFloat
public GraphicsFormat RGBA_BC7_SRGB
public GraphicsFormat RGBA_BC7_UNorm
public GraphicsFormat RGB_PVRTC_2Bpp_SRGB
public GraphicsFormat RGB_PVRTC_2Bpp_UNorm
public GraphicsFormat RGB_PVRTC_4Bpp_SRGB
public GraphicsFormat RGB_PVRTC_4Bpp_UNorm
public GraphicsFormat RGBA_PVRTC_2Bpp_SRGB
public GraphicsFormat RGBA_PVRTC_2Bpp_UNorm
public GraphicsFormat RGBA_PVRTC_4Bpp_SRGB
public GraphicsFormat RGBA_PVRTC_4Bpp_UNorm
public GraphicsFormat RGB_ETC_UNorm
public GraphicsFormat RGB_ETC2_SRGB
public GraphicsFormat RGB_ETC2_UNorm
public GraphicsFormat RGB_A1_ETC2_SRGB
public GraphicsFormat RGB_A1_ETC2_UNorm
public GraphicsFormat RGBA_ETC2_SRGB
public GraphicsFormat RGBA_ETC2_UNorm
public GraphicsFormat R_EAC_UNorm
public GraphicsFormat R_EAC_SNorm
public GraphicsFormat RG_EAC_UNorm
public GraphicsFormat RG_EAC_SNorm
public GraphicsFormat RGBA_ASTC4X4_SRGB
public GraphicsFormat RGBA_ASTC4X4_UNorm
public GraphicsFormat RGBA_ASTC5X5_SRGB
public GraphicsFormat RGBA_ASTC5X5_UNorm
public GraphicsFormat RGBA_ASTC6X6_SRGB
public GraphicsFormat RGBA_ASTC6X6_UNorm
public GraphicsFormat RGBA_ASTC8X8_SRGB
public GraphicsFormat RGBA_ASTC8X8_UNorm
public GraphicsFormat RGBA_ASTC10X10_SRGB
public GraphicsFormat RGBA_ASTC10X10_UNorm
public GraphicsFormat RGBA_ASTC12X12_SRGB
public GraphicsFormat RGBA_ASTC12X12_UNorm
public GraphicsFormat YUV2
public GraphicsFormat DepthAuto
public GraphicsFormat ShadowAuto
public GraphicsFormat VideoAuto
public GraphicsFormat RGBA_ASTC4X4_UFloat
public GraphicsFormat RGBA_ASTC5X5_UFloat
public GraphicsFormat RGBA_ASTC6X6_UFloat
public GraphicsFormat RGBA_ASTC8X8_UFloat
public GraphicsFormat RGBA_ASTC10X10_UFloat
public GraphicsFormat RGBA_ASTC12X12_UFloat
}
public UnityEngine.Experimental.Rendering.GraphicsFormatUtility : object {
private GraphicsFormat[] tableNoStencil
private GraphicsFormat[] tableStencil
internal GraphicsFormat GetFormat(Texture texture)
public GraphicsFormat GetGraphicsFormat(TextureFormat format, bool isSRGB)
private GraphicsFormat GetGraphicsFormat_Native_TextureFormat(TextureFormat format, bool isSRGB)
public TextureFormat GetTextureFormat(GraphicsFormat format)
private TextureFormat GetTextureFormat_Native_GraphicsFormat(GraphicsFormat format)
public GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, bool isSRGB)
private GraphicsFormat GetGraphicsFormat_Native_RenderTextureFormat(RenderTextureFormat format, bool isSRGB)
public GraphicsFormat GetGraphicsFormat(RenderTextureFormat format, RenderTextureReadWrite readWrite)
private GraphicsFormat GetDepthStencilFormatFromBitsLegacy_Native(int minimumDepthBits)
internal GraphicsFormat GetDepthStencilFormat(int minimumDepthBits)
public int GetDepthBits(GraphicsFormat format)
public GraphicsFormat GetDepthStencilFormat(int minimumDepthBits, int minimumStencilBits)
public bool IsSRGBFormat(GraphicsFormat format)
public bool IsSwizzleFormat(GraphicsFormat format)
public GraphicsFormat GetSRGBFormat(GraphicsFormat format)
public GraphicsFormat GetLinearFormat(GraphicsFormat format)
public RenderTextureFormat GetRenderTextureFormat(GraphicsFormat format)
public UInt32 GetColorComponentCount(GraphicsFormat format)
public UInt32 GetAlphaComponentCount(GraphicsFormat format)
public UInt32 GetComponentCount(GraphicsFormat format)
public string GetFormatString(GraphicsFormat format)
public bool IsCompressedFormat(GraphicsFormat format)
internal bool IsCompressedTextureFormat(TextureFormat format)
private bool CanDecompressFormat(GraphicsFormat format, bool wholeImage)
internal bool CanDecompressFormat(GraphicsFormat format)
public bool IsPackedFormat(GraphicsFormat format)
public bool Is16BitPackedFormat(GraphicsFormat format)
public GraphicsFormat ConvertToAlphaFormat(GraphicsFormat format)
public bool IsAlphaOnlyFormat(GraphicsFormat format)
public bool IsAlphaTestFormat(GraphicsFormat format)
public bool HasAlphaChannel(GraphicsFormat format)
public bool IsDepthFormat(GraphicsFormat format)
public bool IsStencilFormat(GraphicsFormat format)
public bool IsIEEE754Format(GraphicsFormat format)
public bool IsFloatFormat(GraphicsFormat format)
public bool IsHalfFormat(GraphicsFormat format)
public bool IsUnsignedFormat(GraphicsFormat format)
public bool IsSignedFormat(GraphicsFormat format)
public bool IsNormFormat(GraphicsFormat format)
public bool IsUNormFormat(GraphicsFormat format)
public bool IsSNormFormat(GraphicsFormat format)
public bool IsIntegerFormat(GraphicsFormat format)
public bool IsUIntFormat(GraphicsFormat format)
public bool IsSIntFormat(GraphicsFormat format)
public bool IsXRFormat(GraphicsFormat format)
public bool IsDXTCFormat(GraphicsFormat format)
public bool IsRGTCFormat(GraphicsFormat format)
public bool IsBPTCFormat(GraphicsFormat format)
public bool IsBCFormat(GraphicsFormat format)
public bool IsPVRTCFormat(GraphicsFormat format)
public bool IsETCFormat(GraphicsFormat format)
public bool IsEACFormat(GraphicsFormat format)
public bool IsASTCFormat(GraphicsFormat format)
public bool IsCrunchFormat(TextureFormat format)
public FormatSwizzle GetSwizzleR(GraphicsFormat format)
public FormatSwizzle GetSwizzleG(GraphicsFormat format)
public FormatSwizzle GetSwizzleB(GraphicsFormat format)
public FormatSwizzle GetSwizzleA(GraphicsFormat format)
public UInt32 GetBlockSize(GraphicsFormat format)
public UInt32 GetBlockWidth(GraphicsFormat format)
public UInt32 GetBlockHeight(GraphicsFormat format)
public UInt32 ComputeMipmapSize(int width, int height, GraphicsFormat format)
private UInt32 ComputeMipmapSize_Native_2D(int width, int height, GraphicsFormat format)
public UInt32 ComputeMipmapSize(int width, int height, int depth, GraphicsFormat format)
private UInt32 ComputeMipmapSize_Native_3D(int width, int height, int depth, GraphicsFormat format)
}
public UnityEngine.Experimental.Rendering.GraphicsJobsSyncPoint : Enum {
public int value__
public GraphicsJobsSyncPoint EndOfFrame
public GraphicsJobsSyncPoint AfterScriptUpdate
public GraphicsJobsSyncPoint AfterScriptLateUpdate
public GraphicsJobsSyncPoint WaitForPresent
}
public UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem {
public bool TickRealtimeProbes()
}
public UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure : object {
internal IntPtr m_Ptr
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
public void .ctor(RASSettings settings)
private IntPtr Create(RASSettings desc)
private void Destroy(RayTracingAccelerationStructure accelStruct)
public void Release()
public void Build()
public void Update()
public void Build(Vector3 relativeOrigin)
public void Update(Vector3 relativeOrigin)
public void AddInstance(Renderer targetRenderer, Boolean[] subMeshMask, Boolean[] subMeshTransparencyFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id)
public void AddInstance(Renderer targetRenderer, RayTracingSubMeshFlags[] subMeshFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id)
public void RemoveInstance(Renderer targetRenderer)
public void AddInstance(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id)
public void AddInstance(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4 instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id)
private void AddInstance_Procedural(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4 instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id)
public void UpdateInstanceTransform(Renderer renderer)
public void UpdateInstanceMask(Renderer renderer, UInt32 mask)
public void UpdateInstanceID(Renderer renderer, UInt32 instanceID)
public ulong GetSize()
public UInt32 GetInstanceCount()
private void AddInstanceSubMeshFlagsArray(Renderer targetRenderer, RayTracingSubMeshFlags[] subMeshFlags, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, UInt32 id)
private IntPtr Create_Injected(RASSettings& desc)
private void Build_Injected(Vector3& relativeOrigin)
private void Update_Injected(Vector3& relativeOrigin)
private void AddInstance_Procedural_Injected(GraphicsBuffer aabbBuffer, UInt32 numElements, Material material, Matrix4x4& instanceTransform, bool isCutOff, bool enableTriangleCulling, bool frontTriangleCounterClockwise, UInt32 mask, bool reuseBounds, UInt32 id)
}
public UnityEngine.Experimental.Rendering.RayTracingMode : Enum {
public int value__
public RayTracingMode Off
public RayTracingMode Static
public RayTracingMode DynamicTransform
public RayTracingMode DynamicGeometry
}
public UnityEngine.Experimental.Rendering.RayTracingShader : Object {
public float maxRecursionDepth
public float get_maxRecursionDepth()
public void SetFloat(int nameID, float val)
public void SetInt(int nameID, int val)
public void SetVector(int nameID, Vector4 val)
public void SetMatrix(int nameID, Matrix4x4 val)
private void SetFloatArray(int nameID, Single[] values)
private void SetIntArray(int nameID, Int32[] values)
public void SetVectorArray(int nameID, Vector4[] values)
public void SetMatrixArray(int nameID, Matrix4x4[] values)
public void SetTexture(int nameID, Texture texture)
public void SetBuffer(int nameID, ComputeBuffer buffer)
private void SetGraphicsBuffer(int nameID, GraphicsBuffer buffer)
private void SetConstantComputeBuffer(int nameID, ComputeBuffer buffer, int offset, int size)
private void SetConstantGraphicsBuffer(int nameID, GraphicsBuffer buffer, int offset, int size)
public void SetAccelerationStructure(int nameID, RayTracingAccelerationStructure accelerationStructure)
public void SetShaderPass(string passName)
public void SetTextureFromGlobal(int nameID, int globalTextureNameID)
public void Dispatch(string rayGenFunctionName, int width, int height, int depth, Camera camera)
public void SetBuffer(int nameID, GraphicsBuffer buffer)
public void SetFloat(string name, float val)
public void SetInt(string name, int val)
public void SetVector(string name, Vector4 val)
public void SetMatrix(string name, Matrix4x4 val)
public void SetVectorArray(string name, Vector4[] values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetFloats(string name, Single[] values)
public void SetFloats(int nameID, Single[] values)
public void SetInts(string name, Int32[] values)
public void SetInts(int nameID, Int32[] values)
public void SetBool(string name, bool val)
public void SetBool(int nameID, bool val)
public void SetTexture(string name, Texture texture)
public void SetBuffer(string name, ComputeBuffer buffer)
public void SetBuffer(string name, GraphicsBuffer buffer)
public void SetConstantBuffer(int nameID, ComputeBuffer buffer, int offset, int size)
public void SetConstantBuffer(string name, ComputeBuffer buffer, int offset, int size)
public void SetConstantBuffer(int nameID, GraphicsBuffer buffer, int offset, int size)
public void SetConstantBuffer(string name, GraphicsBuffer buffer, int offset, int size)
public void SetAccelerationStructure(string name, RayTracingAccelerationStructure accelerationStructure)
public void SetTextureFromGlobal(string name, string globalTextureName)
private void SetVector_Injected(int nameID, Vector4& val)
private void SetMatrix_Injected(int nameID, Matrix4x4& val)
}
public UnityEngine.Experimental.Rendering.RayTracingSubMeshFlags : Enum {
public int value__
public RayTracingSubMeshFlags Disabled
public RayTracingSubMeshFlags Enabled
public RayTracingSubMeshFlags ClosestHitOnly
public RayTracingSubMeshFlags UniqueAnyHitCalls
}
public UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystem : object {
public bool TickRealtimeProbes()
protected void Dispose(bool disposing)
private void System.IDisposable.Dispose()
}
public UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystemSettings : object {
private ScriptableRuntimeReflectionSystemWrapper s_Instance
public IScriptableRuntimeReflectionSystem system
private IScriptableRuntimeReflectionSystem Internal_ScriptableRuntimeReflectionSystemSettings_system
private ScriptableRuntimeReflectionSystemWrapper Internal_ScriptableRuntimeReflectionSystemSettings_instance
public IScriptableRuntimeReflectionSystem get_system()
public void set_system(IScriptableRuntimeReflectionSystem value)
private IScriptableRuntimeReflectionSystem get_Internal_ScriptableRuntimeReflectionSystemSettings_system()
private void set_Internal_ScriptableRuntimeReflectionSystemSettings_system(IScriptableRuntimeReflectionSystem value)
private ScriptableRuntimeReflectionSystemWrapper get_Internal_ScriptableRuntimeReflectionSystemSettings_instance()
private void ScriptingDirtyReflectionSystemInstance()
}
internal UnityEngine.Experimental.Rendering.ScriptableRuntimeReflectionSystemWrapper : object {
private IScriptableRuntimeReflectionSystem <implementation>k__BackingField
internal IScriptableRuntimeReflectionSystem implementation
internal IScriptableRuntimeReflectionSystem get_implementation()
internal void set_implementation(IScriptableRuntimeReflectionSystem value)
private void Internal_ScriptableRuntimeReflectionSystemWrapper_TickRealtimeProbes(Boolean& result)
}
public UnityEngine.Experimental.Rendering.ShaderWarmup : object {
public void WarmupShader(Shader shader, ShaderWarmupSetup setup)
public void WarmupShaderFromCollection(ShaderVariantCollection collection, Shader shader, ShaderWarmupSetup setup)
private void WarmupShader_Injected(Shader shader, ShaderWarmupSetup& setup)
private void WarmupShaderFromCollection_Injected(ShaderVariantCollection collection, Shader shader, ShaderWarmupSetup& setup)
}
public UnityEngine.Experimental.Rendering.ShaderWarmupSetup : ValueType {
public VertexAttributeDescriptor[] vdecl
}
public UnityEngine.Experimental.Rendering.TextureCreationFlags : Enum {
public int value__
public TextureCreationFlags None
public TextureCreationFlags MipChain
public TextureCreationFlags Crunch
}
public UnityEngine.Experimental.Rendering.WaitForPresentSyncPoint : Enum {
public int value__
public WaitForPresentSyncPoint BeginFrame
public WaitForPresentSyncPoint EndFrame
}
internal UnityEngine.Experimental.U2D.SpriteIntermediateRendererInfo : ValueType {
public int SpriteID
public int TextureID
public int MaterialID
public Color Color
public Matrix4x4 Transform
public Bounds Bounds
public int Layer
public int SortingLayer
public int SortingOrder
public ulong SceneCullingMask
public IntPtr IndexData
public IntPtr VertexData
public int IndexCount
public int VertexCount
public int ShaderChannelMask
}
internal UnityEngine.Experimental.U2D.SpriteRendererGroup : object {
public void AddRenderers(NativeArray`1<SpriteIntermediateRendererInfo> renderers)
private void AddRenderers(Void* renderers, int count)
public void Clear()
}
public UnityEngine.ExposedPropertyResolver : ValueType {
internal IntPtr table
internal Object ResolveReferenceInternal(IntPtr ptr, PropertyName name, Boolean& isValid)
private Object ResolveReferenceBindingsInternal(IntPtr ptr, PropertyName name, Boolean& isValid)
private Object ResolveReferenceBindingsInternal_Injected(IntPtr ptr, PropertyName& name, Boolean& isValid)
}
public UnityEngine.ExposedReference`1 : ValueType {
public PropertyName exposedName
public Object defaultValue
public T Resolve(IExposedPropertyTable resolver)
}
public UnityEngine.FilterMode : Enum {
public int value__
public FilterMode Point
public FilterMode Bilinear
public FilterMode Trilinear
}
public UnityEngine.FindObjectsInactive : Enum {
public int value__
public FindObjectsInactive Exclude
public FindObjectsInactive Include
}
public UnityEngine.FindObjectsSortMode : Enum {
public int value__
public FindObjectsSortMode None
public FindObjectsSortMode InstanceID
}
public UnityEngine.Flare : Object {
private void Internal_Create(Flare self)
}
public UnityEngine.FogMode : Enum {
public int value__
public FogMode Linear
public FogMode Exponential
public FogMode ExponentialSquared
}
public UnityEngine.FrameDebugger : object {
public bool enabled
public bool get_enabled()
internal bool IsLocalEnabled()
internal bool IsRemoteEnabled()
}
public UnityEngine.FrameTiming : ValueType {
public ulong cpuTimePresentCalled
public double cpuFrameTime
public ulong cpuTimeFrameComplete
public double gpuFrameTime
public float heightScale
public float widthScale
public UInt32 syncInterval
}
public UnityEngine.FrameTimingManager : object {
public void CaptureFrameTimings()
public UInt32 GetLatestTimings(UInt32 numFrames, FrameTiming[] timings)
public float GetVSyncsPerSecond()
public ulong GetGpuTimerFrequency()
public ulong GetCpuTimerFrequency()
}
public UnityEngine.FrustumPlanes : ValueType {
public float left
public float right
public float bottom
public float top
public float zNear
public float zFar
}
public UnityEngine.FullScreenMode : Enum {
public int value__
public FullScreenMode ExclusiveFullScreen
public FullScreenMode FullScreenWindow
public FullScreenMode MaximizedWindow
public FullScreenMode Windowed
}
public UnityEngine.GameObject : Object {
public Transform transform
public int layer
public bool active
public bool activeSelf
public bool activeInHierarchy
public bool isStatic
internal bool isStaticBatchable
public string tag
public Scene scene
public ulong sceneCullingMask
public GameObject gameObject
public GameObject CreatePrimitive(PrimitiveType type)
public T GetComponent()
public Component GetComponent(Type type)
internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue)
internal Component GetComponentByName(string type)
public Component GetComponent(string type)
public Component GetComponentInChildren(Type type, bool includeInactive)
public Component GetComponentInChildren(Type type)
public T GetComponentInChildren()
public T GetComponentInChildren(bool includeInactive)
public Component GetComponentInParent(Type type, bool includeInactive)
public Component GetComponentInParent(Type type)
public T GetComponentInParent()
public T GetComponentInParent(bool includeInactive)
private Array GetComponentsInternal(Type type, bool useSearchTypeAsArrayReturnType, bool recursive, bool includeInactive, bool reverse, object resultList)
public Component[] GetComponents(Type type)
public T[] GetComponents()
public void GetComponents(Type type, List`1<Component> results)
public void GetComponents(List`1<T> results)
public Component[] GetComponentsInChildren(Type type)
public Component[] GetComponentsInChildren(Type type, bool includeInactive)
public T[] GetComponentsInChildren(bool includeInactive)
public void GetComponentsInChildren(bool includeInactive, List`1<T> results)
public T[] GetComponentsInChildren()
public void GetComponentsInChildren(List`1<T> results)
public Component[] GetComponentsInParent(Type type)
public Component[] GetComponentsInParent(Type type, bool includeInactive)
public void GetComponentsInParent(bool includeInactive, List`1<T> results)
public T[] GetComponentsInParent(bool includeInactive)
public T[] GetComponentsInParent()
public bool TryGetComponent(T& component)
public bool TryGetComponent(Type type, Component& component)
internal Component TryGetComponentInternal(Type type)
internal void TryGetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue)
public GameObject FindWithTag(string tag)
public void SendMessageUpwards(string methodName, SendMessageOptions options)
public void SendMessage(string methodName, SendMessageOptions options)
public void BroadcastMessage(string methodName, SendMessageOptions options)
internal Component AddComponentInternal(string className)
private Component Internal_AddComponentWithType(Type componentType)
public Component AddComponent(Type componentType)
public T AddComponent()
public Transform get_transform()
public int get_layer()
public void set_layer(int value)
public bool get_active()
public void set_active(bool value)
public void SetActive(bool value)
public bool get_activeSelf()
public bool get_activeInHierarchy()
public void SetActiveRecursively(bool state)
public bool get_isStatic()
public void set_isStatic(bool value)
internal bool get_isStaticBatchable()
public string get_tag()
public void set_tag(string value)
public bool CompareTag(string tag)
public GameObject FindGameObjectWithTag(string tag)
public GameObject[] FindGameObjectsWithTag(string tag)
public void SendMessageUpwards(string methodName, object value, SendMessageOptions options)
public void SendMessageUpwards(string methodName, object value)
public void SendMessageUpwards(string methodName)
public void SendMessage(string methodName, object value, SendMessageOptions options)
public void SendMessage(string methodName, object value)
public void SendMessage(string methodName)
public void BroadcastMessage(string methodName, object parameter, SendMessageOptions options)
public void BroadcastMessage(string methodName, object parameter)
public void BroadcastMessage(string methodName)
public void .ctor(string name)
public void .ctor(string name, Type[] components)
private void Internal_CreateGameObject(GameObject self, string name)
public GameObject Find(string name)
public Scene get_scene()
public ulong get_sceneCullingMask()
public GameObject get_gameObject()
private void get_scene_Injected(Scene& ret)
}
public UnityEngine.GeometryUtility : object {
public Plane[] CalculateFrustumPlanes(Camera camera)
public Plane[] CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix)
public void CalculateFrustumPlanes(Camera camera, Plane[] planes)
public void CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix, Plane[] planes)
public Bounds CalculateBounds(Vector3[] positions, Matrix4x4 transform)
public bool TryCreatePlaneFromPolygon(Vector3[] vertices, Plane& plane)
public bool TestPlanesAABB(Plane[] planes, Bounds bounds)
private void Internal_ExtractPlanes(Plane[] planes, Matrix4x4 worldToProjectionMatrix)
private Bounds Internal_CalculateBounds(Vector3[] positions, Matrix4x4 transform)
private bool TestPlanesAABB_Injected(Plane[] planes, Bounds& bounds)
private void Internal_ExtractPlanes_Injected(Plane[] planes, Matrix4x4& worldToProjectionMatrix)
private void Internal_CalculateBounds_Injected(Vector3[] positions, Matrix4x4& transform, Bounds& ret)
}
public UnityEngine.Gizmos : object {
public Color color
public Matrix4x4 matrix
public Texture exposure
public float probeSize
public void DrawLine(Vector3 from, Vector3 to)
public void DrawWireSphere(Vector3 center, float radius)
public void DrawSphere(Vector3 center, float radius)
public void DrawWireCube(Vector3 center, Vector3 size)
public void DrawCube(Vector3 center, Vector3 size)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawIcon(Vector3 center, string name, bool allowScaling)
public void DrawIcon(Vector3 center, string name, bool allowScaling, Color tint)
public void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public Color get_color()
public void set_color(Color value)
public Matrix4x4 get_matrix()
public void set_matrix(Matrix4x4 value)
public Texture get_exposure()
public void set_exposure(Texture value)
public float get_probeSize()
public void DrawFrustum(Vector3 center, float fov, float maxRange, float minRange, float aspect)
public void DrawRay(Ray r)
public void DrawRay(Vector3 from, Vector3 direction)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawMesh(Mesh mesh, Vector3 position)
public void DrawMesh(Mesh mesh)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation)
public void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position)
public void DrawMesh(Mesh mesh, int submeshIndex)
public void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawWireMesh(Mesh mesh, Vector3 position)
public void DrawWireMesh(Mesh mesh)
public void DrawWireMesh(Mesh mesh, Vector3 position, Quaternion rotation, Vector3 scale)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position, Quaternion rotation)
public void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position)
public void DrawWireMesh(Mesh mesh, int submeshIndex)
public void DrawIcon(Vector3 center, string name)
public void DrawGUITexture(Rect screenRect, Texture texture)
public void DrawGUITexture(Rect screenRect, Texture texture, Material mat)
public void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
private void DrawLine_Injected(Vector3& from, Vector3& to)
private void DrawWireSphere_Injected(Vector3& center, float radius)
private void DrawSphere_Injected(Vector3& center, float radius)
private void DrawWireCube_Injected(Vector3& center, Vector3& size)
private void DrawCube_Injected(Vector3& center, Vector3& size)
private void DrawMesh_Injected(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale)
private void DrawWireMesh_Injected(Mesh mesh, int submeshIndex, Vector3& position, Quaternion& rotation, Vector3& scale)
private void DrawIcon_Injected(Vector3& center, string name, bool allowScaling, Color& tint)
private void DrawGUITexture_Injected(Rect& screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
private void get_matrix_Injected(Matrix4x4& ret)
private void set_matrix_Injected(Matrix4x4& value)
private void DrawFrustum_Injected(Vector3& center, float fov, float maxRange, float minRange, float aspect)
}
public UnityEngine.GL : object {
public int TRIANGLES
public int TRIANGLE_STRIP
public int QUADS
public int LINES
public int LINE_STRIP
public bool wireframe
public bool sRGBWrite
public bool invertCulling
public Matrix4x4 modelview
public void Vertex3(float x, float y, float z)
public void Vertex(Vector3 v)
internal void Vertices(Vector3* v, Vector3* coords, Vector4* colors, int length)
public void TexCoord3(float x, float y, float z)
public void TexCoord(Vector3 v)
public void TexCoord2(float x, float y)
public void MultiTexCoord3(int unit, float x, float y, float z)
public void MultiTexCoord(int unit, Vector3 v)
public void MultiTexCoord2(int unit, float x, float y)
private void ImmediateColor(float r, float g, float b, float a)
public void Color(Color c)
public bool get_wireframe()
public void set_wireframe(bool value)
public bool get_sRGBWrite()
public void set_sRGBWrite(bool value)
public bool get_invertCulling()
public void set_invertCulling(bool value)
public void Flush()
public void RenderTargetBarrier()
private Matrix4x4 GetWorldViewMatrix()
private void SetViewMatrix(Matrix4x4 m)
public Matrix4x4 get_modelview()
public void set_modelview(Matrix4x4 value)
public void MultMatrix(Matrix4x4 m)
public void IssuePluginEvent(int eventID)
public void SetRevertBackfacing(bool revertBackFaces)
public void PushMatrix()
public void PopMatrix()
public void LoadIdentity()
public void LoadOrtho()
public void LoadPixelMatrix()
public void LoadProjectionMatrix(Matrix4x4 mat)
public void InvalidateState()
public Matrix4x4 GetGPUProjectionMatrix(Matrix4x4 proj, bool renderIntoTexture)
private void GLLoadPixelMatrixScript(float left, float right, float bottom, float top)
public void LoadPixelMatrix(float left, float right, float bottom, float top)
private void GLIssuePluginEvent(IntPtr callback, int eventID)
public void IssuePluginEvent(IntPtr callback, int eventID)
public void Begin(int mode)
public void End()
private void GLClear(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void Clear(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void Clear(bool clearDepth, bool clearColor, Color backgroundColor)
public void Viewport(Rect pixelRect)
public void ClearWithSkybox(bool clearDepth, Camera camera)
private void GetWorldViewMatrix_Injected(Matrix4x4& ret)
private void SetViewMatrix_Injected(Matrix4x4& m)
private void MultMatrix_Injected(Matrix4x4& m)
private void LoadProjectionMatrix_Injected(Matrix4x4& mat)
private void GetGPUProjectionMatrix_Injected(Matrix4x4& proj, bool renderIntoTexture, Matrix4x4& ret)
private void GLClear_Injected(bool clearDepth, bool clearColor, Color& backgroundColor, float depth)
private void Viewport_Injected(Rect& pixelRect)
}
public UnityEngine.Gradient : object {
internal IntPtr m_Ptr
public GradientColorKey[] colorKeys
public GradientAlphaKey[] alphaKeys
public GradientMode mode
private IntPtr Init()
private void Cleanup()
private bool Internal_Equals(IntPtr other)
protected void Finalize()
public Color Evaluate(float time)
public GradientColorKey[] get_colorKeys()
public void set_colorKeys(GradientColorKey[] value)
public GradientAlphaKey[] get_alphaKeys()
public void set_alphaKeys(GradientAlphaKey[] value)
public GradientMode get_mode()
public void set_mode(GradientMode value)
public void SetKeys(GradientColorKey[] colorKeys, GradientAlphaKey[] alphaKeys)
public bool Equals(object o)
public bool Equals(Gradient other)
public int GetHashCode()
private void Evaluate_Injected(float time, Color& ret)
}
public UnityEngine.GradientAlphaKey : ValueType {
public float alpha
public float time
public void .ctor(float alpha, float time)
}
public UnityEngine.GradientColorKey : ValueType {
public Color color
public float time
public void .ctor(Color col, float time)
}
public UnityEngine.GradientMode : Enum {
public int value__
public GradientMode Blend
public GradientMode Fixed
}
public UnityEngine.GradientUsageAttribute : PropertyAttribute {
public bool hdr
public ColorSpace colorSpace
public void .ctor(bool hdr)
public void .ctor(bool hdr, ColorSpace colorSpace)
}
public UnityEngine.Graphics : object {
internal int kMaxDrawMeshInstanceCount
internal Dictionary`2<int, RenderInstancedDataLayout> s_RenderInstancedDataLayouts
public ColorGamut activeColorGamut
public GraphicsTier activeTier
public bool preserveFramebufferAlpha
public OpenGLESVersion minOpenGLESVersion
public RenderBuffer activeColorBuffer
public RenderBuffer activeDepthBuffer
private int Internal_GetMaxDrawMeshInstanceCount()
private ColorGamut GetActiveColorGamut()
public ColorGamut get_activeColorGamut()
public GraphicsTier get_activeTier()
public void set_activeTier(GraphicsTier value)
internal bool GetPreserveFramebufferAlpha()
public bool get_preserveFramebufferAlpha()
internal OpenGLESVersion GetMinOpenGLESVersion()
public OpenGLESVersion get_minOpenGLESVersion()
private RenderBuffer GetActiveColorBuffer()
private RenderBuffer GetActiveDepthBuffer()
private void Internal_SetNullRT()
private void Internal_SetRTSimple(RenderBuffer color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice)
private void Internal_SetMRTSimple(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice)
private void Internal_SetMRTFullSetup(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, int depthSlice, RenderBufferLoadAction[] colorLA, RenderBufferStoreAction[] colorSA, RenderBufferLoadAction depthLA, RenderBufferStoreAction depthSA)
private void Internal_SetRandomWriteTargetRT(int index, RenderTexture uav)
private void Internal_SetRandomWriteTargetBuffer(int index, ComputeBuffer uav, bool preserveCounterValue)
private void Internal_SetRandomWriteTargetGraphicsBuffer(int index, GraphicsBuffer uav, bool preserveCounterValue)
public void ClearRandomWriteTargets()
private void CopyTexture_Full(Texture src, Texture dst)
private void CopyTexture_Slice_AllMips(Texture src, int srcElement, Texture dst, int dstElement)
private void CopyTexture_Slice(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip)
private void CopyTexture_Region(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY)
private bool ConvertTexture_Full(Texture src, Texture dst)
private bool ConvertTexture_Slice(Texture src, int srcElement, Texture dst, int dstElement)
private void CopyBufferImpl(GraphicsBuffer source, GraphicsBuffer dest)
private void Internal_DrawMeshNow1(Mesh mesh, int subsetIndex, Vector3 position, Quaternion rotation)
private void Internal_DrawMeshNow2(Mesh mesh, int subsetIndex, Matrix4x4 matrix)
internal void Internal_DrawTexture(Internal_DrawTextureArguments& args)
private void Internal_RenderMesh(RenderParams rparams, Mesh mesh, int submeshIndex, Matrix4x4 objectToWorld, Matrix4x4* prevObjectToWorld)
private void Internal_RenderMeshInstanced(RenderParams rparams, Mesh mesh, int submeshIndex, IntPtr instanceData, RenderInstancedDataLayout layout, UInt32 instanceCount)
private void Internal_RenderMeshIndirect(RenderParams rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_RenderMeshPrimitives(RenderParams rparams, Mesh mesh, int submeshIndex, int instanceCount)
private void Internal_RenderPrimitives(RenderParams rparams, MeshTopology topology, int vertexCount, int instanceCount)
private void Internal_RenderPrimitivesIndexed(RenderParams rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount)
private void Internal_RenderPrimitivesIndirect(RenderParams rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_RenderPrimitivesIndexedIndirect(RenderParams rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_DrawMesh(Mesh mesh, int submeshIndex, Matrix4x4 matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, Bounds bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedIndirectGraphicsBuffer(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawProceduralNow(MeshTopology topology, int vertexCount, int instanceCount)
private void Internal_DrawProceduralIndexedNow(MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount)
private void Internal_DrawProceduralIndirectNow(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
private void Internal_DrawProceduralIndexedIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset)
private void Internal_DrawProceduralIndirectNowGraphicsBuffer(MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset)
private void Internal_DrawProceduralIndexedIndirectNowGraphicsBuffer(MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset)
private void Internal_DrawProcedural(Material material, Bounds bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexed(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndirectGraphicsBuffer(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexedIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_BlitMaterial5(Texture source, RenderTexture dest, Material mat, int pass, bool setRT)
private void Internal_BlitMaterial6(Texture source, RenderTexture dest, Material mat, int pass, bool setRT, int destDepthSlice)
private void Internal_BlitMultiTap4(Texture source, RenderTexture dest, Material mat, Vector2[] offsets)
private void Internal_BlitMultiTap5(Texture source, RenderTexture dest, Material mat, Vector2[] offsets, int destDepthSlice)
private void Blit2(Texture source, RenderTexture dest)
private void Blit3(Texture source, RenderTexture dest, int sourceDepthSlice, int destDepthSlice)
private void Blit4(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset)
private void Blit5(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice)
private IntPtr CreateGPUFenceImpl(GraphicsFenceType fenceType, SynchronisationStageFlags stage)
private void WaitOnGPUFenceImpl(IntPtr fencePtr, SynchronisationStageFlags stage)
public void ExecuteCommandBuffer(CommandBuffer buffer)
public void ExecuteCommandBufferAsync(CommandBuffer buffer, ComputeQueueType queueType)
internal void CheckLoadActionValid(RenderBufferLoadAction load, string bufferType)
internal void CheckStoreActionValid(RenderBufferStoreAction store, string bufferType)
internal void SetRenderTargetImpl(RenderTargetSetup setup)
internal void SetRenderTargetImpl(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
internal void SetRenderTargetImpl(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice)
internal void SetRenderTargetImpl(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face, int depthSlice)
public void SetRenderTarget(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer)
public void SetRenderTarget(RenderTargetSetup setup)
public RenderBuffer get_activeColorBuffer()
public RenderBuffer get_activeDepthBuffer()
public void SetRandomWriteTarget(int index, RenderTexture uav)
public void SetRandomWriteTarget(int index, ComputeBuffer uav, bool preserveCounterValue)
public void SetRandomWriteTarget(int index, GraphicsBuffer uav, bool preserveCounterValue)
public void CopyTexture(Texture src, Texture dst)
public void CopyTexture(Texture src, int srcElement, Texture dst, int dstElement)
public void CopyTexture(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip)
public void CopyTexture(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY)
public bool ConvertTexture(Texture src, Texture dst)
public bool ConvertTexture(Texture src, int srcElement, Texture dst, int dstElement)
public GraphicsFence CreateAsyncGraphicsFence(SynchronisationStage stage)
public GraphicsFence CreateAsyncGraphicsFence()
public GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, SynchronisationStageFlags stage)
public void WaitOnAsyncGraphicsFence(GraphicsFence fence)
public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStage stage)
internal void ValidateCopyBuffer(GraphicsBuffer source, GraphicsBuffer dest)
public void CopyBuffer(GraphicsBuffer source, GraphicsBuffer dest)
private void DrawTextureImpl(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat, int pass)
public void DrawTexture(Rect screenRect, Texture texture, Material mat, int pass)
public void RenderMesh(RenderParams& rparams, Mesh mesh, int submeshIndex, Matrix4x4 objectToWorld, Nullable`1<Matrix4x4> prevObjectToWorld)
private RenderInstancedDataLayout GetCachedRenderInstancedDataLayout(Type type)
public void RenderMeshInstanced(RenderParams& rparams, Mesh mesh, int submeshIndex, T[] instanceData, int instanceCount, int startInstance)
public void RenderMeshInstanced(RenderParams& rparams, Mesh mesh, int submeshIndex, List`1<T> instanceData, int instanceCount, int startInstance)
public void RenderMeshInstanced(RenderParams rparams, Mesh mesh, int submeshIndex, NativeArray`1<T> instanceData, int instanceCount, int startInstance)
public void RenderMeshIndirect(RenderParams& rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
public void RenderMeshPrimitives(RenderParams& rparams, Mesh mesh, int submeshIndex, int instanceCount)
public void RenderPrimitives(RenderParams& rparams, MeshTopology topology, int vertexCount, int instanceCount)
public void RenderPrimitivesIndexed(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount)
public void RenderPrimitivesIndirect(RenderParams& rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
public void RenderPrimitivesIndexedIndirect(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
public void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex)
public void DrawMeshNow(Mesh mesh, Matrix4x4 matrix, int materialIndex)
public void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation)
public void DrawMeshNow(Mesh mesh, Matrix4x4 matrix)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, Bounds bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
public void DrawProceduralNow(MeshTopology topology, int vertexCount, int instanceCount)
public void DrawProceduralNow(MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount)
public void DrawProceduralIndirectNow(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirectNow(MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset)
public void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawProcedural(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawProceduralIndirect(Material material, Bounds bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void Blit(Texture source, RenderTexture dest)
public void Blit(Texture source, RenderTexture dest, int sourceDepthSlice, int destDepthSlice)
public void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset)
public void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice)
public void Blit(Texture source, RenderTexture dest, Material mat, int pass)
public void Blit(Texture source, RenderTexture dest, Material mat, int pass, int destDepthSlice)
public void Blit(Texture source, RenderTexture dest, Material mat)
public void Blit(Texture source, Material mat, int pass)
public void Blit(Texture source, Material mat, int pass, int destDepthSlice)
public void Blit(Texture source, Material mat)
public void BlitMultiTap(Texture source, RenderTexture dest, Material mat, Vector2[] offsets)
public void BlitMultiTap(Texture source, RenderTexture dest, Material mat, int destDepthSlice, Vector2[] offsets)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, bool castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, bool useLightProbes)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List`1<Matrix4x4> matrices, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat)
public void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder)
public void DrawTexture(Rect screenRect, Texture texture, Material mat)
public void DrawTexture(Rect screenRect, Texture texture)
public void SetRenderTarget(RenderTexture rt)
public void SetRenderTarget(RenderTexture rt, int mipLevel)
public void SetRenderTarget(RenderTexture rt, int mipLevel, CubemapFace face)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel)
public void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel, CubemapFace face)
public void SetRandomWriteTarget(int index, ComputeBuffer uav)
public void SetRandomWriteTarget(int index, GraphicsBuffer uav)
private void GetActiveColorBuffer_Injected(RenderBuffer& ret)
private void GetActiveDepthBuffer_Injected(RenderBuffer& ret)
private void Internal_SetRTSimple_Injected(RenderBuffer& color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice)
private void Internal_SetMRTSimple_Injected(RenderBuffer[] color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice)
private void Internal_SetMRTFullSetup_Injected(RenderBuffer[] color, RenderBuffer& depth, int mip, CubemapFace face, int depthSlice, RenderBufferLoadAction[] colorLA, RenderBufferStoreAction[] colorSA, RenderBufferLoadAction depthLA, RenderBufferStoreAction depthSA)
private void Internal_DrawMeshNow1_Injected(Mesh mesh, int subsetIndex, Vector3& position, Quaternion& rotation)
private void Internal_DrawMeshNow2_Injected(Mesh mesh, int subsetIndex, Matrix4x4& matrix)
private void Internal_RenderMesh_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, Matrix4x4& objectToWorld, Matrix4x4* prevObjectToWorld)
private void Internal_RenderMeshInstanced_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, IntPtr instanceData, RenderInstancedDataLayout& layout, UInt32 instanceCount)
private void Internal_RenderMeshIndirect_Injected(RenderParams& rparams, Mesh mesh, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_RenderMeshPrimitives_Injected(RenderParams& rparams, Mesh mesh, int submeshIndex, int instanceCount)
private void Internal_RenderPrimitives_Injected(RenderParams& rparams, MeshTopology topology, int vertexCount, int instanceCount)
private void Internal_RenderPrimitivesIndexed_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int startIndex, int instanceCount)
private void Internal_RenderPrimitivesIndirect_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_RenderPrimitivesIndexedIndirect_Injected(RenderParams& rparams, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer commandBuffer, int commandCount, int startCommand)
private void Internal_DrawMesh_Injected(Mesh mesh, int submeshIndex, Matrix4x4& matrix, Material material, int layer, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, Transform probeAnchor, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedProcedural_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, int count, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedIndirect_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawMeshInstancedIndirectGraphicsBuffer_Injected(Mesh mesh, int submeshIndex, Material material, Bounds& bounds, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer, Camera camera, LightProbeUsage lightProbeUsage, LightProbeProxyVolume lightProbeProxyVolume)
private void Internal_DrawProcedural_Injected(Material material, Bounds& bounds, MeshTopology topology, int vertexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexed_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, int indexCount, int instanceCount, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndirect_Injected(Material material, Bounds& bounds, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndirectGraphicsBuffer_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexedIndirect_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, ComputeBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer_Injected(Material material, Bounds& bounds, MeshTopology topology, GraphicsBuffer indexBuffer, GraphicsBuffer bufferWithArgs, int argsOffset, Camera camera, MaterialPropertyBlock properties, ShadowCastingMode castShadows, bool receiveShadows, int layer)
private void Blit4_Injected(Texture source, RenderTexture dest, Vector2& scale, Vector2& offset)
private void Blit5_Injected(Texture source, RenderTexture dest, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice)
}
public UnityEngine.GraphicsBuffer : object {
internal IntPtr m_Ptr
public int count
public int stride
public Target target
public string name
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
private bool RequiresCompute(Target target)
private bool IsVertexIndexOrCopyOnly(Target target)
private IntPtr InitBuffer(Target target, int count, int stride)
private void DestroyBuffer(GraphicsBuffer buf)
public void .ctor(Target target, int count, int stride)
public void Release()
private bool IsValidBuffer(GraphicsBuffer buf)
public bool IsValid()
public int get_count()
public int get_stride()
public Target get_target()
public void SetData(Array data)
public void SetData(List`1<T> data)
public void SetData(NativeArray`1<T> data)
public void SetData(Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetData(List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetData(NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count)
private void InternalSetNativeData(IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
private void InternalSetData(Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
public void GetData(Array data)
public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count)
private void InternalGetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count, int elemSize)
public IntPtr GetNativeBufferPtr()
public void set_name(string value)
private void SetName(string name)
public void SetCounterValue(UInt32 counterValue)
private void CopyCountCC(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes)
private void CopyCountGC(GraphicsBuffer src, ComputeBuffer dst, int dstOffsetBytes)
private void CopyCountCG(ComputeBuffer src, GraphicsBuffer dst, int dstOffsetBytes)
private void CopyCountGG(GraphicsBuffer src, GraphicsBuffer dst, int dstOffsetBytes)
public void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes)
public void CopyCount(GraphicsBuffer src, ComputeBuffer dst, int dstOffsetBytes)
public void CopyCount(ComputeBuffer src, GraphicsBuffer dst, int dstOffsetBytes)
public void CopyCount(GraphicsBuffer src, GraphicsBuffer dst, int dstOffsetBytes)
}
public UnityEngine.Hash128 : ValueType {
internal ulong u64_0
internal ulong u64_1
private ulong kConst
public bool isValid
public void .ctor(UInt32 u32_0, UInt32 u32_1, UInt32 u32_2, UInt32 u32_3)
public void .ctor(ulong u64_0, ulong u64_1)
public bool get_isValid()
public int CompareTo(Hash128 rhs)
public string ToString()
public Hash128 Parse(string hashString)
private string Hash128ToStringImpl(Hash128 hash)
private void ComputeFromString(string data, Hash128& hash)
private void ComputeFromPtr(IntPtr data, int start, int count, int elemSize, Hash128& hash)
private void ComputeFromArray(Array data, int start, int count, int elemSize, Hash128& hash)
public Hash128 Compute(string data)
public Hash128 Compute(NativeArray`1<T> data)
public Hash128 Compute(NativeArray`1<T> data, int start, int count)
public Hash128 Compute(T[] data)
public Hash128 Compute(T[] data, int start, int count)
public Hash128 Compute(List`1<T> data)
public Hash128 Compute(List`1<T> data, int start, int count)
public Hash128 Compute(T& val)
public Hash128 Compute(int val)
public Hash128 Compute(float val)
public Hash128 Compute(Void* data, ulong size)
public void Append(string data)
public void Append(NativeArray`1<T> data)
public void Append(NativeArray`1<T> data, int start, int count)
public void Append(T[] data)
public void Append(T[] data, int start, int count)
public void Append(List`1<T> data)
public void Append(List`1<T> data, int start, int count)
public void Append(T& val)
public void Append(int val)
public void Append(float val)
public void Append(Void* data, ulong size)
public bool Equals(object obj)
public bool Equals(Hash128 obj)
public int GetHashCode()
public int CompareTo(object obj)
public bool op_Equality(Hash128 hash1, Hash128 hash2)
public bool op_Inequality(Hash128 hash1, Hash128 hash2)
public bool op_LessThan(Hash128 x, Hash128 y)
public bool op_GreaterThan(Hash128 x, Hash128 y)
private void ShortHash4(UInt32 data)
private void ShortEnd(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3)
private void Rot64(UInt64& x, int k)
private void Parse_Injected(string hashString, Hash128& ret)
private string Hash128ToStringImpl_Injected(Hash128& hash)
}
public UnityEngine.HashUnsafeUtilities : object {
public void ComputeHash128(Void* data, ulong dataSize, UInt64* hash1, UInt64* hash2)
public void ComputeHash128(Void* data, ulong dataSize, Hash128* hash)
}
public UnityEngine.HashUtilities : object {
public void AppendHash(Hash128& inHash, Hash128& outHash)
public void QuantisedMatrixHash(Matrix4x4& value, Hash128& hash)
public void QuantisedVectorHash(Vector3& value, Hash128& hash)
public void ComputeHash128(T& value, Hash128& hash)
public void ComputeHash128(Byte[] value, Hash128& hash)
}
public UnityEngine.HDRDisplaySupportFlags : Enum {
public int value__
public HDRDisplaySupportFlags None
public HDRDisplaySupportFlags Supported
public HDRDisplaySupportFlags RuntimeSwitchable
public HDRDisplaySupportFlags AutomaticTonemapping
}
public UnityEngine.HDROutputSettings : object {
private int m_DisplayIndex
public HDROutputSettings[] displays
private HDROutputSettings _mainDisplay
public HDROutputSettings main
public bool active
public bool available
public bool automaticHDRTonemapping
public ColorGamut displayColorGamut
public RenderTextureFormat format
public GraphicsFormat graphicsFormat
public float paperWhiteNits
public int maxFullFrameToneMapLuminance
public int maxToneMapLuminance
public int minToneMapLuminance
public bool HDRModeChangeRequested
internal void .ctor(int displayIndex)
public HDROutputSettings get_main()
public bool get_active()
public bool get_available()
public bool get_automaticHDRTonemapping()
public void set_automaticHDRTonemapping(bool value)
public ColorGamut get_displayColorGamut()
public RenderTextureFormat get_format()
public GraphicsFormat get_graphicsFormat()
public float get_paperWhiteNits()
public void set_paperWhiteNits(float value)
public int get_maxFullFrameToneMapLuminance()
public int get_maxToneMapLuminance()
public int get_minToneMapLuminance()
public bool get_HDRModeChangeRequested()
public void RequestHDRModeChange(bool enabled)
public void SetPaperWhiteInNits(float paperWhite)
private bool GetActive(int displayIndex)
private bool GetAvailable(int displayIndex)
private bool GetAutomaticHDRTonemapping(int displayIndex)
private void SetAutomaticHDRTonemapping(int displayIndex, bool scripted)
private ColorGamut GetDisplayColorGamut(int displayIndex)
private GraphicsFormat GetGraphicsFormat(int displayIndex)
private float GetPaperWhiteNits(int displayIndex)
private void SetPaperWhiteNits(int displayIndex, float paperWhite)
private int GetMaxFullFrameToneMapLuminance(int displayIndex)
private int GetMaxToneMapLuminance(int displayIndex)
private int GetMinToneMapLuminance(int displayIndex)
private bool GetHDRModeChangeRequested(int displayIndex)
private void RequestHDRModeChangeInternal(int displayIndex, bool enabled)
}
public UnityEngine.HeaderAttribute : PropertyAttribute {
public string header
public void .ctor(string header)
}
public UnityEngine.HelpURLAttribute : Attribute {
internal string m_Url
internal bool m_Dispatcher
internal string m_DispatchingFieldName
public string URL
public void .ctor(string url)
internal void .ctor(string defaultURL, string dispatchingFieldName)
public string get_URL()
}
public UnityEngine.HideFlags : Enum {
public int value__
public HideFlags None
public HideFlags HideInHierarchy
public HideFlags HideInInspector
public HideFlags DontSaveInEditor
public HideFlags NotEditable
public HideFlags DontSaveInBuild
public HideFlags DontUnloadUnusedAsset
public HideFlags DontSave
public HideFlags HideAndDontSave
}
internal UnityEngine.HotReloadDeserializer : object {
internal void PrepareHotReload()
internal void FinishHotReload(Type[] typesToReset)
internal Object CreateEmptyAsset(Type type)
internal void DeserializeAsset(Object asset, Byte[] data)
private void RemapInstanceIds(Object editorAsset, Int32[] editorToPlayerInstanceIdMapKeys, Int32[] editorToPlayerInstanceIdMapValues)
internal void RemapInstanceIds(Object editorAsset, Dictionary`2<int, int> editorToPlayerInstanceIdMap)
internal void FinalizeAssetCreation(Object asset)
internal Object[] GetDependencies(Object asset)
internal Int32[] GetNullDependencies(Object asset)
}
public UnityEngine.IconAttribute : Attribute {
private string m_IconPath
public string path
public string get_path()
public void .ctor(string path)
}
public UnityEngine.IExposedPropertyTable {
public void SetReferenceValue(PropertyName id, Object value)
public Object GetReferenceValue(PropertyName id, Boolean& idValid)
public void ClearReferenceValue(PropertyName id)
}
public UnityEngine.ILogger {
public ILogHandler logHandler
public bool logEnabled
public LogType filterLogType
public ILogHandler get_logHandler()
public void set_logHandler(ILogHandler value)
public bool get_logEnabled()
public void set_logEnabled(bool value)
public LogType get_filterLogType()
public void set_filterLogType(LogType value)
public bool IsLogTypeAllowed(LogType logType)
public void Log(LogType logType, object message)
public void Log(LogType logType, object message, Object context)
public void Log(LogType logType, string tag, object message)
public void Log(LogType logType, string tag, object message, Object context)
public void Log(object message)
public void Log(string tag, object message)
public void Log(string tag, object message, Object context)
public void LogWarning(string tag, object message)
public void LogWarning(string tag, object message, Object context)
public void LogError(string tag, object message)
public void LogError(string tag, object message, Object context)
public void LogFormat(LogType logType, string format, Object[] args)
public void LogException(Exception exception)
}
public UnityEngine.ILogHandler {
public void LogFormat(LogType logType, Object context, string format, Object[] args)
public void LogException(Exception exception, Object context)
}
public UnityEngine.InspectorNameAttribute : PropertyAttribute {
public string displayName
public void .ctor(string displayName)
}
internal UnityEngine.Internal_DrawTextureArguments : ValueType {
public Rect screenRect
public Rect sourceRect
public int leftBorder
public int rightBorder
public int topBorder
public int bottomBorder
public Color leftBorderColor
public Color rightBorderColor
public Color topBorderColor
public Color bottomBorderColor
public Color color
public Vector4 borderWidths
public Vector4 cornerRadiuses
public bool smoothCorners
public int pass
public Texture texture
public Material mat
}
public UnityEngine.Internal.DefaultValueAttribute : Attribute {
private object DefaultValue
public object Value
public void .ctor(string value)
public object get_Value()
public bool Equals(object obj)
public int GetHashCode()
}
internal UnityEngine.InternalStaticBatchingUtility : object {
private int MaxVerticesInBatch
private string CombinedMeshPrefix
public void CombineRoot(GameObject staticBatchRoot, StaticBatcherGOSorter sorter)
public void Combine(GameObject staticBatchRoot, bool combineOnlyStatic, bool isEditorPostprocessScene, StaticBatcherGOSorter sorter)
private UInt32 GetMeshFormatHash(Mesh mesh)
private GameObject[] SortGameObjectsForStaticBatching(GameObject[] gos, StaticBatcherGOSorter sorter)
public void CombineGameObjects(GameObject[] gos, GameObject staticBatchRoot, bool isEditorPostprocessScene, StaticBatcherGOSorter sorter)
private void MakeBatch(List`1<MeshContainer> meshes, Transform staticBatchRootTransform, int batchIndex)
}
internal UnityEngine.IO.File : object {
internal ulong totalOpenCalls
internal ulong totalCloseCalls
internal ulong totalReadCalls
internal ulong totalWriteCalls
internal ulong totalSeekCalls
internal ulong totalZeroSeekCalls
internal ulong totalFilesOpened
internal ulong totalFilesClosed
internal ulong totalBytesRead
internal ulong totalBytesWritten
internal bool recordZeroSeeks
internal ThreadIORestrictionMode MainThreadIORestrictionMode
internal ulong get_totalOpenCalls()
internal ulong get_totalCloseCalls()
internal ulong get_totalReadCalls()
internal ulong get_totalWriteCalls()
internal ulong get_totalSeekCalls()
internal ulong get_totalZeroSeekCalls()
internal ulong get_totalFilesOpened()
internal ulong get_totalFilesClosed()
internal ulong get_totalBytesRead()
internal ulong get_totalBytesWritten()
internal void set_recordZeroSeeks(bool value)
internal bool get_recordZeroSeeks()
internal ThreadIORestrictionMode get_MainThreadIORestrictionMode()
internal void set_MainThreadIORestrictionMode(ThreadIORestrictionMode value)
internal void SetRecordZeroSeeks(bool enable)
internal bool GetRecordZeroSeeks()
internal ulong GetTotalOpenCalls()
internal ulong GetTotalCloseCalls()
internal ulong GetTotalReadCalls()
internal ulong GetTotalWriteCalls()
internal ulong GetTotalSeekCalls()
internal ulong GetTotalZeroSeekCalls()
internal ulong GetTotalFilesOpened()
internal ulong GetTotalFilesClosed()
internal ulong GetTotalBytesRead()
internal ulong GetTotalBytesWritten()
private void SetMainThreadFileIORestriction(ThreadIORestrictionMode mode)
private ThreadIORestrictionMode GetMainThreadFileIORestriction()
}
internal UnityEngine.IO.ThreadIORestrictionMode : Enum {
public int value__
public ThreadIORestrictionMode Allowed
public ThreadIORestrictionMode TreatAsError
}
internal UnityEngine.IPlayerEditorConnectionNative {
public void Initialize()
public void DisconnectAll()
public void SendMessage(Guid messageId, Byte[] data, int playerId)
public bool TrySendMessage(Guid messageId, Byte[] data, int playerId)
public void Poll()
public void RegisterInternal(Guid messageId)
public void UnregisterInternal(Guid messageId)
public bool IsConnected()
}
public UnityEngine.ISerializationCallbackReceiver {
public void OnBeforeSerialize()
public void OnAfterDeserialize()
}
public UnityEngine.Jobs.IJobParallelForTransform {
public void Execute(int index, TransformAccess transform)
}
public UnityEngine.Jobs.IJobParallelForTransformExtensions : object {
public JobHandle Schedule(T jobData, TransformAccessArray transforms, JobHandle dependsOn)
public JobHandle ScheduleReadOnly(T jobData, TransformAccessArray transforms, int batchSize, JobHandle dependsOn)
public void RunReadOnly(T jobData, TransformAccessArray transforms)
}
public UnityEngine.Jobs.TransformAccess : ValueType {
private IntPtr hierarchy
private int index
public Vector3 position
public Quaternion rotation
public Vector3 localPosition
public Quaternion localRotation
public Vector3 localScale
public Matrix4x4 localToWorldMatrix
public Matrix4x4 worldToLocalMatrix
public bool isValid
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Vector3 get_localPosition()
public void set_localPosition(Vector3 value)
public Quaternion get_localRotation()
public void set_localRotation(Quaternion value)
public Vector3 get_localScale()
public void set_localScale(Vector3 value)
public Matrix4x4 get_localToWorldMatrix()
public Matrix4x4 get_worldToLocalMatrix()
public bool get_isValid()
public void SetPositionAndRotation(Vector3 position, Quaternion rotation)
public void SetLocalPositionAndRotation(Vector3 localPosition, Quaternion localRotation)
public void GetPositionAndRotation(Vector3& position, Quaternion& rotation)
public void GetLocalPositionAndRotation(Vector3& localPosition, Quaternion& localRotation)
private void SetPositionAndRotation_Internal(TransformAccess& access, Vector3& position, Quaternion& rotation)
private void SetLocalPositionAndRotation_Internal(TransformAccess& access, Vector3& localPosition, Quaternion& localRotation)
private void GetPositionAndRotation_Internal(TransformAccess& access, Vector3& position, Quaternion& rotation)
private void GetLocalPositionAndRotation_Internal(TransformAccess& access, Vector3& localPosition, Quaternion& localRotation)
private void GetPosition(TransformAccess& access, Vector3& p)
private void SetPosition(TransformAccess& access, Vector3& p)
private void GetRotation(TransformAccess& access, Quaternion& r)
private void SetRotation(TransformAccess& access, Quaternion& r)
private void GetLocalPosition(TransformAccess& access, Vector3& p)
private void SetLocalPosition(TransformAccess& access, Vector3& p)
private void GetLocalRotation(TransformAccess& access, Quaternion& r)
private void SetLocalRotation(TransformAccess& access, Quaternion& r)
private void GetLocalScale(TransformAccess& access, Vector3& r)
private void SetLocalScale(TransformAccess& access, Vector3& r)
private void GetLocalToWorldMatrix(TransformAccess& access, Matrix4x4& m)
private void GetWorldToLocalMatrix(TransformAccess& access, Matrix4x4& m)
internal void CheckHierarchyValid()
internal void MarkReadWrite()
internal void MarkReadOnly()
private void CheckWriteAccess()
}
public UnityEngine.Jobs.TransformAccessArray : ValueType {
private IntPtr m_TransformArray
public bool isCreated
public Transform Item
public int capacity
public int length
public void .ctor(Transform[] transforms, int desiredJobCount)
public void .ctor(int capacity, int desiredJobCount)
public void Allocate(int capacity, int desiredJobCount, TransformAccessArray& array)
public bool get_isCreated()
public void Dispose()
internal IntPtr GetTransformAccessArrayForSchedule()
public Transform get_Item(int index)
public void set_Item(int index, Transform value)
public int get_capacity()
public void set_capacity(int value)
public int get_length()
public void Add(Transform transform)
public void RemoveAtSwapBack(int index)
public void SetTransforms(Transform[] transforms)
private IntPtr Create(int capacity, int desiredJobCount)
private void DestroyTransformAccessArray(IntPtr transformArray)
private void SetTransforms(IntPtr transformArrayIntPtr, Transform[] transforms)
private void Add(IntPtr transformArrayIntPtr, Transform transform)
private void RemoveAtSwapBack(IntPtr transformArrayIntPtr, int index)
internal IntPtr GetSortedTransformAccess(IntPtr transformArrayIntPtr)
internal IntPtr GetSortedToUserIndex(IntPtr transformArrayIntPtr)
internal int GetLength(IntPtr transformArrayIntPtr)
internal int GetCapacity(IntPtr transformArrayIntPtr)
internal void SetCapacity(IntPtr transformArrayIntPtr, int capacity)
internal Transform GetTransform(IntPtr transformArrayIntPtr, int index)
internal void SetTransform(IntPtr transformArrayIntPtr, int index, Transform transform)
}
public UnityEngine.KeyCode : Enum {
public int value__
public KeyCode None
public KeyCode Backspace
public KeyCode Delete
public KeyCode Tab
public KeyCode Clear
public KeyCode Return
public KeyCode Pause
public KeyCode Escape
public KeyCode Space
public KeyCode Keypad0
public KeyCode Keypad1
public KeyCode Keypad2
public KeyCode Keypad3
public KeyCode Keypad4
public KeyCode Keypad5
public KeyCode Keypad6
public KeyCode Keypad7
public KeyCode Keypad8
public KeyCode Keypad9
public KeyCode KeypadPeriod
public KeyCode KeypadDivide
public KeyCode KeypadMultiply
public KeyCode KeypadMinus
public KeyCode KeypadPlus
public KeyCode KeypadEnter
public KeyCode KeypadEquals
public KeyCode UpArrow
public KeyCode DownArrow
public KeyCode RightArrow
public KeyCode LeftArrow
public KeyCode Insert
public KeyCode Home
public KeyCode End
public KeyCode PageUp
public KeyCode PageDown
public KeyCode F1
public KeyCode F2
public KeyCode F3
public KeyCode F4
public KeyCode F5
public KeyCode F6
public KeyCode F7
public KeyCode F8
public KeyCode F9
public KeyCode F10
public KeyCode F11
public KeyCode F12
public KeyCode F13
public KeyCode F14
public KeyCode F15
public KeyCode Alpha0
public KeyCode Alpha1
public KeyCode Alpha2
public KeyCode Alpha3
public KeyCode Alpha4
public KeyCode Alpha5
public KeyCode Alpha6
public KeyCode Alpha7
public KeyCode Alpha8
public KeyCode Alpha9
public KeyCode Exclaim
public KeyCode DoubleQuote
public KeyCode Hash
public KeyCode Dollar
public KeyCode Percent
public KeyCode Ampersand
public KeyCode Quote
public KeyCode LeftParen
public KeyCode RightParen
public KeyCode Asterisk
public KeyCode Plus
public KeyCode Comma
public KeyCode Minus
public KeyCode Period
public KeyCode Slash
public KeyCode Colon
public KeyCode Semicolon
public KeyCode Less
public KeyCode Equals
public KeyCode Greater
public KeyCode Question
public KeyCode At
public KeyCode LeftBracket
public KeyCode Backslash
public KeyCode RightBracket
public KeyCode Caret
public KeyCode Underscore
public KeyCode BackQuote
public KeyCode A
public KeyCode B
public KeyCode C
public KeyCode D
public KeyCode E
public KeyCode F
public KeyCode G
public KeyCode H
public KeyCode I
public KeyCode J
public KeyCode K
public KeyCode L
public KeyCode M
public KeyCode N
public KeyCode O
public KeyCode P
public KeyCode Q
public KeyCode R
public KeyCode S
public KeyCode T
public KeyCode U
public KeyCode V
public KeyCode W
public KeyCode X
public KeyCode Y
public KeyCode Z
public KeyCode LeftCurlyBracket
public KeyCode Pipe
public KeyCode RightCurlyBracket
public KeyCode Tilde
public KeyCode Numlock
public KeyCode CapsLock
public KeyCode ScrollLock
public KeyCode RightShift
public KeyCode LeftShift
public KeyCode RightControl
public KeyCode LeftControl
public KeyCode RightAlt
public KeyCode LeftAlt
public KeyCode LeftMeta
public KeyCode LeftCommand
public KeyCode LeftApple
public KeyCode LeftWindows
public KeyCode RightMeta
public KeyCode RightCommand
public KeyCode RightApple
public KeyCode RightWindows
public KeyCode AltGr
public KeyCode Help
public KeyCode Print
public KeyCode SysReq
public KeyCode Break
public KeyCode Menu
public KeyCode Mouse0
public KeyCode Mouse1
public KeyCode Mouse2
public KeyCode Mouse3
public KeyCode Mouse4
public KeyCode Mouse5
public KeyCode Mouse6
public KeyCode JoystickButton0
public KeyCode JoystickButton1
public KeyCode JoystickButton2
public KeyCode JoystickButton3
public KeyCode JoystickButton4
public KeyCode JoystickButton5
public KeyCode JoystickButton6
public KeyCode JoystickButton7
public KeyCode JoystickButton8
public KeyCode JoystickButton9
public KeyCode JoystickButton10
public KeyCode JoystickButton11
public KeyCode JoystickButton12
public KeyCode JoystickButton13
public KeyCode JoystickButton14
public KeyCode JoystickButton15
public KeyCode JoystickButton16
public KeyCode JoystickButton17
public KeyCode JoystickButton18
public KeyCode JoystickButton19
public KeyCode Joystick1Button0
public KeyCode Joystick1Button1
public KeyCode Joystick1Button2
public KeyCode Joystick1Button3
public KeyCode Joystick1Button4
public KeyCode Joystick1Button5
public KeyCode Joystick1Button6
public KeyCode Joystick1Button7
public KeyCode Joystick1Button8
public KeyCode Joystick1Button9
public KeyCode Joystick1Button10
public KeyCode Joystick1Button11
public KeyCode Joystick1Button12
public KeyCode Joystick1Button13
public KeyCode Joystick1Button14
public KeyCode Joystick1Button15
public KeyCode Joystick1Button16
public KeyCode Joystick1Button17
public KeyCode Joystick1Button18
public KeyCode Joystick1Button19
public KeyCode Joystick2Button0
public KeyCode Joystick2Button1
public KeyCode Joystick2Button2
public KeyCode Joystick2Button3
public KeyCode Joystick2Button4
public KeyCode Joystick2Button5
public KeyCode Joystick2Button6
public KeyCode Joystick2Button7
public KeyCode Joystick2Button8
public KeyCode Joystick2Button9
public KeyCode Joystick2Button10
public KeyCode Joystick2Button11
public KeyCode Joystick2Button12
public KeyCode Joystick2Button13
public KeyCode Joystick2Button14
public KeyCode Joystick2Button15
public KeyCode Joystick2Button16
public KeyCode Joystick2Button17
public KeyCode Joystick2Button18
public KeyCode Joystick2Button19
public KeyCode Joystick3Button0
public KeyCode Joystick3Button1
public KeyCode Joystick3Button2
public KeyCode Joystick3Button3
public KeyCode Joystick3Button4
public KeyCode Joystick3Button5
public KeyCode Joystick3Button6
public KeyCode Joystick3Button7
public KeyCode Joystick3Button8
public KeyCode Joystick3Button9
public KeyCode Joystick3Button10
public KeyCode Joystick3Button11
public KeyCode Joystick3Button12
public KeyCode Joystick3Button13
public KeyCode Joystick3Button14
public KeyCode Joystick3Button15
public KeyCode Joystick3Button16
public KeyCode Joystick3Button17
public KeyCode Joystick3Button18
public KeyCode Joystick3Button19
public KeyCode Joystick4Button0
public KeyCode Joystick4Button1
public KeyCode Joystick4Button2
public KeyCode Joystick4Button3
public KeyCode Joystick4Button4
public KeyCode Joystick4Button5
public KeyCode Joystick4Button6
public KeyCode Joystick4Button7
public KeyCode Joystick4Button8
public KeyCode Joystick4Button9
public KeyCode Joystick4Button10
public KeyCode Joystick4Button11
public KeyCode Joystick4Button12
public KeyCode Joystick4Button13
public KeyCode Joystick4Button14
public KeyCode Joystick4Button15
public KeyCode Joystick4Button16
public KeyCode Joystick4Button17
public KeyCode Joystick4Button18
public KeyCode Joystick4Button19
public KeyCode Joystick5Button0
public KeyCode Joystick5Button1
public KeyCode Joystick5Button2
public KeyCode Joystick5Button3
public KeyCode Joystick5Button4
public KeyCode Joystick5Button5
public KeyCode Joystick5Button6
public KeyCode Joystick5Button7
public KeyCode Joystick5Button8
public KeyCode Joystick5Button9
public KeyCode Joystick5Button10
public KeyCode Joystick5Button11
public KeyCode Joystick5Button12
public KeyCode Joystick5Button13
public KeyCode Joystick5Button14
public KeyCode Joystick5Button15
public KeyCode Joystick5Button16
public KeyCode Joystick5Button17
public KeyCode Joystick5Button18
public KeyCode Joystick5Button19
public KeyCode Joystick6Button0
public KeyCode Joystick6Button1
public KeyCode Joystick6Button2
public KeyCode Joystick6Button3
public KeyCode Joystick6Button4
public KeyCode Joystick6Button5
public KeyCode Joystick6Button6
public KeyCode Joystick6Button7
public KeyCode Joystick6Button8
public KeyCode Joystick6Button9
public KeyCode Joystick6Button10
public KeyCode Joystick6Button11
public KeyCode Joystick6Button12
public KeyCode Joystick6Button13
public KeyCode Joystick6Button14
public KeyCode Joystick6Button15
public KeyCode Joystick6Button16
public KeyCode Joystick6Button17
public KeyCode Joystick6Button18
public KeyCode Joystick6Button19
public KeyCode Joystick7Button0
public KeyCode Joystick7Button1
public KeyCode Joystick7Button2
public KeyCode Joystick7Button3
public KeyCode Joystick7Button4
public KeyCode Joystick7Button5
public KeyCode Joystick7Button6
public KeyCode Joystick7Button7
public KeyCode Joystick7Button8
public KeyCode Joystick7Button9
public KeyCode Joystick7Button10
public KeyCode Joystick7Button11
public KeyCode Joystick7Button12
public KeyCode Joystick7Button13
public KeyCode Joystick7Button14
public KeyCode Joystick7Button15
public KeyCode Joystick7Button16
public KeyCode Joystick7Button17
public KeyCode Joystick7Button18
public KeyCode Joystick7Button19
public KeyCode Joystick8Button0
public KeyCode Joystick8Button1
public KeyCode Joystick8Button2
public KeyCode Joystick8Button3
public KeyCode Joystick8Button4
public KeyCode Joystick8Button5
public KeyCode Joystick8Button6
public KeyCode Joystick8Button7
public KeyCode Joystick8Button8
public KeyCode Joystick8Button9
public KeyCode Joystick8Button10
public KeyCode Joystick8Button11
public KeyCode Joystick8Button12
public KeyCode Joystick8Button13
public KeyCode Joystick8Button14
public KeyCode Joystick8Button15
public KeyCode Joystick8Button16
public KeyCode Joystick8Button17
public KeyCode Joystick8Button18
public KeyCode Joystick8Button19
}
public UnityEngine.Keyframe : ValueType {
private float m_Time
private float m_Value
private float m_InTangent
private float m_OutTangent
private int m_WeightedMode
private float m_InWeight
private float m_OutWeight
public float time
public float value
public float inTangent
public float outTangent
public float inWeight
public float outWeight
public WeightedMode weightedMode
public int tangentMode
internal int tangentModeInternal
public void .ctor(float time, float value)
public void .ctor(float time, float value, float inTangent, float outTangent)
public void .ctor(float time, float value, float inTangent, float outTangent, float inWeight, float outWeight)
public float get_time()
public void set_time(float value)
public float get_value()
public void set_value(float value)
public float get_inTangent()
public void set_inTangent(float value)
public float get_outTangent()
public void set_outTangent(float value)
public float get_inWeight()
public void set_inWeight(float value)
public float get_outWeight()
public void set_outWeight(float value)
public WeightedMode get_weightedMode()
public void set_weightedMode(WeightedMode value)
public int get_tangentMode()
public void set_tangentMode(int value)
internal int get_tangentModeInternal()
internal void set_tangentModeInternal(int value)
}
public UnityEngine.LayerMask : ValueType {
private int m_Mask
public int value
public int op_Implicit(LayerMask mask)
public LayerMask op_Implicit(int intVal)
public int get_value()
public void set_value(int value)
public string LayerToName(int layer)
public int NameToLayer(string layerName)
public int GetMask(String[] layerNames)
}
public UnityEngine.LazyLoadReference`1 : ValueType {
private int kInstanceID_None
private int m_InstanceID
public bool isSet
public bool isBroken
public T asset
public int instanceID
public bool get_isSet()
public bool get_isBroken()
public T get_asset()
public void set_asset(T value)
public int get_instanceID()
public void set_instanceID(int value)
public void .ctor(T asset)
public void .ctor(int instanceID)
public LazyLoadReference`1<T> op_Implicit(T asset)
public LazyLoadReference`1<T> op_Implicit(int instanceID)
}
public UnityEngine.LensFlare : Behaviour {
public float brightness
public float fadeSpeed
public Color color
public Flare flare
public float get_brightness()
public void set_brightness(float value)
public float get_fadeSpeed()
public void set_fadeSpeed(float value)
public Color get_color()
public void set_color(Color value)
public Flare get_flare()
public void set_flare(Flare value)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
}
public UnityEngine.Light : Behaviour {
private int m_BakedIndex
public LightType type
public LightShape shape
public float spotAngle
public float innerSpotAngle
public Color color
public float colorTemperature
public bool useColorTemperature
public float intensity
public float bounceIntensity
public bool useBoundingSphereOverride
public Vector4 boundingSphereOverride
public bool useViewFrustumForShadowCasterCull
public int shadowCustomResolution
public float shadowBias
public float shadowNormalBias
public float shadowNearPlane
public bool useShadowMatrixOverride
public Matrix4x4 shadowMatrixOverride
public float range
public Flare flare
public LightBakingOutput bakingOutput
public int cullingMask
public int renderingLayerMask
public LightShadowCasterMode lightShadowCasterMode
public LightShadows shadows
public float shadowStrength
public LightShadowResolution shadowResolution
public float shadowSoftness
public float shadowSoftnessFade
public Single[] layerShadowCullDistances
public float cookieSize
public Texture cookie
public LightRenderMode renderMode
public int bakedIndex
public int commandBufferCount
public int pixelLightCount
public float shadowConstantBias
public float shadowObjectSizeBias
public bool attenuate
public LightType get_type()
public void set_type(LightType value)
public LightShape get_shape()
public void set_shape(LightShape value)
public float get_spotAngle()
public void set_spotAngle(float value)
public float get_innerSpotAngle()
public void set_innerSpotAngle(float value)
public Color get_color()
public void set_color(Color value)
public float get_colorTemperature()
public void set_colorTemperature(float value)
public bool get_useColorTemperature()
public void set_useColorTemperature(bool value)
public float get_intensity()
public void set_intensity(float value)
public float get_bounceIntensity()
public void set_bounceIntensity(float value)
public bool get_useBoundingSphereOverride()
public void set_useBoundingSphereOverride(bool value)
public Vector4 get_boundingSphereOverride()
public void set_boundingSphereOverride(Vector4 value)
public bool get_useViewFrustumForShadowCasterCull()
public void set_useViewFrustumForShadowCasterCull(bool value)
public int get_shadowCustomResolution()
public void set_shadowCustomResolution(int value)
public float get_shadowBias()
public void set_shadowBias(float value)
public float get_shadowNormalBias()
public void set_shadowNormalBias(float value)
public float get_shadowNearPlane()
public void set_shadowNearPlane(float value)
public bool get_useShadowMatrixOverride()
public void set_useShadowMatrixOverride(bool value)
public Matrix4x4 get_shadowMatrixOverride()
public void set_shadowMatrixOverride(Matrix4x4 value)
public float get_range()
public void set_range(float value)
public Flare get_flare()
public void set_flare(Flare value)
public LightBakingOutput get_bakingOutput()
public void set_bakingOutput(LightBakingOutput value)
public int get_cullingMask()
public void set_cullingMask(int value)
public int get_renderingLayerMask()
public void set_renderingLayerMask(int value)
public LightShadowCasterMode get_lightShadowCasterMode()
public void set_lightShadowCasterMode(LightShadowCasterMode value)
public void Reset()
public LightShadows get_shadows()
public void set_shadows(LightShadows value)
public float get_shadowStrength()
public void set_shadowStrength(float value)
public LightShadowResolution get_shadowResolution()
public void set_shadowResolution(LightShadowResolution value)
public float get_shadowSoftness()
public void set_shadowSoftness(float value)
public float get_shadowSoftnessFade()
public void set_shadowSoftnessFade(float value)
public Single[] get_layerShadowCullDistances()
public void set_layerShadowCullDistances(Single[] value)
public float get_cookieSize()
public void set_cookieSize(float value)
public Texture get_cookie()
public void set_cookie(Texture value)
public LightRenderMode get_renderMode()
public void set_renderMode(LightRenderMode value)
public int get_bakedIndex()
public void set_bakedIndex(int value)
public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer)
public void AddCommandBuffer(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask)
public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ComputeQueueType queueType)
public void AddCommandBufferAsync(LightEvent evt, CommandBuffer buffer, ShadowMapPass shadowPassMask, ComputeQueueType queueType)
public void RemoveCommandBuffer(LightEvent evt, CommandBuffer buffer)
public void RemoveCommandBuffers(LightEvent evt)
public void RemoveAllCommandBuffers()
public CommandBuffer[] GetCommandBuffers(LightEvent evt)
public int get_commandBufferCount()
public int get_pixelLightCount()
public void set_pixelLightCount(int value)
public Light[] GetLights(LightType type, int layer)
public float get_shadowConstantBias()
public void set_shadowConstantBias(float value)
public float get_shadowObjectSizeBias()
public void set_shadowObjectSizeBias(float value)
public bool get_attenuate()
public void set_attenuate(bool value)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
private void get_boundingSphereOverride_Injected(Vector4& ret)
private void set_boundingSphereOverride_Injected(Vector4& value)
private void get_shadowMatrixOverride_Injected(Matrix4x4& ret)
private void set_shadowMatrixOverride_Injected(Matrix4x4& value)
private void get_bakingOutput_Injected(LightBakingOutput& ret)
private void set_bakingOutput_Injected(LightBakingOutput& value)
}
public UnityEngine.LightBakingOutput : ValueType {
public int probeOcclusionLightIndex
public int occlusionMaskChannel
public LightmapBakeType lightmapBakeType
public MixedLightingMode mixedLightingMode
public bool isBaked
}
public UnityEngine.LightingSettings : Object {
public bool bakedGI
public bool realtimeGI
public bool realtimeEnvironmentLighting
internal void LightingSettingsDontStripMe()
private void Internal_Create(LightingSettings self)
public bool get_bakedGI()
public void set_bakedGI(bool value)
public bool get_realtimeGI()
public void set_realtimeGI(bool value)
public bool get_realtimeEnvironmentLighting()
public void set_realtimeEnvironmentLighting(bool value)
}
public UnityEngine.LightmapBakeType : Enum {
public int value__
public LightmapBakeType Realtime
public LightmapBakeType Baked
public LightmapBakeType Mixed
}
public UnityEngine.LightmapCompression : Enum {
public int value__
public LightmapCompression None
public LightmapCompression LowQuality
public LightmapCompression NormalQuality
public LightmapCompression HighQuality
}
public UnityEngine.LightmapData : object {
internal Texture2D m_Light
internal Texture2D m_Dir
internal Texture2D m_ShadowMask
public Texture2D lightmapLight
public Texture2D lightmapColor
public Texture2D lightmapDir
public Texture2D shadowMask
public Texture2D get_lightmapLight()
public void set_lightmapLight(Texture2D value)
public Texture2D get_lightmapColor()
public void set_lightmapColor(Texture2D value)
public Texture2D get_lightmapDir()
public void set_lightmapDir(Texture2D value)
public Texture2D get_shadowMask()
public void set_shadowMask(Texture2D value)
}
public UnityEngine.LightmapSettings : Object {
public LightmapData[] lightmaps
public LightmapsMode lightmapsMode
public LightProbes lightProbes
public LightmapsModeLegacy lightmapsModeLegacy
public ColorSpace bakedColorSpace
public LightmapData[] get_lightmaps()
public void set_lightmaps(LightmapData[] value)
public LightmapsMode get_lightmapsMode()
public void set_lightmapsMode(LightmapsMode value)
public LightProbes get_lightProbes()
public void set_lightProbes(LightProbes value)
internal void Reset()
public LightmapsModeLegacy get_lightmapsModeLegacy()
public void set_lightmapsModeLegacy(LightmapsModeLegacy value)
public ColorSpace get_bakedColorSpace()
public void set_bakedColorSpace(ColorSpace value)
}
public UnityEngine.LightmapsMode : Enum {
public int value__
public LightmapsMode NonDirectional
public LightmapsMode CombinedDirectional
}
public UnityEngine.LightmapsModeLegacy : Enum {
public int value__
public LightmapsModeLegacy Single
public LightmapsModeLegacy Dual
public LightmapsModeLegacy Directional
}
public UnityEngine.LightProbeGroup : Behaviour {
public Vector3[] probePositions
public Vector3[] get_probePositions()
}
public UnityEngine.LightProbeProxyVolume : Behaviour {
public bool isFeatureSupported
public Bounds boundsGlobal
public Vector3 sizeCustom
public Vector3 originCustom
public float probeDensity
public int gridResolutionX
public int gridResolutionY
public int gridResolutionZ
public BoundingBoxMode boundingBoxMode
public ResolutionMode resolutionMode
public ProbePositionMode probePositionMode
public RefreshMode refreshMode
public QualityMode qualityMode
public DataFormat dataFormat
public bool get_isFeatureSupported()
public Bounds get_boundsGlobal()
public Vector3 get_sizeCustom()
public void set_sizeCustom(Vector3 value)
public Vector3 get_originCustom()
public void set_originCustom(Vector3 value)
public float get_probeDensity()
public void set_probeDensity(float value)
public int get_gridResolutionX()
public void set_gridResolutionX(int value)
public int get_gridResolutionY()
public void set_gridResolutionY(int value)
public int get_gridResolutionZ()
public void set_gridResolutionZ(int value)
public BoundingBoxMode get_boundingBoxMode()
public void set_boundingBoxMode(BoundingBoxMode value)
public ResolutionMode get_resolutionMode()
public void set_resolutionMode(ResolutionMode value)
public ProbePositionMode get_probePositionMode()
public void set_probePositionMode(ProbePositionMode value)
public RefreshMode get_refreshMode()
public void set_refreshMode(RefreshMode value)
public QualityMode get_qualityMode()
public void set_qualityMode(QualityMode value)
public DataFormat get_dataFormat()
public void set_dataFormat(DataFormat value)
public void Update()
private void SetDirtyFlag(bool flag)
private void get_boundsGlobal_Injected(Bounds& ret)
private void get_sizeCustom_Injected(Vector3& ret)
private void set_sizeCustom_Injected(Vector3& value)
private void get_originCustom_Injected(Vector3& ret)
private void set_originCustom_Injected(Vector3& value)
}
public UnityEngine.LightProbes : Object {
private Action tetrahedralizationCompleted
private Action needsRetetrahedralization
public Vector3[] positions
public SphericalHarmonicsL2[] bakedProbes
public int count
public int cellCount
public Single[] coefficients
public void add_tetrahedralizationCompleted(Action value)
public void remove_tetrahedralizationCompleted(Action value)
private void Internal_CallTetrahedralizationCompletedFunction()
public void add_needsRetetrahedralization(Action value)
public void remove_needsRetetrahedralization(Action value)
private void Internal_CallNeedsRetetrahedralizationFunction()
public void Tetrahedralize()
public void TetrahedralizeAsync()
public void GetInterpolatedProbe(Vector3 position, Renderer renderer, SphericalHarmonicsL2& probe)
internal bool AreLightProbesAllowed(Renderer renderer)
public void CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes)
public void CalculateInterpolatedLightAndOcclusionProbes(List`1<Vector3> positions, List`1<SphericalHarmonicsL2> lightProbes, List`1<Vector4> occlusionProbes)
internal void CalculateInterpolatedLightAndOcclusionProbes_Internal(Vector3[] positions, int positionsCount, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes)
public Vector3[] get_positions()
public SphericalHarmonicsL2[] get_bakedProbes()
public void set_bakedProbes(SphericalHarmonicsL2[] value)
public int get_count()
public int get_cellCount()
internal int GetCount()
public void GetInterpolatedLightProbe(Vector3 position, Renderer renderer, Single[] coefficients)
public Single[] get_coefficients()
public void set_coefficients(Single[] value)
private void GetInterpolatedProbe_Injected(Vector3& position, Renderer renderer, SphericalHarmonicsL2& probe)
}
public UnityEngine.LightRenderMode : Enum {
public int value__
public LightRenderMode Auto
public LightRenderMode ForcePixel
public LightRenderMode ForceVertex
}
public UnityEngine.LightShadowCasterMode : Enum {
public int value__
public LightShadowCasterMode Default
public LightShadowCasterMode NonLightmappedOnly
public LightShadowCasterMode Everything
}
public UnityEngine.LightShadows : Enum {
public int value__
public LightShadows None
public LightShadows Hard
public LightShadows Soft
}
public UnityEngine.LightShape : Enum {
public int value__
public LightShape Cone
public LightShape Pyramid
public LightShape Box
}
public UnityEngine.LightType : Enum {
public int value__
public LightType Spot
public LightType Directional
public LightType Point
public LightType Area
public LightType Rectangle
public LightType Disc
}
public UnityEngine.LineAlignment : Enum {
public int value__
public LineAlignment View
public LineAlignment Local
public LineAlignment TransformZ
}
public UnityEngine.LineRenderer : Renderer {
public int numPositions
public float startWidth
public float endWidth
public float widthMultiplier
public int numCornerVertices
public int numCapVertices
public bool useWorldSpace
public bool loop
public Color startColor
public Color endColor
public int positionCount
public float shadowBias
public bool generateLightingData
public LineTextureMode textureMode
public LineAlignment alignment
public AnimationCurve widthCurve
public Gradient colorGradient
public void SetWidth(float start, float end)
public void SetColors(Color start, Color end)
public void SetVertexCount(int count)
public int get_numPositions()
public void set_numPositions(int value)
public float get_startWidth()
public void set_startWidth(float value)
public float get_endWidth()
public void set_endWidth(float value)
public float get_widthMultiplier()
public void set_widthMultiplier(float value)
public int get_numCornerVertices()
public void set_numCornerVertices(int value)
public int get_numCapVertices()
public void set_numCapVertices(int value)
public bool get_useWorldSpace()
public void set_useWorldSpace(bool value)
public bool get_loop()
public void set_loop(bool value)
public Color get_startColor()
public void set_startColor(Color value)
public Color get_endColor()
public void set_endColor(Color value)
public int get_positionCount()
public void set_positionCount(int value)
public void SetPosition(int index, Vector3 position)
public Vector3 GetPosition(int index)
public float get_shadowBias()
public void set_shadowBias(float value)
public bool get_generateLightingData()
public void set_generateLightingData(bool value)
public LineTextureMode get_textureMode()
public void set_textureMode(LineTextureMode value)
public LineAlignment get_alignment()
public void set_alignment(LineAlignment value)
public void Simplify(float tolerance)
public void BakeMesh(Mesh mesh, bool useTransform)
public void BakeMesh(Mesh mesh, Camera camera, bool useTransform)
public AnimationCurve get_widthCurve()
public void set_widthCurve(AnimationCurve value)
public Gradient get_colorGradient()
public void set_colorGradient(Gradient value)
private AnimationCurve GetWidthCurveCopy()
private void SetWidthCurve(AnimationCurve curve)
private Gradient GetColorGradientCopy()
private void SetColorGradient(Gradient curve)
public int GetPositions(Vector3[] positions)
public void SetPositions(Vector3[] positions)
public void SetPositions(NativeArray`1<Vector3> positions)
public void SetPositions(NativeSlice`1<Vector3> positions)
public int GetPositions(NativeArray`1<Vector3> positions)
public int GetPositions(NativeSlice`1<Vector3> positions)
private void SetPositionsWithNativeContainer(IntPtr positions, int count)
private int GetPositionsWithNativeContainer(IntPtr positions, int length)
private void get_startColor_Injected(Color& ret)
private void set_startColor_Injected(Color& value)
private void get_endColor_Injected(Color& ret)
private void set_endColor_Injected(Color& value)
private void SetPosition_Injected(int index, Vector3& position)
private void GetPosition_Injected(int index, Vector3& ret)
}
public UnityEngine.LineTextureMode : Enum {
public int value__
public LineTextureMode Stretch
public LineTextureMode Tile
public LineTextureMode DistributePerSegment
public LineTextureMode RepeatPerSegment
}
public UnityEngine.LineUtility : object {
public void Simplify(List`1<Vector3> points, float tolerance, List`1<int> pointsToKeep)
public void Simplify(List`1<Vector3> points, float tolerance, List`1<Vector3> simplifiedPoints)
public void Simplify(List`1<Vector2> points, float tolerance, List`1<int> pointsToKeep)
public void Simplify(List`1<Vector2> points, float tolerance, List`1<Vector2> simplifiedPoints)
internal void GeneratePointsToKeep3D(object pointsList, float tolerance, object pointsToKeepList)
internal void GeneratePointsToKeep2D(object pointsList, float tolerance, object pointsToKeepList)
internal void GenerateSimplifiedPoints3D(object pointsList, float tolerance, object simplifiedPoints)
internal void GenerateSimplifiedPoints2D(object pointsList, float tolerance, object simplifiedPoints)
}
public UnityEngine.LOD : ValueType {
public float screenRelativeTransitionHeight
public float fadeTransitionWidth
public Renderer[] renderers
public void .ctor(float screenRelativeTransitionHeight, Renderer[] renderers)
}
public UnityEngine.LODFadeMode : Enum {
public int value__
public LODFadeMode None
public LODFadeMode CrossFade
public LODFadeMode SpeedTree
}
public UnityEngine.LODGroup : Component {
public Vector3 localReferencePoint
public float size
public int lodCount
public LODFadeMode fadeMode
public bool animateCrossFading
public bool enabled
public float crossFadeAnimationDuration
internal Vector3 worldReferencePoint
public Vector3 get_localReferencePoint()
public void set_localReferencePoint(Vector3 value)
public float get_size()
public void set_size(float value)
public int get_lodCount()
public LODFadeMode get_fadeMode()
public void set_fadeMode(LODFadeMode value)
public bool get_animateCrossFading()
public void set_animateCrossFading(bool value)
public bool get_enabled()
public void set_enabled(bool value)
public void RecalculateBounds()
public LOD[] GetLODs()
public void SetLODS(LOD[] lods)
public void SetLODs(LOD[] lods)
public void ForceLOD(int index)
public float get_crossFadeAnimationDuration()
public void set_crossFadeAnimationDuration(float value)
internal Vector3 get_worldReferencePoint()
private void get_localReferencePoint_Injected(Vector3& ret)
private void set_localReferencePoint_Injected(Vector3& value)
private void get_worldReferencePoint_Injected(Vector3& ret)
}
public UnityEngine.Logger : object {
private string kNoTagFormat
private string kTagFormat
private ILogHandler <logHandler>k__BackingField
private bool <logEnabled>k__BackingField
private LogType <filterLogType>k__BackingField
public ILogHandler logHandler
public bool logEnabled
public LogType filterLogType
public void .ctor(ILogHandler logHandler)
public ILogHandler get_logHandler()
public void set_logHandler(ILogHandler value)
public bool get_logEnabled()
public void set_logEnabled(bool value)
public LogType get_filterLogType()
public void set_filterLogType(LogType value)
public bool IsLogTypeAllowed(LogType logType)
private string GetString(object message)
public void Log(LogType logType, object message)
public void Log(LogType logType, object message, Object context)
public void Log(LogType logType, string tag, object message)
public void Log(LogType logType, string tag, object message, Object context)
public void Log(object message)
public void Log(string tag, object message)
public void Log(string tag, object message, Object context)
public void LogWarning(string tag, object message)
public void LogWarning(string tag, object message, Object context)
public void LogError(string tag, object message)
public void LogError(string tag, object message, Object context)
public void LogException(Exception exception)
public void LogException(Exception exception, Object context)
public void LogFormat(LogType logType, string format, Object[] args)
public void LogFormat(LogType logType, Object context, string format, Object[] args)
}
public UnityEngine.LogOption : Enum {
public int value__
public LogOption None
public LogOption NoStacktrace
}
public UnityEngine.LogType : Enum {
public int value__
public LogType Error
public LogType Assert
public LogType Warning
public LogType Log
public LogType Exception
}
internal UnityEngine.LowerResBlitTexture : Object {
internal void LowerResBlitTextureDontStripMe()
}
public UnityEngine.LowLevel.PlayerLoop : object {
public PlayerLoopSystem GetDefaultPlayerLoop()
public PlayerLoopSystem GetCurrentPlayerLoop()
public void SetPlayerLoop(PlayerLoopSystem loop)
private int PlayerLoopSystemToInternal(PlayerLoopSystem sys, List`1& internalSys)
private PlayerLoopSystem InternalToPlayerLoopSystem(PlayerLoopSystemInternal[] internalSys, Int32& offset)
private PlayerLoopSystemInternal[] GetDefaultPlayerLoopInternal()
private PlayerLoopSystemInternal[] GetCurrentPlayerLoopInternal()
private void SetPlayerLoopInternal(PlayerLoopSystemInternal[] loop)
}
public UnityEngine.LowLevel.PlayerLoopSystem : ValueType {
public Type type
public PlayerLoopSystem[] subSystemList
public UpdateFunction updateDelegate
public IntPtr updateFunction
public IntPtr loopConditionFunction
public string ToString()
}
internal UnityEngine.LowLevel.PlayerLoopSystemInternal : ValueType {
public Type type
public UpdateFunction updateDelegate
public IntPtr updateFunction
public IntPtr loopConditionFunction
public int numSubSystems
}
public UnityEngine.Lumin.UsesLuminPlatformLevelAttribute : Attribute {
private UInt32 m_PlatformLevel
public UInt32 platformLevel
public void .ctor(UInt32 platformLevel)
public UInt32 get_platformLevel()
}
public UnityEngine.Lumin.UsesLuminPrivilegeAttribute : Attribute {
private string m_Privilege
public string privilege
public void .ctor(string privilege)
public string get_privilege()
}
internal UnityEngine.ManagedStreamHelpers : object {
internal void ValidateLoadFromStream(Stream stream)
internal void ManagedStreamRead(Byte[] buffer, int offset, int count, Stream stream, IntPtr returnValueAddress)
internal void ManagedStreamSeek(long offset, UInt32 origin, Stream stream, IntPtr returnValueAddress)
internal void ManagedStreamLength(Stream stream, IntPtr returnValueAddress)
}
public UnityEngine.Material : Object {
public Shader shader
public Color color
public Texture mainTexture
public Vector2 mainTextureOffset
public Vector2 mainTextureScale
public int renderQueue
internal int rawRenderQueue
public LocalKeyword[] enabledKeywords
public MaterialGlobalIlluminationFlags globalIlluminationFlags
public bool doubleSidedGI
public bool enableInstancing
public int passCount
public String[] shaderKeywords
public Material Create(string scriptContents)
private void CreateWithShader(Material self, Shader shader)
private void CreateWithMaterial(Material self, Material source)
private void CreateWithString(Material self)
public void .ctor(Shader shader)
public void .ctor(Material source)
public void .ctor(string contents)
internal Material GetDefaultMaterial()
internal Material GetDefaultParticleMaterial()
internal Material GetDefaultLineMaterial()
public Shader get_shader()
public void set_shader(Shader value)
public Color get_color()
public void set_color(Color value)
public Texture get_mainTexture()
public void set_mainTexture(Texture value)
public Vector2 get_mainTextureOffset()
public void set_mainTextureOffset(Vector2 value)
public Vector2 get_mainTextureScale()
public void set_mainTextureScale(Vector2 value)
private int GetFirstPropertyNameIdByAttribute(ShaderPropertyFlags attributeFlag)
public bool HasProperty(int nameID)
public bool HasProperty(string name)
private bool HasFloatImpl(int name)
public bool HasFloat(string name)
public bool HasFloat(int nameID)
public bool HasInt(string name)
public bool HasInt(int nameID)
private bool HasIntImpl(int name)
public bool HasInteger(string name)
public bool HasInteger(int nameID)
private bool HasTextureImpl(int name)
public bool HasTexture(string name)
public bool HasTexture(int nameID)
private bool HasMatrixImpl(int name)
public bool HasMatrix(string name)
public bool HasMatrix(int nameID)
private bool HasVectorImpl(int name)
public bool HasVector(string name)
public bool HasVector(int nameID)
public bool HasColor(string name)
public bool HasColor(int nameID)
private bool HasBufferImpl(int name)
public bool HasBuffer(string name)
public bool HasBuffer(int nameID)
private bool HasConstantBufferImpl(int name)
public bool HasConstantBuffer(string name)
public bool HasConstantBuffer(int nameID)
public int get_renderQueue()
public void set_renderQueue(int value)
internal int get_rawRenderQueue()
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
public bool IsKeywordEnabled(string keyword)
private void EnableLocalKeyword(LocalKeyword keyword)
private void DisableLocalKeyword(LocalKeyword keyword)
private void SetLocalKeyword(LocalKeyword keyword, bool value)
private bool IsLocalKeywordEnabled(LocalKeyword keyword)
public void EnableKeyword(LocalKeyword& keyword)
public void DisableKeyword(LocalKeyword& keyword)
public void SetKeyword(LocalKeyword& keyword, bool value)
public bool IsKeywordEnabled(LocalKeyword& keyword)
private LocalKeyword[] GetEnabledKeywords()
private void SetEnabledKeywords(LocalKeyword[] keywords)
public LocalKeyword[] get_enabledKeywords()
public void set_enabledKeywords(LocalKeyword[] value)
public MaterialGlobalIlluminationFlags get_globalIlluminationFlags()
public void set_globalIlluminationFlags(MaterialGlobalIlluminationFlags value)
public bool get_doubleSidedGI()
public void set_doubleSidedGI(bool value)
public bool get_enableInstancing()
public void set_enableInstancing(bool value)
public int get_passCount()
public void SetShaderPassEnabled(string passName, bool enabled)
public bool GetShaderPassEnabled(string passName)
public string GetPassName(int pass)
public int FindPass(string passName)
public void SetOverrideTag(string tag, string val)
private string GetTagImpl(string tag, bool currentSubShaderOnly, string defaultValue)
public string GetTag(string tag, bool searchFallbacks, string defaultValue)
public string GetTag(string tag, bool searchFallbacks)
public void Lerp(Material start, Material end, float t)
public bool SetPass(int pass)
public void CopyPropertiesFromMaterial(Material mat)
public void CopyMatchingPropertiesFromMaterial(Material mat)
private String[] GetShaderKeywords()
private void SetShaderKeywords(String[] names)
public String[] get_shaderKeywords()
public void set_shaderKeywords(String[] value)
public int ComputeCRC()
public String[] GetTexturePropertyNames()
public Int32[] GetTexturePropertyNameIDs()
private void GetTexturePropertyNamesInternal(object outNames)
private void GetTexturePropertyNameIDsInternal(object outNames)
public void GetTexturePropertyNames(List`1<string> outNames)
public void GetTexturePropertyNameIDs(List`1<int> outNames)
private void SetIntImpl(int name, int value)
private void SetFloatImpl(int name, float value)
private void SetColorImpl(int name, Color value)
private void SetMatrixImpl(int name, Matrix4x4 value)
private void SetTextureImpl(int name, Texture value)
private void SetRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element)
private void SetBufferImpl(int name, ComputeBuffer value)
private void SetGraphicsBufferImpl(int name, GraphicsBuffer value)
private void SetConstantBufferImpl(int name, ComputeBuffer value, int offset, int size)
private void SetConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size)
private int GetIntImpl(int name)
private float GetFloatImpl(int name)
private Color GetColorImpl(int name)
private Matrix4x4 GetMatrixImpl(int name)
private Texture GetTextureImpl(int name)
private void SetFloatArrayImpl(int name, Single[] values, int count)
private void SetVectorArrayImpl(int name, Vector4[] values, int count)
private void SetColorArrayImpl(int name, Color[] values, int count)
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetFloatArrayImpl(int name)
private Vector4[] GetVectorArrayImpl(int name)
private Color[] GetColorArrayImpl(int name)
private Matrix4x4[] GetMatrixArrayImpl(int name)
private int GetFloatArrayCountImpl(int name)
private int GetVectorArrayCountImpl(int name)
private int GetColorArrayCountImpl(int name)
private int GetMatrixArrayCountImpl(int name)
private void ExtractFloatArrayImpl(int name, Single[] val)
private void ExtractVectorArrayImpl(int name, Vector4[] val)
private void ExtractColorArrayImpl(int name, Color[] val)
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val)
private Vector4 GetTextureScaleAndOffsetImpl(int name)
private void SetTextureOffsetImpl(int name, Vector2 offset)
private void SetTextureScaleImpl(int name, Vector2 scale)
private void SetFloatArray(int name, Single[] values, int count)
private void SetVectorArray(int name, Vector4[] values, int count)
private void SetColorArray(int name, Color[] values, int count)
private void SetMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractFloatArray(int name, List`1<float> values)
private void ExtractVectorArray(int name, List`1<Vector4> values)
private void ExtractColorArray(int name, List`1<Color> values)
private void ExtractMatrixArray(int name, List`1<Matrix4x4> values)
public void SetInt(string name, int value)
public void SetInt(int nameID, int value)
public void SetFloat(string name, float value)
public void SetFloat(int nameID, float value)
public void SetInteger(string name, int value)
public void SetInteger(int nameID, int value)
public void SetColor(string name, Color value)
public void SetColor(int nameID, Color value)
public void SetVector(string name, Vector4 value)
public void SetVector(int nameID, Vector4 value)
public void SetMatrix(string name, Matrix4x4 value)
public void SetMatrix(int nameID, Matrix4x4 value)
public void SetTexture(string name, Texture value)
public void SetTexture(int nameID, Texture value)
public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element)
public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element)
public void SetBuffer(string name, ComputeBuffer value)
public void SetBuffer(int nameID, ComputeBuffer value)
public void SetBuffer(string name, GraphicsBuffer value)
public void SetBuffer(int nameID, GraphicsBuffer value)
public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size)
public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size)
public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size)
public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size)
public void SetFloatArray(string name, List`1<float> values)
public void SetFloatArray(int nameID, List`1<float> values)
public void SetFloatArray(string name, Single[] values)
public void SetFloatArray(int nameID, Single[] values)
public void SetColorArray(string name, List`1<Color> values)
public void SetColorArray(int nameID, List`1<Color> values)
public void SetColorArray(string name, Color[] values)
public void SetColorArray(int nameID, Color[] values)
public void SetVectorArray(string name, List`1<Vector4> values)
public void SetVectorArray(int nameID, List`1<Vector4> values)
public void SetVectorArray(string name, Vector4[] values)
public void SetVectorArray(int nameID, Vector4[] values)
public void SetMatrixArray(string name, List`1<Matrix4x4> values)
public void SetMatrixArray(int nameID, List`1<Matrix4x4> values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetMatrixArray(int nameID, Matrix4x4[] values)
public int GetInt(string name)
public int GetInt(int nameID)
public float GetFloat(string name)
public float GetFloat(int nameID)
public int GetInteger(string name)
public int GetInteger(int nameID)
public Color GetColor(string name)
public Color GetColor(int nameID)
public Vector4 GetVector(string name)
public Vector4 GetVector(int nameID)
public Matrix4x4 GetMatrix(string name)
public Matrix4x4 GetMatrix(int nameID)
public Texture GetTexture(string name)
public Texture GetTexture(int nameID)
public Single[] GetFloatArray(string name)
public Single[] GetFloatArray(int nameID)
public Color[] GetColorArray(string name)
public Color[] GetColorArray(int nameID)
public Vector4[] GetVectorArray(string name)
public Vector4[] GetVectorArray(int nameID)
public Matrix4x4[] GetMatrixArray(string name)
public Matrix4x4[] GetMatrixArray(int nameID)
public void GetFloatArray(string name, List`1<float> values)
public void GetFloatArray(int nameID, List`1<float> values)
public void GetColorArray(string name, List`1<Color> values)
public void GetColorArray(int nameID, List`1<Color> values)
public void GetVectorArray(string name, List`1<Vector4> values)
public void GetVectorArray(int nameID, List`1<Vector4> values)
public void GetMatrixArray(string name, List`1<Matrix4x4> values)
public void GetMatrixArray(int nameID, List`1<Matrix4x4> values)
public void SetTextureOffset(string name, Vector2 value)
public void SetTextureOffset(int nameID, Vector2 value)
public void SetTextureScale(string name, Vector2 value)
public void SetTextureScale(int nameID, Vector2 value)
public Vector2 GetTextureOffset(string name)
public Vector2 GetTextureOffset(int nameID)
public Vector2 GetTextureScale(string name)
public Vector2 GetTextureScale(int nameID)
private void EnableLocalKeyword_Injected(LocalKeyword& keyword)
private void DisableLocalKeyword_Injected(LocalKeyword& keyword)
private void SetLocalKeyword_Injected(LocalKeyword& keyword, bool value)
private bool IsLocalKeywordEnabled_Injected(LocalKeyword& keyword)
private void SetColorImpl_Injected(int name, Color& value)
private void SetMatrixImpl_Injected(int name, Matrix4x4& value)
private void GetColorImpl_Injected(int name, Color& ret)
private void GetMatrixImpl_Injected(int name, Matrix4x4& ret)
private void GetTextureScaleAndOffsetImpl_Injected(int name, Vector4& ret)
private void SetTextureOffsetImpl_Injected(int name, Vector2& offset)
private void SetTextureScaleImpl_Injected(int name, Vector2& scale)
}
public UnityEngine.MaterialGlobalIlluminationFlags : Enum {
public int value__
public MaterialGlobalIlluminationFlags None
public MaterialGlobalIlluminationFlags RealtimeEmissive
public MaterialGlobalIlluminationFlags BakedEmissive
public MaterialGlobalIlluminationFlags EmissiveIsBlack
public MaterialGlobalIlluminationFlags AnyEmissive
}
public UnityEngine.MaterialPropertyBlock : object {
internal IntPtr m_Ptr
public bool isEmpty
public void AddFloat(string name, float value)
public void AddFloat(int nameID, float value)
public void AddVector(string name, Vector4 value)
public void AddVector(int nameID, Vector4 value)
public void AddColor(string name, Color value)
public void AddColor(int nameID, Color value)
public void AddMatrix(string name, Matrix4x4 value)
public void AddMatrix(int nameID, Matrix4x4 value)
public void AddTexture(string name, Texture value)
public void AddTexture(int nameID, Texture value)
private int GetIntImpl(int name)
private float GetFloatImpl(int name)
private Vector4 GetVectorImpl(int name)
private Color GetColorImpl(int name)
private Matrix4x4 GetMatrixImpl(int name)
private Texture GetTextureImpl(int name)
private bool HasPropertyImpl(int name)
private bool HasFloatImpl(int name)
private bool HasIntImpl(int name)
private bool HasTextureImpl(int name)
private bool HasMatrixImpl(int name)
private bool HasVectorImpl(int name)
private bool HasBufferImpl(int name)
private bool HasConstantBufferImpl(int name)
private void SetIntImpl(int name, int value)
private void SetFloatImpl(int name, float value)
private void SetVectorImpl(int name, Vector4 value)
private void SetColorImpl(int name, Color value)
private void SetMatrixImpl(int name, Matrix4x4 value)
private void SetTextureImpl(int name, Texture value)
private void SetRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element)
private void SetBufferImpl(int name, ComputeBuffer value)
private void SetGraphicsBufferImpl(int name, GraphicsBuffer value)
private void SetConstantBufferImpl(int name, ComputeBuffer value, int offset, int size)
private void SetConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size)
private void SetFloatArrayImpl(int name, Single[] values, int count)
private void SetVectorArrayImpl(int name, Vector4[] values, int count)
private void SetMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetFloatArrayImpl(int name)
private Vector4[] GetVectorArrayImpl(int name)
private Matrix4x4[] GetMatrixArrayImpl(int name)
private int GetFloatArrayCountImpl(int name)
private int GetVectorArrayCountImpl(int name)
private int GetMatrixArrayCountImpl(int name)
private void ExtractFloatArrayImpl(int name, Single[] val)
private void ExtractVectorArrayImpl(int name, Vector4[] val)
private void ExtractMatrixArrayImpl(int name, Matrix4x4[] val)
internal void Internal_CopySHCoefficientArraysFrom(MaterialPropertyBlock properties, SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count)
internal void Internal_CopyProbeOcclusionArrayFrom(MaterialPropertyBlock properties, Vector4[] occlusionProbes, int sourceStart, int destStart, int count)
private IntPtr CreateImpl()
private void DestroyImpl(IntPtr mpb)
public bool get_isEmpty()
private void Clear(bool keepMemory)
public void Clear()
private void SetFloatArray(int name, Single[] values, int count)
private void SetVectorArray(int name, Vector4[] values, int count)
private void SetMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractFloatArray(int name, List`1<float> values)
private void ExtractVectorArray(int name, List`1<Vector4> values)
private void ExtractMatrixArray(int name, List`1<Matrix4x4> values)
protected void Finalize()
private void Dispose()
public void SetInt(string name, int value)
public void SetInt(int nameID, int value)
public void SetFloat(string name, float value)
public void SetFloat(int nameID, float value)
public void SetInteger(string name, int value)
public void SetInteger(int nameID, int value)
public void SetVector(string name, Vector4 value)
public void SetVector(int nameID, Vector4 value)
public void SetColor(string name, Color value)
public void SetColor(int nameID, Color value)
public void SetMatrix(string name, Matrix4x4 value)
public void SetMatrix(int nameID, Matrix4x4 value)
public void SetBuffer(string name, ComputeBuffer value)
public void SetBuffer(int nameID, ComputeBuffer value)
public void SetBuffer(string name, GraphicsBuffer value)
public void SetBuffer(int nameID, GraphicsBuffer value)
public void SetTexture(string name, Texture value)
public void SetTexture(int nameID, Texture value)
public void SetTexture(string name, RenderTexture value, RenderTextureSubElement element)
public void SetTexture(int nameID, RenderTexture value, RenderTextureSubElement element)
public void SetConstantBuffer(string name, ComputeBuffer value, int offset, int size)
public void SetConstantBuffer(int nameID, ComputeBuffer value, int offset, int size)
public void SetConstantBuffer(string name, GraphicsBuffer value, int offset, int size)
public void SetConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size)
public void SetFloatArray(string name, List`1<float> values)
public void SetFloatArray(int nameID, List`1<float> values)
public void SetFloatArray(string name, Single[] values)
public void SetFloatArray(int nameID, Single[] values)
public void SetVectorArray(string name, List`1<Vector4> values)
public void SetVectorArray(int nameID, List`1<Vector4> values)
public void SetVectorArray(string name, Vector4[] values)
public void SetVectorArray(int nameID, Vector4[] values)
public void SetMatrixArray(string name, List`1<Matrix4x4> values)
public void SetMatrixArray(int nameID, List`1<Matrix4x4> values)
public void SetMatrixArray(string name, Matrix4x4[] values)
public void SetMatrixArray(int nameID, Matrix4x4[] values)
public bool HasProperty(string name)
public bool HasProperty(int nameID)
public bool HasInt(string name)
public bool HasInt(int nameID)
public bool HasFloat(string name)
public bool HasFloat(int nameID)
public bool HasInteger(string name)
public bool HasInteger(int nameID)
public bool HasTexture(string name)
public bool HasTexture(int nameID)
public bool HasMatrix(string name)
public bool HasMatrix(int nameID)
public bool HasVector(string name)
public bool HasVector(int nameID)
public bool HasColor(string name)
public bool HasColor(int nameID)
public bool HasBuffer(string name)
public bool HasBuffer(int nameID)
public bool HasConstantBuffer(string name)
public bool HasConstantBuffer(int nameID)
public float GetFloat(string name)
public float GetFloat(int nameID)
public int GetInt(string name)
public int GetInt(int nameID)
public int GetInteger(string name)
public int GetInteger(int nameID)
public Vector4 GetVector(string name)
public Vector4 GetVector(int nameID)
public Color GetColor(string name)
public Color GetColor(int nameID)
public Matrix4x4 GetMatrix(string name)
public Matrix4x4 GetMatrix(int nameID)
public Texture GetTexture(string name)
public Texture GetTexture(int nameID)
public Single[] GetFloatArray(string name)
public Single[] GetFloatArray(int nameID)
public Vector4[] GetVectorArray(string name)
public Vector4[] GetVectorArray(int nameID)
public Matrix4x4[] GetMatrixArray(string name)
public Matrix4x4[] GetMatrixArray(int nameID)
public void GetFloatArray(string name, List`1<float> values)
public void GetFloatArray(int nameID, List`1<float> values)
public void GetVectorArray(string name, List`1<Vector4> values)
public void GetVectorArray(int nameID, List`1<Vector4> values)
public void GetMatrixArray(string name, List`1<Matrix4x4> values)
public void GetMatrixArray(int nameID, List`1<Matrix4x4> values)
public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes)
public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes)
public void CopySHCoefficientArraysFrom(List`1<SphericalHarmonicsL2> lightProbes, int sourceStart, int destStart, int count)
public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count)
public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes)
public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes)
public void CopyProbeOcclusionArrayFrom(List`1<Vector4> occlusionProbes, int sourceStart, int destStart, int count)
public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes, int sourceStart, int destStart, int count)
private void GetVectorImpl_Injected(int name, Vector4& ret)
private void GetColorImpl_Injected(int name, Color& ret)
private void GetMatrixImpl_Injected(int name, Matrix4x4& ret)
private void SetVectorImpl_Injected(int name, Vector4& value)
private void SetColorImpl_Injected(int name, Color& value)
private void SetMatrixImpl_Injected(int name, Matrix4x4& value)
}
public UnityEngine.Mathf : ValueType {
public float PI
public float Infinity
public float NegativeInfinity
public float Deg2Rad
public float Rad2Deg
public float Epsilon
public int ClosestPowerOfTwo(int value)
public bool IsPowerOfTwo(int value)
public int NextPowerOfTwo(int value)
public float GammaToLinearSpace(float value)
public float LinearToGammaSpace(float value)
public Color CorrelatedColorTemperatureToRGB(float kelvin)
public ushort FloatToHalf(float val)
public float HalfToFloat(ushort val)
public float PerlinNoise(float x, float y)
public float Sin(float f)
public float Cos(float f)
public float Tan(float f)
public float Asin(float f)
public float Acos(float f)
public float Atan(float f)
public float Atan2(float y, float x)
public float Sqrt(float f)
public float Abs(float f)
public int Abs(int value)
public float Min(float a, float b)
public float Min(Single[] values)
public int Min(int a, int b)
public int Min(Int32[] values)
public float Max(float a, float b)
public float Max(Single[] values)
public int Max(int a, int b)
public int Max(Int32[] values)
public float Pow(float f, float p)
public float Exp(float power)
public float Log(float f, float p)
public float Log(float f)
public float Log10(float f)
public float Ceil(float f)
public float Floor(float f)
public float Round(float f)
public int CeilToInt(float f)
public int FloorToInt(float f)
public int RoundToInt(float f)
public float Sign(float f)
public float Clamp(float value, float min, float max)
public int Clamp(int value, int min, int max)
public float Clamp01(float value)
public float Lerp(float a, float b, float t)
public float LerpUnclamped(float a, float b, float t)
public float LerpAngle(float a, float b, float t)
public float MoveTowards(float current, float target, float maxDelta)
public float MoveTowardsAngle(float current, float target, float maxDelta)
public float SmoothStep(float from, float to, float t)
public float Gamma(float value, float absmax, float gamma)
public bool Approximately(float a, float b)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime)
public float SmoothDamp(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime)
public float SmoothDampAngle(float current, float target, Single& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float Repeat(float t, float length)
public float PingPong(float t, float length)
public float InverseLerp(float a, float b, float value)
public float DeltaAngle(float current, float target)
internal bool LineIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result)
internal bool LineSegmentIntersection(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, Vector2& result)
internal long RandomToLong(Random r)
private void CorrelatedColorTemperatureToRGB_Injected(float kelvin, Color& ret)
}
public UnityEngine.Matrix4x4 : ValueType {
public float m00
public float m10
public float m20
public float m30
public float m01
public float m11
public float m21
public float m31
public float m02
public float m12
public float m22
public float m32
public float m03
public float m13
public float m23
public float m33
private Matrix4x4 zeroMatrix
private Matrix4x4 identityMatrix
public Quaternion rotation
public Vector3 lossyScale
public bool isIdentity
public float determinant
public FrustumPlanes decomposeProjection
public Matrix4x4 inverse
public Matrix4x4 transpose
public float Item
public float Item
public Matrix4x4 zero
public Matrix4x4 identity
private Quaternion GetRotation()
private Vector3 GetLossyScale()
private bool IsIdentity()
private float GetDeterminant()
private FrustumPlanes DecomposeProjection()
public Quaternion get_rotation()
public Vector3 get_lossyScale()
public bool get_isIdentity()
public float get_determinant()
public FrustumPlanes get_decomposeProjection()
public bool ValidTRS()
public float Determinant(Matrix4x4 m)
public Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s)
public void SetTRS(Vector3 pos, Quaternion q, Vector3 s)
public bool Inverse3DAffine(Matrix4x4 input, Matrix4x4& result)
public Matrix4x4 Inverse(Matrix4x4 m)
public Matrix4x4 get_inverse()
public Matrix4x4 Transpose(Matrix4x4 m)
public Matrix4x4 get_transpose()
public Matrix4x4 Ortho(float left, float right, float bottom, float top, float zNear, float zFar)
public Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar)
public Matrix4x4 LookAt(Vector3 from, Vector3 to, Vector3 up)
public Matrix4x4 Frustum(float left, float right, float bottom, float top, float zNear, float zFar)
public Matrix4x4 Frustum(FrustumPlanes fp)
public void .ctor(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3)
public float get_Item(int row, int column)
public void set_Item(int row, int column, float value)
public float get_Item(int index)
public void set_Item(int index, float value)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Matrix4x4 other)
public Matrix4x4 op_Multiply(Matrix4x4 lhs, Matrix4x4 rhs)
public Vector4 op_Multiply(Matrix4x4 lhs, Vector4 vector)
public bool op_Equality(Matrix4x4 lhs, Matrix4x4 rhs)
public bool op_Inequality(Matrix4x4 lhs, Matrix4x4 rhs)
public Vector4 GetColumn(int index)
public Vector4 GetRow(int index)
public Vector3 GetPosition()
public void SetColumn(int index, Vector4 column)
public void SetRow(int index, Vector4 row)
public Vector3 MultiplyPoint(Vector3 point)
public Vector3 MultiplyPoint3x4(Vector3 point)
public Vector3 MultiplyVector(Vector3 vector)
public Plane TransformPlane(Plane plane)
public Matrix4x4 Scale(Vector3 vector)
public Matrix4x4 Translate(Vector3 vector)
public Matrix4x4 Rotate(Quaternion q)
public Matrix4x4 get_zero()
public Matrix4x4 get_identity()
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
private void GetRotation_Injected(Matrix4x4& _unity_self, Quaternion& ret)
private void GetLossyScale_Injected(Matrix4x4& _unity_self, Vector3& ret)
private bool IsIdentity_Injected(Matrix4x4& _unity_self)
private float GetDeterminant_Injected(Matrix4x4& _unity_self)
private void DecomposeProjection_Injected(Matrix4x4& _unity_self, FrustumPlanes& ret)
private bool ValidTRS_Injected(Matrix4x4& _unity_self)
private void TRS_Injected(Vector3& pos, Quaternion& q, Vector3& s, Matrix4x4& ret)
private bool Inverse3DAffine_Injected(Matrix4x4& input, Matrix4x4& result)
private void Inverse_Injected(Matrix4x4& m, Matrix4x4& ret)
private void Transpose_Injected(Matrix4x4& m, Matrix4x4& ret)
private void Ortho_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret)
private void Perspective_Injected(float fov, float aspect, float zNear, float zFar, Matrix4x4& ret)
private void LookAt_Injected(Vector3& from, Vector3& to, Vector3& up, Matrix4x4& ret)
private void Frustum_Injected(float left, float right, float bottom, float top, float zNear, float zFar, Matrix4x4& ret)
}
public UnityEngine.Mesh : Object {
public IndexFormat indexFormat
public int vertexBufferCount
public Target vertexBufferTarget
public Target indexBufferTarget
public int blendShapeCount
public Matrix4x4[] bindposes
public bool isReadable
internal bool canAccess
public int vertexCount
public int subMeshCount
public Bounds bounds
public Vector3[] vertices
public Vector3[] normals
public Vector4[] tangents
public Vector2[] uv
public Vector2[] uv2
public Vector2[] uv3
public Vector2[] uv4
public Vector2[] uv5
public Vector2[] uv6
public Vector2[] uv7
public Vector2[] uv8
public Color[] colors
public Color32[] colors32
public int vertexAttributeCount
public Int32[] triangles
public BoneWeight[] boneWeights
private void Internal_Create(Mesh mono)
internal Mesh FromInstanceID(int id)
public IndexFormat get_indexFormat()
public void set_indexFormat(IndexFormat value)
internal UInt32 GetTotalIndexCount()
public void SetIndexBufferParams(int indexCount, IndexFormat format)
private void InternalSetIndexBufferData(IntPtr data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags)
private void InternalSetIndexBufferDataFromArray(Array data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags)
private void SetVertexBufferParamsFromPtr(int vertexCount, IntPtr attributesPtr, int attributesCount)
private void SetVertexBufferParamsFromArray(int vertexCount, VertexAttributeDescriptor[] attributes)
private void InternalSetVertexBufferData(int stream, IntPtr data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags)
private void InternalSetVertexBufferDataFromArray(int stream, Array data, int dataStart, int meshBufferStart, int count, int elemSize, MeshUpdateFlags flags)
private Array GetVertexAttributesAlloc()
private int GetVertexAttributesArray(VertexAttributeDescriptor[] attributes)
private int GetVertexAttributesList(List`1<VertexAttributeDescriptor> attributes)
private int GetVertexAttributeCountImpl()
public VertexAttributeDescriptor GetVertexAttribute(int index)
private UInt32 GetIndexStartImpl(int submesh)
private UInt32 GetIndexCountImpl(int submesh)
private UInt32 GetTrianglesCountImpl(int submesh)
private UInt32 GetBaseVertexImpl(int submesh)
private Int32[] GetTrianglesImpl(int submesh, bool applyBaseVertex)
private Int32[] GetIndicesImpl(int submesh, bool applyBaseVertex)
private void SetIndicesImpl(int submesh, MeshTopology topology, IndexFormat indicesFormat, Array indices, int arrayStart, int arraySize, bool calculateBounds, int baseVertex)
private void SetIndicesNativeArrayImpl(int submesh, MeshTopology topology, IndexFormat indicesFormat, IntPtr indices, int arrayStart, int arraySize, bool calculateBounds, int baseVertex)
private void GetTrianglesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex)
private void GetTrianglesNonAllocImpl16(UInt16[] values, int submesh, bool applyBaseVertex)
private void GetIndicesNonAllocImpl(Int32[] values, int submesh, bool applyBaseVertex)
private void GetIndicesNonAllocImpl16(UInt16[] values, int submesh, bool applyBaseVertex)
private void PrintErrorCantAccessChannel(VertexAttribute ch)
public bool HasVertexAttribute(VertexAttribute attr)
public int GetVertexAttributeDimension(VertexAttribute attr)
public VertexAttributeFormat GetVertexAttributeFormat(VertexAttribute attr)
public int GetVertexAttributeStream(VertexAttribute attr)
public int GetVertexAttributeOffset(VertexAttribute attr)
private void SetArrayForChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values, int arraySize, int valuesStart, int valuesCount, MeshUpdateFlags flags)
private void SetNativeArrayForChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, IntPtr values, int arraySize, int valuesStart, int valuesCount, MeshUpdateFlags flags)
private Array GetAllocArrayFromChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim)
private void GetArrayFromChannelImpl(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values)
public int get_vertexBufferCount()
public int GetVertexBufferStride(int stream)
public IntPtr GetNativeVertexBufferPtr(int index)
public IntPtr GetNativeIndexBufferPtr()
private GraphicsBuffer GetVertexBufferImpl(int index)
private GraphicsBuffer GetIndexBufferImpl()
public Target get_vertexBufferTarget()
public void set_vertexBufferTarget(Target value)
public Target get_indexBufferTarget()
public void set_indexBufferTarget(Target value)
public int get_blendShapeCount()
public void ClearBlendShapes()
public string GetBlendShapeName(int shapeIndex)
public int GetBlendShapeIndex(string blendShapeName)
public int GetBlendShapeFrameCount(int shapeIndex)
public float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex)
public void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)
public void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)
private bool HasBoneWeights()
private BoneWeight[] GetBoneWeightsImpl()
private void SetBoneWeightsImpl(BoneWeight[] weights)
public void SetBoneWeights(NativeArray`1<byte> bonesPerVertex, NativeArray`1<BoneWeight1> weights)
private void InternalSetBoneWeights(IntPtr bonesPerVertex, int bonesPerVertexSize, IntPtr weights, int weightsSize)
public NativeArray`1<BoneWeight1> GetAllBoneWeights()
public NativeArray`1<byte> GetBonesPerVertex()
private int GetAllBoneWeightsArraySize()
private IntPtr GetAllBoneWeightsArray()
private IntPtr GetBonesPerVertexArray()
private int GetBindposeCount()
public Matrix4x4[] get_bindposes()
public void set_bindposes(Matrix4x4[] value)
private void GetBoneWeightsNonAllocImpl(BoneWeight[] values)
private void GetBindposesNonAllocImpl(Matrix4x4[] values)
public bool get_isReadable()
internal bool get_canAccess()
public int get_vertexCount()
public int get_subMeshCount()
public void set_subMeshCount(int value)
public void SetSubMesh(int index, SubMeshDescriptor desc, MeshUpdateFlags flags)
public SubMeshDescriptor GetSubMesh(int index)
private void SetAllSubMeshesAtOnceFromArray(SubMeshDescriptor[] desc, int start, int count, MeshUpdateFlags flags)
private void SetAllSubMeshesAtOnceFromNativeArray(IntPtr desc, int start, int count, MeshUpdateFlags flags)
public Bounds get_bounds()
public void set_bounds(Bounds value)
private void ClearImpl(bool keepVertexLayout)
private void RecalculateBoundsImpl(MeshUpdateFlags flags)
private void RecalculateNormalsImpl(MeshUpdateFlags flags)
private void RecalculateTangentsImpl(MeshUpdateFlags flags)
private void MarkDynamicImpl()
public void MarkModified()
private void UploadMeshDataImpl(bool markNoLongerReadable)
private MeshTopology GetTopologyImpl(int submesh)
private void RecalculateUVDistributionMetricImpl(int uvSetIndex, float uvAreaThreshold)
private void RecalculateUVDistributionMetricsImpl(float uvAreaThreshold)
public float GetUVDistributionMetric(int uvSetIndex)
private void CombineMeshesImpl(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData)
private void OptimizeImpl()
private void OptimizeIndexBuffersImpl()
private void OptimizeReorderVertexBufferImpl()
internal VertexAttribute GetUVChannel(int uvIndex)
internal int DefaultDimensionForChannel(VertexAttribute channel)
private T[] GetAllocArrayFromChannel(VertexAttribute channel, VertexAttributeFormat format, int dim)
private T[] GetAllocArrayFromChannel(VertexAttribute channel)
private void SetSizedArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, Array values, int valuesArrayLength, int valuesStart, int valuesCount, MeshUpdateFlags flags)
private void SetSizedNativeArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, IntPtr values, int valuesArrayLength, int valuesStart, int valuesCount, MeshUpdateFlags flags)
private void SetArrayForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, T[] values, MeshUpdateFlags flags)
private void SetArrayForChannel(VertexAttribute channel, T[] values, MeshUpdateFlags flags)
private void SetListForChannel(VertexAttribute channel, VertexAttributeFormat format, int dim, List`1<T> values, int start, int length, MeshUpdateFlags flags)
private void SetListForChannel(VertexAttribute channel, List`1<T> values, int start, int length, MeshUpdateFlags flags)
private void GetListForChannel(List`1<T> buffer, int capacity, VertexAttribute channel, int dim)
private void GetListForChannel(List`1<T> buffer, int capacity, VertexAttribute channel, int dim, VertexAttributeFormat channelType)
public Vector3[] get_vertices()
public void set_vertices(Vector3[] value)
public Vector3[] get_normals()
public void set_normals(Vector3[] value)
public Vector4[] get_tangents()
public void set_tangents(Vector4[] value)
public Vector2[] get_uv()
public void set_uv(Vector2[] value)
public Vector2[] get_uv2()
public void set_uv2(Vector2[] value)
public Vector2[] get_uv3()
public void set_uv3(Vector2[] value)
public Vector2[] get_uv4()
public void set_uv4(Vector2[] value)
public Vector2[] get_uv5()
public void set_uv5(Vector2[] value)
public Vector2[] get_uv6()
public void set_uv6(Vector2[] value)
public Vector2[] get_uv7()
public void set_uv7(Vector2[] value)
public Vector2[] get_uv8()
public void set_uv8(Vector2[] value)
public Color[] get_colors()
public void set_colors(Color[] value)
public Color32[] get_colors32()
public void set_colors32(Color32[] value)
public void GetVertices(List`1<Vector3> vertices)
public void SetVertices(List`1<Vector3> inVertices)
public void SetVertices(List`1<Vector3> inVertices, int start, int length)
public void SetVertices(List`1<Vector3> inVertices, int start, int length, MeshUpdateFlags flags)
public void SetVertices(Vector3[] inVertices)
public void SetVertices(Vector3[] inVertices, int start, int length)
public void SetVertices(Vector3[] inVertices, int start, int length, MeshUpdateFlags flags)
public void SetVertices(NativeArray`1<T> inVertices)
public void SetVertices(NativeArray`1<T> inVertices, int start, int length)
public void SetVertices(NativeArray`1<T> inVertices, int start, int length, MeshUpdateFlags flags)
public void GetNormals(List`1<Vector3> normals)
public void SetNormals(List`1<Vector3> inNormals)
public void SetNormals(List`1<Vector3> inNormals, int start, int length)
public void SetNormals(List`1<Vector3> inNormals, int start, int length, MeshUpdateFlags flags)
public void SetNormals(Vector3[] inNormals)
public void SetNormals(Vector3[] inNormals, int start, int length)
public void SetNormals(Vector3[] inNormals, int start, int length, MeshUpdateFlags flags)
public void SetNormals(NativeArray`1<T> inNormals)
public void SetNormals(NativeArray`1<T> inNormals, int start, int length)
public void SetNormals(NativeArray`1<T> inNormals, int start, int length, MeshUpdateFlags flags)
public void GetTangents(List`1<Vector4> tangents)
public void SetTangents(List`1<Vector4> inTangents)
public void SetTangents(List`1<Vector4> inTangents, int start, int length)
public void SetTangents(List`1<Vector4> inTangents, int start, int length, MeshUpdateFlags flags)
public void SetTangents(Vector4[] inTangents)
public void SetTangents(Vector4[] inTangents, int start, int length)
public void SetTangents(Vector4[] inTangents, int start, int length, MeshUpdateFlags flags)
public void SetTangents(NativeArray`1<T> inTangents)
public void SetTangents(NativeArray`1<T> inTangents, int start, int length)
public void SetTangents(NativeArray`1<T> inTangents, int start, int length, MeshUpdateFlags flags)
public void GetColors(List`1<Color> colors)
public void SetColors(List`1<Color> inColors)
public void SetColors(List`1<Color> inColors, int start, int length)
public void SetColors(List`1<Color> inColors, int start, int length, MeshUpdateFlags flags)
public void SetColors(Color[] inColors)
public void SetColors(Color[] inColors, int start, int length)
public void SetColors(Color[] inColors, int start, int length, MeshUpdateFlags flags)
public void GetColors(List`1<Color32> colors)
public void SetColors(List`1<Color32> inColors)
public void SetColors(List`1<Color32> inColors, int start, int length)
public void SetColors(List`1<Color32> inColors, int start, int length, MeshUpdateFlags flags)
public void SetColors(Color32[] inColors)
public void SetColors(Color32[] inColors, int start, int length)
public void SetColors(Color32[] inColors, int start, int length, MeshUpdateFlags flags)
public void SetColors(NativeArray`1<T> inColors)
public void SetColors(NativeArray`1<T> inColors, int start, int length)
public void SetColors(NativeArray`1<T> inColors, int start, int length, MeshUpdateFlags flags)
private void SetUvsImpl(int uvIndex, int dim, List`1<T> uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, List`1<Vector2> uvs)
public void SetUVs(int channel, List`1<Vector3> uvs)
public void SetUVs(int channel, List`1<Vector4> uvs)
public void SetUVs(int channel, List`1<Vector2> uvs, int start, int length)
public void SetUVs(int channel, List`1<Vector2> uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, List`1<Vector3> uvs, int start, int length)
public void SetUVs(int channel, List`1<Vector3> uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, List`1<Vector4> uvs, int start, int length)
public void SetUVs(int channel, List`1<Vector4> uvs, int start, int length, MeshUpdateFlags flags)
private void SetUvsImpl(int uvIndex, int dim, Array uvs, int arrayStart, int arraySize, MeshUpdateFlags flags)
public void SetUVs(int channel, Vector2[] uvs)
public void SetUVs(int channel, Vector3[] uvs)
public void SetUVs(int channel, Vector4[] uvs)
public void SetUVs(int channel, Vector2[] uvs, int start, int length)
public void SetUVs(int channel, Vector2[] uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, Vector3[] uvs, int start, int length)
public void SetUVs(int channel, Vector3[] uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, Vector4[] uvs, int start, int length)
public void SetUVs(int channel, Vector4[] uvs, int start, int length, MeshUpdateFlags flags)
public void SetUVs(int channel, NativeArray`1<T> uvs)
public void SetUVs(int channel, NativeArray`1<T> uvs, int start, int length)
public void SetUVs(int channel, NativeArray`1<T> uvs, int start, int length, MeshUpdateFlags flags)
private void GetUVsImpl(int uvIndex, List`1<T> uvs, int dim)
public void GetUVs(int channel, List`1<Vector2> uvs)
public void GetUVs(int channel, List`1<Vector3> uvs)
public void GetUVs(int channel, List`1<Vector4> uvs)
public int get_vertexAttributeCount()
public VertexAttributeDescriptor[] GetVertexAttributes()
public int GetVertexAttributes(VertexAttributeDescriptor[] attributes)
public int GetVertexAttributes(List`1<VertexAttributeDescriptor> attributes)
public void SetVertexBufferParams(int vertexCount, VertexAttributeDescriptor[] attributes)
public void SetVertexBufferParams(int vertexCount, NativeArray`1<VertexAttributeDescriptor> attributes)
public void SetVertexBufferData(NativeArray`1<T> data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags)
public void SetVertexBufferData(T[] data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags)
public void SetVertexBufferData(List`1<T> data, int dataStart, int meshBufferStart, int count, int stream, MeshUpdateFlags flags)
public MeshDataArray AcquireReadOnlyMeshData(Mesh mesh)
public MeshDataArray AcquireReadOnlyMeshData(Mesh[] meshes)
public MeshDataArray AcquireReadOnlyMeshData(List`1<Mesh> meshes)
public MeshDataArray AllocateWritableMeshData(int meshCount)
public void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh mesh, MeshUpdateFlags flags)
public void ApplyAndDisposeWritableMeshData(MeshDataArray data, Mesh[] meshes, MeshUpdateFlags flags)
public void ApplyAndDisposeWritableMeshData(MeshDataArray data, List`1<Mesh> meshes, MeshUpdateFlags flags)
public GraphicsBuffer GetVertexBuffer(int index)
public GraphicsBuffer GetIndexBuffer()
private void PrintErrorCantAccessIndices()
private bool CheckCanAccessSubmesh(int submesh, bool errorAboutTriangles)
private bool CheckCanAccessSubmeshTriangles(int submesh)
private bool CheckCanAccessSubmeshIndices(int submesh)
public Int32[] get_triangles()
public void set_triangles(Int32[] value)
public Int32[] GetTriangles(int submesh)
public Int32[] GetTriangles(int submesh, bool applyBaseVertex)
public void GetTriangles(List`1<int> triangles, int submesh)
public void GetTriangles(List`1<int> triangles, int submesh, bool applyBaseVertex)
public void GetTriangles(List`1<ushort> triangles, int submesh, bool applyBaseVertex)
public Int32[] GetIndices(int submesh)
public Int32[] GetIndices(int submesh, bool applyBaseVertex)
public void GetIndices(List`1<int> indices, int submesh)
public void GetIndices(List`1<int> indices, int submesh, bool applyBaseVertex)
public void GetIndices(List`1<ushort> indices, int submesh, bool applyBaseVertex)
public void SetIndexBufferData(NativeArray`1<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags)
public void SetIndexBufferData(T[] data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags)
public void SetIndexBufferData(List`1<T> data, int dataStart, int meshBufferStart, int count, MeshUpdateFlags flags)
public UInt32 GetIndexStart(int submesh)
public UInt32 GetIndexCount(int submesh)
public UInt32 GetBaseVertex(int submesh)
private void CheckIndicesArrayRange(int valuesLength, int start, int length)
private void SetTrianglesImpl(int submesh, IndexFormat indicesFormat, Array triangles, int trianglesArrayLength, int start, int length, bool calculateBounds, int baseVertex)
public void SetTriangles(Int32[] triangles, int submesh)
public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds)
public void SetTriangles(Int32[] triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(Int32[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(UInt16[] triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(UInt16[] triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(List`1<int> triangles, int submesh)
public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds)
public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(List`1<int> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(List`1<ushort> triangles, int submesh, bool calculateBounds, int baseVertex)
public void SetTriangles(List`1<ushort> triangles, int trianglesStart, int trianglesLength, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds)
public void SetIndices(Int32[] indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(Int32[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(UInt16[] indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(UInt16[] indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(NativeArray`1<T> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(NativeArray`1<T> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(List`1<int> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(List`1<int> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(List`1<ushort> indices, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetIndices(List`1<ushort> indices, int indicesStart, int indicesLength, MeshTopology topology, int submesh, bool calculateBounds, int baseVertex)
public void SetSubMeshes(SubMeshDescriptor[] desc, int start, int count, MeshUpdateFlags flags)
public void SetSubMeshes(SubMeshDescriptor[] desc, MeshUpdateFlags flags)
public void SetSubMeshes(List`1<SubMeshDescriptor> desc, int start, int count, MeshUpdateFlags flags)
public void SetSubMeshes(List`1<SubMeshDescriptor> desc, MeshUpdateFlags flags)
public void SetSubMeshes(NativeArray`1<T> desc, int start, int count, MeshUpdateFlags flags)
public void SetSubMeshes(NativeArray`1<T> desc, MeshUpdateFlags flags)
public void GetBindposes(List`1<Matrix4x4> bindposes)
public void GetBoneWeights(List`1<BoneWeight> boneWeights)
public BoneWeight[] get_boneWeights()
public void set_boneWeights(BoneWeight[] value)
public void Clear(bool keepVertexLayout)
public void Clear()
public void RecalculateBounds()
public void RecalculateNormals()
public void RecalculateTangents()
public void RecalculateBounds(MeshUpdateFlags flags)
public void RecalculateNormals(MeshUpdateFlags flags)
public void RecalculateTangents(MeshUpdateFlags flags)
public void RecalculateUVDistributionMetric(int uvSetIndex, float uvAreaThreshold)
public void RecalculateUVDistributionMetrics(float uvAreaThreshold)
public void MarkDynamic()
public void UploadMeshData(bool markNoLongerReadable)
public void Optimize()
public void OptimizeIndexBuffers()
public void OptimizeReorderVertexBuffer()
public MeshTopology GetTopology(int submesh)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices, bool hasLightmapData)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes, bool useMatrices)
public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes)
public void CombineMeshes(CombineInstance[] combine)
private void GetVertexAttribute_Injected(int index, VertexAttributeDescriptor& ret)
private void SetSubMesh_Injected(int index, SubMeshDescriptor& desc, MeshUpdateFlags flags)
private void GetSubMesh_Injected(int index, SubMeshDescriptor& ret)
private void get_bounds_Injected(Bounds& ret)
private void set_bounds_Injected(Bounds& value)
}
public UnityEngine.MeshFilter : Component {
public Mesh sharedMesh
public Mesh mesh
private void DontStripMeshFilter()
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public Mesh get_mesh()
public void set_mesh(Mesh value)
}
public UnityEngine.MeshRenderer : Renderer {
public Mesh additionalVertexStreams
public Mesh enlightenVertexStream
public int subMeshStartIndex
private void DontStripMeshRenderer()
public Mesh get_additionalVertexStreams()
public void set_additionalVertexStreams(Mesh value)
public Mesh get_enlightenVertexStream()
public void set_enlightenVertexStream(Mesh value)
public int get_subMeshStartIndex()
}
public UnityEngine.MeshTopology : Enum {
public int value__
public MeshTopology Triangles
public MeshTopology Quads
public MeshTopology Lines
public MeshTopology LineStrip
public MeshTopology Points
}
internal UnityEngine.MethodImplOptionsEx : object {
public short AggressiveInlining
}
public UnityEngine.MinAttribute : PropertyAttribute {
public float min
public void .ctor(float min)
}
public UnityEngine.MissingComponentException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public UnityEngine.MissingReferenceException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public UnityEngine.MixedLightingMode : Enum {
public int value__
public MixedLightingMode IndirectOnly
public MixedLightingMode Shadowmask
public MixedLightingMode Subtractive
}
public UnityEngine.MonoBehaviour : Behaviour {
public bool useGUILayout
public bool IsInvoking()
public void CancelInvoke()
public void Invoke(string methodName, float time)
public void InvokeRepeating(string methodName, float time, float repeatRate)
public void CancelInvoke(string methodName)
public bool IsInvoking(string methodName)
public Coroutine StartCoroutine(string methodName)
public Coroutine StartCoroutine(string methodName, object value)
public Coroutine StartCoroutine(IEnumerator routine)
public Coroutine StartCoroutine_Auto(IEnumerator routine)
public void StopCoroutine(IEnumerator routine)
public void StopCoroutine(Coroutine routine)
public void StopCoroutine(string methodName)
public void StopAllCoroutines()
public bool get_useGUILayout()
public void set_useGUILayout(bool value)
public void print(object message)
private void Internal_CancelInvokeAll(MonoBehaviour self)
private bool Internal_IsInvokingAll(MonoBehaviour self)
private void InvokeDelayed(MonoBehaviour self, string methodName, float time, float repeatRate)
private void CancelInvoke(MonoBehaviour self, string methodName)
private bool IsInvoking(MonoBehaviour self, string methodName)
private bool IsObjectMonoBehaviour(Object obj)
private Coroutine StartCoroutineManaged(string methodName, object value)
private Coroutine StartCoroutineManaged2(IEnumerator enumerator)
private void StopCoroutineManaged(Coroutine routine)
private void StopCoroutineFromEnumeratorManaged(IEnumerator routine)
internal string GetScriptClassName()
}
public UnityEngine.MotionVectorGenerationMode : Enum {
public int value__
public MotionVectorGenerationMode Camera
public MotionVectorGenerationMode Object
public MotionVectorGenerationMode ForceNoMotion
}
public UnityEngine.MultilineAttribute : PropertyAttribute {
public int lines
public void .ctor(int lines)
}
public UnityEngine.Networking.PlayerConnection.ConnectionTarget : Enum {
public int value__
public ConnectionTarget None
public ConnectionTarget Player
public ConnectionTarget Editor
}
public UnityEngine.Networking.PlayerConnection.IConnectionState {
public ConnectionTarget connectedToTarget
public string connectionName
public ConnectionTarget get_connectedToTarget()
public string get_connectionName()
}
public UnityEngine.Networking.PlayerConnection.IEditorPlayerConnection {
public void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void DisconnectAll()
public void RegisterConnection(UnityAction`1<int> callback)
public void RegisterDisconnection(UnityAction`1<int> callback)
public void UnregisterConnection(UnityAction`1<int> callback)
public void UnregisterDisconnection(UnityAction`1<int> callback)
public void Send(Guid messageId, Byte[] data)
public bool TrySend(Guid messageId, Byte[] data)
}
public UnityEngine.Networking.PlayerConnection.MessageEventArgs : object {
public int playerId
public Byte[] data
}
public UnityEngine.Networking.PlayerConnection.PlayerConnection : ScriptableObject {
internal IPlayerEditorConnectionNative connectionNative
private PlayerEditorConnectionEvents m_PlayerEditorConnectionEvents
private List`1<int> m_connectedPlayers
private bool m_IsInitilized
private PlayerConnection s_Instance
public PlayerConnection instance
public bool isConnected
public PlayerConnection get_instance()
public bool get_isConnected()
private PlayerConnection CreateInstance()
public void OnEnable()
private IPlayerEditorConnectionNative GetConnectionNativeApi()
public void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback)
public void RegisterConnection(UnityAction`1<int> callback)
public void RegisterDisconnection(UnityAction`1<int> callback)
public void UnregisterConnection(UnityAction`1<int> callback)
public void UnregisterDisconnection(UnityAction`1<int> callback)
public void Send(Guid messageId, Byte[] data)
public bool TrySend(Guid messageId, Byte[] data)
public bool BlockUntilRecvMsg(Guid messageId, int timeout)
public void DisconnectAll()
private void MessageCallbackInternal(IntPtr data, ulong size, ulong guid, string messageId)
private void ConnectedCallbackInternal(int playerId)
private void DisconnectedCallback(int playerId)
}
internal UnityEngine.Networking.PlayerConnection.PlayerEditorConnectionEvents : object {
public List`1<MessageTypeSubscribers> messageTypeSubscribers
public ConnectionChangeEvent connectionEvent
public ConnectionChangeEvent disconnectionEvent
public void InvokeMessageIdSubscribers(Guid messageId, Byte[] data, int playerId)
public UnityEvent`1<MessageEventArgs> AddAndCreate(Guid messageId)
public void UnregisterManagedCallback(Guid messageId, UnityAction`1<MessageEventArgs> callback)
}
public UnityEngine.NetworkReachability : Enum {
public int value__
public NetworkReachability NotReachable
public NetworkReachability ReachableViaCarrierDataNetwork
public NetworkReachability ReachableViaLocalAreaNetwork
}
internal UnityEngine.NoAllocHelpers : object {
public void ResizeList(List`1<T> list, int size)
public void EnsureListElemCount(List`1<T> list, int count)
public int SafeLength(Array values)
public int SafeLength(List`1<T> values)
public T[] ExtractArrayFromListT(List`1<T> list)
internal void Internal_ResizeList(object list, int size)
public Array ExtractArrayFromList(object list)
}
public UnityEngine.NPOTSupport : Enum {
public int value__
public NPOTSupport None
public NPOTSupport Restricted
public NPOTSupport Full
}
public UnityEngine.Object : object {
private IntPtr m_CachedPtr
internal int OffsetOfInstanceIDInCPlusPlusObject
private string objectIsNullMessage
private string cloneDestroyedMessage
public string name
public HideFlags hideFlags
public int GetInstanceID()
public int GetHashCode()
public bool Equals(object other)
public bool op_Implicit(Object exists)
private bool CompareBaseObjects(Object lhs, Object rhs)
private void EnsureRunningOnMainThread()
private bool IsNativeObjectAlive(Object o)
private IntPtr GetCachedPtr()
public string get_name()
public void set_name(string value)
public Object Instantiate(Object original, Vector3 position, Quaternion rotation)
public Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent)
public Object Instantiate(Object original)
public Object Instantiate(Object original, Transform parent)
public Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace)
public T Instantiate(T original)
public T Instantiate(T original, Vector3 position, Quaternion rotation)
public T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent)
public T Instantiate(T original, Transform parent)
public T Instantiate(T original, Transform parent, bool worldPositionStays)
public void Destroy(Object obj, float t)
public void Destroy(Object obj)
public void DestroyImmediate(Object obj, bool allowDestroyingAssets)
public void DestroyImmediate(Object obj)
public Object[] FindObjectsOfType(Type type)
public Object[] FindObjectsOfType(Type type, bool includeInactive)
public Object[] FindObjectsByType(Type type, FindObjectsSortMode sortMode)
public Object[] FindObjectsByType(Type type, FindObjectsInactive findObjectsInactive, FindObjectsSortMode sortMode)
public void DontDestroyOnLoad(Object target)
public HideFlags get_hideFlags()
public void set_hideFlags(HideFlags value)
public void DestroyObject(Object obj, float t)
public void DestroyObject(Object obj)
public Object[] FindSceneObjectsOfType(Type type)
public Object[] FindObjectsOfTypeIncludingAssets(Type type)
public T[] FindObjectsOfType()
public T[] FindObjectsByType(FindObjectsSortMode sortMode)
public T[] FindObjectsOfType(bool includeInactive)
public T[] FindObjectsByType(FindObjectsInactive findObjectsInactive, FindObjectsSortMode sortMode)
public T FindObjectOfType()
public T FindObjectOfType(bool includeInactive)
public T FindFirstObjectByType()
public T FindAnyObjectByType()
public T FindFirstObjectByType(FindObjectsInactive findObjectsInactive)
public T FindAnyObjectByType(FindObjectsInactive findObjectsInactive)
public Object[] FindObjectsOfTypeAll(Type type)
private void CheckNullArgument(object arg, string message)
public Object FindObjectOfType(Type type)
public Object FindFirstObjectByType(Type type)
public Object FindAnyObjectByType(Type type)
public Object FindObjectOfType(Type type, bool includeInactive)
public Object FindFirstObjectByType(Type type, FindObjectsInactive findObjectsInactive)
public Object FindAnyObjectByType(Type type, FindObjectsInactive findObjectsInactive)
public string ToString()
public bool op_Equality(Object x, Object y)
public bool op_Inequality(Object x, Object y)
private int GetOffsetOfInstanceIDInCPlusPlusObject()
private bool CurrentThreadIsMainThread()
private Object Internal_CloneSingle(Object data)
private Object Internal_CloneSingleWithParent(Object data, Transform parent, bool worldPositionStays)
private Object Internal_InstantiateSingle(Object data, Vector3 pos, Quaternion rot)
private Object Internal_InstantiateSingleWithParent(Object data, Transform parent, Vector3 pos, Quaternion rot)
private string ToString(Object obj)
private string GetName(Object obj)
internal bool IsPersistent(Object obj)
private void SetName(Object obj, string name)
internal bool DoesObjectWithInstanceIDExist(int instanceID)
internal Object FindObjectFromInstanceID(int instanceID)
internal Object ForceLoadFromInstanceID(int instanceID)
private Object Internal_InstantiateSingle_Injected(Object data, Vector3& pos, Quaternion& rot)
private Object Internal_InstantiateSingleWithParent_Injected(Object data, Transform parent, Vector3& pos, Quaternion& rot)
}
public UnityEngine.OcclusionArea : Component {
public Vector3 center
public Vector3 size
public Vector3 get_center()
public void set_center(Vector3 value)
public Vector3 get_size()
public void set_size(Vector3 value)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
private void get_size_Injected(Vector3& ret)
private void set_size_Injected(Vector3& value)
}
public UnityEngine.OcclusionPortal : Component {
public bool open
public bool get_open()
public void set_open(bool value)
}
public UnityEngine.OperatingSystemFamily : Enum {
public int value__
public OperatingSystemFamily Other
public OperatingSystemFamily MacOSX
public OperatingSystemFamily Windows
public OperatingSystemFamily Linux
}
public UnityEngine.Ping : object {
internal IntPtr m_Ptr
public bool isDone
public int time
public string ip
public void .ctor(string address)
protected void Finalize()
public void DestroyPing()
private void Internal_Destroy(IntPtr ptr)
private IntPtr Internal_Create(string address)
public bool get_isDone()
private bool Internal_IsDone()
public int get_time()
public string get_ip()
}
public UnityEngine.Plane : ValueType {
internal int size
private Vector3 m_Normal
private float m_Distance
public Vector3 normal
public float distance
public Plane flipped
public Vector3 get_normal()
public void set_normal(Vector3 value)
public float get_distance()
public void set_distance(float value)
public void .ctor(Vector3 inNormal, Vector3 inPoint)
public void .ctor(Vector3 inNormal, float d)
public void .ctor(Vector3 a, Vector3 b, Vector3 c)
public void SetNormalAndPosition(Vector3 inNormal, Vector3 inPoint)
public void Set3Points(Vector3 a, Vector3 b, Vector3 c)
public void Flip()
public Plane get_flipped()
public void Translate(Vector3 translation)
public Plane Translate(Plane plane, Vector3 translation)
public Vector3 ClosestPointOnPlane(Vector3 point)
public float GetDistanceToPoint(Vector3 point)
public bool GetSide(Vector3 point)
public bool SameSide(Vector3 inPt0, Vector3 inPt1)
public bool Raycast(Ray ray, Single& enter)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
}
public UnityEngine.Playables.DataStreamType : Enum {
public int value__
public DataStreamType Animation
public DataStreamType Audio
public DataStreamType Texture
public DataStreamType None
}
public UnityEngine.Playables.DirectorUpdateMode : Enum {
public int value__
public DirectorUpdateMode DSPClock
public DirectorUpdateMode GameTime
public DirectorUpdateMode UnscaledGameTime
public DirectorUpdateMode Manual
}
public UnityEngine.Playables.DirectorWrapMode : Enum {
public int value__
public DirectorWrapMode Hold
public DirectorWrapMode Loop
public DirectorWrapMode None
}
public UnityEngine.Playables.FrameData : ValueType {
internal ulong m_FrameID
internal double m_DeltaTime
internal float m_Weight
internal float m_EffectiveWeight
internal double m_EffectiveParentDelay
internal float m_EffectiveParentSpeed
internal float m_EffectiveSpeed
internal Flags m_Flags
internal PlayableOutput m_Output
public ulong frameId
public float deltaTime
public float weight
public float effectiveWeight
public double effectiveParentDelay
public float effectiveParentSpeed
public float effectiveSpeed
public EvaluationType evaluationType
public bool seekOccurred
public bool timeLooped
public bool timeHeld
public PlayableOutput output
public PlayState effectivePlayState
private bool HasFlags(Flags flag)
public ulong get_frameId()
public float get_deltaTime()
public float get_weight()
public float get_effectiveWeight()
public double get_effectiveParentDelay()
public float get_effectiveParentSpeed()
public float get_effectiveSpeed()
public EvaluationType get_evaluationType()
public bool get_seekOccurred()
public bool get_timeLooped()
public bool get_timeHeld()
public PlayableOutput get_output()
public PlayState get_effectivePlayState()
}
internal UnityEngine.Playables.FrameRate : ValueType {
public FrameRate k_24Fps
public FrameRate k_23_976Fps
public FrameRate k_25Fps
public FrameRate k_30Fps
public FrameRate k_29_97Fps
public FrameRate k_50Fps
public FrameRate k_60Fps
public FrameRate k_59_94Fps
private int m_Rate
public bool dropFrame
public double rate
public bool get_dropFrame()
public double get_rate()
public void .ctor(UInt32 frameRate, bool drop)
public bool IsValid()
public bool Equals(FrameRate other)
public bool Equals(object obj)
public bool op_Equality(FrameRate a, FrameRate b)
public bool op_Inequality(FrameRate a, FrameRate b)
public bool op_LessThan(FrameRate a, FrameRate b)
public bool op_LessThanOrEqual(FrameRate a, FrameRate b)
public bool op_GreaterThan(FrameRate a, FrameRate b)
public bool op_GreaterThanOrEqual(FrameRate a, FrameRate b)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
internal int FrameRateToInt(FrameRate framerate)
internal FrameRate DoubleToFrameRate(double framerate)
}
public UnityEngine.Playables.INotification {
public PropertyName id
public PropertyName get_id()
}
public UnityEngine.Playables.INotificationReceiver {
public void OnNotify(Playable origin, INotification notification, object context)
}
public UnityEngine.Playables.IPlayable {
public PlayableHandle GetHandle()
}
public UnityEngine.Playables.IPlayableAsset {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
}
public UnityEngine.Playables.IPlayableBehaviour {
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
}
public UnityEngine.Playables.IPlayableOutput {
public PlayableOutputHandle GetHandle()
}
public UnityEngine.Playables.Notification : object {
private PropertyName <id>k__BackingField
public PropertyName id
public void .ctor(string name)
public PropertyName get_id()
}
public UnityEngine.Playables.Playable : ValueType {
private PlayableHandle m_Handle
private Playable m_NullPlayable
public Playable Null
public Playable get_Null()
public Playable Create(PlayableGraph graph, int inputCount)
internal void .ctor(PlayableHandle handle)
public PlayableHandle GetHandle()
public bool IsPlayableOfType()
public Type GetPlayableType()
public bool Equals(Playable other)
}
public UnityEngine.Playables.PlayableAsset : ScriptableObject {
public double duration
public IEnumerable`1<PlayableBinding> outputs
public Playable CreatePlayable(PlayableGraph graph, GameObject owner)
public double get_duration()
public IEnumerable`1<PlayableBinding> get_outputs()
internal void Internal_CreatePlayable(PlayableAsset asset, PlayableGraph graph, GameObject go, IntPtr ptr)
internal void Internal_GetPlayableAssetDuration(PlayableAsset asset, IntPtr ptrToDouble)
}
public UnityEngine.Playables.PlayableBehaviour : object {
public void OnGraphStart(Playable playable)
public void OnGraphStop(Playable playable)
public void OnPlayableCreate(Playable playable)
public void OnPlayableDestroy(Playable playable)
public void OnBehaviourDelay(Playable playable, FrameData info)
public void OnBehaviourPlay(Playable playable, FrameData info)
public void OnBehaviourPause(Playable playable, FrameData info)
public void PrepareData(Playable playable, FrameData info)
public void PrepareFrame(Playable playable, FrameData info)
public void ProcessFrame(Playable playable, FrameData info, object playerData)
public object Clone()
}
public UnityEngine.Playables.PlayableBinding : ValueType {
private string m_StreamName
private Object m_SourceObject
private Type m_SourceBindingType
private CreateOutputMethod m_CreateOutputMethod
public PlayableBinding[] None
public double DefaultDuration
public string streamName
public Object sourceObject
public Type outputTargetType
public Type sourceBindingType
public DataStreamType streamType
public string get_streamName()
public void set_streamName(string value)
public Object get_sourceObject()
public void set_sourceObject(Object value)
public Type get_outputTargetType()
public Type get_sourceBindingType()
public void set_sourceBindingType(Type value)
public DataStreamType get_streamType()
public void set_streamType(DataStreamType value)
internal PlayableOutput CreateOutput(PlayableGraph graph)
internal PlayableBinding CreateInternal(string name, Object sourceObject, Type sourceType, CreateOutputMethod createFunction)
}
public UnityEngine.Playables.PlayableExtensions : object {
public bool IsNull(U playable)
public bool IsValid(U playable)
public void Destroy(U playable)
public PlayableGraph GetGraph(U playable)
public void SetPlayState(U playable, PlayState value)
public PlayState GetPlayState(U playable)
public void Play(U playable)
public void Pause(U playable)
public void SetSpeed(U playable, double value)
public double GetSpeed(U playable)
public void SetDuration(U playable, double value)
public double GetDuration(U playable)
public void SetTime(U playable, double value)
public double GetTime(U playable)
public double GetPreviousTime(U playable)
public void SetDone(U playable, bool value)
public bool IsDone(U playable)
public void SetPropagateSetTime(U playable, bool value)
public bool GetPropagateSetTime(U playable)
public bool CanChangeInputs(U playable)
public bool CanSetWeights(U playable)
public bool CanDestroy(U playable)
public void SetInputCount(U playable, int value)
public int GetInputCount(U playable)
public void SetOutputCount(U playable, int value)
public int GetOutputCount(U playable)
public Playable GetInput(U playable, int inputPort)
public Playable GetOutput(U playable, int outputPort)
public void SetInputWeight(U playable, int inputIndex, float weight)
public void SetInputWeight(U playable, V input, float weight)
public float GetInputWeight(U playable, int inputIndex)
public void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex)
public void ConnectInput(U playable, int inputIndex, V sourcePlayable, int sourceOutputIndex, float weight)
public void DisconnectInput(U playable, int inputPort)
public int AddInput(U playable, V sourcePlayable, int sourceOutputIndex, float weight)
public void SetDelay(U playable, double delay)
public double GetDelay(U playable)
public bool IsDelayed(U playable)
public void SetLeadTime(U playable, float value)
public float GetLeadTime(U playable)
public PlayableTraversalMode GetTraversalMode(U playable)
public void SetTraversalMode(U playable, PlayableTraversalMode mode)
internal DirectorWrapMode GetTimeWrapMode(U playable)
internal void SetTimeWrapMode(U playable, DirectorWrapMode value)
}
public UnityEngine.Playables.PlayableGraph : ValueType {
internal IntPtr m_Handle
internal UInt32 m_Version
public Playable GetRootPlayable(int index)
public bool Connect(U source, int sourceOutputPort, V destination, int destinationInputPort)
public void Disconnect(U input, int inputPort)
public void DestroyPlayable(U playable)
public void DestroySubgraph(U playable)
public void DestroyOutput(U output)
public int GetOutputCountByType()
public PlayableOutput GetOutput(int index)
public PlayableOutput GetOutputByType(int index)
public void Evaluate()
public PlayableGraph Create()
public PlayableGraph Create(string name)
public void Destroy()
public bool IsValid()
public bool IsPlaying()
public bool IsDone()
public void Play()
public void Stop()
public void Evaluate(float deltaTime)
public DirectorUpdateMode GetTimeUpdateMode()
public void SetTimeUpdateMode(DirectorUpdateMode value)
public IExposedPropertyTable GetResolver()
public void SetResolver(IExposedPropertyTable value)
public int GetPlayableCount()
public int GetRootPlayableCount()
internal void SynchronizeEvaluation(PlayableGraph playable)
public int GetOutputCount()
internal PlayableHandle CreatePlayableHandle()
internal bool CreateScriptOutputInternal(string name, PlayableOutputHandle& handle)
internal PlayableHandle GetRootPlayableInternal(int index)
internal void DestroyOutputInternal(PlayableOutputHandle handle)
internal bool IsMatchFrameRateEnabled()
internal void EnableMatchFrameRate(FrameRate frameRate)
internal void DisableMatchFrameRate()
internal FrameRate GetFrameRate()
private bool GetOutputInternal(int index, PlayableOutputHandle& handle)
private int GetOutputCountByTypeInternal(Type outputType)
private bool GetOutputByTypeInternal(Type outputType, int index, PlayableOutputHandle& handle)
private bool ConnectInternal(PlayableHandle source, int sourceOutputPort, PlayableHandle destination, int destinationInputPort)
private void DisconnectInternal(PlayableHandle playable, int inputPort)
private void DestroyPlayableInternal(PlayableHandle playable)
private void DestroySubgraphInternal(PlayableHandle playable)
private void Create_Injected(string name, PlayableGraph& ret)
private void Destroy_Injected(PlayableGraph& _unity_self)
private bool IsValid_Injected(PlayableGraph& _unity_self)
private bool IsPlaying_Injected(PlayableGraph& _unity_self)
private bool IsDone_Injected(PlayableGraph& _unity_self)
private void Play_Injected(PlayableGraph& _unity_self)
private void Stop_Injected(PlayableGraph& _unity_self)
private void Evaluate_Injected(PlayableGraph& _unity_self, float deltaTime)
private DirectorUpdateMode GetTimeUpdateMode_Injected(PlayableGraph& _unity_self)
private void SetTimeUpdateMode_Injected(PlayableGraph& _unity_self, DirectorUpdateMode value)
private IExposedPropertyTable GetResolver_Injected(PlayableGraph& _unity_self)
private void SetResolver_Injected(PlayableGraph& _unity_self, IExposedPropertyTable value)
private int GetPlayableCount_Injected(PlayableGraph& _unity_self)
private int GetRootPlayableCount_Injected(PlayableGraph& _unity_self)
private void SynchronizeEvaluation_Injected(PlayableGraph& _unity_self, PlayableGraph& playable)
private int GetOutputCount_Injected(PlayableGraph& _unity_self)
private void CreatePlayableHandle_Injected(PlayableGraph& _unity_self, PlayableHandle& ret)
private bool CreateScriptOutputInternal_Injected(PlayableGraph& _unity_self, string name, PlayableOutputHandle& handle)
private void GetRootPlayableInternal_Injected(PlayableGraph& _unity_self, int index, PlayableHandle& ret)
private void DestroyOutputInternal_Injected(PlayableGraph& _unity_self, PlayableOutputHandle& handle)
private bool IsMatchFrameRateEnabled_Injected(PlayableGraph& _unity_self)
private void EnableMatchFrameRate_Injected(PlayableGraph& _unity_self, FrameRate& frameRate)
private void DisableMatchFrameRate_Injected(PlayableGraph& _unity_self)
private void GetFrameRate_Injected(PlayableGraph& _unity_self, FrameRate& ret)
private bool GetOutputInternal_Injected(PlayableGraph& _unity_self, int index, PlayableOutputHandle& handle)
private int GetOutputCountByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType)
private bool GetOutputByTypeInternal_Injected(PlayableGraph& _unity_self, Type outputType, int index, PlayableOutputHandle& handle)
private bool ConnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& source, int sourceOutputPort, PlayableHandle& destination, int destinationInputPort)
private void DisconnectInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable, int inputPort)
private void DestroyPlayableInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable)
private void DestroySubgraphInternal_Injected(PlayableGraph& _unity_self, PlayableHandle& playable)
}
public UnityEngine.Playables.PlayableHandle : ValueType {
internal IntPtr m_Handle
internal UInt32 m_Version
private PlayableHandle m_Null
public PlayableHandle Null
internal T GetObject()
internal bool IsPlayableOfType()
public PlayableHandle get_Null()
internal Playable GetInput(int inputPort)
internal Playable GetOutput(int outputPort)
internal bool SetInputWeight(int inputIndex, float weight)
internal float GetInputWeight(int inputIndex)
internal void Destroy()
public bool op_Equality(PlayableHandle x, PlayableHandle y)
public bool op_Inequality(PlayableHandle x, PlayableHandle y)
public bool Equals(object p)
public bool Equals(PlayableHandle other)
public int GetHashCode()
internal bool CompareVersion(PlayableHandle lhs, PlayableHandle rhs)
internal bool CheckInputBounds(int inputIndex)
internal bool CheckInputBounds(int inputIndex, bool acceptAny)
internal bool IsNull()
internal bool IsValid()
internal Type GetPlayableType()
internal Type GetJobType()
internal void SetScriptInstance(object scriptInstance)
internal bool CanChangeInputs()
internal bool CanSetWeights()
internal bool CanDestroy()
internal PlayState GetPlayState()
internal void Play()
internal void Pause()
internal double GetSpeed()
internal void SetSpeed(double value)
internal double GetTime()
internal void SetTime(double value)
internal bool IsDone()
internal void SetDone(bool value)
internal double GetDuration()
internal void SetDuration(double value)
internal bool GetPropagateSetTime()
internal void SetPropagateSetTime(bool value)
internal PlayableGraph GetGraph()
internal int GetInputCount()
internal void SetInputCount(int value)
internal int GetOutputCount()
internal void SetOutputCount(int value)
internal void SetInputWeight(PlayableHandle input, float weight)
internal void SetDelay(double delay)
internal double GetDelay()
internal bool IsDelayed()
internal double GetPreviousTime()
internal void SetLeadTime(float value)
internal float GetLeadTime()
internal PlayableTraversalMode GetTraversalMode()
internal void SetTraversalMode(PlayableTraversalMode mode)
internal IntPtr GetJobData()
internal DirectorWrapMode GetTimeWrapMode()
internal void SetTimeWrapMode(DirectorWrapMode mode)
private object GetScriptInstance()
private PlayableHandle GetInputHandle(int index)
private PlayableHandle GetOutputHandle(int index)
private void SetInputWeightFromIndex(int index, float weight)
private float GetInputWeightFromIndex(int index)
private bool IsNull_Injected(PlayableHandle& _unity_self)
private bool IsValid_Injected(PlayableHandle& _unity_self)
private Type GetPlayableType_Injected(PlayableHandle& _unity_self)
private Type GetJobType_Injected(PlayableHandle& _unity_self)
private void SetScriptInstance_Injected(PlayableHandle& _unity_self, object scriptInstance)
private bool CanChangeInputs_Injected(PlayableHandle& _unity_self)
private bool CanSetWeights_Injected(PlayableHandle& _unity_self)
private bool CanDestroy_Injected(PlayableHandle& _unity_self)
private PlayState GetPlayState_Injected(PlayableHandle& _unity_self)
private void Play_Injected(PlayableHandle& _unity_self)
private void Pause_Injected(PlayableHandle& _unity_self)
private double GetSpeed_Injected(PlayableHandle& _unity_self)
private void SetSpeed_Injected(PlayableHandle& _unity_self, double value)
private double GetTime_Injected(PlayableHandle& _unity_self)
private void SetTime_Injected(PlayableHandle& _unity_self, double value)
private bool IsDone_Injected(PlayableHandle& _unity_self)
private void SetDone_Injected(PlayableHandle& _unity_self, bool value)
private double GetDuration_Injected(PlayableHandle& _unity_self)
private void SetDuration_Injected(PlayableHandle& _unity_self, double value)
private bool GetPropagateSetTime_Injected(PlayableHandle& _unity_self)
private void SetPropagateSetTime_Injected(PlayableHandle& _unity_self, bool value)
private void GetGraph_Injected(PlayableHandle& _unity_self, PlayableGraph& ret)
private int GetInputCount_Injected(PlayableHandle& _unity_self)
private void SetInputCount_Injected(PlayableHandle& _unity_self, int value)
private int GetOutputCount_Injected(PlayableHandle& _unity_self)
private void SetOutputCount_Injected(PlayableHandle& _unity_self, int value)
private void SetInputWeight_Injected(PlayableHandle& _unity_self, PlayableHandle& input, float weight)
private void SetDelay_Injected(PlayableHandle& _unity_self, double delay)
private double GetDelay_Injected(PlayableHandle& _unity_self)
private bool IsDelayed_Injected(PlayableHandle& _unity_self)
private double GetPreviousTime_Injected(PlayableHandle& _unity_self)
private void SetLeadTime_Injected(PlayableHandle& _unity_self, float value)
private float GetLeadTime_Injected(PlayableHandle& _unity_self)
private PlayableTraversalMode GetTraversalMode_Injected(PlayableHandle& _unity_self)
private void SetTraversalMode_Injected(PlayableHandle& _unity_self, PlayableTraversalMode mode)
private IntPtr GetJobData_Injected(PlayableHandle& _unity_self)
private DirectorWrapMode GetTimeWrapMode_Injected(PlayableHandle& _unity_self)
private void SetTimeWrapMode_Injected(PlayableHandle& _unity_self, DirectorWrapMode mode)
private object GetScriptInstance_Injected(PlayableHandle& _unity_self)
private void GetInputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret)
private void GetOutputHandle_Injected(PlayableHandle& _unity_self, int index, PlayableHandle& ret)
private void SetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index, float weight)
private float GetInputWeightFromIndex_Injected(PlayableHandle& _unity_self, int index)
}
public UnityEngine.Playables.PlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
private PlayableOutput m_NullPlayableOutput
public PlayableOutput Null
public PlayableOutput get_Null()
internal void .ctor(PlayableOutputHandle handle)
public PlayableOutputHandle GetHandle()
public bool IsPlayableOutputOfType()
public Type GetPlayableOutputType()
public bool Equals(PlayableOutput other)
}
public UnityEngine.Playables.PlayableOutputExtensions : object {
public bool IsOutputNull(U output)
public bool IsOutputValid(U output)
public Object GetReferenceObject(U output)
public void SetReferenceObject(U output, Object value)
public Object GetUserData(U output)
public void SetUserData(U output, Object value)
public Playable GetSourcePlayable(U output)
public void SetSourcePlayable(U output, V value)
public void SetSourcePlayable(U output, V value, int port)
public int GetSourceOutputPort(U output)
public float GetWeight(U output)
public void SetWeight(U output, float value)
public void PushNotification(U output, Playable origin, INotification notification, object context)
public INotificationReceiver[] GetNotificationReceivers(U output)
public void AddNotificationReceiver(U output, INotificationReceiver receiver)
public void RemoveNotificationReceiver(U output, INotificationReceiver receiver)
public int GetSourceInputPort(U output)
public void SetSourceInputPort(U output, int value)
public void SetSourceOutputPort(U output, int value)
}
public UnityEngine.Playables.PlayableOutputHandle : ValueType {
internal IntPtr m_Handle
internal UInt32 m_Version
private PlayableOutputHandle m_Null
public PlayableOutputHandle Null
public PlayableOutputHandle get_Null()
internal bool IsPlayableOutputOfType()
public int GetHashCode()
public bool op_Equality(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
public bool op_Inequality(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
public bool Equals(object p)
public bool Equals(PlayableOutputHandle other)
internal bool CompareVersion(PlayableOutputHandle lhs, PlayableOutputHandle rhs)
internal bool IsNull()
internal bool IsValid()
internal Type GetPlayableOutputType()
internal Object GetReferenceObject()
internal void SetReferenceObject(Object target)
internal Object GetUserData()
internal void SetUserData(Object target)
internal PlayableHandle GetSourcePlayable()
internal void SetSourcePlayable(PlayableHandle target, int port)
internal int GetSourceOutputPort()
internal float GetWeight()
internal void SetWeight(float weight)
internal void PushNotification(PlayableHandle origin, INotification notification, object context)
internal INotificationReceiver[] GetNotificationReceivers()
internal void AddNotificationReceiver(INotificationReceiver receiver)
internal void RemoveNotificationReceiver(INotificationReceiver receiver)
private bool IsNull_Injected(PlayableOutputHandle& _unity_self)
private bool IsValid_Injected(PlayableOutputHandle& _unity_self)
private Type GetPlayableOutputType_Injected(PlayableOutputHandle& _unity_self)
private Object GetReferenceObject_Injected(PlayableOutputHandle& _unity_self)
private void SetReferenceObject_Injected(PlayableOutputHandle& _unity_self, Object target)
private Object GetUserData_Injected(PlayableOutputHandle& _unity_self)
private void SetUserData_Injected(PlayableOutputHandle& _unity_self, Object target)
private void GetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& ret)
private void SetSourcePlayable_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& target, int port)
private int GetSourceOutputPort_Injected(PlayableOutputHandle& _unity_self)
private float GetWeight_Injected(PlayableOutputHandle& _unity_self)
private void SetWeight_Injected(PlayableOutputHandle& _unity_self, float weight)
private void PushNotification_Injected(PlayableOutputHandle& _unity_self, PlayableHandle& origin, INotification notification, object context)
private INotificationReceiver[] GetNotificationReceivers_Injected(PlayableOutputHandle& _unity_self)
private void AddNotificationReceiver_Injected(PlayableOutputHandle& _unity_self, INotificationReceiver receiver)
private void RemoveNotificationReceiver_Injected(PlayableOutputHandle& _unity_self, INotificationReceiver receiver)
}
public UnityEngine.Playables.PlayableTraversalMode : Enum {
public int value__
public PlayableTraversalMode Mix
public PlayableTraversalMode Passthrough
}
public UnityEngine.Playables.PlayState : Enum {
public int value__
public PlayState Paused
public PlayState Playing
public PlayState Delayed
}
public UnityEngine.Playables.ScriptPlayable`1 : ValueType {
private PlayableHandle m_Handle
private ScriptPlayable`1<T> m_NullPlayable
public ScriptPlayable`1<T> Null
public ScriptPlayable`1<T> get_Null()
public ScriptPlayable`1<T> Create(PlayableGraph graph, int inputCount)
public ScriptPlayable`1<T> Create(PlayableGraph graph, T template, int inputCount)
private PlayableHandle CreateHandle(PlayableGraph graph, T template, int inputCount)
private object CreateScriptInstance()
private object CloneScriptInstance(IPlayableBehaviour source)
private object CloneScriptInstanceFromEngineObject(Object source)
private object CloneScriptInstanceFromIClonable(ICloneable source)
internal void .ctor(PlayableHandle handle)
public PlayableHandle GetHandle()
public T GetBehaviour()
public Playable op_Implicit(ScriptPlayable`1<T> playable)
public ScriptPlayable`1<T> op_Explicit(Playable playable)
public bool Equals(ScriptPlayable`1<T> other)
}
public UnityEngine.Playables.ScriptPlayableBinding : object {
public PlayableBinding Create(string name, Object key, Type type)
private PlayableOutput CreateScriptOutput(PlayableGraph graph, string name)
}
public UnityEngine.Playables.ScriptPlayableOutput : ValueType {
private PlayableOutputHandle m_Handle
public ScriptPlayableOutput Null
public ScriptPlayableOutput Create(PlayableGraph graph, string name)
internal void .ctor(PlayableOutputHandle handle)
public ScriptPlayableOutput get_Null()
public PlayableOutputHandle GetHandle()
public PlayableOutput op_Implicit(ScriptPlayableOutput output)
public ScriptPlayableOutput op_Explicit(PlayableOutput output)
}
internal UnityEngine.PlayerConnectionInternal : object {
private void UnityEngine.IPlayerEditorConnectionNative.SendMessage(Guid messageId, Byte[] data, int playerId)
private bool UnityEngine.IPlayerEditorConnectionNative.TrySendMessage(Guid messageId, Byte[] data, int playerId)
private void UnityEngine.IPlayerEditorConnectionNative.Poll()
private void UnityEngine.IPlayerEditorConnectionNative.RegisterInternal(Guid messageId)
private void UnityEngine.IPlayerEditorConnectionNative.UnregisterInternal(Guid messageId)
private void UnityEngine.IPlayerEditorConnectionNative.Initialize()
private bool UnityEngine.IPlayerEditorConnectionNative.IsConnected()
private void UnityEngine.IPlayerEditorConnectionNative.DisconnectAll()
private bool IsConnected()
private void Initialize()
private void RegisterInternal(string messageId)
private void UnregisterInternal(string messageId)
private void SendMessage(string messageId, Byte[] data, int playerId)
private bool TrySendMessage(string messageId, Byte[] data, int playerId)
private void PollInternal()
private void DisconnectAll()
}
public UnityEngine.PlayerPrefs : object {
private bool TrySetInt(string key, int value)
private bool TrySetFloat(string key, float value)
private bool TrySetSetString(string key, string value)
public void SetInt(string key, int value)
public int GetInt(string key, int defaultValue)
public int GetInt(string key)
public void SetFloat(string key, float value)
public float GetFloat(string key, float defaultValue)
public float GetFloat(string key)
public void SetString(string key, string value)
public string GetString(string key, string defaultValue)
public string GetString(string key)
public bool HasKey(string key)
public void DeleteKey(string key)
public void DeleteAll()
public void Save()
}
public UnityEngine.PlayerPrefsException : Exception {
public void .ctor(string error)
}
public UnityEngine.Pool.CollectionPool`2 : object {
internal ObjectPool`1<TCollection> s_Pool
public TCollection Get()
public PooledObject`1<TCollection> Get(TCollection& value)
public void Release(TCollection toRelease)
}
public UnityEngine.Pool.GenericPool`1 : object {
internal ObjectPool`1<T> s_Pool
public T Get()
public PooledObject`1<T> Get(T& value)
public void Release(T toRelease)
}
public UnityEngine.Pool.IObjectPool`1 {
public int CountInactive
public int get_CountInactive()
public T Get()
public PooledObject`1<T> Get(T& v)
public void Release(T element)
public void Clear()
}
public UnityEngine.Pool.LinkedPool`1 : object {
private Func`1<T> m_CreateFunc
private Action`1<T> m_ActionOnGet
private Action`1<T> m_ActionOnRelease
private Action`1<T> m_ActionOnDestroy
private int m_Limit
internal LinkedPoolItem<T> m_PoolFirst
internal LinkedPoolItem<T> m_NextAvailableListItem
private bool m_CollectionCheck
private int <CountInactive>k__BackingField
public int CountInactive
public void .ctor(Func`1<T> createFunc, Action`1<T> actionOnGet, Action`1<T> actionOnRelease, Action`1<T> actionOnDestroy, bool collectionCheck, int maxSize)
public int get_CountInactive()
private void set_CountInactive(int value)
public T Get()
public PooledObject`1<T> Get(T& v)
public void Release(T item)
public void Clear()
public void Dispose()
}
public UnityEngine.Pool.ObjectPool`1 : object {
internal List`1<T> m_List
private Func`1<T> m_CreateFunc
private Action`1<T> m_ActionOnGet
private Action`1<T> m_ActionOnRelease
private Action`1<T> m_ActionOnDestroy
private int m_MaxSize
internal bool m_CollectionCheck
private int <CountAll>k__BackingField
public int CountAll
public int CountActive
public int CountInactive
public int get_CountAll()
private void set_CountAll(int value)
public int get_CountActive()
public int get_CountInactive()
public void .ctor(Func`1<T> createFunc, Action`1<T> actionOnGet, Action`1<T> actionOnRelease, Action`1<T> actionOnDestroy, bool collectionCheck, int defaultCapacity, int maxSize)
public T Get()
public PooledObject`1<T> Get(T& v)
public void Release(T element)
public void Clear()
public void Dispose()
}
public UnityEngine.Pool.PooledObject`1 : ValueType {
private T m_ToReturn
private IObjectPool`1<T> m_Pool
internal void .ctor(T value, IObjectPool`1<T> pool)
private void System.IDisposable.Dispose()
}
public UnityEngine.Pool.UnsafeGenericPool`1 : object {
internal ObjectPool`1<T> s_Pool
public T Get()
public PooledObject`1<T> Get(T& value)
public void Release(T toRelease)
}
public UnityEngine.Pose : ValueType {
public Vector3 position
public Quaternion rotation
private Pose k_Identity
public Vector3 forward
public Vector3 right
public Vector3 up
public Pose identity
public void .ctor(Vector3 position, Quaternion rotation)
public string ToString()
public string ToString(string format)
public Pose GetTransformedBy(Pose lhs)
public Pose GetTransformedBy(Transform lhs)
public Vector3 get_forward()
public Vector3 get_right()
public Vector3 get_up()
public Pose get_identity()
public bool Equals(object obj)
public bool Equals(Pose other)
public int GetHashCode()
public bool op_Equality(Pose a, Pose b)
public bool op_Inequality(Pose a, Pose b)
}
internal UnityEngine.PreloadData : Object {
internal void PreloadDataDontStripMe()
}
public UnityEngine.PrimitiveType : Enum {
public int value__
public PrimitiveType Sphere
public PrimitiveType Capsule
public PrimitiveType Cylinder
public PrimitiveType Cube
public PrimitiveType Plane
public PrimitiveType Quad
}
public UnityEngine.Profiling.CustomSampler : Sampler {
internal CustomSampler s_InvalidCustomSampler
internal void .ctor(IntPtr ptr)
public CustomSampler Create(string name, bool collectGpuData)
public void Begin()
public void Begin(Object targetObject)
public void End()
}
public UnityEngine.Profiling.Experimental.DebugScreenCapture : ValueType {
private NativeArray`1<byte> <rawImageDataReference>k__BackingField
private TextureFormat <imageFormat>k__BackingField
private int <width>k__BackingField
private int <height>k__BackingField
public NativeArray`1<byte> rawImageDataReference
public TextureFormat imageFormat
public int width
public int height
public NativeArray`1<byte> get_rawImageDataReference()
public void set_rawImageDataReference(NativeArray`1<byte> value)
public TextureFormat get_imageFormat()
public void set_imageFormat(TextureFormat value)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
}
public UnityEngine.Profiling.Memory.Experimental.CaptureFlags : Enum {
public UInt32 value__
public CaptureFlags ManagedObjects
public CaptureFlags NativeObjects
public CaptureFlags NativeAllocations
public CaptureFlags NativeAllocationSites
public CaptureFlags NativeStackTraces
}
public UnityEngine.Profiling.Memory.Experimental.MemoryProfiler : object {
private Action`2<string, bool> m_SnapshotFinished
private Action`3<string, bool, DebugScreenCapture> m_SaveScreenshotToDisk
private Action`1<MetaData> createMetaData
private void add_m_SnapshotFinished(Action`2<string, bool> value)
private void remove_m_SnapshotFinished(Action`2<string, bool> value)
private void add_m_SaveScreenshotToDisk(Action`3<string, bool, DebugScreenCapture> value)
private void remove_m_SaveScreenshotToDisk(Action`3<string, bool, DebugScreenCapture> value)
public void add_createMetaData(Action`1<MetaData> value)
public void remove_createMetaData(Action`1<MetaData> value)
private void StartOperation(UInt32 captureFlag, bool requestScreenshot, string path, bool isRemote)
public void TakeSnapshot(string path, Action`2<string, bool> finishCallback, CaptureFlags captureFlags)
public void TakeSnapshot(string path, Action`2<string, bool> finishCallback, Action`3<string, bool, DebugScreenCapture> screenshotCallback, CaptureFlags captureFlags)
public void TakeTempSnapshot(Action`2<string, bool> finishCallback, CaptureFlags captureFlags)
private Byte[] PrepareMetadata()
internal int WriteIntToByteArray(Byte[] array, int offset, int value)
internal int WriteStringToByteArray(Byte[] array, int offset, string value)
private void FinalizeSnapshot(string path, bool result)
private void SaveScreenshotToDisk(string path, bool result, IntPtr pixelsPtr, int pixelsCount, TextureFormat format, int width, int height)
}
public UnityEngine.Profiling.Memory.Experimental.MetaData : object {
public string content
public string platform
}
public UnityEngine.Profiling.Profiler : object {
internal UInt32 invalidProfilerArea
public bool supported
public string logFile
public bool enableBinaryLog
public int maxUsedMemory
public bool enabled
public bool enableAllocationCallstacks
public int areaCount
public int maxNumberOfSamplesPerFrame
public UInt32 usedHeapSize
public long usedHeapSizeLong
public bool get_supported()
public string get_logFile()
public void set_logFile(string value)
public bool get_enableBinaryLog()
public void set_enableBinaryLog(bool value)
public int get_maxUsedMemory()
public void set_maxUsedMemory(int value)
public bool get_enabled()
public void set_enabled(bool value)
public bool get_enableAllocationCallstacks()
public void set_enableAllocationCallstacks(bool value)
public void SetAreaEnabled(ProfilerArea area, bool enabled)
public int get_areaCount()
public bool GetAreaEnabled(ProfilerArea area)
public void AddFramesFromFile(string file)
private void AddFramesFromFile_Internal(string file, bool keepExistingFrames)
public void BeginThreadProfiling(string threadGroupName, string threadName)
private void BeginThreadProfilingInternal(string threadGroupName, string threadName)
public void EndThreadProfiling()
public void BeginSample(string name)
public void BeginSample(string name, Object targetObject)
private void ValidateArguments(string name)
private void BeginSampleImpl(string name, Object targetObject)
public void EndSample()
public int get_maxNumberOfSamplesPerFrame()
public void set_maxNumberOfSamplesPerFrame(int value)
public UInt32 get_usedHeapSize()
public long get_usedHeapSizeLong()
public int GetRuntimeMemorySize(Object o)
public long GetRuntimeMemorySizeLong(Object o)
public UInt32 GetMonoHeapSize()
public long GetMonoHeapSizeLong()
public UInt32 GetMonoUsedSize()
public long GetMonoUsedSizeLong()
public bool SetTempAllocatorRequestedSize(UInt32 size)
public UInt32 GetTempAllocatorSize()
public UInt32 GetTotalAllocatedMemory()
public long GetTotalAllocatedMemoryLong()
public UInt32 GetTotalUnusedReservedMemory()
public long GetTotalUnusedReservedMemoryLong()
public UInt32 GetTotalReservedMemory()
public long GetTotalReservedMemoryLong()
public long GetTotalFragmentationInfo(NativeArray`1<int> stats)
private long InternalGetTotalFragmentationInfo(IntPtr pStats, int count)
public long GetAllocatedMemoryForGraphicsDriver()
public void EmitFrameMetaData(Guid id, int tag, Array data)
public void EmitFrameMetaData(Guid id, int tag, List`1<T> data)
public void EmitFrameMetaData(Guid id, int tag, NativeArray`1<T> data)
public void EmitSessionMetaData(Guid id, int tag, Array data)
public void EmitSessionMetaData(Guid id, int tag, List`1<T> data)
public void EmitSessionMetaData(Guid id, int tag, NativeArray`1<T> data)
private void Internal_EmitGlobalMetaData_Array(Void* id, int idLen, int tag, Array data, int count, int elementSize, bool frameData)
private void Internal_EmitGlobalMetaData_Native(Void* id, int idLen, int tag, IntPtr data, int count, int elementSize, bool frameData)
public void SetCategoryEnabled(ProfilerCategory category, bool enabled)
public bool IsCategoryEnabled(ProfilerCategory category)
public UInt32 GetCategoriesCount()
public void GetAllCategories(ProfilerCategory[] categories)
public void GetAllCategories(NativeArray`1<ProfilerCategory> categories)
private void Internal_SetCategoryEnabled(ushort categoryId, bool enabled)
private bool Internal_IsCategoryEnabled(ushort categoryId)
}
public UnityEngine.Profiling.ProfilerArea : Enum {
public int value__
public ProfilerArea CPU
public ProfilerArea GPU
public ProfilerArea Rendering
public ProfilerArea Memory
public ProfilerArea Audio
public ProfilerArea Video
public ProfilerArea Physics
public ProfilerArea Physics2D
public ProfilerArea NetworkMessages
public ProfilerArea NetworkOperations
public ProfilerArea UI
public ProfilerArea UIDetails
public ProfilerArea GlobalIllumination
public ProfilerArea VirtualTexturing
}
public UnityEngine.Profiling.Recorder : object {
private ProfilerRecorderOptions s_RecorderDefaultOptions
internal Recorder s_InvalidRecorder
private ProfilerRecorder m_RecorderCPU
private ProfilerRecorder m_RecorderGPU
public bool isValid
public bool enabled
public long elapsedNanoseconds
public long gpuElapsedNanoseconds
public int sampleBlockCount
public int gpuSampleBlockCount
internal void .ctor(ProfilerRecorderHandle handle)
protected void Finalize()
public Recorder Get(string samplerName)
public bool get_isValid()
public bool get_enabled()
public void set_enabled(bool value)
public long get_elapsedNanoseconds()
public long get_gpuElapsedNanoseconds()
public int get_sampleBlockCount()
public int get_gpuSampleBlockCount()
public void FilterToCurrentThread()
public void CollectFromAllThreads()
private void SetEnabled(bool state)
}
public UnityEngine.Profiling.Sampler : object {
internal IntPtr m_Ptr
internal Sampler s_InvalidSampler
public bool isValid
public string name
internal void .ctor(IntPtr ptr)
public bool get_isValid()
public Recorder GetRecorder()
public Sampler Get(string name)
public int GetNames(List`1<string> names)
public string get_name()
}
public UnityEngine.Projector : Behaviour {
public float nearClipPlane
public float farClipPlane
public float fieldOfView
public float aspectRatio
public bool orthographic
public float orthographicSize
public int ignoreLayers
public Material material
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public float get_aspectRatio()
public void set_aspectRatio(float value)
public bool get_orthographic()
public void set_orthographic(bool value)
public float get_orthographicSize()
public void set_orthographicSize(float value)
public int get_ignoreLayers()
public void set_ignoreLayers(int value)
public Material get_material()
public void set_material(Material value)
}
public UnityEngine.PropertyAttribute : Attribute {
private int <order>k__BackingField
public int order
public int get_order()
public void set_order(int value)
}
public UnityEngine.PropertyName : ValueType {
internal int id
public void .ctor(string name)
public void .ctor(PropertyName other)
public void .ctor(int id)
public bool IsNullOrEmpty(PropertyName prop)
public bool op_Equality(PropertyName lhs, PropertyName rhs)
public bool op_Inequality(PropertyName lhs, PropertyName rhs)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(PropertyName other)
public PropertyName op_Implicit(string name)
public PropertyName op_Implicit(int id)
public string ToString()
}
internal UnityEngine.PropertyNameUtils : object {
public PropertyName PropertyNameFromString(string name)
private void PropertyNameFromString_Injected(string name, PropertyName& ret)
}
public UnityEngine.QualityLevel : Enum {
public int value__
public QualityLevel Fastest
public QualityLevel Fast
public QualityLevel Simple
public QualityLevel Good
public QualityLevel Beautiful
public QualityLevel Fantastic
}
public UnityEngine.QualitySettings : Object {
public QualityLevel currentLevel
public int pixelLightCount
public ShadowQuality shadows
public ShadowProjection shadowProjection
public int shadowCascades
public float shadowDistance
public ShadowResolution shadowResolution
public ShadowmaskMode shadowmaskMode
public float shadowNearPlaneOffset
public float shadowCascade2Split
public Vector3 shadowCascade4Split
public float lodBias
public AnisotropicFiltering anisotropicFiltering
public int masterTextureLimit
public int maximumLODLevel
public int particleRaycastBudget
public bool softParticles
public bool softVegetation
public int vSyncCount
public int realtimeGICPUUsage
public int antiAliasing
public int asyncUploadTimeSlice
public int asyncUploadBufferSize
public bool asyncUploadPersistentBuffer
public bool realtimeReflectionProbes
public bool billboardsFaceCameraPosition
public float resolutionScalingFixedDPIFactor
private ScriptableObject INTERNAL_renderPipeline
public RenderPipelineAsset renderPipeline
public BlendWeights blendWeights
public SkinWeights skinWeights
public bool streamingMipmapsActive
public float streamingMipmapsMemoryBudget
public int streamingMipmapsRenderersPerFrame
public int streamingMipmapsMaxLevelReduction
public bool streamingMipmapsAddAllCameras
public int streamingMipmapsMaxFileIORequests
public int maxQueuedFrames
public String[] names
public ColorSpace desiredColorSpace
public ColorSpace activeColorSpace
public void IncreaseLevel(bool applyExpensiveChanges)
public void DecreaseLevel(bool applyExpensiveChanges)
public void SetQualityLevel(int index)
public void IncreaseLevel()
public void DecreaseLevel()
public QualityLevel get_currentLevel()
public void set_currentLevel(QualityLevel value)
public int get_pixelLightCount()
public void set_pixelLightCount(int value)
public ShadowQuality get_shadows()
public void set_shadows(ShadowQuality value)
public ShadowProjection get_shadowProjection()
public void set_shadowProjection(ShadowProjection value)
public int get_shadowCascades()
public void set_shadowCascades(int value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public ShadowResolution get_shadowResolution()
public void set_shadowResolution(ShadowResolution value)
public ShadowmaskMode get_shadowmaskMode()
public void set_shadowmaskMode(ShadowmaskMode value)
public float get_shadowNearPlaneOffset()
public void set_shadowNearPlaneOffset(float value)
public float get_shadowCascade2Split()
public void set_shadowCascade2Split(float value)
public Vector3 get_shadowCascade4Split()
public void set_shadowCascade4Split(Vector3 value)
public float get_lodBias()
public void set_lodBias(float value)
public AnisotropicFiltering get_anisotropicFiltering()
public void set_anisotropicFiltering(AnisotropicFiltering value)
public int get_masterTextureLimit()
public void set_masterTextureLimit(int value)
public int get_maximumLODLevel()
public void set_maximumLODLevel(int value)
public int get_particleRaycastBudget()
public void set_particleRaycastBudget(int value)
public bool get_softParticles()
public void set_softParticles(bool value)
public bool get_softVegetation()
public void set_softVegetation(bool value)
public int get_vSyncCount()
public void set_vSyncCount(int value)
public int get_realtimeGICPUUsage()
public void set_realtimeGICPUUsage(int value)
public int get_antiAliasing()
public void set_antiAliasing(int value)
public int get_asyncUploadTimeSlice()
public void set_asyncUploadTimeSlice(int value)
public int get_asyncUploadBufferSize()
public void set_asyncUploadBufferSize(int value)
public bool get_asyncUploadPersistentBuffer()
public void set_asyncUploadPersistentBuffer(bool value)
public void SetLODSettings(float lodBias, int maximumLODLevel, bool setDirty)
public bool get_realtimeReflectionProbes()
public void set_realtimeReflectionProbes(bool value)
public bool get_billboardsFaceCameraPosition()
public void set_billboardsFaceCameraPosition(bool value)
public float get_resolutionScalingFixedDPIFactor()
public void set_resolutionScalingFixedDPIFactor(float value)
private ScriptableObject get_INTERNAL_renderPipeline()
private void set_INTERNAL_renderPipeline(ScriptableObject value)
public RenderPipelineAsset get_renderPipeline()
public void set_renderPipeline(RenderPipelineAsset value)
internal ScriptableObject InternalGetRenderPipelineAssetAt(int index)
public RenderPipelineAsset GetRenderPipelineAssetAt(int index)
public BlendWeights get_blendWeights()
public void set_blendWeights(BlendWeights value)
public SkinWeights get_skinWeights()
public void set_skinWeights(SkinWeights value)
public bool get_streamingMipmapsActive()
public void set_streamingMipmapsActive(bool value)
public float get_streamingMipmapsMemoryBudget()
public void set_streamingMipmapsMemoryBudget(float value)
public int get_streamingMipmapsRenderersPerFrame()
public void set_streamingMipmapsRenderersPerFrame(int value)
public int get_streamingMipmapsMaxLevelReduction()
public void set_streamingMipmapsMaxLevelReduction(int value)
public bool get_streamingMipmapsAddAllCameras()
public void set_streamingMipmapsAddAllCameras(bool value)
public int get_streamingMipmapsMaxFileIORequests()
public void set_streamingMipmapsMaxFileIORequests(int value)
public int get_maxQueuedFrames()
public void set_maxQueuedFrames(int value)
public int GetQualityLevel()
public Object GetQualitySettings()
public void SetQualityLevel(int index, bool applyExpensiveChanges)
public String[] get_names()
public ColorSpace get_desiredColorSpace()
public ColorSpace get_activeColorSpace()
private void get_shadowCascade4Split_Injected(Vector3& ret)
private void set_shadowCascade4Split_Injected(Vector3& value)
}
public UnityEngine.Quaternion : ValueType {
public float x
public float y
public float z
public float w
private Quaternion identityQuaternion
public float kEpsilon
public float Item
public Quaternion identity
public Vector3 eulerAngles
public Quaternion normalized
public Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection)
public Quaternion Inverse(Quaternion rotation)
public Quaternion Slerp(Quaternion a, Quaternion b, float t)
public Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t)
public Quaternion Lerp(Quaternion a, Quaternion b, float t)
public Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t)
private Quaternion Internal_FromEulerRad(Vector3 euler)
private Vector3 Internal_ToEulerRad(Quaternion rotation)
private void Internal_ToAxisAngleRad(Quaternion q, Vector3& axis, Single& angle)
public Quaternion AngleAxis(float angle, Vector3 axis)
public Quaternion LookRotation(Vector3 forward, Vector3 upwards)
public Quaternion LookRotation(Vector3 forward)
public float get_Item(int index)
public void set_Item(int index, float value)
public void .ctor(float x, float y, float z, float w)
public void Set(float newX, float newY, float newZ, float newW)
public Quaternion get_identity()
public Quaternion op_Multiply(Quaternion lhs, Quaternion rhs)
public Vector3 op_Multiply(Quaternion rotation, Vector3 point)
private bool IsEqualUsingDot(float dot)
public bool op_Equality(Quaternion lhs, Quaternion rhs)
public bool op_Inequality(Quaternion lhs, Quaternion rhs)
public float Dot(Quaternion a, Quaternion b)
public void SetLookRotation(Vector3 view)
public void SetLookRotation(Vector3 view, Vector3 up)
public float Angle(Quaternion a, Quaternion b)
private Vector3 Internal_MakePositive(Vector3 euler)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public Quaternion Euler(float x, float y, float z)
public Quaternion Euler(Vector3 euler)
public void ToAngleAxis(Single& angle, Vector3& axis)
public void SetFromToRotation(Vector3 fromDirection, Vector3 toDirection)
public Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta)
public Quaternion Normalize(Quaternion q)
public void Normalize()
public Quaternion get_normalized()
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Quaternion other)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public Quaternion EulerRotation(float x, float y, float z)
public Quaternion EulerRotation(Vector3 euler)
public void SetEulerRotation(float x, float y, float z)
public void SetEulerRotation(Vector3 euler)
public Vector3 ToEuler()
public Quaternion EulerAngles(float x, float y, float z)
public Quaternion EulerAngles(Vector3 euler)
public void ToAxisAngle(Vector3& axis, Single& angle)
public void SetEulerAngles(float x, float y, float z)
public void SetEulerAngles(Vector3 euler)
public Vector3 ToEulerAngles(Quaternion rotation)
public Vector3 ToEulerAngles()
public void SetAxisAngle(Vector3 axis, float angle)
public Quaternion AxisAngle(Vector3 axis, float angle)
private void FromToRotation_Injected(Vector3& fromDirection, Vector3& toDirection, Quaternion& ret)
private void Inverse_Injected(Quaternion& rotation, Quaternion& ret)
private void Slerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void SlerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void Lerp_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void LerpUnclamped_Injected(Quaternion& a, Quaternion& b, float t, Quaternion& ret)
private void Internal_FromEulerRad_Injected(Vector3& euler, Quaternion& ret)
private void Internal_ToEulerRad_Injected(Quaternion& rotation, Vector3& ret)
private void Internal_ToAxisAngleRad_Injected(Quaternion& q, Vector3& axis, Single& angle)
private void AngleAxis_Injected(float angle, Vector3& axis, Quaternion& ret)
private void LookRotation_Injected(Vector3& forward, Vector3& upwards, Quaternion& ret)
}
public UnityEngine.Random : object {
public State state
public float value
public Vector3 insideUnitSphere
public Vector2 insideUnitCircle
public Vector3 onUnitSphere
public Quaternion rotation
public Quaternion rotationUniform
public int seed
public void InitState(int seed)
public State get_state()
public void set_state(State value)
public float Range(float minInclusive, float maxInclusive)
public int Range(int minInclusive, int maxExclusive)
private int RandomRangeInt(int minInclusive, int maxExclusive)
public float get_value()
public Vector3 get_insideUnitSphere()
private void GetRandomUnitCircle(Vector2& output)
public Vector2 get_insideUnitCircle()
public Vector3 get_onUnitSphere()
public Quaternion get_rotation()
public Quaternion get_rotationUniform()
public int get_seed()
public void set_seed(int value)
public float RandomRange(float min, float max)
public int RandomRange(int min, int max)
public Color ColorHSV()
public Color ColorHSV(float hueMin, float hueMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax)
public Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax, float alphaMin, float alphaMax)
private void get_state_Injected(State& ret)
private void set_state_Injected(State& value)
private void get_insideUnitSphere_Injected(Vector3& ret)
private void get_onUnitSphere_Injected(Vector3& ret)
private void get_rotation_Injected(Quaternion& ret)
private void get_rotationUniform_Injected(Quaternion& ret)
}
public UnityEngine.RangeAttribute : PropertyAttribute {
public float min
public float max
public void .ctor(float min, float max)
}
public UnityEngine.RangeInt : ValueType {
public int start
public int length
public int end
public int get_end()
public void .ctor(int start, int length)
}
public UnityEngine.Ray : ValueType {
private Vector3 m_Origin
private Vector3 m_Direction
public Vector3 origin
public Vector3 direction
public void .ctor(Vector3 origin, Vector3 direction)
public Vector3 get_origin()
public void set_origin(Vector3 value)
public Vector3 get_direction()
public void set_direction(Vector3 value)
public Vector3 GetPoint(float distance)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
}
public UnityEngine.Ray2D : ValueType {
private Vector2 m_Origin
private Vector2 m_Direction
public Vector2 origin
public Vector2 direction
public void .ctor(Vector2 origin, Vector2 direction)
public Vector2 get_origin()
public void set_origin(Vector2 value)
public Vector2 get_direction()
public void set_direction(Vector2 value)
public Vector2 GetPoint(float distance)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
}
public UnityEngine.ReceiveGI : Enum {
public int value__
public ReceiveGI Lightmaps
public ReceiveGI LightProbes
}
public UnityEngine.Rect : ValueType {
private float m_XMin
private float m_YMin
private float m_Width
private float m_Height
public Rect zero
public float x
public float y
public Vector2 position
public Vector2 center
public Vector2 min
public Vector2 max
public float width
public float height
public Vector2 size
public float xMin
public float yMin
public float xMax
public float yMax
public float left
public float right
public float top
public float bottom
public void .ctor(float x, float y, float width, float height)
public void .ctor(Vector2 position, Vector2 size)
public void .ctor(Rect source)
public Rect get_zero()
public Rect MinMaxRect(float xmin, float ymin, float xmax, float ymax)
public void Set(float x, float y, float width, float height)
public float get_x()
public void set_x(float value)
public float get_y()
public void set_y(float value)
public Vector2 get_position()
public void set_position(Vector2 value)
public Vector2 get_center()
public void set_center(Vector2 value)
public Vector2 get_min()
public void set_min(Vector2 value)
public Vector2 get_max()
public void set_max(Vector2 value)
public float get_width()
public void set_width(float value)
public float get_height()
public void set_height(float value)
public Vector2 get_size()
public void set_size(Vector2 value)
public float get_xMin()
public void set_xMin(float value)
public float get_yMin()
public void set_yMin(float value)
public float get_xMax()
public void set_xMax(float value)
public float get_yMax()
public void set_yMax(float value)
public bool Contains(Vector2 point)
public bool Contains(Vector3 point)
public bool Contains(Vector3 point, bool allowInverse)
private Rect OrderMinMax(Rect rect)
public bool Overlaps(Rect other)
public bool Overlaps(Rect other, bool allowInverse)
public Vector2 NormalizedToPoint(Rect rectangle, Vector2 normalizedRectCoordinates)
public Vector2 PointToNormalized(Rect rectangle, Vector2 point)
public bool op_Inequality(Rect lhs, Rect rhs)
public bool op_Equality(Rect lhs, Rect rhs)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Rect other)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public float get_left()
public float get_right()
public float get_top()
public float get_bottom()
}
public UnityEngine.RectInt : ValueType {
private int m_XMin
private int m_YMin
private int m_Width
private int m_Height
public int x
public int y
public Vector2 center
public Vector2Int min
public Vector2Int max
public int width
public int height
public int xMin
public int yMin
public int xMax
public int yMax
public Vector2Int position
public Vector2Int size
public PositionEnumerator allPositionsWithin
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public Vector2 get_center()
public Vector2Int get_min()
public void set_min(Vector2Int value)
public Vector2Int get_max()
public void set_max(Vector2Int value)
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_xMin()
public void set_xMin(int value)
public int get_yMin()
public void set_yMin(int value)
public int get_xMax()
public void set_xMax(int value)
public int get_yMax()
public void set_yMax(int value)
public Vector2Int get_position()
public void set_position(Vector2Int value)
public Vector2Int get_size()
public void set_size(Vector2Int value)
public void SetMinMax(Vector2Int minPosition, Vector2Int maxPosition)
public void .ctor(int xMin, int yMin, int width, int height)
public void .ctor(Vector2Int position, Vector2Int size)
public void ClampToBounds(RectInt bounds)
public bool Contains(Vector2Int position)
public bool Overlaps(RectInt other)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public bool Equals(RectInt other)
public PositionEnumerator get_allPositionsWithin()
}
public UnityEngine.RectOffset : object {
internal IntPtr m_Ptr
private object m_SourceStyle
public int left
public int right
public int top
public int bottom
public int horizontal
public int vertical
internal void .ctor(object sourceStyle, IntPtr source)
protected void Finalize()
public void .ctor(int left, int right, int top, int bottom)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
private void Destroy()
private IntPtr InternalCreate()
private void InternalDestroy(IntPtr ptr)
public int get_left()
public void set_left(int value)
public int get_right()
public void set_right(int value)
public int get_top()
public void set_top(int value)
public int get_bottom()
public void set_bottom(int value)
public int get_horizontal()
public int get_vertical()
public Rect Add(Rect rect)
public Rect Remove(Rect rect)
private void Add_Injected(Rect& rect, Rect& ret)
private void Remove_Injected(Rect& rect, Rect& ret)
}
public UnityEngine.RectTransform : Transform {
private ReapplyDrivenProperties reapplyDrivenProperties
public Rect rect
public Vector2 anchorMin
public Vector2 anchorMax
public Vector2 anchoredPosition
public Vector2 sizeDelta
public Vector2 pivot
public Vector3 anchoredPosition3D
public Vector2 offsetMin
public Vector2 offsetMax
public Object drivenByObject
internal DrivenTransformProperties drivenProperties
public void add_reapplyDrivenProperties(ReapplyDrivenProperties value)
public void remove_reapplyDrivenProperties(ReapplyDrivenProperties value)
public Rect get_rect()
public Vector2 get_anchorMin()
public void set_anchorMin(Vector2 value)
public Vector2 get_anchorMax()
public void set_anchorMax(Vector2 value)
public Vector2 get_anchoredPosition()
public void set_anchoredPosition(Vector2 value)
public Vector2 get_sizeDelta()
public void set_sizeDelta(Vector2 value)
public Vector2 get_pivot()
public void set_pivot(Vector2 value)
public Vector3 get_anchoredPosition3D()
public void set_anchoredPosition3D(Vector3 value)
public Vector2 get_offsetMin()
public void set_offsetMin(Vector2 value)
public Vector2 get_offsetMax()
public void set_offsetMax(Vector2 value)
public Object get_drivenByObject()
internal void set_drivenByObject(Object value)
internal DrivenTransformProperties get_drivenProperties()
internal void set_drivenProperties(DrivenTransformProperties value)
public void ForceUpdateRectTransforms()
public void GetLocalCorners(Vector3[] fourCornersArray)
public void GetWorldCorners(Vector3[] fourCornersArray)
public void SetInsetAndSizeFromParentEdge(Edge edge, float inset, float size)
public void SetSizeWithCurrentAnchors(Axis axis, float size)
internal void SendReapplyDrivenProperties(RectTransform driven)
internal Rect GetRectInParentSpace()
private Vector2 GetParentSize()
private void get_rect_Injected(Rect& ret)
private void get_anchorMin_Injected(Vector2& ret)
private void set_anchorMin_Injected(Vector2& value)
private void get_anchorMax_Injected(Vector2& ret)
private void set_anchorMax_Injected(Vector2& value)
private void get_anchoredPosition_Injected(Vector2& ret)
private void set_anchoredPosition_Injected(Vector2& value)
private void get_sizeDelta_Injected(Vector2& ret)
private void set_sizeDelta_Injected(Vector2& value)
private void get_pivot_Injected(Vector2& ret)
private void set_pivot_Injected(Vector2& value)
}
public UnityEngine.ReflectionProbe : Behaviour {
private Action`2<ReflectionProbe, ReflectionProbeEvent> reflectionProbeChanged
private Action`1<Cubemap> defaultReflectionSet
private Action`1<Texture> defaultReflectionTexture
public ReflectionProbeType type
public Vector3 size
public Vector3 center
public float nearClipPlane
public float farClipPlane
public float intensity
public Bounds bounds
public bool hdr
public bool renderDynamicObjects
public float shadowDistance
public int resolution
public int cullingMask
public ReflectionProbeClearFlags clearFlags
public Color backgroundColor
public float blendDistance
public bool boxProjection
public ReflectionProbeMode mode
public int importance
public ReflectionProbeRefreshMode refreshMode
public ReflectionProbeTimeSlicingMode timeSlicingMode
public Texture bakedTexture
public Texture customBakedTexture
public RenderTexture realtimeTexture
public Texture texture
public Vector4 textureHDRDecodeValues
public int minBakedCubemapResolution
public int maxBakedCubemapResolution
public Vector4 defaultTextureHDRDecodeValues
public Texture defaultTexture
public ReflectionProbeType get_type()
public void set_type(ReflectionProbeType value)
public Vector3 get_size()
public void set_size(Vector3 value)
public Vector3 get_center()
public void set_center(Vector3 value)
public float get_nearClipPlane()
public void set_nearClipPlane(float value)
public float get_farClipPlane()
public void set_farClipPlane(float value)
public float get_intensity()
public void set_intensity(float value)
public Bounds get_bounds()
public bool get_hdr()
public void set_hdr(bool value)
public bool get_renderDynamicObjects()
public void set_renderDynamicObjects(bool value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public int get_resolution()
public void set_resolution(int value)
public int get_cullingMask()
public void set_cullingMask(int value)
public ReflectionProbeClearFlags get_clearFlags()
public void set_clearFlags(ReflectionProbeClearFlags value)
public Color get_backgroundColor()
public void set_backgroundColor(Color value)
public float get_blendDistance()
public void set_blendDistance(float value)
public bool get_boxProjection()
public void set_boxProjection(bool value)
public ReflectionProbeMode get_mode()
public void set_mode(ReflectionProbeMode value)
public int get_importance()
public void set_importance(int value)
public ReflectionProbeRefreshMode get_refreshMode()
public void set_refreshMode(ReflectionProbeRefreshMode value)
public ReflectionProbeTimeSlicingMode get_timeSlicingMode()
public void set_timeSlicingMode(ReflectionProbeTimeSlicingMode value)
public Texture get_bakedTexture()
public void set_bakedTexture(Texture value)
public Texture get_customBakedTexture()
public void set_customBakedTexture(Texture value)
public RenderTexture get_realtimeTexture()
public void set_realtimeTexture(RenderTexture value)
public Texture get_texture()
public Vector4 get_textureHDRDecodeValues()
public void Reset()
public int RenderProbe()
public int RenderProbe(RenderTexture targetTexture)
public bool IsFinishedRendering(int renderId)
private int ScheduleRender(ReflectionProbeTimeSlicingMode timeSlicingMode, RenderTexture targetTexture)
public bool BlendCubemap(Texture src, Texture dst, float blend, RenderTexture target)
public void UpdateCachedState()
public int get_minBakedCubemapResolution()
public int get_maxBakedCubemapResolution()
public Vector4 get_defaultTextureHDRDecodeValues()
public Texture get_defaultTexture()
public void add_reflectionProbeChanged(Action`2<ReflectionProbe, ReflectionProbeEvent> value)
public void remove_reflectionProbeChanged(Action`2<ReflectionProbe, ReflectionProbeEvent> value)
public void add_defaultReflectionSet(Action`1<Cubemap> value)
public void remove_defaultReflectionSet(Action`1<Cubemap> value)
public void add_defaultReflectionTexture(Action`1<Texture> value)
public void remove_defaultReflectionTexture(Action`1<Texture> value)
private void CallReflectionProbeEvent(ReflectionProbe probe, ReflectionProbeEvent probeEvent)
private void CallSetDefaultReflection(Texture defaultReflectionCubemap)
private void get_size_Injected(Vector3& ret)
private void set_size_Injected(Vector3& value)
private void get_center_Injected(Vector3& ret)
private void set_center_Injected(Vector3& value)
private void get_bounds_Injected(Bounds& ret)
private void get_backgroundColor_Injected(Color& ret)
private void set_backgroundColor_Injected(Color& value)
private void get_textureHDRDecodeValues_Injected(Vector4& ret)
private void get_defaultTextureHDRDecodeValues_Injected(Vector4& ret)
}
public UnityEngine.RefreshRate : ValueType {
public UInt32 numerator
public UInt32 denominator
public double value
public double get_value()
public bool Equals(RefreshRate other)
}
public UnityEngine.RenderBuffer : ValueType {
internal int m_RenderTextureInstanceID
internal IntPtr m_BufferPtr
internal RenderBufferLoadAction loadAction
internal RenderBufferStoreAction storeAction
internal void SetLoadAction(RenderBufferLoadAction action)
internal void SetStoreAction(RenderBufferStoreAction action)
internal RenderBufferLoadAction GetLoadAction()
internal RenderBufferStoreAction GetStoreAction()
public IntPtr GetNativeRenderBufferPtr()
internal RenderBufferLoadAction get_loadAction()
internal void set_loadAction(RenderBufferLoadAction value)
internal RenderBufferStoreAction get_storeAction()
internal void set_storeAction(RenderBufferStoreAction value)
private void SetLoadAction_Injected(RenderBuffer& _unity_self, RenderBufferLoadAction action)
private void SetStoreAction_Injected(RenderBuffer& _unity_self, RenderBufferStoreAction action)
private RenderBufferLoadAction GetLoadAction_Injected(RenderBuffer& _unity_self)
private RenderBufferStoreAction GetStoreAction_Injected(RenderBuffer& _unity_self)
private IntPtr GetNativeRenderBufferPtr_Injected(RenderBuffer& _unity_self)
}
public UnityEngine.Renderer : Component {
public bool castShadows
public bool motionVectors
public bool useLightProbes
public Bounds bounds
public Bounds localBounds
public bool enabled
public bool isVisible
public ShadowCastingMode shadowCastingMode
public bool receiveShadows
public bool forceRenderingOff
public bool staticShadowCaster
public MotionVectorGenerationMode motionVectorGenerationMode
public LightProbeUsage lightProbeUsage
public ReflectionProbeUsage reflectionProbeUsage
public UInt32 renderingLayerMask
public int rendererPriority
public RayTracingMode rayTracingMode
public string sortingLayerName
public int sortingLayerID
public int sortingOrder
internal int sortingGroupID
internal int sortingGroupOrder
public bool allowOcclusionWhenDynamic
internal Transform staticBatchRootTransform
internal int staticBatchIndex
public bool isPartOfStaticBatch
public Matrix4x4 worldToLocalMatrix
public Matrix4x4 localToWorldMatrix
public GameObject lightProbeProxyVolumeOverride
public Transform probeAnchor
public int lightmapIndex
public int realtimeLightmapIndex
public Vector4 lightmapScaleOffset
public Vector4 realtimeLightmapScaleOffset
public Material[] materials
public Material material
public Material sharedMaterial
public Material[] sharedMaterials
public bool get_castShadows()
public void set_castShadows(bool value)
public bool get_motionVectors()
public void set_motionVectors(bool value)
public bool get_useLightProbes()
public void set_useLightProbes(bool value)
public Bounds get_bounds()
public void set_bounds(Bounds value)
public Bounds get_localBounds()
public void set_localBounds(Bounds value)
public void ResetBounds()
public void ResetLocalBounds()
private void SetStaticLightmapST(Vector4 st)
private Material GetMaterial()
private Material GetSharedMaterial()
private void SetMaterial(Material m)
private Material[] GetMaterialArray()
private void CopyMaterialArray(Material[] m)
private void CopySharedMaterialArray(Material[] m)
private void SetMaterialArray(Material[] m)
internal void Internal_SetPropertyBlock(MaterialPropertyBlock properties)
internal void Internal_GetPropertyBlock(MaterialPropertyBlock dest)
internal void Internal_SetPropertyBlockMaterialIndex(MaterialPropertyBlock properties, int materialIndex)
internal void Internal_GetPropertyBlockMaterialIndex(MaterialPropertyBlock dest, int materialIndex)
public bool HasPropertyBlock()
public void SetPropertyBlock(MaterialPropertyBlock properties)
public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex)
public void GetPropertyBlock(MaterialPropertyBlock properties)
public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex)
private void GetClosestReflectionProbesInternal(object result)
public bool get_enabled()
public void set_enabled(bool value)
public bool get_isVisible()
public ShadowCastingMode get_shadowCastingMode()
public void set_shadowCastingMode(ShadowCastingMode value)
public bool get_receiveShadows()
public void set_receiveShadows(bool value)
public bool get_forceRenderingOff()
public void set_forceRenderingOff(bool value)
private bool GetIsStaticShadowCaster()
private void SetIsStaticShadowCaster(bool value)
public bool get_staticShadowCaster()
public void set_staticShadowCaster(bool value)
public MotionVectorGenerationMode get_motionVectorGenerationMode()
public void set_motionVectorGenerationMode(MotionVectorGenerationMode value)
public LightProbeUsage get_lightProbeUsage()
public void set_lightProbeUsage(LightProbeUsage value)
public ReflectionProbeUsage get_reflectionProbeUsage()
public void set_reflectionProbeUsage(ReflectionProbeUsage value)
public UInt32 get_renderingLayerMask()
public void set_renderingLayerMask(UInt32 value)
public int get_rendererPriority()
public void set_rendererPriority(int value)
public RayTracingMode get_rayTracingMode()
public void set_rayTracingMode(RayTracingMode value)
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
internal int get_sortingGroupID()
internal void set_sortingGroupID(int value)
internal int get_sortingGroupOrder()
internal void set_sortingGroupOrder(int value)
public bool get_allowOcclusionWhenDynamic()
public void set_allowOcclusionWhenDynamic(bool value)
internal Transform get_staticBatchRootTransform()
internal void set_staticBatchRootTransform(Transform value)
internal int get_staticBatchIndex()
internal void SetStaticBatchInfo(int firstSubMesh, int subMeshCount)
public bool get_isPartOfStaticBatch()
public Matrix4x4 get_worldToLocalMatrix()
public Matrix4x4 get_localToWorldMatrix()
public GameObject get_lightProbeProxyVolumeOverride()
public void set_lightProbeProxyVolumeOverride(GameObject value)
public Transform get_probeAnchor()
public void set_probeAnchor(Transform value)
private int GetLightmapIndex(LightmapType lt)
private void SetLightmapIndex(int index, LightmapType lt)
private Vector4 GetLightmapST(LightmapType lt)
private void SetLightmapST(Vector4 st, LightmapType lt)
public int get_lightmapIndex()
public void set_lightmapIndex(int value)
public int get_realtimeLightmapIndex()
public void set_realtimeLightmapIndex(int value)
public Vector4 get_lightmapScaleOffset()
public void set_lightmapScaleOffset(Vector4 value)
public Vector4 get_realtimeLightmapScaleOffset()
public void set_realtimeLightmapScaleOffset(Vector4 value)
private int GetMaterialCount()
private Material[] GetSharedMaterialArray()
public Material[] get_materials()
public void set_materials(Material[] value)
public Material get_material()
public void set_material(Material value)
public Material get_sharedMaterial()
public void set_sharedMaterial(Material value)
public Material[] get_sharedMaterials()
public void set_sharedMaterials(Material[] value)
public void GetMaterials(List`1<Material> m)
public void GetSharedMaterials(List`1<Material> m)
public void GetClosestReflectionProbes(List`1<ReflectionProbeBlendInfo> result)
private void get_bounds_Injected(Bounds& ret)
private void set_bounds_Injected(Bounds& value)
private void get_localBounds_Injected(Bounds& ret)
private void set_localBounds_Injected(Bounds& value)
private void SetStaticLightmapST_Injected(Vector4& st)
private void get_worldToLocalMatrix_Injected(Matrix4x4& ret)
private void get_localToWorldMatrix_Injected(Matrix4x4& ret)
private void GetLightmapST_Injected(LightmapType lt, Vector4& ret)
private void SetLightmapST_Injected(Vector4& st, LightmapType lt)
}
public UnityEngine.RendererExtensions : object {
public void UpdateGIMaterials(Renderer renderer)
internal void UpdateGIMaterialsForRenderer(Renderer renderer)
}
public UnityEngine.Rendering.AmbientMode : Enum {
public int value__
public AmbientMode Skybox
public AmbientMode Trilight
public AmbientMode Flat
public AmbientMode Custom
}
public UnityEngine.Rendering.AsyncGPUReadback : object {
internal void ValidateFormat(Texture src, GraphicsFormat dstformat)
public void WaitAllRequests()
public AsyncGPUReadbackRequest Request(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest Request(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public AsyncGPUReadbackRequest RequestIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
private AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_1(ComputeBuffer buffer, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_ComputeBuffer_2(ComputeBuffer src, int size, int offset, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_GraphicsBuffer_1(GraphicsBuffer buffer, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_GraphicsBuffer_2(GraphicsBuffer src, int size, int offset, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_Texture_1(Texture src, int mipIndex, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_Texture_2(Texture src, int mipIndex, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_Texture_3(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, AsyncRequestNativeArrayData* data)
private AsyncGPUReadbackRequest Request_Internal_Texture_4(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data)
private void Request_Internal_ComputeBuffer_1_Injected(ComputeBuffer buffer, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_ComputeBuffer_2_Injected(ComputeBuffer src, int size, int offset, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_GraphicsBuffer_1_Injected(GraphicsBuffer buffer, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_GraphicsBuffer_2_Injected(GraphicsBuffer src, int size, int offset, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_1_Injected(Texture src, int mipIndex, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_2_Injected(Texture src, int mipIndex, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_3_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
private void Request_Internal_Texture_4_Injected(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, AsyncRequestNativeArrayData* data, AsyncGPUReadbackRequest& ret)
}
public UnityEngine.Rendering.AsyncGPUReadbackRequest : ValueType {
internal IntPtr m_Ptr
internal int m_Version
public bool done
public bool hasError
public int layerCount
public int layerDataSize
public int width
public int height
public int depth
public void Update()
public void WaitForCompletion()
public NativeArray`1<T> GetData(int layer)
public bool get_done()
public bool get_hasError()
public int get_layerCount()
public int get_layerDataSize()
public int get_width()
public int get_height()
public int get_depth()
private bool IsDone()
private bool HasError()
private int GetLayerCount()
private int GetLayerDataSize()
private int GetWidth()
private int GetHeight()
private int GetDepth()
internal void SetScriptingCallback(Action`1<AsyncGPUReadbackRequest> callback)
private IntPtr GetDataRaw(int layer)
private void Update_Injected(AsyncGPUReadbackRequest& _unity_self)
private void WaitForCompletion_Injected(AsyncGPUReadbackRequest& _unity_self)
private bool IsDone_Injected(AsyncGPUReadbackRequest& _unity_self)
private bool HasError_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetLayerCount_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetLayerDataSize_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetWidth_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetHeight_Injected(AsyncGPUReadbackRequest& _unity_self)
private int GetDepth_Injected(AsyncGPUReadbackRequest& _unity_self)
private void SetScriptingCallback_Injected(AsyncGPUReadbackRequest& _unity_self, Action`1<AsyncGPUReadbackRequest> callback)
private IntPtr GetDataRaw_Injected(AsyncGPUReadbackRequest& _unity_self, int layer)
}
internal UnityEngine.Rendering.AsyncRequestNativeArrayData : ValueType {
public Void* nativeArrayBuffer
public long lengthInBytes
public AsyncRequestNativeArrayData CreateAndCheckAccess(NativeArray`1<T> array)
public AsyncRequestNativeArrayData CreateAndCheckAccess(NativeSlice`1<T> array)
}
public UnityEngine.Rendering.AttachmentDescriptor : ValueType {
private RenderBufferLoadAction m_LoadAction
private RenderBufferStoreAction m_StoreAction
private GraphicsFormat m_Format
private RenderTargetIdentifier m_LoadStoreTarget
private RenderTargetIdentifier m_ResolveTarget
private Color m_ClearColor
private float m_ClearDepth
private UInt32 m_ClearStencil
public RenderBufferLoadAction loadAction
public RenderBufferStoreAction storeAction
public GraphicsFormat graphicsFormat
public RenderTextureFormat format
public RenderTargetIdentifier loadStoreTarget
public RenderTargetIdentifier resolveTarget
public Color clearColor
public float clearDepth
public UInt32 clearStencil
public RenderBufferLoadAction get_loadAction()
public void set_loadAction(RenderBufferLoadAction value)
public RenderBufferStoreAction get_storeAction()
public void set_storeAction(RenderBufferStoreAction value)
public GraphicsFormat get_graphicsFormat()
public void set_graphicsFormat(GraphicsFormat value)
public RenderTextureFormat get_format()
public void set_format(RenderTextureFormat value)
public RenderTargetIdentifier get_loadStoreTarget()
public void set_loadStoreTarget(RenderTargetIdentifier value)
public RenderTargetIdentifier get_resolveTarget()
public void set_resolveTarget(RenderTargetIdentifier value)
public Color get_clearColor()
public void set_clearColor(Color value)
public float get_clearDepth()
public void set_clearDepth(float value)
public UInt32 get_clearStencil()
public void set_clearStencil(UInt32 value)
public void ConfigureTarget(RenderTargetIdentifier target, bool loadExistingContents, bool storeResults)
public void ConfigureResolveTarget(RenderTargetIdentifier target)
public void ConfigureClear(Color clearColor, float clearDepth, UInt32 clearStencil)
public void .ctor(GraphicsFormat format)
public void .ctor(RenderTextureFormat format)
public void .ctor(RenderTextureFormat format, RenderTargetIdentifier target, bool loadExistingContents, bool storeResults, bool resolve)
public bool Equals(AttachmentDescriptor other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(AttachmentDescriptor left, AttachmentDescriptor right)
public bool op_Inequality(AttachmentDescriptor left, AttachmentDescriptor right)
}
public UnityEngine.Rendering.BatchCullingContext : ValueType {
public NativeArray`1<Plane> cullingPlanes
public NativeArray`1<BatchVisibility> batchVisibility
public NativeArray`1<int> visibleIndices
public NativeArray`1<int> visibleIndicesY
public LODParameters lodParameters
public Matrix4x4 cullingMatrix
public float nearPlane
public void .ctor(NativeArray`1<Plane> inCullingPlanes, NativeArray`1<BatchVisibility> inOutBatchVisibility, NativeArray`1<int> outVisibleIndices, LODParameters inLodParameters)
public void .ctor(NativeArray`1<Plane> inCullingPlanes, NativeArray`1<BatchVisibility> inOutBatchVisibility, NativeArray`1<int> outVisibleIndices, LODParameters inLodParameters, Matrix4x4 inCullingMatrix, float inNearPlane)
internal void .ctor(NativeArray`1<Plane> inCullingPlanes, NativeArray`1<BatchVisibility> inOutBatchVisibility, NativeArray`1<int> outVisibleIndices, NativeArray`1<int> outVisibleIndicesY, LODParameters inLodParameters, Matrix4x4 inCullingMatrix, float inNearPlane)
}
internal UnityEngine.Rendering.BatchRendererCullingOutput : ValueType {
public JobHandle cullingJobsFence
public Matrix4x4 cullingMatrix
public Plane* cullingPlanes
public BatchVisibility* batchVisibility
public Int32* visibleIndices
public Int32* visibleIndicesY
public int cullingPlanesCount
public int batchVisibilityCount
public int visibleIndicesCount
public float nearPlane
}
public UnityEngine.Rendering.BatchRendererGroup : object {
private IntPtr m_GroupHandle
private OnPerformCulling m_PerformCulling
public void .ctor(OnPerformCulling cullingCallback)
public void Dispose()
public int AddBatch(Mesh mesh, int subMeshIndex, Material material, int layer, ShadowCastingMode castShadows, bool receiveShadows, bool invertCulling, Bounds bounds, int instanceCount, MaterialPropertyBlock customProps, GameObject associatedSceneObject, ulong sceneCullingMask, UInt32 renderingLayerMask)
public void SetBatchFlags(int batchIndex, ulong flags)
public void SetBatchPropertyMetadata(int batchIndex, NativeArray`1<int> cbufferLengths, NativeArray`1<int> cbufferMetadata)
private void InternalSetBatchPropertyMetadata(int batchIndex, IntPtr cbufferLengths, int cbufferLengthsCount, IntPtr cbufferMetadata, int cbufferMetadataCount)
public void SetInstancingData(int batchIndex, int instanceCount, MaterialPropertyBlock customProps)
public NativeArray`1<Matrix4x4> GetBatchMatrices(int batchIndex)
public NativeArray`1<int> GetBatchScalarArrayInt(int batchIndex, string propertyName)
public NativeArray`1<float> GetBatchScalarArray(int batchIndex, string propertyName)
public NativeArray`1<int> GetBatchVectorArrayInt(int batchIndex, string propertyName)
public NativeArray`1<Vector4> GetBatchVectorArray(int batchIndex, string propertyName)
public NativeArray`1<Matrix4x4> GetBatchMatrixArray(int batchIndex, string propertyName)
public NativeArray`1<int> GetBatchScalarArrayInt(int batchIndex, int propertyName)
public NativeArray`1<float> GetBatchScalarArray(int batchIndex, int propertyName)
public NativeArray`1<int> GetBatchVectorArrayInt(int batchIndex, int propertyName)
public NativeArray`1<Vector4> GetBatchVectorArray(int batchIndex, int propertyName)
public NativeArray`1<Matrix4x4> GetBatchMatrixArray(int batchIndex, int propertyName)
public void SetBatchBounds(int batchIndex, Bounds bounds)
public int GetNumBatches()
public void RemoveBatch(int index)
private Void* GetBatchMatrices(int batchIndex, Int32& matrixCount)
private Void* GetBatchScalarArray(int batchIndex, string propertyName, Int32& elementCount)
private Void* GetBatchVectorArray(int batchIndex, string propertyName, Int32& elementCount)
private Void* GetBatchMatrixArray(int batchIndex, string propertyName, Int32& elementCount)
private Void* GetBatchScalarArray_Internal(int batchIndex, int propertyName, Int32& elementCount)
private Void* GetBatchVectorArray_Internal(int batchIndex, int propertyName, Int32& elementCount)
private Void* GetBatchMatrixArray_Internal(int batchIndex, int propertyName, Int32& elementCount)
public void EnableVisibleIndicesYArray(bool enabled)
private IntPtr Create(BatchRendererGroup group)
private void Destroy(IntPtr groupHandle)
private void InvokeOnPerformCulling(BatchRendererGroup group, BatchRendererCullingOutput& context, LODParameters& lodParameters)
private int AddBatch_Injected(Mesh mesh, int subMeshIndex, Material material, int layer, ShadowCastingMode castShadows, bool receiveShadows, bool invertCulling, Bounds& bounds, int instanceCount, MaterialPropertyBlock customProps, GameObject associatedSceneObject, ulong sceneCullingMask, UInt32 renderingLayerMask)
private void SetBatchBounds_Injected(int batchIndex, Bounds& bounds)
}
public UnityEngine.Rendering.BatchVisibility : ValueType {
public int offset
public int instancesCount
public int visibleCount
}
public UnityEngine.Rendering.BlendMode : Enum {
public int value__
public BlendMode Zero
public BlendMode One
public BlendMode DstColor
public BlendMode SrcColor
public BlendMode OneMinusDstColor
public BlendMode SrcAlpha
public BlendMode OneMinusSrcColor
public BlendMode DstAlpha
public BlendMode OneMinusDstAlpha
public BlendMode SrcAlphaSaturate
public BlendMode OneMinusSrcAlpha
}
public UnityEngine.Rendering.BlendOp : Enum {
public int value__
public BlendOp Add
public BlendOp Subtract
public BlendOp ReverseSubtract
public BlendOp Min
public BlendOp Max
public BlendOp LogicalClear
public BlendOp LogicalSet
public BlendOp LogicalCopy
public BlendOp LogicalCopyInverted
public BlendOp LogicalNoop
public BlendOp LogicalInvert
public BlendOp LogicalAnd
public BlendOp LogicalNand
public BlendOp LogicalOr
public BlendOp LogicalNor
public BlendOp LogicalXor
public BlendOp LogicalEquivalence
public BlendOp LogicalAndReverse
public BlendOp LogicalAndInverted
public BlendOp LogicalOrReverse
public BlendOp LogicalOrInverted
public BlendOp Multiply
public BlendOp Screen
public BlendOp Overlay
public BlendOp Darken
public BlendOp Lighten
public BlendOp ColorDodge
public BlendOp ColorBurn
public BlendOp HardLight
public BlendOp SoftLight
public BlendOp Difference
public BlendOp Exclusion
public BlendOp HSLHue
public BlendOp HSLSaturation
public BlendOp HSLColor
public BlendOp HSLLuminosity
}
public UnityEngine.Rendering.BlendState : ValueType {
private RenderTargetBlendState m_BlendState0
private RenderTargetBlendState m_BlendState1
private RenderTargetBlendState m_BlendState2
private RenderTargetBlendState m_BlendState3
private RenderTargetBlendState m_BlendState4
private RenderTargetBlendState m_BlendState5
private RenderTargetBlendState m_BlendState6
private RenderTargetBlendState m_BlendState7
private byte m_SeparateMRTBlendStates
private byte m_AlphaToMask
private short m_Padding
public BlendState defaultValue
public bool separateMRTBlendStates
public bool alphaToMask
public RenderTargetBlendState blendState0
public RenderTargetBlendState blendState1
public RenderTargetBlendState blendState2
public RenderTargetBlendState blendState3
public RenderTargetBlendState blendState4
public RenderTargetBlendState blendState5
public RenderTargetBlendState blendState6
public RenderTargetBlendState blendState7
public BlendState get_defaultValue()
public void .ctor(bool separateMRTBlend, bool alphaToMask)
public bool get_separateMRTBlendStates()
public void set_separateMRTBlendStates(bool value)
public bool get_alphaToMask()
public void set_alphaToMask(bool value)
public RenderTargetBlendState get_blendState0()
public void set_blendState0(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState1()
public void set_blendState1(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState2()
public void set_blendState2(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState3()
public void set_blendState3(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState4()
public void set_blendState4(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState5()
public void set_blendState5(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState6()
public void set_blendState6(RenderTargetBlendState value)
public RenderTargetBlendState get_blendState7()
public void set_blendState7(RenderTargetBlendState value)
public bool Equals(BlendState other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(BlendState left, BlendState right)
public bool op_Inequality(BlendState left, BlendState right)
}
public UnityEngine.Rendering.BuiltinRenderTextureType : Enum {
public int value__
public BuiltinRenderTextureType PropertyName
public BuiltinRenderTextureType BufferPtr
public BuiltinRenderTextureType RenderTexture
public BuiltinRenderTextureType BindableTexture
public BuiltinRenderTextureType None
public BuiltinRenderTextureType CurrentActive
public BuiltinRenderTextureType CameraTarget
public BuiltinRenderTextureType Depth
public BuiltinRenderTextureType DepthNormals
public BuiltinRenderTextureType ResolvedDepth
public BuiltinRenderTextureType PrepassNormalsSpec
public BuiltinRenderTextureType PrepassLight
public BuiltinRenderTextureType PrepassLightSpec
public BuiltinRenderTextureType GBuffer0
public BuiltinRenderTextureType GBuffer1
public BuiltinRenderTextureType GBuffer2
public BuiltinRenderTextureType GBuffer3
public BuiltinRenderTextureType Reflections
public BuiltinRenderTextureType MotionVectors
public BuiltinRenderTextureType GBuffer4
public BuiltinRenderTextureType GBuffer5
public BuiltinRenderTextureType GBuffer6
public BuiltinRenderTextureType GBuffer7
}
public UnityEngine.Rendering.BuiltinShaderDefine : Enum {
public int value__
public BuiltinShaderDefine UNITY_NO_DXT5nm
public BuiltinShaderDefine UNITY_NO_RGBM
public BuiltinShaderDefine UNITY_USE_NATIVE_HDR
public BuiltinShaderDefine UNITY_ENABLE_REFLECTION_BUFFERS
public BuiltinShaderDefine UNITY_FRAMEBUFFER_FETCH_AVAILABLE
public BuiltinShaderDefine UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS
public BuiltinShaderDefine UNITY_METAL_SHADOWS_USE_POINT_FILTERING
public BuiltinShaderDefine UNITY_NO_CUBEMAP_ARRAY
public BuiltinShaderDefine UNITY_NO_SCREENSPACE_SHADOWS
public BuiltinShaderDefine UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS
public BuiltinShaderDefine UNITY_PBS_USE_BRDF1
public BuiltinShaderDefine UNITY_PBS_USE_BRDF2
public BuiltinShaderDefine UNITY_PBS_USE_BRDF3
public BuiltinShaderDefine UNITY_NO_FULL_STANDARD_SHADER
public BuiltinShaderDefine UNITY_SPECCUBE_BOX_PROJECTION
public BuiltinShaderDefine UNITY_SPECCUBE_BLENDING
public BuiltinShaderDefine UNITY_ENABLE_DETAIL_NORMALMAP
public BuiltinShaderDefine SHADER_API_MOBILE
public BuiltinShaderDefine SHADER_API_DESKTOP
public BuiltinShaderDefine UNITY_HARDWARE_TIER1
public BuiltinShaderDefine UNITY_HARDWARE_TIER2
public BuiltinShaderDefine UNITY_HARDWARE_TIER3
public BuiltinShaderDefine UNITY_COLORSPACE_GAMMA
public BuiltinShaderDefine UNITY_LIGHT_PROBE_PROXY_VOLUME
public BuiltinShaderDefine UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
public BuiltinShaderDefine UNITY_LIGHTMAP_DLDR_ENCODING
public BuiltinShaderDefine UNITY_LIGHTMAP_RGBM_ENCODING
public BuiltinShaderDefine UNITY_LIGHTMAP_FULL_HDR
public BuiltinShaderDefine UNITY_VIRTUAL_TEXTURING
public BuiltinShaderDefine UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION
public BuiltinShaderDefine UNITY_ASTC_NORMALMAP_ENCODING
public BuiltinShaderDefine SHADER_API_GLES30
public BuiltinShaderDefine UNITY_UNIFIED_SHADER_PRECISION_MODEL
}
public UnityEngine.Rendering.BuiltinShaderMode : Enum {
public int value__
public BuiltinShaderMode Disabled
public BuiltinShaderMode UseBuiltin
public BuiltinShaderMode UseCustom
}
public UnityEngine.Rendering.BuiltinShaderType : Enum {
public int value__
public BuiltinShaderType DeferredShading
public BuiltinShaderType DeferredReflections
public BuiltinShaderType LegacyDeferredLighting
public BuiltinShaderType ScreenSpaceShadows
public BuiltinShaderType DepthNormals
public BuiltinShaderType MotionVectors
public BuiltinShaderType LightHalo
public BuiltinShaderType LensFlare
}
public UnityEngine.Rendering.CameraEvent : Enum {
public int value__
public CameraEvent BeforeDepthTexture
public CameraEvent AfterDepthTexture
public CameraEvent BeforeDepthNormalsTexture
public CameraEvent AfterDepthNormalsTexture
public CameraEvent BeforeGBuffer
public CameraEvent AfterGBuffer
public CameraEvent BeforeLighting
public CameraEvent AfterLighting
public CameraEvent BeforeFinalPass
public CameraEvent AfterFinalPass
public CameraEvent BeforeForwardOpaque
public CameraEvent AfterForwardOpaque
public CameraEvent BeforeImageEffectsOpaque
public CameraEvent AfterImageEffectsOpaque
public CameraEvent BeforeSkybox
public CameraEvent AfterSkybox
public CameraEvent BeforeForwardAlpha
public CameraEvent AfterForwardAlpha
public CameraEvent BeforeImageEffects
public CameraEvent AfterImageEffects
public CameraEvent AfterEverything
public CameraEvent BeforeReflections
public CameraEvent AfterReflections
public CameraEvent BeforeHaloAndLensFlares
public CameraEvent AfterHaloAndLensFlares
}
internal UnityEngine.Rendering.CameraEventUtils : object {
private CameraEvent k_MinimumValue
private CameraEvent k_MaximumValue
public bool IsValid(CameraEvent value)
}
public UnityEngine.Rendering.CameraHDRMode : Enum {
public int value__
public CameraHDRMode FP16
public CameraHDRMode R11G11B10
}
public UnityEngine.Rendering.CameraLateLatchMatrixType : Enum {
public int value__
public CameraLateLatchMatrixType View
public CameraLateLatchMatrixType InverseView
public CameraLateLatchMatrixType ViewProjection
public CameraLateLatchMatrixType InverseViewProjection
}
public UnityEngine.Rendering.CameraProperties : ValueType {
private int k_NumLayers
private Rect screenRect
private Vector3 viewDir
private float projectionNear
private float projectionFar
private float cameraNear
private float cameraFar
private float cameraAspect
private Matrix4x4 cameraToWorld
private Matrix4x4 actualWorldToClip
private Matrix4x4 cameraClipToWorld
private Matrix4x4 cameraWorldToClip
private Matrix4x4 implicitProjection
private Matrix4x4 stereoWorldToClipLeft
private Matrix4x4 stereoWorldToClipRight
private Matrix4x4 worldToCamera
private Vector3 up
private Vector3 right
private Vector3 transformDirection
private Vector3 cameraEuler
private Vector3 velocity
private float farPlaneWorldSpaceLength
private UInt32 rendererCount
private int k_PlaneCount
internal <m_ShadowCullPlanes>e__FixedBuffer m_ShadowCullPlanes
internal <m_CameraCullPlanes>e__FixedBuffer m_CameraCullPlanes
private float baseFarDistance
private Vector3 shadowCullCenter
internal <layerCullDistances>e__FixedBuffer layerCullDistances
private int layerCullSpherical
private CoreCameraValues coreCameraValues
private UInt32 cameraType
private int projectionIsOblique
private int isImplicitProjectionMatrix
public Plane GetShadowCullingPlane(int index)
public void SetShadowCullingPlane(int index, Plane plane)
public Plane GetCameraCullingPlane(int index)
public void SetCameraCullingPlane(int index, Plane plane)
public bool Equals(CameraProperties other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CameraProperties left, CameraProperties right)
public bool op_Inequality(CameraProperties left, CameraProperties right)
}
public UnityEngine.Rendering.ColorWriteMask : Enum {
public int value__
public ColorWriteMask Alpha
public ColorWriteMask Blue
public ColorWriteMask Green
public ColorWriteMask Red
public ColorWriteMask All
}
public UnityEngine.Rendering.CommandBuffer : object {
internal IntPtr m_Ptr
public string name
public int sizeInBytes
public void ConvertTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst)
public void ConvertTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
public void WaitAllAsyncReadbackRequests()
public void RequestAsyncReadback(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeArray(NativeArray`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
public void RequestAsyncReadbackIntoNativeSlice(NativeSlice`1& output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback)
private void Internal_RequestAsyncReadback_1(ComputeBuffer src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_2(ComputeBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_3(Texture src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_4(Texture src, int mipIndex, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_5(Texture src, int mipIndex, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_6(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_7(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, GraphicsFormat dstFormat, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_8(GraphicsBuffer src, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
private void Internal_RequestAsyncReadback_9(GraphicsBuffer src, int size, int offset, Action`1<AsyncGPUReadbackRequest> callback, AsyncRequestNativeArrayData* nativeArrayData)
public void SetInvertCulling(bool invertCulling)
private void ConvertTexture_Internal(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
private void Internal_SetSinglePassStereo(SinglePassStereoMode mode)
private IntPtr InitBuffer()
private IntPtr CreateGPUFence_Internal(GraphicsFenceType fenceType, SynchronisationStageFlags stage)
private void WaitOnGPUFence_Internal(IntPtr fencePtr, SynchronisationStageFlags stage)
private void ReleaseBuffer()
public void SetComputeFloatParam(ComputeShader computeShader, int nameID, float val)
public void SetComputeIntParam(ComputeShader computeShader, int nameID, int val)
public void SetComputeVectorParam(ComputeShader computeShader, int nameID, Vector4 val)
public void SetComputeVectorArrayParam(ComputeShader computeShader, int nameID, Vector4[] values)
public void SetComputeMatrixParam(ComputeShader computeShader, int nameID, Matrix4x4 val)
public void SetComputeMatrixArrayParam(ComputeShader computeShader, int nameID, Matrix4x4[] values)
private void Internal_SetComputeFloats(ComputeShader computeShader, int nameID, Single[] values)
private void Internal_SetComputeInts(ComputeShader computeShader, int nameID, Int32[] values)
private void Internal_SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier& rt, int mipLevel, RenderTextureSubElement element)
private void Internal_SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer)
private void Internal_SetComputeGraphicsBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer)
private void Internal_SetComputeConstantComputeBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size)
private void Internal_SetComputeConstantGraphicsBufferParam(ComputeShader computeShader, int nameID, GraphicsBuffer buffer, int offset, int size)
private void Internal_DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
private void Internal_DispatchComputeIndirect(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset)
private void Internal_DispatchComputeIndirectGraphicsBuffer(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, UInt32 argsOffset)
private void Internal_SetRayTracingBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer)
private void Internal_SetRayTracingConstantComputeBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer, int offset, int size)
private void Internal_SetRayTracingConstantGraphicsBufferParam(RayTracingShader rayTracingShader, int nameID, GraphicsBuffer buffer, int offset, int size)
private void Internal_SetRayTracingTextureParam(RayTracingShader rayTracingShader, int nameID, RenderTargetIdentifier& rt)
private void Internal_SetRayTracingFloatParam(RayTracingShader rayTracingShader, int nameID, float val)
private void Internal_SetRayTracingIntParam(RayTracingShader rayTracingShader, int nameID, int val)
private void Internal_SetRayTracingVectorParam(RayTracingShader rayTracingShader, int nameID, Vector4 val)
private void Internal_SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, int nameID, Vector4[] values)
private void Internal_SetRayTracingMatrixParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4 val)
private void Internal_SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4[] values)
private void Internal_SetRayTracingFloats(RayTracingShader rayTracingShader, int nameID, Single[] values)
private void Internal_SetRayTracingInts(RayTracingShader rayTracingShader, int nameID, Int32[] values)
private void Internal_BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure, Vector3 relativeOrigin)
private void Internal_SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, int nameID, RayTracingAccelerationStructure accelerationStructure)
public void SetRayTracingShaderPass(RayTracingShader rayTracingShader, string passName)
private void Internal_DispatchRays(RayTracingShader rayTracingShader, string rayGenShaderName, UInt32 width, UInt32 height, UInt32 depth, Camera camera)
private void Internal_GenerateMips(RenderTargetIdentifier rt)
private void Internal_ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target)
private void CopyCounterValueCC(ComputeBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes)
private void CopyCounterValueGC(GraphicsBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes)
private void CopyCounterValueCG(ComputeBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes)
private void CopyCounterValueGG(GraphicsBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes)
public string get_name()
public void set_name(string value)
public int get_sizeInBytes()
public void Clear()
private void Internal_DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass)
private void Internal_DrawRendererList(RendererList rendererList)
private void Internal_DrawRenderer(Renderer renderer, Material material, int submeshIndex)
private void Internal_DrawRenderer(Renderer renderer, Material material)
private void Internal_DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexed(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexedIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndirectGraphicsBuffer(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawMeshInstancedIndirectGraphicsBuffer(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawOcclusionMesh(RectInt normalizedCamViewport)
private void SetRandomWriteTarget_Texture(int index, RenderTargetIdentifier& rt)
private void SetRandomWriteTarget_Buffer(int index, ComputeBuffer uav, bool preserveCounterValue)
private void SetRandomWriteTarget_GraphicsBuffer(int index, GraphicsBuffer uav, bool preserveCounterValue)
public void ClearRandomWriteTargets()
public void SetViewport(Rect pixelRect)
public void EnableScissorRect(Rect scissor)
public void DisableScissorRect()
private void CopyTexture_Internal(RenderTargetIdentifier& src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier& dst, int dstElement, int dstMip, int dstX, int dstY, int mode)
private void Blit_Texture(Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice)
private void Blit_Identifier(RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, GraphicsFormat format)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter)
public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer)
public void GetTemporaryRT(int nameID, int width, int height)
private void GetTemporaryRTWithDescriptor(int nameID, RenderTextureDescriptor desc, FilterMode filter)
public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter)
public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite, bool useDynamicScale)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format, int antiAliasing)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, GraphicsFormat format)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer)
public void GetTemporaryRTArray(int nameID, int width, int height, int slices)
public void ReleaseTemporaryRT(int nameID)
public void ClearRenderTarget(RTClearFlags clearFlags, Color backgroundColor, float depth, UInt32 stencil)
public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor)
public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor, float depth)
public void SetGlobalFloat(int nameID, float value)
public void SetGlobalInt(int nameID, int value)
public void SetGlobalInteger(int nameID, int value)
public void SetGlobalVector(int nameID, Vector4 value)
public void SetGlobalColor(int nameID, Color value)
public void SetGlobalMatrix(int nameID, Matrix4x4 value)
public void EnableShaderKeyword(string keyword)
private void EnableGlobalKeyword(GlobalKeyword keyword)
private void EnableMaterialKeyword(Material material, LocalKeyword keyword)
private void EnableComputeKeyword(ComputeShader computeShader, LocalKeyword keyword)
public void EnableKeyword(GlobalKeyword& keyword)
public void EnableKeyword(Material material, LocalKeyword& keyword)
public void EnableKeyword(ComputeShader computeShader, LocalKeyword& keyword)
public void DisableShaderKeyword(string keyword)
private void DisableGlobalKeyword(GlobalKeyword keyword)
private void DisableMaterialKeyword(Material material, LocalKeyword keyword)
private void DisableComputeKeyword(ComputeShader computeShader, LocalKeyword keyword)
public void DisableKeyword(GlobalKeyword& keyword)
public void DisableKeyword(Material material, LocalKeyword& keyword)
public void DisableKeyword(ComputeShader computeShader, LocalKeyword& keyword)
private void SetGlobalKeyword(GlobalKeyword keyword, bool value)
private void SetMaterialKeyword(Material material, LocalKeyword keyword, bool value)
private void SetComputeKeyword(ComputeShader computeShader, LocalKeyword keyword, bool value)
public void SetKeyword(GlobalKeyword& keyword, bool value)
public void SetKeyword(Material material, LocalKeyword& keyword, bool value)
public void SetKeyword(ComputeShader computeShader, LocalKeyword& keyword, bool value)
public void SetViewMatrix(Matrix4x4 view)
public void SetProjectionMatrix(Matrix4x4 proj)
public void SetViewProjectionMatrices(Matrix4x4 view, Matrix4x4 proj)
public void SetGlobalDepthBias(float bias, float slopeBias)
public void SetExecutionFlags(CommandBufferExecutionFlags flags)
private bool ValidateAgainstExecutionFlags(CommandBufferExecutionFlags requiredFlags, CommandBufferExecutionFlags invalidFlags)
private void SetGlobalFloatArrayListImpl(int nameID, object values)
private void SetGlobalVectorArrayListImpl(int nameID, object values)
private void SetGlobalMatrixArrayListImpl(int nameID, object values)
public void SetGlobalFloatArray(int nameID, Single[] values)
public void SetGlobalVectorArray(int nameID, Vector4[] values)
public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values)
public void SetLateLatchProjectionMatrices(Matrix4x4[] projectionMat)
public void MarkLateLatchMatrixShaderPropertyID(CameraLateLatchMatrixType matrixPropertyType, int shaderPropertyID)
public void UnmarkLateLatchMatrix(CameraLateLatchMatrixType matrixPropertyType)
private void SetGlobalTexture_Impl(int nameID, RenderTargetIdentifier& rt, RenderTextureSubElement element)
private void SetGlobalBufferInternal(int nameID, ComputeBuffer value)
private void SetGlobalGraphicsBufferInternal(int nameID, GraphicsBuffer value)
private void SetShadowSamplingMode_Impl(RenderTargetIdentifier& shadowmap, ShadowSamplingMode mode)
private void IssuePluginEventInternal(IntPtr callback, int eventID)
public void BeginSample(string name)
public void EndSample(string name)
public void BeginSample(CustomSampler sampler)
public void EndSample(CustomSampler sampler)
private void BeginSample_CustomSampler(CustomSampler sampler)
private void EndSample_CustomSampler(CustomSampler sampler)
private void IssuePluginEventAndDataInternal(IntPtr callback, int eventID, IntPtr data)
private void IssuePluginCustomBlitInternal(IntPtr callback, UInt32 command, RenderTargetIdentifier& source, RenderTargetIdentifier& dest, UInt32 commandParam, UInt32 commandFlags)
private void IssuePluginCustomTextureUpdateInternal(IntPtr callback, Texture targetTexture, UInt32 userData, bool useNewUnityRenderingExtTextureUpdateParamsV2)
private void SetGlobalConstantBufferInternal(ComputeBuffer buffer, int nameID, int offset, int size)
private void SetGlobalConstantGraphicsBufferInternal(GraphicsBuffer buffer, int nameID, int offset, int size)
public void IncrementUpdateCount(RenderTargetIdentifier dest)
public void SetInstanceMultiplier(UInt32 multiplier)
public void SetRenderTarget(RenderTargetIdentifier rt)
public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction)
public void SetRenderTarget(RenderTargetIdentifier rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace)
public void SetRenderTarget(RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace)
public void SetRenderTarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth)
public void SetRenderTarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetBinding binding, int mipLevel, CubemapFace cubemapFace, int depthSlice)
public void SetRenderTarget(RenderTargetBinding binding)
private void SetRenderTargetSingle_Internal(RenderTargetIdentifier rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
private void SetRenderTargetColorDepth_Internal(RenderTargetIdentifier color, RenderTargetIdentifier depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags)
private void SetRenderTargetMulti_Internal(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags)
private void SetRenderTargetColorDepthSubtarget(RenderTargetIdentifier color, RenderTargetIdentifier depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void SetRenderTargetMultiSubtarget(RenderTargetIdentifier[] colors, RenderTargetIdentifier depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void Internal_ProcessVTFeedback(RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip)
public void SetBufferData(ComputeBuffer buffer, Array data)
public void SetBufferData(ComputeBuffer buffer, List`1<T> data)
public void SetBufferData(ComputeBuffer buffer, NativeArray`1<T> data)
public void SetBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferData(ComputeBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferData(ComputeBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue)
private void InternalSetComputeBufferNativeData(ComputeBuffer buffer, IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
private void InternalSetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
private void InternalSetComputeBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue)
public void SetBufferData(GraphicsBuffer buffer, Array data)
public void SetBufferData(GraphicsBuffer buffer, List`1<T> data)
public void SetBufferData(GraphicsBuffer buffer, NativeArray`1<T> data)
public void SetBufferData(GraphicsBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferData(GraphicsBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferData(GraphicsBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetBufferCounterValue(GraphicsBuffer buffer, UInt32 counterValue)
private void InternalSetGraphicsBufferNativeData(GraphicsBuffer buffer, IntPtr data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
private void InternalSetGraphicsBufferData(GraphicsBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count, int elemSize)
private void InternalSetGraphicsBufferCounterValue(GraphicsBuffer buffer, UInt32 counterValue)
private void CopyBufferImpl(GraphicsBuffer source, GraphicsBuffer dest)
protected void Finalize()
public void Dispose()
private void Dispose(bool disposing)
public void Release()
public GraphicsFence CreateAsyncGraphicsFence()
public GraphicsFence CreateAsyncGraphicsFence(SynchronisationStage stage)
public GraphicsFence CreateGraphicsFence(GraphicsFenceType fenceType, SynchronisationStageFlags stage)
public void WaitOnAsyncGraphicsFence(GraphicsFence fence)
public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStage stage)
public void WaitOnAsyncGraphicsFence(GraphicsFence fence, SynchronisationStageFlags stage)
public void SetComputeFloatParam(ComputeShader computeShader, string name, float val)
public void SetComputeIntParam(ComputeShader computeShader, string name, int val)
public void SetComputeVectorParam(ComputeShader computeShader, string name, Vector4 val)
public void SetComputeVectorArrayParam(ComputeShader computeShader, string name, Vector4[] values)
public void SetComputeMatrixParam(ComputeShader computeShader, string name, Matrix4x4 val)
public void SetComputeMatrixArrayParam(ComputeShader computeShader, string name, Matrix4x4[] values)
public void SetComputeFloatParams(ComputeShader computeShader, string name, Single[] values)
public void SetComputeFloatParams(ComputeShader computeShader, int nameID, Single[] values)
public void SetComputeIntParams(ComputeShader computeShader, string name, Int32[] values)
public void SetComputeIntParams(ComputeShader computeShader, int nameID, Int32[] values)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element)
public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, RenderTargetIdentifier rt, int mipLevel, RenderTextureSubElement element)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, ComputeBuffer buffer)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer)
public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, GraphicsBuffer buffer)
public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size)
public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, ComputeBuffer buffer, int offset, int size)
public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, GraphicsBuffer buffer, int offset, int size)
public void SetComputeConstantBufferParam(ComputeShader computeShader, string name, GraphicsBuffer buffer, int offset, int size)
public void DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ)
public void DispatchCompute(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, UInt32 argsOffset)
public void DispatchCompute(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, UInt32 argsOffset)
public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure)
public void BuildRayTracingAccelerationStructure(RayTracingAccelerationStructure accelerationStructure, Vector3 relativeOrigin)
public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, string name, RayTracingAccelerationStructure rayTracingAccelerationStructure)
public void SetRayTracingAccelerationStructure(RayTracingShader rayTracingShader, int nameID, RayTracingAccelerationStructure rayTracingAccelerationStructure)
public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer)
public void SetRayTracingBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer)
public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer, int offset, int size)
public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, ComputeBuffer buffer, int offset, int size)
public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, int nameID, GraphicsBuffer buffer, int offset, int size)
public void SetRayTracingConstantBufferParam(RayTracingShader rayTracingShader, string name, GraphicsBuffer buffer, int offset, int size)
public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, string name, RenderTargetIdentifier rt)
public void SetRayTracingTextureParam(RayTracingShader rayTracingShader, int nameID, RenderTargetIdentifier rt)
public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, string name, float val)
public void SetRayTracingFloatParam(RayTracingShader rayTracingShader, int nameID, float val)
public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, string name, Single[] values)
public void SetRayTracingFloatParams(RayTracingShader rayTracingShader, int nameID, Single[] values)
public void SetRayTracingIntParam(RayTracingShader rayTracingShader, string name, int val)
public void SetRayTracingIntParam(RayTracingShader rayTracingShader, int nameID, int val)
public void SetRayTracingIntParams(RayTracingShader rayTracingShader, string name, Int32[] values)
public void SetRayTracingIntParams(RayTracingShader rayTracingShader, int nameID, Int32[] values)
public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, string name, Vector4 val)
public void SetRayTracingVectorParam(RayTracingShader rayTracingShader, int nameID, Vector4 val)
public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, string name, Vector4[] values)
public void SetRayTracingVectorArrayParam(RayTracingShader rayTracingShader, int nameID, Vector4[] values)
public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, string name, Matrix4x4 val)
public void SetRayTracingMatrixParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4 val)
public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, string name, Matrix4x4[] values)
public void SetRayTracingMatrixArrayParam(RayTracingShader rayTracingShader, int nameID, Matrix4x4[] values)
public void DispatchRays(RayTracingShader rayTracingShader, string rayGenName, UInt32 width, UInt32 height, UInt32 depth, Camera camera)
public void GenerateMips(RenderTargetIdentifier rt)
public void GenerateMips(RenderTexture rt)
public void ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex)
public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material)
public void DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass)
public void DrawRenderer(Renderer renderer, Material material, int submeshIndex)
public void DrawRenderer(Renderer renderer, Material material)
public void DrawRendererList(RendererList rendererList)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount)
public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount)
public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties)
public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount)
public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset)
public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count)
public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices)
public void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset)
public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs)
public void DrawOcclusionMesh(RectInt normalizedCamViewport)
public void SetRandomWriteTarget(int index, RenderTargetIdentifier rt)
public void SetRandomWriteTarget(int index, ComputeBuffer buffer, bool preserveCounterValue)
public void SetRandomWriteTarget(int index, ComputeBuffer buffer)
public void SetRandomWriteTarget(int index, GraphicsBuffer buffer, bool preserveCounterValue)
public void SetRandomWriteTarget(int index, GraphicsBuffer buffer)
public void CopyCounterValue(ComputeBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes)
public void CopyCounterValue(GraphicsBuffer src, ComputeBuffer dst, UInt32 dstOffsetBytes)
public void CopyCounterValue(ComputeBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes)
public void CopyCounterValue(GraphicsBuffer src, GraphicsBuffer dst, UInt32 dstOffsetBytes)
public void CopyTexture(RenderTargetIdentifier src, RenderTargetIdentifier dst)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, RenderTargetIdentifier dst, int dstElement)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, RenderTargetIdentifier dst, int dstElement, int dstMip)
public void CopyTexture(RenderTargetIdentifier src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, RenderTargetIdentifier dst, int dstElement, int dstMip, int dstX, int dstY)
public void Blit(Texture source, RenderTargetIdentifier dest)
public void Blit(Texture source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset)
public void Blit(Texture source, RenderTargetIdentifier dest, Material mat)
public void Blit(Texture source, RenderTargetIdentifier dest, Material mat, int pass)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, int sourceDepthSlice, int destDepthSlice)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice)
public void Blit(RenderTargetIdentifier source, RenderTargetIdentifier dest, Material mat, int pass, int destDepthSlice)
public void SetGlobalFloat(string name, float value)
public void SetGlobalInt(string name, int value)
public void SetGlobalInteger(string name, int value)
public void SetGlobalVector(string name, Vector4 value)
public void SetGlobalColor(string name, Color value)
public void SetGlobalMatrix(string name, Matrix4x4 value)
public void SetGlobalFloatArray(string propertyName, List`1<float> values)
public void SetGlobalFloatArray(int nameID, List`1<float> values)
public void SetGlobalFloatArray(string propertyName, Single[] values)
public void SetGlobalVectorArray(string propertyName, List`1<Vector4> values)
public void SetGlobalVectorArray(int nameID, List`1<Vector4> values)
public void SetGlobalVectorArray(string propertyName, Vector4[] values)
public void SetGlobalMatrixArray(string propertyName, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(string propertyName, Matrix4x4[] values)
public void SetGlobalTexture(string name, RenderTargetIdentifier value)
public void SetGlobalTexture(int nameID, RenderTargetIdentifier value)
public void SetGlobalTexture(string name, RenderTargetIdentifier value, RenderTextureSubElement element)
public void SetGlobalTexture(int nameID, RenderTargetIdentifier value, RenderTextureSubElement element)
public void SetGlobalBuffer(string name, ComputeBuffer value)
public void SetGlobalBuffer(int nameID, ComputeBuffer value)
public void SetGlobalBuffer(string name, GraphicsBuffer value)
public void SetGlobalBuffer(int nameID, GraphicsBuffer value)
public void SetGlobalConstantBuffer(ComputeBuffer buffer, int nameID, int offset, int size)
public void SetGlobalConstantBuffer(ComputeBuffer buffer, string name, int offset, int size)
public void SetGlobalConstantBuffer(GraphicsBuffer buffer, int nameID, int offset, int size)
public void SetGlobalConstantBuffer(GraphicsBuffer buffer, string name, int offset, int size)
public void SetShadowSamplingMode(RenderTargetIdentifier shadowmap, ShadowSamplingMode mode)
public void SetSinglePassStereo(SinglePassStereoMode mode)
public void IssuePluginEvent(IntPtr callback, int eventID)
public void IssuePluginEventAndData(IntPtr callback, int eventID, IntPtr data)
public void IssuePluginCustomBlit(IntPtr callback, UInt32 command, RenderTargetIdentifier source, RenderTargetIdentifier dest, UInt32 commandParam, UInt32 commandFlags)
public void IssuePluginCustomTextureUpdate(IntPtr callback, Texture targetTexture, UInt32 userData)
public void IssuePluginCustomTextureUpdateV1(IntPtr callback, Texture targetTexture, UInt32 userData)
public void IssuePluginCustomTextureUpdateV2(IntPtr callback, Texture targetTexture, UInt32 userData)
public void ProcessVTFeedback(RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip)
public void CopyBuffer(GraphicsBuffer source, GraphicsBuffer dest)
public GPUFence CreateGPUFence(SynchronisationStage stage)
public GPUFence CreateGPUFence()
public void WaitOnGPUFence(GPUFence fence, SynchronisationStage stage)
public void WaitOnGPUFence(GPUFence fence)
public void SetComputeBufferData(ComputeBuffer buffer, Array data)
public void SetComputeBufferData(ComputeBuffer buffer, List`1<T> data)
public void SetComputeBufferData(ComputeBuffer buffer, NativeArray`1<T> data)
public void SetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetComputeBufferData(ComputeBuffer buffer, List`1<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetComputeBufferData(ComputeBuffer buffer, NativeArray`1<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count)
public void SetComputeBufferCounterValue(ComputeBuffer buffer, UInt32 counterValue)
private void ConvertTexture_Internal_Injected(RenderTargetIdentifier& src, int srcElement, RenderTargetIdentifier& dst, int dstElement)
private void SetComputeVectorParam_Injected(ComputeShader computeShader, int nameID, Vector4& val)
private void SetComputeMatrixParam_Injected(ComputeShader computeShader, int nameID, Matrix4x4& val)
private void Internal_SetRayTracingVectorParam_Injected(RayTracingShader rayTracingShader, int nameID, Vector4& val)
private void Internal_SetRayTracingMatrixParam_Injected(RayTracingShader rayTracingShader, int nameID, Matrix4x4& val)
private void Internal_BuildRayTracingAccelerationStructure_Injected(RayTracingAccelerationStructure accelerationStructure, Vector3& relativeOrigin)
private void Internal_GenerateMips_Injected(RenderTargetIdentifier& rt)
private void Internal_DrawMesh_Injected(Mesh mesh, Matrix4x4& matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties)
private void Internal_DrawRendererList_Injected(RendererList& rendererList)
private void Internal_DrawProcedural_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexed_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndirect_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexedIndirect_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndirectGraphicsBuffer_Injected(Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawProceduralIndexedIndirectGraphicsBuffer_Injected(GraphicsBuffer indexBuffer, Matrix4x4& matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties)
private void Internal_DrawOcclusionMesh_Injected(RectInt& normalizedCamViewport)
private void SetViewport_Injected(Rect& pixelRect)
private void EnableScissorRect_Injected(Rect& scissor)
private void Blit_Texture_Injected(Texture source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice)
private void Blit_Identifier_Injected(RenderTargetIdentifier& source, RenderTargetIdentifier& dest, Material mat, int pass, Vector2& scale, Vector2& offset, int sourceDepthSlice, int destDepthSlice)
private void GetTemporaryRTWithDescriptor_Injected(int nameID, RenderTextureDescriptor& desc, FilterMode filter)
private void ClearRenderTarget_Injected(RTClearFlags clearFlags, Color& backgroundColor, float depth, UInt32 stencil)
private void SetGlobalVector_Injected(int nameID, Vector4& value)
private void SetGlobalColor_Injected(int nameID, Color& value)
private void SetGlobalMatrix_Injected(int nameID, Matrix4x4& value)
private void EnableGlobalKeyword_Injected(GlobalKeyword& keyword)
private void EnableMaterialKeyword_Injected(Material material, LocalKeyword& keyword)
private void EnableComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword)
private void DisableGlobalKeyword_Injected(GlobalKeyword& keyword)
private void DisableMaterialKeyword_Injected(Material material, LocalKeyword& keyword)
private void DisableComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword)
private void SetGlobalKeyword_Injected(GlobalKeyword& keyword, bool value)
private void SetMaterialKeyword_Injected(Material material, LocalKeyword& keyword, bool value)
private void SetComputeKeyword_Injected(ComputeShader computeShader, LocalKeyword& keyword, bool value)
private void SetViewMatrix_Injected(Matrix4x4& view)
private void SetProjectionMatrix_Injected(Matrix4x4& proj)
private void SetViewProjectionMatrices_Injected(Matrix4x4& view, Matrix4x4& proj)
private void IncrementUpdateCount_Injected(RenderTargetIdentifier& dest)
private void SetRenderTargetSingle_Internal_Injected(RenderTargetIdentifier& rt, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
private void SetRenderTargetColorDepth_Internal_Injected(RenderTargetIdentifier& color, RenderTargetIdentifier& depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags)
private void SetRenderTargetMulti_Internal_Injected(RenderTargetIdentifier[] colors, RenderTargetIdentifier& depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, RenderTargetFlags flags)
private void SetRenderTargetColorDepthSubtarget_Injected(RenderTargetIdentifier& color, RenderTargetIdentifier& depth, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void SetRenderTargetMultiSubtarget_Injected(RenderTargetIdentifier[] colors, RenderTargetIdentifier& depth, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction, int mipLevel, CubemapFace cubemapFace, int depthSlice)
private void Internal_ProcessVTFeedback_Injected(RenderTargetIdentifier& rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip)
}
public UnityEngine.Rendering.CommandBufferExecutionFlags : Enum {
public int value__
public CommandBufferExecutionFlags None
public CommandBufferExecutionFlags AsyncCompute
}
public UnityEngine.Rendering.CommandBufferExtensions : object {
private void Internal_SwitchIntoFastMemory(CommandBuffer cmd, RenderTargetIdentifier& rt, FastMemoryFlags fastMemoryFlags, float residency, bool copyContents)
private void Internal_SwitchOutOfFastMemory(CommandBuffer cmd, RenderTargetIdentifier& rt, bool copyContents)
public void SwitchIntoFastMemory(CommandBuffer cmd, RenderTargetIdentifier rid, FastMemoryFlags fastMemoryFlags, float residency, bool copyContents)
public void SwitchOutOfFastMemory(CommandBuffer cmd, RenderTargetIdentifier rid, bool copyContents)
}
public UnityEngine.Rendering.CompareFunction : Enum {
public int value__
public CompareFunction Disabled
public CompareFunction Never
public CompareFunction Less
public CompareFunction Equal
public CompareFunction LessEqual
public CompareFunction Greater
public CompareFunction NotEqual
public CompareFunction GreaterEqual
public CompareFunction Always
}
public UnityEngine.Rendering.ComputeQueueType : Enum {
public int value__
public ComputeQueueType Default
public ComputeQueueType Background
public ComputeQueueType Urgent
}
public UnityEngine.Rendering.CopyTextureSupport : Enum {
public int value__
public CopyTextureSupport None
public CopyTextureSupport Basic
public CopyTextureSupport Copy3D
public CopyTextureSupport DifferentTypes
public CopyTextureSupport TextureToRT
public CopyTextureSupport RTToTexture
}
internal UnityEngine.Rendering.CoreCameraValues : ValueType {
private int filterMode
private UInt32 cullingMask
private int instanceID
public bool Equals(CoreCameraValues other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CoreCameraValues left, CoreCameraValues right)
public bool op_Inequality(CoreCameraValues left, CoreCameraValues right)
}
internal UnityEngine.Rendering.CullingAllocationInfo : ValueType {
public VisibleLight* visibleLightsPtr
public VisibleLight* visibleOffscreenVertexLightsPtr
public VisibleReflectionProbe* visibleReflectionProbesPtr
public int visibleLightCount
public int visibleOffscreenVertexLightCount
public int visibleReflectionProbeCount
}
public UnityEngine.Rendering.CullingOptions : Enum {
public int value__
public CullingOptions None
public CullingOptions ForceEvenIfCameraIsNotActive
public CullingOptions OcclusionCull
public CullingOptions NeedsLighting
public CullingOptions NeedsReflectionProbes
public CullingOptions Stereo
public CullingOptions DisablePerObjectCulling
public CullingOptions ShadowCasters
}
public UnityEngine.Rendering.CullingResults : ValueType {
internal IntPtr ptr
private CullingAllocationInfo* m_AllocationInfo
public NativeArray`1<VisibleLight> visibleLights
public NativeArray`1<VisibleLight> visibleOffscreenVertexLights
public NativeArray`1<VisibleReflectionProbe> visibleReflectionProbes
public int lightIndexCount
public int reflectionProbeIndexCount
public int lightAndReflectionProbeIndexCount
private int GetLightIndexCount(IntPtr cullingResultsPtr)
private int GetReflectionProbeIndexCount(IntPtr cullingResultsPtr)
private void FillLightAndReflectionProbeIndices(IntPtr cullingResultsPtr, ComputeBuffer computeBuffer)
private void FillLightAndReflectionProbeIndicesGraphicsBuffer(IntPtr cullingResultsPtr, GraphicsBuffer buffer)
private int GetLightIndexMapSize(IntPtr cullingResultsPtr)
private int GetReflectionProbeIndexMapSize(IntPtr cullingResultsPtr)
private void FillLightIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize)
private void FillReflectionProbeIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize)
private void SetLightIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize)
private void SetReflectionProbeIndexMap(IntPtr cullingResultsPtr, IntPtr indexMapPtr, int indexMapSize)
private bool GetShadowCasterBounds(IntPtr cullingResultsPtr, int lightIndex, Bounds& bounds)
private bool ComputeSpotShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool ComputePointShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
private bool ComputeDirectionalShadowMatricesAndCullingPrimitives(IntPtr cullingResultsPtr, int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
public NativeArray`1<VisibleLight> get_visibleLights()
public NativeArray`1<VisibleLight> get_visibleOffscreenVertexLights()
public NativeArray`1<VisibleReflectionProbe> get_visibleReflectionProbes()
private NativeArray`1<T> GetNativeArray(Void* dataPointer, int length)
public int get_lightIndexCount()
public int get_reflectionProbeIndexCount()
public int get_lightAndReflectionProbeIndexCount()
public void FillLightAndReflectionProbeIndices(ComputeBuffer computeBuffer)
public void FillLightAndReflectionProbeIndices(GraphicsBuffer buffer)
public NativeArray`1<int> GetLightIndexMap(Allocator allocator)
public void SetLightIndexMap(NativeArray`1<int> lightIndexMap)
public NativeArray`1<int> GetReflectionProbeIndexMap(Allocator allocator)
public void SetReflectionProbeIndexMap(NativeArray`1<int> lightIndexMap)
public bool GetShadowCasterBounds(int lightIndex, Bounds& outBounds)
public bool ComputeSpotShadowMatricesAndCullingPrimitives(int activeLightIndex, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
public bool ComputePointShadowMatricesAndCullingPrimitives(int activeLightIndex, CubemapFace cubemapFace, float fovBias, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
public bool ComputeDirectionalShadowMatricesAndCullingPrimitives(int activeLightIndex, int splitIndex, int splitCount, Vector3 splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
internal void Validate()
public bool Equals(CullingResults other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CullingResults left, CullingResults right)
public bool op_Inequality(CullingResults left, CullingResults right)
private bool ComputeDirectionalShadowMatricesAndCullingPrimitives_Injected(IntPtr cullingResultsPtr, int activeLightIndex, int splitIndex, int splitCount, Vector3& splitRatio, int shadowResolution, float shadowNearPlaneOffset, Matrix4x4& viewMatrix, Matrix4x4& projMatrix, ShadowSplitData& shadowSplitData)
}
public UnityEngine.Rendering.CullMode : Enum {
public int value__
public CullMode Off
public CullMode Front
public CullMode Back
}
public UnityEngine.Rendering.DefaultReflectionMode : Enum {
public int value__
public DefaultReflectionMode Skybox
public DefaultReflectionMode Custom
}
public UnityEngine.Rendering.DepthState : ValueType {
private byte m_WriteEnabled
private sbyte m_CompareFunction
public DepthState defaultValue
public bool writeEnabled
public CompareFunction compareFunction
public DepthState get_defaultValue()
public void .ctor(bool writeEnabled, CompareFunction compareFunction)
public bool get_writeEnabled()
public void set_writeEnabled(bool value)
public CompareFunction get_compareFunction()
public void set_compareFunction(CompareFunction value)
public bool Equals(DepthState other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(DepthState left, DepthState right)
public bool op_Inequality(DepthState left, DepthState right)
}
public UnityEngine.Rendering.DistanceMetric : Enum {
public int value__
public DistanceMetric Perspective
public DistanceMetric Orthographic
public DistanceMetric CustomAxis
}
public UnityEngine.Rendering.DrawingSettings : ValueType {
private int kMaxShaderPasses
public int maxShaderPasses
private SortingSettings m_SortingSettings
internal <shaderPassNames>e__FixedBuffer shaderPassNames
private PerObjectData m_PerObjectData
private DrawRendererFlags m_Flags
private int m_OverrideMaterialInstanceId
private int m_OverrideMaterialPassIndex
private int m_fallbackMaterialInstanceId
private int m_MainLightIndex
private int m_UseSrpBatcher
public SortingSettings sortingSettings
public PerObjectData perObjectData
public bool enableDynamicBatching
public bool enableInstancing
public Material overrideMaterial
public int overrideMaterialPassIndex
public Material fallbackMaterial
public int mainLightIndex
public void .ctor(ShaderTagId shaderPassName, SortingSettings sortingSettings)
public SortingSettings get_sortingSettings()
public void set_sortingSettings(SortingSettings value)
public PerObjectData get_perObjectData()
public void set_perObjectData(PerObjectData value)
public bool get_enableDynamicBatching()
public void set_enableDynamicBatching(bool value)
public bool get_enableInstancing()
public void set_enableInstancing(bool value)
public Material get_overrideMaterial()
public void set_overrideMaterial(Material value)
public int get_overrideMaterialPassIndex()
public void set_overrideMaterialPassIndex(int value)
public Material get_fallbackMaterial()
public void set_fallbackMaterial(Material value)
public int get_mainLightIndex()
public void set_mainLightIndex(int value)
public ShaderTagId GetShaderPassName(int index)
public void SetShaderPassName(int index, ShaderTagId shaderPassName)
public bool Equals(DrawingSettings other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(DrawingSettings left, DrawingSettings right)
public bool op_Inequality(DrawingSettings left, DrawingSettings right)
}
internal UnityEngine.Rendering.DrawRendererFlags : Enum {
public int value__
public DrawRendererFlags None
public DrawRendererFlags EnableDynamicBatching
public DrawRendererFlags EnableInstancing
}
public UnityEngine.Rendering.FastMemoryFlags : Enum {
public int value__
public FastMemoryFlags None
public FastMemoryFlags SpillTop
public FastMemoryFlags SpillBottom
}
public UnityEngine.Rendering.FilteringSettings : ValueType {
private RenderQueueRange m_RenderQueueRange
private int m_LayerMask
private UInt32 m_RenderingLayerMask
private int m_ExcludeMotionVectorObjects
private SortingLayerRange m_SortingLayerRange
public FilteringSettings defaultValue
public RenderQueueRange renderQueueRange
public int layerMask
public UInt32 renderingLayerMask
public bool excludeMotionVectorObjects
public SortingLayerRange sortingLayerRange
public FilteringSettings get_defaultValue()
public void .ctor(Nullable`1<RenderQueueRange> renderQueueRange, int layerMask, UInt32 renderingLayerMask, int excludeMotionVectorObjects)
public RenderQueueRange get_renderQueueRange()
public void set_renderQueueRange(RenderQueueRange value)
public int get_layerMask()
public void set_layerMask(int value)
public UInt32 get_renderingLayerMask()
public void set_renderingLayerMask(UInt32 value)
public bool get_excludeMotionVectorObjects()
public void set_excludeMotionVectorObjects(bool value)
public SortingLayerRange get_sortingLayerRange()
public void set_sortingLayerRange(SortingLayerRange value)
public bool Equals(FilteringSettings other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(FilteringSettings left, FilteringSettings right)
public bool op_Inequality(FilteringSettings left, FilteringSettings right)
}
public UnityEngine.Rendering.FormatSwizzle : Enum {
public int value__
public FormatSwizzle FormatSwizzleR
public FormatSwizzle FormatSwizzleG
public FormatSwizzle FormatSwizzleB
public FormatSwizzle FormatSwizzleA
public FormatSwizzle FormatSwizzle0
public FormatSwizzle FormatSwizzle1
}
public UnityEngine.Rendering.GizmoSubset : Enum {
public int value__
public GizmoSubset PreImageEffects
public GizmoSubset PostImageEffects
}
public UnityEngine.Rendering.GlobalKeyword : ValueType {
internal string m_Name
internal UInt32 m_Index
public string name
private UInt32 GetGlobalKeywordCount()
private UInt32 GetGlobalKeywordIndex(string keyword)
private void CreateGlobalKeyword(string keyword)
public string get_name()
public GlobalKeyword Create(string name)
public void .ctor(string name)
public string ToString()
}
public UnityEngine.Rendering.GPUFence : ValueType {
public bool passed
public bool get_passed()
}
public UnityEngine.Rendering.GraphicsDeviceType : Enum {
public int value__
public GraphicsDeviceType OpenGL2
public GraphicsDeviceType Direct3D9
public GraphicsDeviceType Direct3D11
public GraphicsDeviceType PlayStation3
public GraphicsDeviceType Null
public GraphicsDeviceType Xbox360
public GraphicsDeviceType OpenGLES2
public GraphicsDeviceType OpenGLES3
public GraphicsDeviceType PlayStationVita
public GraphicsDeviceType PlayStation4
public GraphicsDeviceType XboxOne
public GraphicsDeviceType PlayStationMobile
public GraphicsDeviceType Metal
public GraphicsDeviceType OpenGLCore
public GraphicsDeviceType Direct3D12
public GraphicsDeviceType N3DS
public GraphicsDeviceType Vulkan
public GraphicsDeviceType Switch
public GraphicsDeviceType XboxOneD3D12
public GraphicsDeviceType GameCoreXboxOne
public GraphicsDeviceType GameCoreScarlett
public GraphicsDeviceType GameCoreXboxSeries
public GraphicsDeviceType PlayStation5
public GraphicsDeviceType PlayStation5NGGC
}
public UnityEngine.Rendering.GraphicsFence : ValueType {
internal IntPtr m_Ptr
internal int m_Version
internal GraphicsFenceType m_FenceType
public bool passed
internal SynchronisationStageFlags TranslateSynchronizationStageToFlags(SynchronisationStage s)
public bool get_passed()
private bool HasFencePassed_Internal(IntPtr fencePtr)
internal void InitPostAllocation()
internal bool IsFencePending()
internal void Validate()
private int GetPlatformNotSupportedVersion()
private int GetVersionNumber(IntPtr fencePtr)
}
public UnityEngine.Rendering.GraphicsFenceType : Enum {
public int value__
public GraphicsFenceType AsyncQueueSynchronisation
public GraphicsFenceType CPUSynchronisation
}
public UnityEngine.Rendering.GraphicsSettings : Object {
public TransparencySortMode transparencySortMode
public Vector3 transparencySortAxis
public bool realtimeDirectRectangularAreaLights
public bool lightsUseLinearIntensity
public bool lightsUseColorTemperature
public UInt32 defaultRenderingLayerMask
public bool useScriptableRenderPipelineBatching
public bool logWhenShaderIsCompiled
public bool disableBuiltinCustomRenderTextureUpdate
public VideoShadersIncludeMode videoShadersIncludeMode
private ScriptableObject INTERNAL_currentRenderPipeline
public RenderPipelineAsset currentRenderPipeline
public RenderPipelineAsset renderPipelineAsset
private ScriptableObject INTERNAL_defaultRenderPipeline
public RenderPipelineAsset defaultRenderPipeline
public RenderPipelineAsset[] allConfiguredRenderPipelines
public bool cameraRelativeLightCulling
public bool cameraRelativeShadowCulling
public TransparencySortMode get_transparencySortMode()
public void set_transparencySortMode(TransparencySortMode value)
public Vector3 get_transparencySortAxis()
public void set_transparencySortAxis(Vector3 value)
public bool get_realtimeDirectRectangularAreaLights()
public void set_realtimeDirectRectangularAreaLights(bool value)
public bool get_lightsUseLinearIntensity()
public void set_lightsUseLinearIntensity(bool value)
public bool get_lightsUseColorTemperature()
public void set_lightsUseColorTemperature(bool value)
public UInt32 get_defaultRenderingLayerMask()
public void set_defaultRenderingLayerMask(UInt32 value)
public bool get_useScriptableRenderPipelineBatching()
public void set_useScriptableRenderPipelineBatching(bool value)
public bool get_logWhenShaderIsCompiled()
public void set_logWhenShaderIsCompiled(bool value)
public bool get_disableBuiltinCustomRenderTextureUpdate()
public void set_disableBuiltinCustomRenderTextureUpdate(bool value)
public VideoShadersIncludeMode get_videoShadersIncludeMode()
public bool HasShaderDefine(GraphicsTier tier, BuiltinShaderDefine defineHash)
public bool HasShaderDefine(BuiltinShaderDefine defineHash)
private ScriptableObject get_INTERNAL_currentRenderPipeline()
public RenderPipelineAsset get_currentRenderPipeline()
public RenderPipelineAsset get_renderPipelineAsset()
public void set_renderPipelineAsset(RenderPipelineAsset value)
private ScriptableObject get_INTERNAL_defaultRenderPipeline()
private void set_INTERNAL_defaultRenderPipeline(ScriptableObject value)
public RenderPipelineAsset get_defaultRenderPipeline()
public void set_defaultRenderPipeline(RenderPipelineAsset value)
private ScriptableObject[] GetAllConfiguredRenderPipelines()
public RenderPipelineAsset[] get_allConfiguredRenderPipelines()
public Object GetGraphicsSettings()
public void SetShaderMode(BuiltinShaderType type, BuiltinShaderMode mode)
public BuiltinShaderMode GetShaderMode(BuiltinShaderType type)
public void SetCustomShader(BuiltinShaderType type, Shader shader)
public Shader GetCustomShader(BuiltinShaderType type)
public void RegisterRenderPipelineSettings(RenderPipelineGlobalSettings settings)
private void RegisterRenderPipeline(string renderpipelineName, Object settings)
public void UnregisterRenderPipelineSettings()
private void UnregisterRenderPipeline(string renderpipelineName)
public RenderPipelineGlobalSettings GetSettingsForRenderPipeline()
private Object GetSettingsForRenderPipeline(string renderpipelineName)
public bool get_cameraRelativeLightCulling()
public void set_cameraRelativeLightCulling(bool value)
public bool get_cameraRelativeShadowCulling()
public void set_cameraRelativeShadowCulling(bool value)
private void get_transparencySortAxis_Injected(Vector3& ret)
private void set_transparencySortAxis_Injected(Vector3& value)
}
public UnityEngine.Rendering.GraphicsTier : Enum {
public int value__
public GraphicsTier Tier1
public GraphicsTier Tier2
public GraphicsTier Tier3
}
public UnityEngine.Rendering.IndexFormat : Enum {
public int value__
public IndexFormat UInt16
public IndexFormat UInt32
}
public UnityEngine.Rendering.LightEvent : Enum {
public int value__
public LightEvent BeforeShadowMap
public LightEvent AfterShadowMap
public LightEvent BeforeScreenspaceMask
public LightEvent AfterScreenspaceMask
public LightEvent BeforeShadowMapPass
public LightEvent AfterShadowMapPass
}
public UnityEngine.Rendering.LightProbeUsage : Enum {
public int value__
public LightProbeUsage Off
public LightProbeUsage BlendProbes
public LightProbeUsage UseProxyVolume
public LightProbeUsage CustomProvided
}
public UnityEngine.Rendering.LightShadowResolution : Enum {
public int value__
public LightShadowResolution FromQualitySettings
public LightShadowResolution Low
public LightShadowResolution Medium
public LightShadowResolution High
public LightShadowResolution VeryHigh
}
public UnityEngine.Rendering.LocalKeyword : ValueType {
internal LocalKeywordSpace m_SpaceInfo
internal string m_Name
internal UInt32 m_Index
public string name
public bool isOverridable
public bool isValid
public ShaderKeywordType type
private bool IsOverridable(LocalKeyword kw)
private UInt32 GetShaderKeywordCount(Shader shader)
private UInt32 GetShaderKeywordIndex(Shader shader, string keyword)
private UInt32 GetComputeShaderKeywordCount(ComputeShader shader)
private UInt32 GetComputeShaderKeywordIndex(ComputeShader shader, string keyword)
private ShaderKeywordType GetKeywordType(LocalKeywordSpace spaceInfo, UInt32 keyword)
private bool IsValid(LocalKeywordSpace spaceInfo, UInt32 keyword)
public string get_name()
public bool get_isOverridable()
public bool get_isValid()
public ShaderKeywordType get_type()
public void .ctor(Shader shader, string name)
public void .ctor(ComputeShader shader, string name)
public string ToString()
public bool Equals(object o)
public bool Equals(LocalKeyword rhs)
public bool op_Equality(LocalKeyword lhs, LocalKeyword rhs)
public bool op_Inequality(LocalKeyword lhs, LocalKeyword rhs)
public int GetHashCode()
private bool IsOverridable_Injected(LocalKeyword& kw)
private ShaderKeywordType GetKeywordType_Injected(LocalKeywordSpace& spaceInfo, UInt32 keyword)
private bool IsValid_Injected(LocalKeywordSpace& spaceInfo, UInt32 keyword)
}
public UnityEngine.Rendering.LocalKeywordSpace : ValueType {
private IntPtr m_KeywordSpace
public LocalKeyword[] keywords
public String[] keywordNames
public UInt32 keywordCount
private LocalKeyword[] GetKeywords()
private String[] GetKeywordNames()
private UInt32 GetKeywordCount()
private LocalKeyword GetKeyword(string name)
public LocalKeyword[] get_keywords()
public String[] get_keywordNames()
public UInt32 get_keywordCount()
public LocalKeyword FindKeyword(string name)
public bool Equals(object o)
public bool Equals(LocalKeywordSpace rhs)
public bool op_Equality(LocalKeywordSpace lhs, LocalKeywordSpace rhs)
public bool op_Inequality(LocalKeywordSpace lhs, LocalKeywordSpace rhs)
public int GetHashCode()
private LocalKeyword[] GetKeywords_Injected(LocalKeywordSpace& _unity_self)
private String[] GetKeywordNames_Injected(LocalKeywordSpace& _unity_self)
private UInt32 GetKeywordCount_Injected(LocalKeywordSpace& _unity_self)
private void GetKeyword_Injected(LocalKeywordSpace& _unity_self, string name, LocalKeyword& ret)
}
public UnityEngine.Rendering.LODParameters : ValueType {
private int m_IsOrthographic
private Vector3 m_CameraPosition
private float m_FieldOfView
private float m_OrthoSize
private int m_CameraPixelHeight
public bool isOrthographic
public Vector3 cameraPosition
public float fieldOfView
public float orthoSize
public int cameraPixelHeight
public bool get_isOrthographic()
public void set_isOrthographic(bool value)
public Vector3 get_cameraPosition()
public void set_cameraPosition(Vector3 value)
public float get_fieldOfView()
public void set_fieldOfView(float value)
public float get_orthoSize()
public void set_orthoSize(float value)
public int get_cameraPixelHeight()
public void set_cameraPixelHeight(int value)
public bool Equals(LODParameters other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(LODParameters left, LODParameters right)
public bool op_Inequality(LODParameters left, LODParameters right)
}
public UnityEngine.Rendering.MeshUpdateFlags : Enum {
public int value__
public MeshUpdateFlags Default
public MeshUpdateFlags DontValidateIndices
public MeshUpdateFlags DontResetBoneBounds
public MeshUpdateFlags DontNotifyMeshUsers
public MeshUpdateFlags DontRecalculateBounds
}
public UnityEngine.Rendering.OnDemandRendering : object {
private int m_RenderFrameInterval
public bool willCurrentFrameRender
public int renderFrameInterval
public int effectiveRenderFrameRate
public bool get_willCurrentFrameRender()
public int get_renderFrameInterval()
public void set_renderFrameInterval(int value)
internal void GetRenderFrameInterval(Int32& frameInterval)
internal float GetEffectiveRenderFrameRate()
public int get_effectiveRenderFrameRate()
}
public UnityEngine.Rendering.OpaqueSortMode : Enum {
public int value__
public OpaqueSortMode Default
public OpaqueSortMode FrontToBack
public OpaqueSortMode NoDistanceSort
}
public UnityEngine.Rendering.OpenGLESVersion : Enum {
public int value__
public OpenGLESVersion None
public OpenGLESVersion OpenGLES20
public OpenGLESVersion OpenGLES30
public OpenGLESVersion OpenGLES31
public OpenGLESVersion OpenGLES31AEP
public OpenGLESVersion OpenGLES32
}
public UnityEngine.Rendering.PassIdentifier : ValueType {
internal UInt32 m_SubShaderIndex
internal UInt32 m_PassIndex
public UInt32 SubshaderIndex
public UInt32 PassIndex
public UInt32 get_SubshaderIndex()
public UInt32 get_PassIndex()
public bool Equals(object o)
public bool Equals(PassIdentifier rhs)
public bool op_Equality(PassIdentifier lhs, PassIdentifier rhs)
public bool op_Inequality(PassIdentifier lhs, PassIdentifier rhs)
public int GetHashCode()
}
public UnityEngine.Rendering.PassType : Enum {
public int value__
public PassType Normal
public PassType Vertex
public PassType VertexLM
public PassType VertexLMRGBM
public PassType ForwardBase
public PassType ForwardAdd
public PassType LightPrePassBase
public PassType LightPrePassFinal
public PassType ShadowCaster
public PassType Deferred
public PassType Meta
public PassType MotionVectors
public PassType ScriptableRenderPipeline
public PassType ScriptableRenderPipelineDefaultUnlit
public PassType GrabPass
}
public UnityEngine.Rendering.PerObjectData : Enum {
public int value__
public PerObjectData None
public PerObjectData LightProbe
public PerObjectData ReflectionProbes
public PerObjectData LightProbeProxyVolume
public PerObjectData Lightmaps
public PerObjectData LightData
public PerObjectData MotionVectors
public PerObjectData LightIndices
public PerObjectData ReflectionProbeData
public PerObjectData OcclusionProbe
public PerObjectData OcclusionProbeProxyVolume
public PerObjectData ShadowMask
}
public UnityEngine.Rendering.PIX : object {
public void BeginGPUCapture()
public void EndGPUCapture()
public bool IsAttached()
}
public UnityEngine.Rendering.PlatformKeywordSet : ValueType {
private int k_SizeInBits
internal ulong m_Bits
private ulong ComputeKeywordMask(BuiltinShaderDefine define)
public bool IsEnabled(BuiltinShaderDefine define)
public void Enable(BuiltinShaderDefine define)
public void Disable(BuiltinShaderDefine define)
}
public UnityEngine.Rendering.RasterState : ValueType {
public RasterState defaultValue
private CullMode m_CullingMode
private int m_OffsetUnits
private float m_OffsetFactor
private byte m_DepthClip
private byte m_Conservative
private byte m_Padding1
private byte m_Padding2
public CullMode cullingMode
public bool depthClip
public bool conservative
public int offsetUnits
public float offsetFactor
public void .ctor(CullMode cullingMode, int offsetUnits, float offsetFactor, bool depthClip)
public CullMode get_cullingMode()
public void set_cullingMode(CullMode value)
public bool get_depthClip()
public void set_depthClip(bool value)
public bool get_conservative()
public void set_conservative(bool value)
public int get_offsetUnits()
public void set_offsetUnits(int value)
public float get_offsetFactor()
public void set_offsetFactor(float value)
public bool Equals(RasterState other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(RasterState left, RasterState right)
public bool op_Inequality(RasterState left, RasterState right)
}
public UnityEngine.Rendering.RealtimeGICPUUsage : Enum {
public int value__
public RealtimeGICPUUsage Low
public RealtimeGICPUUsage Medium
public RealtimeGICPUUsage High
public RealtimeGICPUUsage Unlimited
}
public UnityEngine.Rendering.ReflectionCubemapCompression : Enum {
public int value__
public ReflectionCubemapCompression Uncompressed
public ReflectionCubemapCompression Compressed
public ReflectionCubemapCompression Auto
}
public UnityEngine.Rendering.ReflectionProbeBlendInfo : ValueType {
public ReflectionProbe probe
public float weight
}
public UnityEngine.Rendering.ReflectionProbeClearFlags : Enum {
public int value__
public ReflectionProbeClearFlags Skybox
public ReflectionProbeClearFlags SolidColor
}
public UnityEngine.Rendering.ReflectionProbeMode : Enum {
public int value__
public ReflectionProbeMode Baked
public ReflectionProbeMode Realtime
public ReflectionProbeMode Custom
}
public UnityEngine.Rendering.ReflectionProbeRefreshMode : Enum {
public int value__
public ReflectionProbeRefreshMode OnAwake
public ReflectionProbeRefreshMode EveryFrame
public ReflectionProbeRefreshMode ViaScripting
}
public UnityEngine.Rendering.ReflectionProbeSortingCriteria : Enum {
public int value__
public ReflectionProbeSortingCriteria None
public ReflectionProbeSortingCriteria Importance
public ReflectionProbeSortingCriteria Size
public ReflectionProbeSortingCriteria ImportanceThenSize
}
public UnityEngine.Rendering.ReflectionProbeTimeSlicingMode : Enum {
public int value__
public ReflectionProbeTimeSlicingMode AllFacesAtOnce
public ReflectionProbeTimeSlicingMode IndividualFaces
public ReflectionProbeTimeSlicingMode NoTimeSlicing
}
public UnityEngine.Rendering.ReflectionProbeType : Enum {
public int value__
public ReflectionProbeType Cube
public ReflectionProbeType Card
}
public UnityEngine.Rendering.ReflectionProbeUsage : Enum {
public int value__
public ReflectionProbeUsage Off
public ReflectionProbeUsage BlendProbes
public ReflectionProbeUsage BlendProbesAndSkybox
public ReflectionProbeUsage Simple
}
public UnityEngine.Rendering.RenderBufferLoadAction : Enum {
public int value__
public RenderBufferLoadAction Load
public RenderBufferLoadAction Clear
public RenderBufferLoadAction DontCare
}
public UnityEngine.Rendering.RenderBufferStoreAction : Enum {
public int value__
public RenderBufferStoreAction Store
public RenderBufferStoreAction Resolve
public RenderBufferStoreAction StoreAndResolve
public RenderBufferStoreAction DontCare
}
public UnityEngine.Rendering.RendererUtils.RendererList : ValueType {
internal UIntPtr context
internal UInt32 index
internal UInt32 frame
public RendererList nullRendererList
public bool isValid
public bool get_isValid()
internal void .ctor(UIntPtr ctx, UInt32 indx)
private bool get_isValid_Injected(RendererList& _unity_self)
}
public UnityEngine.Rendering.RendererUtils.RendererListDesc : ValueType {
public SortingCriteria sortingCriteria
public PerObjectData rendererConfiguration
public RenderQueueRange renderQueueRange
public Nullable`1<RenderStateBlock> stateBlock
public Material overrideMaterial
public bool excludeObjectMotionVectors
public int layerMask
public int overrideMaterialPassIndex
private CullingResults <cullingResult>k__BackingField
private Camera <camera>k__BackingField
private ShaderTagId <passName>k__BackingField
private ShaderTagId[] <passNames>k__BackingField
internal CullingResults cullingResult
internal Camera camera
internal ShaderTagId passName
internal ShaderTagId[] passNames
internal CullingResults get_cullingResult()
private void set_cullingResult(CullingResults value)
internal Camera get_camera()
internal void set_camera(Camera value)
internal ShaderTagId get_passName()
private void set_passName(ShaderTagId value)
internal ShaderTagId[] get_passNames()
private void set_passNames(ShaderTagId[] value)
public void .ctor(ShaderTagId passName, CullingResults cullingResult, Camera camera)
public void .ctor(ShaderTagId[] passNames, CullingResults cullingResult, Camera camera)
public bool IsValid()
}
internal UnityEngine.Rendering.RendererUtils.RendererListParams : ValueType {
private ShaderTagId s_EmptyName
public RendererListParams nullRendererList
private bool <isValid>k__BackingField
internal CullingResults cullingResult
internal DrawingSettings drawSettings
internal FilteringSettings filteringSettings
internal Nullable`1<RenderStateBlock> stateBlock
public bool isValid
public bool get_isValid()
private void set_isValid(bool value)
internal RendererListParams Create(RendererListDesc& desc)
}
public UnityEngine.Rendering.RendererUtils.RendererListStatus : Enum {
public int value__
public RendererListStatus kRendererListInvalid
public RendererListStatus kRendererListProcessing
public RendererListStatus kRendererListEmpty
public RendererListStatus kRendererListPopulated
}
public UnityEngine.Rendering.RenderingThreadingMode : Enum {
public int value__
public RenderingThreadingMode Direct
public RenderingThreadingMode SingleThreaded
public RenderingThreadingMode MultiThreaded
public RenderingThreadingMode LegacyJobified
public RenderingThreadingMode NativeGraphicsJobs
public RenderingThreadingMode NativeGraphicsJobsWithoutRenderThread
}
public UnityEngine.Rendering.RenderPipeline : object {
private bool <disposed>k__BackingField
public bool disposed
public RenderPipelineGlobalSettings defaultSettings
protected void Render(ScriptableRenderContext context, Camera[] cameras)
protected void ProcessRenderRequests(ScriptableRenderContext context, Camera camera, List`1<RenderRequest> renderRequests)
protected void BeginFrameRendering(ScriptableRenderContext context, Camera[] cameras)
protected void BeginContextRendering(ScriptableRenderContext context, List`1<Camera> cameras)
protected void BeginCameraRendering(ScriptableRenderContext context, Camera camera)
protected void EndContextRendering(ScriptableRenderContext context, List`1<Camera> cameras)
protected void EndFrameRendering(ScriptableRenderContext context, Camera[] cameras)
protected void EndCameraRendering(ScriptableRenderContext context, Camera camera)
protected void Render(ScriptableRenderContext context, List`1<Camera> cameras)
internal void InternalRender(ScriptableRenderContext context, List`1<Camera> cameras)
internal void InternalRenderWithRequests(ScriptableRenderContext context, List`1<Camera> cameras, List`1<RenderRequest> renderRequests)
public bool get_disposed()
private void set_disposed(bool value)
internal void Dispose()
protected void Dispose(bool disposing)
public RenderPipelineGlobalSettings get_defaultSettings()
}
public UnityEngine.Rendering.RenderPipelineAsset : ScriptableObject {
public String[] renderingLayerMaskNames
public String[] prefixedRenderingLayerMaskNames
public Material defaultMaterial
public Shader autodeskInteractiveShader
public Shader autodeskInteractiveTransparentShader
public Shader autodeskInteractiveMaskedShader
public Shader terrainDetailLitShader
public Shader terrainDetailGrassShader
public Shader terrainDetailGrassBillboardShader
public Material defaultParticleMaterial
public Material defaultLineMaterial
public Material defaultTerrainMaterial
public Material defaultUIMaterial
public Material defaultUIOverdrawMaterial
public Material defaultUIETC1SupportedMaterial
public Material default2DMaterial
public Material default2DMaskMaterial
public Shader defaultShader
public Shader defaultSpeedTree7Shader
public Shader defaultSpeedTree8Shader
internal RenderPipeline InternalCreatePipeline()
public String[] get_renderingLayerMaskNames()
public String[] get_prefixedRenderingLayerMaskNames()
public Material get_defaultMaterial()
public Shader get_autodeskInteractiveShader()
public Shader get_autodeskInteractiveTransparentShader()
public Shader get_autodeskInteractiveMaskedShader()
public Shader get_terrainDetailLitShader()
public Shader get_terrainDetailGrassShader()
public Shader get_terrainDetailGrassBillboardShader()
public Material get_defaultParticleMaterial()
public Material get_defaultLineMaterial()
public Material get_defaultTerrainMaterial()
public Material get_defaultUIMaterial()
public Material get_defaultUIOverdrawMaterial()
public Material get_defaultUIETC1SupportedMaterial()
public Material get_default2DMaterial()
public Material get_default2DMaskMaterial()
public Shader get_defaultShader()
public Shader get_defaultSpeedTree7Shader()
public Shader get_defaultSpeedTree8Shader()
protected RenderPipeline CreatePipeline()
protected void OnValidate()
protected void OnDisable()
}
public UnityEngine.Rendering.RenderPipelineManager : object {
internal RenderPipelineAsset s_CurrentPipelineAsset
private List`1<Camera> s_Cameras
private string s_currentPipelineType
private string s_builtinPipelineName
private RenderPipeline s_currentPipeline
private Action`2<ScriptableRenderContext, List`1<Camera>> beginContextRendering
private Action`2<ScriptableRenderContext, List`1<Camera>> endContextRendering
private Action`2<ScriptableRenderContext, Camera[]> beginFrameRendering
private Action`2<ScriptableRenderContext, Camera> beginCameraRendering
private Action`2<ScriptableRenderContext, Camera[]> endFrameRendering
private Action`2<ScriptableRenderContext, Camera> endCameraRendering
private Action activeRenderPipelineTypeChanged
public RenderPipeline currentPipeline
public bool pipelineSwitchCompleted
public RenderPipeline get_currentPipeline()
private void set_currentPipeline(RenderPipeline value)
public void add_beginContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value)
public void remove_beginContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value)
public void add_endContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value)
public void remove_endContextRendering(Action`2<ScriptableRenderContext, List`1<Camera>> value)
public void add_beginFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value)
public void remove_beginFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value)
public void add_beginCameraRendering(Action`2<ScriptableRenderContext, Camera> value)
public void remove_beginCameraRendering(Action`2<ScriptableRenderContext, Camera> value)
public void add_endFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value)
public void remove_endFrameRendering(Action`2<ScriptableRenderContext, Camera[]> value)
public void add_endCameraRendering(Action`2<ScriptableRenderContext, Camera> value)
public void remove_endCameraRendering(Action`2<ScriptableRenderContext, Camera> value)
public void add_activeRenderPipelineTypeChanged(Action value)
public void remove_activeRenderPipelineTypeChanged(Action value)
internal void BeginContextRendering(ScriptableRenderContext context, List`1<Camera> cameras)
internal void BeginCameraRendering(ScriptableRenderContext context, Camera camera)
internal void EndContextRendering(ScriptableRenderContext context, List`1<Camera> cameras)
internal void EndCameraRendering(ScriptableRenderContext context, Camera camera)
internal void OnActiveRenderPipelineTypeChanged()
internal void HandleRenderPipelineChange(RenderPipelineAsset pipelineAsset)
internal void CleanupRenderPipeline()
private string GetCurrentPipelineAssetType()
private void DoRenderLoop_Internal(RenderPipelineAsset pipe, IntPtr loopPtr, List`1<RenderRequest> renderRequests)
internal void PrepareRenderPipeline(RenderPipelineAsset pipelineAsset)
public bool get_pipelineSwitchCompleted()
}
public UnityEngine.Rendering.RenderQueue : Enum {
public int value__
public RenderQueue Background
public RenderQueue Geometry
public RenderQueue AlphaTest
public RenderQueue GeometryLast
public RenderQueue Transparent
public RenderQueue Overlay
}
public UnityEngine.Rendering.RenderQueueRange : ValueType {
private int m_LowerBound
private int m_UpperBound
private int k_MinimumBound
public int minimumBound
private int k_MaximumBound
public int maximumBound
public RenderQueueRange all
public RenderQueueRange opaque
public RenderQueueRange transparent
public int lowerBound
public int upperBound
public void .ctor(int lowerBound, int upperBound)
public RenderQueueRange get_all()
public RenderQueueRange get_opaque()
public RenderQueueRange get_transparent()
public int get_lowerBound()
public void set_lowerBound(int value)
public int get_upperBound()
public void set_upperBound(int value)
public bool Equals(RenderQueueRange other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(RenderQueueRange left, RenderQueueRange right)
public bool op_Inequality(RenderQueueRange left, RenderQueueRange right)
}
public UnityEngine.Rendering.RenderStateBlock : ValueType {
private BlendState m_BlendState
private RasterState m_RasterState
private DepthState m_DepthState
private StencilState m_StencilState
private int m_StencilReference
private RenderStateMask m_Mask
public BlendState blendState
public RasterState rasterState
public DepthState depthState
public StencilState stencilState
public int stencilReference
public RenderStateMask mask
public void .ctor(RenderStateMask mask)
public BlendState get_blendState()
public void set_blendState(BlendState value)
public RasterState get_rasterState()
public void set_rasterState(RasterState value)
public DepthState get_depthState()
public void set_depthState(DepthState value)
public StencilState get_stencilState()
public void set_stencilState(StencilState value)
public int get_stencilReference()
public void set_stencilReference(int value)
public RenderStateMask get_mask()
public void set_mask(RenderStateMask value)
public bool Equals(RenderStateBlock other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(RenderStateBlock left, RenderStateBlock right)
public bool op_Inequality(RenderStateBlock left, RenderStateBlock right)
}
public UnityEngine.Rendering.RenderStateMask : Enum {
public int value__
public RenderStateMask Nothing
public RenderStateMask Blend
public RenderStateMask Raster
public RenderStateMask Depth
public RenderStateMask Stencil
public RenderStateMask Everything
}
public UnityEngine.Rendering.RenderTargetBinding : ValueType {
private RenderTargetIdentifier[] m_ColorRenderTargets
private RenderTargetIdentifier m_DepthRenderTarget
private RenderBufferLoadAction[] m_ColorLoadActions
private RenderBufferStoreAction[] m_ColorStoreActions
private RenderBufferLoadAction m_DepthLoadAction
private RenderBufferStoreAction m_DepthStoreAction
private RenderTargetFlags m_Flags
public RenderTargetIdentifier[] colorRenderTargets
public RenderTargetIdentifier depthRenderTarget
public RenderBufferLoadAction[] colorLoadActions
public RenderBufferStoreAction[] colorStoreActions
public RenderBufferLoadAction depthLoadAction
public RenderBufferStoreAction depthStoreAction
public RenderTargetFlags flags
public RenderTargetIdentifier[] get_colorRenderTargets()
public void set_colorRenderTargets(RenderTargetIdentifier[] value)
public RenderTargetIdentifier get_depthRenderTarget()
public void set_depthRenderTarget(RenderTargetIdentifier value)
public RenderBufferLoadAction[] get_colorLoadActions()
public void set_colorLoadActions(RenderBufferLoadAction[] value)
public RenderBufferStoreAction[] get_colorStoreActions()
public void set_colorStoreActions(RenderBufferStoreAction[] value)
public RenderBufferLoadAction get_depthLoadAction()
public void set_depthLoadAction(RenderBufferLoadAction value)
public RenderBufferStoreAction get_depthStoreAction()
public void set_depthStoreAction(RenderBufferStoreAction value)
public RenderTargetFlags get_flags()
public void set_flags(RenderTargetFlags value)
public void .ctor(RenderTargetIdentifier[] colorRenderTargets, RenderBufferLoadAction[] colorLoadActions, RenderBufferStoreAction[] colorStoreActions, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
public void .ctor(RenderTargetIdentifier colorRenderTarget, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depthRenderTarget, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
public void .ctor(RenderTargetSetup setup)
}
public UnityEngine.Rendering.RenderTargetBlendState : ValueType {
private byte m_WriteMask
private byte m_SourceColorBlendMode
private byte m_DestinationColorBlendMode
private byte m_SourceAlphaBlendMode
private byte m_DestinationAlphaBlendMode
private byte m_ColorBlendOperation
private byte m_AlphaBlendOperation
private byte m_Padding
public RenderTargetBlendState defaultValue
public ColorWriteMask writeMask
public BlendMode sourceColorBlendMode
public BlendMode destinationColorBlendMode
public BlendMode sourceAlphaBlendMode
public BlendMode destinationAlphaBlendMode
public BlendOp colorBlendOperation
public BlendOp alphaBlendOperation
public RenderTargetBlendState get_defaultValue()
public void .ctor(ColorWriteMask writeMask, BlendMode sourceColorBlendMode, BlendMode destinationColorBlendMode, BlendMode sourceAlphaBlendMode, BlendMode destinationAlphaBlendMode, BlendOp colorBlendOperation, BlendOp alphaBlendOperation)
public ColorWriteMask get_writeMask()
public void set_writeMask(ColorWriteMask value)
public BlendMode get_sourceColorBlendMode()
public void set_sourceColorBlendMode(BlendMode value)
public BlendMode get_destinationColorBlendMode()
public void set_destinationColorBlendMode(BlendMode value)
public BlendMode get_sourceAlphaBlendMode()
public void set_sourceAlphaBlendMode(BlendMode value)
public BlendMode get_destinationAlphaBlendMode()
public void set_destinationAlphaBlendMode(BlendMode value)
public BlendOp get_colorBlendOperation()
public void set_colorBlendOperation(BlendOp value)
public BlendOp get_alphaBlendOperation()
public void set_alphaBlendOperation(BlendOp value)
public bool Equals(RenderTargetBlendState other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(RenderTargetBlendState left, RenderTargetBlendState right)
public bool op_Inequality(RenderTargetBlendState left, RenderTargetBlendState right)
}
public UnityEngine.Rendering.RenderTargetFlags : Enum {
public int value__
public RenderTargetFlags None
public RenderTargetFlags ReadOnlyDepth
public RenderTargetFlags ReadOnlyStencil
public RenderTargetFlags ReadOnlyDepthStencil
}
public UnityEngine.Rendering.RenderTargetIdentifier : ValueType {
public int AllDepthSlices
private BuiltinRenderTextureType m_Type
private int m_NameID
private int m_InstanceID
private IntPtr m_BufferPointer
private int m_MipLevel
private CubemapFace m_CubeFace
private int m_DepthSlice
public void .ctor(BuiltinRenderTextureType type)
public void .ctor(BuiltinRenderTextureType type, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(string name)
public void .ctor(string name, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(int nameID)
public void .ctor(int nameID, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(RenderTargetIdentifier renderTargetIdentifier, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(Texture tex)
public void .ctor(Texture tex, int mipLevel, CubemapFace cubeFace, int depthSlice)
public void .ctor(RenderBuffer buf, int mipLevel, CubemapFace cubeFace, int depthSlice)
public RenderTargetIdentifier op_Implicit(BuiltinRenderTextureType type)
public RenderTargetIdentifier op_Implicit(string name)
public RenderTargetIdentifier op_Implicit(int nameID)
public RenderTargetIdentifier op_Implicit(Texture tex)
public RenderTargetIdentifier op_Implicit(RenderBuffer buf)
public string ToString()
public int GetHashCode()
public bool Equals(RenderTargetIdentifier rhs)
public bool Equals(object obj)
public bool op_Equality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs)
public bool op_Inequality(RenderTargetIdentifier lhs, RenderTargetIdentifier rhs)
}
public UnityEngine.Rendering.RenderTextureSubElement : Enum {
public int value__
public RenderTextureSubElement Color
public RenderTextureSubElement Depth
public RenderTextureSubElement Stencil
public RenderTextureSubElement Default
}
public UnityEngine.Rendering.RTClearFlags : Enum {
public int value__
public RTClearFlags None
public RTClearFlags Color
public RTClearFlags Depth
public RTClearFlags Stencil
public RTClearFlags All
public RTClearFlags DepthStencil
public RTClearFlags ColorDepth
public RTClearFlags ColorStencil
}
public UnityEngine.Rendering.ScopedRenderPass : ValueType {
private ScriptableRenderContext m_Context
internal void .ctor(ScriptableRenderContext context)
public void Dispose()
}
public UnityEngine.Rendering.ScopedSubPass : ValueType {
private ScriptableRenderContext m_Context
internal void .ctor(ScriptableRenderContext context)
public void Dispose()
}
public UnityEngine.Rendering.ScriptableCullingParameters : ValueType {
private int m_IsOrthographic
private LODParameters m_LODParameters
private int k_MaximumCullingPlaneCount
public int maximumCullingPlaneCount
internal <m_CullingPlanes>e__FixedBuffer m_CullingPlanes
private int m_CullingPlaneCount
private UInt32 m_CullingMask
private ulong m_SceneMask
private int k_LayerCount
public int layerCount
internal <m_LayerFarCullDistances>e__FixedBuffer m_LayerFarCullDistances
private int m_LayerCull
private Matrix4x4 m_CullingMatrix
private Vector3 m_Origin
private float m_ShadowDistance
private float m_ShadowNearPlaneOffset
private CullingOptions m_CullingOptions
private ReflectionProbeSortingCriteria m_ReflectionProbeSortingCriteria
private CameraProperties m_CameraProperties
private float m_AccurateOcclusionThreshold
private int m_MaximumPortalCullingJobs
private int k_CullingJobCountLowerLimit
private int k_CullingJobCountUpperLimit
private Matrix4x4 m_StereoViewMatrix
private Matrix4x4 m_StereoProjectionMatrix
private float m_StereoSeparationDistance
private int m_maximumVisibleLights
private bool m_ConservativeEnclosingSphere
private int m_NumIterationsEnclosingSphere
public int maximumVisibleLights
public bool conservativeEnclosingSphere
public int numIterationsEnclosingSphere
public int cullingPlaneCount
public bool isOrthographic
public LODParameters lodParameters
public UInt32 cullingMask
public Matrix4x4 cullingMatrix
public Vector3 origin
public float shadowDistance
public float shadowNearPlaneOffset
public CullingOptions cullingOptions
public ReflectionProbeSortingCriteria reflectionProbeSortingCriteria
public CameraProperties cameraProperties
public Matrix4x4 stereoViewMatrix
public Matrix4x4 stereoProjectionMatrix
public float stereoSeparationDistance
public float accurateOcclusionThreshold
public int maximumPortalCullingJobs
public int cullingJobsLowerLimit
public int cullingJobsUpperLimit
public int get_maximumVisibleLights()
public void set_maximumVisibleLights(int value)
public bool get_conservativeEnclosingSphere()
public void set_conservativeEnclosingSphere(bool value)
public int get_numIterationsEnclosingSphere()
public void set_numIterationsEnclosingSphere(int value)
public int get_cullingPlaneCount()
public void set_cullingPlaneCount(int value)
public bool get_isOrthographic()
public void set_isOrthographic(bool value)
public LODParameters get_lodParameters()
public void set_lodParameters(LODParameters value)
public UInt32 get_cullingMask()
public void set_cullingMask(UInt32 value)
public Matrix4x4 get_cullingMatrix()
public void set_cullingMatrix(Matrix4x4 value)
public Vector3 get_origin()
public void set_origin(Vector3 value)
public float get_shadowDistance()
public void set_shadowDistance(float value)
public float get_shadowNearPlaneOffset()
public void set_shadowNearPlaneOffset(float value)
public CullingOptions get_cullingOptions()
public void set_cullingOptions(CullingOptions value)
public ReflectionProbeSortingCriteria get_reflectionProbeSortingCriteria()
public void set_reflectionProbeSortingCriteria(ReflectionProbeSortingCriteria value)
public CameraProperties get_cameraProperties()
public void set_cameraProperties(CameraProperties value)
public Matrix4x4 get_stereoViewMatrix()
public void set_stereoViewMatrix(Matrix4x4 value)
public Matrix4x4 get_stereoProjectionMatrix()
public void set_stereoProjectionMatrix(Matrix4x4 value)
public float get_stereoSeparationDistance()
public void set_stereoSeparationDistance(float value)
public float get_accurateOcclusionThreshold()
public void set_accurateOcclusionThreshold(float value)
public int get_maximumPortalCullingJobs()
public void set_maximumPortalCullingJobs(int value)
public int get_cullingJobsLowerLimit()
public int get_cullingJobsUpperLimit()
public float GetLayerCullingDistance(int layerIndex)
public void SetLayerCullingDistance(int layerIndex, float distance)
public Plane GetCullingPlane(int index)
public void SetCullingPlane(int index, Plane plane)
public bool Equals(ScriptableCullingParameters other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ScriptableCullingParameters left, ScriptableCullingParameters right)
public bool op_Inequality(ScriptableCullingParameters left, ScriptableCullingParameters right)
}
public UnityEngine.Rendering.ScriptableRenderContext : ValueType {
private ShaderTagId kRenderTypeTag
private IntPtr m_Ptr
private void BeginRenderPass_Internal(IntPtr self, int width, int height, int samples, IntPtr colors, int colorCount, int depthAttachmentIndex)
private void BeginSubPass_Internal(IntPtr self, IntPtr colors, int colorCount, IntPtr inputs, int inputCount, bool isDepthReadOnly, bool isStencilReadOnly)
private void EndSubPass_Internal(IntPtr self)
private void EndRenderPass_Internal(IntPtr self)
private void Internal_Cull(ScriptableCullingParameters& parameters, ScriptableRenderContext renderLoop, IntPtr results)
internal void InitializeSortSettings(Camera camera, SortingSettings& sortingSettings)
private void Submit_Internal()
private bool SubmitForRenderPassValidation_Internal()
private void GetCameras_Internal(Type listType, object resultList)
private void DrawRenderers_Internal(IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount)
private void DrawShadows_Internal(IntPtr shadowDrawingSettings)
public void EmitGeometryForCamera(Camera camera)
private void ExecuteCommandBuffer_Internal(CommandBuffer commandBuffer)
private void ExecuteCommandBufferAsync_Internal(CommandBuffer commandBuffer, ComputeQueueType queueType)
private void SetupCameraProperties_Internal(Camera camera, bool stereoSetup, int eye)
private void StereoEndRender_Internal(Camera camera, int eye, bool isFinalPass)
private void StartMultiEye_Internal(Camera camera, int eye)
private void StopMultiEye_Internal(Camera camera)
private void DrawSkybox_Internal(Camera camera)
private void InvokeOnRenderObjectCallback_Internal()
private void DrawGizmos_Internal(Camera camera, GizmoSubset gizmoSubset)
private void DrawWireOverlay_Impl(Camera camera)
private void DrawUIOverlay_Internal(Camera camera)
internal IntPtr Internal_GetPtr()
private RendererList CreateRendererList_Internal(IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount)
private void PrepareRendererListsAsync_Internal(object rendererLists)
private RendererListStatus QueryRendererListStatus_Internal(RendererList handle)
internal void .ctor(IntPtr ptr)
public void BeginRenderPass(int width, int height, int samples, NativeArray`1<AttachmentDescriptor> attachments, int depthAttachmentIndex)
public ScopedRenderPass BeginScopedRenderPass(int width, int height, int samples, NativeArray`1<AttachmentDescriptor> attachments, int depthAttachmentIndex)
public void BeginSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly)
public void BeginSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthStencilReadOnly)
public void BeginSubPass(NativeArray`1<int> colors, bool isDepthReadOnly, bool isStencilReadOnly)
public void BeginSubPass(NativeArray`1<int> colors, bool isDepthStencilReadOnly)
public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthReadOnly, bool isStencilReadOnly)
public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, NativeArray`1<int> inputs, bool isDepthStencilReadOnly)
public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, bool isDepthReadOnly, bool isStencilReadOnly)
public ScopedSubPass BeginScopedSubPass(NativeArray`1<int> colors, bool isDepthStencilReadOnly)
public void EndSubPass()
public void EndRenderPass()
public void Submit()
public bool SubmitForRenderPassValidation()
internal void GetCameras(List`1<Camera> results)
public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings)
public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, RenderStateBlock& stateBlock)
public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, NativeArray`1<ShaderTagId> renderTypes, NativeArray`1<RenderStateBlock> stateBlocks)
public void DrawRenderers(CullingResults cullingResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId tagName, bool isPassTagName, NativeArray`1<ShaderTagId> tagValues, NativeArray`1<RenderStateBlock> stateBlocks)
public void DrawShadows(ShadowDrawingSettings& settings)
public void ExecuteCommandBuffer(CommandBuffer commandBuffer)
public void ExecuteCommandBufferAsync(CommandBuffer commandBuffer, ComputeQueueType queueType)
public void SetupCameraProperties(Camera camera, bool stereoSetup)
public void SetupCameraProperties(Camera camera, bool stereoSetup, int eye)
public void StereoEndRender(Camera camera)
public void StereoEndRender(Camera camera, int eye)
public void StereoEndRender(Camera camera, int eye, bool isFinalPass)
public void StartMultiEye(Camera camera)
public void StartMultiEye(Camera camera, int eye)
public void StopMultiEye(Camera camera)
public void DrawSkybox(Camera camera)
public void InvokeOnRenderObjectCallback()
public void DrawGizmos(Camera camera, GizmoSubset gizmoSubset)
public void DrawWireOverlay(Camera camera)
public void DrawUIOverlay(Camera camera)
public CullingResults Cull(ScriptableCullingParameters& parameters)
internal void Validate()
public bool Equals(ScriptableRenderContext other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ScriptableRenderContext left, ScriptableRenderContext right)
public bool op_Inequality(ScriptableRenderContext left, ScriptableRenderContext right)
public RendererList CreateRendererList(RendererListDesc desc)
public void PrepareRendererListsAsync(List`1<RendererList> rendererLists)
public RendererListStatus QueryRendererListStatus(RendererList rendererList)
private void Internal_Cull_Injected(ScriptableCullingParameters& parameters, ScriptableRenderContext& renderLoop, IntPtr results)
private void Submit_Internal_Injected(ScriptableRenderContext& _unity_self)
private bool SubmitForRenderPassValidation_Internal_Injected(ScriptableRenderContext& _unity_self)
private void GetCameras_Internal_Injected(ScriptableRenderContext& _unity_self, Type listType, object resultList)
private void DrawRenderers_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId& tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount)
private void DrawShadows_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr shadowDrawingSettings)
private void ExecuteCommandBuffer_Internal_Injected(ScriptableRenderContext& _unity_self, CommandBuffer commandBuffer)
private void ExecuteCommandBufferAsync_Internal_Injected(ScriptableRenderContext& _unity_self, CommandBuffer commandBuffer, ComputeQueueType queueType)
private void SetupCameraProperties_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, bool stereoSetup, int eye)
private void StereoEndRender_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, int eye, bool isFinalPass)
private void StartMultiEye_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, int eye)
private void StopMultiEye_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera)
private void DrawSkybox_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera)
private void InvokeOnRenderObjectCallback_Internal_Injected(ScriptableRenderContext& _unity_self)
private void DrawGizmos_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera, GizmoSubset gizmoSubset)
private void DrawWireOverlay_Impl_Injected(ScriptableRenderContext& _unity_self, Camera camera)
private void DrawUIOverlay_Internal_Injected(ScriptableRenderContext& _unity_self, Camera camera)
private void CreateRendererList_Internal_Injected(ScriptableRenderContext& _unity_self, IntPtr cullResults, DrawingSettings& drawingSettings, FilteringSettings& filteringSettings, ShaderTagId& tagName, bool isPassTagName, IntPtr tagValues, IntPtr stateBlocks, int stateCount, RendererList& ret)
private void PrepareRendererListsAsync_Internal_Injected(ScriptableRenderContext& _unity_self, object rendererLists)
private RendererListStatus QueryRendererListStatus_Internal_Injected(ScriptableRenderContext& _unity_self, RendererList& handle)
}
public UnityEngine.Rendering.ShaderConstantType : Enum {
public int value__
public ShaderConstantType Vector
public ShaderConstantType Matrix
public ShaderConstantType Struct
}
public UnityEngine.Rendering.ShaderHardwareTier : Enum {
public int value__
public ShaderHardwareTier Tier1
public ShaderHardwareTier Tier2
public ShaderHardwareTier Tier3
}
public UnityEngine.Rendering.ShaderKeyword : ValueType {
internal string m_Name
internal UInt32 m_Index
internal bool m_IsLocal
internal bool m_IsCompute
internal bool m_IsValid
public string name
public int index
internal UInt32 GetGlobalKeywordCount()
internal UInt32 GetGlobalKeywordIndex(string keyword)
internal UInt32 GetKeywordCount(Shader shader)
internal UInt32 GetKeywordIndex(Shader shader, string keyword)
internal UInt32 GetComputeShaderKeywordCount(ComputeShader shader)
internal UInt32 GetComputeShaderKeywordIndex(ComputeShader shader, string keyword)
internal void CreateGlobalKeyword(string keyword)
internal ShaderKeywordType GetGlobalShaderKeywordType(UInt32 keyword)
public string get_name()
public ShaderKeywordType GetGlobalKeywordType(ShaderKeyword index)
public void .ctor(string keywordName)
public void .ctor(Shader shader, string keywordName)
public void .ctor(ComputeShader shader, string keywordName)
public bool IsKeywordLocal(ShaderKeyword keyword)
public bool IsValid()
public bool IsValid(ComputeShader shader)
public bool IsValid(Shader shader)
public int get_index()
public string ToString()
public ShaderKeywordType GetKeywordType(Shader shader, ShaderKeyword index)
public ShaderKeywordType GetKeywordType(ComputeShader shader, ShaderKeyword index)
public string GetGlobalKeywordName(ShaderKeyword index)
public string GetKeywordName(Shader shader, ShaderKeyword index)
public string GetKeywordName(ComputeShader shader, ShaderKeyword index)
public ShaderKeywordType GetKeywordType()
public string GetKeywordName()
public string GetName()
}
public UnityEngine.Rendering.ShaderKeywordSet : ValueType {
private IntPtr m_KeywordState
private IntPtr m_Shader
private IntPtr m_ComputeShader
private ulong m_StateIndex
private bool IsGlobalKeywordEnabled(ShaderKeywordSet state, UInt32 index)
private bool IsKeywordEnabled(ShaderKeywordSet state, LocalKeywordSpace keywordSpace, UInt32 index)
private bool IsKeywordNameEnabled(ShaderKeywordSet state, string name)
private void EnableGlobalKeyword(ShaderKeywordSet state, UInt32 index)
private void EnableKeywordName(ShaderKeywordSet state, string name)
private void DisableGlobalKeyword(ShaderKeywordSet state, UInt32 index)
private void DisableKeywordName(ShaderKeywordSet state, string name)
private ShaderKeyword[] GetEnabledKeywords(ShaderKeywordSet state)
private void CheckKeywordCompatible(ShaderKeyword keyword)
public bool IsEnabled(ShaderKeyword keyword)
public bool IsEnabled(GlobalKeyword keyword)
public bool IsEnabled(LocalKeyword keyword)
public void Enable(ShaderKeyword keyword)
public void Disable(ShaderKeyword keyword)
public ShaderKeyword[] GetShaderKeywords()
private bool IsGlobalKeywordEnabled_Injected(ShaderKeywordSet& state, UInt32 index)
private bool IsKeywordEnabled_Injected(ShaderKeywordSet& state, LocalKeywordSpace& keywordSpace, UInt32 index)
private bool IsKeywordNameEnabled_Injected(ShaderKeywordSet& state, string name)
private void EnableGlobalKeyword_Injected(ShaderKeywordSet& state, UInt32 index)
private void EnableKeywordName_Injected(ShaderKeywordSet& state, string name)
private void DisableGlobalKeyword_Injected(ShaderKeywordSet& state, UInt32 index)
private void DisableKeywordName_Injected(ShaderKeywordSet& state, string name)
private ShaderKeyword[] GetEnabledKeywords_Injected(ShaderKeywordSet& state)
}
public UnityEngine.Rendering.ShaderKeywordType : Enum {
public int value__
public ShaderKeywordType None
public ShaderKeywordType BuiltinDefault
public ShaderKeywordType BuiltinExtra
public ShaderKeywordType BuiltinAutoStripped
public ShaderKeywordType UserDefined
public ShaderKeywordType Plugin
}
public UnityEngine.Rendering.ShaderParamType : Enum {
public int value__
public ShaderParamType Float
public ShaderParamType Int
public ShaderParamType Bool
public ShaderParamType Half
public ShaderParamType Short
public ShaderParamType UInt
}
public UnityEngine.Rendering.ShaderPropertyFlags : Enum {
public int value__
public ShaderPropertyFlags None
public ShaderPropertyFlags HideInInspector
public ShaderPropertyFlags PerRendererData
public ShaderPropertyFlags NoScaleOffset
public ShaderPropertyFlags Normal
public ShaderPropertyFlags HDR
public ShaderPropertyFlags Gamma
public ShaderPropertyFlags NonModifiableTextureData
public ShaderPropertyFlags MainTexture
public ShaderPropertyFlags MainColor
}
public UnityEngine.Rendering.ShaderPropertyType : Enum {
public int value__
public ShaderPropertyType Color
public ShaderPropertyType Vector
public ShaderPropertyType Float
public ShaderPropertyType Range
public ShaderPropertyType Texture
public ShaderPropertyType Int
}
public UnityEngine.Rendering.ShaderTagId : ValueType {
public ShaderTagId none
private int m_Id
internal int id
public string name
public void .ctor(string name)
internal int get_id()
internal void set_id(int value)
public string get_name()
public bool Equals(object obj)
public bool Equals(ShaderTagId other)
public int GetHashCode()
public bool op_Equality(ShaderTagId tag1, ShaderTagId tag2)
public bool op_Inequality(ShaderTagId tag1, ShaderTagId tag2)
public ShaderTagId op_Explicit(string name)
public string op_Explicit(ShaderTagId tagId)
}
public UnityEngine.Rendering.ShadowCastingMode : Enum {
public int value__
public ShadowCastingMode Off
public ShadowCastingMode On
public ShadowCastingMode TwoSided
public ShadowCastingMode ShadowsOnly
}
public UnityEngine.Rendering.ShadowDrawingSettings : ValueType {
private CullingResults m_CullingResults
private int m_LightIndex
private int m_UseRenderingLayerMaskTest
private ShadowSplitData m_SplitData
private ShadowObjectsFilter m_ObjectsFilter
public CullingResults cullingResults
public int lightIndex
public bool useRenderingLayerMaskTest
public ShadowSplitData splitData
public ShadowObjectsFilter objectsFilter
public CullingResults get_cullingResults()
public void set_cullingResults(CullingResults value)
public int get_lightIndex()
public void set_lightIndex(int value)
public bool get_useRenderingLayerMaskTest()
public void set_useRenderingLayerMaskTest(bool value)
public ShadowSplitData get_splitData()
public void set_splitData(ShadowSplitData value)
public ShadowObjectsFilter get_objectsFilter()
public void set_objectsFilter(ShadowObjectsFilter value)
public void .ctor(CullingResults cullingResults, int lightIndex)
public bool Equals(ShadowDrawingSettings other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ShadowDrawingSettings left, ShadowDrawingSettings right)
public bool op_Inequality(ShadowDrawingSettings left, ShadowDrawingSettings right)
}
public UnityEngine.Rendering.ShadowMapPass : Enum {
public int value__
public ShadowMapPass PointlightPositiveX
public ShadowMapPass PointlightNegativeX
public ShadowMapPass PointlightPositiveY
public ShadowMapPass PointlightNegativeY
public ShadowMapPass PointlightPositiveZ
public ShadowMapPass PointlightNegativeZ
public ShadowMapPass DirectionalCascade0
public ShadowMapPass DirectionalCascade1
public ShadowMapPass DirectionalCascade2
public ShadowMapPass DirectionalCascade3
public ShadowMapPass Spotlight
public ShadowMapPass Pointlight
public ShadowMapPass Directional
public ShadowMapPass All
}
public UnityEngine.Rendering.ShadowSamplingMode : Enum {
public int value__
public ShadowSamplingMode CompareDepths
public ShadowSamplingMode RawDepth
public ShadowSamplingMode None
}
public UnityEngine.Rendering.ShadowSplitData : ValueType {
private int k_MaximumCullingPlaneCount
public int maximumCullingPlaneCount
private int m_CullingPlaneCount
internal <m_CullingPlanes>e__FixedBuffer m_CullingPlanes
private Vector4 m_CullingSphere
private float m_ShadowCascadeBlendCullingFactor
private float m_CullingNearPlane
public int cullingPlaneCount
public Vector4 cullingSphere
public float shadowCascadeBlendCullingFactor
public int get_cullingPlaneCount()
public void set_cullingPlaneCount(int value)
public Vector4 get_cullingSphere()
public void set_cullingSphere(Vector4 value)
public float get_shadowCascadeBlendCullingFactor()
public void set_shadowCascadeBlendCullingFactor(float value)
public Plane GetCullingPlane(int index)
public void SetCullingPlane(int index, Plane plane)
public bool Equals(ShadowSplitData other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(ShadowSplitData left, ShadowSplitData right)
public bool op_Inequality(ShadowSplitData left, ShadowSplitData right)
}
public UnityEngine.Rendering.SinglePassStereoMode : Enum {
public int value__
public SinglePassStereoMode None
public SinglePassStereoMode SideBySide
public SinglePassStereoMode Instancing
public SinglePassStereoMode Multiview
}
public UnityEngine.Rendering.SortingCriteria : Enum {
public int value__
public SortingCriteria None
public SortingCriteria SortingLayer
public SortingCriteria RenderQueue
public SortingCriteria BackToFront
public SortingCriteria QuantizedFrontToBack
public SortingCriteria OptimizeStateChanges
public SortingCriteria CanvasOrder
public SortingCriteria RendererPriority
public SortingCriteria CommonOpaque
public SortingCriteria CommonTransparent
}
public UnityEngine.Rendering.SortingGroup : Behaviour {
internal int invalidSortingGroupID
public string sortingLayerName
public int sortingLayerID
public int sortingOrder
internal int sortingGroupID
internal int sortingGroupOrder
internal int index
internal int get_invalidSortingGroupID()
public void UpdateAllSortingGroups()
internal SortingGroup GetSortingGroupByIndex(int index)
public string get_sortingLayerName()
public void set_sortingLayerName(string value)
public int get_sortingLayerID()
public void set_sortingLayerID(int value)
public int get_sortingOrder()
public void set_sortingOrder(int value)
internal int get_sortingGroupID()
internal int get_sortingGroupOrder()
internal int get_index()
}
public UnityEngine.Rendering.SortingLayerRange : ValueType {
private short m_LowerBound
private short m_UpperBound
public short lowerBound
public short upperBound
public SortingLayerRange all
public void .ctor(short lowerBound, short upperBound)
public short get_lowerBound()
public void set_lowerBound(short value)
public short get_upperBound()
public void set_upperBound(short value)
public SortingLayerRange get_all()
public bool Equals(SortingLayerRange other)
public bool Equals(object obj)
public bool op_Inequality(SortingLayerRange lhs, SortingLayerRange rhs)
public bool op_Equality(SortingLayerRange lhs, SortingLayerRange rhs)
public int GetHashCode()
}
public UnityEngine.Rendering.SortingSettings : ValueType {
private Matrix4x4 m_WorldToCameraMatrix
private Vector3 m_CameraPosition
private Vector3 m_CustomAxis
private SortingCriteria m_Criteria
private DistanceMetric m_DistanceMetric
private Matrix4x4 m_PreviousVPMatrix
private Matrix4x4 m_NonJitteredVPMatrix
public Matrix4x4 worldToCameraMatrix
public Vector3 cameraPosition
public Vector3 customAxis
public SortingCriteria criteria
public DistanceMetric distanceMetric
public void .ctor(Camera camera)
public Matrix4x4 get_worldToCameraMatrix()
public void set_worldToCameraMatrix(Matrix4x4 value)
public Vector3 get_cameraPosition()
public void set_cameraPosition(Vector3 value)
public Vector3 get_customAxis()
public void set_customAxis(Vector3 value)
public SortingCriteria get_criteria()
public void set_criteria(SortingCriteria value)
public DistanceMetric get_distanceMetric()
public void set_distanceMetric(DistanceMetric value)
public bool Equals(SortingSettings other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(SortingSettings left, SortingSettings right)
public bool op_Inequality(SortingSettings left, SortingSettings right)
}
public UnityEngine.Rendering.SphericalHarmonicsL2 : ValueType {
private float shr0
private float shr1
private float shr2
private float shr3
private float shr4
private float shr5
private float shr6
private float shr7
private float shr8
private float shg0
private float shg1
private float shg2
private float shg3
private float shg4
private float shg5
private float shg6
private float shg7
private float shg8
private float shb0
private float shb1
private float shb2
private float shb3
private float shb4
private float shb5
private float shb6
private float shb7
private float shb8
public float Item
public void Clear()
private void SetZero()
public void AddAmbientLight(Color color)
public void AddDirectionalLight(Vector3 direction, Color color, float intensity)
private void AddDirectionalLightInternal(SphericalHarmonicsL2& sh, Vector3 direction, Color color)
public void Evaluate(Vector3[] directions, Color[] results)
private void EvaluateInternal(SphericalHarmonicsL2& sh, Vector3[] directions, Color[] results)
public float get_Item(int rgb, int coefficient)
public void set_Item(int rgb, int coefficient, float value)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(SphericalHarmonicsL2 other)
public SphericalHarmonicsL2 op_Multiply(SphericalHarmonicsL2 lhs, float rhs)
public SphericalHarmonicsL2 op_Multiply(float lhs, SphericalHarmonicsL2 rhs)
public SphericalHarmonicsL2 op_Addition(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
public bool op_Equality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
public bool op_Inequality(SphericalHarmonicsL2 lhs, SphericalHarmonicsL2 rhs)
private void SetZero_Injected(SphericalHarmonicsL2& _unity_self)
private void AddAmbientLight_Injected(SphericalHarmonicsL2& _unity_self, Color& color)
private void AddDirectionalLightInternal_Injected(SphericalHarmonicsL2& sh, Vector3& direction, Color& color)
}
public UnityEngine.Rendering.SplashScreen : object {
public bool isFinished
public bool get_isFinished()
private void CancelSplashScreen()
private void BeginSplashScreenFade()
public void Begin()
public void Stop(StopBehavior stopBehavior)
public void Draw()
internal void SetTime(float time)
}
public UnityEngine.Rendering.StencilOp : Enum {
public int value__
public StencilOp Keep
public StencilOp Zero
public StencilOp Replace
public StencilOp IncrementSaturate
public StencilOp DecrementSaturate
public StencilOp Invert
public StencilOp IncrementWrap
public StencilOp DecrementWrap
}
public UnityEngine.Rendering.StencilState : ValueType {
private byte m_Enabled
private byte m_ReadMask
private byte m_WriteMask
private byte m_Padding
private byte m_CompareFunctionFront
private byte m_PassOperationFront
private byte m_FailOperationFront
private byte m_ZFailOperationFront
private byte m_CompareFunctionBack
private byte m_PassOperationBack
private byte m_FailOperationBack
private byte m_ZFailOperationBack
public StencilState defaultValue
public bool enabled
public byte readMask
public byte writeMask
public CompareFunction compareFunctionFront
public StencilOp passOperationFront
public StencilOp failOperationFront
public StencilOp zFailOperationFront
public CompareFunction compareFunctionBack
public StencilOp passOperationBack
public StencilOp failOperationBack
public StencilOp zFailOperationBack
public StencilState get_defaultValue()
public void .ctor(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunction, StencilOp passOperation, StencilOp failOperation, StencilOp zFailOperation)
public void .ctor(bool enabled, byte readMask, byte writeMask, CompareFunction compareFunctionFront, StencilOp passOperationFront, StencilOp failOperationFront, StencilOp zFailOperationFront, CompareFunction compareFunctionBack, StencilOp passOperationBack, StencilOp failOperationBack, StencilOp zFailOperationBack)
public bool get_enabled()
public void set_enabled(bool value)
public byte get_readMask()
public void set_readMask(byte value)
public byte get_writeMask()
public void set_writeMask(byte value)
public void SetCompareFunction(CompareFunction value)
public void SetPassOperation(StencilOp value)
public void SetFailOperation(StencilOp value)
public void SetZFailOperation(StencilOp value)
public CompareFunction get_compareFunctionFront()
public void set_compareFunctionFront(CompareFunction value)
public StencilOp get_passOperationFront()
public void set_passOperationFront(StencilOp value)
public StencilOp get_failOperationFront()
public void set_failOperationFront(StencilOp value)
public StencilOp get_zFailOperationFront()
public void set_zFailOperationFront(StencilOp value)
public CompareFunction get_compareFunctionBack()
public void set_compareFunctionBack(CompareFunction value)
public StencilOp get_passOperationBack()
public void set_passOperationBack(StencilOp value)
public StencilOp get_failOperationBack()
public void set_failOperationBack(StencilOp value)
public StencilOp get_zFailOperationBack()
public void set_zFailOperationBack(StencilOp value)
public bool Equals(StencilState other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(StencilState left, StencilState right)
public bool op_Inequality(StencilState left, StencilState right)
}
public UnityEngine.Rendering.SubMeshDescriptor : ValueType {
private Bounds <bounds>k__BackingField
private MeshTopology <topology>k__BackingField
private int <indexStart>k__BackingField
private int <indexCount>k__BackingField
private int <baseVertex>k__BackingField
private int <firstVertex>k__BackingField
private int <vertexCount>k__BackingField
public Bounds bounds
public MeshTopology topology
public int indexStart
public int indexCount
public int baseVertex
public int firstVertex
public int vertexCount
public void .ctor(int indexStart, int indexCount, MeshTopology topology)
public Bounds get_bounds()
public void set_bounds(Bounds value)
public MeshTopology get_topology()
public void set_topology(MeshTopology value)
public int get_indexStart()
public void set_indexStart(int value)
public int get_indexCount()
public void set_indexCount(int value)
public int get_baseVertex()
public void set_baseVertex(int value)
public int get_firstVertex()
public void set_firstVertex(int value)
public int get_vertexCount()
public void set_vertexCount(int value)
public string ToString()
}
public UnityEngine.Rendering.SupportedRenderingFeatures : object {
private SupportedRenderingFeatures s_Active
private ReflectionProbeModes <reflectionProbeModes>k__BackingField
private LightmapMixedBakeModes <defaultMixedLightingModes>k__BackingField
private LightmapMixedBakeModes <mixedLightingModes>k__BackingField
private LightmapBakeType <lightmapBakeTypes>k__BackingField
private LightmapsMode <lightmapsModes>k__BackingField
private bool <enlightenLightmapper>k__BackingField
private bool <enlighten>k__BackingField
private bool <lightProbeProxyVolumes>k__BackingField
private bool <motionVectors>k__BackingField
private bool <receiveShadows>k__BackingField
private bool <reflectionProbes>k__BackingField
private bool <reflectionProbesBlendDistance>k__BackingField
private bool <rendererPriority>k__BackingField
private bool <rendersUIOverlay>k__BackingField
private bool <overridesEnvironmentLighting>k__BackingField
private bool <overridesFog>k__BackingField
private bool <overridesRealtimeReflectionProbes>k__BackingField
private bool <overridesOtherLightingSettings>k__BackingField
private bool <editableMaterialRenderQueue>k__BackingField
private bool <overridesLODBias>k__BackingField
private bool <overridesMaximumLODLevel>k__BackingField
private bool <rendererProbes>k__BackingField
private bool <particleSystemInstancing>k__BackingField
private bool <autoAmbientProbeBaking>k__BackingField
private bool <autoDefaultReflectionProbeBaking>k__BackingField
private bool <overridesShadowmask>k__BackingField
private string <overrideShadowmaskMessage>k__BackingField
public SupportedRenderingFeatures active
public ReflectionProbeModes reflectionProbeModes
public LightmapMixedBakeModes defaultMixedLightingModes
public LightmapMixedBakeModes mixedLightingModes
public LightmapBakeType lightmapBakeTypes
public LightmapsMode lightmapsModes
public bool enlightenLightmapper
public bool enlighten
public bool lightProbeProxyVolumes
public bool motionVectors
public bool receiveShadows
public bool reflectionProbes
public bool reflectionProbesBlendDistance
public bool rendererPriority
public bool rendersUIOverlay
public bool overridesEnvironmentLighting
public bool overridesFog
public bool overridesRealtimeReflectionProbes
public bool overridesOtherLightingSettings
public bool editableMaterialRenderQueue
public bool overridesLODBias
public bool overridesMaximumLODLevel
public bool rendererProbes
public bool particleSystemInstancing
public bool autoAmbientProbeBaking
public bool autoDefaultReflectionProbeBaking
public bool overridesShadowmask
public string overrideShadowmaskMessage
public string shadowmaskMessage
public bool terrainDetailUnsupported
public SupportedRenderingFeatures get_active()
public void set_active(SupportedRenderingFeatures value)
public ReflectionProbeModes get_reflectionProbeModes()
public void set_reflectionProbeModes(ReflectionProbeModes value)
public LightmapMixedBakeModes get_defaultMixedLightingModes()
public void set_defaultMixedLightingModes(LightmapMixedBakeModes value)
public LightmapMixedBakeModes get_mixedLightingModes()
public void set_mixedLightingModes(LightmapMixedBakeModes value)
public LightmapBakeType get_lightmapBakeTypes()
public void set_lightmapBakeTypes(LightmapBakeType value)
public LightmapsMode get_lightmapsModes()
public void set_lightmapsModes(LightmapsMode value)
public bool get_enlightenLightmapper()
public void set_enlightenLightmapper(bool value)
public bool get_enlighten()
public void set_enlighten(bool value)
public bool get_lightProbeProxyVolumes()
public void set_lightProbeProxyVolumes(bool value)
public bool get_motionVectors()
public void set_motionVectors(bool value)
public bool get_receiveShadows()
public void set_receiveShadows(bool value)
public bool get_reflectionProbes()
public void set_reflectionProbes(bool value)
public bool get_reflectionProbesBlendDistance()
public void set_reflectionProbesBlendDistance(bool value)
public bool get_rendererPriority()
public void set_rendererPriority(bool value)
public bool get_rendersUIOverlay()
public void set_rendersUIOverlay(bool value)
public bool get_overridesEnvironmentLighting()
public void set_overridesEnvironmentLighting(bool value)
public bool get_overridesFog()
public void set_overridesFog(bool value)
public bool get_overridesRealtimeReflectionProbes()
public void set_overridesRealtimeReflectionProbes(bool value)
public bool get_overridesOtherLightingSettings()
public void set_overridesOtherLightingSettings(bool value)
public bool get_editableMaterialRenderQueue()
public void set_editableMaterialRenderQueue(bool value)
public bool get_overridesLODBias()
public void set_overridesLODBias(bool value)
public bool get_overridesMaximumLODLevel()
public void set_overridesMaximumLODLevel(bool value)
public bool get_rendererProbes()
public void set_rendererProbes(bool value)
public bool get_particleSystemInstancing()
public void set_particleSystemInstancing(bool value)
public bool get_autoAmbientProbeBaking()
public void set_autoAmbientProbeBaking(bool value)
public bool get_autoDefaultReflectionProbeBaking()
public void set_autoDefaultReflectionProbeBaking(bool value)
public bool get_overridesShadowmask()
public void set_overridesShadowmask(bool value)
public string get_overrideShadowmaskMessage()
public void set_overrideShadowmaskMessage(string value)
public string get_shadowmaskMessage()
internal MixedLightingMode FallbackMixedLightingMode()
internal void FallbackMixedLightingModeByRef(IntPtr fallbackModePtr)
internal bool IsMixedLightingModeSupported(MixedLightingMode mixedMode)
internal void IsMixedLightingModeSupportedByRef(MixedLightingMode mixedMode, IntPtr isSupportedPtr)
internal bool IsLightmapBakeTypeSupported(LightmapBakeType bakeType)
internal void IsLightmapBakeTypeSupportedByRef(LightmapBakeType bakeType, IntPtr isSupportedPtr)
internal bool IsLightmapsModeSupported(LightmapsMode mode)
internal void IsLightmapsModeSupportedByRef(LightmapsMode mode, IntPtr isSupportedPtr)
internal bool IsLightmapperSupported(int lightmapper)
internal void IsLightmapperSupportedByRef(int lightmapper, IntPtr isSupportedPtr)
internal void IsUIOverlayRenderedBySRP(IntPtr isSupportedPtr)
internal void IsAutoAmbientProbeBakingSupported(IntPtr isSupportedPtr)
internal void IsAutoDefaultReflectionProbeBakingSupported(IntPtr isSupportedPtr)
internal int FallbackLightmapper()
internal void FallbackLightmapperByRef(IntPtr lightmapperPtr)
public bool get_terrainDetailUnsupported()
public void set_terrainDetailUnsupported(bool value)
}
public UnityEngine.Rendering.SynchronisationStage : Enum {
public int value__
public SynchronisationStage VertexProcessing
public SynchronisationStage PixelProcessing
}
public UnityEngine.Rendering.SynchronisationStageFlags : Enum {
public int value__
public SynchronisationStageFlags VertexProcessing
public SynchronisationStageFlags PixelProcessing
public SynchronisationStageFlags ComputeProcessing
public SynchronisationStageFlags AllGPUOperations
}
public UnityEngine.Rendering.TextureDimension : Enum {
public int value__
public TextureDimension Unknown
public TextureDimension None
public TextureDimension Any
public TextureDimension Tex2D
public TextureDimension Tex3D
public TextureDimension Cube
public TextureDimension Tex2DArray
public TextureDimension CubeArray
}
public UnityEngine.Rendering.VertexAttribute : Enum {
public int value__
public VertexAttribute Position
public VertexAttribute Normal
public VertexAttribute Tangent
public VertexAttribute Color
public VertexAttribute TexCoord0
public VertexAttribute TexCoord1
public VertexAttribute TexCoord2
public VertexAttribute TexCoord3
public VertexAttribute TexCoord4
public VertexAttribute TexCoord5
public VertexAttribute TexCoord6
public VertexAttribute TexCoord7
public VertexAttribute BlendWeight
public VertexAttribute BlendIndices
}
public UnityEngine.Rendering.VertexAttributeDescriptor : ValueType {
private VertexAttribute <attribute>k__BackingField
private VertexAttributeFormat <format>k__BackingField
private int <dimension>k__BackingField
private int <stream>k__BackingField
public VertexAttribute attribute
public VertexAttributeFormat format
public int dimension
public int stream
public VertexAttribute get_attribute()
public void set_attribute(VertexAttribute value)
public VertexAttributeFormat get_format()
public void set_format(VertexAttributeFormat value)
public int get_dimension()
public void set_dimension(int value)
public int get_stream()
public void set_stream(int value)
public void .ctor(VertexAttribute attribute, VertexAttributeFormat format, int dimension, int stream)
public string ToString()
public int GetHashCode()
public bool Equals(object other)
public bool Equals(VertexAttributeDescriptor other)
public bool op_Equality(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs)
public bool op_Inequality(VertexAttributeDescriptor lhs, VertexAttributeDescriptor rhs)
}
public UnityEngine.Rendering.VertexAttributeFormat : Enum {
public int value__
public VertexAttributeFormat Float32
public VertexAttributeFormat Float16
public VertexAttributeFormat UNorm8
public VertexAttributeFormat SNorm8
public VertexAttributeFormat UNorm16
public VertexAttributeFormat SNorm16
public VertexAttributeFormat UInt8
public VertexAttributeFormat SInt8
public VertexAttributeFormat UInt16
public VertexAttributeFormat SInt16
public VertexAttributeFormat UInt32
public VertexAttributeFormat SInt32
}
public UnityEngine.Rendering.VideoShadersIncludeMode : Enum {
public int value__
public VideoShadersIncludeMode Never
public VideoShadersIncludeMode Referenced
public VideoShadersIncludeMode Always
}
public UnityEngine.Rendering.VisibleLight : ValueType {
private LightType m_LightType
private Color m_FinalColor
private Rect m_ScreenRect
private Matrix4x4 m_LocalToWorldMatrix
private float m_Range
private float m_SpotAngle
private int m_InstanceId
private VisibleLightFlags m_Flags
public Light light
public LightType lightType
public Color finalColor
public Rect screenRect
public Matrix4x4 localToWorldMatrix
public float range
public float spotAngle
public bool intersectsNearPlane
public bool intersectsFarPlane
public Light get_light()
public LightType get_lightType()
public void set_lightType(LightType value)
public Color get_finalColor()
public void set_finalColor(Color value)
public Rect get_screenRect()
public void set_screenRect(Rect value)
public Matrix4x4 get_localToWorldMatrix()
public void set_localToWorldMatrix(Matrix4x4 value)
public float get_range()
public void set_range(float value)
public float get_spotAngle()
public void set_spotAngle(float value)
public bool get_intersectsNearPlane()
public void set_intersectsNearPlane(bool value)
public bool get_intersectsFarPlane()
public void set_intersectsFarPlane(bool value)
public bool Equals(VisibleLight other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(VisibleLight left, VisibleLight right)
public bool op_Inequality(VisibleLight left, VisibleLight right)
}
internal UnityEngine.Rendering.VisibleLightFlags : Enum {
public int value__
public VisibleLightFlags IntersectsNearPlane
public VisibleLightFlags IntersectsFarPlane
}
public UnityEngine.Rendering.VisibleReflectionProbe : ValueType {
private Bounds m_Bounds
private Matrix4x4 m_LocalToWorldMatrix
private Vector4 m_HdrData
private Vector3 m_Center
private float m_BlendDistance
private int m_Importance
private int m_BoxProjection
private int m_InstanceId
private int m_TextureId
public Texture texture
public ReflectionProbe reflectionProbe
public Bounds bounds
public Matrix4x4 localToWorldMatrix
public Vector4 hdrData
public Vector3 center
public float blendDistance
public int importance
public bool isBoxProjection
public Texture get_texture()
public ReflectionProbe get_reflectionProbe()
public Bounds get_bounds()
public void set_bounds(Bounds value)
public Matrix4x4 get_localToWorldMatrix()
public void set_localToWorldMatrix(Matrix4x4 value)
public Vector4 get_hdrData()
public void set_hdrData(Vector4 value)
public Vector3 get_center()
public void set_center(Vector3 value)
public float get_blendDistance()
public void set_blendDistance(float value)
public int get_importance()
public void set_importance(int value)
public bool get_isBoxProjection()
public void set_isBoxProjection(bool value)
public bool Equals(VisibleReflectionProbe other)
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(VisibleReflectionProbe left, VisibleReflectionProbe right)
public bool op_Inequality(VisibleReflectionProbe left, VisibleReflectionProbe right)
}
public UnityEngine.RenderingPath : Enum {
public int value__
public RenderingPath UsePlayerSettings
public RenderingPath VertexLit
public RenderingPath Forward
public RenderingPath DeferredLighting
public RenderingPath DeferredShading
}
internal UnityEngine.RenderInstancedDataLayout : ValueType {
private int <size>k__BackingField
private int <offsetObjectToWorld>k__BackingField
private int <offsetPrevObjectToWorld>k__BackingField
private int <offsetRenderingLayerMask>k__BackingField
public int size
public int offsetObjectToWorld
public int offsetPrevObjectToWorld
public int offsetRenderingLayerMask
public void .ctor(Type t)
public int get_size()
public int get_offsetObjectToWorld()
public int get_offsetPrevObjectToWorld()
public int get_offsetRenderingLayerMask()
}
public UnityEngine.RenderParams : ValueType {
private int <layer>k__BackingField
private UInt32 <renderingLayerMask>k__BackingField
private int <rendererPriority>k__BackingField
private Bounds <worldBounds>k__BackingField
private Camera <camera>k__BackingField
private MotionVectorGenerationMode <motionVectorMode>k__BackingField
private ReflectionProbeUsage <reflectionProbeUsage>k__BackingField
private Material <material>k__BackingField
private MaterialPropertyBlock <matProps>k__BackingField
private ShadowCastingMode <shadowCastingMode>k__BackingField
private bool <receiveShadows>k__BackingField
private LightProbeUsage <lightProbeUsage>k__BackingField
private LightProbeProxyVolume <lightProbeProxyVolume>k__BackingField
public int layer
public UInt32 renderingLayerMask
public int rendererPriority
public Bounds worldBounds
public Camera camera
public MotionVectorGenerationMode motionVectorMode
public ReflectionProbeUsage reflectionProbeUsage
public Material material
public MaterialPropertyBlock matProps
public ShadowCastingMode shadowCastingMode
public bool receiveShadows
public LightProbeUsage lightProbeUsage
public LightProbeProxyVolume lightProbeProxyVolume
public void .ctor(Material mat)
public int get_layer()
public void set_layer(int value)
public UInt32 get_renderingLayerMask()
public void set_renderingLayerMask(UInt32 value)
public int get_rendererPriority()
public void set_rendererPriority(int value)
public Bounds get_worldBounds()
public void set_worldBounds(Bounds value)
public Camera get_camera()
public void set_camera(Camera value)
public MotionVectorGenerationMode get_motionVectorMode()
public void set_motionVectorMode(MotionVectorGenerationMode value)
public ReflectionProbeUsage get_reflectionProbeUsage()
public void set_reflectionProbeUsage(ReflectionProbeUsage value)
public Material get_material()
public void set_material(Material value)
public MaterialPropertyBlock get_matProps()
public void set_matProps(MaterialPropertyBlock value)
public ShadowCastingMode get_shadowCastingMode()
public void set_shadowCastingMode(ShadowCastingMode value)
public bool get_receiveShadows()
public void set_receiveShadows(bool value)
public LightProbeUsage get_lightProbeUsage()
public void set_lightProbeUsage(LightProbeUsage value)
public LightProbeProxyVolume get_lightProbeProxyVolume()
public void set_lightProbeProxyVolume(LightProbeProxyVolume value)
}
public UnityEngine.RenderSettings : Object {
public float ambientSkyboxAmount
public bool fog
public float fogStartDistance
public float fogEndDistance
public FogMode fogMode
public Color fogColor
public float fogDensity
public AmbientMode ambientMode
public Color ambientSkyColor
public Color ambientEquatorColor
public Color ambientGroundColor
public float ambientIntensity
public Color ambientLight
public Color subtractiveShadowColor
public Material skybox
public Light sun
public SphericalHarmonicsL2 ambientProbe
public Texture customReflection
public float reflectionIntensity
public int reflectionBounces
internal Cubemap defaultReflection
public DefaultReflectionMode defaultReflectionMode
public int defaultReflectionResolution
public float haloStrength
public float flareStrength
public float flareFadeSpeed
public float get_ambientSkyboxAmount()
public void set_ambientSkyboxAmount(float value)
public bool get_fog()
public void set_fog(bool value)
public float get_fogStartDistance()
public void set_fogStartDistance(float value)
public float get_fogEndDistance()
public void set_fogEndDistance(float value)
public FogMode get_fogMode()
public void set_fogMode(FogMode value)
public Color get_fogColor()
public void set_fogColor(Color value)
public float get_fogDensity()
public void set_fogDensity(float value)
public AmbientMode get_ambientMode()
public void set_ambientMode(AmbientMode value)
public Color get_ambientSkyColor()
public void set_ambientSkyColor(Color value)
public Color get_ambientEquatorColor()
public void set_ambientEquatorColor(Color value)
public Color get_ambientGroundColor()
public void set_ambientGroundColor(Color value)
public float get_ambientIntensity()
public void set_ambientIntensity(float value)
public Color get_ambientLight()
public void set_ambientLight(Color value)
public Color get_subtractiveShadowColor()
public void set_subtractiveShadowColor(Color value)
public Material get_skybox()
public void set_skybox(Material value)
public Light get_sun()
public void set_sun(Light value)
public SphericalHarmonicsL2 get_ambientProbe()
public void set_ambientProbe(SphericalHarmonicsL2 value)
public Texture get_customReflection()
public void set_customReflection(Texture value)
public float get_reflectionIntensity()
public void set_reflectionIntensity(float value)
public int get_reflectionBounces()
public void set_reflectionBounces(int value)
internal Cubemap get_defaultReflection()
public DefaultReflectionMode get_defaultReflectionMode()
public void set_defaultReflectionMode(DefaultReflectionMode value)
public int get_defaultReflectionResolution()
public void set_defaultReflectionResolution(int value)
public float get_haloStrength()
public void set_haloStrength(float value)
public float get_flareStrength()
public void set_flareStrength(float value)
public float get_flareFadeSpeed()
public void set_flareFadeSpeed(float value)
internal Object GetRenderSettings()
internal void Reset()
private void get_fogColor_Injected(Color& ret)
private void set_fogColor_Injected(Color& value)
private void get_ambientSkyColor_Injected(Color& ret)
private void set_ambientSkyColor_Injected(Color& value)
private void get_ambientEquatorColor_Injected(Color& ret)
private void set_ambientEquatorColor_Injected(Color& value)
private void get_ambientGroundColor_Injected(Color& ret)
private void set_ambientGroundColor_Injected(Color& value)
private void get_ambientLight_Injected(Color& ret)
private void set_ambientLight_Injected(Color& value)
private void get_subtractiveShadowColor_Injected(Color& ret)
private void set_subtractiveShadowColor_Injected(Color& value)
private void get_ambientProbe_Injected(SphericalHarmonicsL2& ret)
private void set_ambientProbe_Injected(SphericalHarmonicsL2& value)
}
public UnityEngine.RenderTargetSetup : ValueType {
public RenderBuffer[] color
public RenderBuffer depth
public int mipLevel
public CubemapFace cubemapFace
public int depthSlice
public RenderBufferLoadAction[] colorLoad
public RenderBufferStoreAction[] colorStore
public RenderBufferLoadAction depthLoad
public RenderBufferStoreAction depthStore
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face, RenderBufferLoadAction[] colorLoad, RenderBufferStoreAction[] colorStore, RenderBufferLoadAction depthLoad, RenderBufferStoreAction depthStore)
internal RenderBufferLoadAction[] LoadActions(RenderBuffer[] buf)
internal RenderBufferStoreAction[] StoreActions(RenderBuffer[] buf)
public void .ctor(RenderBuffer color, RenderBuffer depth)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face)
public void .ctor(RenderBuffer color, RenderBuffer depth, int mipLevel, CubemapFace face, int depthSlice)
public void .ctor(RenderBuffer[] color, RenderBuffer depth)
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mipLevel)
public void .ctor(RenderBuffer[] color, RenderBuffer depth, int mip, CubemapFace face)
}
public UnityEngine.RenderTexture : Texture {
public int width
public int height
public TextureDimension dimension
public GraphicsFormat graphicsFormat
public bool useMipMap
public bool sRGB
public VRTextureUsage vrUsage
public RenderTextureMemoryless memorylessMode
public RenderTextureFormat format
public GraphicsFormat stencilFormat
public GraphicsFormat depthStencilFormat
public bool autoGenerateMips
public int volumeDepth
public int antiAliasing
public bool bindTextureMS
public bool enableRandomWrite
public bool useDynamicScale
public bool isPowerOfTwo
public RenderTexture active
public RenderBuffer colorBuffer
public RenderBuffer depthBuffer
public int depth
public RenderTextureDescriptor descriptor
public bool isCubemap
public bool isVolume
public bool enabled
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public GraphicsFormat get_graphicsFormat()
public void set_graphicsFormat(GraphicsFormat value)
public bool get_useMipMap()
public void set_useMipMap(bool value)
public bool get_sRGB()
public VRTextureUsage get_vrUsage()
public void set_vrUsage(VRTextureUsage value)
public RenderTextureMemoryless get_memorylessMode()
public void set_memorylessMode(RenderTextureMemoryless value)
public RenderTextureFormat get_format()
public void set_format(RenderTextureFormat value)
public GraphicsFormat get_stencilFormat()
public void set_stencilFormat(GraphicsFormat value)
public GraphicsFormat get_depthStencilFormat()
public void set_depthStencilFormat(GraphicsFormat value)
public bool get_autoGenerateMips()
public void set_autoGenerateMips(bool value)
public int get_volumeDepth()
public void set_volumeDepth(int value)
public int get_antiAliasing()
public void set_antiAliasing(int value)
public bool get_bindTextureMS()
public void set_bindTextureMS(bool value)
public bool get_enableRandomWrite()
public void set_enableRandomWrite(bool value)
public bool get_useDynamicScale()
public void set_useDynamicScale(bool value)
private bool GetIsPowerOfTwo()
public bool get_isPowerOfTwo()
public void set_isPowerOfTwo(bool value)
private RenderTexture GetActive()
private void SetActive(RenderTexture rt)
public RenderTexture get_active()
public void set_active(RenderTexture value)
private RenderBuffer GetColorBuffer()
private RenderBuffer GetDepthBuffer()
private void SetMipMapCount(int count)
private void SetShadowSamplingMode(ShadowSamplingMode samplingMode)
public RenderBuffer get_colorBuffer()
public RenderBuffer get_depthBuffer()
public IntPtr GetNativeDepthBufferPtr()
public void DiscardContents(bool discardColor, bool discardDepth)
public void MarkRestoreExpected()
public void DiscardContents()
private void ResolveAA()
private void ResolveAATo(RenderTexture rt)
public void ResolveAntiAliasedSurface()
public void ResolveAntiAliasedSurface(RenderTexture target)
public void SetGlobalShaderProperty(string propertyName)
public bool Create()
public void Release()
public bool IsCreated()
public void GenerateMips()
public void ConvertToEquirect(RenderTexture equirect, MonoOrStereoscopicEye eye)
internal void SetSRGBReadWrite(bool srgb)
private void Internal_Create(RenderTexture rt)
public bool SupportsStencil(RenderTexture rt)
private void SetRenderTextureDescriptor(RenderTextureDescriptor desc)
private RenderTextureDescriptor GetDescriptor()
private RenderTexture GetTemporary_Internal(RenderTextureDescriptor desc)
public void ReleaseTemporary(RenderTexture temp)
public int get_depth()
public void set_depth(int value)
public void .ctor(RenderTextureDescriptor desc)
public void .ctor(RenderTexture textureToCopy)
public void .ctor(int width, int height, int depth, DefaultFormat format)
public void .ctor(int width, int height, int depth, GraphicsFormat format)
public void .ctor(int width, int height, int depth, GraphicsFormat format, int mipCount)
public void .ctor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat, int mipCount)
public void .ctor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat)
public void .ctor(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public void .ctor(int width, int height, int depth, RenderTextureFormat format)
public void .ctor(int width, int height, int depth)
public void .ctor(int width, int height, int depth, RenderTextureFormat format, int mipCount)
private void Initialize(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite, int mipCount)
internal GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, GraphicsFormat colorFormat)
internal GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, RenderTextureFormat format)
internal GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, DefaultFormat format)
internal GraphicsFormat GetDepthStencilFormatLegacy(int depthBits, bool requestedShadowMap)
public RenderTextureDescriptor get_descriptor()
public void set_descriptor(RenderTextureDescriptor value)
private void ValidateRenderTextureDesc(RenderTextureDescriptor desc)
internal GraphicsFormat GetDefaultColorFormat(DefaultFormat format)
internal GraphicsFormat GetDefaultDepthStencilFormat(DefaultFormat format, int depth)
internal GraphicsFormat GetCompatibleFormat(RenderTextureFormat renderTextureFormat, RenderTextureReadWrite readWrite)
public RenderTexture GetTemporary(RenderTextureDescriptor desc)
private RenderTexture GetTemporaryImpl(int width, int height, GraphicsFormat depthStencilFormat, GraphicsFormat colorFormat, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing, RenderTextureMemoryless memorylessMode)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format, int antiAliasing)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, GraphicsFormat format)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage, bool useDynamicScale)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode, VRTextureUsage vrUsage)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, RenderTextureMemoryless memorylessMode)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format, RenderTextureReadWrite readWrite)
public RenderTexture GetTemporary(int width, int height, int depthBuffer, RenderTextureFormat format)
public RenderTexture GetTemporary(int width, int height, int depthBuffer)
public RenderTexture GetTemporary(int width, int height)
public bool get_isCubemap()
public void set_isCubemap(bool value)
public bool get_isVolume()
public void set_isVolume(bool value)
public bool get_enabled()
public void set_enabled(bool value)
public Vector2 GetTexelOffset()
private void GetColorBuffer_Injected(RenderBuffer& ret)
private void GetDepthBuffer_Injected(RenderBuffer& ret)
private void SetRenderTextureDescriptor_Injected(RenderTextureDescriptor& desc)
private void GetDescriptor_Injected(RenderTextureDescriptor& ret)
private RenderTexture GetTemporary_Internal_Injected(RenderTextureDescriptor& desc)
}
public UnityEngine.RenderTextureCreationFlags : Enum {
public int value__
public RenderTextureCreationFlags MipMap
public RenderTextureCreationFlags AutoGenerateMips
public RenderTextureCreationFlags SRGB
public RenderTextureCreationFlags EyeTexture
public RenderTextureCreationFlags EnableRandomWrite
public RenderTextureCreationFlags CreatedFromScript
public RenderTextureCreationFlags AllowVerticalFlip
public RenderTextureCreationFlags NoResolvedColorSurface
public RenderTextureCreationFlags DynamicallyScalable
public RenderTextureCreationFlags BindMS
}
public UnityEngine.RenderTextureDescriptor : ValueType {
private int <width>k__BackingField
private int <height>k__BackingField
private int <msaaSamples>k__BackingField
private int <volumeDepth>k__BackingField
private int <mipCount>k__BackingField
private GraphicsFormat _graphicsFormat
private GraphicsFormat <stencilFormat>k__BackingField
private GraphicsFormat <depthStencilFormat>k__BackingField
private TextureDimension <dimension>k__BackingField
private ShadowSamplingMode <shadowSamplingMode>k__BackingField
private VRTextureUsage <vrUsage>k__BackingField
private RenderTextureCreationFlags _flags
private RenderTextureMemoryless <memoryless>k__BackingField
public int width
public int height
public int msaaSamples
public int volumeDepth
public int mipCount
public GraphicsFormat graphicsFormat
public GraphicsFormat stencilFormat
public GraphicsFormat depthStencilFormat
public RenderTextureFormat colorFormat
public bool sRGB
public int depthBufferBits
public TextureDimension dimension
public ShadowSamplingMode shadowSamplingMode
public VRTextureUsage vrUsage
public RenderTextureCreationFlags flags
public RenderTextureMemoryless memoryless
public bool useMipMap
public bool autoGenerateMips
public bool enableRandomWrite
public bool bindMS
internal bool createdFromScript
public bool useDynamicScale
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_msaaSamples()
public void set_msaaSamples(int value)
public int get_volumeDepth()
public void set_volumeDepth(int value)
public int get_mipCount()
public void set_mipCount(int value)
public GraphicsFormat get_graphicsFormat()
public void set_graphicsFormat(GraphicsFormat value)
public GraphicsFormat get_stencilFormat()
public void set_stencilFormat(GraphicsFormat value)
public GraphicsFormat get_depthStencilFormat()
public void set_depthStencilFormat(GraphicsFormat value)
public RenderTextureFormat get_colorFormat()
public void set_colorFormat(RenderTextureFormat value)
public bool get_sRGB()
public void set_sRGB(bool value)
public int get_depthBufferBits()
public void set_depthBufferBits(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public ShadowSamplingMode get_shadowSamplingMode()
public void set_shadowSamplingMode(ShadowSamplingMode value)
public VRTextureUsage get_vrUsage()
public void set_vrUsage(VRTextureUsage value)
public RenderTextureCreationFlags get_flags()
public RenderTextureMemoryless get_memoryless()
public void set_memoryless(RenderTextureMemoryless value)
public void .ctor(int width, int height)
public void .ctor(int width, int height, RenderTextureFormat colorFormat)
public void .ctor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits)
public void .ctor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits)
public void .ctor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits, int mipCount)
public void .ctor(int width, int height, RenderTextureFormat colorFormat, int depthBufferBits, int mipCount, RenderTextureReadWrite readWrite)
public void .ctor(int width, int height, GraphicsFormat colorFormat, int depthBufferBits, int mipCount)
public void .ctor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat)
public void .ctor(int width, int height, GraphicsFormat colorFormat, GraphicsFormat depthStencilFormat, int mipCount)
private void SetOrClearRenderTextureCreationFlag(bool value, RenderTextureCreationFlags flag)
public bool get_useMipMap()
public void set_useMipMap(bool value)
public bool get_autoGenerateMips()
public void set_autoGenerateMips(bool value)
public bool get_enableRandomWrite()
public void set_enableRandomWrite(bool value)
public bool get_bindMS()
public void set_bindMS(bool value)
internal bool get_createdFromScript()
internal void set_createdFromScript(bool value)
public bool get_useDynamicScale()
public void set_useDynamicScale(bool value)
}
public UnityEngine.RenderTextureFormat : Enum {
public int value__
public RenderTextureFormat ARGB32
public RenderTextureFormat Depth
public RenderTextureFormat ARGBHalf
public RenderTextureFormat Shadowmap
public RenderTextureFormat RGB565
public RenderTextureFormat ARGB4444
public RenderTextureFormat ARGB1555
public RenderTextureFormat Default
public RenderTextureFormat ARGB2101010
public RenderTextureFormat DefaultHDR
public RenderTextureFormat ARGB64
public RenderTextureFormat ARGBFloat
public RenderTextureFormat RGFloat
public RenderTextureFormat RGHalf
public RenderTextureFormat RFloat
public RenderTextureFormat RHalf
public RenderTextureFormat R8
public RenderTextureFormat ARGBInt
public RenderTextureFormat RGInt
public RenderTextureFormat RInt
public RenderTextureFormat BGRA32
public RenderTextureFormat RGB111110Float
public RenderTextureFormat RG32
public RenderTextureFormat RGBAUShort
public RenderTextureFormat RG16
public RenderTextureFormat BGRA10101010_XR
public RenderTextureFormat BGR101010_XR
public RenderTextureFormat R16
}
public UnityEngine.RenderTextureMemoryless : Enum {
public int value__
public RenderTextureMemoryless None
public RenderTextureMemoryless Color
public RenderTextureMemoryless Depth
public RenderTextureMemoryless MSAA
}
public UnityEngine.RenderTextureReadWrite : Enum {
public int value__
public RenderTextureReadWrite Default
public RenderTextureReadWrite Linear
public RenderTextureReadWrite sRGB
}
public UnityEngine.RequireComponent : Attribute {
public Type m_Type0
public Type m_Type1
public Type m_Type2
public void .ctor(Type requiredComponent)
public void .ctor(Type requiredComponent, Type requiredComponent2)
public void .ctor(Type requiredComponent, Type requiredComponent2, Type requiredComponent3)
}
public UnityEngine.Resolution : ValueType {
private int m_Width
private int m_Height
private int m_RefreshRate
public int width
public int height
public int refreshRate
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public int get_refreshRate()
public void set_refreshRate(int value)
public string ToString()
}
public UnityEngine.ResourceRequest : AsyncOperation {
internal string m_Path
internal Type m_Type
public Object asset
protected Object GetResult()
public Object get_asset()
}
public UnityEngine.Resources : object {
internal T[] ConvertObjects(Object[] rawObjects)
public Object[] FindObjectsOfTypeAll(Type type)
public T[] FindObjectsOfTypeAll()
public Object Load(string path)
public T Load(string path)
public Object Load(string path, Type systemTypeInstance)
public ResourceRequest LoadAsync(string path)
public ResourceRequest LoadAsync(string path)
public ResourceRequest LoadAsync(string path, Type type)
public Object[] LoadAll(string path, Type systemTypeInstance)
public Object[] LoadAll(string path)
public T[] LoadAll(string path)
public Object GetBuiltinResource(Type type, string path)
public T GetBuiltinResource(string path)
public void UnloadAsset(Object assetToUnload)
private void UnloadAssetImplResourceManager(Object assetToUnload)
public AsyncOperation UnloadUnusedAssets()
public Object InstanceIDToObject(int instanceID)
private void InstanceIDToObjectList(IntPtr instanceIDs, int instanceCount, List`1<Object> objects)
public void InstanceIDToObjectList(NativeArray`1<int> instanceIDs, List`1<Object> objects)
}
public UnityEngine.ResourcesAPI : object {
private ResourcesAPI s_DefaultAPI
private ResourcesAPI <overrideAPI>k__BackingField
internal ResourcesAPI ActiveAPI
public ResourcesAPI overrideAPI
internal ResourcesAPI get_ActiveAPI()
public ResourcesAPI get_overrideAPI()
public void set_overrideAPI(ResourcesAPI value)
protected internal Object[] FindObjectsOfTypeAll(Type systemTypeInstance)
protected internal Shader FindShaderByName(string name)
protected internal Object Load(string path, Type systemTypeInstance)
protected internal Object[] LoadAll(string path, Type systemTypeInstance)
protected internal ResourceRequest LoadAsync(string path, Type systemTypeInstance)
protected internal void UnloadAsset(Object assetToUnload)
}
internal UnityEngine.ResourcesAPIInternal : object {
public Object[] FindObjectsOfTypeAll(Type type)
public Shader FindShaderByName(string name)
public Object Load(string path, Type systemTypeInstance)
public Object[] LoadAll(string path, Type systemTypeInstance)
internal ResourceRequest LoadAsyncInternal(string path, Type type)
public void UnloadAsset(Object assetToUnload)
}
internal UnityEngine.RotationOrder : Enum {
public int value__
public RotationOrder OrderXYZ
public RotationOrder OrderXZY
public RotationOrder OrderYZX
public RotationOrder OrderYXZ
public RotationOrder OrderZXY
public RotationOrder OrderZYX
}
public UnityEngine.RuntimeInitializeLoadType : Enum {
public int value__
public RuntimeInitializeLoadType AfterSceneLoad
public RuntimeInitializeLoadType BeforeSceneLoad
public RuntimeInitializeLoadType AfterAssembliesLoaded
public RuntimeInitializeLoadType BeforeSplashScreen
public RuntimeInitializeLoadType SubsystemRegistration
}
public UnityEngine.RuntimeInitializeOnLoadMethodAttribute : PreserveAttribute {
private RuntimeInitializeLoadType m_LoadType
public RuntimeInitializeLoadType loadType
public void .ctor(RuntimeInitializeLoadType loadType)
public RuntimeInitializeLoadType get_loadType()
private void set_loadType(RuntimeInitializeLoadType value)
}
public UnityEngine.RuntimePlatform : Enum {
public int value__
public RuntimePlatform OSXEditor
public RuntimePlatform OSXPlayer
public RuntimePlatform WindowsPlayer
public RuntimePlatform OSXWebPlayer
public RuntimePlatform OSXDashboardPlayer
public RuntimePlatform WindowsWebPlayer
public RuntimePlatform WindowsEditor
public RuntimePlatform IPhonePlayer
public RuntimePlatform XBOX360
public RuntimePlatform PS3
public RuntimePlatform Android
public RuntimePlatform NaCl
public RuntimePlatform FlashPlayer
public RuntimePlatform LinuxPlayer
public RuntimePlatform LinuxEditor
public RuntimePlatform WebGLPlayer
public RuntimePlatform MetroPlayerX86
public RuntimePlatform WSAPlayerX86
public RuntimePlatform MetroPlayerX64
public RuntimePlatform WSAPlayerX64
public RuntimePlatform MetroPlayerARM
public RuntimePlatform WSAPlayerARM
public RuntimePlatform WP8Player
public RuntimePlatform BlackBerryPlayer
public RuntimePlatform TizenPlayer
public RuntimePlatform PSP2
public RuntimePlatform PS4
public RuntimePlatform PSM
public RuntimePlatform XboxOne
public RuntimePlatform SamsungTVPlayer
public RuntimePlatform WiiU
public RuntimePlatform tvOS
public RuntimePlatform Switch
public RuntimePlatform Lumin
public RuntimePlatform Stadia
public RuntimePlatform CloudRendering
public RuntimePlatform GameCoreScarlett
public RuntimePlatform GameCoreXboxSeries
public RuntimePlatform GameCoreXboxOne
public RuntimePlatform PS5
public RuntimePlatform EmbeddedLinuxArm64
public RuntimePlatform EmbeddedLinuxArm32
public RuntimePlatform EmbeddedLinuxX64
public RuntimePlatform EmbeddedLinuxX86
public RuntimePlatform LinuxServer
public RuntimePlatform WindowsServer
public RuntimePlatform OSXServer
}
public UnityEngine.ScalableBufferManager : object {
public float widthScaleFactor
public float heightScaleFactor
public float get_widthScaleFactor()
public float get_heightScaleFactor()
public void ResizeBuffers(float widthScale, float heightScale)
}
public UnityEngine.SceneManagement.CreateSceneParameters : ValueType {
private LocalPhysicsMode m_LocalPhysicsMode
public LocalPhysicsMode localPhysicsMode
public LocalPhysicsMode get_localPhysicsMode()
public void set_localPhysicsMode(LocalPhysicsMode value)
public void .ctor(LocalPhysicsMode physicsMode)
}
public UnityEngine.SceneManagement.LoadSceneMode : Enum {
public int value__
public LoadSceneMode Single
public LoadSceneMode Additive
}
public UnityEngine.SceneManagement.LoadSceneParameters : ValueType {
private LoadSceneMode m_LoadSceneMode
private LocalPhysicsMode m_LocalPhysicsMode
public LoadSceneMode loadSceneMode
public LocalPhysicsMode localPhysicsMode
public LoadSceneMode get_loadSceneMode()
public void set_loadSceneMode(LoadSceneMode value)
public LocalPhysicsMode get_localPhysicsMode()
public void set_localPhysicsMode(LocalPhysicsMode value)
public void .ctor(LoadSceneMode mode)
public void .ctor(LoadSceneMode mode, LocalPhysicsMode physicsMode)
}
public UnityEngine.SceneManagement.LocalPhysicsMode : Enum {
public int value__
public LocalPhysicsMode None
public LocalPhysicsMode Physics2D
public LocalPhysicsMode Physics3D
}
public UnityEngine.SceneManagement.Scene : ValueType {
private int m_Handle
public int handle
internal LoadingState loadingState
internal string guid
public string path
public string name
public bool isLoaded
public int buildIndex
public bool isDirty
internal int dirtyID
public int rootCount
public bool isSubScene
private bool IsValidInternal(int sceneHandle)
private string GetPathInternal(int sceneHandle)
private string GetNameInternal(int sceneHandle)
private void SetNameInternal(int sceneHandle, string name)
private string GetGUIDInternal(int sceneHandle)
private bool IsSubScene(int sceneHandle)
private void SetIsSubScene(int sceneHandle, bool value)
private bool GetIsLoadedInternal(int sceneHandle)
private LoadingState GetLoadingStateInternal(int sceneHandle)
private bool GetIsDirtyInternal(int sceneHandle)
private int GetDirtyID(int sceneHandle)
private int GetBuildIndexInternal(int sceneHandle)
private int GetRootCountInternal(int sceneHandle)
private void GetRootGameObjectsInternal(int sceneHandle, object resultRootList)
internal void .ctor(int handle)
public int get_handle()
internal LoadingState get_loadingState()
internal string get_guid()
public bool IsValid()
public string get_path()
public string get_name()
public void set_name(string value)
public bool get_isLoaded()
public int get_buildIndex()
public bool get_isDirty()
internal int get_dirtyID()
public int get_rootCount()
public bool get_isSubScene()
public void set_isSubScene(bool value)
public GameObject[] GetRootGameObjects()
public void GetRootGameObjects(List`1<GameObject> rootGameObjects)
public bool op_Equality(Scene lhs, Scene rhs)
public bool op_Inequality(Scene lhs, Scene rhs)
public int GetHashCode()
public bool Equals(object other)
}
public UnityEngine.SceneManagement.SceneManager : object {
internal bool s_AllowLoadScene
private UnityAction`2<Scene, LoadSceneMode> sceneLoaded
private UnityAction`1<Scene> sceneUnloaded
private UnityAction`2<Scene, Scene> activeSceneChanged
public int sceneCount
public int sceneCountInBuildSettings
public int get_sceneCount()
public int get_sceneCountInBuildSettings()
public Scene GetActiveScene()
public bool SetActiveScene(Scene scene)
public Scene GetSceneByPath(string scenePath)
public Scene GetSceneByName(string name)
public Scene GetSceneByBuildIndex(int buildIndex)
public Scene GetSceneAt(int index)
public Scene CreateScene(string sceneName, CreateSceneParameters parameters)
private bool UnloadSceneInternal(Scene scene, UnloadSceneOptions options)
private AsyncOperation UnloadSceneAsyncInternal(Scene scene, UnloadSceneOptions options)
private AsyncOperation LoadSceneAsyncNameIndexInternal(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame)
private AsyncOperation UnloadSceneNameIndexInternal(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess)
public void MergeScenes(Scene sourceScene, Scene destinationScene)
public void MoveGameObjectToScene(GameObject go, Scene scene)
internal AsyncOperation LoadFirstScene_Internal(bool async)
public void add_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value)
public void remove_sceneLoaded(UnityAction`2<Scene, LoadSceneMode> value)
public void add_sceneUnloaded(UnityAction`1<Scene> value)
public void remove_sceneUnloaded(UnityAction`1<Scene> value)
public void add_activeSceneChanged(UnityAction`2<Scene, Scene> value)
public void remove_activeSceneChanged(UnityAction`2<Scene, Scene> value)
public Scene[] GetAllScenes()
public Scene CreateScene(string sceneName)
public void LoadScene(string sceneName, LoadSceneMode mode)
public void LoadScene(string sceneName)
public Scene LoadScene(string sceneName, LoadSceneParameters parameters)
public void LoadScene(int sceneBuildIndex, LoadSceneMode mode)
public void LoadScene(int sceneBuildIndex)
public Scene LoadScene(int sceneBuildIndex, LoadSceneParameters parameters)
public AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneMode mode)
public AsyncOperation LoadSceneAsync(int sceneBuildIndex)
public AsyncOperation LoadSceneAsync(int sceneBuildIndex, LoadSceneParameters parameters)
public AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode)
public AsyncOperation LoadSceneAsync(string sceneName)
public AsyncOperation LoadSceneAsync(string sceneName, LoadSceneParameters parameters)
public bool UnloadScene(Scene scene)
public bool UnloadScene(int sceneBuildIndex)
public bool UnloadScene(string sceneName)
public AsyncOperation UnloadSceneAsync(int sceneBuildIndex)
public AsyncOperation UnloadSceneAsync(string sceneName)
public AsyncOperation UnloadSceneAsync(Scene scene)
public AsyncOperation UnloadSceneAsync(int sceneBuildIndex, UnloadSceneOptions options)
public AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options)
public AsyncOperation UnloadSceneAsync(Scene scene, UnloadSceneOptions options)
private void Internal_SceneLoaded(Scene scene, LoadSceneMode mode)
private void Internal_SceneUnloaded(Scene scene)
private void Internal_ActiveSceneChanged(Scene previousActiveScene, Scene newActiveScene)
private void GetActiveScene_Injected(Scene& ret)
private bool SetActiveScene_Injected(Scene& scene)
private void GetSceneByPath_Injected(string scenePath, Scene& ret)
private void GetSceneByName_Injected(string name, Scene& ret)
private void GetSceneAt_Injected(int index, Scene& ret)
private void CreateScene_Injected(string sceneName, CreateSceneParameters& parameters, Scene& ret)
private bool UnloadSceneInternal_Injected(Scene& scene, UnloadSceneOptions options)
private AsyncOperation UnloadSceneAsyncInternal_Injected(Scene& scene, UnloadSceneOptions options)
private void MergeScenes_Injected(Scene& sourceScene, Scene& destinationScene)
private void MoveGameObjectToScene_Injected(GameObject go, Scene& scene)
}
public UnityEngine.SceneManagement.SceneManagerAPI : object {
private SceneManagerAPI s_DefaultAPI
private SceneManagerAPI <overrideAPI>k__BackingField
internal SceneManagerAPI ActiveAPI
public SceneManagerAPI overrideAPI
internal SceneManagerAPI get_ActiveAPI()
public SceneManagerAPI get_overrideAPI()
public void set_overrideAPI(SceneManagerAPI value)
protected internal int GetNumScenesInBuildSettings()
protected internal Scene GetSceneByBuildIndex(int buildIndex)
protected internal AsyncOperation LoadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame)
protected internal AsyncOperation UnloadSceneAsyncByNameOrIndex(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess)
protected internal AsyncOperation LoadFirstScene(bool mustLoadAsync)
}
internal UnityEngine.SceneManagement.SceneManagerAPIInternal : object {
public int GetNumScenesInBuildSettings()
public Scene GetSceneByBuildIndex(int buildIndex)
public AsyncOperation LoadSceneAsyncNameIndexInternal(string sceneName, int sceneBuildIndex, LoadSceneParameters parameters, bool mustCompleteNextFrame)
public AsyncOperation UnloadSceneNameIndexInternal(string sceneName, int sceneBuildIndex, bool immediately, UnloadSceneOptions options, Boolean& outSuccess)
private void GetSceneByBuildIndex_Injected(int buildIndex, Scene& ret)
private AsyncOperation LoadSceneAsyncNameIndexInternal_Injected(string sceneName, int sceneBuildIndex, LoadSceneParameters& parameters, bool mustCompleteNextFrame)
}
public UnityEngine.SceneManagement.SceneUtility : object {
public string GetScenePathByBuildIndex(int buildIndex)
public int GetBuildIndexByScenePath(string scenePath)
}
public UnityEngine.SceneManagement.UnloadSceneOptions : Enum {
public int value__
public UnloadSceneOptions None
public UnloadSceneOptions UnloadAllEmbeddedSceneObjects
}
public UnityEngine.Screen : object {
public int width
public int height
public float dpi
public ScreenOrientation orientation
public int sleepTimeout
public bool autorotateToPortrait
public bool autorotateToPortraitUpsideDown
public bool autorotateToLandscapeLeft
public bool autorotateToLandscapeRight
public Resolution currentResolution
public bool fullScreen
public FullScreenMode fullScreenMode
public Rect safeArea
public Rect[] cutouts
public Vector2Int mainWindowPosition
public DisplayInfo mainWindowDisplayInfo
public Resolution[] resolutions
public float brightness
public bool lockCursor
public int get_width()
public int get_height()
public float get_dpi()
private void RequestOrientation(ScreenOrientation orient)
private ScreenOrientation GetScreenOrientation()
public ScreenOrientation get_orientation()
public void set_orientation(ScreenOrientation value)
public int get_sleepTimeout()
public void set_sleepTimeout(int value)
private bool IsOrientationEnabled(EnabledOrientation orient)
private void SetOrientationEnabled(EnabledOrientation orient, bool enabled)
public bool get_autorotateToPortrait()
public void set_autorotateToPortrait(bool value)
public bool get_autorotateToPortraitUpsideDown()
public void set_autorotateToPortraitUpsideDown(bool value)
public bool get_autorotateToLandscapeLeft()
public void set_autorotateToLandscapeLeft(bool value)
public bool get_autorotateToLandscapeRight()
public void set_autorotateToLandscapeRight(bool value)
public Resolution get_currentResolution()
public bool get_fullScreen()
public void set_fullScreen(bool value)
public FullScreenMode get_fullScreenMode()
public void set_fullScreenMode(FullScreenMode value)
public Rect get_safeArea()
public Rect[] get_cutouts()
public void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate)
public void SetResolution(int width, int height, FullScreenMode fullscreenMode)
public void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate)
public void SetResolution(int width, int height, bool fullscreen)
public Vector2Int get_mainWindowPosition()
public DisplayInfo get_mainWindowDisplayInfo()
public void GetDisplayLayout(List`1<DisplayInfo> displayLayout)
public AsyncOperation MoveMainWindowTo(DisplayInfo& display, Vector2Int position)
private Vector2Int GetMainWindowPosition()
private DisplayInfo GetMainWindowDisplayInfo()
private void GetDisplayLayoutImpl(List`1<DisplayInfo> displayLayout)
private AsyncOperation MoveMainWindowImpl(DisplayInfo& display, Vector2Int position)
public Resolution[] get_resolutions()
public float get_brightness()
public void set_brightness(float value)
public bool get_lockCursor()
public void set_lockCursor(bool value)
private void get_currentResolution_Injected(Resolution& ret)
private void get_safeArea_Injected(Rect& ret)
private void GetMainWindowPosition_Injected(Vector2Int& ret)
private void GetMainWindowDisplayInfo_Injected(DisplayInfo& ret)
private AsyncOperation MoveMainWindowImpl_Injected(DisplayInfo& display, Vector2Int& position)
}
public UnityEngine.ScreenOrientation : Enum {
public int value__
public ScreenOrientation Unknown
public ScreenOrientation Landscape
public ScreenOrientation Portrait
public ScreenOrientation PortraitUpsideDown
public ScreenOrientation LandscapeLeft
public ScreenOrientation LandscapeRight
public ScreenOrientation AutoRotation
}
public UnityEngine.ScriptableObject : Object {
public void SetDirty()
public ScriptableObject CreateInstance(string className)
public ScriptableObject CreateInstance(Type type)
public T CreateInstance()
internal ScriptableObject CreateInstance(Type type, Action`1<ScriptableObject> initialize)
private void CreateScriptableObject(ScriptableObject self)
private ScriptableObject CreateScriptableObjectInstanceFromName(string className)
internal ScriptableObject CreateScriptableObjectInstanceFromType(Type type, bool applyDefaultsAndReset)
internal void ResetAndApplyDefaultInstances(Object obj)
}
public UnityEngine.Scripting.APIUpdating.MovedFromAttribute : Attribute {
internal MovedFromAttributeData data
internal bool AffectsAPIUpdater
public bool IsInDifferentAssembly
public void .ctor(bool autoUpdateAPI, string sourceNamespace, string sourceAssembly, string sourceClassName)
public void .ctor(string sourceNamespace)
internal bool get_AffectsAPIUpdater()
public bool get_IsInDifferentAssembly()
}
internal UnityEngine.Scripting.APIUpdating.MovedFromAttributeData : ValueType {
public string className
public string nameSpace
public string assembly
public bool classHasChanged
public bool nameSpaceHasChanged
public bool assemblyHasChanged
public bool autoUdpateAPI
public void Set(bool autoUpdateAPI, string sourceNamespace, string sourceAssembly, string sourceClassName)
}
public UnityEngine.Scripting.GarbageCollector : object {
private Action`1<Mode> GCModeChanged
public Mode GCMode
public bool isIncremental
public ulong incrementalTimeSliceNanoseconds
public void add_GCModeChanged(Action`1<Mode> value)
public void remove_GCModeChanged(Action`1<Mode> value)
public Mode get_GCMode()
public void set_GCMode(Mode value)
private void SetMode(Mode mode)
private Mode GetMode()
public bool get_isIncremental()
public ulong get_incrementalTimeSliceNanoseconds()
public void set_incrementalTimeSliceNanoseconds(ulong value)
public bool CollectIncremental(ulong nanoseconds)
}
public UnityEngine.Scripting.RequiredInterfaceAttribute : Attribute {
public void .ctor(Type interfaceType)
}
internal UnityEngine.ScriptingRuntime : object {
public String[] GetAllUserAssemblies()
}
internal UnityEngine.ScriptingUtility : object {
private bool IsManagedCodeWorking()
}
internal UnityEngine.ScrollWaitDefinitions : object {
public int firstWait
public int regularWait
}
public UnityEngine.Search.SearchContextAttribute : PropertyAttribute {
private string <query>k__BackingField
private String[] <providerIds>k__BackingField
private Type[] <instantiableProviders>k__BackingField
private SearchViewFlags <flags>k__BackingField
public string query
public String[] providerIds
public Type[] instantiableProviders
public SearchViewFlags flags
public string get_query()
private void set_query(string value)
public String[] get_providerIds()
private void set_providerIds(String[] value)
public Type[] get_instantiableProviders()
private void set_instantiableProviders(Type[] value)
public SearchViewFlags get_flags()
private void set_flags(SearchViewFlags value)
public void .ctor(string query)
public void .ctor(string query, SearchViewFlags flags)
public void .ctor(string query, string providerIdsCommaSeparated)
public void .ctor(string query, string providerIdsCommaSeparated, SearchViewFlags flags)
public void .ctor(string query, Type[] instantiableProviders)
public void .ctor(string query, SearchViewFlags flags, Type[] instantiableProviders)
public void .ctor(string query, SearchViewFlags flags, string providerIdsCommaSeparated, Type[] instantiableProviders)
}
public UnityEngine.Search.SearchViewFlags : Enum {
public int value__
public SearchViewFlags None
public SearchViewFlags Debug
public SearchViewFlags NoIndexing
public SearchViewFlags Packages
public SearchViewFlags OpenLeftSidePanel
public SearchViewFlags OpenInspectorPreview
public SearchViewFlags Centered
public SearchViewFlags HideSearchBar
public SearchViewFlags CompactView
public SearchViewFlags ListView
public SearchViewFlags GridView
public SearchViewFlags TableView
public SearchViewFlags EnableSearchQuery
public SearchViewFlags DisableInspectorPreview
public SearchViewFlags DisableSavedSearchQuery
public SearchViewFlags OpenInBuilderMode
public SearchViewFlags OpenInTextMode
public SearchViewFlags DisableBuilderModeToggle
public SearchViewFlags Borderless
}
public UnityEngine.SearchService.ObjectSelectorHandlerWithLabelsAttribute : Attribute {
private String[] <labels>k__BackingField
private bool <matchAll>k__BackingField
public String[] labels
public bool matchAll
public String[] get_labels()
public bool get_matchAll()
public void .ctor(String[] labels)
public void .ctor(bool matchAll, String[] labels)
}
public UnityEngine.SearchService.ObjectSelectorHandlerWithTagsAttribute : Attribute {
private String[] <tags>k__BackingField
public String[] tags
public String[] get_tags()
public void .ctor(String[] tags)
}
public UnityEngine.SecondarySpriteTexture : ValueType {
public string name
public Texture2D texture
}
public UnityEngine.Security : object {
public Assembly LoadAndVerifyAssembly(Byte[] assemblyData, string authorizationKey)
public Assembly LoadAndVerifyAssembly(Byte[] assemblyData)
public bool PrefetchSocketPolicy(string ip, int atPort)
public bool PrefetchSocketPolicy(string ip, int atPort, int timeout)
}
public UnityEngine.SendMessageOptions : Enum {
public int value__
public SendMessageOptions RequireReceiver
public SendMessageOptions DontRequireReceiver
}
internal UnityEngine.Serialization.DictionarySerializationSurrogate`2 : object {
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
}
public UnityEngine.Serialization.FormerlySerializedAsAttribute : Attribute {
private string m_oldName
public string oldName
public void .ctor(string oldName)
public string get_oldName()
}
internal UnityEngine.Serialization.ListSerializationSurrogate : object {
public ISerializationSurrogate Default
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
private Array ArrayFromGenericList(IList list)
}
public UnityEngine.Serialization.UnitySurrogateSelector : object {
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
}
internal UnityEngine.SetupCoroutine : object {
public void InvokeMoveNext(IEnumerator enumerator, IntPtr returnValueAddress)
public object InvokeMember(object behaviour, string name, object variable)
public object InvokeStatic(Type klass, string name, object variable)
}
public UnityEngine.Shader : Object {
public ShaderHardwareTier globalShaderHardwareTier
public int maximumChunksOverride
public int maximumLOD
public int globalMaximumLOD
public bool isSupported
public string globalRenderPipeline
public GlobalKeyword[] enabledGlobalKeywords
public GlobalKeyword[] globalKeywords
public LocalKeywordSpace keywordSpace
public int renderQueue
internal DisableBatchingType disableBatching
public int passCount
public int subshaderCount
public ShaderHardwareTier get_globalShaderHardwareTier()
public void set_globalShaderHardwareTier(ShaderHardwareTier value)
public Shader Find(string name)
internal Shader FindBuiltin(string name)
public int get_maximumChunksOverride()
public void set_maximumChunksOverride(int value)
public int get_maximumLOD()
public void set_maximumLOD(int value)
public int get_globalMaximumLOD()
public void set_globalMaximumLOD(int value)
public bool get_isSupported()
public string get_globalRenderPipeline()
public void set_globalRenderPipeline(string value)
public GlobalKeyword[] get_enabledGlobalKeywords()
public GlobalKeyword[] get_globalKeywords()
public LocalKeywordSpace get_keywordSpace()
internal GlobalKeyword[] GetEnabledGlobalKeywords()
internal GlobalKeyword[] GetAllGlobalKeywords()
public void EnableKeyword(string keyword)
public void DisableKeyword(string keyword)
public bool IsKeywordEnabled(string keyword)
internal void EnableKeywordFast(GlobalKeyword keyword)
internal void DisableKeywordFast(GlobalKeyword keyword)
internal void SetKeywordFast(GlobalKeyword keyword, bool value)
internal bool IsKeywordEnabledFast(GlobalKeyword keyword)
public void EnableKeyword(GlobalKeyword& keyword)
public void DisableKeyword(GlobalKeyword& keyword)
public void SetKeyword(GlobalKeyword& keyword, bool value)
public bool IsKeywordEnabled(GlobalKeyword& keyword)
public int get_renderQueue()
internal DisableBatchingType get_disableBatching()
public void WarmupAllShaders()
internal int TagToID(string name)
internal string IDToTag(int name)
public int PropertyToID(string name)
public Shader GetDependency(string name)
public int get_passCount()
public int get_subshaderCount()
public int GetPassCountInSubshader(int subshaderIndex)
public ShaderTagId FindPassTagValue(int passIndex, ShaderTagId tagName)
public ShaderTagId FindPassTagValue(int subshaderIndex, int passIndex, ShaderTagId tagName)
public ShaderTagId FindSubshaderTagValue(int subshaderIndex, ShaderTagId tagName)
private int Internal_FindPassTagValue(int passIndex, int tagName)
private int Internal_FindPassTagValueInSubShader(int subShaderIndex, int passIndex, int tagName)
private int Internal_FindSubshaderTagValue(int subShaderIndex, int tagName)
private void SetGlobalIntImpl(int name, int value)
private void SetGlobalFloatImpl(int name, float value)
private void SetGlobalVectorImpl(int name, Vector4 value)
private void SetGlobalMatrixImpl(int name, Matrix4x4 value)
private void SetGlobalTextureImpl(int name, Texture value)
private void SetGlobalRenderTextureImpl(int name, RenderTexture value, RenderTextureSubElement element)
private void SetGlobalBufferImpl(int name, ComputeBuffer value)
private void SetGlobalGraphicsBufferImpl(int name, GraphicsBuffer value)
private void SetGlobalConstantBufferImpl(int name, ComputeBuffer value, int offset, int size)
private void SetGlobalConstantGraphicsBufferImpl(int name, GraphicsBuffer value, int offset, int size)
private int GetGlobalIntImpl(int name)
private float GetGlobalFloatImpl(int name)
private Vector4 GetGlobalVectorImpl(int name)
private Matrix4x4 GetGlobalMatrixImpl(int name)
private Texture GetGlobalTextureImpl(int name)
private void SetGlobalFloatArrayImpl(int name, Single[] values, int count)
private void SetGlobalVectorArrayImpl(int name, Vector4[] values, int count)
private void SetGlobalMatrixArrayImpl(int name, Matrix4x4[] values, int count)
private Single[] GetGlobalFloatArrayImpl(int name)
private Vector4[] GetGlobalVectorArrayImpl(int name)
private Matrix4x4[] GetGlobalMatrixArrayImpl(int name)
private int GetGlobalFloatArrayCountImpl(int name)
private int GetGlobalVectorArrayCountImpl(int name)
private int GetGlobalMatrixArrayCountImpl(int name)
private void ExtractGlobalFloatArrayImpl(int name, Single[] val)
private void ExtractGlobalVectorArrayImpl(int name, Vector4[] val)
private void ExtractGlobalMatrixArrayImpl(int name, Matrix4x4[] val)
private void SetGlobalFloatArray(int name, Single[] values, int count)
private void SetGlobalVectorArray(int name, Vector4[] values, int count)
private void SetGlobalMatrixArray(int name, Matrix4x4[] values, int count)
private void ExtractGlobalFloatArray(int name, List`1<float> values)
private void ExtractGlobalVectorArray(int name, List`1<Vector4> values)
private void ExtractGlobalMatrixArray(int name, List`1<Matrix4x4> values)
public void SetGlobalInt(string name, int value)
public void SetGlobalInt(int nameID, int value)
public void SetGlobalFloat(string name, float value)
public void SetGlobalFloat(int nameID, float value)
public void SetGlobalInteger(string name, int value)
public void SetGlobalInteger(int nameID, int value)
public void SetGlobalVector(string name, Vector4 value)
public void SetGlobalVector(int nameID, Vector4 value)
public void SetGlobalColor(string name, Color value)
public void SetGlobalColor(int nameID, Color value)
public void SetGlobalMatrix(string name, Matrix4x4 value)
public void SetGlobalMatrix(int nameID, Matrix4x4 value)
public void SetGlobalTexture(string name, Texture value)
public void SetGlobalTexture(int nameID, Texture value)
public void SetGlobalTexture(string name, RenderTexture value, RenderTextureSubElement element)
public void SetGlobalTexture(int nameID, RenderTexture value, RenderTextureSubElement element)
public void SetGlobalBuffer(string name, ComputeBuffer value)
public void SetGlobalBuffer(int nameID, ComputeBuffer value)
public void SetGlobalBuffer(string name, GraphicsBuffer value)
public void SetGlobalBuffer(int nameID, GraphicsBuffer value)
public void SetGlobalConstantBuffer(string name, ComputeBuffer value, int offset, int size)
public void SetGlobalConstantBuffer(int nameID, ComputeBuffer value, int offset, int size)
public void SetGlobalConstantBuffer(string name, GraphicsBuffer value, int offset, int size)
public void SetGlobalConstantBuffer(int nameID, GraphicsBuffer value, int offset, int size)
public void SetGlobalFloatArray(string name, List`1<float> values)
public void SetGlobalFloatArray(int nameID, List`1<float> values)
public void SetGlobalFloatArray(string name, Single[] values)
public void SetGlobalFloatArray(int nameID, Single[] values)
public void SetGlobalVectorArray(string name, List`1<Vector4> values)
public void SetGlobalVectorArray(int nameID, List`1<Vector4> values)
public void SetGlobalVectorArray(string name, Vector4[] values)
public void SetGlobalVectorArray(int nameID, Vector4[] values)
public void SetGlobalMatrixArray(string name, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values)
public void SetGlobalMatrixArray(string name, Matrix4x4[] values)
public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values)
public int GetGlobalInt(string name)
public int GetGlobalInt(int nameID)
public float GetGlobalFloat(string name)
public float GetGlobalFloat(int nameID)
public int GetGlobalInteger(string name)
public int GetGlobalInteger(int nameID)
public Vector4 GetGlobalVector(string name)
public Vector4 GetGlobalVector(int nameID)
public Color GetGlobalColor(string name)
public Color GetGlobalColor(int nameID)
public Matrix4x4 GetGlobalMatrix(string name)
public Matrix4x4 GetGlobalMatrix(int nameID)
public Texture GetGlobalTexture(string name)
public Texture GetGlobalTexture(int nameID)
public Single[] GetGlobalFloatArray(string name)
public Single[] GetGlobalFloatArray(int nameID)
public Vector4[] GetGlobalVectorArray(string name)
public Vector4[] GetGlobalVectorArray(int nameID)
public Matrix4x4[] GetGlobalMatrixArray(string name)
public Matrix4x4[] GetGlobalMatrixArray(int nameID)
public void GetGlobalFloatArray(string name, List`1<float> values)
public void GetGlobalFloatArray(int nameID, List`1<float> values)
public void GetGlobalVectorArray(string name, List`1<Vector4> values)
public void GetGlobalVectorArray(int nameID, List`1<Vector4> values)
public void GetGlobalMatrixArray(string name, List`1<Matrix4x4> values)
public void GetGlobalMatrixArray(int nameID, List`1<Matrix4x4> values)
private string GetPropertyName(Shader shader, int propertyIndex)
private int GetPropertyNameId(Shader shader, int propertyIndex)
private ShaderPropertyType GetPropertyType(Shader shader, int propertyIndex)
private string GetPropertyDescription(Shader shader, int propertyIndex)
private ShaderPropertyFlags GetPropertyFlags(Shader shader, int propertyIndex)
private String[] GetPropertyAttributes(Shader shader, int propertyIndex)
private int GetPropertyDefaultIntValue(Shader shader, int propertyIndex)
private Vector4 GetPropertyDefaultValue(Shader shader, int propertyIndex)
private TextureDimension GetPropertyTextureDimension(Shader shader, int propertyIndex)
private string GetPropertyTextureDefaultName(Shader shader, int propertyIndex)
private bool FindTextureStackImpl(Shader s, int propertyIdx, String& stackName, Int32& layerIndex)
private void CheckPropertyIndex(Shader s, int propertyIndex)
public int GetPropertyCount()
public int FindPropertyIndex(string propertyName)
public string GetPropertyName(int propertyIndex)
public int GetPropertyNameId(int propertyIndex)
public ShaderPropertyType GetPropertyType(int propertyIndex)
public string GetPropertyDescription(int propertyIndex)
public ShaderPropertyFlags GetPropertyFlags(int propertyIndex)
public String[] GetPropertyAttributes(int propertyIndex)
public float GetPropertyDefaultFloatValue(int propertyIndex)
public Vector4 GetPropertyDefaultVectorValue(int propertyIndex)
public Vector2 GetPropertyRangeLimits(int propertyIndex)
public TextureDimension GetPropertyTextureDimension(int propertyIndex)
public string GetPropertyTextureDefaultName(int propertyIndex)
public bool FindTextureStack(int propertyIndex, String& stackName, Int32& layerIndex)
private void get_keywordSpace_Injected(LocalKeywordSpace& ret)
private void EnableKeywordFast_Injected(GlobalKeyword& keyword)
private void DisableKeywordFast_Injected(GlobalKeyword& keyword)
private void SetKeywordFast_Injected(GlobalKeyword& keyword, bool value)
private bool IsKeywordEnabledFast_Injected(GlobalKeyword& keyword)
private void SetGlobalVectorImpl_Injected(int name, Vector4& value)
private void SetGlobalMatrixImpl_Injected(int name, Matrix4x4& value)
private void GetGlobalVectorImpl_Injected(int name, Vector4& ret)
private void GetGlobalMatrixImpl_Injected(int name, Matrix4x4& ret)
private void GetPropertyDefaultValue_Injected(Shader shader, int propertyIndex, Vector4& ret)
}
public UnityEngine.ShaderVariantCollection : Object {
public int shaderCount
public int variantCount
public bool isWarmedUp
public int get_shaderCount()
public int get_variantCount()
public bool get_isWarmedUp()
private bool AddVariant(Shader shader, PassType passType, String[] keywords)
private bool RemoveVariant(Shader shader, PassType passType, String[] keywords)
private bool ContainsVariant(Shader shader, PassType passType, String[] keywords)
public void Clear()
public void WarmUp()
private void Internal_Create(ShaderVariantCollection svc)
public bool Add(ShaderVariant variant)
public bool Remove(ShaderVariant variant)
public bool Contains(ShaderVariant variant)
}
public UnityEngine.ShadowmaskMode : Enum {
public int value__
public ShadowmaskMode Shadowmask
public ShadowmaskMode DistanceShadowmask
}
public UnityEngine.ShadowObjectsFilter : Enum {
public int value__
public ShadowObjectsFilter AllObjects
public ShadowObjectsFilter DynamicOnly
public ShadowObjectsFilter StaticOnly
}
public UnityEngine.ShadowProjection : Enum {
public int value__
public ShadowProjection CloseFit
public ShadowProjection StableFit
}
public UnityEngine.ShadowQuality : Enum {
public int value__
public ShadowQuality Disable
public ShadowQuality HardOnly
public ShadowQuality All
}
public UnityEngine.ShadowResolution : Enum {
public int value__
public ShadowResolution Low
public ShadowResolution Medium
public ShadowResolution High
public ShadowResolution VeryHigh
}
public UnityEngine.SkinnedMeshRenderer : Renderer {
public SkinQuality quality
public bool updateWhenOffscreen
public bool forceMatrixRecalculationPerRender
public Transform rootBone
public Transform[] bones
public Mesh sharedMesh
public bool skinnedMotionVectors
public Target vertexBufferTarget
public SkinQuality get_quality()
public void set_quality(SkinQuality value)
public bool get_updateWhenOffscreen()
public void set_updateWhenOffscreen(bool value)
public bool get_forceMatrixRecalculationPerRender()
public void set_forceMatrixRecalculationPerRender(bool value)
public Transform get_rootBone()
public void set_rootBone(Transform value)
public Transform[] get_bones()
public void set_bones(Transform[] value)
public Mesh get_sharedMesh()
public void set_sharedMesh(Mesh value)
public bool get_skinnedMotionVectors()
public void set_skinnedMotionVectors(bool value)
public float GetBlendShapeWeight(int index)
public void SetBlendShapeWeight(int index, float value)
public void BakeMesh(Mesh mesh)
public void BakeMesh(Mesh mesh, bool useScale)
public GraphicsBuffer GetVertexBuffer()
public GraphicsBuffer GetPreviousVertexBuffer()
private GraphicsBuffer GetVertexBufferImpl()
private GraphicsBuffer GetPreviousVertexBufferImpl()
public Target get_vertexBufferTarget()
public void set_vertexBufferTarget(Target value)
}
public UnityEngine.SkinQuality : Enum {
public int value__
public SkinQuality Auto
public SkinQuality Bone1
public SkinQuality Bone2
public SkinQuality Bone4
}
public UnityEngine.SkinWeights : Enum {
public int value__
public SkinWeights OneBone
public SkinWeights TwoBones
public SkinWeights FourBones
public SkinWeights Unlimited
}
public UnityEngine.Skybox : Behaviour {
public Material material
public Material get_material()
public void set_material(Material value)
}
public UnityEngine.SleepTimeout : object {
public int NeverSleep
public int SystemSetting
}
public UnityEngine.SnapAxis : Enum {
public byte value__
public SnapAxis None
public SnapAxis X
public SnapAxis Y
public SnapAxis Z
public SnapAxis All
}
internal UnityEngine.SnapAxisFilter : ValueType {
private SnapAxis X
private SnapAxis Y
private SnapAxis Z
public SnapAxisFilter all
private SnapAxis m_Mask
public float x
public float y
public float z
public int active
public float Item
public float get_x()
public float get_y()
public float get_z()
public void .ctor(Vector3 v)
public void .ctor(SnapAxis axis)
public string ToString()
public int get_active()
public Vector3 op_Implicit(SnapAxisFilter mask)
public SnapAxisFilter op_Explicit(Vector3 v)
public SnapAxis op_Explicit(SnapAxisFilter mask)
public SnapAxisFilter op_BitwiseOr(SnapAxisFilter left, SnapAxisFilter right)
public SnapAxisFilter op_BitwiseAnd(SnapAxisFilter left, SnapAxisFilter right)
public SnapAxisFilter op_ExclusiveOr(SnapAxisFilter left, SnapAxisFilter right)
public SnapAxisFilter op_OnesComplement(SnapAxisFilter left)
public Vector3 op_Multiply(SnapAxisFilter mask, float value)
public Vector3 op_Multiply(SnapAxisFilter mask, Vector3 right)
public Vector3 op_Multiply(Quaternion rotation, SnapAxisFilter mask)
public bool op_Equality(SnapAxisFilter left, SnapAxisFilter right)
public bool op_Inequality(SnapAxisFilter left, SnapAxisFilter right)
public float get_Item(int i)
public void set_Item(int i, float value)
public bool Equals(SnapAxisFilter other)
public bool Equals(object obj)
public int GetHashCode()
}
public UnityEngine.Snapping : object {
internal bool IsCardinalDirection(Vector3 direction)
public float Snap(float val, float snap)
public Vector2 Snap(Vector2 val, Vector2 snap)
public Vector3 Snap(Vector3 val, Vector3 snap, SnapAxis axis)
}
public UnityEngine.SortingLayer : ValueType {
private int m_Id
public int id
public string name
public int value
public SortingLayer[] layers
public int get_id()
public string get_name()
public int get_value()
public SortingLayer[] get_layers()
private Int32[] GetSortingLayerIDsInternal()
public int GetLayerValueFromID(int id)
public int GetLayerValueFromName(string name)
public int NameToID(string name)
public string IDToName(int id)
public bool IsValid(int id)
}
public UnityEngine.Space : Enum {
public int value__
public Space World
public Space Self
}
public UnityEngine.SpaceAttribute : PropertyAttribute {
public float height
public void .ctor(float height)
}
public UnityEngine.SparseTexture : Texture {
public int tileWidth
public int tileHeight
public bool isCreated
public int get_tileWidth()
public int get_tileHeight()
public bool get_isCreated()
private void Internal_Create(SparseTexture mono, int width, int height, GraphicsFormat format, TextureColorSpace colorSpace, int mipCount)
public void UpdateTile(int tileX, int tileY, int miplevel, Color32[] data)
public void UpdateTileRaw(int tileX, int tileY, int miplevel, Byte[] data)
public void UnloadTile(int tileX, int tileY, int miplevel)
internal bool ValidateFormat(TextureFormat format, int width, int height)
internal bool ValidateFormat(GraphicsFormat format, int width, int height)
internal bool ValidateSize(int width, int height, GraphicsFormat format)
private void ValidateIsNotCrunched(TextureFormat textureFormat)
public void .ctor(int width, int height, DefaultFormat format, int mipCount)
public void .ctor(int width, int height, GraphicsFormat format, int mipCount)
public void .ctor(int width, int height, TextureFormat textureFormat, int mipCount)
public void .ctor(int width, int height, TextureFormat textureFormat, int mipCount, bool linear)
}
internal UnityEngine.SpookyHash : object {
private bool AllowUnalignedRead
private int k_NumVars
private int k_BlockSize
private int k_BufferSize
private ulong k_DeadBeefConst
private bool AttemptDetectAllowUnalignedRead()
public void Hash(Void* message, ulong length, UInt64* hash1, UInt64* hash2)
private void End(UInt64* data, UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3, UInt64& h4, UInt64& h5, UInt64& h6, UInt64& h7, UInt64& h8, UInt64& h9, UInt64& h10, UInt64& h11)
private void EndPartial(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3, UInt64& h4, UInt64& h5, UInt64& h6, UInt64& h7, UInt64& h8, UInt64& h9, UInt64& h10, UInt64& h11)
private void Rot64(UInt64& x, int k)
private void Short(Void* message, ulong length, UInt64* hash1, UInt64* hash2)
private void ShortMix(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3)
private void ShortEnd(UInt64& h0, UInt64& h1, UInt64& h2, UInt64& h3)
private void Mix(UInt64* data, UInt64& s0, UInt64& s1, UInt64& s2, UInt64& s3, UInt64& s4, UInt64& s5, UInt64& s6, UInt64& s7, UInt64& s8, UInt64& s9, UInt64& s10, UInt64& s11)
private void memset(Void* dst, int value, ulong numberOfBytes)
}
public UnityEngine.Sprite : Object {
public Bounds bounds
public Rect rect
public Vector4 border
public Texture2D texture
public float pixelsPerUnit
public float spriteAtlasTextureScale
public Texture2D associatedAlphaSplitTexture
public Vector2 pivot
public bool packed
public SpritePackingMode packingMode
public SpritePackingRotation packingRotation
public Rect textureRect
public Vector2 textureRectOffset
public Vector2[] vertices
public UInt16[] triangles
public Vector2[] uv
internal int GetPackingMode()
internal int GetPackingRotation()
internal int GetPacked()
internal Rect GetTextureRect()
internal Vector2 GetTextureRectOffset()
internal Vector4 GetInnerUVs()
internal Vector4 GetOuterUVs()
internal Vector4 GetPadding()
internal Sprite CreateSpriteWithoutTextureScripting(Rect rect, Vector2 pivot, float pixelsToUnits, Texture2D texture)
internal Sprite CreateSprite(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape)
public Bounds get_bounds()
public Rect get_rect()
public Vector4 get_border()
public Texture2D get_texture()
internal Texture2D GetSecondaryTexture(int index)
public float get_pixelsPerUnit()
public float get_spriteAtlasTextureScale()
public Texture2D get_associatedAlphaSplitTexture()
public Vector2 get_pivot()
public bool get_packed()
public SpritePackingMode get_packingMode()
public SpritePackingRotation get_packingRotation()
public Rect get_textureRect()
public Vector2 get_textureRectOffset()
public Vector2[] get_vertices()
public UInt16[] get_triangles()
public Vector2[] get_uv()
public int GetPhysicsShapeCount()
public int GetPhysicsShapePointCount(int shapeIdx)
private int Internal_GetPhysicsShapePointCount(int shapeIdx)
public int GetPhysicsShape(int shapeIdx, List`1<Vector2> physicsShape)
private void GetPhysicsShapeImpl(Sprite sprite, int shapeIdx, List`1<Vector2> physicsShape)
public void OverridePhysicsShape(IList`1<Vector2[]> physicsShapes)
private void OverridePhysicsShapeCount(Sprite sprite, int physicsShapeCount)
private void OverridePhysicsShape(Sprite sprite, Vector2[] physicsShape, int idx)
public void OverrideGeometry(Vector2[] vertices, UInt16[] triangles)
internal Sprite Create(Rect rect, Vector2 pivot, float pixelsToUnits, Texture2D texture)
internal Sprite Create(Rect rect, Vector2 pivot, float pixelsToUnits)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4 border)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, UInt32 extrude)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit)
public Sprite Create(Texture2D texture, Rect rect, Vector2 pivot)
private void GetTextureRect_Injected(Rect& ret)
private void GetTextureRectOffset_Injected(Vector2& ret)
private void GetInnerUVs_Injected(Vector4& ret)
private void GetOuterUVs_Injected(Vector4& ret)
private void GetPadding_Injected(Vector4& ret)
private Sprite CreateSpriteWithoutTextureScripting_Injected(Rect& rect, Vector2& pivot, float pixelsToUnits, Texture2D texture)
private Sprite CreateSprite_Injected(Texture2D texture, Rect& rect, Vector2& pivot, float pixelsPerUnit, UInt32 extrude, SpriteMeshType meshType, Vector4& border, bool generateFallbackPhysicsShape)
private void get_bounds_Injected(Bounds& ret)
private void get_rect_Injected(Rect& ret)
private void get_border_Injected(Vector4& ret)
private void get_pivot_Injected(Vector2& ret)
}
public UnityEngine.SpriteAlignment : Enum {
public int value__
public SpriteAlignment Center
public SpriteAlignment TopLeft
public SpriteAlignment TopCenter
public SpriteAlignment TopRight
public SpriteAlignment LeftCenter
public SpriteAlignment RightCenter
public SpriteAlignment BottomLeft
public SpriteAlignment BottomCenter
public SpriteAlignment BottomRight
public SpriteAlignment Custom
}
public UnityEngine.SpriteDrawMode : Enum {
public int value__
public SpriteDrawMode Simple
public SpriteDrawMode Sliced
public SpriteDrawMode Tiled
}
public UnityEngine.SpriteMaskInteraction : Enum {
public int value__
public SpriteMaskInteraction None
public SpriteMaskInteraction VisibleInsideMask
public SpriteMaskInteraction VisibleOutsideMask
}
public UnityEngine.SpriteMeshType : Enum {
public int value__
public SpriteMeshType FullRect
public SpriteMeshType Tight
}
public UnityEngine.SpritePackingMode : Enum {
public int value__
public SpritePackingMode Tight
public SpritePackingMode Rectangle
}
public UnityEngine.SpritePackingRotation : Enum {
public int value__
public SpritePackingRotation None
public SpritePackingRotation FlipHorizontal
public SpritePackingRotation FlipVertical
public SpritePackingRotation Rotate180
public SpritePackingRotation Any
}
public UnityEngine.SpriteRenderer : Renderer {
private UnityEvent`1<SpriteRenderer> m_SpriteChangeEvent
internal bool shouldSupportTiling
public Sprite sprite
public SpriteDrawMode drawMode
public Vector2 size
public float adaptiveModeThreshold
public SpriteTileMode tileMode
public Color color
public SpriteMaskInteraction maskInteraction
public bool flipX
public bool flipY
public SpriteSortPoint spriteSortPoint
public void RegisterSpriteChangeCallback(UnityAction`1<SpriteRenderer> callback)
public void UnregisterSpriteChangeCallback(UnityAction`1<SpriteRenderer> callback)
private void InvokeSpriteChanged()
internal bool get_shouldSupportTiling()
public Sprite get_sprite()
public void set_sprite(Sprite value)
public SpriteDrawMode get_drawMode()
public void set_drawMode(SpriteDrawMode value)
public Vector2 get_size()
public void set_size(Vector2 value)
public float get_adaptiveModeThreshold()
public void set_adaptiveModeThreshold(float value)
public SpriteTileMode get_tileMode()
public void set_tileMode(SpriteTileMode value)
public Color get_color()
public void set_color(Color value)
public SpriteMaskInteraction get_maskInteraction()
public void set_maskInteraction(SpriteMaskInteraction value)
public bool get_flipX()
public void set_flipX(bool value)
public bool get_flipY()
public void set_flipY(bool value)
public SpriteSortPoint get_spriteSortPoint()
public void set_spriteSortPoint(SpriteSortPoint value)
internal Bounds Internal_GetSpriteBounds(SpriteDrawMode mode)
internal Bounds GetSpriteBounds()
private void get_size_Injected(Vector2& ret)
private void set_size_Injected(Vector2& value)
private void get_color_Injected(Color& ret)
private void set_color_Injected(Color& value)
private void Internal_GetSpriteBounds_Injected(SpriteDrawMode mode, Bounds& ret)
}
public UnityEngine.Sprites.DataUtility : object {
public Vector4 GetInnerUV(Sprite sprite)
public Vector4 GetOuterUV(Sprite sprite)
public Vector4 GetPadding(Sprite sprite)
public Vector2 GetMinSize(Sprite sprite)
}
public UnityEngine.SpriteSortPoint : Enum {
public int value__
public SpriteSortPoint Center
public SpriteSortPoint Pivot
}
public UnityEngine.SpriteTileMode : Enum {
public int value__
public SpriteTileMode Continuous
public SpriteTileMode Adaptive
}
public UnityEngine.StackTraceLogType : Enum {
public int value__
public StackTraceLogType None
public StackTraceLogType ScriptOnly
public StackTraceLogType Full
}
public UnityEngine.StackTraceUtility : object {
private string projectFolder
internal void SetProjectFolder(string folder)
public string ExtractStackTrace()
public string ExtractStringFromException(object exception)
internal void ExtractStringFromExceptionInternal(object exceptiono, String& message, String& stackTrace)
internal string ExtractFormattedStackTrace(StackTrace stackTrace)
}
internal UnityEngine.StaticBatchingHelper : ValueType {
internal Mesh InternalCombineVertices(MeshInstance[] meshes, string meshName)
internal void InternalCombineIndices(SubMeshInstance[] submeshes, Mesh combinedMesh)
internal bool IsMeshBatchable(Mesh mesh)
}
public UnityEngine.StaticBatchingUtility : object {
internal ProfilerMarker s_CombineMarker
internal ProfilerMarker s_SortMarker
internal ProfilerMarker s_MakeBatchMarker
public void Combine(GameObject staticBatchRoot)
public void Combine(GameObject[] gos, GameObject staticBatchRoot)
}
public UnityEngine.StereoTargetEyeMask : Enum {
public int value__
public StereoTargetEyeMask None
public StereoTargetEyeMask Left
public StereoTargetEyeMask Right
public StereoTargetEyeMask Both
}
internal UnityEngine.SystemClock : object {
private DateTime s_Epoch
public DateTime now
public DateTime get_now()
public long ToUnixTimeMilliseconds(DateTime date)
public long ToUnixTimeSeconds(DateTime date)
}
public UnityEngine.SystemInfo : object {
public string unsupportedIdentifier
public float batteryLevel
public BatteryStatus batteryStatus
public string operatingSystem
public OperatingSystemFamily operatingSystemFamily
public string processorType
public int processorFrequency
public int processorCount
public int systemMemorySize
public string deviceUniqueIdentifier
public string deviceName
public string deviceModel
public bool supportsAccelerometer
public bool supportsGyroscope
public bool supportsLocationService
public bool supportsVibration
public bool supportsAudio
public DeviceType deviceType
public int graphicsMemorySize
public string graphicsDeviceName
public string graphicsDeviceVendor
public int graphicsDeviceID
public int graphicsDeviceVendorID
public GraphicsDeviceType graphicsDeviceType
public bool graphicsUVStartsAtTop
public string graphicsDeviceVersion
public int graphicsShaderLevel
public bool graphicsMultiThreaded
public RenderingThreadingMode renderingThreadingMode
public bool hasHiddenSurfaceRemovalOnGPU
public bool hasDynamicUniformArrayIndexingInFragmentShaders
public bool supportsShadows
public bool supportsRawShadowDepthSampling
public bool supportsRenderTextures
public bool supportsMotionVectors
public bool supportsRenderToCubemap
public bool supportsImageEffects
public bool supports3DTextures
public bool supportsCompressed3DTextures
public bool supports2DArrayTextures
public bool supports3DRenderTextures
public bool supportsCubemapArrayTextures
public bool supportsAnisotropicFilter
public CopyTextureSupport copyTextureSupport
public bool supportsComputeShaders
public bool supportsGeometryShaders
public bool supportsTessellationShaders
public bool supportsRenderTargetArrayIndexFromVertexShader
public bool supportsInstancing
public bool supportsHardwareQuadTopology
public bool supports32bitsIndexBuffer
public bool supportsSparseTextures
public int supportedRenderTargetCount
public bool supportsSeparatedRenderTargetsBlend
public int supportedRandomWriteTargetCount
public int supportsMultisampledTextures
public bool supportsMultisampled2DArrayTextures
public bool supportsMultisampleAutoResolve
public int supportsTextureWrapMirrorOnce
public bool usesReversedZBuffer
public int supportsStencil
public NPOTSupport npotSupport
public int maxTextureSize
public int maxTexture3DSize
public int maxTextureArraySlices
public int maxCubemapSize
public int maxAnisotropyLevel
internal int maxRenderTextureSize
public int maxComputeBufferInputsVertex
public int maxComputeBufferInputsFragment
public int maxComputeBufferInputsGeometry
public int maxComputeBufferInputsDomain
public int maxComputeBufferInputsHull
public int maxComputeBufferInputsCompute
public int maxComputeWorkGroupSize
public int maxComputeWorkGroupSizeX
public int maxComputeWorkGroupSizeY
public int maxComputeWorkGroupSizeZ
public int computeSubGroupSize
public bool supportsAsyncCompute
public bool supportsGpuRecorder
public bool supportsGraphicsFence
public bool supportsAsyncGPUReadback
public bool supportsRayTracing
public bool supportsSetConstantBuffer
public int constantBufferOffsetAlignment
public long maxGraphicsBufferSize
public bool minConstantBufferOffsetAlignment
public bool hasMipMaxLevel
public bool supportsMipStreaming
public int graphicsPixelFillrate
public bool usesLoadStoreActions
public HDRDisplaySupportFlags hdrDisplaySupportFlags
public bool supportsConservativeRaster
public bool supportsMultiview
public bool supportsStoreAndResolveAction
public bool supportsMultisampleResolveDepth
public bool supportsVertexPrograms
public bool supportsGPUFence
public float get_batteryLevel()
public BatteryStatus get_batteryStatus()
public string get_operatingSystem()
public OperatingSystemFamily get_operatingSystemFamily()
public string get_processorType()
public int get_processorFrequency()
public int get_processorCount()
public int get_systemMemorySize()
public string get_deviceUniqueIdentifier()
public string get_deviceName()
public string get_deviceModel()
public bool get_supportsAccelerometer()
public bool get_supportsGyroscope()
public bool get_supportsLocationService()
public bool get_supportsVibration()
public bool get_supportsAudio()
public DeviceType get_deviceType()
public int get_graphicsMemorySize()
public string get_graphicsDeviceName()
public string get_graphicsDeviceVendor()
public int get_graphicsDeviceID()
public int get_graphicsDeviceVendorID()
public GraphicsDeviceType get_graphicsDeviceType()
public bool get_graphicsUVStartsAtTop()
public string get_graphicsDeviceVersion()
public int get_graphicsShaderLevel()
public bool get_graphicsMultiThreaded()
public RenderingThreadingMode get_renderingThreadingMode()
public bool get_hasHiddenSurfaceRemovalOnGPU()
public bool get_hasDynamicUniformArrayIndexingInFragmentShaders()
public bool get_supportsShadows()
public bool get_supportsRawShadowDepthSampling()
public bool get_supportsRenderTextures()
public bool get_supportsMotionVectors()
public bool get_supportsRenderToCubemap()
public bool get_supportsImageEffects()
public bool get_supports3DTextures()
public bool get_supportsCompressed3DTextures()
public bool get_supports2DArrayTextures()
public bool get_supports3DRenderTextures()
public bool get_supportsCubemapArrayTextures()
public bool get_supportsAnisotropicFilter()
public CopyTextureSupport get_copyTextureSupport()
public bool get_supportsComputeShaders()
public bool get_supportsGeometryShaders()
public bool get_supportsTessellationShaders()
public bool get_supportsRenderTargetArrayIndexFromVertexShader()
public bool get_supportsInstancing()
public bool get_supportsHardwareQuadTopology()
public bool get_supports32bitsIndexBuffer()
public bool get_supportsSparseTextures()
public int get_supportedRenderTargetCount()
public bool get_supportsSeparatedRenderTargetsBlend()
public int get_supportedRandomWriteTargetCount()
public int get_supportsMultisampledTextures()
public bool get_supportsMultisampled2DArrayTextures()
public bool get_supportsMultisampleAutoResolve()
public int get_supportsTextureWrapMirrorOnce()
public bool get_usesReversedZBuffer()
public int get_supportsStencil()
private bool IsValidEnumValue(Enum value)
public bool SupportsRenderTextureFormat(RenderTextureFormat format)
public bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format)
public bool SupportsRandomWriteOnRenderTextureFormat(RenderTextureFormat format)
public bool SupportsTextureFormat(TextureFormat format)
public bool SupportsVertexAttributeFormat(VertexAttributeFormat format, int dimension)
public NPOTSupport get_npotSupport()
public int get_maxTextureSize()
public int get_maxTexture3DSize()
public int get_maxTextureArraySlices()
public int get_maxCubemapSize()
public int get_maxAnisotropyLevel()
internal int get_maxRenderTextureSize()
public int get_maxComputeBufferInputsVertex()
public int get_maxComputeBufferInputsFragment()
public int get_maxComputeBufferInputsGeometry()
public int get_maxComputeBufferInputsDomain()
public int get_maxComputeBufferInputsHull()
public int get_maxComputeBufferInputsCompute()
public int get_maxComputeWorkGroupSize()
public int get_maxComputeWorkGroupSizeX()
public int get_maxComputeWorkGroupSizeY()
public int get_maxComputeWorkGroupSizeZ()
public int get_computeSubGroupSize()
public bool get_supportsAsyncCompute()
public bool get_supportsGpuRecorder()
public bool get_supportsGraphicsFence()
public bool get_supportsAsyncGPUReadback()
public bool get_supportsRayTracing()
public bool get_supportsSetConstantBuffer()
public int get_constantBufferOffsetAlignment()
public long get_maxGraphicsBufferSize()
public bool get_minConstantBufferOffsetAlignment()
public bool get_hasMipMaxLevel()
public bool get_supportsMipStreaming()
public int get_graphicsPixelFillrate()
public bool get_usesLoadStoreActions()
public HDRDisplaySupportFlags get_hdrDisplaySupportFlags()
public bool get_supportsConservativeRaster()
public bool get_supportsMultiview()
public bool get_supportsStoreAndResolveAction()
public bool get_supportsMultisampleResolveDepth()
public bool get_supportsVertexPrograms()
private float GetBatteryLevel()
private BatteryStatus GetBatteryStatus()
private string GetOperatingSystem()
private OperatingSystemFamily GetOperatingSystemFamily()
private string GetProcessorType()
private int GetProcessorFrequencyMHz()
private int GetProcessorCount()
private int GetPhysicalMemoryMB()
private string GetDeviceUniqueIdentifier()
private string GetDeviceName()
private string GetDeviceModel()
private bool SupportsAccelerometer()
private bool IsGyroAvailable()
private bool SupportsLocationService()
private bool SupportsVibration()
private bool SupportsAudio()
private DeviceType GetDeviceType()
private int GetGraphicsMemorySize()
private string GetGraphicsDeviceName()
private string GetGraphicsDeviceVendor()
private int GetGraphicsDeviceID()
private int GetGraphicsDeviceVendorID()
private GraphicsDeviceType GetGraphicsDeviceType()
private bool GetGraphicsUVStartsAtTop()
private string GetGraphicsDeviceVersion()
private int GetGraphicsShaderLevel()
private bool GetGraphicsMultiThreaded()
private RenderingThreadingMode GetRenderingThreadingMode()
private bool HasHiddenSurfaceRemovalOnGPU()
private bool HasDynamicUniformArrayIndexingInFragmentShaders()
private bool SupportsShadows()
private bool SupportsRawShadowDepthSampling()
private bool SupportsMotionVectors()
private bool Supports3DTextures()
private bool SupportsCompressed3DTextures()
private bool Supports2DArrayTextures()
private bool Supports3DRenderTextures()
private bool SupportsCubemapArrayTextures()
private bool SupportsAnisotropicFilter()
private CopyTextureSupport GetCopyTextureSupport()
private bool SupportsComputeShaders()
private bool SupportsGeometryShaders()
private bool SupportsTessellationShaders()
private bool SupportsRenderTargetArrayIndexFromVertexShader()
private bool SupportsInstancing()
private bool SupportsHardwareQuadTopology()
private bool Supports32bitsIndexBuffer()
private bool SupportsSparseTextures()
private int SupportedRenderTargetCount()
private bool SupportsSeparatedRenderTargetsBlend()
private int SupportedRandomWriteTargetCount()
private int MaxComputeBufferInputsVertex()
private int MaxComputeBufferInputsFragment()
private int MaxComputeBufferInputsGeometry()
private int MaxComputeBufferInputsDomain()
private int MaxComputeBufferInputsHull()
private int MaxComputeBufferInputsCompute()
private int SupportsMultisampledTextures()
private bool SupportsMultisampled2DArrayTextures()
private bool SupportsMultisampleAutoResolve()
private int SupportsTextureWrapMirrorOnce()
private bool UsesReversedZBuffer()
private bool HasRenderTextureNative(RenderTextureFormat format)
private bool SupportsBlendingOnRenderTextureFormatNative(RenderTextureFormat format)
private bool SupportsRandomWriteOnRenderTextureFormatNative(RenderTextureFormat format)
private bool SupportsTextureFormatNative(TextureFormat format)
private bool SupportsVertexAttributeFormatNative(VertexAttributeFormat format, int dimension)
private NPOTSupport GetNPOTSupport()
private int GetMaxTextureSize()
private int GetMaxTexture3DSize()
private int GetMaxTextureArraySlices()
private int GetMaxCubemapSize()
private int GetMaxAnisotropyLevel()
private int GetMaxRenderTextureSize()
private int GetMaxComputeWorkGroupSize()
private int GetMaxComputeWorkGroupSizeX()
private int GetMaxComputeWorkGroupSizeY()
private int GetMaxComputeWorkGroupSizeZ()
private int GetComputeSubGroupSize()
private bool SupportsAsyncCompute()
private bool SupportsGpuRecorder()
private bool SupportsGPUFence()
private bool SupportsAsyncGPUReadback()
private bool SupportsRayTracing()
private bool SupportsSetConstantBuffer()
private int MinConstantBufferOffsetAlignment()
private long MaxGraphicsBufferSize()
private bool HasMipMaxLevel()
private bool SupportsMipStreaming()
public bool IsFormatSupported(GraphicsFormat format, FormatUsage usage)
public GraphicsFormat GetCompatibleFormat(GraphicsFormat format, FormatUsage usage)
public GraphicsFormat GetGraphicsFormat(DefaultFormat format)
public int GetRenderTextureSupportedMSAASampleCount(RenderTextureDescriptor desc)
private bool UsesLoadStoreActions()
private HDRDisplaySupportFlags GetHDRDisplaySupportFlags()
private bool SupportsConservativeRaster()
private bool SupportsMultiview()
private bool SupportsStoreAndResolveAction()
private bool SupportsMultisampleResolveDepth()
public bool get_supportsGPUFence()
private int GetRenderTextureSupportedMSAASampleCount_Injected(RenderTextureDescriptor& desc)
}
public UnityEngine.SystemLanguage : Enum {
public int value__
public SystemLanguage Afrikaans
public SystemLanguage Arabic
public SystemLanguage Basque
public SystemLanguage Belarusian
public SystemLanguage Bulgarian
public SystemLanguage Catalan
public SystemLanguage Chinese
public SystemLanguage Czech
public SystemLanguage Danish
public SystemLanguage Dutch
public SystemLanguage English
public SystemLanguage Estonian
public SystemLanguage Faroese
public SystemLanguage Finnish
public SystemLanguage French
public SystemLanguage German
public SystemLanguage Greek
public SystemLanguage Hebrew
public SystemLanguage Icelandic
public SystemLanguage Indonesian
public SystemLanguage Italian
public SystemLanguage Japanese
public SystemLanguage Korean
public SystemLanguage Latvian
public SystemLanguage Lithuanian
public SystemLanguage Norwegian
public SystemLanguage Polish
public SystemLanguage Portuguese
public SystemLanguage Romanian
public SystemLanguage Russian
public SystemLanguage SerboCroatian
public SystemLanguage Slovak
public SystemLanguage Slovenian
public SystemLanguage Spanish
public SystemLanguage Swedish
public SystemLanguage Thai
public SystemLanguage Turkish
public SystemLanguage Ukrainian
public SystemLanguage Vietnamese
public SystemLanguage ChineseSimplified
public SystemLanguage ChineseTraditional
public SystemLanguage Unknown
public SystemLanguage Hungarian
}
public UnityEngine.TestTools.Coverage : object {
public bool enabled
public bool get_enabled()
public void set_enabled(bool value)
private CoveredSequencePoint[] GetSequencePointsFor_Internal(MethodBase method)
private void ResetFor_Internal(MethodBase method)
private CoveredMethodStats GetStatsFor_Internal(MethodBase method)
public CoveredSequencePoint[] GetSequencePointsFor(MethodBase method)
public CoveredMethodStats GetStatsFor(MethodBase method)
public CoveredMethodStats[] GetStatsFor(MethodBase[] methods)
public CoveredMethodStats[] GetStatsFor(Type type)
public CoveredMethodStats[] GetStatsForAllCoveredMethods()
public void ResetFor(MethodBase method)
public void ResetAll()
private void GetStatsFor_Internal_Injected(MethodBase method, CoveredMethodStats& ret)
}
public UnityEngine.TestTools.CoveredMethodStats : ValueType {
public MethodBase method
public int totalSequencePoints
public int uncoveredSequencePoints
private string GetTypeDisplayName(Type t)
public string ToString()
}
public UnityEngine.TestTools.CoveredSequencePoint : ValueType {
public MethodBase method
public UInt32 ilOffset
public UInt32 hitCount
public string filename
public UInt32 line
public UInt32 column
}
public UnityEngine.TexGenMode : Enum {
public int value__
public TexGenMode None
public TexGenMode SphereMap
public TexGenMode Object
public TexGenMode EyeLinear
public TexGenMode CubeReflect
public TexGenMode CubeNormal
}
public UnityEngine.TextAreaAttribute : PropertyAttribute {
public int minLines
public int maxLines
public void .ctor(int minLines, int maxLines)
}
public UnityEngine.TextAsset : Object {
public Byte[] bytes
public string text
public long dataSize
public Byte[] get_bytes()
private Byte[] GetPreviewBytes(int maxByteCount)
private void Internal_CreateInstance(TextAsset self, string text)
private IntPtr GetDataPtr()
private long GetDataSize()
public string get_text()
public long get_dataSize()
public string ToString()
public void .ctor(string text)
internal void .ctor(CreateOptions options, string text)
public NativeArray`1<T> GetData()
internal string GetPreview(int maxChars)
internal string DecodeString(Byte[] bytes)
}
public UnityEngine.Texture : Object {
public int GenerateAllMips
public int masterTextureLimit
public int mipmapCount
public AnisotropicFiltering anisotropicFiltering
public GraphicsFormat graphicsFormat
public int width
public int height
public TextureDimension dimension
public bool isReadable
public TextureWrapMode wrapMode
public TextureWrapMode wrapModeU
public TextureWrapMode wrapModeV
public TextureWrapMode wrapModeW
public FilterMode filterMode
public int anisoLevel
public float mipMapBias
public Vector2 texelSize
public UInt32 updateCount
internal ColorSpace activeTextureColorSpace
public bool isDataSRGB
public ulong totalTextureMemory
public ulong desiredTextureMemory
public ulong targetTextureMemory
public ulong currentTextureMemory
public ulong nonStreamingTextureMemory
public ulong streamingMipmapUploadCount
public ulong streamingRendererCount
public ulong streamingTextureCount
public ulong nonStreamingTextureCount
public ulong streamingTexturePendingLoadCount
public ulong streamingTextureLoadingCount
public bool streamingTextureForceLoadAll
public bool streamingTextureDiscardUnusedMips
public bool allowThreadedTextureCreation
public int get_masterTextureLimit()
public void set_masterTextureLimit(int value)
public int get_mipmapCount()
public AnisotropicFiltering get_anisotropicFiltering()
public void set_anisotropicFiltering(AnisotropicFiltering value)
public void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax)
public GraphicsFormat get_graphicsFormat()
private int GetDataWidth()
private int GetDataHeight()
private TextureDimension GetDimension()
public int get_width()
public void set_width(int value)
public int get_height()
public void set_height(int value)
public TextureDimension get_dimension()
public void set_dimension(TextureDimension value)
public bool get_isReadable()
public TextureWrapMode get_wrapMode()
public void set_wrapMode(TextureWrapMode value)
public TextureWrapMode get_wrapModeU()
public void set_wrapModeU(TextureWrapMode value)
public TextureWrapMode get_wrapModeV()
public void set_wrapModeV(TextureWrapMode value)
public TextureWrapMode get_wrapModeW()
public void set_wrapModeW(TextureWrapMode value)
public FilterMode get_filterMode()
public void set_filterMode(FilterMode value)
public int get_anisoLevel()
public void set_anisoLevel(int value)
public float get_mipMapBias()
public void set_mipMapBias(float value)
public Vector2 get_texelSize()
public IntPtr GetNativeTexturePtr()
public int GetNativeTextureID()
public UInt32 get_updateCount()
public void IncrementUpdateCount()
private int Internal_GetActiveTextureColorSpace()
internal ColorSpace get_activeTextureColorSpace()
private TextureColorSpace Internal_GetStoredColorSpace()
public bool get_isDataSRGB()
public ulong get_totalTextureMemory()
public ulong get_desiredTextureMemory()
public ulong get_targetTextureMemory()
public ulong get_currentTextureMemory()
public ulong get_nonStreamingTextureMemory()
public ulong get_streamingMipmapUploadCount()
public ulong get_streamingRendererCount()
public ulong get_streamingTextureCount()
public ulong get_nonStreamingTextureCount()
public ulong get_streamingTexturePendingLoadCount()
public ulong get_streamingTextureLoadingCount()
public void SetStreamingTextureMaterialDebugProperties()
public bool get_streamingTextureForceLoadAll()
public void set_streamingTextureForceLoadAll(bool value)
public bool get_streamingTextureDiscardUnusedMips()
public void set_streamingTextureDiscardUnusedMips(bool value)
public bool get_allowThreadedTextureCreation()
public void set_allowThreadedTextureCreation(bool value)
internal ulong GetPixelDataSize(int mipLevel, int element)
internal ulong GetPixelDataOffset(int mipLevel, int element)
internal TextureColorSpace GetTextureColorSpace(bool linear)
internal TextureColorSpace GetTextureColorSpace(GraphicsFormat format)
internal bool ValidateFormat(RenderTextureFormat format)
internal bool ValidateFormat(TextureFormat format)
internal bool ValidateFormat(GraphicsFormat format, FormatUsage usage)
internal UnityException CreateNonReadableException(Texture t)
internal UnityException CreateNativeArrayLengthOverflowException()
private void get_texelSize_Injected(Vector2& ret)
}
public UnityEngine.Texture2D : Texture {
internal int streamingMipmapsPriorityMin
internal int streamingMipmapsPriorityMax
public TextureFormat format
public bool ignoreMipmapLimit
public Texture2D whiteTexture
public Texture2D blackTexture
public Texture2D redTexture
public Texture2D grayTexture
public Texture2D linearGrayTexture
public Texture2D normalTexture
public bool isReadable
public bool vtOnly
internal bool isPreProcessed
public bool streamingMipmaps
public int streamingMipmapsPriority
public int requestedMipmapLevel
public int minimumMipmapLevel
internal bool loadAllMips
public int calculatedMipmapLevel
public int desiredMipmapLevel
public int loadingMipmapLevel
public int loadedMipmapLevel
public TextureFormat get_format()
public bool get_ignoreMipmapLimit()
public void set_ignoreMipmapLimit(bool value)
public Texture2D get_whiteTexture()
public Texture2D get_blackTexture()
public Texture2D get_redTexture()
public Texture2D get_grayTexture()
public Texture2D get_linearGrayTexture()
public Texture2D get_normalTexture()
public void Compress(bool highQuality)
private bool Internal_CreateImpl(Texture2D mono, int w, int h, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
private void Internal_Create(Texture2D mono, int w, int h, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
public bool get_isReadable()
public bool get_vtOnly()
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
private bool ReinitializeImpl(int width, int height)
private void SetPixelImpl(int image, int mip, int x, int y, Color color)
private Color GetPixelImpl(int image, int mip, int x, int y)
private Color GetPixelBilinearImpl(int image, int mip, float u, float v)
private bool ReinitializeWithFormatImpl(int width, int height, GraphicsFormat format, bool hasMipMap)
private void ReadPixelsImpl(Rect source, int destX, int destY, bool recalculateMipMaps)
private void SetPixelsImpl(int x, int y, int w, int h, Color[] pixel, int miplevel, int frame)
private bool LoadRawTextureDataImpl(IntPtr data, ulong size)
private bool LoadRawTextureDataImplArray(Byte[] data)
private bool SetPixelDataImplArray(Array data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex)
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex)
private IntPtr GetWritableImageData(int frame)
private ulong GetRawImageDataSize()
private void GenerateAtlasImpl(Vector2[] sizes, int padding, int atlasSize, Rect[] rect)
internal bool get_isPreProcessed()
public bool get_streamingMipmaps()
public int get_streamingMipmapsPriority()
public int get_requestedMipmapLevel()
public void set_requestedMipmapLevel(int value)
public int get_minimumMipmapLevel()
public void set_minimumMipmapLevel(int value)
internal bool get_loadAllMips()
internal void set_loadAllMips(bool value)
public int get_calculatedMipmapLevel()
public int get_desiredMipmapLevel()
public int get_loadingMipmapLevel()
public int get_loadedMipmapLevel()
public void ClearRequestedMipmapLevel()
public bool IsRequestedMipmapLevelLoaded()
public void ClearMinimumMipmapLevel()
public void UpdateExternalTexture(IntPtr nativeTex)
private void SetAllPixels32(Color32[] colors, int miplevel)
private void SetBlockOfPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel)
public Byte[] GetRawTextureData()
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight, int miplevel)
public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight)
public Color32[] GetPixels32(int miplevel)
public Color32[] GetPixels32()
public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize, bool makeNoLongerReadable)
public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize)
public Rect[] PackTextures(Texture2D[] textures, int padding)
internal bool ValidateFormat(TextureFormat format, int width, int height)
internal bool ValidateFormat(GraphicsFormat format, int width, int height)
internal void .ctor(int width, int height, GraphicsFormat format, TextureCreationFlags flags, int mipCount, IntPtr nativeTex)
public void .ctor(int width, int height, DefaultFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, GraphicsFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, GraphicsFormat format, int mipCount, TextureCreationFlags flags)
internal void .ctor(int width, int height, TextureFormat textureFormat, int mipCount, bool linear, IntPtr nativeTex)
public void .ctor(int width, int height, TextureFormat textureFormat, int mipCount, bool linear)
public void .ctor(int width, int height, TextureFormat textureFormat, bool mipChain, bool linear)
public void .ctor(int width, int height, TextureFormat textureFormat, bool mipChain)
public void .ctor(int width, int height)
public Texture2D CreateExternalTexture(int width, int height, TextureFormat format, bool mipChain, bool linear, IntPtr nativeTex)
public void SetPixel(int x, int y, Color color)
public void SetPixel(int x, int y, Color color, int mipLevel)
public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors, int miplevel)
public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors)
public void SetPixels(Color[] colors, int miplevel)
public void SetPixels(Color[] colors)
public Color GetPixel(int x, int y)
public Color GetPixel(int x, int y, int mipLevel)
public Color GetPixelBilinear(float u, float v)
public Color GetPixelBilinear(float u, float v, int mipLevel)
public void LoadRawTextureData(IntPtr data, int size)
public void LoadRawTextureData(Byte[] data)
public void LoadRawTextureData(NativeArray`1<T> data)
public void SetPixelData(T[] data, int mipLevel, int sourceDataStartIndex)
public void SetPixelData(NativeArray`1<T> data, int mipLevel, int sourceDataStartIndex)
public NativeArray`1<T> GetPixelData(int mipLevel)
public NativeArray`1<T> GetRawTextureData()
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
public bool Reinitialize(int width, int height)
public bool Reinitialize(int width, int height, TextureFormat format, bool hasMipMap)
public bool Reinitialize(int width, int height, GraphicsFormat format, bool hasMipMap)
public bool Resize(int width, int height)
public bool Resize(int width, int height, TextureFormat format, bool hasMipMap)
public bool Resize(int width, int height, GraphicsFormat format, bool hasMipMap)
public void ReadPixels(Rect source, int destX, int destY, bool recalculateMipMaps)
public void ReadPixels(Rect source, int destX, int destY)
public bool GenerateAtlas(Vector2[] sizes, int padding, int atlasSize, List`1<Rect> results)
public void SetPixels32(Color32[] colors, int miplevel)
public void SetPixels32(Color32[] colors)
public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel)
public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors)
public Color[] GetPixels(int miplevel)
public Color[] GetPixels()
private void SetPixelImpl_Injected(int image, int mip, int x, int y, Color& color)
private void GetPixelImpl_Injected(int image, int mip, int x, int y, Color& ret)
private void GetPixelBilinearImpl_Injected(int image, int mip, float u, float v, Color& ret)
private void ReadPixelsImpl_Injected(Rect& source, int destX, int destY, bool recalculateMipMaps)
}
public UnityEngine.Texture2DArray : Texture {
public int allSlices
public int depth
public TextureFormat format
public bool isReadable
public int get_allSlices()
public int get_depth()
public TextureFormat get_format()
public bool get_isReadable()
private bool Internal_CreateImpl(Texture2DArray mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags)
private void Internal_Create(Texture2DArray mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public Color[] GetPixels(int arrayElement, int miplevel)
public Color[] GetPixels(int arrayElement)
private bool SetPixelDataImplArray(Array data, int mipLevel, int element, int elementSize, int dataArraySize, int sourceDataStartIndex)
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int element, int elementSize, int dataArraySize, int sourceDataStartIndex)
public Color32[] GetPixels32(int arrayElement, int miplevel)
public Color32[] GetPixels32(int arrayElement)
public void SetPixels(Color[] colors, int arrayElement, int miplevel)
public void SetPixels(Color[] colors, int arrayElement)
public void SetPixels32(Color32[] colors, int arrayElement, int miplevel)
public void SetPixels32(Color32[] colors, int arrayElement)
private IntPtr GetImageDataPointer()
internal bool ValidateFormat(TextureFormat format, int width, int height)
internal bool ValidateFormat(GraphicsFormat format, int width, int height)
public void .ctor(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, int mipCount, bool linear)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, bool linear)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
public void SetPixelData(T[] data, int mipLevel, int element, int sourceDataStartIndex)
public void SetPixelData(NativeArray`1<T> data, int mipLevel, int element, int sourceDataStartIndex)
public NativeArray`1<T> GetPixelData(int mipLevel, int element)
private void ValidateIsNotCrunched(TextureCreationFlags flags)
}
public UnityEngine.Texture3D : Texture {
public int depth
public TextureFormat format
public bool isReadable
public int get_depth()
public TextureFormat get_format()
public bool get_isReadable()
private void SetPixelImpl(int mip, int x, int y, int z, Color color)
private Color GetPixelImpl(int mip, int x, int y, int z)
private Color GetPixelBilinearImpl(int mip, float u, float v, float w)
private bool Internal_CreateImpl(Texture3D mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
private void Internal_Create(Texture3D mono, int w, int h, int d, int mipCount, GraphicsFormat format, TextureColorSpace colorSpace, TextureCreationFlags flags, IntPtr nativeTex)
public void UpdateExternalTexture(IntPtr nativeTex)
private void ApplyImpl(bool updateMipmaps, bool makeNoLongerReadable)
public Color[] GetPixels(int miplevel)
public Color[] GetPixels()
public Color32[] GetPixels32(int miplevel)
public Color32[] GetPixels32()
public void SetPixels(Color[] colors, int miplevel)
public void SetPixels(Color[] colors)
public void SetPixels32(Color32[] colors, int miplevel)
public void SetPixels32(Color32[] colors)
private bool SetPixelDataImplArray(Array data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex)
private bool SetPixelDataImpl(IntPtr data, int mipLevel, int elementSize, int dataArraySize, int sourceDataStartIndex)
private IntPtr GetImageDataPointer()
public void .ctor(int width, int height, int depth, DefaultFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags)
public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags, int mipCount)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, int mipCount)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, int mipCount, IntPtr nativeTex)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain)
public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, IntPtr nativeTex)
public Texture3D CreateExternalTexture(int width, int height, int depth, TextureFormat format, bool mipChain, IntPtr nativeTex)
public void Apply(bool updateMipmaps, bool makeNoLongerReadable)
public void Apply(bool updateMipmaps)
public void Apply()
public void SetPixel(int x, int y, int z, Color color)
public void SetPixel(int x, int y, int z, Color color, int mipLevel)
public Color GetPixel(int x, int y, int z)
public Color GetPixel(int x, int y, int z, int mipLevel)
public Color GetPixelBilinear(float u, float v, float w)
public Color GetPixelBilinear(float u, float v, float w, int mipLevel)
public void SetPixelData(T[] data, int mipLevel, int sourceDataStartIndex)
public void SetPixelData(NativeArray`1<T> data, int mipLevel, int sourceDataStartIndex)
public NativeArray`1<T> GetPixelData(int mipLevel)
private void ValidateIsNotCrunched(TextureCreationFlags flags)
private void SetPixelImpl_Injected(int mip, int x, int y, int z, Color& color)
private void GetPixelImpl_Injected(int mip, int x, int y, int z, Color& ret)
private void GetPixelBilinearImpl_Injected(int mip, float u, float v, float w, Color& ret)
}
internal UnityEngine.TextureColorSpace : Enum {
public int value__
public TextureColorSpace Linear
public TextureColorSpace sRGB
}
public UnityEngine.TextureFormat : Enum {
public int value__
public TextureFormat Alpha8
public TextureFormat ARGB4444
public TextureFormat RGB24
public TextureFormat RGBA32
public TextureFormat ARGB32
public TextureFormat RGB565
public TextureFormat R16
public TextureFormat DXT1
public TextureFormat DXT5
public TextureFormat RGBA4444
public TextureFormat BGRA32
public TextureFormat RHalf
public TextureFormat RGHalf
public TextureFormat RGBAHalf
public TextureFormat RFloat
public TextureFormat RGFloat
public TextureFormat RGBAFloat
public TextureFormat YUY2
public TextureFormat RGB9e5Float
public TextureFormat BC4
public TextureFormat BC5
public TextureFormat BC6H
public TextureFormat BC7
public TextureFormat DXT1Crunched
public TextureFormat DXT5Crunched
public TextureFormat PVRTC_RGB2
public TextureFormat PVRTC_RGBA2
public TextureFormat PVRTC_RGB4
public TextureFormat PVRTC_RGBA4
public TextureFormat ETC_RGB4
public TextureFormat EAC_R
public TextureFormat EAC_R_SIGNED
public TextureFormat EAC_RG
public TextureFormat EAC_RG_SIGNED
public TextureFormat ETC2_RGB
public TextureFormat ETC2_RGBA1
public TextureFormat ETC2_RGBA8
public TextureFormat ASTC_4x4
public TextureFormat ASTC_5x5
public TextureFormat ASTC_6x6
public TextureFormat ASTC_8x8
public TextureFormat ASTC_10x10
public TextureFormat ASTC_12x12
public TextureFormat ETC_RGB4_3DS
public TextureFormat ETC_RGBA8_3DS
public TextureFormat RG16
public TextureFormat R8
public TextureFormat ETC_RGB4Crunched
public TextureFormat ETC2_RGBA8Crunched
public TextureFormat ASTC_HDR_4x4
public TextureFormat ASTC_HDR_5x5
public TextureFormat ASTC_HDR_6x6
public TextureFormat ASTC_HDR_8x8
public TextureFormat ASTC_HDR_10x10
public TextureFormat ASTC_HDR_12x12
public TextureFormat RG32
public TextureFormat RGB48
public TextureFormat RGBA64
public TextureFormat ASTC_RGB_4x4
public TextureFormat ASTC_RGB_5x5
public TextureFormat ASTC_RGB_6x6
public TextureFormat ASTC_RGB_8x8
public TextureFormat ASTC_RGB_10x10
public TextureFormat ASTC_RGB_12x12
public TextureFormat ASTC_RGBA_4x4
public TextureFormat ASTC_RGBA_5x5
public TextureFormat ASTC_RGBA_6x6
public TextureFormat ASTC_RGBA_8x8
public TextureFormat ASTC_RGBA_10x10
public TextureFormat ASTC_RGBA_12x12
}
public UnityEngine.TextureWrapMode : Enum {
public int value__
public TextureWrapMode Repeat
public TextureWrapMode Clamp
public TextureWrapMode Mirror
public TextureWrapMode MirrorOnce
}
public UnityEngine.ThreadPriority : Enum {
public int value__
public ThreadPriority Low
public ThreadPriority BelowNormal
public ThreadPriority Normal
public ThreadPriority High
}
public UnityEngine.Time : object {
public float time
public double timeAsDouble
public float timeSinceLevelLoad
public double timeSinceLevelLoadAsDouble
public float deltaTime
public float fixedTime
public double fixedTimeAsDouble
public float unscaledTime
public double unscaledTimeAsDouble
public float fixedUnscaledTime
public double fixedUnscaledTimeAsDouble
public float unscaledDeltaTime
public float fixedUnscaledDeltaTime
public float fixedDeltaTime
public float maximumDeltaTime
public float smoothDeltaTime
public float maximumParticleDeltaTime
public float timeScale
public int frameCount
public int renderedFrameCount
public float realtimeSinceStartup
public double realtimeSinceStartupAsDouble
public float captureDeltaTime
public int captureFramerate
public bool inFixedTimeStep
public float get_time()
public double get_timeAsDouble()
public float get_timeSinceLevelLoad()
public double get_timeSinceLevelLoadAsDouble()
public float get_deltaTime()
public float get_fixedTime()
public double get_fixedTimeAsDouble()
public float get_unscaledTime()
public double get_unscaledTimeAsDouble()
public float get_fixedUnscaledTime()
public double get_fixedUnscaledTimeAsDouble()
public float get_unscaledDeltaTime()
public float get_fixedUnscaledDeltaTime()
public float get_fixedDeltaTime()
public void set_fixedDeltaTime(float value)
public float get_maximumDeltaTime()
public void set_maximumDeltaTime(float value)
public float get_smoothDeltaTime()
public float get_maximumParticleDeltaTime()
public void set_maximumParticleDeltaTime(float value)
public float get_timeScale()
public void set_timeScale(float value)
public int get_frameCount()
public int get_renderedFrameCount()
public float get_realtimeSinceStartup()
public double get_realtimeSinceStartupAsDouble()
public float get_captureDeltaTime()
public void set_captureDeltaTime(float value)
public int get_captureFramerate()
public void set_captureFramerate(int value)
public bool get_inFixedTimeStep()
}
public UnityEngine.TooltipAttribute : PropertyAttribute {
public string tooltip
public void .ctor(string tooltip)
}
public UnityEngine.TouchScreenKeyboard : object {
internal IntPtr m_Ptr
private bool <disableInPlaceEditing>k__BackingField
public bool isSupported
internal bool disableInPlaceEditing
public bool isInPlaceEditingAllowed
internal bool isRequiredToForceOpen
public string text
public bool hideInput
public bool active
public bool done
public bool wasCanceled
public Status status
public int characterLimit
public bool canGetSelection
public bool canSetSelection
public RangeInt selection
public TouchScreenKeyboardType type
public int targetDisplay
public Rect area
public bool visible
private void Internal_Destroy(IntPtr ptr)
private void Destroy()
protected void Finalize()
public void .ctor(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit)
private IntPtr TouchScreenKeyboard_InternalConstructorHelper(TouchScreenKeyboard_InternalConstructorHelperArguments& arguments, string text, string textPlaceholder)
public bool get_isSupported()
internal bool get_disableInPlaceEditing()
internal void set_disableInPlaceEditing(bool value)
public bool get_isInPlaceEditingAllowed()
internal bool get_isRequiredToForceOpen()
private bool IsRequiredToForceOpen()
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection)
public TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType)
public TouchScreenKeyboard Open(string text)
public string get_text()
public void set_text(string value)
public bool get_hideInput()
public void set_hideInput(bool value)
public bool get_active()
public void set_active(bool value)
private bool GetDone(IntPtr ptr)
public bool get_done()
private bool GetWasCanceled(IntPtr ptr)
public bool get_wasCanceled()
public Status get_status()
public int get_characterLimit()
public void set_characterLimit(int value)
public bool get_canGetSelection()
public bool get_canSetSelection()
public RangeInt get_selection()
public void set_selection(RangeInt value)
private void GetSelection(Int32& start, Int32& length)
private void SetSelection(int start, int length)
public TouchScreenKeyboardType get_type()
public int get_targetDisplay()
public void set_targetDisplay(int value)
public Rect get_area()
public bool get_visible()
private void get_area_Injected(Rect& ret)
}
internal UnityEngine.TouchScreenKeyboard_InternalConstructorHelperArguments : ValueType {
public UInt32 keyboardType
public UInt32 autocorrection
public UInt32 multiline
public UInt32 secure
public UInt32 alert
public int characterLimit
}
public UnityEngine.TouchScreenKeyboardType : Enum {
public int value__
public TouchScreenKeyboardType Default
public TouchScreenKeyboardType ASCIICapable
public TouchScreenKeyboardType NumbersAndPunctuation
public TouchScreenKeyboardType URL
public TouchScreenKeyboardType NumberPad
public TouchScreenKeyboardType PhonePad
public TouchScreenKeyboardType NamePhonePad
public TouchScreenKeyboardType EmailAddress
public TouchScreenKeyboardType NintendoNetworkAccount
public TouchScreenKeyboardType Social
public TouchScreenKeyboardType Search
public TouchScreenKeyboardType DecimalPad
public TouchScreenKeyboardType OneTimeCode
}
public UnityEngine.TrackedReference : object {
internal IntPtr m_Ptr
public bool op_Equality(TrackedReference x, TrackedReference y)
public bool op_Inequality(TrackedReference x, TrackedReference y)
public bool Equals(object o)
public int GetHashCode()
public bool op_Implicit(TrackedReference exists)
}
public UnityEngine.TrailRenderer : Renderer {
public int numPositions
public float time
public float startWidth
public float endWidth
public float widthMultiplier
public bool autodestruct
public bool emitting
public int numCornerVertices
public int numCapVertices
public float minVertexDistance
public Color startColor
public Color endColor
public int positionCount
public float shadowBias
public bool generateLightingData
public LineTextureMode textureMode
public LineAlignment alignment
public AnimationCurve widthCurve
public Gradient colorGradient
public int get_numPositions()
public float get_time()
public void set_time(float value)
public float get_startWidth()
public void set_startWidth(float value)
public float get_endWidth()
public void set_endWidth(float value)
public float get_widthMultiplier()
public void set_widthMultiplier(float value)
public bool get_autodestruct()
public void set_autodestruct(bool value)
public bool get_emitting()
public void set_emitting(bool value)
public int get_numCornerVertices()
public void set_numCornerVertices(int value)
public int get_numCapVertices()
public void set_numCapVertices(int value)
public float get_minVertexDistance()
public void set_minVertexDistance(float value)
public Color get_startColor()
public void set_startColor(Color value)
public Color get_endColor()
public void set_endColor(Color value)
public int get_positionCount()
public void SetPosition(int index, Vector3 position)
public Vector3 GetPosition(int index)
public float get_shadowBias()
public void set_shadowBias(float value)
public bool get_generateLightingData()
public void set_generateLightingData(bool value)
public LineTextureMode get_textureMode()
public void set_textureMode(LineTextureMode value)
public LineAlignment get_alignment()
public void set_alignment(LineAlignment value)
public void Clear()
public void BakeMesh(Mesh mesh, bool useTransform)
public void BakeMesh(Mesh mesh, Camera camera, bool useTransform)
public AnimationCurve get_widthCurve()
public void set_widthCurve(AnimationCurve value)
public Gradient get_colorGradient()
public void set_colorGradient(Gradient value)
private AnimationCurve GetWidthCurveCopy()
private void SetWidthCurve(AnimationCurve curve)
private Gradient GetColorGradientCopy()
private void SetColorGradient(Gradient curve)
public int GetPositions(Vector3[] positions)
public int GetVisiblePositions(Vector3[] positions)
public void SetPositions(Vector3[] positions)
public void AddPosition(Vector3 position)
public void AddPositions(Vector3[] positions)
public void SetPositions(NativeArray`1<Vector3> positions)
public void SetPositions(NativeSlice`1<Vector3> positions)
public int GetPositions(NativeArray`1<Vector3> positions)
public int GetPositions(NativeSlice`1<Vector3> positions)
public int GetVisiblePositions(NativeArray`1<Vector3> positions)
public int GetVisiblePositions(NativeSlice`1<Vector3> positions)
public void AddPositions(NativeArray`1<Vector3> positions)
public void AddPositions(NativeSlice`1<Vector3> positions)
private void SetPositionsWithNativeContainer(IntPtr positions, int count)
private int GetPositionsWithNativeContainer(IntPtr positions, int length)
private int GetVisiblePositionsWithNativeContainer(IntPtr positions, int length)
private void AddPositionsWithNativeContainer(IntPtr positions, int length)
private void get_startColor_Injected(Color& ret)
private void set_startColor_Injected(Color& value)
private void get_endColor_Injected(Color& ret)
private void set_endColor_Injected(Color& value)
private void SetPosition_Injected(int index, Vector3& position)
private void GetPosition_Injected(int index, Vector3& ret)
private void AddPosition_Injected(Vector3& position)
}
public UnityEngine.Transform : Component {
public Vector3 position
public Vector3 localPosition
public Vector3 eulerAngles
public Vector3 localEulerAngles
public Vector3 right
public Vector3 up
public Vector3 forward
public Quaternion rotation
public Quaternion localRotation
internal RotationOrder rotationOrder
public Vector3 localScale
public Transform parent
internal Transform parentInternal
public Matrix4x4 worldToLocalMatrix
public Matrix4x4 localToWorldMatrix
public Transform root
public int childCount
public Vector3 lossyScale
public bool hasChanged
public int hierarchyCapacity
public int hierarchyCount
internal bool constrainProportionsScale
public Vector3 get_position()
public void set_position(Vector3 value)
public Vector3 get_localPosition()
public void set_localPosition(Vector3 value)
internal Vector3 GetLocalEulerAngles(RotationOrder order)
internal void SetLocalEulerAngles(Vector3 euler, RotationOrder order)
internal void SetLocalEulerHint(Vector3 euler)
public Vector3 get_eulerAngles()
public void set_eulerAngles(Vector3 value)
public Vector3 get_localEulerAngles()
public void set_localEulerAngles(Vector3 value)
public Vector3 get_right()
public void set_right(Vector3 value)
public Vector3 get_up()
public void set_up(Vector3 value)
public Vector3 get_forward()
public void set_forward(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public Quaternion get_localRotation()
public void set_localRotation(Quaternion value)
internal RotationOrder get_rotationOrder()
internal void set_rotationOrder(RotationOrder value)
internal int GetRotationOrderInternal()
internal void SetRotationOrderInternal(RotationOrder rotationOrder)
public Vector3 get_localScale()
public void set_localScale(Vector3 value)
public Transform get_parent()
public void set_parent(Transform value)
internal Transform get_parentInternal()
internal void set_parentInternal(Transform value)
private Transform GetParent()
public void SetParent(Transform p)
public void SetParent(Transform parent, bool worldPositionStays)
public Matrix4x4 get_worldToLocalMatrix()
public Matrix4x4 get_localToWorldMatrix()
public void SetPositionAndRotation(Vector3 position, Quaternion rotation)
public void SetLocalPositionAndRotation(Vector3 localPosition, Quaternion localRotation)
public void GetPositionAndRotation(Vector3& position, Quaternion& rotation)
public void GetLocalPositionAndRotation(Vector3& localPosition, Quaternion& localRotation)
public void Translate(Vector3 translation, Space relativeTo)
public void Translate(Vector3 translation)
public void Translate(float x, float y, float z, Space relativeTo)
public void Translate(float x, float y, float z)
public void Translate(Vector3 translation, Transform relativeTo)
public void Translate(float x, float y, float z, Transform relativeTo)
public void Rotate(Vector3 eulers, Space relativeTo)
public void Rotate(Vector3 eulers)
public void Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo)
public void Rotate(float xAngle, float yAngle, float zAngle)
internal void RotateAroundInternal(Vector3 axis, float angle)
public void Rotate(Vector3 axis, float angle, Space relativeTo)
public void Rotate(Vector3 axis, float angle)
public void RotateAround(Vector3 point, Vector3 axis, float angle)
public void LookAt(Transform target, Vector3 worldUp)
public void LookAt(Transform target)
public void LookAt(Vector3 worldPosition, Vector3 worldUp)
public void LookAt(Vector3 worldPosition)
private void Internal_LookAt(Vector3 worldPosition, Vector3 worldUp)
public Vector3 TransformDirection(Vector3 direction)
public Vector3 TransformDirection(float x, float y, float z)
public Vector3 InverseTransformDirection(Vector3 direction)
public Vector3 InverseTransformDirection(float x, float y, float z)
public Vector3 TransformVector(Vector3 vector)
public Vector3 TransformVector(float x, float y, float z)
public Vector3 InverseTransformVector(Vector3 vector)
public Vector3 InverseTransformVector(float x, float y, float z)
public Vector3 TransformPoint(Vector3 position)
public Vector3 TransformPoint(float x, float y, float z)
public Vector3 InverseTransformPoint(Vector3 position)
public Vector3 InverseTransformPoint(float x, float y, float z)
public Transform get_root()
private Transform GetRoot()
public int get_childCount()
public void DetachChildren()
public void SetAsFirstSibling()
public void SetAsLastSibling()
public void SetSiblingIndex(int index)
internal void MoveAfterSibling(Transform transform, bool notifyEditorAndMarkDirty)
public int GetSiblingIndex()
private Transform FindRelativeTransformWithPath(Transform transform, string path, bool isActiveOnly)
public Transform Find(string n)
internal void SendTransformChangedScale()
public Vector3 get_lossyScale()
public bool IsChildOf(Transform parent)
public bool get_hasChanged()
public void set_hasChanged(bool value)
public Transform FindChild(string n)
public IEnumerator GetEnumerator()
public void RotateAround(Vector3 axis, float angle)
public void RotateAroundLocal(Vector3 axis, float angle)
public Transform GetChild(int index)
public int GetChildCount()
public int get_hierarchyCapacity()
public void set_hierarchyCapacity(int value)
private int internal_getHierarchyCapacity()
private void internal_setHierarchyCapacity(int value)
public int get_hierarchyCount()
private int internal_getHierarchyCount()
internal bool IsNonUniformScaleTransform()
internal bool get_constrainProportionsScale()
internal void set_constrainProportionsScale(bool value)
private void SetConstrainProportionsScale(bool isLinked)
private bool IsConstrainProportionsScale()
private void get_position_Injected(Vector3& ret)
private void set_position_Injected(Vector3& value)
private void get_localPosition_Injected(Vector3& ret)
private void set_localPosition_Injected(Vector3& value)
private void GetLocalEulerAngles_Injected(RotationOrder order, Vector3& ret)
private void SetLocalEulerAngles_Injected(Vector3& euler, RotationOrder order)
private void SetLocalEulerHint_Injected(Vector3& euler)
private void get_rotation_Injected(Quaternion& ret)
private void set_rotation_Injected(Quaternion& value)
private void get_localRotation_Injected(Quaternion& ret)
private void set_localRotation_Injected(Quaternion& value)
private void get_localScale_Injected(Vector3& ret)
private void set_localScale_Injected(Vector3& value)
private void get_worldToLocalMatrix_Injected(Matrix4x4& ret)
private void get_localToWorldMatrix_Injected(Matrix4x4& ret)
private void SetPositionAndRotation_Injected(Vector3& position, Quaternion& rotation)
private void SetLocalPositionAndRotation_Injected(Vector3& localPosition, Quaternion& localRotation)
private void RotateAroundInternal_Injected(Vector3& axis, float angle)
private void Internal_LookAt_Injected(Vector3& worldPosition, Vector3& worldUp)
private void TransformDirection_Injected(Vector3& direction, Vector3& ret)
private void InverseTransformDirection_Injected(Vector3& direction, Vector3& ret)
private void TransformVector_Injected(Vector3& vector, Vector3& ret)
private void InverseTransformVector_Injected(Vector3& vector, Vector3& ret)
private void TransformPoint_Injected(Vector3& position, Vector3& ret)
private void InverseTransformPoint_Injected(Vector3& position, Vector3& ret)
private void get_lossyScale_Injected(Vector3& ret)
private void RotateAround_Injected(Vector3& axis, float angle)
private void RotateAroundLocal_Injected(Vector3& axis, float angle)
}
public UnityEngine.TransparencySortMode : Enum {
public int value__
public TransparencySortMode Default
public TransparencySortMode Perspective
public TransparencySortMode Orthographic
public TransparencySortMode CustomAxis
}
public UnityEngine.Types : object {
public Type GetType(string typeName, string assemblyName)
}
internal UnityEngine.U2D.Light2DType : Enum {
public int value__
public Light2DType Parametric
public Light2DType Freeform
public Light2DType Sprite
public Light2DType Point
public Light2DType Global
}
public UnityEngine.U2D.PixelPerfectRendering : object {
public float pixelSnapSpacing
public float get_pixelSnapSpacing()
public void set_pixelSnapSpacing(float value)
}
public UnityEngine.U2D.SpriteAtlas : Object {
public bool isVariant
public string tag
public int spriteCount
public bool get_isVariant()
public string get_tag()
public int get_spriteCount()
public bool CanBindTo(Sprite sprite)
public Sprite GetSprite(string name)
public int GetSprites(Sprite[] sprites)
public int GetSprites(Sprite[] sprites, string name)
private int GetSpritesScripting(Sprite[] sprites)
private int GetSpritesWithNameScripting(Sprite[] sprites, string name)
}
public UnityEngine.U2D.SpriteAtlasManager : object {
private Action`2<string, Action`1<SpriteAtlas>> atlasRequested
private Action`1<SpriteAtlas> atlasRegistered
public void add_atlasRequested(Action`2<string, Action`1<SpriteAtlas>> value)
public void remove_atlasRequested(Action`2<string, Action`1<SpriteAtlas>> value)
private bool RequestAtlas(string tag)
public void add_atlasRegistered(Action`1<SpriteAtlas> value)
public void remove_atlasRegistered(Action`1<SpriteAtlas> value)
private void PostRegisteredAtlas(SpriteAtlas spriteAtlas)
internal void Register(SpriteAtlas spriteAtlas)
}
public UnityEngine.U2D.SpriteBone : ValueType {
private string m_Name
private string m_Guid
private Vector3 m_Position
private Quaternion m_Rotation
private float m_Length
private int m_ParentId
private Color32 m_Color
public string name
public string guid
public Vector3 position
public Quaternion rotation
public float length
public int parentId
public Color32 color
public string get_name()
public void set_name(string value)
public string get_guid()
public void set_guid(string value)
public Vector3 get_position()
public void set_position(Vector3 value)
public Quaternion get_rotation()
public void set_rotation(Quaternion value)
public float get_length()
public void set_length(float value)
public int get_parentId()
public void set_parentId(int value)
public Color32 get_color()
public void set_color(Color32 value)
}
internal UnityEngine.U2D.SpriteChannelInfo : ValueType {
private IntPtr m_Buffer
private int m_Count
private int m_Offset
private int m_Stride
public Void* buffer
public int count
public int offset
public int stride
public Void* get_buffer()
public void set_buffer(Void* value)
public int get_count()
public void set_count(int value)
public int get_offset()
public void set_offset(int value)
public int get_stride()
public void set_stride(int value)
}
public UnityEngine.U2D.SpriteDataAccessExtensions : object {
private void CheckAttributeTypeMatchesAndThrow(VertexAttribute channel)
public NativeSlice`1<T> GetVertexAttribute(Sprite sprite, VertexAttribute channel)
public void SetVertexAttribute(Sprite sprite, VertexAttribute channel, NativeArray`1<T> src)
public NativeArray`1<Matrix4x4> GetBindPoses(Sprite sprite)
public void SetBindPoses(Sprite sprite, NativeArray`1<Matrix4x4> src)
public NativeArray`1<ushort> GetIndices(Sprite sprite)
public void SetIndices(Sprite sprite, NativeArray`1<ushort> src)
public SpriteBone[] GetBones(Sprite sprite)
public void SetBones(Sprite sprite, SpriteBone[] src)
public bool HasVertexAttribute(Sprite sprite, VertexAttribute channel)
public void SetVertexCount(Sprite sprite, int count)
public int GetVertexCount(Sprite sprite)
private SpriteChannelInfo GetBindPoseInfo(Sprite sprite)
private void SetBindPoseData(Sprite sprite, Void* src, int count)
private SpriteChannelInfo GetIndicesInfo(Sprite sprite)
private void SetIndicesData(Sprite sprite, Void* src, int count)
private SpriteChannelInfo GetChannelInfo(Sprite sprite, VertexAttribute channel)
private void SetChannelData(Sprite sprite, VertexAttribute channel, Void* src)
private SpriteBone[] GetBoneInfo(Sprite sprite)
private void SetBoneData(Sprite sprite, SpriteBone[] src)
internal int GetPrimaryVertexStreamSize(Sprite sprite)
private void GetBindPoseInfo_Injected(Sprite sprite, SpriteChannelInfo& ret)
private void GetIndicesInfo_Injected(Sprite sprite, SpriteChannelInfo& ret)
private void GetChannelInfo_Injected(Sprite sprite, VertexAttribute channel, SpriteChannelInfo& ret)
}
public UnityEngine.U2D.SpriteRendererDataAccessExtensions : object {
internal void SetDeformableBuffer(SpriteRenderer spriteRenderer, NativeArray`1<byte> src)
internal void SetDeformableBuffer(SpriteRenderer spriteRenderer, NativeArray`1<Vector3> src)
internal void SetBatchDeformableBufferAndLocalAABBArray(SpriteRenderer[] spriteRenderers, NativeArray`1<IntPtr> buffers, NativeArray`1<int> bufferSizes, NativeArray`1<Bounds> bounds)
internal bool IsUsingDeformableBuffer(SpriteRenderer spriteRenderer, IntPtr buffer)
public void DeactivateDeformableBuffer(SpriteRenderer renderer)
internal void SetLocalAABB(SpriteRenderer renderer, Bounds aabb)
private void SetDeformableBuffer(SpriteRenderer spriteRenderer, Void* src, int count)
private void SetBatchDeformableBufferAndLocalAABBArray(SpriteRenderer[] spriteRenderers, Void* buffers, Void* bufferSizes, Void* bounds, int count)
private bool IsUsingDeformableBuffer(SpriteRenderer spriteRenderer, Void* buffer)
private void SetLocalAABB_Injected(SpriteRenderer renderer, Bounds& aabb)
}
public UnityEngine.UnassignedReferenceException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal UnityEngine.UnhandledExceptionHandler : object {
private void RegisterUECatcher()
}
public UnityEngine.UnityAPICompatibilityVersionAttribute : Attribute {
private string _version
private String[] _configurationAssembliesHashes
public string version
internal String[] configurationAssembliesHashes
public void .ctor(string version)
public void .ctor(string version, bool checkOnlyUnityVersion)
public void .ctor(string version, String[] configurationAssembliesHashes)
public string get_version()
internal String[] get_configurationAssembliesHashes()
}
public UnityEngine.UnityEventQueueSystem : object {
public string GenerateEventIdForPayload(string eventPayloadName)
public IntPtr GetGlobalEventQueue()
}
public UnityEngine.UnityException : SystemException {
private int Result
private string unityStackTrace
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal UnityEngine.UnityLogWriter : TextWriter {
public Encoding Encoding
public void WriteStringToUnityLog(string s)
private void WriteStringToUnityLogImpl(string s)
public void Init()
public Encoding get_Encoding()
public void Write(char value)
public void Write(string s)
public void Write(Char[] buffer, int index, int count)
}
internal UnityEngine.UnitySynchronizationContext : SynchronizationContext {
private int kAwqInitialCapacity
private List`1<WorkRequest> m_AsyncWorkQueue
private List`1<WorkRequest> m_CurrentFrameWork
private int m_MainThreadID
private int m_TrackedCount
private void .ctor(int mainThreadID)
private void .ctor(List`1<WorkRequest> queue, int mainThreadID)
public void Send(SendOrPostCallback callback, object state)
public void OperationStarted()
public void OperationCompleted()
public void Post(SendOrPostCallback callback, object state)
public SynchronizationContext CreateCopy()
private void Exec()
private bool HasPendingTasks()
private void InitializeSynchronizationContext()
private void ExecuteTasks()
private bool ExecutePendingTasks(long millisecondsTimeout)
}
public UnityEngine.UserAuthorization : Enum {
public int value__
public UserAuthorization WebCam
public UserAuthorization Microphone
}
public UnityEngine.Vector2 : ValueType {
public float x
public float y
private Vector2 zeroVector
private Vector2 oneVector
private Vector2 upVector
private Vector2 downVector
private Vector2 leftVector
private Vector2 rightVector
private Vector2 positiveInfinityVector
private Vector2 negativeInfinityVector
public float kEpsilon
public float kEpsilonNormalSqrt
public float Item
public Vector2 normalized
public float magnitude
public float sqrMagnitude
public Vector2 zero
public Vector2 one
public Vector2 up
public Vector2 down
public Vector2 left
public Vector2 right
public Vector2 positiveInfinity
public Vector2 negativeInfinity
public float get_Item(int index)
public void set_Item(int index, float value)
public void .ctor(float x, float y)
public void Set(float newX, float newY)
public Vector2 Lerp(Vector2 a, Vector2 b, float t)
public Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t)
public Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta)
public Vector2 Scale(Vector2 a, Vector2 b)
public void Scale(Vector2 scale)
public void Normalize()
public Vector2 get_normalized()
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Vector2 other)
public Vector2 Reflect(Vector2 inDirection, Vector2 inNormal)
public Vector2 Perpendicular(Vector2 inDirection)
public float Dot(Vector2 lhs, Vector2 rhs)
public float get_magnitude()
public float get_sqrMagnitude()
public float Angle(Vector2 from, Vector2 to)
public float SignedAngle(Vector2 from, Vector2 to)
public float Distance(Vector2 a, Vector2 b)
public Vector2 ClampMagnitude(Vector2 vector, float maxLength)
public float SqrMagnitude(Vector2 a)
public float SqrMagnitude()
public Vector2 Min(Vector2 lhs, Vector2 rhs)
public Vector2 Max(Vector2 lhs, Vector2 rhs)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime)
public Vector2 SmoothDamp(Vector2 current, Vector2 target, Vector2& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public Vector2 op_Addition(Vector2 a, Vector2 b)
public Vector2 op_Subtraction(Vector2 a, Vector2 b)
public Vector2 op_Multiply(Vector2 a, Vector2 b)
public Vector2 op_Division(Vector2 a, Vector2 b)
public Vector2 op_UnaryNegation(Vector2 a)
public Vector2 op_Multiply(Vector2 a, float d)
public Vector2 op_Multiply(float d, Vector2 a)
public Vector2 op_Division(Vector2 a, float d)
public bool op_Equality(Vector2 lhs, Vector2 rhs)
public bool op_Inequality(Vector2 lhs, Vector2 rhs)
public Vector2 op_Implicit(Vector3 v)
public Vector3 op_Implicit(Vector2 v)
public Vector2 get_zero()
public Vector2 get_one()
public Vector2 get_up()
public Vector2 get_down()
public Vector2 get_left()
public Vector2 get_right()
public Vector2 get_positiveInfinity()
public Vector2 get_negativeInfinity()
}
public UnityEngine.Vector2Int : ValueType {
private int m_X
private int m_Y
private Vector2Int s_Zero
private Vector2Int s_One
private Vector2Int s_Up
private Vector2Int s_Down
private Vector2Int s_Left
private Vector2Int s_Right
public int x
public int y
public int Item
public float magnitude
public int sqrMagnitude
public Vector2Int zero
public Vector2Int one
public Vector2Int up
public Vector2Int down
public Vector2Int left
public Vector2Int right
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public void .ctor(int x, int y)
public void Set(int x, int y)
public int get_Item(int index)
public void set_Item(int index, int value)
public float get_magnitude()
public int get_sqrMagnitude()
public float Distance(Vector2Int a, Vector2Int b)
public Vector2Int Min(Vector2Int lhs, Vector2Int rhs)
public Vector2Int Max(Vector2Int lhs, Vector2Int rhs)
public Vector2Int Scale(Vector2Int a, Vector2Int b)
public void Scale(Vector2Int scale)
public void Clamp(Vector2Int min, Vector2Int max)
public Vector2 op_Implicit(Vector2Int v)
public Vector3Int op_Explicit(Vector2Int v)
public Vector2Int FloorToInt(Vector2 v)
public Vector2Int CeilToInt(Vector2 v)
public Vector2Int RoundToInt(Vector2 v)
public Vector2Int op_UnaryNegation(Vector2Int v)
public Vector2Int op_Addition(Vector2Int a, Vector2Int b)
public Vector2Int op_Subtraction(Vector2Int a, Vector2Int b)
public Vector2Int op_Multiply(Vector2Int a, Vector2Int b)
public Vector2Int op_Multiply(int a, Vector2Int b)
public Vector2Int op_Multiply(Vector2Int a, int b)
public Vector2Int op_Division(Vector2Int a, int b)
public bool op_Equality(Vector2Int lhs, Vector2Int rhs)
public bool op_Inequality(Vector2Int lhs, Vector2Int rhs)
public bool Equals(object other)
public bool Equals(Vector2Int other)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public Vector2Int get_zero()
public Vector2Int get_one()
public Vector2Int get_up()
public Vector2Int get_down()
public Vector2Int get_left()
public Vector2Int get_right()
}
public UnityEngine.Vector3 : ValueType {
public float kEpsilon
public float kEpsilonNormalSqrt
public float x
public float y
public float z
private Vector3 zeroVector
private Vector3 oneVector
private Vector3 upVector
private Vector3 downVector
private Vector3 leftVector
private Vector3 rightVector
private Vector3 forwardVector
private Vector3 backVector
private Vector3 positiveInfinityVector
private Vector3 negativeInfinityVector
public float Item
public Vector3 normalized
public float magnitude
public float sqrMagnitude
public Vector3 zero
public Vector3 one
public Vector3 forward
public Vector3 back
public Vector3 up
public Vector3 down
public Vector3 left
public Vector3 right
public Vector3 positiveInfinity
public Vector3 negativeInfinity
public Vector3 fwd
public Vector3 Slerp(Vector3 a, Vector3 b, float t)
public Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t)
private void OrthoNormalize2(Vector3& a, Vector3& b)
public void OrthoNormalize(Vector3& normal, Vector3& tangent)
private void OrthoNormalize3(Vector3& a, Vector3& b, Vector3& c)
public void OrthoNormalize(Vector3& normal, Vector3& tangent, Vector3& binormal)
public Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)
public Vector3 Lerp(Vector3 a, Vector3 b, float t)
public Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t)
public Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime)
public Vector3 SmoothDamp(Vector3 current, Vector3 target, Vector3& currentVelocity, float smoothTime, float maxSpeed, float deltaTime)
public float get_Item(int index)
public void set_Item(int index, float value)
public void .ctor(float x, float y, float z)
public void .ctor(float x, float y)
public void Set(float newX, float newY, float newZ)
public Vector3 Scale(Vector3 a, Vector3 b)
public void Scale(Vector3 scale)
public Vector3 Cross(Vector3 lhs, Vector3 rhs)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Vector3 other)
public Vector3 Reflect(Vector3 inDirection, Vector3 inNormal)
public Vector3 Normalize(Vector3 value)
public void Normalize()
public Vector3 get_normalized()
public float Dot(Vector3 lhs, Vector3 rhs)
public Vector3 Project(Vector3 vector, Vector3 onNormal)
public Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal)
public float Angle(Vector3 from, Vector3 to)
public float SignedAngle(Vector3 from, Vector3 to, Vector3 axis)
public float Distance(Vector3 a, Vector3 b)
public Vector3 ClampMagnitude(Vector3 vector, float maxLength)
public float Magnitude(Vector3 vector)
public float get_magnitude()
public float SqrMagnitude(Vector3 vector)
public float get_sqrMagnitude()
public Vector3 Min(Vector3 lhs, Vector3 rhs)
public Vector3 Max(Vector3 lhs, Vector3 rhs)
public Vector3 get_zero()
public Vector3 get_one()
public Vector3 get_forward()
public Vector3 get_back()
public Vector3 get_up()
public Vector3 get_down()
public Vector3 get_left()
public Vector3 get_right()
public Vector3 get_positiveInfinity()
public Vector3 get_negativeInfinity()
public Vector3 op_Addition(Vector3 a, Vector3 b)
public Vector3 op_Subtraction(Vector3 a, Vector3 b)
public Vector3 op_UnaryNegation(Vector3 a)
public Vector3 op_Multiply(Vector3 a, float d)
public Vector3 op_Multiply(float d, Vector3 a)
public Vector3 op_Division(Vector3 a, float d)
public bool op_Equality(Vector3 lhs, Vector3 rhs)
public bool op_Inequality(Vector3 lhs, Vector3 rhs)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public Vector3 get_fwd()
public float AngleBetween(Vector3 from, Vector3 to)
public Vector3 Exclude(Vector3 excludeThis, Vector3 fromThat)
private void Slerp_Injected(Vector3& a, Vector3& b, float t, Vector3& ret)
private void SlerpUnclamped_Injected(Vector3& a, Vector3& b, float t, Vector3& ret)
private void RotateTowards_Injected(Vector3& current, Vector3& target, float maxRadiansDelta, float maxMagnitudeDelta, Vector3& ret)
}
public UnityEngine.Vector3Int : ValueType {
private int m_X
private int m_Y
private int m_Z
private Vector3Int s_Zero
private Vector3Int s_One
private Vector3Int s_Up
private Vector3Int s_Down
private Vector3Int s_Left
private Vector3Int s_Right
private Vector3Int s_Forward
private Vector3Int s_Back
public int x
public int y
public int z
public int Item
public float magnitude
public int sqrMagnitude
public Vector3Int zero
public Vector3Int one
public Vector3Int up
public Vector3Int down
public Vector3Int left
public Vector3Int right
public Vector3Int forward
public Vector3Int back
public int get_x()
public void set_x(int value)
public int get_y()
public void set_y(int value)
public int get_z()
public void set_z(int value)
public void .ctor(int x, int y)
public void .ctor(int x, int y, int z)
public void Set(int x, int y, int z)
public int get_Item(int index)
public void set_Item(int index, int value)
public float get_magnitude()
public int get_sqrMagnitude()
public float Distance(Vector3Int a, Vector3Int b)
public Vector3Int Min(Vector3Int lhs, Vector3Int rhs)
public Vector3Int Max(Vector3Int lhs, Vector3Int rhs)
public Vector3Int Scale(Vector3Int a, Vector3Int b)
public void Scale(Vector3Int scale)
public void Clamp(Vector3Int min, Vector3Int max)
public Vector3 op_Implicit(Vector3Int v)
public Vector2Int op_Explicit(Vector3Int v)
public Vector3Int FloorToInt(Vector3 v)
public Vector3Int CeilToInt(Vector3 v)
public Vector3Int RoundToInt(Vector3 v)
public Vector3Int op_Addition(Vector3Int a, Vector3Int b)
public Vector3Int op_Subtraction(Vector3Int a, Vector3Int b)
public Vector3Int op_Multiply(Vector3Int a, Vector3Int b)
public Vector3Int op_UnaryNegation(Vector3Int a)
public Vector3Int op_Multiply(Vector3Int a, int b)
public Vector3Int op_Multiply(int a, Vector3Int b)
public Vector3Int op_Division(Vector3Int a, int b)
public bool op_Equality(Vector3Int lhs, Vector3Int rhs)
public bool op_Inequality(Vector3Int lhs, Vector3Int rhs)
public bool Equals(object other)
public bool Equals(Vector3Int other)
public int GetHashCode()
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public Vector3Int get_zero()
public Vector3Int get_one()
public Vector3Int get_up()
public Vector3Int get_down()
public Vector3Int get_left()
public Vector3Int get_right()
public Vector3Int get_forward()
public Vector3Int get_back()
}
public UnityEngine.Vector4 : ValueType {
public float kEpsilon
public float x
public float y
public float z
public float w
private Vector4 zeroVector
private Vector4 oneVector
private Vector4 positiveInfinityVector
private Vector4 negativeInfinityVector
public float Item
public Vector4 normalized
public float magnitude
public float sqrMagnitude
public Vector4 zero
public Vector4 one
public Vector4 positiveInfinity
public Vector4 negativeInfinity
public float get_Item(int index)
public void set_Item(int index, float value)
public void .ctor(float x, float y, float z, float w)
public void .ctor(float x, float y, float z)
public void .ctor(float x, float y)
public void Set(float newX, float newY, float newZ, float newW)
public Vector4 Lerp(Vector4 a, Vector4 b, float t)
public Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t)
public Vector4 MoveTowards(Vector4 current, Vector4 target, float maxDistanceDelta)
public Vector4 Scale(Vector4 a, Vector4 b)
public void Scale(Vector4 scale)
public int GetHashCode()
public bool Equals(object other)
public bool Equals(Vector4 other)
public Vector4 Normalize(Vector4 a)
public void Normalize()
public Vector4 get_normalized()
public float Dot(Vector4 a, Vector4 b)
public Vector4 Project(Vector4 a, Vector4 b)
public float Distance(Vector4 a, Vector4 b)
public float Magnitude(Vector4 a)
public float get_magnitude()
public float get_sqrMagnitude()
public Vector4 Min(Vector4 lhs, Vector4 rhs)
public Vector4 Max(Vector4 lhs, Vector4 rhs)
public Vector4 get_zero()
public Vector4 get_one()
public Vector4 get_positiveInfinity()
public Vector4 get_negativeInfinity()
public Vector4 op_Addition(Vector4 a, Vector4 b)
public Vector4 op_Subtraction(Vector4 a, Vector4 b)
public Vector4 op_UnaryNegation(Vector4 a)
public Vector4 op_Multiply(Vector4 a, float d)
public Vector4 op_Multiply(float d, Vector4 a)
public Vector4 op_Division(Vector4 a, float d)
public bool op_Equality(Vector4 lhs, Vector4 rhs)
public bool op_Inequality(Vector4 lhs, Vector4 rhs)
public Vector4 op_Implicit(Vector3 v)
public Vector3 op_Implicit(Vector4 v)
public Vector4 op_Implicit(Vector2 v)
public Vector2 op_Implicit(Vector4 v)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public float SqrMagnitude(Vector4 a)
public float SqrMagnitude()
}
public UnityEngine.VRTextureUsage : Enum {
public int value__
public VRTextureUsage None
public VRTextureUsage OneEye
public VRTextureUsage TwoEyes
public VRTextureUsage DeviceSpecific
}
public UnityEngine.WaitForSeconds : YieldInstruction {
internal float m_Seconds
public void .ctor(float seconds)
}
public UnityEngine.WaitForSecondsRealtime : CustomYieldInstruction {
private float <waitTime>k__BackingField
private float m_WaitUntilTime
public float waitTime
public bool keepWaiting
public float get_waitTime()
public void set_waitTime(float value)
public bool get_keepWaiting()
public void .ctor(float time)
public void Reset()
}
public UnityEngine.WaitUntil : CustomYieldInstruction {
private Func`1<bool> m_Predicate
public bool keepWaiting
public bool get_keepWaiting()
public void .ctor(Func`1<bool> predicate)
}
public UnityEngine.WaitWhile : CustomYieldInstruction {
private Func`1<bool> m_Predicate
public bool keepWaiting
public bool get_keepWaiting()
public void .ctor(Func`1<bool> predicate)
}
public UnityEngine.WeightedMode : Enum {
public int value__
public WeightedMode None
public WeightedMode In
public WeightedMode Out
public WeightedMode Both
}
public UnityEngine.Windows.CrashReporting : object {
public string crashReportFolder
public string get_crashReportFolder()
}
public UnityEngine.Windows.Input : object {
private void ForwardRawInputImpl(UInt32* rawInputHeaderIndices, UInt32* rawInputDataIndices, UInt32 indicesCount, Byte* rawInputData, UInt32 rawInputDataSize)
public void ForwardRawInput(IntPtr rawInputHeaderIndices, IntPtr rawInputDataIndices, UInt32 indicesCount, IntPtr rawInputData, UInt32 rawInputDataSize)
public void ForwardRawInput(UInt32* rawInputHeaderIndices, UInt32* rawInputDataIndices, UInt32 indicesCount, Byte* rawInputData, UInt32 rawInputDataSize)
}
public UnityEngine.Windows.Speech.ConfidenceLevel : Enum {
public int value__
public ConfidenceLevel High
public ConfidenceLevel Medium
public ConfidenceLevel Low
public ConfidenceLevel Rejected
}
public UnityEngine.Windows.Speech.DictationCompletionCause : Enum {
public int value__
public DictationCompletionCause Complete
public DictationCompletionCause AudioQualityFailure
public DictationCompletionCause Canceled
public DictationCompletionCause TimeoutExceeded
public DictationCompletionCause PauseLimitExceeded
public DictationCompletionCause NetworkFailure
public DictationCompletionCause MicrophoneUnavailable
public DictationCompletionCause UnknownError
}
public UnityEngine.Windows.Speech.DictationRecognizer : object {
private IntPtr m_Recognizer
private DictationHypothesisDelegate DictationHypothesis
private DictationResultDelegate DictationResult
private DictationCompletedDelegate DictationComplete
private DictationErrorHandler DictationError
public SpeechSystemStatus Status
public float AutoSilenceTimeoutSeconds
public float InitialSilenceTimeoutSeconds
private IntPtr Create(object self, ConfidenceLevel minimumConfidence, DictationTopicConstraint topicConstraint)
private void Start(IntPtr self)
private void Stop(IntPtr self)
private void Destroy(IntPtr self)
private void DestroyThreaded(IntPtr self)
private SpeechSystemStatus GetStatus(IntPtr self)
private float GetAutoSilenceTimeoutSeconds(IntPtr self)
private void SetAutoSilenceTimeoutSeconds(IntPtr self, float value)
private float GetInitialSilenceTimeoutSeconds(IntPtr self)
private void SetInitialSilenceTimeoutSeconds(IntPtr self, float value)
public void add_DictationHypothesis(DictationHypothesisDelegate value)
public void remove_DictationHypothesis(DictationHypothesisDelegate value)
public void add_DictationResult(DictationResultDelegate value)
public void remove_DictationResult(DictationResultDelegate value)
public void add_DictationComplete(DictationCompletedDelegate value)
public void remove_DictationComplete(DictationCompletedDelegate value)
public void add_DictationError(DictationErrorHandler value)
public void remove_DictationError(DictationErrorHandler value)
public SpeechSystemStatus get_Status()
public float get_AutoSilenceTimeoutSeconds()
public void set_AutoSilenceTimeoutSeconds(float value)
public float get_InitialSilenceTimeoutSeconds()
public void set_InitialSilenceTimeoutSeconds(float value)
public void .ctor(ConfidenceLevel confidenceLevel)
public void .ctor(DictationTopicConstraint topic)
public void .ctor(ConfidenceLevel minimumConfidence, DictationTopicConstraint topic)
protected void Finalize()
public void Start()
public void Stop()
public void Dispose()
private void DictationRecognizer_InvokeHypothesisGeneratedEvent(string keyword)
private void DictationRecognizer_InvokeResultGeneratedEvent(string keyword, ConfidenceLevel minimumConfidence)
private void DictationRecognizer_InvokeCompletedEvent(DictationCompletionCause cause)
private void DictationRecognizer_InvokeErrorEvent(string error, int hresult)
}
public UnityEngine.Windows.Speech.DictationTopicConstraint : Enum {
public int value__
public DictationTopicConstraint WebSearch
public DictationTopicConstraint Form
public DictationTopicConstraint Dictation
}
public UnityEngine.Windows.Speech.GrammarRecognizer : PhraseRecognizer {
private string <GrammarFilePath>k__BackingField
public string GrammarFilePath
public string get_GrammarFilePath()
private void set_GrammarFilePath(string value)
public void .ctor(string grammarFilePath)
public void .ctor(string grammarFilePath, ConfidenceLevel minimumConfidence)
}
public UnityEngine.Windows.Speech.KeywordRecognizer : PhraseRecognizer {
private IEnumerable`1<string> <Keywords>k__BackingField
public IEnumerable`1<string> Keywords
public IEnumerable`1<string> get_Keywords()
private void set_Keywords(IEnumerable`1<string> value)
public void .ctor(String[] keywords)
public void .ctor(String[] keywords, ConfidenceLevel minimumConfidence)
}
public UnityEngine.Windows.Speech.PhraseRecognitionSystem : object {
private ErrorDelegate OnError
private StatusDelegate OnStatusChanged
public bool isSupported
public SpeechSystemStatus Status
public bool get_isSupported()
public SpeechSystemStatus get_Status()
public void Restart()
public void Shutdown()
public void add_OnError(ErrorDelegate value)
public void remove_OnError(ErrorDelegate value)
public void add_OnStatusChanged(StatusDelegate value)
public void remove_OnStatusChanged(StatusDelegate value)
private void PhraseRecognitionSystem_InvokeErrorEvent(SpeechError errorCode)
private void PhraseRecognitionSystem_InvokeStatusChangedEvent(SpeechSystemStatus status)
}
public UnityEngine.Windows.Speech.PhraseRecognizedEventArgs : ValueType {
public ConfidenceLevel confidence
public SemanticMeaning[] semanticMeanings
public string text
public DateTime phraseStartTime
public TimeSpan phraseDuration
internal void .ctor(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, DateTime phraseStartTime, TimeSpan phraseDuration)
}
public UnityEngine.Windows.Speech.PhraseRecognizer : object {
protected IntPtr m_Recognizer
private PhraseRecognizedDelegate OnPhraseRecognized
public bool IsRunning
protected IntPtr CreateFromKeywords(object self, String[] keywords, ConfidenceLevel minimumConfidence)
protected IntPtr CreateFromGrammarFile(object self, string grammarFilePath, ConfidenceLevel minimumConfidence)
private void Start_Internal(IntPtr recognizer)
private void Stop_Internal(IntPtr recognizer)
private bool IsRunning_Internal(IntPtr recognizer)
private void Destroy(IntPtr recognizer)
private void DestroyThreaded(IntPtr recognizer)
public void add_OnPhraseRecognized(PhraseRecognizedDelegate value)
public void remove_OnPhraseRecognized(PhraseRecognizedDelegate value)
protected void Finalize()
public void Start()
public void Stop()
public void Dispose()
public bool get_IsRunning()
private void InvokePhraseRecognizedEvent(string text, ConfidenceLevel confidence, SemanticMeaning[] semanticMeanings, long phraseStartFileTime, long phraseDurationTicks)
private SemanticMeaning[] MarshalSemanticMeaning(IntPtr keys, IntPtr values, IntPtr valueSizes, int valueCount)
}
public UnityEngine.Windows.Speech.SemanticMeaning : ValueType {
public string key
public String[] values
}
public UnityEngine.Windows.Speech.SpeechError : Enum {
public int value__
public SpeechError NoError
public SpeechError TopicLanguageNotSupported
public SpeechError GrammarLanguageMismatch
public SpeechError GrammarCompilationFailure
public SpeechError AudioQualityFailure
public SpeechError PauseLimitExceeded
public SpeechError TimeoutExceeded
public SpeechError NetworkFailure
public SpeechError MicrophoneUnavailable
public SpeechError UnknownError
}
public UnityEngine.Windows.Speech.SpeechSystemStatus : Enum {
public int value__
public SpeechSystemStatus Stopped
public SpeechSystemStatus Running
public SpeechSystemStatus Failed
}
public UnityEngine.Windows.WebCam.CameraParameters : ValueType {
private float m_HologramOpacity
private float m_FrameRate
private int m_CameraResolutionWidth
private int m_CameraResolutionHeight
private CapturePixelFormat m_PixelFormat
public float hologramOpacity
public float frameRate
public int cameraResolutionWidth
public int cameraResolutionHeight
public CapturePixelFormat pixelFormat
public float get_hologramOpacity()
public void set_hologramOpacity(float value)
public float get_frameRate()
public void set_frameRate(float value)
public int get_cameraResolutionWidth()
public void set_cameraResolutionWidth(int value)
public int get_cameraResolutionHeight()
public void set_cameraResolutionHeight(int value)
public CapturePixelFormat get_pixelFormat()
public void set_pixelFormat(CapturePixelFormat value)
public void .ctor(WebCamMode webCamMode)
}
public UnityEngine.Windows.WebCam.CapturePixelFormat : Enum {
public int value__
public CapturePixelFormat BGRA32
public CapturePixelFormat NV12
public CapturePixelFormat JPEG
public CapturePixelFormat PNG
}
public UnityEngine.Windows.WebCam.PhotoCapture : object {
internal IntPtr m_NativePtr
private Resolution[] s_SupportedResolutions
private long HR_SUCCESS
public IEnumerable`1<Resolution> SupportedResolutions
private PhotoCaptureResult MakeCaptureResult(CaptureResultType resultType, long hResult)
private PhotoCaptureResult MakeCaptureResult(long hResult)
public IEnumerable`1<Resolution> get_SupportedResolutions()
private Resolution[] GetSupportedResolutions_Internal()
public void CreateAsync(bool showHolograms, OnCaptureResourceCreatedCallback onCreatedCallback)
public void CreateAsync(OnCaptureResourceCreatedCallback onCreatedCallback)
private IntPtr Instantiate_Internal(bool showHolograms, OnCaptureResourceCreatedCallback onCreatedCallback)
private void InvokeOnCreatedResourceDelegate(OnCaptureResourceCreatedCallback callback, IntPtr nativePtr)
private void .ctor(IntPtr nativeCaptureObject)
public void StartPhotoModeAsync(CameraParameters setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback)
private void StartPhotoMode_Internal(CameraParameters setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback)
private void InvokeOnPhotoModeStartedDelegate(OnPhotoModeStartedCallback callback, long hResult)
public void StopPhotoModeAsync(OnPhotoModeStoppedCallback onPhotoModeStoppedCallback)
private void InvokeOnPhotoModeStoppedDelegate(OnPhotoModeStoppedCallback callback, long hResult)
public void TakePhotoAsync(string filename, PhotoCaptureFileOutputFormat fileOutputFormat, OnCapturedToDiskCallback onCapturedPhotoToDiskCallback)
private void CapturePhotoToDisk_Internal(string filename, PhotoCaptureFileOutputFormat fileOutputFormat, OnCapturedToDiskCallback onCapturedPhotoToDiskCallback)
private void InvokeOnCapturedPhotoToDiskDelegate(OnCapturedToDiskCallback callback, long hResult)
public void TakePhotoAsync(OnCapturedToMemoryCallback onCapturedPhotoToMemoryCallback)
private void CapturePhotoToMemory_Internal(OnCapturedToMemoryCallback onCapturedPhotoToMemoryCallback)
private void InvokeOnCapturedPhotoToMemoryDelegate(OnCapturedToMemoryCallback callback, long hResult, IntPtr photoCaptureFramePtr)
public IntPtr GetUnsafePointerToVideoDeviceController()
public void Dispose()
private void Dispose_Internal()
protected void Finalize()
private void DisposeThreaded_Internal()
private void StartPhotoMode_Internal_Injected(CameraParameters& setupParams, OnPhotoModeStartedCallback onPhotoModeStartedCallback)
}
public UnityEngine.Windows.WebCam.PhotoCaptureFileOutputFormat : Enum {
public int value__
public PhotoCaptureFileOutputFormat PNG
public PhotoCaptureFileOutputFormat JPG
}
public UnityEngine.Windows.WebCam.PhotoCaptureFrame : object {
private IntPtr m_NativePtr
private int <dataLength>k__BackingField
private bool <hasLocationData>k__BackingField
private CapturePixelFormat <pixelFormat>k__BackingField
public int dataLength
public bool hasLocationData
public CapturePixelFormat pixelFormat
public int get_dataLength()
private void set_dataLength(int value)
public bool get_hasLocationData()
private void set_hasLocationData(bool value)
public CapturePixelFormat get_pixelFormat()
private void set_pixelFormat(CapturePixelFormat value)
private int GetDataLength()
private bool GetHasLocationData()
private CapturePixelFormat GetCapturePixelFormat()
public bool TryGetCameraToWorldMatrix(Matrix4x4& cameraToWorldMatrix)
private Matrix4x4 GetCameraToWorldMatrix()
public bool TryGetProjectionMatrix(Matrix4x4& projectionMatrix)
public bool TryGetProjectionMatrix(float nearClipPlane, float farClipPlane, Matrix4x4& projectionMatrix)
private Matrix4x4 GetProjection()
public void UploadImageDataToTexture(Texture2D targetTexture)
private void UploadImageDataToTexture_Internal(Texture2D targetTexture)
public IntPtr GetUnsafePointerToBuffer()
public void CopyRawImageDataIntoBuffer(List`1<byte> byteBuffer)
internal void CopyRawImageDataIntoBuffer_Internal(Byte[] byteArray)
internal void .ctor(IntPtr nativePtr)
private void Cleanup()
private void Dispose_Internal()
public void Dispose()
protected void Finalize()
private void GetCameraToWorldMatrix_Injected(Matrix4x4& ret)
private void GetProjection_Injected(Matrix4x4& ret)
}
public UnityEngine.Windows.WebCam.VideoCapture : object {
internal IntPtr m_NativePtr
private Resolution[] s_SupportedResolutions
private long HR_SUCCESS
public IEnumerable`1<Resolution> SupportedResolutions
public bool IsRecording
private VideoCaptureResult MakeCaptureResult(CaptureResultType resultType, long hResult)
private VideoCaptureResult MakeCaptureResult(long hResult)
public IEnumerable`1<Resolution> get_SupportedResolutions()
private Resolution[] GetSupportedResolutions_Internal()
public IEnumerable`1<float> GetSupportedFrameRatesForResolution(Resolution resolution)
private Single[] GetSupportedFrameRatesForResolution_Internal(int resolutionWidth, int resolutionHeight)
public bool get_IsRecording()
public void CreateAsync(bool showHolograms, OnVideoCaptureResourceCreatedCallback onCreatedCallback)
public void CreateAsync(OnVideoCaptureResourceCreatedCallback onCreatedCallback)
private void Instantiate_Internal(bool showHolograms, OnVideoCaptureResourceCreatedCallback onCreatedCallback)
private void InvokeOnCreatedVideoCaptureResourceDelegate(OnVideoCaptureResourceCreatedCallback callback, IntPtr nativePtr)
private void .ctor(IntPtr nativeCaptureObject)
public void StartVideoModeAsync(CameraParameters setupParams, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback)
private void StartVideoMode_Internal(CameraParameters cameraParameters, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback)
private void InvokeOnVideoModeStartedDelegate(OnVideoModeStartedCallback callback, long hResult)
public void StopVideoModeAsync(OnVideoModeStoppedCallback onVideoModeStoppedCallback)
private void InvokeOnVideoModeStoppedDelegate(OnVideoModeStoppedCallback callback, long hResult)
public void StartRecordingAsync(string filename, OnStartedRecordingVideoCallback onStartedRecordingVideoCallback)
private void StartRecordingVideoToDisk_Internal(string filename, OnStartedRecordingVideoCallback onStartedRecordingVideoCallback)
private void InvokeOnStartedRecordingVideoToDiskDelegate(OnStartedRecordingVideoCallback callback, long hResult)
public void StopRecordingAsync(OnStoppedRecordingVideoCallback onStoppedRecordingVideoCallback)
private void InvokeOnStoppedRecordingVideoToDiskDelegate(OnStoppedRecordingVideoCallback callback, long hResult)
public IntPtr GetUnsafePointerToVideoDeviceController()
public void Dispose()
private void Dispose_Internal()
protected void Finalize()
private void DisposeThreaded_Internal()
private void StartVideoMode_Internal_Injected(CameraParameters& cameraParameters, AudioState audioState, OnVideoModeStartedCallback onVideoModeStartedCallback)
}
public UnityEngine.Windows.WebCam.WebCam : object {
public WebCamMode Mode
public WebCamMode get_Mode()
}
public UnityEngine.Windows.WebCam.WebCamMode : Enum {
public int value__
public WebCamMode None
public WebCamMode PhotoMode
public WebCamMode VideoMode
}
public UnityEngine.WrapMode : Enum {
public int value__
public WrapMode Once
public WrapMode Loop
public WrapMode PingPong
public WrapMode Default
public WrapMode ClampForever
public WrapMode Clamp
}
public UnityEngineInternal.APIUpdaterRuntimeServices : object {
public Component AddComponent(GameObject go, string sourceInfo, string name)
}
public UnityEngineInternal.GIDebugVisualisation : object {
public bool cycleMode
public bool pauseCycleMode
public GITextureType texType
public void ResetRuntimeInputTextures()
public void PlayCycleMode()
public void PauseCycleMode()
public void StopCycleMode()
public void CycleSkipSystems(int skip)
public void CycleSkipInstances(int skip)
public bool get_cycleMode()
public bool get_pauseCycleMode()
public GITextureType get_texType()
public void set_texType(GITextureType value)
}
public UnityEngineInternal.GITextureType : Enum {
public int value__
public GITextureType Charting
public GITextureType Albedo
public GITextureType Emissive
public GITextureType Irradiance
public GITextureType Directionality
public GITextureType Baked
public GITextureType BakedDirectional
public GITextureType InputWorkspace
public GITextureType BakedShadowMask
public GITextureType BakedAlbedo
public GITextureType BakedEmissive
public GITextureType BakedCharting
public GITextureType BakedTexelValidity
public GITextureType BakedUVOverlap
public GITextureType BakedLightmapCulling
}
internal UnityEngineInternal.GraphicsDeviceDebug : object {
internal GraphicsDeviceDebugSettings settings
internal GraphicsDeviceDebugSettings get_settings()
internal void set_settings(GraphicsDeviceDebugSettings value)
private void get_settings_Injected(GraphicsDeviceDebugSettings& ret)
private void set_settings_Injected(GraphicsDeviceDebugSettings& value)
}
internal UnityEngineInternal.GraphicsDeviceDebugSettings : ValueType {
public float sleepAtStartOfGraphicsJobs
public float sleepBeforeTextureUpload
}
internal UnityEngineInternal.LightmapType : Enum {
public int value__
public LightmapType NoLightmap
public LightmapType StaticLightmap
public LightmapType DynamicLightmap
}
public UnityEngineInternal.MathfInternal : ValueType {
public Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinNormal
public Single modreq(System.Runtime.CompilerServices.IsVolatile) FloatMinDenormal
public bool IsFlushToZeroEnabled
}
public UnityEngineInternal.MemorylessManager : object {
public MemorylessMode depthMemorylessMode
public MemorylessMode get_depthMemorylessMode()
public void set_depthMemorylessMode(MemorylessMode value)
internal MemorylessMode GetFramebufferDepthMemorylessMode()
internal void SetFramebufferDepthMemorylessMode(MemorylessMode mode)
}
public UnityEngineInternal.MemorylessMode : Enum {
public int value__
public MemorylessMode Unused
public MemorylessMode Forced
public MemorylessMode Automatic
}
public UnityEngineInternal.TypeInferenceRuleAttribute : Attribute {
private string _rule
public void .ctor(TypeInferenceRules rule)
public void .ctor(string rule)
public string ToString()
}
public UnityEngineInternal.TypeInferenceRules : Enum {
public int value__
public TypeInferenceRules TypeReferencedByFirstArgument
public TypeInferenceRules TypeReferencedBySecondArgument
public TypeInferenceRules ArrayOfTypeReferencedByFirstArgument
public TypeInferenceRules TypeOfFirstArgument
}
