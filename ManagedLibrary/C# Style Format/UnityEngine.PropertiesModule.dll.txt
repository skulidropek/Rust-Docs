public Unity.Properties.ArrayPropertyBag`1 : IndexedCollectionPropertyBag`2<TElement[], TElement> {
protected InstantiationKind InstantiationKind
protected InstantiationKind get_InstantiationKind()
protected TElement[] InstantiateWithCount(int count)
protected TElement[] Instantiate()
}
public Unity.Properties.AttributesScope : ValueType {
private IAttributes m_Target
private List`1<Attribute> m_Previous
public void .ctor(IProperty target, IProperty source)
internal void .ctor(IAttributes target, List`1<Attribute> attributes)
public void Dispose()
}
public Unity.Properties.ConcreteTypeVisitor : object {
protected void VisitContainer(TContainer& container)
private void Unity.Properties.IPropertyBagVisitor.Visit(IPropertyBag`1<TContainer> properties, TContainer& container)
}
public Unity.Properties.ContainerPropertyBag`1 : PropertyBag`1<TContainer> {
private List`1<IProperty`1<TContainer>> m_PropertiesList
private Dictionary`2<string, IProperty`1<TContainer>> m_PropertiesHash
protected void AddProperty(Property`2<TContainer, TValue> property)
public PropertyCollection`1<TContainer> GetProperties()
public PropertyCollection`1<TContainer> GetProperties(TContainer& container)
public bool TryGetProperty(TContainer& container, string name, IProperty`1& property)
}
internal Unity.Properties.ConversionRegistry : ValueType {
private ConverterKeyComparer Comparer
private Dictionary`2<ConverterKey, Delegate> m_Converters
public int ConverterCount
private void .ctor(Dictionary`2<ConverterKey, Delegate> storage)
public int get_ConverterCount()
public ConversionRegistry Create()
public void Register(Type source, Type destination, Delegate converter)
public void Unregister(Type source, Type destination)
public Delegate GetConverter(Type source, Type destination)
public bool TryGetConverter(Type source, Type destination, Delegate& converter)
public void GetAllTypesConvertingToType(Type type, List`1<Type> result)
public bool Equals(ConversionRegistry x, ConversionRegistry y)
public int GetHashCode(ConversionRegistry obj)
}
public Unity.Properties.DelegateProperty`2 : Property`2<TContainer, TValue> {
private PropertyGetter`2<TContainer, TValue> m_Getter
private PropertySetter`2<TContainer, TValue> m_Setter
private string <Name>k__BackingField
public string Name
public bool IsReadOnly
public string get_Name()
public bool get_IsReadOnly()
public void .ctor(string name, PropertyGetter`2<TContainer, TValue> getter, PropertySetter`2<TContainer, TValue> setter)
public TValue GetValue(TContainer& container)
public void SetValue(TContainer& container, TValue value)
}
public Unity.Properties.DictionaryPropertyBag`2 : KeyValueCollectionPropertyBag`3<Dictionary`2<TKey, TValue>, TKey, TValue> {
protected InstantiationKind InstantiationKind
protected InstantiationKind get_InstantiationKind()
protected Dictionary`2<TKey, TValue> Instantiate()
}
public Unity.Properties.ExcludeContext`1 : ValueType {
private PropertyVisitor m_Visitor
private IProperty`1<TContainer> <Property>k__BackingField
public IProperty`1<TContainer> Property
internal ExcludeContext`1<TContainer> FromProperty(PropertyVisitor visitor, Property`2<TContainer, TValue> property)
public IProperty`1<TContainer> get_Property()
private void .ctor(PropertyVisitor visitor, IProperty`1<TContainer> property)
}
public Unity.Properties.ExcludeContext`2 : ValueType {
private PropertyVisitor m_Visitor
private Property`2<TContainer, TValue> <Property>k__BackingField
public Property`2<TContainer, TValue> Property
internal ExcludeContext`2<TContainer, TValue> FromProperty(PropertyVisitor visitor, Property`2<TContainer, TValue> property)
public Property`2<TContainer, TValue> get_Property()
private void .ctor(PropertyVisitor visitor, Property`2<TContainer, TValue> property)
}
internal Unity.Properties.FieldMember : ValueType {
internal FieldInfo m_FieldInfo
private string <Name>k__BackingField
public string Name
public bool IsReadOnly
public Type ValueType
public void .ctor(FieldInfo fieldInfo)
public string get_Name()
public bool get_IsReadOnly()
public Type get_ValueType()
public object GetValue(object obj)
public void SetValue(object obj, object value)
public IEnumerable`1<Attribute> GetCustomAttributes()
}
public Unity.Properties.GeneratePropertyBagsForTypeAttribute : Attribute {
private Type <Type>k__BackingField
public Type Type
public Type get_Type()
public void .ctor(Type type)
}
public Unity.Properties.GeneratePropertyBagsForTypesQualifiedWithAttribute : Attribute {
private Type <Type>k__BackingField
private TypeGenerationOptions <Options>k__BackingField
public Type Type
public TypeGenerationOptions Options
public Type get_Type()
public TypeGenerationOptions get_Options()
public void .ctor(Type type, TypeGenerationOptions options)
}
public Unity.Properties.HashSetPropertyBag`1 : SetPropertyBagBase`2<HashSet`1<TElement>, TElement> {
protected InstantiationKind InstantiationKind
protected InstantiationKind get_InstantiationKind()
protected HashSet`1<TElement> Instantiate()
}
public Unity.Properties.ICollectionPropertyAccept`1 {
public void Accept(ICollectionPropertyVisitor visitor, Property`2<TContainer, TCollection> property, TContainer& container, TCollection& collection)
}
public Unity.Properties.ICollectionPropertyBagAccept`1 {
public void Accept(ICollectionPropertyBagVisitor visitor, TContainer& container)
}
public Unity.Properties.ICollectionPropertyBagVisitor {
public void Visit(ICollectionPropertyBag`2<TCollection, TElement> properties, TCollection& container)
}
public Unity.Properties.ICollectionPropertyVisitor {
public void Visit(Property`2<TContainer, TCollection> property, TContainer& container, TCollection& collection)
}
internal Unity.Properties.IConstructor {
public InstantiationKind InstantiationKind
public InstantiationKind get_InstantiationKind()
}
internal Unity.Properties.IConstructor`1 {
public T Instantiate()
}
internal Unity.Properties.IConstructorWithCount`1 {
public T InstantiateWithCount(int count)
}
public Unity.Properties.IDictionaryElementProperty {
public object ObjectKey
public object get_ObjectKey()
}
public Unity.Properties.IDictionaryElementProperty`1 {
public TKey Key
public TKey get_Key()
}
public Unity.Properties.IDictionaryPropertyAccept`1 {
public void Accept(IDictionaryPropertyVisitor visitor, Property`2<TContainer, TDictionary> property, TContainer& container, TDictionary& dictionary)
}
public Unity.Properties.IDictionaryPropertyBagAccept`1 {
public void Accept(IDictionaryPropertyBagVisitor visitor, TContainer& container)
}
public Unity.Properties.IDictionaryPropertyBagVisitor {
public void Visit(IDictionaryPropertyBag`3<TDictionary, TKey, TValue> properties, TDictionary& container)
}
public Unity.Properties.IDictionaryPropertyVisitor {
public void Visit(Property`2<TContainer, TDictionary> property, TContainer& container, TDictionary& dictionary)
}
public Unity.Properties.IExcludeContravariantPropertyAdapter`1 {
public bool IsExcluded(ExcludeContext`1& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue value)
}
public Unity.Properties.IExcludeContravariantPropertyAdapter`2 {
public bool IsExcluded(ExcludeContext`1& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue value)
}
public Unity.Properties.IExcludePropertyAdapter {
public bool IsExcluded(ExcludeContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
public Unity.Properties.IExcludePropertyAdapter`1 {
public bool IsExcluded(ExcludeContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
public Unity.Properties.IExcludePropertyAdapter`2 {
public bool IsExcluded(ExcludeContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
internal Unity.Properties.IIndexedCollectionPropertyBagEnumerator`1 {
public int GetCount(TContainer& container)
public IProperty`1<TContainer> GetSharedProperty()
public IndexedCollectionSharedPropertyState GetSharedPropertyState()
public void SetSharedPropertyState(IndexedCollectionSharedPropertyState state)
}
public Unity.Properties.IIndexedProperties`1 {
public bool TryGetProperty(TContainer& container, int index, IProperty`1& property)
}
public Unity.Properties.IKeyedProperties`2 {
public bool TryGetProperty(TContainer& container, TKey key, IProperty`1& property)
}
public Unity.Properties.IListElementProperty {
public int Index
public int get_Index()
}
public Unity.Properties.IListPropertyAccept`1 {
public void Accept(IListPropertyVisitor visitor, Property`2<TContainer, TList> property, TContainer& container, TList& list)
}
public Unity.Properties.IListPropertyBagAccept`1 {
public void Accept(IListPropertyBagVisitor visitor, TContainer& container)
}
public Unity.Properties.IListPropertyBagVisitor {
public void Visit(IListPropertyBag`2<TList, TElement> properties, TList& container)
}
public Unity.Properties.IListPropertyVisitor {
public void Visit(Property`2<TContainer, TList> property, TContainer& container, TList& list)
}
internal Unity.Properties.IMemberInfo {
public string Name
public bool IsReadOnly
public Type ValueType
public string get_Name()
public bool get_IsReadOnly()
public Type get_ValueType()
public object GetValue(object obj)
public void SetValue(object obj, object value)
public IEnumerable`1<Attribute> GetCustomAttributes()
}
public Unity.Properties.INamedProperties`1 {
public bool TryGetProperty(TContainer& container, string name, IProperty`1& property)
}
public Unity.Properties.IndexedCollectionPropertyBag`2 : PropertyBag`1<TList> {
private ListElementProperty<TList, TElement> m_Property
public PropertyCollection`1<TList> GetProperties()
public PropertyCollection`1<TList> GetProperties(TList& container)
public bool TryGetProperty(TList& container, int index, IProperty`1& property)
private void Unity.Properties.ICollectionPropertyBagAccept<TList>.Accept(ICollectionPropertyBagVisitor visitor, TList& container)
private void Unity.Properties.IListPropertyBagAccept<TList>.Accept(IListPropertyBagVisitor visitor, TList& list)
private void Unity.Properties.IListPropertyAccept<TList>.Accept(IListPropertyVisitor visitor, Property`2<TContainer, TList> property, TContainer& container, TList& list)
private TList Unity.Properties.IConstructorWithCount<TList>.InstantiateWithCount(int count)
protected TList InstantiateWithCount(int count)
private int Unity.Properties.IIndexedCollectionPropertyBagEnumerator<TList>.GetCount(TList& container)
private IProperty`1<TList> Unity.Properties.IIndexedCollectionPropertyBagEnumerator<TList>.GetSharedProperty()
private IndexedCollectionSharedPropertyState Unity.Properties.IIndexedCollectionPropertyBagEnumerator<TList>.GetSharedPropertyState()
private void Unity.Properties.IIndexedCollectionPropertyBagEnumerator<TList>.SetSharedPropertyState(IndexedCollectionSharedPropertyState state)
}
internal Unity.Properties.IndexedCollectionPropertyBagEnumerable`1 : ValueType {
private IIndexedCollectionPropertyBagEnumerator`1<TContainer> m_Impl
private TContainer m_Container
public void .ctor(IIndexedCollectionPropertyBagEnumerator`1<TContainer> impl, TContainer container)
public IndexedCollectionPropertyBagEnumerator`1<TContainer> GetEnumerator()
}
internal Unity.Properties.IndexedCollectionPropertyBagEnumerator`1 : ValueType {
private IIndexedCollectionPropertyBagEnumerator`1<TContainer> m_Impl
private IndexedCollectionSharedPropertyState m_Previous
private TContainer m_Container
private int m_Position
public IProperty`1<TContainer> Current
private object System.Collections.IEnumerator.Current
internal void .ctor(IIndexedCollectionPropertyBagEnumerator`1<TContainer> impl, TContainer container)
public IProperty`1<TContainer> get_Current()
private object System.Collections.IEnumerator.get_Current()
public bool MoveNext()
public void Reset()
public void Dispose()
}
internal Unity.Properties.IndexedCollectionSharedPropertyState : ValueType {
public int Index
public bool IsReadOnly
}
public Unity.Properties.InstantiationKind : Enum {
public int value__
public InstantiationKind Activator
public InstantiationKind PropertyBagOverride
public InstantiationKind NotInstantiatable
}
internal Unity.Properties.Internal.DefaultPropertyBagInitializer : object {
internal void Initialize()
}
internal Unity.Properties.Internal.IAttributes {
public List`1<Attribute> Attributes
public List`1<Attribute> get_Attributes()
public void set_Attributes(List`1<Attribute> value)
public void AddAttribute(Attribute attribute)
public void AddAttributes(IEnumerable`1<Attribute> attributes)
public AttributesScope CreateAttributesScope(IAttributes attributes)
}
internal Unity.Properties.Internal.IPropertyBagRegister {
public void Register()
}
internal Unity.Properties.Internal.PropertyBagStore : object {
private ConcurrentDictionary`2<Type, IPropertyBag> s_PropertyBags
private List`1<Type> s_RegisteredTypes
private Action`2<Type, IPropertyBag> NewTypeRegistered
private ReflectedPropertyBagProvider s_PropertyBagProvider
internal bool HasProvider
internal List`1<Type> AllTypes
internal void add_NewTypeRegistered(Action`2<Type, IPropertyBag> value)
internal void remove_NewTypeRegistered(Action`2<Type, IPropertyBag> value)
internal bool get_HasProvider()
internal List`1<Type> get_AllTypes()
internal void AddPropertyBag(IPropertyBag`1<TContainer> propertyBag)
internal IPropertyBag`1<TContainer> GetPropertyBag()
internal IPropertyBag GetPropertyBag(Type type)
internal bool Exists()
internal bool Exists(Type type)
internal bool Exists(TContainer& value)
internal bool TryGetPropertyBagForValue(TValue& value, IPropertyBag& propertyBag)
}
internal Unity.Properties.Internal.ReadOnlyAdapterCollection : ValueType {
private List`1<IPropertyVisitorAdapter> m_Adapters
public void .ctor(List`1<IPropertyVisitorAdapter> adapters)
public Enumerator GetEnumerator()
}
internal Unity.Properties.Internal.ReflectedPropertyBag`1 : ContainerPropertyBag`1<TContainer> {
internal void AddProperty(Property`2<TContainer, TValue> property)
}
internal Unity.Properties.Internal.ReflectedPropertyBagProvider : object {
private MethodInfo m_CreatePropertyMethod
private MethodInfo m_CreatePropertyBagMethod
private MethodInfo m_CreateIndexedCollectionPropertyBagMethod
private MethodInfo m_CreateSetPropertyBagMethod
private MethodInfo m_CreateKeyValueCollectionPropertyBagMethod
private MethodInfo m_CreateKeyValuePairPropertyBagMethod
private MethodInfo m_CreateArrayPropertyBagMethod
private MethodInfo m_CreateListPropertyBagMethod
private MethodInfo m_CreateHashSetPropertyBagMethod
private MethodInfo m_CreateDictionaryPropertyBagMethod
public IPropertyBag CreatePropertyBag(Type type)
public IPropertyBag`1<TContainer> CreatePropertyBag()
private void CreateProperty(IMemberInfo member, ReflectedPropertyBag`1<TContainer> propertyBag)
private IPropertyBag`1<TList> CreateIndexedCollectionPropertyBag()
private IPropertyBag`1<TSet> CreateSetPropertyBag()
private IPropertyBag`1<TDictionary> CreateKeyValueCollectionPropertyBag()
private IPropertyBag`1<KeyValuePair`2<TKey, TValue>> CreateKeyValuePairPropertyBag()
private IPropertyBag`1<TElement[]> CreateArrayPropertyBag()
private IPropertyBag`1<List`1<TElement>> CreateListPropertyBag()
private IPropertyBag`1<HashSet`1<TElement>> CreateHashSetPropertyBag()
private IPropertyBag`1<Dictionary`2<TKey, TValue>> CreateDictionaryPropertyBag()
private IEnumerable`1<MemberInfo> GetPropertyMembers(Type type)
private bool IsValidMember(MemberInfo memberInfo)
private bool IsValidPropertyType(Type type)
}
internal Unity.Properties.Internal.ReflectionUtilities : object {
public string SanitizeMemberName(MemberInfo info)
}
public Unity.Properties.InvalidContainerTypeException : Exception {
private Type <Type>k__BackingField
public Type Type
public Type get_Type()
public void .ctor(Type type)
public void .ctor(Type type, Exception inner)
private string GetMessageForType(Type type)
}
public Unity.Properties.InvalidPathException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
public Unity.Properties.IProperty {
public string Name
public bool IsReadOnly
public string get_Name()
public bool get_IsReadOnly()
public Type DeclaredValueType()
public bool HasAttribute()
public TAttribute GetAttribute()
public IEnumerable`1<TAttribute> GetAttributes()
public IEnumerable`1<Attribute> GetAttributes()
}
public Unity.Properties.IProperty`1 {
public object GetValue(TContainer& container)
public void SetValue(TContainer& container, object value)
}
public Unity.Properties.IPropertyAccept`1 {
public void Accept(IPropertyVisitor visitor, TContainer& container)
}
public Unity.Properties.IPropertyBag {
public void Accept(ITypeVisitor visitor)
public void Accept(IPropertyBagVisitor visitor, Object& container)
}
public Unity.Properties.IPropertyBag`1 {
public PropertyCollection`1<TContainer> GetProperties()
public PropertyCollection`1<TContainer> GetProperties(TContainer& container)
public TContainer CreateInstance()
public bool TryCreateInstance(TContainer& instance)
public void Accept(IPropertyBagVisitor visitor, TContainer& container)
}
public Unity.Properties.IPropertyBagVisitor {
public void Visit(IPropertyBag`1<TContainer> properties, TContainer& container)
}
public Unity.Properties.IPropertyVisitor {
public void Visit(Property`2<TContainer, TValue> property, TContainer& container)
}
public Unity.Properties.ISetElementProperty {
public object ObjectKey
public object get_ObjectKey()
}
public Unity.Properties.ISetElementProperty`1 {
public TKey Key
public TKey get_Key()
}
public Unity.Properties.ISetPropertyAccept`1 {
public void Accept(ISetPropertyVisitor visitor, Property`2<TContainer, TSet> property, TContainer& container, TSet& set)
}
public Unity.Properties.ISetPropertyBagAccept`1 {
public void Accept(ISetPropertyBagVisitor visitor, TContainer& container)
}
public Unity.Properties.ISetPropertyBagVisitor {
public void Visit(ISetPropertyBag`2<TSet, TValue> properties, TSet& container)
}
public Unity.Properties.ISetPropertyVisitor {
public void Visit(Property`2<TContainer, TSet> property, TContainer& container, TSet& set)
}
public Unity.Properties.ITypeVisitor {
public void Visit()
}
public Unity.Properties.IVisitContravariantPropertyAdapter`1 {
public void Visit(VisitContext`1& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue value)
}
public Unity.Properties.IVisitContravariantPropertyAdapter`2 {
public void Visit(VisitContext`1& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue value)
}
public Unity.Properties.IVisitPropertyAdapter {
public void Visit(VisitContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
public Unity.Properties.IVisitPropertyAdapter`1 {
public void Visit(VisitContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
public Unity.Properties.IVisitPropertyAdapter`2 {
public void Visit(VisitContext`2& modreq(System.Runtime.InteropServices.InAttribute) context, TContainer& container, TValue& value)
}
public Unity.Properties.KeyValueCollectionPropertyBag`3 : PropertyBag`1<TDictionary> {
private KeyValuePairProperty<TDictionary, TKey, TValue> m_KeyValuePairProperty
public PropertyCollection`1<TDictionary> GetProperties()
public PropertyCollection`1<TDictionary> GetProperties(TDictionary& container)
private void Unity.Properties.ICollectionPropertyBagAccept<TDictionary>.Accept(ICollectionPropertyBagVisitor visitor, TDictionary& container)
private void Unity.Properties.IDictionaryPropertyBagAccept<TDictionary>.Accept(IDictionaryPropertyBagVisitor visitor, TDictionary& container)
private void Unity.Properties.IDictionaryPropertyAccept<TDictionary>.Accept(IDictionaryPropertyVisitor visitor, Property`2<TContainer, TDictionary> property, TContainer& container, TDictionary& dictionary)
private bool Unity.Properties.IKeyedProperties<TDictionary,System.Object>.TryGetProperty(TDictionary& container, object key, IProperty`1& property)
}
public Unity.Properties.KeyValuePairPropertyBag`2 : PropertyBag`1<KeyValuePair`2<TKey, TValue>> {
private DelegateProperty`2<KeyValuePair`2<TKey, TValue>, TKey> s_KeyProperty
private DelegateProperty`2<KeyValuePair`2<TKey, TValue>, TValue> s_ValueProperty
public PropertyCollection`1<KeyValuePair`2<TKey, TValue>> GetProperties()
public PropertyCollection`1<KeyValuePair`2<TKey, TValue>> GetProperties(KeyValuePair`2& container)
private IEnumerable`1<IProperty`1<KeyValuePair`2<TKey, TValue>>> GetPropertiesEnumerable()
public bool TryGetProperty(KeyValuePair`2& container, string name, IProperty`1& property)
}
public Unity.Properties.ListPropertyBag`1 : IndexedCollectionPropertyBag`2<List`1<TElement>, TElement> {
protected InstantiationKind InstantiationKind
protected InstantiationKind get_InstantiationKind()
protected List`1<TElement> InstantiateWithCount(int count)
protected List`1<TElement> Instantiate()
}
public Unity.Properties.MissingPropertyBagException : Exception {
private Type <Type>k__BackingField
public Type Type
public Type get_Type()
public void .ctor(Type type)
public void .ctor(Type type, Exception inner)
private string GetMessageForType(Type type)
}
public Unity.Properties.PathVisitor : object {
private int m_PathIndex
private PropertyPath <Path>k__BackingField
private IProperty <Property>k__BackingField
private bool <ReadonlyVisit>k__BackingField
private VisitReturnCode <ReturnCode>k__BackingField
public PropertyPath Path
private IProperty Property
public bool ReadonlyVisit
public VisitReturnCode ReturnCode
public PropertyPath get_Path()
public void set_Path(PropertyPath value)
public void Reset()
private IProperty get_Property()
private void set_Property(IProperty value)
public bool get_ReadonlyVisit()
public void set_ReadonlyVisit(bool value)
public VisitReturnCode get_ReturnCode()
protected void set_ReturnCode(VisitReturnCode value)
private void Unity.Properties.IPropertyBagVisitor.Visit(IPropertyBag`1<TContainer> properties, TContainer& container)
private void Unity.Properties.IPropertyVisitor.Visit(Property`2<TContainer, TValue> property, TContainer& container)
protected void VisitPath(Property`2<TContainer, TValue> property, TContainer& container, TValue& value)
}
public Unity.Properties.Property`2 : object {
private List`1<Attribute> m_Attributes
private List`1<Attribute> Unity.Properties.Internal.IAttributes.Attributes
public string Name
public bool IsReadOnly
private List`1<Attribute> Unity.Properties.Internal.IAttributes.get_Attributes()
private void Unity.Properties.Internal.IAttributes.set_Attributes(List`1<Attribute> value)
public string get_Name()
public bool get_IsReadOnly()
public Type DeclaredValueType()
public void Accept(IPropertyVisitor visitor, TContainer& container)
private object Unity.Properties.IProperty<TContainer>.GetValue(TContainer& container)
private void Unity.Properties.IProperty<TContainer>.SetValue(TContainer& container, object value)
public TValue GetValue(TContainer& container)
public void SetValue(TContainer& container, TValue value)
protected void AddAttribute(Attribute attribute)
protected void AddAttributes(IEnumerable`1<Attribute> attributes)
private void Unity.Properties.Internal.IAttributes.AddAttribute(Attribute attribute)
private void Unity.Properties.Internal.IAttributes.AddAttributes(IEnumerable`1<Attribute> attributes)
public bool HasAttribute()
public TAttribute GetAttribute()
public IEnumerable`1<TAttribute> GetAttributes()
public IEnumerable`1<Attribute> GetAttributes()
private AttributesScope Unity.Properties.Internal.IAttributes.CreateAttributesScope(IAttributes attributes)
}
public Unity.Properties.PropertyBag : object {
public void AcceptWithSpecializedVisitor(IPropertyBag`1<TContainer> properties, IPropertyBagVisitor visitor, TContainer& container)
public void Register(PropertyBag`1<TContainer> propertyBag)
public void RegisterArray()
public void RegisterArray()
public void RegisterList()
public void RegisterList()
public void RegisterHashSet()
public void RegisterHashSet()
public void RegisterDictionary()
public void RegisterDictionary()
public void RegisterIList()
public void RegisterIList()
public void RegisterISet()
public void RegisterISet()
public void RegisterIDictionary()
public void RegisterIDictionary()
public TContainer CreateInstance()
public IPropertyBag GetPropertyBag(Type type)
public IPropertyBag`1<TContainer> GetPropertyBag()
public bool TryGetPropertyBagForValue(TValue& value, IPropertyBag& propertyBag)
public bool Exists()
public bool Exists(Type type)
public IEnumerable`1<Type> GetAllTypesWithAPropertyBag()
}
public Unity.Properties.PropertyBag`1 : object {
private InstantiationKind <InstantiationKind>k__BackingField
private InstantiationKind Unity.Properties.IConstructor.InstantiationKind
protected InstantiationKind InstantiationKind
private void Unity.Properties.Internal.IPropertyBagRegister.Register()
public void Accept(ITypeVisitor visitor)
private void Unity.Properties.IPropertyBag.Accept(IPropertyBagVisitor visitor, Object& container)
private void Unity.Properties.IPropertyBag<TContainer>.Accept(IPropertyBagVisitor visitor, TContainer& container)
private PropertyCollection`1<TContainer> Unity.Properties.IPropertyBag<TContainer>.GetProperties()
private PropertyCollection`1<TContainer> Unity.Properties.IPropertyBag<TContainer>.GetProperties(TContainer& container)
private InstantiationKind Unity.Properties.IConstructor.get_InstantiationKind()
private TContainer Unity.Properties.IConstructor<TContainer>.Instantiate()
public PropertyCollection`1<TContainer> GetProperties()
public PropertyCollection`1<TContainer> GetProperties(TContainer& container)
protected InstantiationKind get_InstantiationKind()
protected TContainer Instantiate()
public TContainer CreateInstance()
public bool TryCreateInstance(TContainer& instance)
}
public Unity.Properties.PropertyCollection`1 : ValueType {
private EnumeratorType<TContainer> m_Type
private IEnumerable`1<IProperty`1<TContainer>> m_Enumerable
private List`1<IProperty`1<TContainer>> m_Properties
private IndexedCollectionPropertyBagEnumerable`1<TContainer> m_IndexedCollectionPropertyBag
private PropertyCollection`1<TContainer> <Empty>k__BackingField
public PropertyCollection`1<TContainer> Empty
public PropertyCollection`1<TContainer> get_Empty()
public void .ctor(IEnumerable`1<IProperty`1<TContainer>> enumerable)
public void .ctor(List`1<IProperty`1<TContainer>> properties)
internal void .ctor(IndexedCollectionPropertyBagEnumerable`1<TContainer> enumerable)
public Enumerator<TContainer> GetEnumerator()
private IEnumerator`1<IProperty`1<TContainer>> System.Collections.Generic.IEnumerable<Unity.Properties.IProperty<TContainer>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Unity.Properties.PropertyContainer : object {
public void Accept(IPropertyBagVisitor visitor, TContainer container, VisitParameters parameters)
public void Accept(IPropertyBagVisitor visitor, TContainer& container, VisitParameters parameters)
public bool TryAccept(IPropertyBagVisitor visitor, TContainer& container, VisitParameters parameters)
public bool TryAccept(IPropertyBagVisitor visitor, TContainer& container, VisitReturnCode& returnCode, VisitParameters parameters)
public void Accept(IPropertyVisitor visitor, TContainer& container, PropertyPath& path, VisitParameters parameters)
public bool TryAccept(IPropertyVisitor visitor, TContainer& container, PropertyPath& path, VisitReturnCode& returnCode, VisitParameters parameters)
public IProperty GetProperty(TContainer container, PropertyPath& path)
public IProperty GetProperty(TContainer& container, PropertyPath& path)
public bool TryGetProperty(TContainer container, PropertyPath& path, IProperty& property)
public bool TryGetProperty(TContainer& container, PropertyPath& path, IProperty& property)
public bool TryGetProperty(TContainer& container, PropertyPath& path, IProperty& property, VisitReturnCode& returnCode)
public TValue GetValue(TContainer container, string name)
public TValue GetValue(TContainer& container, string name)
public TValue GetValue(TContainer container, PropertyPath& path)
public TValue GetValue(TContainer& container, PropertyPath& path)
public bool TryGetValue(TContainer container, string name, TValue& value)
public bool TryGetValue(TContainer& container, string name, TValue& value)
public bool TryGetValue(TContainer container, PropertyPath& path, TValue& value)
public bool TryGetValue(TContainer& container, PropertyPath& path, TValue& value)
public bool TryGetValue(TContainer& container, PropertyPath& path, TValue& value, VisitReturnCode& returnCode)
public bool IsPathValid(TContainer container, string path)
public bool IsPathValid(TContainer container, PropertyPath& path)
public bool IsPathValid(TContainer& container, string path)
public bool IsPathValid(TContainer& container, PropertyPath& path)
public void SetValue(TContainer container, string name, TValue value)
public void SetValue(TContainer& container, string name, TValue value)
public void SetValue(TContainer container, PropertyPath& path, TValue value)
public void SetValue(TContainer& container, PropertyPath& path, TValue value)
public bool TrySetValue(TContainer container, string name, TValue value)
public bool TrySetValue(TContainer& container, string name, TValue value)
public bool TrySetValue(TContainer container, PropertyPath& path, TValue value)
public bool TrySetValue(TContainer& container, PropertyPath& path, TValue value)
public bool TrySetValue(TContainer& container, PropertyPath& path, TValue value, VisitReturnCode& returnCode)
}
public Unity.Properties.PropertyGetter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TValue Invoke(TContainer& container)
public IAsyncResult BeginInvoke(TContainer& container, AsyncCallback callback, object object)
public TValue EndInvoke(TContainer& container, IAsyncResult result)
}
internal Unity.Properties.PropertyMember : ValueType {
internal PropertyInfo m_PropertyInfo
private string <Name>k__BackingField
public string Name
public bool IsReadOnly
public Type ValueType
public string get_Name()
public bool get_IsReadOnly()
public Type get_ValueType()
public void .ctor(PropertyInfo propertyInfo)
public object GetValue(object obj)
public void SetValue(object obj, object value)
public IEnumerable`1<Attribute> GetCustomAttributes()
}
public Unity.Properties.PropertyPath : ValueType {
internal int k_InlineCount
private PropertyPathPart m_Part0
private PropertyPathPart m_Part1
private PropertyPathPart m_Part2
private PropertyPathPart m_Part3
private int m_InlinePartsCount
private PropertyPathPart[] m_AdditionalParts
private int <Length>k__BackingField
public int Length
public bool IsEmpty
public PropertyPathPart Item
public int get_Length()
public bool get_IsEmpty()
public PropertyPathPart get_Item(int index)
public void .ctor(string path)
private void .ctor(PropertyPathPart& part)
private void .ctor(PropertyPathPart& part0, PropertyPathPart& part1)
private void .ctor(PropertyPathPart& part0, PropertyPathPart& part1, PropertyPathPart& part2)
private void .ctor(PropertyPathPart& part0, PropertyPathPart& part1, PropertyPathPart& part2, PropertyPathPart& part3)
internal void .ctor(List`1<PropertyPathPart> parts)
public PropertyPath FromPart(PropertyPathPart& part)
public PropertyPath FromName(string name)
public PropertyPath FromIndex(int index)
public PropertyPath FromKey(object key)
public PropertyPath Combine(PropertyPath& path, PropertyPath& pathToAppend)
public PropertyPath Combine(PropertyPath& path, string pathToAppend)
public PropertyPath AppendPart(PropertyPath& path, PropertyPathPart& part)
public PropertyPath AppendName(PropertyPath& path, string name)
public PropertyPath AppendIndex(PropertyPath& path, int index)
public PropertyPath AppendKey(PropertyPath& path, object key)
public PropertyPath AppendProperty(PropertyPath& path, IProperty property)
public PropertyPath Pop(PropertyPath& path)
public PropertyPath SubPath(PropertyPath& path, int startIndex)
public PropertyPath SubPath(PropertyPath& path, int startIndex, int length)
public string ToString()
private void AppendToBuilder(PropertyPathPart& part, StringBuilder builder)
private void GetParts(PropertyPath& path, List`1<PropertyPathPart> parts)
private PropertyPath ConstructFromPath(string path)
public bool Equals(PropertyPath other)
public bool Equals(object obj)
public int GetHashCode()
internal void <ConstructFromPath>g__TrimStart|37_0(<>c__DisplayClass37_0& )
internal void <ConstructFromPath>g__ReadNext|37_1(<>c__DisplayClass37_0& )
}
public Unity.Properties.PropertyPathPart : ValueType {
private PropertyPathPartKind m_Kind
private string m_Name
private int m_Index
private object m_Key
public bool IsName
public bool IsIndex
public bool IsKey
public PropertyPathPartKind Kind
public string Name
public int Index
public object Key
public bool get_IsName()
public bool get_IsIndex()
public bool get_IsKey()
public PropertyPathPartKind get_Kind()
public string get_Name()
public int get_Index()
public object get_Key()
public void .ctor(string name)
public void .ctor(int index)
public void .ctor(object key)
private void CheckKind(PropertyPathPartKind type)
public string ToString()
public bool Equals(PropertyPathPart other)
public bool Equals(object obj)
public int GetHashCode()
}
public Unity.Properties.PropertyPathPartKind : Enum {
public int value__
public PropertyPathPartKind Name
public PropertyPathPartKind Index
public PropertyPathPartKind Key
}
public Unity.Properties.PropertySetter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(TContainer& container, TValue value)
public IAsyncResult BeginInvoke(TContainer& container, TValue value, AsyncCallback callback, object object)
public void EndInvoke(TContainer& container, IAsyncResult result)
}
public Unity.Properties.PropertyVisitor : object {
private List`1<IPropertyVisitorAdapter> m_Adapters
public void AddAdapter(IPropertyVisitorAdapter adapter)
public void RemoveAdapter(IPropertyVisitorAdapter adapter)
private void Unity.Properties.IPropertyBagVisitor.Visit(IPropertyBag`1<TContainer> properties, TContainer& container)
private void Unity.Properties.IListPropertyBagVisitor.Visit(IListPropertyBag`2<TList, TElement> properties, TList& container)
private void Unity.Properties.IDictionaryPropertyBagVisitor.Visit(IDictionaryPropertyBag`3<TDictionary, TKey, TValue> properties, TDictionary& container)
private void Unity.Properties.IPropertyVisitor.Visit(Property`2<TContainer, TValue> property, TContainer& container)
internal void ContinueVisitation(Property`2<TContainer, TValue> property, TContainer& container, TValue& value)
private void Unity.Properties.ICollectionPropertyVisitor.Visit(Property`2<TContainer, TCollection> property, TContainer& container, TCollection& collection)
private void Unity.Properties.IListPropertyVisitor.Visit(Property`2<TContainer, TList> property, TContainer& container, TList& list)
private void Unity.Properties.ISetPropertyVisitor.Visit(Property`2<TContainer, TSet> property, TContainer& container, TSet& set)
private void Unity.Properties.IDictionaryPropertyVisitor.Visit(Property`2<TContainer, TDictionary> property, TContainer& container, TDictionary& dictionary)
protected bool IsExcluded(Property`2<TContainer, TValue> property, TContainer& container, TValue& value)
protected void VisitProperty(Property`2<TContainer, TValue> property, TContainer& container, TValue& value)
protected void VisitCollection(Property`2<TContainer, TCollection> property, TContainer& container, TCollection& value)
protected void VisitList(Property`2<TContainer, TList> property, TContainer& container, TList& value)
protected void VisitSet(Property`2<TContainer, TSet> property, TContainer& container, TSet& value)
protected void VisitDictionary(Property`2<TContainer, TDictionary> property, TContainer& container, TDictionary& value)
private bool IsExcluded(Property`2<TContainer, TValue> property, Enumerator enumerator, TContainer& container, TValue& value)
internal void ContinueVisitation(Property`2<TContainer, TValue> property, Enumerator enumerator, TContainer& container, TValue& value)
internal void ContinueVisitationWithoutAdapters(Property`2<TContainer, TValue> property, Enumerator enumerator, TContainer& container, TValue& value)
}
public Unity.Properties.ReflectedMemberProperty`2 : Property`2<TContainer, TValue> {
private IMemberInfo m_Info
private bool m_IsStructContainerType
private GetStructValueAction<TContainer, TValue> m_GetStructValueAction
private SetStructValueAction<TContainer, TValue> m_SetStructValueAction
private GetClassValueAction<TContainer, TValue> m_GetClassValueAction
private SetClassValueAction<TContainer, TValue> m_SetClassValueAction
private string <Name>k__BackingField
private bool <IsReadOnly>k__BackingField
public string Name
public bool IsReadOnly
public string get_Name()
public bool get_IsReadOnly()
public void .ctor(FieldInfo info, string name)
public void .ctor(PropertyInfo info, string name)
internal void .ctor(IMemberInfo info, string name)
public TValue GetValue(TContainer& container)
public void SetValue(TContainer& container, TValue value)
}
public Unity.Properties.SetPropertyBagBase`2 : PropertyBag`1<TSet> {
private SetElementProperty<TSet, TElement> m_Property
public PropertyCollection`1<TSet> GetProperties()
public PropertyCollection`1<TSet> GetProperties(TSet& container)
private IEnumerable`1<IProperty`1<TSet>> GetPropertiesEnumerable(TSet container)
private void Unity.Properties.ICollectionPropertyBagAccept<TSet>.Accept(ICollectionPropertyBagVisitor visitor, TSet& container)
private void Unity.Properties.ISetPropertyBagAccept<TSet>.Accept(ISetPropertyBagVisitor visitor, TSet& container)
private void Unity.Properties.ISetPropertyAccept<TSet>.Accept(ISetPropertyVisitor visitor, Property`2<TContainer, TSet> property, TContainer& container, TSet& dictionary)
public bool TryGetProperty(TSet& container, object key, IProperty`1& property)
}
public Unity.Properties.TypeConversion : object {
private ConversionRegistry s_GlobalConverters
public void Register(TypeConverter`2<TSource, TDestination> converter)
public TDestination Convert(TSource& value)
public bool TryConvert(TSource& source, TDestination& destination)
private bool TryConvertToUnityEngineObject(TSource source, TDestination& destination)
private bool IsNumericType(Type t)
}
public Unity.Properties.TypeConverter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TDestination Invoke(TSource& value)
public IAsyncResult BeginInvoke(TSource& value, AsyncCallback callback, object object)
public TDestination EndInvoke(TSource& value, IAsyncResult result)
}
public Unity.Properties.TypeGenerationOptions : Enum {
public int value__
public TypeGenerationOptions None
public TypeGenerationOptions ValueType
public TypeGenerationOptions ReferenceType
public TypeGenerationOptions Default
}
public Unity.Properties.TypeTraits : object {
public bool IsContainer(Type type)
}
public Unity.Properties.TypeTraits`1 : object {
private bool <IsValueType>k__BackingField
private bool <IsPrimitive>k__BackingField
private bool <IsInterface>k__BackingField
private bool <IsAbstract>k__BackingField
private bool <IsArray>k__BackingField
private bool <IsMultidimensionalArray>k__BackingField
private bool <IsEnum>k__BackingField
private bool <IsEnumFlags>k__BackingField
private bool <IsNullable>k__BackingField
private bool <IsObject>k__BackingField
private bool <IsString>k__BackingField
private bool <IsContainer>k__BackingField
private bool <CanBeNull>k__BackingField
private bool <IsPrimitiveOrString>k__BackingField
private bool <IsAbstractOrInterface>k__BackingField
private bool <IsUnityObject>k__BackingField
private bool <IsLazyLoadReference>k__BackingField
public bool IsValueType
public bool IsPrimitive
public bool IsInterface
public bool IsAbstract
public bool IsArray
public bool IsMultidimensionalArray
public bool IsEnum
public bool IsEnumFlags
public bool IsNullable
public bool IsObject
public bool IsString
public bool IsContainer
public bool CanBeNull
public bool IsPrimitiveOrString
public bool IsAbstractOrInterface
public bool IsUnityObject
public bool IsLazyLoadReference
public bool get_IsValueType()
public bool get_IsPrimitive()
public bool get_IsInterface()
public bool get_IsAbstract()
public bool get_IsArray()
public bool get_IsMultidimensionalArray()
public bool get_IsEnum()
public bool get_IsEnumFlags()
public bool get_IsNullable()
public bool get_IsObject()
public bool get_IsString()
public bool get_IsContainer()
public bool get_CanBeNull()
public bool get_IsPrimitiveOrString()
public bool get_IsAbstractOrInterface()
public bool get_IsUnityObject()
public bool get_IsLazyLoadReference()
}
public Unity.Properties.TypeUtility : object {
private ConcurrentDictionary`2<Type, ITypeConstructor> s_TypeConstructors
private MethodInfo s_CreateTypeConstructor
private ConcurrentDictionary`2<Type, string> s_CachedResolvedName
private ObjectPool`1<StringBuilder> s_Builders
private object syncedPoolObject
public string GetTypeDisplayName(Type type)
private string GetTypeDisplayName(Type type, IReadOnlyList`1<Type> args, Int32& argIndex)
public Type GetRootType(Type type)
private ITypeConstructor CreateTypeConstructor(Type type)
private ITypeConstructor`1<T> CreateTypeConstructor()
private ITypeConstructor GetTypeConstructor(Type type)
private ITypeConstructor`1<T> GetTypeConstructor()
public bool CanBeInstantiated(Type type)
public bool CanBeInstantiated()
public void SetExplicitInstantiationMethod(Func`1<T> constructor)
public T Instantiate()
public bool TryInstantiate(T& instance)
public T Instantiate(Type derivedType)
public bool TryInstantiate(Type derivedType, T& value)
public TArray InstantiateArray(int count)
public bool TryInstantiateArray(int count, TArray& instance)
public TArray InstantiateArray(Type derivedType, int count)
private void CheckIsAssignableFrom(Type type, Type derivedType)
private void CheckCanBeInstantiated(ITypeConstructor`1<T> constructor)
private void CheckCanBeInstantiated(ITypeConstructor constructor, Type type)
}
public Unity.Properties.VisitContext`1 : ValueType {
private Enumerator m_Enumerator
private PropertyVisitor m_Visitor
private VisitDelegate<TContainer> m_Continue
private VisitWithoutAdaptersDelegate<TContainer> m_ContinueWithoutAdapters
private IProperty`1<TContainer> <Property>k__BackingField
public IProperty`1<TContainer> Property
internal VisitContext`1<TContainer> FromProperty(PropertyVisitor visitor, Enumerator enumerator, Property`2<TContainer, TValue> property)
public IProperty`1<TContainer> get_Property()
private void .ctor(PropertyVisitor visitor, Enumerator enumerator, IProperty`1<TContainer> property, VisitDelegate<TContainer> continueVisitation, VisitWithoutAdaptersDelegate<TContainer> continueVisitationWithoutAdapters)
public void ContinueVisitation(TContainer& container)
public void ContinueVisitationWithoutAdapters(TContainer& container)
}
public Unity.Properties.VisitContext`2 : ValueType {
private Enumerator m_Enumerator
private PropertyVisitor m_Visitor
private Property`2<TContainer, TValue> <Property>k__BackingField
public Property`2<TContainer, TValue> Property
internal VisitContext`2<TContainer, TValue> FromProperty(PropertyVisitor visitor, Enumerator enumerator, Property`2<TContainer, TValue> property)
public Property`2<TContainer, TValue> get_Property()
private void .ctor(PropertyVisitor visitor, Enumerator enumerator, Property`2<TContainer, TValue> property)
public void ContinueVisitation(TContainer& container, TValue& value)
public void ContinueVisitationWithoutAdapters(TContainer& container, TValue& value)
}
public Unity.Properties.VisitExceptionKind : Enum {
public int value__
public VisitExceptionKind None
public VisitExceptionKind Internal
public VisitExceptionKind Visitor
public VisitExceptionKind All
}
public Unity.Properties.VisitParameters : ValueType {
private VisitExceptionKind <IgnoreExceptions>k__BackingField
public VisitExceptionKind IgnoreExceptions
public VisitExceptionKind get_IgnoreExceptions()
public void set_IgnoreExceptions(VisitExceptionKind value)
}
public Unity.Properties.VisitReturnCode : Enum {
public int value__
public VisitReturnCode Ok
public VisitReturnCode NullContainer
public VisitReturnCode InvalidContainerType
public VisitReturnCode MissingPropertyBag
public VisitReturnCode InvalidPath
public VisitReturnCode InvalidCast
public VisitReturnCode AccessViolation
}
