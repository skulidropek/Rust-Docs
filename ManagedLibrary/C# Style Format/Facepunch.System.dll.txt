public BitUtility : object {
private float float2byte
private float byte2float
private float float2short
private float short2float
public byte Float2Byte(float f)
public float Byte2Float(int b)
public short Float2Short(float f)
public float Short2Float(int b)
public Color32 EncodeFloat(float f)
public float DecodeFloat(Color32 c)
public Color32 EncodeInt(int i)
public int DecodeInt(Color32 c)
public Color32 EncodeShort(short i)
public short DecodeShort(Color32 c)
public Color EncodeNormal(Vector3 n)
public Vector3 DecodeNormal(Color c)
public Color32 EncodeVector(Vector4 v)
public Vector4 DecodeVector(Color32 c)
public Color32 EncodeVector2i(Vector2i v)
public Vector2i DecodeVector2i(Color32 c)
}
public BufferList`1 : object {
private int count
private T[] buffer
public int Count
public int Capacity
public T[] Buffer
public T Item
public int get_Count()
public int get_Capacity()
public T[] get_Buffer()
public T get_Item(int index)
public void set_Item(int index, T value)
public void .ctor(int capacity)
public void Push(T element)
public T Pop()
public void Add(T element)
public bool Remove(T element)
public void RemoveAt(int index)
public void RemoveUnordered(int index)
public int IndexOf(T element)
public int LastIndexOf(T element)
public bool Contains(T element)
public void Clear()
public void Sort()
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Checksum : object {
private List`1<byte> values
public void Add(float f, int bytes)
public void Add(float f)
public void Add(int i)
public void Add(UInt32 u)
public void Add(short i)
public void Add(ushort u)
public void Add(byte b)
public void Clear()
public string MD5()
public string SHA1()
public string ToString()
private string BytesToString(Byte[] bytes)
}
public CircularBuffer.CircularBuffer`1 : object {
private T[] _buffer
private int _start
private int _end
private int _size
public int Capacity
public bool IsFull
public bool IsEmpty
public int Size
public T Item
public void .ctor(int capacity)
public void .ctor(int capacity, T[] items)
public int get_Capacity()
public bool get_IsFull()
public bool get_IsEmpty()
public int get_Size()
public T Front()
public T Back()
public T get_Item(int index)
public void set_Item(int index, T value)
public void PushBack(T item)
public void PushFront(T item)
public void PopBack()
public void PopFront()
public void Clear()
public T[] ToArray()
public IList`1<ArraySegment`1<T>> ToArraySegments()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void ThrowIfEmpty(string message)
private void Increment(Int32& index)
private void Decrement(Int32& index)
private int InternalIndex(int index)
private ArraySegment`1<T> ArrayOne()
private ArraySegment`1<T> ArrayTwo()
}
public Deque`1 : object {
private T[] buffer
private int offset
private int count
public T Item
public int Count
public bool IsEmpty
public bool IsFull
public bool IsSplit
public int Capacity
public T Front
public T Back
public void .ctor(int capacity)
public T get_Item(int index)
public void set_Item(int index, T value)
public int get_Count()
public bool get_IsEmpty()
public bool get_IsFull()
public bool get_IsSplit()
public int get_Capacity()
public T get_Front()
public T get_Back()
public void Clear()
public void Resize(int capacity)
public T PeekBack()
public T PeekFront()
public void PushBack(T value)
public void PushFront(T value)
public T PopBack()
public T PopFront()
}
public Facepunch.ArrayPool`1 : object {
private int count
private ConcurrentQueue`1[] buffer
public void .ctor(int maxSize)
public ConcurrentQueue`1[] GetBuffer()
public T[] Rent(int minSize)
public void Return(T[] array)
public int SizeToIndex(int size)
public int IndexToSize(int index)
}
public Facepunch.ByteArrayStream : Stream {
private Byte[] _data
private int _base
private int _length
private int _position
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void SetData(Byte[] data, int offset, int length)
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public long Seek(long offset, SeekOrigin origin)
public void Flush()
public void SetLength(long value)
}
public Facepunch.CommandLine : object {
private bool initialized
private string commandline
private Dictionary`2<string, string> switches
public string Full
public string get_Full()
public void Force(string val)
private void Initalize()
public bool HasSwitch(string strName)
public string GetSwitch(string strName, string strDefault)
public int GetSwitchInt(string strName, int iDefault)
public Dictionary`2<string, string> GetSwitches()
}
public Facepunch.Crypt.Md5 : object {
public string Calculate(string input)
public string Calculate(Byte[] input)
}
public Facepunch.Extend.Base36Extensions : object {
private string CharList
private Char[] CharArray
public string ToBase36(T i)
public long FromBase36(string input)
}
public Facepunch.Extend.ByteExtensions : object {
public T ReadUnsafe(Byte[] buffer, int iOffset)
public void WriteUnsafe(Byte[] buffer, T& value, int iOffset)
}
public Facepunch.Extend.DictionaryExtensions : object {
public TValue GetOrCreate(Dictionary`2<TKey, TValue> dict, TKey key)
public TValue GetOrCreatePooled(Dictionary`2<TKey, TValue> dict, TKey key)
public Dictionary`2<TKey, TValue> Clone(Dictionary`2<TKey, TValue> dict)
}
public Facepunch.Extend.List : object {
public void Compare(TListA a, TListB b, List`1<T> added, List`1<T> removed, List`1<T> remained)
public void Compare(TListA a, TListB b, HashSet`1<TKey> added, HashSet`1<TKey> removed, HashSet`1<TKey> remained, Func`2<TItemA, TKey> selectorA, Func`2<TItemB, TKey> selectorB)
public TItem FindWith(IReadOnlyCollection`1<TItem> items, Func`2<TItem, TKey> selector, TKey search, IEqualityComparer`1<TKey> comparer)
public Nullable`1<TItem> TryFindWith(IReadOnlyCollection`1<TItem> items, Func`2<TItem, TKey> selector, TKey search, IEqualityComparer`1<TKey> comparer)
public int FindIndexWith(IReadOnlyList`1<TItem> items, Func`2<TItem, TKey> selector, TKey search)
internal void <Compare>g__InitializeWith|1_0(HashSet`1<TKey> set, HashSet`1<TKey> values)
}
public Facepunch.Extend.NumberExtensions : object {
public string FormatBytes(T input, bool shortFormat)
public T Clamp(T input, T min, T max)
public string FormatSeconds(ulong i)
public string FormatSeconds(long s)
public string FormatSecondsLong(ulong i)
public string FormatSecondsLong(long s)
public string FormatNumberShort(ulong i)
public string FormatNumberShort(long num)
public string FormatDistance(float num)
}
public Facepunch.Extend.ReflectionExtensions : object {
public bool HasAttribute(MemberInfo method, Type attribute)
}
public Facepunch.Extend.StringExtensions : object {
private Regex regexSplitQuotes
private Char[] spaceOrQuote
private StringBuilder _quoteSafeBuilder
private Char[] FilenameDelim
private Char[] _badCharacters
public string QuoteSafe(string str)
public String[] SplitQuotesStrings(string input, int maxCount)
public decimal ToDecimal(string str, decimal Default)
public float ToFloat(string str, float Default)
public int ToInt(string str, int Default)
public long ToLong(string str, long Default)
public bool ToBool(string str)
public string Truncate(string str, int maxLength, string appendage)
public string TruncateFilename(string str, int maxLength, string appendage)
public bool Contains(string source, string toCheck, StringComparison comp)
public string Snippet(string source, string find, int padding)
public string RemoveBadCharacters(string str)
public string Base64Encode(string plainText)
public string Base64Decode(string base64EncodedData)
}
public Facepunch.Pool : object {
public ConcurrentDictionary`2<Type, IPoolCollection> Directory
public void FreeList(List`1& obj)
public void FreeMemoryStream(MemoryStream& obj)
public void Free(T& obj)
public void FreeDynamic(T& obj)
private void FreeInternal(T& obj)
public T Get()
public List`1<T> GetList()
public void ResizeBuffer(int size)
public void FillBuffer()
public PoolCollection`1<T> FindCollection()
public void Clear(string filter)
private bool Contains(string haystack, string needle, CompareOptions options)
}
internal Facepunch.Pool`1 : object {
public PoolCollection`1<T> Collection
}
public GenericsUtil : object {
public TDst Cast(TSrc obj)
public void Swap(T& a, T& b)
}
public IImmutableStack`1 {
public int Count
public int get_Count()
public IImmutableStack`1<T> Push(T value)
public IImmutableStack`1<T> Pop()
public T Peek()
}
public ILinkedListNode`1 {
public T next
public T get_next()
public void set_next(T value)
}
public IMinHeapNode`1 {
public T child
public int order
public T get_child()
public void set_child(T value)
public int get_order()
}
public ImmutableStack`1 : object {
private IImmutableStack`1<T> <Empty>k__BackingField
private T _head
private IImmutableStack`1<T> _tail
private int <Count>k__BackingField
public IImmutableStack`1<T> Empty
public int Count
public IImmutableStack`1<T> get_Empty()
private void .ctor(T head, IImmutableStack`1<T> tail)
public int get_Count()
public T Peek()
public IImmutableStack`1<T> Pop()
public IImmutableStack`1<T> Push(T value)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public IntrusiveLinkedList`1 : ValueType {
private T head
public bool Empty
public bool get_Empty()
public void Add(T item)
public T Pop()
}
public IntrusiveMinHeap`1 : ValueType {
private T head
public bool Empty
public bool get_Empty()
public void Add(T item)
public T Pop()
}
public ListDictionary`2 : object {
private Dictionary`2<TKey, int> key2idx
private Dictionary`2<int, TKey> idx2key
private BufferList`1<TKey> keys
private BufferList`1<TVal> vals
public TVal Item
public BufferList`1<TKey> Keys
public BufferList`1<TVal> Values
public int Count
public void .ctor(int capacity)
public void Add(TKey key, TVal val)
public bool Contains(TKey key)
public bool ContainsKey(TKey key)
public bool Remove(TKey key)
public bool RemoveAt(int idx)
private void Remove(int idx_remove, TKey key_remove)
public bool TryGetValue(TKey key, TVal& val)
public KeyValuePair`2<TKey, TVal> GetByIndex(int idx)
public TVal get_Item(TKey key)
public void set_Item(TKey key, TVal value)
public void Clear()
public BufferList`1<TKey> get_Keys()
public BufferList`1<TVal> get_Values()
public int get_Count()
public IEnumerator`1<KeyValuePair`2<TKey, TVal>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public ListHashSet`1 : object {
private Dictionary`2<T, int> val2idx
private Dictionary`2<int, T> idx2val
private BufferList`1<T> vals
public BufferList`1<T> Values
public int Count
public bool IsReadOnly
public T Item
public void .ctor(int capacity)
public void Add(T val)
public void AddRange(List`1<T> list)
public bool Contains(T val)
public bool Remove(T val)
public void RemoveAt(int idx)
public int IndexOf(T item)
public void Insert(int index, T item)
public void Clear()
private void Remove(int idx_remove, T val_remove)
public void CopyTo(T[] array, int arrayIndex)
public BufferList`1<T> get_Values()
public int get_Count()
public bool get_IsReadOnly()
public T get_Item(int index)
public void set_Item(int index, T value)
public Enumerator<T> GetEnumerator()
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public MaxQueue : object {
private Deque`1<int> data
private Deque`1<int> max
public int Max
public void .ctor(int capacity)
public void Push(int value)
public int Pop()
public int get_Max()
}
public Memoized`2 : object {
private Func`2<TArgs, TResult> _factory
private Dictionary`2<TArgs, TResult> _cache
public void .ctor(Func`2<TArgs, TResult> factory)
public TResult Get(TArgs args)
}
public MinQueue : object {
private Deque`1<int> data
private Deque`1<int> min
public int Min
public void .ctor(int capacity)
public void Push(int value)
public int Pop()
public int get_Min()
}
public MruDictionary`2 : object {
private int capacity
private Queue`1<LinkedListNode`1<KeyValuePair`2<Key, Value>>> recycled
private LinkedList`1<KeyValuePair`2<Key, Value>> list
private Dictionary`2<Key, LinkedListNode`1<KeyValuePair`2<Key, Value>>> dict
private Action`2<Key, Value> valueRecycler
public int Capacity
public int Count
public int get_Capacity()
public int get_Count()
public void .ctor(int capacity, Action`2<Key, Value> valueRecycler)
public void Add(Key key, Value value)
public void Remove(Key key)
private void RemoveLast()
public bool TryGetValue(Key key, Value& value)
public void Clear()
public Enumerator<KeyValuePair`2<Key, Value>> GetEnumerator()
private IEnumerator`1<KeyValuePair`2<Key, Value>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<Key,Value>>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public SpanningTree`1 : object {
private List`1<Node<T>> nodes
private List`1<Edge<T>> edges
public int AddNode()
public void AddEdge(int a_idx, int b_idx, int cost, T value)
public void Clear()
public void Reset()
public void CalculateMin()
public void ForEach(Action`1<T> action)
}
public Spatial.Grid`1 : object {
private int <CellCount>k__BackingField
private int <CellSize>k__BackingField
private float CenterX
private float CenterY
private Node[0...,0...] Nodes
private Dictionary`2<T, Node<T>> Lookup
public int CellCount
public int CellSize
public int get_CellCount()
private void set_CellCount(int value)
public int get_CellSize()
private void set_CellSize(int value)
public void .ctor(int CellSize, float WorldSize)
public int Query(float x, float y, float radius, T[] result, Func`2<T, bool> filter)
private int Clamp(float input)
private Node<T> GetNode(float x, float y, bool create)
public void Add(T obj, float x, float y)
public void Move(T obj, float x, float y)
public bool Remove(T obj)
}
public StringBuilderExtensions : object {
public StringBuilder QuoteSafe(StringBuilder builder, string value)
}
public Union16 : ValueType {
public short i
public ushort u
public byte b1
public byte b2
}
public Union32 : ValueType {
public int i
public UInt32 u
public float f
public byte b1
public byte b2
public byte b3
public byte b4
}
public Union64 : ValueType {
public long i
public ulong u
public double f
public byte b1
public byte b2
public byte b3
public byte b4
public byte b5
public byte b6
public byte b7
public byte b8
}
public Union8 : ValueType {
public sbyte i
public byte u
public byte b1
}
public Vector2b : ValueType {
public Vector2b alltrue
public Vector2b allfalse
public bool x
public bool y
public void .ctor(bool x, bool y)
public bool op_Equality(Vector2b a, Vector2b b)
public bool op_Inequality(Vector2b a, Vector2b b)
public bool Equals(Vector2b o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector2i : ValueType {
public Vector2i zero
public Vector2i one
public Vector2i left
public Vector2i right
public Vector2i forward
public Vector2i back
public int x
public int y
public void .ctor(int x, int y)
public Vector2i op_RightShift(Vector2i v, int shift)
public Vector2i op_LeftShift(Vector2i v, int shift)
public Vector2i op_UnaryPlus(Vector2i v)
public Vector2i op_UnaryNegation(Vector2i v)
public Vector2i op_Addition(Vector2i a, Vector2i b)
public Vector2i op_Subtraction(Vector2i a, Vector2i b)
public Vector2i op_Multiply(Vector2i v, int multiplier)
public Vector2i op_Division(Vector2i v, int divisor)
public Vector2 op_Multiply(Vector2i v, float multiplier)
public Vector2 op_Division(Vector2i v, float divisor)
public Vector2i op_Modulus(Vector2i v, int mod)
public Vector2 op_Implicit(Vector2i other)
public Vector2i op_Explicit(Vector2 other)
public bool op_Equality(Vector2i a, Vector2i b)
public bool op_Inequality(Vector2i a, Vector2i b)
public bool Equals(Vector2i o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector3b : ValueType {
public Vector3b alltrue
public Vector3b allfalse
public bool x
public bool y
public bool z
public void .ctor(bool x, bool y, bool z)
public bool op_Equality(Vector3b a, Vector3b b)
public bool op_Inequality(Vector3b a, Vector3b b)
public bool Equals(Vector3b o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
public Vector3i : ValueType {
public Vector3i zero
public Vector3i one
public Vector3i forward
public Vector3i back
public Vector3i up
public Vector3i down
public Vector3i right
public Vector3i left
public int x
public int y
public int z
public void .ctor(int x, int y, int z)
public Vector3i op_RightShift(Vector3i v, int shift)
public Vector3i op_LeftShift(Vector3i v, int shift)
public Vector3i op_UnaryPlus(Vector3i v)
public Vector3i op_UnaryNegation(Vector3i v)
public Vector3i op_Addition(Vector3i a, Vector3i b)
public Vector3i op_Subtraction(Vector3i a, Vector3i b)
public Vector3i op_Multiply(Vector3i v, int multiplier)
public Vector3i op_Division(Vector3i v, int divisor)
public Vector3 op_Multiply(Vector3i v, float multiplier)
public Vector3 op_Division(Vector3i v, float divisor)
public Vector3i op_Modulus(Vector3i v, int mod)
public Vector3 op_Implicit(Vector3i other)
public Vector3i op_Explicit(Vector3 other)
public bool op_Equality(Vector3i a, Vector3i b)
public bool op_Inequality(Vector3i a, Vector3i b)
public bool Equals(Vector3i o)
public int GetHashCode()
public bool Equals(object o)
public string ToString()
}
