public BitUtility : object {
private float float2byte
private float byte2float
private float float2short
private float short2float
public byte Float2Byte(float f)
public float Byte2Float(int b)
public short Float2Short(float f)
public float Short2Float(int b)
public Color32 EncodeFloat(float f)
public float DecodeFloat(Color32 c)
public Color32 EncodeInt(int i)
public int DecodeInt(Color32 c)
public Color32 EncodeShort(short i)
public short DecodeShort(Color32 c)
public Color EncodeNormal(Vector3 n)
public Vector3 DecodeNormal(Color c)
public Color32 EncodeVector(Vector4 v)
public Vector4 DecodeVector(Color32 c)
}
public BufferList`1 : object {
private int count
private T[] buffer
public int Count
public int Capacity
public T[] Buffer
public T Item
public int get_Count()
public int get_Capacity()
public T[] get_Buffer()
public T get_Item(int index)
public void set_Item(int index, T value)
public void .ctor(int capacity)
public void Add(T element)
public bool Remove(T element)
public void RemoveAt(int index)
public void RemoveUnordered(int index)
public int IndexOf(T element)
public int LastIndexOf(T element)
public bool Contains(T element)
public void Clear()
public void Sort()
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public Checksum : object {
private List`1<byte> values
public void Add(float f, int bytes)
public void Add(float f)
public void Add(int i)
public void Add(UInt32 u)
public void Add(short i)
public void Add(ushort u)
public void Add(byte b)
public void Clear()
public string MD5()
public string SHA1()
public string ToString()
private string BytesToString(Byte[] bytes)
}
public Deque`1 : object {
private T[] buffer
private int offset
private int count
public int Count
public bool IsEmpty
public bool IsFull
public bool IsSplit
public int Capacity
public T Front
public T Back
public void .ctor(int capacity)
public int get_Count()
public bool get_IsEmpty()
public bool get_IsFull()
public bool get_IsSplit()
public int get_Capacity()
public T get_Front()
public T get_Back()
public void Clear()
public void Resize(int capacity)
public void PushBack(T value)
public void PushFront(T value)
public T PopBack()
public T PopFront()
}
public Facepunch.CommandLine : object {
private bool initialized
private string commandline
private Dictionary`2<string, string> switches
public string Full
public string get_Full()
public void Force(string val)
private void Initalize()
public bool HasSwitch(string strName)
public string GetSwitch(string strName, string strDefault)
public int GetSwitchInt(string strName, int iDefault)
public Dictionary`2<string, string> GetSwitches()
}
public Facepunch.Crypt.Md5 : object {
public string Calculate(string input)
public string Calculate(Byte[] input)
}
public Facepunch.Extend.Base36Extensions : object {
private string CharList
private Char[] CharArray
public string ToBase36(T i)
public long FromBase36(string input)
}
public Facepunch.Extend.ByteExtensions : object {
public float ReadFloat(Byte[] buffer, int iOffset)
public void WriteFloat(Byte[] buffer, float f, int iOffset)
}
public Facepunch.Extend.DictionaryExtensions : object {
public TValue GetOrCreate(Dictionary`2<TKey, TValue> dict, TKey key)
public TValue GetOrCreatePooled(Dictionary`2<TKey, TValue> dict, TKey key)
public Dictionary`2<TKey, TValue> Clone(Dictionary`2<TKey, TValue> dict)
}
public Facepunch.Extend.List : object {
public void Compare(List`1<T> a, List`1<T> b, List`1<T> added, List`1<T> removed, List`1<T> remained)
}
public Facepunch.Extend.NumberExtensions : object {
public string FormatBytes(T input, bool shortFormat)
public T Clamp(T input, T min, T max)
public string FormatSeconds(ulong i)
public string FormatSeconds(long s)
public string FormatSecondsLong(ulong i)
public string FormatSecondsLong(long s)
public string FormatNumberShort(ulong i)
public string FormatNumberShort(long num)
}
public Facepunch.Extend.ReflectionExtensions : object {
public bool HasAttribute(MemberInfo method, Type attribute)
}
public Facepunch.Extend.StringExtensions : object {
private Char[] FilenameDelim
private Char[] _badCharacters
public string QuoteSafe(string str)
public String[] SplitQuotesStrings(string input)
public decimal ToDecimal(string str, decimal Default)
public float ToFloat(string str, float Default)
public int ToInt(string str, int Default)
public bool ToBool(string str)
public string Truncate(string str, int maxLength, string appendage)
public string TruncateFilename(string str, int maxLength, string appendage)
public bool Contains(string source, string toCheck, StringComparison comp)
public string Snippet(string source, string find, int padding)
public string RemoveBadCharacters(string str)
public string Base64Encode(string plainText)
public string Base64Decode(string base64EncodedData)
}
public Facepunch.Pool : object {
public Dictionary`2<Type, ICollection> directory
public void FreeList(List`1& obj)
public void FreeMemoryStream(MemoryStream& obj)
public void Free(T& obj)
private void FreeInternal(T& obj)
public T Get()
public List`1<T> GetList()
public void ResizeBuffer(int size)
public void FillBuffer(int count)
public PoolCollection`1<T> FindCollection()
public void Clear()
}
internal Facepunch.Pool`1 : object {
public PoolCollection`1<T> Collection
}
public ILinkedListNode`1 {
public T next
public T get_next()
public void set_next(T value)
}
public IMinHeapNode`1 {
public T child
public int order
public T get_child()
public void set_child(T value)
public int get_order()
}
public IntrusiveLinkedList`1 : ValueType {
private T head
public bool Empty
public bool get_Empty()
public void Add(T item)
public T Pop()
}
public IntrusiveMinHeap`1 : ValueType {
private T head
public bool Empty
public bool get_Empty()
public void Add(T item)
public T Pop()
}
public ListDictionary`2 : object {
private Dictionary`2<TKey, int> key2idx
private Dictionary`2<int, TKey> idx2key
private BufferList`1<TKey> keys
private BufferList`1<TVal> vals
public TVal Item
public BufferList`1<TKey> Keys
public BufferList`1<TVal> Values
public int Count
public void .ctor(int capacity)
public void Add(TKey key, TVal val)
public bool Contains(TKey key)
public bool Remove(TKey key)
public bool RemoveAt(int idx)
private void Remove(int idx_remove, TKey key_remove)
public bool TryGetValue(TKey key, TVal& val)
public KeyValuePair`2<TKey, TVal> GetByIndex(int idx)
public TVal get_Item(TKey key)
public void set_Item(TKey key, TVal value)
public void Clear()
public BufferList`1<TKey> get_Keys()
public BufferList`1<TVal> get_Values()
public int get_Count()
public IEnumerator`1<KeyValuePair`2<TKey, TVal>> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public ListHashSet`1 : object {
private Dictionary`2<T, int> val2idx
private Dictionary`2<int, T> idx2val
private BufferList`1<T> vals
public BufferList`1<T> Values
public int Count
public T Item
public void .ctor(int capacity)
public void Add(T val)
public void AddRange(List`1<T> list)
public bool Contains(T val)
public bool Remove(T val)
public bool RemoveAt(int idx)
public void Clear()
private void Remove(int idx_remove, T val_remove)
public BufferList`1<T> get_Values()
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
public IEnumerator`1<T> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public MaxQueue : object {
private Deque`1<int> data
private Deque`1<int> max
public int Max
public void .ctor(int capacity)
public void Push(int value)
public int Pop()
public int get_Max()
}
public MinQueue : object {
private Deque`1<int> data
private Deque`1<int> min
public int Min
public void .ctor(int capacity)
public void Push(int value)
public int Pop()
public int get_Min()
}
public MruDictionary`2 : object {
private int capacity
private Queue`1<LinkedListNode`1<KeyValuePair`2<Key, Value>>> recycled
private LinkedList`1<KeyValuePair`2<Key, Value>> list
private Dictionary`2<Key, LinkedListNode`1<KeyValuePair`2<Key, Value>>> dict
public int Count
public int get_Count()
public void .ctor(int capacity)
public void Clear()
public void Add(Key key, Value value)
public KeyValuePair`2<Key, Value> GetLast()
public void RemoveLast()
public bool TryGetValue(Key key, Value& value)
public bool Touch(Key key)
}
public SpanningTree`1 : object {
private List`1<Node<T>> nodes
private List`1<Edge<T>> edges
public int AddNode()
public void AddEdge(int a_idx, int b_idx, int cost, T value)
public void Clear()
public void Reset()
public void CalculateMin()
public void ForEach(Action`1<T> action)
}
public Spatial.Grid`1 : object {
private int <CellCount>k__BackingField
private int <CellSize>k__BackingField
private float CenterX
private float CenterY
private Node[0...,0...] Nodes
private Dictionary`2<T, Node<T>> Lookup
public int CellCount
public int CellSize
public int get_CellCount()
private void set_CellCount(int value)
public int get_CellSize()
private void set_CellSize(int value)
public void .ctor(int CellSize, float WorldSize)
public int Query(float x, float y, float radius, T[] result, Func`2<T, bool> filter)
private int Clamp(float input)
private Node<T> GetNode(float x, float y, bool create)
public void Add(T obj, float x, float y)
public void Move(T obj, float x, float y)
public bool Remove(T obj)
}
public Union16 : ValueType {
public short i
public ushort u
public byte b1
public byte b2
}
public Union32 : ValueType {
public int i
public UInt32 u
public float f
public byte b1
public byte b2
public byte b3
public byte b4
}
public Union64 : ValueType {
public long i
public ulong u
public double f
public byte b1
public byte b2
public byte b3
public byte b4
public byte b5
public byte b6
public byte b7
public byte b8
}
public Union8 : ValueType {
public sbyte i
public byte u
public byte b1
}
