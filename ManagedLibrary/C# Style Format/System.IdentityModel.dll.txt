internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal Mono.Security.Cryptography.HMAC : KeyedHashAlgorithm {
private HashAlgorithm hash
private bool hashing
private Byte[] innerPad
private Byte[] outerPad
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public void .ctor(string hashName, Byte[] rgbKey)
public void Initialize()
protected Byte[] HashFinal()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
private void initializePad()
}
public System.IdentityModel.Claims.Claim : object {
private ClaimComparer default_comparer
private Claim system
private string claim_type
private object resource
private string right
public IEqualityComparer`1<Claim> DefaultComparer
public Claim System
public object Resource
public string ClaimType
public string Right
public IEqualityComparer`1<Claim> get_DefaultComparer()
public Claim get_System()
public Claim CreateDnsClaim(string dns)
public Claim CreateDenyOnlyWindowsSidClaim(SecurityIdentifier sid)
public Claim CreateHashClaim(Byte[] hash)
public Claim CreateMailAddressClaim(MailAddress mailAddress)
public Claim CreateNameClaim(string name)
public Claim CreateRsaClaim(RSA rsa)
public Claim CreateSpnClaim(string spn)
public Claim CreateThumbprintClaim(Byte[] thumbprint)
public Claim CreateUpnClaim(string upn)
public Claim CreateUriClaim(Uri uri)
public Claim CreateWindowsSidClaim(SecurityIdentifier sid)
public Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName)
public void .ctor(string claimType, object resource, string right)
public object get_Resource()
public string get_ClaimType()
public string get_Right()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public System.IdentityModel.Claims.ClaimSet : object {
private ClaimSet system
private ClaimSet win
public ClaimSet System
public ClaimSet Windows
public int Count
public ClaimSet Issuer
public Claim Item
public ClaimSet get_System()
public ClaimSet get_Windows()
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public bool ContainsClaim(Claim claim)
public bool ContainsClaim(Claim claim, IEqualityComparer`1<Claim> comparer)
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.IdentityModel.Claims.ClaimTypes : object {
public string Anonymous
public string Authentication
public string AuthorizationDecision
public string Country
public string DateOfBirth
public string DenyOnlySid
public string Dns
public string Email
public string Gender
public string GivenName
public string Hash
public string HomePhone
public string Locality
public string MobilePhone
public string Name
public string NameIdentifier
public string OtherPhone
public string PostalCode
public string PPID
public string Rsa
public string Sid
public string Spn
public string StateOrProvince
public string StreetAddress
public string Surname
public string System
public string Thumbprint
public string Upn
public string Uri
public string Webpage
public string X500DistinguishedName
public string get_Anonymous()
public string get_Authentication()
public string get_AuthorizationDecision()
public string get_Country()
public string get_DateOfBirth()
public string get_DenyOnlySid()
public string get_Dns()
public string get_Email()
public string get_Gender()
public string get_GivenName()
public string get_Hash()
public string get_HomePhone()
public string get_Locality()
public string get_MobilePhone()
public string get_Name()
public string get_NameIdentifier()
public string get_OtherPhone()
public string get_PostalCode()
public string get_PPID()
public string get_Rsa()
public string get_Sid()
public string get_Spn()
public string get_StateOrProvince()
public string get_StreetAddress()
public string get_Surname()
public string get_System()
public string get_Thumbprint()
public string get_Upn()
public string get_Uri()
public string get_Webpage()
public string get_X500DistinguishedName()
}
public System.IdentityModel.Claims.DefaultClaimSet : ClaimSet {
private List`1<Claim> list
private ClaimSet issuer
public int Count
public ClaimSet Issuer
public Claim Item
internal DefaultClaimSet CreateSystemClaimSet()
public void .ctor(Claim[] claims)
public void .ctor(IList`1<Claim> claims)
public void .ctor(ClaimSet issuer, Claim[] claims)
public void .ctor(ClaimSet issuer, IList`1<Claim> claims)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public bool ContainsClaim(Claim claim)
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
protected void Initialize(ClaimSet issuer, IList`1<Claim> claims)
public string ToString()
}
public System.IdentityModel.Claims.Rights : object {
public string Identity
public string PossessProperty
public string get_Identity()
public string get_PossessProperty()
}
public System.IdentityModel.Claims.WindowsClaimSet : ClaimSet {
private WindowsIdentity identity
private DateTime expiration_time
public int Count
public ClaimSet Issuer
public Claim Item
public DateTime ExpirationTime
public WindowsIdentity WindowsIdentity
public void .ctor(WindowsIdentity windowsIdentity)
public void .ctor(WindowsIdentity windowsIdentity, bool includeWindowsGroups)
public void .ctor(WindowsIdentity windowsIdentity, DateTime expirationTime)
public void .ctor(WindowsIdentity windowsIdentity, bool includeWindowsGroups, DateTime expirationTime)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public DateTime get_ExpirationTime()
public WindowsIdentity get_WindowsIdentity()
public void Dispose()
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
public string ToString()
}
public System.IdentityModel.Claims.X509CertificateClaimSet : ClaimSet {
private X509Certificate2 cert
private ClaimSet issuer
private List`1<Claim> claims
public int Count
public ClaimSet Issuer
public Claim Item
public DateTime ExpirationTime
public X509Certificate2 X509Certificate
public void .ctor(X509Certificate2 certificate)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public DateTime get_ExpirationTime()
public X509Certificate2 get_X509Certificate()
public void Dispose()
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
public string ToString()
}
public System.IdentityModel.Configuration.ICustomIdentityConfiguration {
public void LoadCustomConfiguration(XmlNodeList nodeList)
}
public System.IdentityModel.Configuration.IdentityModelCaches : object {
private SessionSecurityTokenCache <SessionSecurityTokenCache>k__BackingField
private TokenReplayCache <TokenReplayCache>k__BackingField
public SessionSecurityTokenCache SessionSecurityTokenCache
public TokenReplayCache TokenReplayCache
public SessionSecurityTokenCache get_SessionSecurityTokenCache()
public void set_SessionSecurityTokenCache(SessionSecurityTokenCache value)
public TokenReplayCache get_TokenReplayCache()
public void set_TokenReplayCache(TokenReplayCache value)
}
public System.IdentityModel.CookieTransform : object {
public Byte[] Encode(Byte[] value)
}
public System.IdentityModel.OpenObject : object {
private Dictionary`2<string, object> properties
public Dictionary`2<string, object> Properties
public Dictionary`2<string, object> get_Properties()
}
public System.IdentityModel.Policy.AuthorizationContext : object {
public DateTime ExpirationTime
public string Id
public ReadOnlyCollection`1<ClaimSet> ClaimSets
public IDictionary`2<string, object> Properties
public AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies)
public DateTime get_ExpirationTime()
public string get_Id()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public IDictionary`2<string, object> get_Properties()
}
internal System.IdentityModel.Policy.DefaultEvaluationContext : EvaluationContext {
private DateTime expiration_time
private int generation
private Collection`1<ClaimSet> claim_sets
private ReadOnlyCollection`1<ClaimSet> exposed_claim_sets
private Dictionary`2<string, object> properties
private Dictionary`2<IAuthorizationPolicy, ClaimSet> claim_set_map
public int Generation
public IDictionary`2<string, object> Properties
public ReadOnlyCollection`1<ClaimSet> ClaimSets
internal DateTime ExpirationTime
public int get_Generation()
public IDictionary`2<string, object> get_Properties()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public void AddClaimSet(IAuthorizationPolicy authorizationPolicy, ClaimSet claimSet)
public void RecordExpirationTime(DateTime time)
internal DateTime get_ExpirationTime()
}
public System.IdentityModel.Policy.EvaluationContext : object {
public int Generation
public IDictionary`2<string, object> Properties
public ReadOnlyCollection`1<ClaimSet> ClaimSets
public int get_Generation()
public IDictionary`2<string, object> get_Properties()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet)
public void RecordExpirationTime(DateTime expirationTime)
}
public System.IdentityModel.Policy.IAuthorizationComponent {
public string Id
public string get_Id()
}
public System.IdentityModel.Policy.IAuthorizationPolicy {
public ClaimSet Issuer
public ClaimSet get_Issuer()
public bool Evaluate(EvaluationContext evaluationContext, Object& state)
}
public System.IdentityModel.Protocols.WSTrust.BinaryExchange : object {
private string defaultEncodingTypeUrl
private Byte[] <BinaryData>k__BackingField
private Uri <EncodingType>k__BackingField
private Uri <ValueType>k__BackingField
public Byte[] BinaryData
public Uri EncodingType
public Uri ValueType
public Byte[] get_BinaryData()
private void set_BinaryData(Byte[] value)
public Uri get_EncodingType()
private void set_EncodingType(Uri value)
public Uri get_ValueType()
private void set_ValueType(Uri value)
public void .ctor(Byte[] binaryData, Uri valueType)
public void .ctor(Byte[] binaryData, Uri valueType, Uri encodingType)
}
public System.IdentityModel.Protocols.WSTrust.EndpointReference : object {
private Collection`1<XmlElement> details
private Uri uri
public Collection`1<XmlElement> Details
public Uri Uri
public Collection`1<XmlElement> get_Details()
public Uri get_Uri()
public void .ctor(string uri)
public EndpointReference ReadFrom(XmlDictionaryReader reader)
public EndpointReference ReadFrom(XmlReader reader)
public void WriteTo(XmlWriter writer)
}
public System.IdentityModel.Protocols.WSTrust.Entropy : ProtectedKey {
public void .ctor(ProtectedKey protectedKey)
public void .ctor(Byte[] secret)
public void .ctor(int entropySizeInBits)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
private Byte[] GetRandomByteArray(int arraySize)
}
public System.IdentityModel.Protocols.WSTrust.Lifetime : object {
private Nullable`1<DateTime> <Created>k__BackingField
private Nullable`1<DateTime> <Expires>k__BackingField
public Nullable`1<DateTime> Created
public Nullable`1<DateTime> Expires
public Nullable`1<DateTime> get_Created()
public void set_Created(Nullable`1<DateTime> value)
public Nullable`1<DateTime> get_Expires()
public void set_Expires(Nullable`1<DateTime> value)
public void .ctor(DateTime created, DateTime expires)
public void .ctor(Nullable`1<DateTime> created, Nullable`1<DateTime> expires)
}
public System.IdentityModel.Protocols.WSTrust.ProtectedKey : object {
private Byte[] secret
private EncryptingCredentials <WrappingCredentials>k__BackingField
public EncryptingCredentials WrappingCredentials
public EncryptingCredentials get_WrappingCredentials()
private void set_WrappingCredentials(EncryptingCredentials value)
public void .ctor(Byte[] secret)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
public Byte[] GetKeyBytes()
}
public System.IdentityModel.Protocols.WSTrust.RequestedProofToken : object {
private string <ComputedKeyAlgorithm>k__BackingField
private ProtectedKey <ProtectedKey>k__BackingField
public string ComputedKeyAlgorithm
public ProtectedKey ProtectedKey
public string get_ComputedKeyAlgorithm()
private void set_ComputedKeyAlgorithm(string value)
public ProtectedKey get_ProtectedKey()
private void set_ProtectedKey(ProtectedKey value)
public void .ctor(ProtectedKey protectedKey)
public void .ctor(Byte[] secret)
public void .ctor(string computedKeyAlgorithm)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
}
public System.IdentityModel.Protocols.WSTrust.RequestedSecurityToken : object {
private SecurityToken <SecurityToken>k__BackingField
private XmlElement <SecurityTokenXml>k__BackingField
public SecurityToken SecurityToken
public XmlElement SecurityTokenXml
public SecurityToken get_SecurityToken()
private void set_SecurityToken(SecurityToken value)
public XmlElement get_SecurityTokenXml()
private void set_SecurityTokenXml(XmlElement value)
public void .ctor(SecurityToken token)
public void .ctor(XmlElement tokenAsXml)
}
public System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse : WSTrustMessage {
private bool <IsFinal>k__BackingField
private SecurityKeyIdentifierClause <RequestedAttachedReference>k__BackingField
private RequestedProofToken <RequestedProofToken>k__BackingField
private RequestedSecurityToken <RequestedSecurityToken>k__BackingField
private bool <RequestedTokenCancelled>k__BackingField
private SecurityKeyIdentifierClause <RequestedUnattachedReference>k__BackingField
private Status <Status>k__BackingField
public bool IsFinal
public SecurityKeyIdentifierClause RequestedAttachedReference
public RequestedProofToken RequestedProofToken
public RequestedSecurityToken RequestedSecurityToken
public bool RequestedTokenCancelled
public SecurityKeyIdentifierClause RequestedUnattachedReference
public Status Status
public bool get_IsFinal()
public void set_IsFinal(bool value)
public SecurityKeyIdentifierClause get_RequestedAttachedReference()
public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value)
public RequestedProofToken get_RequestedProofToken()
public void set_RequestedProofToken(RequestedProofToken value)
public RequestedSecurityToken get_RequestedSecurityToken()
public void set_RequestedSecurityToken(RequestedSecurityToken value)
public bool get_RequestedTokenCancelled()
public void set_RequestedTokenCancelled(bool value)
public SecurityKeyIdentifierClause get_RequestedUnattachedReference()
public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value)
public Status get_Status()
public void set_Status(Status value)
public void .ctor(WSTrustMessage message)
}
public System.IdentityModel.Protocols.WSTrust.Status : object {
private string <Code>k__BackingField
private string <Reason>k__BackingField
public string Code
public string Reason
public string get_Code()
public void set_Code(string value)
public string get_Reason()
public void set_Reason(string value)
public void .ctor(string code, string reason)
}
public System.IdentityModel.Protocols.WSTrust.UseKey : object {
private SecurityKeyIdentifier <SecurityKeyIdentifier>k__BackingField
private SecurityToken <Token>k__BackingField
public SecurityKeyIdentifier SecurityKeyIdentifier
public SecurityToken Token
public SecurityKeyIdentifier get_SecurityKeyIdentifier()
private void set_SecurityKeyIdentifier(SecurityKeyIdentifier value)
public SecurityToken get_Token()
private void set_Token(SecurityToken value)
public void .ctor(SecurityKeyIdentifier ski)
public void .ctor(SecurityToken token)
public void .ctor(SecurityKeyIdentifier ski, SecurityToken token)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustMessage : OpenObject {
private bool <AllowPostdating>k__BackingField
private EndpointReference <AppliesTo>k__BackingField
private string <AuthenticationType>k__BackingField
private BinaryExchange <BinaryExchange>k__BackingField
private string <CanonicalizationAlgorithm>k__BackingField
private string <Context>k__BackingField
private string <EncryptionAlgorithm>k__BackingField
private string <EncryptWith>k__BackingField
private Entropy <Entropy>k__BackingField
private Nullable`1<int> <KeySizeInBits>k__BackingField
private string <KeyType>k__BackingField
private string <KeyWrapAlgorithm>k__BackingField
private Lifetime <Lifetime>k__BackingField
private string <ReplyTo>k__BackingField
private string <RequestType>k__BackingField
private string <SignatureAlgorithm>k__BackingField
private string <SignWith>k__BackingField
private string <TokenType>k__BackingField
private UseKey <UseKey>k__BackingField
public bool AllowPostdating
public EndpointReference AppliesTo
public string AuthenticationType
public BinaryExchange BinaryExchange
public string CanonicalizationAlgorithm
public string Context
public string EncryptionAlgorithm
public string EncryptWith
public Entropy Entropy
public Nullable`1<int> KeySizeInBits
public string KeyType
public string KeyWrapAlgorithm
public Lifetime Lifetime
public string ReplyTo
public string RequestType
public string SignatureAlgorithm
public string SignWith
public string TokenType
public UseKey UseKey
public bool get_AllowPostdating()
public void set_AllowPostdating(bool value)
public EndpointReference get_AppliesTo()
public void set_AppliesTo(EndpointReference value)
public string get_AuthenticationType()
public void set_AuthenticationType(string value)
public BinaryExchange get_BinaryExchange()
public void set_BinaryExchange(BinaryExchange value)
public string get_CanonicalizationAlgorithm()
public void set_CanonicalizationAlgorithm(string value)
public string get_Context()
public void set_Context(string value)
public string get_EncryptionAlgorithm()
public void set_EncryptionAlgorithm(string value)
public string get_EncryptWith()
public void set_EncryptWith(string value)
public Entropy get_Entropy()
public void set_Entropy(Entropy value)
public Nullable`1<int> get_KeySizeInBits()
public void set_KeySizeInBits(Nullable`1<int> value)
public string get_KeyType()
public void set_KeyType(string value)
public string get_KeyWrapAlgorithm()
public void set_KeyWrapAlgorithm(string value)
public Lifetime get_Lifetime()
public void set_Lifetime(Lifetime value)
public string get_ReplyTo()
public void set_ReplyTo(string value)
public string get_RequestType()
public void set_RequestType(string value)
public string get_SignatureAlgorithm()
public void set_SignatureAlgorithm(string value)
public string get_SignWith()
public void set_SignWith(string value)
public string get_TokenType()
public void set_TokenType(string value)
public UseKey get_UseKey()
public void set_UseKey(UseKey value)
}
public System.IdentityModel.Selectors.AudienceUriMode : Enum {
public int value__
public AudienceUriMode Never
public AudienceUriMode Always
public AudienceUriMode BearerKeyOnly
}
public System.IdentityModel.Selectors.CustomUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
private UserNamePasswordValidator validator
public void .ctor(UserNamePasswordValidator validator)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.KerberosSecurityTokenAuthenticator : WindowsSecurityTokenAuthenticator {
public void .ctor(bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.KerberosSecurityTokenProvider : SecurityTokenProvider {
private string name
private TokenImpersonationLevel impersonation_level
private NetworkCredential credential
public string ServicePrincipalName
public TokenImpersonationLevel TokenImpersonationLevel
public NetworkCredential NetworkCredential
public void .ctor(string servicePrincipalName)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential)
public string get_ServicePrincipalName()
public TokenImpersonationLevel get_TokenImpersonationLevel()
public NetworkCredential get_NetworkCredential()
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.Selectors.RsaSecurityTokenAuthenticator : SecurityTokenAuthenticator {
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
private IList`1<SecurityTokenAuthenticator> authenticators
private TimeSpan max_clock_skew
public void .ctor(IList`1<SecurityTokenAuthenticator> supportingAuthenticators)
public void .ctor(IList`1<SecurityTokenAuthenticator> supportingAuthenticators, TimeSpan maxClockSkew)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
public ClaimSet ResolveClaimSet(SecurityKeyIdentifier keyIdentifier)
public ClaimSet ResolveClaimSet(SecurityToken token)
public IIdentity ResolveIdentity(SecurityKeyIdentifier keyIdentifier)
public IIdentity ResolveIdentity(SecurityToken token)
}
public System.IdentityModel.Selectors.SecurityTokenAuthenticator : object {
public bool CanValidateToken(SecurityToken token)
protected bool CanValidateTokenCore(SecurityToken token)
public ReadOnlyCollection`1<IAuthorizationPolicy> ValidateToken(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.SecurityTokenManager : object {
public SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver)
public SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
public SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
}
public System.IdentityModel.Selectors.SecurityTokenProvider : object {
public bool SupportsTokenCancellation
public bool SupportsTokenRenewal
public bool get_SupportsTokenCancellation()
public bool get_SupportsTokenRenewal()
public SecurityToken GetToken(TimeSpan timeout)
public IAsyncResult BeginGetToken(TimeSpan timeout, AsyncCallback callback, object state)
public SecurityToken EndGetToken(IAsyncResult result)
public void CancelToken(TimeSpan timeout, SecurityToken token)
public IAsyncResult BeginCancelToken(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state)
public void EndCancelToken(IAsyncResult result)
public SecurityToken RenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed)
public IAsyncResult BeginRenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state)
public SecurityToken EndRenewToken(IAsyncResult result)
protected SecurityToken GetTokenCore(TimeSpan timeout)
protected void CancelTokenCore(TimeSpan timeout, SecurityToken token)
protected SecurityToken RenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed)
protected IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state)
protected IAsyncResult BeginCancelTokenCore(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state)
protected IAsyncResult BeginRenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state)
protected SecurityToken EndGetTokenCore(IAsyncResult result)
protected void EndCancelTokenCore(IAsyncResult result)
protected SecurityToken EndRenewTokenCore(IAsyncResult result)
}
public System.IdentityModel.Selectors.SecurityTokenRequirement : object {
private Dictionary`2<string, object> properties
public string KeySizeProperty
public string KeyTypeProperty
public string KeyUsageProperty
public string RequireCryptographicTokenProperty
public string TokenTypeProperty
public int KeySize
public SecurityKeyType KeyType
public string TokenType
public SecurityKeyUsage KeyUsage
public bool RequireCryptographicToken
public IDictionary`2<string, object> Properties
public string get_KeySizeProperty()
public string get_KeyTypeProperty()
public string get_KeyUsageProperty()
public string get_RequireCryptographicTokenProperty()
public string get_TokenTypeProperty()
public int get_KeySize()
public void set_KeySize(int value)
public SecurityKeyType get_KeyType()
public void set_KeyType(SecurityKeyType value)
public string get_TokenType()
public void set_TokenType(string value)
public SecurityKeyUsage get_KeyUsage()
public void set_KeyUsage(SecurityKeyUsage value)
public bool get_RequireCryptographicToken()
public void set_RequireCryptographicToken(bool value)
public IDictionary`2<string, object> get_Properties()
public TValue GetProperty(string propertyName)
public bool TryGetProperty(string propertyName, TValue& result)
}
public System.IdentityModel.Selectors.SecurityTokenResolver : object {
public SecurityTokenResolver CreateDefaultSecurityTokenResolver(ReadOnlyCollection`1<SecurityToken> tokens, bool canMatchLocalId)
public SecurityKey ResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause)
public SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier)
public SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause)
public bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
public bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
public bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
protected bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
protected bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
protected bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
}
public System.IdentityModel.Selectors.SecurityTokenSerializer : object {
public bool CanReadKeyIdentifier(XmlReader reader)
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanReadToken(XmlReader reader)
public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public bool CanWriteToken(SecurityToken token)
public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
public void WriteToken(XmlWriter writer, SecurityToken token)
protected bool CanReadKeyIdentifierClauseCore(XmlReader reader)
protected bool CanReadKeyIdentifierCore(XmlReader reader)
protected bool CanReadTokenCore(XmlReader reader)
protected SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader)
protected SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
protected SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver)
protected bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier)
protected bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause)
protected bool CanWriteTokenCore(SecurityToken token)
protected void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
protected void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
protected void WriteTokenCore(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Selectors.SecurityTokenVersion : object {
public ReadOnlyCollection`1<string> GetSecuritySpecifications()
}
internal System.IdentityModel.Selectors.SystemIdentityAuthorizationPolicy : object {
private string id
public string Id
public ClaimSet Issuer
public DateTime ExpirationTime
protected void .ctor(string id)
public string get_Id()
public ClaimSet get_Issuer()
public bool Evaluate(EvaluationContext ec, Object& state)
public DateTime get_ExpirationTime()
public ClaimSet CreateClaims()
public IIdentity CreateIdentity()
}
public System.IdentityModel.Selectors.UserNamePasswordValidator : object {
private UserNamePasswordValidator none_validator
public UserNamePasswordValidator None
public UserNamePasswordValidator get_None()
public UserNamePasswordValidator CreateMembershipProviderValidator(MembershipProvider provider)
public void Validate(string userName, string password)
}
public System.IdentityModel.Selectors.UserNameSecurityTokenAuthenticator : SecurityTokenAuthenticator {
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.UserNameSecurityTokenProvider : SecurityTokenProvider {
private string user
private string pass
public void .ctor(string userName, string password)
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.Selectors.WindowsSecurityTokenAuthenticator : SecurityTokenAuthenticator {
public void .ctor(bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.WindowsUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
private bool include_win_groups
public void .ctor(bool includeWindowsGroups)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.X509CertificateValidator : object {
private X509CertificateValidator none
private X509CertificateValidator chain
private X509CertificateValidator peer_or_chain
private X509CertificateValidator peer
public X509CertificateValidator None
public X509CertificateValidator ChainTrust
public X509CertificateValidator PeerOrChainTrust
public X509CertificateValidator PeerTrust
public X509CertificateValidator get_None()
public X509CertificateValidator get_ChainTrust()
public X509CertificateValidator get_PeerOrChainTrust()
public X509CertificateValidator get_PeerTrust()
public X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy)
public X509CertificateValidator CreatePeerOrChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy)
public void Validate(X509Certificate2 certificate)
}
public System.IdentityModel.Selectors.X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
private bool map_to_windows
private bool include_win_groups
private X509CertificateValidator validator
public void .ctor(X509CertificateValidator validator)
public void .ctor(X509CertificateValidator validator, bool mapToWindows)
public void .ctor(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.X509SecurityTokenProvider : SecurityTokenProvider {
private X509Certificate2 cert
private X509Store store
public X509Certificate2 Certificate
public void .ctor(X509Certificate2 certificate)
public void .ctor(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue)
public X509Certificate2 get_Certificate()
public void Dispose()
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.SignatureVerificationFailedException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.IdentityModel.Tokens.AlgorithmSupportType : Enum {
public int value__
public AlgorithmSupportType Symmetric
public AlgorithmSupportType Asymmetric
public AlgorithmSupportType Unsupported
}
public System.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
}
public System.IdentityModel.Tokens.AudienceRestriction : object {
private Collection`1<Uri> <AllowedAudienceUris>k__BackingField
private AudienceUriMode <AudienceMode>k__BackingField
public Collection`1<Uri> AllowedAudienceUris
public AudienceUriMode AudienceMode
public Collection`1<Uri> get_AllowedAudienceUris()
private void set_AllowedAudienceUris(Collection`1<Uri> value)
public AudienceUriMode get_AudienceMode()
public void set_AudienceMode(AudienceUriMode value)
public void .ctor(AudienceUriMode audienceMode)
}
public System.IdentityModel.Tokens.AuthenticationContext : object {
private Collection`1<string> <Authorities>k__BackingField
private string <ContextClass>k__BackingField
private string <ContextDeclaration>k__BackingField
public Collection`1<string> Authorities
public string ContextClass
public string ContextDeclaration
public Collection`1<string> get_Authorities()
private void set_Authorities(Collection`1<string> value)
public string get_ContextClass()
public void set_ContextClass(string value)
public string get_ContextDeclaration()
public void set_ContextDeclaration(string value)
}
public System.IdentityModel.Tokens.BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
private Byte[] data
protected void .ctor(string clauseType, Byte[] identificationData, bool cloneBuffer)
protected void .ctor(string clauseType, Byte[] identificationData, bool cloneBuffer, Byte[] derivationNonce, int derivationLength)
public Byte[] GetBuffer()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(Byte[] data)
public bool Matches(Byte[] data, int offset)
protected Byte[] GetRawBuffer()
}
public System.IdentityModel.Tokens.BootstrapContext : object {
private string <Token>k__BackingField
private Byte[] <TokenBytes>k__BackingField
private SecurityToken <SecurityToken>k__BackingField
private SecurityTokenHandler <SecurityTokenHandler>k__BackingField
public string Token
public Byte[] TokenBytes
public SecurityToken SecurityToken
public SecurityTokenHandler SecurityTokenHandler
public string get_Token()
private void set_Token(string value)
public Byte[] get_TokenBytes()
private void set_TokenBytes(Byte[] value)
public SecurityToken get_SecurityToken()
private void set_SecurityToken(SecurityToken value)
public SecurityTokenHandler get_SecurityTokenHandler()
private void set_SecurityTokenHandler(SecurityTokenHandler value)
public void .ctor(string token)
public void .ctor(Byte[] token)
public void .ctor(SecurityToken token, SecurityTokenHandler tokenHandler)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
private string carried_key_name
private string enc_method
private SecurityKeyIdentifier identifier
public string CarriedKeyName
public string EncryptionMethod
public SecurityKeyIdentifier EncryptingKeyIdentifier
public void .ctor(Byte[] encryptedKey, string encryptionMethod)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, Byte[] derivationNonce, int derivationLength)
public string get_CarriedKeyName()
public string get_EncryptionMethod()
public SecurityKeyIdentifier get_EncryptingKeyIdentifier()
public Byte[] GetEncryptedKey()
public bool Matches(Byte[] encryptedKey, string encryptionMethod, string carriedKeyName)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public string ToString()
}
public System.IdentityModel.Tokens.EncryptingCredentials : object {
private string <Algorithm>k__BackingField
private SecurityKey <SecurityKey>k__BackingField
private SecurityKeyIdentifier <SecurityKeyIdentifier>k__BackingField
public string Algorithm
public SecurityKey SecurityKey
public SecurityKeyIdentifier SecurityKeyIdentifier
public string get_Algorithm()
public void set_Algorithm(string value)
public SecurityKey get_SecurityKey()
public void set_SecurityKey(SecurityKey value)
public SecurityKeyIdentifier get_SecurityKeyIdentifier()
public void set_SecurityKeyIdentifier(SecurityKeyIdentifier value)
public void .ctor(SecurityKey key, SecurityKeyIdentifier keyIdentifier, string algorithm)
}
public System.IdentityModel.Tokens.GenericXmlSecurityToken : SecurityToken {
private XmlElement xml
private SecurityToken proof_token
private DateTime from
private DateTime to
private SecurityKeyIdentifierClause int_tokenref
private SecurityKeyIdentifierClause ext_tokenref
private ReadOnlyCollection`1<IAuthorizationPolicy> auth_policies
public string Id
public XmlElement TokenXml
public SecurityToken ProofToken
public DateTime ValidFrom
public DateTime ValidTo
public SecurityKeyIdentifierClause InternalTokenReference
public SecurityKeyIdentifierClause ExternalTokenReference
public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies)
public string get_Id()
public XmlElement get_TokenXml()
public SecurityToken get_ProofToken()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public SecurityKeyIdentifierClause get_InternalTokenReference()
public SecurityKeyIdentifierClause get_ExternalTokenReference()
public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.InMemorySymmetricSecurityKey : SymmetricSecurityKey {
private Byte[] key
public int KeySize
public void .ctor(Byte[] symmetricKey)
public void .ctor(Byte[] symmetricKey, bool cloneBuffer)
public Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset)
private Byte[] Expand(string hashName, Byte[] secret, Byte[] seed, int length)
public Byte[] GetSymmetricKey()
public KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm)
public SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm)
public ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv)
public ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv)
public int GetIVSize(string algorithm)
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.IssuerNameRegistry : object {
public string GetIssuerName(SecurityToken securityToken)
public string GetIssuerName(SecurityToken securityToken, string requestedIssuerName)
public string GetWindowsIssuerName()
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.IdentityModel.Tokens.KerberosReceiverSecurityToken : WindowsSecurityToken {
public SymmetricSecurityKey SecurityKey
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(Byte[] request)
public void .ctor(Byte[] request, string id)
public SymmetricSecurityKey get_SecurityKey()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public Byte[] GetRequest()
}
public System.IdentityModel.Tokens.KerberosRequestorSecurityToken : SecurityToken {
private NetworkCredential cred
private TokenImpersonationLevel imp_level
private string svc_principal_name
private string id
public string ServicePrincipalName
public SymmetricSecurityKey SecurityKey
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(string servicePrincipalName)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id)
public string get_ServicePrincipalName()
public SymmetricSecurityKey get_SecurityKey()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public Byte[] GetRequest()
}
public System.IdentityModel.Tokens.LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
private string local_id
private Type owner_type
public string LocalId
public Type OwnerType
public void .ctor(string localId)
public void .ctor(string localId, Type ownerType)
public void .ctor(string localId, Byte[] derivationNonce, int derivationLength, Type ownerType)
public string get_LocalId()
public Type get_OwnerType()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(string localId, Type ownerType)
public string ToString()
}
public System.IdentityModel.Tokens.ProofDescriptor : object {
public SecurityKeyIdentifier KeyIdentifier
public SecurityKeyIdentifier get_KeyIdentifier()
public void ApplyTo(RequestSecurityTokenResponse response)
}
public System.IdentityModel.Tokens.RsaKeyIdentifierClause : SecurityKeyIdentifierClause {
private RSA rsa
public RSA Rsa
public bool CanCreateKey
public void .ctor(RSA rsa)
public RSA get_Rsa()
public bool get_CanCreateKey()
public SecurityKey CreateKey()
public Byte[] GetExponent()
public void WriteExponentAsBase64(XmlWriter writer)
public Byte[] GetModulus()
public void WriteModulusAsBase64(XmlWriter writer)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(RSA rsa)
public string ToString()
}
public System.IdentityModel.Tokens.RsaSecurityKey : AsymmetricSecurityKey {
private RSA rsa
public int KeySize
public void .ctor(RSA rsa)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool requiresPrivateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.RsaSecurityToken : SecurityToken {
private RSA rsa
private string id
private DateTime valid_from
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public RSA Rsa
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(RSA rsa)
public void .ctor(RSA rsa, string id)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public RSA get_Rsa()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.SamlAccessDecision : Enum {
public int value__
public SamlAccessDecision Permit
public SamlAccessDecision Deny
public SamlAccessDecision Indeterminate
}
public System.IdentityModel.Tokens.SamlAction : object {
private string action
private string ns
private bool is_readonly
public string Action
public bool IsReadOnly
public string Namespace
public void .ctor(string action)
public void .ctor(string action, string ns)
public string get_Action()
public void set_Action(string value)
public bool get_IsReadOnly()
public string get_Namespace()
public void set_Namespace(string value)
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAdvice : object {
private List`1<string> idrefs
private List`1<SamlAssertion> assertions
private bool is_readonly
public bool IsReadOnly
public IList`1<SamlAssertion> Assertions
public IList`1<string> AssertionIdReferences
public void .ctor(IEnumerable`1<SamlAssertion> assertions)
public void .ctor(IEnumerable`1<string> references)
public void .ctor(IEnumerable`1<string> references, IEnumerable`1<SamlAssertion> assertions)
public bool get_IsReadOnly()
public IList`1<SamlAssertion> get_Assertions()
public IList`1<string> get_AssertionIdReferences()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAssertion : object {
private bool is_readonly
private SamlAdvice advice
private SamlConditions conditions
private string assertion_id
private string issuer
private DateTime issue_instant
private int major
private int minor
private SigningCredentials signing_credentials
private List`1<SamlStatement> statements
public SamlAdvice Advice
public string AssertionId
public SamlConditions Conditions
public DateTime IssueInstant
public string Issuer
public int MajorVersion
public int MinorVersion
public SigningCredentials SigningCredentials
public SecurityToken SigningToken
public IList`1<SamlStatement> Statements
public bool IsReadOnly
public void .ctor(string assertionId, string issuer, DateTime issueInstant, SamlConditions samlConditions, SamlAdvice samlAdvice, IEnumerable`1<SamlStatement> samlStatements)
private bool IsInvalidAssertionId(string assertionId)
public SamlAdvice get_Advice()
public void set_Advice(SamlAdvice value)
public string get_AssertionId()
public void set_AssertionId(string value)
public SamlConditions get_Conditions()
public void set_Conditions(SamlConditions value)
public DateTime get_IssueInstant()
public void set_IssueInstant(DateTime value)
public string get_Issuer()
public void set_Issuer(string value)
public int get_MajorVersion()
public int get_MinorVersion()
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public SecurityToken get_SigningToken()
public IList`1<SamlStatement> get_Statements()
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void ReadSignature(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver, SamlSerializer samlSerializer)
}
public System.IdentityModel.Tokens.SamlAssertionKeyIdentifierClause : SecurityKeyIdentifierClause {
private string id
public string AssertionId
public void .ctor(string assertionId)
public string get_AssertionId()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(string assertionId)
public string ToString()
}
public System.IdentityModel.Tokens.SamlAttribute : object {
private bool is_readonly
private string name
private string ns
private List`1<string> attribute_values
public IList`1<string> AttributeValues
public string Name
public string Namespace
public bool IsReadOnly
public void .ctor(Claim claim)
public void .ctor(string attributeNamespace, string attributeName, IEnumerable`1<string> attributeValues)
public IList`1<string> get_AttributeValues()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
public ReadOnlyCollection`1<Claim> ExtractClaims()
}
public System.IdentityModel.Tokens.SamlAttributeStatement : SamlSubjectStatement {
private bool is_readonly
private List`1<SamlAttribute> attributes
public IList`1<SamlAttribute> Attributes
public bool IsReadOnly
public void .ctor(SamlSubject samlSubject, IEnumerable`1<SamlAttribute> attributes)
public IList`1<SamlAttribute> get_Attributes()
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void AddClaimsToList(IList`1<Claim> claims)
}
public System.IdentityModel.Tokens.SamlAudienceRestrictionCondition : SamlCondition {
private List`1<Uri> audiences
private bool is_readonly
public IList`1<Uri> Audiences
public bool IsReadOnly
public void .ctor(IEnumerable`1<Uri> audiences)
public IList`1<Uri> get_Audiences()
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAuthenticationClaimResource : object {
private ReadOnlyCollection`1<SamlAuthorityBinding> bindings
private DateTime instant
private string method
private string dns
private string ip
public DateTime AuthenticationInstant
public string AuthenticationMethod
public string DnsAddress
public string IPAddress
public ReadOnlyCollection`1<SamlAuthorityBinding> AuthorityBindings
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress)
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings)
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, ReadOnlyCollection`1<SamlAuthorityBinding> authorityBindings)
public DateTime get_AuthenticationInstant()
public string get_AuthenticationMethod()
public string get_DnsAddress()
public string get_IPAddress()
public ReadOnlyCollection`1<SamlAuthorityBinding> get_AuthorityBindings()
}
public System.IdentityModel.Tokens.SamlAuthenticationStatement : SamlSubjectStatement {
private bool is_readonly
private string auth_method
private string dns
private string ip
private IList`1<SamlAuthorityBinding> bindings
private DateTime instant
public string ClaimType
public DateTime AuthenticationInstant
public string AuthenticationMethod
public IList`1<SamlAuthorityBinding> AuthorityBindings
public string DnsAddress
public string IPAddress
public bool IsReadOnly
public string get_ClaimType()
public void .ctor(SamlSubject samlSubject, string authenticationMethod, DateTime authenticationInstant, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings)
public DateTime get_AuthenticationInstant()
public void set_AuthenticationInstant(DateTime value)
public string get_AuthenticationMethod()
public void set_AuthenticationMethod(string value)
public IList`1<SamlAuthorityBinding> get_AuthorityBindings()
public string get_DnsAddress()
public void set_DnsAddress(string value)
public string get_IPAddress()
public void set_IPAddress(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void AddClaimsToList(IList`1<Claim> claims)
}
public System.IdentityModel.Tokens.SamlAuthorityBinding : object {
private XmlQualifiedName kind
private string binding
private string location
private bool is_readonly
public XmlQualifiedName AuthorityKind
public string Binding
public string Location
public bool IsReadOnly
public void .ctor(XmlQualifiedName authorityKind, string binding, string location)
public XmlQualifiedName get_AuthorityKind()
public void set_AuthorityKind(XmlQualifiedName value)
public string get_Binding()
public void set_Binding(string value)
public string get_Location()
public void set_Location(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAuthorizationDecisionClaimResource : object {
private SamlAccessDecision decision
private string name
private string ns
private string resource
public SamlAccessDecision AccessDecision
public string ActionName
public string ActionNamespace
public string Resource
public void .ctor(string resource, SamlAccessDecision accessDecision, string actionNamespace, string actionName)
public SamlAccessDecision get_AccessDecision()
public string get_ActionName()
public string get_ActionNamespace()
public string get_Resource()
}
public System.IdentityModel.Tokens.SamlAuthorizationDecisionStatement : SamlSubjectStatement {
private SamlAccessDecision access_decision
private SamlEvidence evidence
private string resource
private List`1<SamlAction> actions
public string ClaimType
public IList`1<SamlAction> SamlActions
public SamlAccessDecision AccessDecision
public SamlEvidence Evidence
public string Resource
public bool IsReadOnly
public string get_ClaimType()
public void .ctor(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions)
public void .ctor(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions, SamlEvidence samlEvidence)
public IList`1<SamlAction> get_SamlActions()
public SamlAccessDecision get_AccessDecision()
public void set_AccessDecision(SamlAccessDecision value)
public SamlEvidence get_Evidence()
public void set_Evidence(SamlEvidence value)
public string get_Resource()
public void set_Resource(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
protected void AddClaimsToList(IList`1<Claim> claims)
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlCondition : object {
public bool IsReadOnly
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlConditions : object {
private DateTime not_before
private DateTime not_on_after
private bool is_readonly
private bool has_not_before
private bool has_not_on_after
private List`1<SamlCondition> conditions
public IList`1<SamlCondition> Conditions
public DateTime NotBefore
public DateTime NotOnOrAfter
public bool IsReadOnly
public void .ctor(DateTime notBefore, DateTime notOnOrAfter)
public void .ctor(DateTime notBefore, DateTime notOnOrAfter, IEnumerable`1<SamlCondition> conditions)
public IList`1<SamlCondition> get_Conditions()
public DateTime get_NotBefore()
public void set_NotBefore(DateTime value)
public DateTime get_NotOnOrAfter()
public void set_NotOnOrAfter(DateTime value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlConstants : object {
internal string DateFormat
public string EmailName
public string EmailNamespace
public string HolderOfKey
public int MajorVersionValue
public int MinorVersionValue
public string Namespace
public string SenderVouches
public string UserName
public string UserNameNamespace
public string get_EmailName()
public string get_EmailNamespace()
public string get_HolderOfKey()
public int get_MajorVersionValue()
public int get_MinorVersionValue()
public string get_Namespace()
public string get_SenderVouches()
public string get_UserName()
public string get_UserNameNamespace()
}
public System.IdentityModel.Tokens.SamlDoNotCacheCondition : SamlCondition {
private bool is_readonly
public bool IsReadOnly
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlEvidence : object {
private bool is_readonly
private List`1<string> references
private List`1<SamlAssertion> assertions
public IList`1<string> AssertionIdReferences
public IList`1<SamlAssertion> Assertions
public bool IsReadOnly
public void .ctor(IEnumerable`1<string> assertionIdReferences)
public void .ctor(IEnumerable`1<SamlAssertion> assertions)
public void .ctor(IEnumerable`1<string> assertionIdReferences, IEnumerable`1<SamlAssertion> assertions)
public IList`1<string> get_AssertionIdReferences()
public IList`1<SamlAssertion> get_Assertions()
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlNameIdentifierClaimResource : object {
private string name
private string name_qualifier
private string format
public string Format
public string Name
public string NameQualifier
public void .ctor(string name, string nameQualifier, string format)
public string get_Format()
public string get_Name()
public string get_NameQualifier()
}
public System.IdentityModel.Tokens.SamlSecurityToken : SecurityToken {
private SamlAssertion assertion
public SamlAssertion Assertion
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(SamlAssertion assertion)
public SamlAssertion get_Assertion()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
protected void Initialize(SamlAssertion assertion)
}
public System.IdentityModel.Tokens.SamlSerializer : object {
public SamlAdvice LoadAdvice(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlAssertion LoadAssertion(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlAttribute LoadAttribute(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlCondition LoadCondition(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlConditions LoadConditions(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlStatement LoadStatement(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlSecurityToken ReadToken(XmlReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteToken(SamlSecurityToken token, XmlWriter writer, SecurityTokenSerializer keyInfoSerializer)
public void PopulateDictionary(IXmlDictionary dictionary)
}
public System.IdentityModel.Tokens.SamlStatement : object {
public bool IsReadOnly
public bool get_IsReadOnly()
public IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator)
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlSubject : object {
private bool is_readonly
private string name_format
private string name_qualifier
private string name
private SecurityKey crypto
private SecurityKeyIdentifier key_identifier
private List`1<string> confirmation_methods
private string confirmation_data
public string NameClaimType
public bool IsReadOnly
public string NameFormat
public string NameQualifier
public string Name
public IList`1<string> ConfirmationMethods
public string SubjectConfirmationData
public SecurityKey Crypto
public SecurityKeyIdentifier KeyIdentifier
public string get_NameClaimType()
public void .ctor(string nameFormat, string nameQualifier, string name)
public void .ctor(string nameFormat, string nameQualifier, string name, IEnumerable`1<string> confirmations, string confirmationData, SecurityKeyIdentifier securityKeyIdentifier)
public bool get_IsReadOnly()
public string get_NameFormat()
public void set_NameFormat(string value)
public string get_NameQualifier()
public void set_NameQualifier(string value)
public string get_Name()
public void set_Name(string value)
public IList`1<string> get_ConfirmationMethods()
public string get_SubjectConfirmationData()
public void set_SubjectConfirmationData(string value)
public SecurityKey get_Crypto()
public void set_Crypto(SecurityKey value)
public SecurityKeyIdentifier get_KeyIdentifier()
public void set_KeyIdentifier(SecurityKeyIdentifier value)
private void CheckReadOnly()
public void MakeReadOnly()
public ReadOnlyCollection`1<Claim> ExtractClaims()
public ClaimSet ExtractSubjectKeyClaimSet(SamlSecurityTokenAuthenticator samlAuthenticator)
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlSubjectStatement : SamlStatement {
private bool is_readonly
private SamlSubject subject
public SamlSubject SamlSubject
public bool IsReadOnly
protected void .ctor(SamlSubject samlSubject)
public SamlSubject get_SamlSubject()
public void set_SamlSubject(SamlSubject value)
public bool get_IsReadOnly()
public IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator)
private void CheckReadOnly()
public void MakeReadOnly()
protected void AddClaimsToList(IList`1<Claim> claims)
protected void SetSubject(SamlSubject samlSubject)
}
public System.IdentityModel.Tokens.SecurityAlgorithms : object {
public string Aes128Encryption
public string Aes128KeyWrap
public string Aes192Encryption
public string Aes192KeyWrap
public string Aes256Encryption
public string Aes256KeyWrap
public string DesEncryption
public string DsaSha1Signature
public string ExclusiveC14n
public string ExclusiveC14nWithComments
public string HmacSha1Signature
public string Psha1KeyDerivation
public string Ripemd160Digest
public string RsaOaepKeyWrap
public string RsaSha1Signature
public string RsaV15KeyWrap
public string Sha1Digest
public string Sha256Digest
public string Sha512Digest
public string TripleDesEncryption
public string TripleDesKeyWrap
public string HmacSha256Signature
public string RsaSha256Signature
public string TlsSspiKeyWrap
public string WindowsSspiKeyWrap
}
public System.IdentityModel.Tokens.SecurityKey : object {
public int KeySize
internal AlgorithmSupportType GetAlgorithmSupportType(string algorithm)
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.SecurityKeyIdentifier : object {
private List`1<SecurityKeyIdentifierClause> list
private bool is_readonly
public bool CanCreateKey
public int Count
public bool IsReadOnly
public SecurityKeyIdentifierClause Item
public void .ctor(SecurityKeyIdentifierClause[] clauses)
public bool get_CanCreateKey()
public int get_Count()
public bool get_IsReadOnly()
public SecurityKeyIdentifierClause get_Item(int index)
public void Add(SecurityKeyIdentifierClause clause)
public SecurityKey CreateKey()
public TClause Find()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<SecurityKeyIdentifierClause> GetEnumerator()
public void MakeReadOnly()
public string ToString()
public bool TryFind(TClause& clause)
}
public System.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
private string clause_type
private Byte[] nonce
private int deriv_length
private string <Id>k__BackingField
public bool CanCreateKey
public string ClauseType
public int DerivationLength
public string Id
protected void .ctor(string clauseType)
protected void .ctor(string clauseType, Byte[] nonce, int length)
public bool get_CanCreateKey()
public string get_ClauseType()
public int get_DerivationLength()
public Byte[] GetDerivationNonce()
public string get_Id()
public void set_Id(string value)
public SecurityKey CreateKey()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.SecurityKeyType : Enum {
public int value__
public SecurityKeyType SymmetricKey
public SecurityKeyType AsymmetricKey
}
public System.IdentityModel.Tokens.SecurityKeyUsage : Enum {
public int value__
public SecurityKeyUsage Exchange
public SecurityKeyUsage Signature
}
public System.IdentityModel.Tokens.SecurityToken : object {
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.SecurityTokenDescriptor : object {
private Dictionary`2<string, object> properties
private string <AppliesToAddress>k__BackingField
private SecurityKeyIdentifierClause <AttachedReference>k__BackingField
private AuthenticationInformation <AuthenticationInfo>k__BackingField
private EncryptingCredentials <EncryptingCredentials>k__BackingField
private Lifetime <Lifetime>k__BackingField
private ProofDescriptor <Proof>k__BackingField
private string <ReplyToAddress>k__BackingField
private SigningCredentials <SigningCredentials>k__BackingField
private ClaimsIdentity <Subject>k__BackingField
private SecurityToken <Token>k__BackingField
private string <TokenIssuerName>k__BackingField
private string <TokenType>k__BackingField
private SecurityKeyIdentifierClause <UnattachedReference>k__BackingField
public string AppliesToAddress
public SecurityKeyIdentifierClause AttachedReference
public AuthenticationInformation AuthenticationInfo
public EncryptingCredentials EncryptingCredentials
public Lifetime Lifetime
public ProofDescriptor Proof
public Dictionary`2<string, object> Properties
public string ReplyToAddress
public SigningCredentials SigningCredentials
public ClaimsIdentity Subject
public SecurityToken Token
public string TokenIssuerName
public string TokenType
public SecurityKeyIdentifierClause UnattachedReference
public string get_AppliesToAddress()
public void set_AppliesToAddress(string value)
public SecurityKeyIdentifierClause get_AttachedReference()
public void set_AttachedReference(SecurityKeyIdentifierClause value)
public AuthenticationInformation get_AuthenticationInfo()
public void set_AuthenticationInfo(AuthenticationInformation value)
public EncryptingCredentials get_EncryptingCredentials()
public void set_EncryptingCredentials(EncryptingCredentials value)
public Lifetime get_Lifetime()
public void set_Lifetime(Lifetime value)
public ProofDescriptor get_Proof()
public void set_Proof(ProofDescriptor value)
public Dictionary`2<string, object> get_Properties()
public string get_ReplyToAddress()
public void set_ReplyToAddress(string value)
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public ClaimsIdentity get_Subject()
public void set_Subject(ClaimsIdentity value)
public SecurityToken get_Token()
public void set_Token(SecurityToken value)
public string get_TokenIssuerName()
public void set_TokenIssuerName(string value)
public string get_TokenType()
public void set_TokenType(string value)
public SecurityKeyIdentifierClause get_UnattachedReference()
public void set_UnattachedReference(SecurityKeyIdentifierClause value)
public void AddAuthenticationClaims(string authType)
public void AddAuthenticationClaims(string authType, DateTime time)
public void ApplyTo(RequestSecurityTokenResponse response)
}
public System.IdentityModel.Tokens.SecurityTokenException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenExpiredException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenHandler : object {
private SecurityTokenHandlerConfiguration <Configuration>k__BackingField
private SecurityTokenHandlerCollection <ContainingCollection>k__BackingField
public bool CanValidateToken
public bool CanWriteToken
public SecurityTokenHandlerConfiguration Configuration
public SecurityTokenHandlerCollection ContainingCollection
public Type TokenType
public bool get_CanValidateToken()
public bool get_CanWriteToken()
public SecurityTokenHandlerConfiguration get_Configuration()
public void set_Configuration(SecurityTokenHandlerConfiguration value)
public SecurityTokenHandlerCollection get_ContainingCollection()
internal void set_ContainingCollection(SecurityTokenHandlerCollection value)
public Type get_TokenType()
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanReadToken(string tokenString)
public bool CanReadToken(XmlReader reader)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause)
public SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
protected void DetectReplayedToken(SecurityToken token)
public String[] GetTokenTypeIdentifiers()
public void LoadCustomConfiguration(XmlNodeList nodelist)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public SecurityToken ReadToken(string tokenString)
public SecurityToken ReadToken(XmlReader reader)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
protected void TraceTokenValidationFailure(SecurityToken token, string errorMessage)
protected void TraceTokenValidationSuccess(SecurityToken token)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause)
public string WriteToken(SecurityToken token)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SecurityTokenHandlerCollection : Collection`1<SecurityTokenHandler> {
private SecurityTokenHandlerConfiguration config
private IEnumerable`1<string> tokenTypeIdentifiers
private IEnumerable`1<Type> tokenTypes
public SecurityTokenHandlerConfiguration Configuration
public IEnumerable`1<string> TokenTypeIdentifiers
public IEnumerable`1<Type> TokenTypes
public SecurityTokenHandler Item
public SecurityTokenHandler Item
public SecurityTokenHandler Item
public SecurityTokenHandlerConfiguration get_Configuration()
public IEnumerable`1<string> get_TokenTypeIdentifiers()
public IEnumerable`1<Type> get_TokenTypes()
public SecurityTokenHandler get_Item(SecurityToken token)
public SecurityTokenHandler get_Item(string tokenTypeIdentifier)
public SecurityTokenHandler get_Item(Type tokenType)
public void .ctor(SecurityTokenHandlerConfiguration configuration)
public void .ctor(IEnumerable`1<SecurityTokenHandler> handlers)
public void .ctor(IEnumerable`1<SecurityTokenHandler> handlers, SecurityTokenHandlerConfiguration configuration)
public void AddOrReplace(SecurityTokenHandler handler)
public bool CanReadKeyIdentifierClause(XmlReader reader)
protected bool CanReadKeyIdentifierClauseCore(XmlReader reader)
public bool CanReadToken(string tokenString)
public bool CanReadToken(XmlReader reader)
public bool CanWriteToken(SecurityToken token)
protected void ClearItems()
public SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection()
public SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection(SecurityTokenHandlerConfiguration configuration)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
protected void InsertItem(int index, SecurityTokenHandler item)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
protected SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
public SecurityToken ReadToken(string tokenString)
public SecurityToken ReadToken(XmlReader reader)
protected void RemoveItem(int index)
protected void SetItem(int index, SecurityTokenHandler item)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
protected void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
public string WriteToken(SecurityToken token)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration : object {
public X509CertificateValidationMode DefaultCertificateValidationMode
public X509CertificateValidator DefaultCertificateValidator
public bool DefaultDetectReplayedTokens
public IssuerNameRegistry DefaultIssuerNameRegistry
public SecurityTokenResolver DefaultIssuerTokenResolver
public TimeSpan DefaultMaxClockSkew
public X509RevocationMode DefaultRevocationMode
public bool DefaultSaveBootstrapContext
public TimeSpan DefaultTokenReplayCacheExpirationPeriod
public StoreLocation DefaultTrustedStoreLocation
private AudienceRestriction <AudienceRestriction>k__BackingField
private IdentityModelCaches <Caches>k__BackingField
private X509CertificateValidationMode <CertificateValidationMode>k__BackingField
private X509CertificateValidator <CertificateValidator>k__BackingField
private bool <DetectReplayedTokens>k__BackingField
private IssuerNameRegistry <IssuerNameRegistry>k__BackingField
private SecurityTokenResolver <IssuerTokenResolver>k__BackingField
private TimeSpan <MaxClockSkew>k__BackingField
private X509RevocationMode <RevocationMode>k__BackingField
private bool <SaveBootstrapContext>k__BackingField
private SecurityTokenResolver <ServiceTokenResolver>k__BackingField
private TimeSpan <TokenReplayCacheExpirationPeriod>k__BackingField
private StoreLocation <TrustedStoreLocation>k__BackingField
public AudienceRestriction AudienceRestriction
public IdentityModelCaches Caches
public X509CertificateValidationMode CertificateValidationMode
public X509CertificateValidator CertificateValidator
public bool DetectReplayedTokens
public IssuerNameRegistry IssuerNameRegistry
public SecurityTokenResolver IssuerTokenResolver
public TimeSpan MaxClockSkew
public X509RevocationMode RevocationMode
public bool SaveBootstrapContext
public SecurityTokenResolver ServiceTokenResolver
public TimeSpan TokenReplayCacheExpirationPeriod
public StoreLocation TrustedStoreLocation
public AudienceRestriction get_AudienceRestriction()
public void set_AudienceRestriction(AudienceRestriction value)
public IdentityModelCaches get_Caches()
public void set_Caches(IdentityModelCaches value)
public X509CertificateValidationMode get_CertificateValidationMode()
public void set_CertificateValidationMode(X509CertificateValidationMode value)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public bool get_DetectReplayedTokens()
public void set_DetectReplayedTokens(bool value)
public IssuerNameRegistry get_IssuerNameRegistry()
public void set_IssuerNameRegistry(IssuerNameRegistry value)
public SecurityTokenResolver get_IssuerTokenResolver()
public void set_IssuerTokenResolver(SecurityTokenResolver value)
public TimeSpan get_MaxClockSkew()
public void set_MaxClockSkew(TimeSpan value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public bool get_SaveBootstrapContext()
public void set_SaveBootstrapContext(bool value)
public SecurityTokenResolver get_ServiceTokenResolver()
public void set_ServiceTokenResolver(SecurityTokenResolver value)
public TimeSpan get_TokenReplayCacheExpirationPeriod()
public void set_TokenReplayCacheExpirationPeriod(TimeSpan value)
public StoreLocation get_TrustedStoreLocation()
public void set_TrustedStoreLocation(StoreLocation value)
}
public System.IdentityModel.Tokens.SecurityTokenNotYetValidException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenReplayDetectedException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenTypes : object {
public string Kerberos
public string Rsa
public string Saml
public string UserName
public string X509Certificate
public string get_Kerberos()
public string get_Rsa()
public string get_Saml()
public string get_UserName()
public string get_X509Certificate()
}
public System.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SessionSecurityToken : SecurityToken {
private ReadOnlyCollection`1<SecurityKey> securityKeys
private DateTime validFrom
private DateTime validTo
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField
private string <Context>k__BackingField
private UniqueId <ContextId>k__BackingField
private string <EndpointId>k__BackingField
private bool <IsPersistent>k__BackingField
private bool <IsReferenceMode>k__BackingField
private DateTime <KeyEffectiveTime>k__BackingField
private DateTime <KeyExpirationTime>k__BackingField
private UniqueId <KeyGeneration>k__BackingField
private Uri <SecureConversationVersion>k__BackingField
public ClaimsPrincipal ClaimsPrincipal
public string Context
public UniqueId ContextId
public string EndpointId
public string Id
public bool IsPersistent
public bool IsReferenceMode
public DateTime KeyEffectiveTime
public DateTime KeyExpirationTime
public UniqueId KeyGeneration
public Uri SecureConversationVersion
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public DateTime ValidFrom
public DateTime ValidTo
public ClaimsPrincipal get_ClaimsPrincipal()
private void set_ClaimsPrincipal(ClaimsPrincipal value)
public string get_Context()
private void set_Context(string value)
public UniqueId get_ContextId()
private void set_ContextId(UniqueId value)
public string get_EndpointId()
private void set_EndpointId(string value)
public string get_Id()
public bool get_IsPersistent()
public void set_IsPersistent(bool value)
public bool get_IsReferenceMode()
public void set_IsReferenceMode(bool value)
public DateTime get_KeyEffectiveTime()
private void set_KeyEffectiveTime(DateTime value)
public DateTime get_KeyExpirationTime()
private void set_KeyExpirationTime(DateTime value)
public UniqueId get_KeyGeneration()
private void set_KeyGeneration(UniqueId value)
public Uri get_SecureConversationVersion()
private void set_SecureConversationVersion(Uri value)
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public void .ctor(ClaimsPrincipal claimsPrincipal)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context)
public void .ctor(ClaimsPrincipal claimsPrincipal, TimeSpan lifetime)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, TimeSpan lifetime, SymmetricSecurityKey key)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, DateTime validFrom, TimeSpan lifetime, SymmetricSecurityKey key)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo, SymmetricSecurityKey key)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SessionSecurityTokenCache : object {
public void AddOrUpdate(SessionSecurityTokenCacheKey key, SessionSecurityToken value, DateTime expiryTime)
public SessionSecurityToken Get(SessionSecurityTokenCacheKey key)
public IEnumerable`1<SessionSecurityToken> GetAll(string endpointId, UniqueId contextId)
public void LoadCustomConfiguration(XmlNodeList nodelist)
public void Remove(SessionSecurityTokenCacheKey key)
public void RemoveAll(string endpointId)
public void RemoveAll(string endpointId, UniqueId contextId)
}
public System.IdentityModel.Tokens.SessionSecurityTokenCacheKey : object {
private UniqueId <ContextId>k__BackingField
private string <EndpointId>k__BackingField
private bool <IgnoreKeyGeneration>k__BackingField
private UniqueId <KeyGeneration>k__BackingField
public UniqueId ContextId
public string EndpointId
public bool IgnoreKeyGeneration
public UniqueId KeyGeneration
public bool op_Inequality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second)
public bool op_Equality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second)
public UniqueId get_ContextId()
private void set_ContextId(UniqueId value)
public string get_EndpointId()
private void set_EndpointId(string value)
public bool get_IgnoreKeyGeneration()
public void set_IgnoreKeyGeneration(bool value)
public UniqueId get_KeyGeneration()
private void set_KeyGeneration(UniqueId value)
public void .ctor(string endpointId, UniqueId contextId, UniqueId keyGeneration)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.IdentityModel.Tokens.SessionSecurityTokenHandler : SecurityTokenHandler {
public ReadOnlyCollection`1<CookieTransform> DefaultCookieTransforms
public TimeSpan DefaultLifetime
private bool canValidateToken
private bool canWriteToken
private string cookieElementName
private string cookieNamespace
private Type tokenType
private TimeSpan <TokenLifetime>k__BackingField
private ReadOnlyCollection`1<CookieTransform> <Transforms>k__BackingField
public bool CanValidateToken
public bool CanWriteToken
public string CookieElementName
public string CookieNamespace
public TimeSpan DefaultTokenLifetime
public TimeSpan TokenLifetime
public Type TokenType
public ReadOnlyCollection`1<CookieTransform> Transforms
public bool get_CanValidateToken()
public bool get_CanWriteToken()
public string get_CookieElementName()
public string get_CookieNamespace()
public TimeSpan get_DefaultTokenLifetime()
public TimeSpan get_TokenLifetime()
public void set_TokenLifetime(TimeSpan value)
public Type get_TokenType()
public ReadOnlyCollection`1<CookieTransform> get_Transforms()
private void set_Transforms(ReadOnlyCollection`1<CookieTransform> value)
public void .ctor(ReadOnlyCollection`1<CookieTransform> transforms)
public void .ctor(ReadOnlyCollection`1<CookieTransform> transforms, TimeSpan tokenLifetime)
protected Byte[] ApplyTransforms(Byte[] cookie, bool outbound)
public bool CanReadToken(XmlReader reader)
public SessionSecurityToken CreateSessionSecurityToken(ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
public String[] GetTokenTypeIdentifiers()
public void LoadCustomConfiguration(XmlNodeList customConfigElements)
public SecurityToken ReadToken(XmlReader reader)
public SecurityToken ReadToken(Byte[] token, SecurityTokenResolver tokenResolver)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
protected void SetTransforms(IEnumerable`1<CookieTransform> transforms)
protected void ValidateSession(SessionSecurityToken securityToken)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SessionSecurityToken token, string endpointId)
public Byte[] WriteToken(SessionSecurityToken sessionToken)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SigningCredentials : object {
private SecurityKey key
private string sig_alg
private string dig_alg
private SecurityKeyIdentifier identifier
public string DigestAlgorithm
public string SignatureAlgorithm
public SecurityKey SigningKey
public SecurityKeyIdentifier SigningKeyIdentifier
public void .ctor(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm)
public void .ctor(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm, SecurityKeyIdentifier signingKeyIdentifier)
public string get_DigestAlgorithm()
public string get_SignatureAlgorithm()
public SecurityKey get_SigningKey()
public SecurityKeyIdentifier get_SigningKeyIdentifier()
}
public System.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
public Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset)
public Byte[] GetSymmetricKey()
public KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm)
public SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm)
public ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv)
public ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv)
public int GetIVSize(string algorithm)
}
public System.IdentityModel.Tokens.TokenReplayCache : object {
public void AddOrUpdate(string key, SecurityToken securityToken, DateTime expirationTime)
public bool Contains(string key)
public SecurityToken Get(string key)
public void LoadCustomConfiguration(XmlNodeList nodelist)
public void Remove(string key)
}
public System.IdentityModel.Tokens.UserNameSecurityToken : SecurityToken {
private DateTime from
private string username
private string password
private string id
public string UserName
public string Password
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(string userName, string password)
public void .ctor(string userName, string password, string id)
public string get_UserName()
public string get_Password()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
}
public System.IdentityModel.Tokens.WindowsSecurityToken : SecurityToken {
private WindowsIdentity identity
private string id
public WindowsIdentity WindowsIdentity
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(WindowsIdentity windowsIdentity)
public void .ctor(WindowsIdentity windowsIdentity, string id)
public WindowsIdentity get_WindowsIdentity()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
}
public System.IdentityModel.Tokens.X509AsymmetricSecurityKey : AsymmetricSecurityKey {
private X509Certificate2 cert
public int KeySize
public void .ctor(X509Certificate2 certificate)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.X509IssuerSerialKeyIdentifierClause : SecurityKeyIdentifierClause {
private string name
private string serial
public string IssuerName
public string IssuerSerialNumber
private Byte[] FromBinHex(string s)
private byte DecodeHex(char c)
private string ToDecimalString(string hexString)
public void .ctor(X509Certificate2 certificate)
public void .ctor(string issuerName, string issuerSerialNumber)
public string get_IssuerName()
public string get_IssuerSerialNumber()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(X509Certificate2 certificate)
public bool Matches(string issuerName, string issuerSerialNumber)
public string ToString()
}
public System.IdentityModel.Tokens.X509RawDataKeyIdentifierClause : BinaryKeyIdentifierClause {
private X509Certificate2 cert
public bool CanCreateKey
public void .ctor(Byte[] certificateRawData)
public void .ctor(X509Certificate2 certificate)
public bool get_CanCreateKey()
public SecurityKey CreateKey()
public Byte[] GetX509RawData()
public bool Matches(X509Certificate2 certificate)
public string ToString()
}
public System.IdentityModel.Tokens.X509SecurityToken : SecurityToken {
private X509Certificate2 cert
private string id
private ReadOnlyCollection`1<SecurityKey> keys
public X509Certificate2 Certificate
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, string id)
public X509Certificate2 get_Certificate()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public void Dispose()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
protected void ThrowIfDisposed()
}
public System.IdentityModel.Tokens.X509SigningCredentials : SigningCredentials {
private X509Certificate2 <Certificate>k__BackingField
public X509Certificate2 Certificate
public X509Certificate2 get_Certificate()
private void set_Certificate(X509Certificate2 value)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski)
public void .ctor(X509Certificate2 certificate, string signatureAlgorithm, string digestAlgorithm)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski, string signatureAlgorithm, string digestAlgorithm)
private SecurityKeyIdentifier GetSecurityKeyIdentifier(X509Certificate2 certificate)
}
public System.IdentityModel.Tokens.X509SubjectKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] ski)
public bool CanCreateFrom(X509Certificate2 certificate)
public Byte[] GetX509SubjectKeyIdentifier()
public bool Matches(X509Certificate2 certificate)
public string ToString()
public bool TryCreateFrom(X509Certificate2 certificate, X509SubjectKeyIdentifierClause& keyIdentifierClause)
}
public System.IdentityModel.Tokens.X509ThumbprintKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] thumbprint)
public void .ctor(X509Certificate2 certificate)
public Byte[] GetX509Thumbprint()
public bool Matches(X509Certificate2 certificate)
public string ToString()
}
public System.IdentityModel.Tokens.X509WindowsSecurityToken : X509SecurityToken {
private WindowsIdentity identity
public WindowsIdentity WindowsIdentity
public void .ctor(X509Certificate2 certificate, WindowsIdentity windowsIdentity)
public void .ctor(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string id)
public WindowsIdentity get_WindowsIdentity()
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
public System.Security.Claims.AuthenticationInformation : object {
private Collection`1<AuthenticationContext> authorizationContexts
private string <Address>k__BackingField
private string <DnsName>k__BackingField
private Nullable`1<DateTime> <NotOnOrAfter>k__BackingField
private string <Session>k__BackingField
public string Address
public Collection`1<AuthenticationContext> AuthorizationContexts
public string DnsName
public Nullable`1<DateTime> NotOnOrAfter
public string Session
public string get_Address()
public void set_Address(string value)
public Collection`1<AuthenticationContext> get_AuthorizationContexts()
public string get_DnsName()
public void set_DnsName(string value)
public Nullable`1<DateTime> get_NotOnOrAfter()
public void set_NotOnOrAfter(Nullable`1<DateTime> value)
public string get_Session()
public void set_Session(string value)
}
public System.Security.Claims.AuthenticationTypes : object {
public string Basic
public string Federation
public string Kerberos
public string Negotiate
public string Password
public string Signature
public string Windows
public string X509
}
public System.ServiceModel.Security.BinarySecretKeyIdentifierClause : BinaryKeyIdentifierClause {
public bool CanCreateKey
public void .ctor(Byte[] key)
public void .ctor(Byte[] key, bool cloneBuffer)
public void .ctor(Byte[] key, bool cloneBuffer, Byte[] derivationNonce, int derivationLength)
public bool get_CanCreateKey()
public Byte[] GetKeyBytes()
public SecurityKey CreateKey()
public bool Matches(SecurityKeyIdentifierClause clause)
}
public System.ServiceModel.Security.KeyNameIdentifierClause : SecurityKeyIdentifierClause {
private string key_name
public string KeyName
public void .ctor(string keyName)
public string get_KeyName()
public bool Matches(SecurityKeyIdentifierClause clause)
public bool Matches(string keyName)
public string ToString()
}
public System.ServiceModel.Security.SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
private UniqueId context
private UniqueId generation
public UniqueId ContextId
public UniqueId Generation
public void .ctor(UniqueId contextId)
public void .ctor(UniqueId contextId, UniqueId generation)
public void .ctor(UniqueId contextId, UniqueId generation, Byte[] derivationNonce, int derivationLength)
public UniqueId get_ContextId()
public UniqueId get_Generation()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(UniqueId contextId, UniqueId generation)
public string ToString()
}
public System.ServiceModel.Security.Tokens.BinarySecretSecurityToken : SecurityToken {
private ReadOnlyCollection`1<SecurityKey> keys
private string id
private Byte[] key
private bool allow_crypto
private DateTime valid_from
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public int KeySize
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
private void .ctor(string id, bool allowCrypto)
public void .ctor(Byte[] key)
public void .ctor(string id, Byte[] key)
protected void .ctor(string id, Byte[] key, bool allowCrypto)
public void .ctor(int keySizeInBits)
public void .ctor(string id, int keySizeInBits)
protected void .ctor(string id, int keySizeInBits, bool allowCrypto)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public int get_KeySize()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public Byte[] GetKeyBytes()
}
internal System.ServiceModel.Security.Tokens.InternalEncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] hash)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.ServiceModel.Security.Tokens.WrappedKeySecurityToken : SecurityToken {
private string id
private Byte[] raw_key
private Byte[] wrapped_key
private string wrap_alg
private SecurityToken wrap_token
private SecurityKeyIdentifier wrap_token_ref
private DateTime valid_from
private ReadOnlyCollection`1<SecurityKey> keys
private ReferenceList reference_list
private Byte[] keyhash
internal Byte[] RawKey
internal ReferenceList ReferenceList
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public string WrappingAlgorithm
public SecurityToken WrappingToken
public SecurityKeyIdentifier WrappingTokenReference
public void .ctor(string id, Byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference)
internal Byte[] get_RawKey()
internal ReferenceList get_ReferenceList()
internal void set_ReferenceList(ReferenceList value)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public string get_WrappingAlgorithm()
public SecurityToken get_WrappingToken()
public SecurityKeyIdentifier get_WrappingTokenReference()
public Byte[] GetWrappedKey()
internal void SetWrappedKey(Byte[] value)
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.ServiceModel.Security.X509CertificateValidationMode : Enum {
public int value__
public X509CertificateValidationMode None
public X509CertificateValidationMode PeerTrust
public X509CertificateValidationMode ChainTrust
public X509CertificateValidationMode PeerOrChainTrust
public X509CertificateValidationMode Custom
}
