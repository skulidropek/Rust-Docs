internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public int MonoCorlibVersion
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal Mono.Security.Cryptography.HMAC : KeyedHashAlgorithm {
private HashAlgorithm hash
private bool hashing
private Byte[] innerPad
private Byte[] outerPad
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public void .ctor(string hashName, Byte[] rgbKey)
public void Initialize()
protected Byte[] HashFinal()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
private void initializePad()
}
public System.IdentityModel.AsynchronousOperationException : Exception {
public void .ctor(Exception innerException)
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.AsyncResult : object {
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
public void Dispose()
public void End(IAsyncResult result)
}
public System.IdentityModel.BadRequestException : RequestException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.Claims.Claim : object {
private ClaimComparer default_comparer
private Claim system
private string claim_type
private object resource
private string right
public IEqualityComparer`1<Claim> DefaultComparer
public Claim System
public object Resource
public string ClaimType
public string Right
public IEqualityComparer`1<Claim> get_DefaultComparer()
public Claim get_System()
public Claim CreateDnsClaim(string dns)
public Claim CreateDenyOnlyWindowsSidClaim(SecurityIdentifier sid)
public Claim CreateHashClaim(Byte[] hash)
public Claim CreateMailAddressClaim(MailAddress mailAddress)
public Claim CreateNameClaim(string name)
public Claim CreateRsaClaim(RSA rsa)
public Claim CreateSpnClaim(string spn)
public Claim CreateThumbprintClaim(Byte[] thumbprint)
public Claim CreateUpnClaim(string upn)
public Claim CreateUriClaim(Uri uri)
public Claim CreateWindowsSidClaim(SecurityIdentifier sid)
public Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName)
public void .ctor(string claimType, object resource, string right)
public object get_Resource()
public string get_ClaimType()
public string get_Right()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
public System.IdentityModel.Claims.ClaimSet : object {
private ClaimSet system
private ClaimSet win
public ClaimSet System
public ClaimSet Windows
public int Count
public ClaimSet Issuer
public Claim Item
public ClaimSet get_System()
public ClaimSet get_Windows()
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public bool ContainsClaim(Claim claim)
public bool ContainsClaim(Claim claim, IEqualityComparer`1<Claim> comparer)
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
public System.IdentityModel.Claims.ClaimTypes : object {
public string Anonymous
public string Authentication
public string AuthorizationDecision
public string Country
public string DateOfBirth
public string DenyOnlySid
public string Dns
public string Email
public string Gender
public string GivenName
public string Hash
public string HomePhone
public string Locality
public string MobilePhone
public string Name
public string NameIdentifier
public string OtherPhone
public string PostalCode
public string PPID
public string Rsa
public string Sid
public string Spn
public string StateOrProvince
public string StreetAddress
public string Surname
public string System
public string Thumbprint
public string Upn
public string Uri
public string Webpage
public string X500DistinguishedName
public string get_Anonymous()
public string get_Authentication()
public string get_AuthorizationDecision()
public string get_Country()
public string get_DateOfBirth()
public string get_DenyOnlySid()
public string get_Dns()
public string get_Email()
public string get_Gender()
public string get_GivenName()
public string get_Hash()
public string get_HomePhone()
public string get_Locality()
public string get_MobilePhone()
public string get_Name()
public string get_NameIdentifier()
public string get_OtherPhone()
public string get_PostalCode()
public string get_PPID()
public string get_Rsa()
public string get_Sid()
public string get_Spn()
public string get_StateOrProvince()
public string get_StreetAddress()
public string get_Surname()
public string get_System()
public string get_Thumbprint()
public string get_Upn()
public string get_Uri()
public string get_Webpage()
public string get_X500DistinguishedName()
}
public System.IdentityModel.Claims.DefaultClaimSet : ClaimSet {
private List`1<Claim> list
private ClaimSet issuer
public int Count
public ClaimSet Issuer
public Claim Item
internal DefaultClaimSet CreateSystemClaimSet()
public void .ctor(Claim[] claims)
public void .ctor(IList`1<Claim> claims)
public void .ctor(ClaimSet issuer, Claim[] claims)
public void .ctor(ClaimSet issuer, IList`1<Claim> claims)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public bool ContainsClaim(Claim claim)
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
protected void Initialize(ClaimSet issuer, IList`1<Claim> claims)
public string ToString()
}
public System.IdentityModel.Claims.Rights : object {
public string Identity
public string PossessProperty
public string get_Identity()
public string get_PossessProperty()
}
public System.IdentityModel.Claims.WindowsClaimSet : ClaimSet {
private WindowsIdentity identity
private DateTime expiration_time
public int Count
public ClaimSet Issuer
public Claim Item
public DateTime ExpirationTime
public WindowsIdentity WindowsIdentity
public void .ctor(WindowsIdentity windowsIdentity)
public void .ctor(WindowsIdentity windowsIdentity, bool includeWindowsGroups)
public void .ctor(WindowsIdentity windowsIdentity, DateTime expirationTime)
public void .ctor(WindowsIdentity windowsIdentity, bool includeWindowsGroups, DateTime expirationTime)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public DateTime get_ExpirationTime()
public WindowsIdentity get_WindowsIdentity()
public void Dispose()
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
public string ToString()
public void .ctor(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime)
}
public System.IdentityModel.Claims.X509CertificateClaimSet : ClaimSet {
private X509Certificate2 cert
private ClaimSet issuer
private List`1<Claim> claims
public int Count
public ClaimSet Issuer
public Claim Item
public DateTime ExpirationTime
public X509Certificate2 X509Certificate
public void .ctor(X509Certificate2 certificate)
public int get_Count()
public ClaimSet get_Issuer()
public Claim get_Item(int index)
public DateTime get_ExpirationTime()
public X509Certificate2 get_X509Certificate()
public void Dispose()
public IEnumerable`1<Claim> FindClaims(string claimType, string right)
public IEnumerator`1<Claim> GetEnumerator()
public string ToString()
}
public System.IdentityModel.Configuration.AudienceUriElement : ConfigurationElement {
public string Value
public string get_Value()
public void set_Value(string value)
}
public System.IdentityModel.Configuration.AudienceUriElementCollection : ConfigurationElementCollection {
public AudienceUriMode Mode
public AudienceUriMode get_Mode()
public void set_Mode(AudienceUriMode value)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.IdentityModel.Configuration.ConfigurationElementInterceptor : ConfigurationElement {
public XmlNodeList ChildNodes
public XmlElement ElementAsXml
public XmlNodeList get_ChildNodes()
public XmlElement get_ElementAsXml()
}
public System.IdentityModel.Configuration.CustomTypeElement : ConfigurationElementInterceptor {
public bool IsConfigured
public Type Type
public bool get_IsConfigured()
public Type get_Type()
public void set_Type(Type value)
public T Resolve(CustomTypeElement customTypeElement)
}
public System.IdentityModel.Configuration.ICustomIdentityConfiguration {
public void LoadCustomConfiguration(XmlNodeList nodeList)
}
public System.IdentityModel.Configuration.IdentityConfiguration : object {
public X509CertificateValidationMode DefaultCertificateValidationMode
public Type DefaultIssuerNameRegistryType
public TimeSpan DefaultMaxClockSkew
public X509RevocationMode DefaultRevocationMode
public string DefaultServiceName
public StoreLocation DefaultTrustedStoreLocation
public AudienceRestriction AudienceRestriction
public IdentityModelCaches Caches
public X509CertificateValidationMode CertificateValidationMode
public X509CertificateValidator CertificateValidator
public ClaimsAuthenticationManager ClaimsAuthenticationManager
public ClaimsAuthorizationManager ClaimsAuthorizationManager
public bool DetectReplayedTokens
public bool IsInitialized
public IssuerNameRegistry IssuerNameRegistry
public SecurityTokenResolver IssuerTokenResolver
public TimeSpan MaxClockSkew
public string Name
public X509RevocationMode RevocationMode
public bool SaveBootstrapContext
public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager
public SecurityTokenHandlerCollection SecurityTokenHandlers
public X509Certificate2 ServiceCertificate
public SecurityTokenResolver ServiceTokenResolver
public TimeSpan TokenReplayCacheExpirationPeriod
public StoreLocation TrustedStoreLocation
public void .ctor(bool loadConfig)
public void .ctor(bool loadConfig, X509Certificate2 serviceCertificate)
public void .ctor(X509Certificate2 serviceCertificate)
public void .ctor(string identityConfigurationName)
public void .ctor(string identityConfigurationName, X509Certificate2 serviceCertificate)
public AudienceRestriction get_AudienceRestriction()
public void set_AudienceRestriction(AudienceRestriction value)
public IdentityModelCaches get_Caches()
public void set_Caches(IdentityModelCaches value)
public X509CertificateValidationMode get_CertificateValidationMode()
public void set_CertificateValidationMode(X509CertificateValidationMode value)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public ClaimsAuthenticationManager get_ClaimsAuthenticationManager()
public void set_ClaimsAuthenticationManager(ClaimsAuthenticationManager value)
public ClaimsAuthorizationManager get_ClaimsAuthorizationManager()
public void set_ClaimsAuthorizationManager(ClaimsAuthorizationManager value)
public bool get_DetectReplayedTokens()
public void set_DetectReplayedTokens(bool value)
public bool get_IsInitialized()
public IssuerNameRegistry get_IssuerNameRegistry()
public void set_IssuerNameRegistry(IssuerNameRegistry value)
public SecurityTokenResolver get_IssuerTokenResolver()
public void set_IssuerTokenResolver(SecurityTokenResolver value)
public TimeSpan get_MaxClockSkew()
public void set_MaxClockSkew(TimeSpan value)
public string get_Name()
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public bool get_SaveBootstrapContext()
public void set_SaveBootstrapContext(bool value)
public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager()
public SecurityTokenHandlerCollection get_SecurityTokenHandlers()
public X509Certificate2 get_ServiceCertificate()
public void set_ServiceCertificate(X509Certificate2 value)
public SecurityTokenResolver get_ServiceTokenResolver()
public void set_ServiceTokenResolver(SecurityTokenResolver value)
public TimeSpan get_TokenReplayCacheExpirationPeriod()
public void set_TokenReplayCacheExpirationPeriod(TimeSpan value)
public StoreLocation get_TrustedStoreLocation()
public void set_TrustedStoreLocation(StoreLocation value)
public void Initialize()
}
public System.IdentityModel.Configuration.IdentityConfigurationElement : ConfigurationElement {
public AudienceUriElementCollection AudienceUris
public IdentityModelCachesElement Caches
public X509CertificateValidationElement CertificateValidation
public CustomTypeElement ClaimsAuthenticationManager
public CustomTypeElement ClaimsAuthorizationManager
public IssuerNameRegistryElement IssuerNameRegistry
public CustomTypeElement IssuerTokenResolver
public TimeSpan MaximumClockSkew
public string Name
public bool SaveBootstrapContext
public SecurityTokenHandlerSetElementCollection SecurityTokenHandlerSets
public CustomTypeElement ServiceTokenResolver
public TokenReplayDetectionElement TokenReplayDetection
public AudienceUriElementCollection get_AudienceUris()
public IdentityModelCachesElement get_Caches()
public void set_Caches(IdentityModelCachesElement value)
public X509CertificateValidationElement get_CertificateValidation()
public void set_CertificateValidation(X509CertificateValidationElement value)
public CustomTypeElement get_ClaimsAuthenticationManager()
public void set_ClaimsAuthenticationManager(CustomTypeElement value)
public CustomTypeElement get_ClaimsAuthorizationManager()
public void set_ClaimsAuthorizationManager(CustomTypeElement value)
public IssuerNameRegistryElement get_IssuerNameRegistry()
public void set_IssuerNameRegistry(IssuerNameRegistryElement value)
public CustomTypeElement get_IssuerTokenResolver()
public void set_IssuerTokenResolver(CustomTypeElement value)
public TimeSpan get_MaximumClockSkew()
public void set_MaximumClockSkew(TimeSpan value)
public string get_Name()
public void set_Name(string value)
public bool get_SaveBootstrapContext()
public void set_SaveBootstrapContext(bool value)
public SecurityTokenHandlerSetElementCollection get_SecurityTokenHandlerSets()
public CustomTypeElement get_ServiceTokenResolver()
public void set_ServiceTokenResolver(CustomTypeElement value)
public TokenReplayDetectionElement get_TokenReplayDetection()
public void set_TokenReplayDetection(TokenReplayDetectionElement value)
}
public System.IdentityModel.Configuration.IdentityConfigurationElementCollection : ConfigurationElementCollection {
protected ConfigurationElement CreateNewElement()
public IdentityConfigurationElement GetElement(string name)
protected object GetElementKey(ConfigurationElement element)
}
public System.IdentityModel.Configuration.IdentityModelCaches : object {
private SessionSecurityTokenCache <SessionSecurityTokenCache>k__BackingField
private TokenReplayCache <TokenReplayCache>k__BackingField
public SessionSecurityTokenCache SessionSecurityTokenCache
public TokenReplayCache TokenReplayCache
public SessionSecurityTokenCache get_SessionSecurityTokenCache()
public void set_SessionSecurityTokenCache(SessionSecurityTokenCache value)
public TokenReplayCache get_TokenReplayCache()
public void set_TokenReplayCache(TokenReplayCache value)
}
public System.IdentityModel.Configuration.IdentityModelCachesElement : ConfigurationElement {
public bool IsConfigured
public CustomTypeElement SessionSecurityTokenCache
public CustomTypeElement TokenReplayCache
public bool get_IsConfigured()
public CustomTypeElement get_SessionSecurityTokenCache()
public void set_SessionSecurityTokenCache(CustomTypeElement value)
public CustomTypeElement get_TokenReplayCache()
public void set_TokenReplayCache(CustomTypeElement value)
}
public System.IdentityModel.Configuration.IssuerNameRegistryElement : ConfigurationElementInterceptor {
public string Type
public string get_Type()
public void set_Type(string value)
}
public System.IdentityModel.Configuration.SecurityTokenHandlerConfigurationElement : ConfigurationElement {
public AudienceUriElementCollection AudienceUris
public IdentityModelCachesElement Caches
public X509CertificateValidationElement CertificateValidation
public IssuerNameRegistryElement IssuerNameRegistry
public CustomTypeElement IssuerTokenResolver
public TimeSpan MaximumClockSkew
public string Name
public bool SaveBootstrapContext
public CustomTypeElement ServiceTokenResolver
public TokenReplayDetectionElement TokenReplayDetection
public AudienceUriElementCollection get_AudienceUris()
public IdentityModelCachesElement get_Caches()
public void set_Caches(IdentityModelCachesElement value)
public X509CertificateValidationElement get_CertificateValidation()
public void set_CertificateValidation(X509CertificateValidationElement value)
public IssuerNameRegistryElement get_IssuerNameRegistry()
public void set_IssuerNameRegistry(IssuerNameRegistryElement value)
public CustomTypeElement get_IssuerTokenResolver()
public void set_IssuerTokenResolver(CustomTypeElement value)
public TimeSpan get_MaximumClockSkew()
public void set_MaximumClockSkew(TimeSpan value)
public string get_Name()
public void set_Name(string value)
public bool get_SaveBootstrapContext()
public void set_SaveBootstrapContext(bool value)
public CustomTypeElement get_ServiceTokenResolver()
public void set_ServiceTokenResolver(CustomTypeElement value)
public TokenReplayDetectionElement get_TokenReplayDetection()
public void set_TokenReplayDetection(TokenReplayDetectionElement value)
}
public System.IdentityModel.Configuration.SecurityTokenHandlerElementCollection : ConfigurationElementCollection {
public string Name
public SecurityTokenHandlerConfigurationElement SecurityTokenHandlerConfiguration
public string get_Name()
public void set_Name(string value)
public SecurityTokenHandlerConfigurationElement get_SecurityTokenHandlerConfiguration()
public void set_SecurityTokenHandlerConfiguration(SecurityTokenHandlerConfigurationElement value)
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.IdentityModel.Configuration.SecurityTokenHandlerSetElementCollection : ConfigurationElementCollection {
public bool IsConfigured
public bool get_IsConfigured()
protected ConfigurationElement CreateNewElement()
protected object GetElementKey(ConfigurationElement element)
}
public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration : IdentityConfiguration {
public int DefaultMaxSymmetricKeySizeInBits
public int DefaultSymmetricKeySizeInBits
public TimeSpan DefaultTokenLifetime
public string DefaultTokenType
public bool DisableWsdl
public TimeSpan MaximumTokenLifetime
public Type SecurityTokenService
public SigningCredentials SigningCredentials
public string TokenIssuerName
public WSTrust13RequestSerializer WSTrust13RequestSerializer
public WSTrust13ResponseSerializer WSTrust13ResponseSerializer
public WSTrustFeb2005RequestSerializer WSTrustFeb2005RequestSerializer
public WSTrustFeb2005ResponseSerializer WSTrustFeb2005ResponseSerializer
public void .ctor(bool loadConfig)
public void .ctor(string issuerName)
public void .ctor(string issuerName, bool loadConfig)
public void .ctor(string issuerName, SigningCredentials signingCredentials)
public void .ctor(string issuerName, SigningCredentials signingCredentials, bool loadConfig)
public void .ctor(string issuerName, SigningCredentials signingCredentials, string serviceName)
public int get_DefaultMaxSymmetricKeySizeInBits()
public void set_DefaultMaxSymmetricKeySizeInBits(int value)
public int get_DefaultSymmetricKeySizeInBits()
public void set_DefaultSymmetricKeySizeInBits(int value)
public TimeSpan get_DefaultTokenLifetime()
public void set_DefaultTokenLifetime(TimeSpan value)
public string get_DefaultTokenType()
public void set_DefaultTokenType(string value)
public bool get_DisableWsdl()
public void set_DisableWsdl(bool value)
public TimeSpan get_MaximumTokenLifetime()
public void set_MaximumTokenLifetime(TimeSpan value)
public Type get_SecurityTokenService()
public void set_SecurityTokenService(Type value)
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public string get_TokenIssuerName()
public void set_TokenIssuerName(string value)
public WSTrust13RequestSerializer get_WSTrust13RequestSerializer()
public void set_WSTrust13RequestSerializer(WSTrust13RequestSerializer value)
public WSTrust13ResponseSerializer get_WSTrust13ResponseSerializer()
public void set_WSTrust13ResponseSerializer(WSTrust13ResponseSerializer value)
public WSTrustFeb2005RequestSerializer get_WSTrustFeb2005RequestSerializer()
public void set_WSTrustFeb2005RequestSerializer(WSTrustFeb2005RequestSerializer value)
public WSTrustFeb2005ResponseSerializer get_WSTrustFeb2005ResponseSerializer()
public void set_WSTrustFeb2005ResponseSerializer(WSTrustFeb2005ResponseSerializer value)
public SecurityTokenService CreateSecurityTokenService()
}
public System.IdentityModel.Configuration.SystemIdentityModelSection : ConfigurationSection {
public string SectionName
public SystemIdentityModelSection Current
public IdentityConfigurationElement DefaultIdentityConfigurationElement
public IdentityConfigurationElementCollection IdentityConfigurationElements
public SystemIdentityModelSection get_Current()
public IdentityConfigurationElement get_DefaultIdentityConfigurationElement()
public IdentityConfigurationElementCollection get_IdentityConfigurationElements()
}
public System.IdentityModel.Configuration.TokenReplayDetectionElement : ConfigurationElement {
public bool Enabled
public TimeSpan ExpirationPeriod
public bool get_Enabled()
public void set_Enabled(bool value)
public TimeSpan get_ExpirationPeriod()
public void set_ExpirationPeriod(TimeSpan value)
}
public System.IdentityModel.Configuration.X509CertificateValidationElement : ConfigurationElement {
public X509CertificateValidationMode CertificateValidationMode
public CustomTypeElement CertificateValidator
public X509RevocationMode RevocationMode
public StoreLocation TrustedStoreLocation
public X509CertificateValidationMode get_CertificateValidationMode()
public void set_CertificateValidationMode(X509CertificateValidationMode value)
public CustomTypeElement get_CertificateValidator()
public void set_CertificateValidator(CustomTypeElement value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public StoreLocation get_TrustedStoreLocation()
public void set_TrustedStoreLocation(StoreLocation value)
}
public System.IdentityModel.CookieTransform : object {
public Byte[] Encode(Byte[] value)
public Byte[] Decode(Byte[] encoded)
}
public System.IdentityModel.DeflateCookieTransform : CookieTransform {
public int MaxDecompressedSize
public int get_MaxDecompressedSize()
public void set_MaxDecompressedSize(int value)
public Byte[] Decode(Byte[] encoded)
public Byte[] Encode(Byte[] value)
}
public System.IdentityModel.DelegatingXmlDictionaryReader : XmlDictionaryReader {
public int AttributeCount
public string BaseURI
public int Depth
public bool EOF
public bool IsEmptyElement
public string LocalName
public string NamespaceURI
public XmlNameTable NameTable
public XmlNodeType NodeType
public string Prefix
public ReadState ReadState
public string Value
public int get_AttributeCount()
public string get_BaseURI()
public int get_Depth()
public bool get_EOF()
public bool get_IsEmptyElement()
public string get_LocalName()
public string get_NamespaceURI()
public XmlNameTable get_NameTable()
public XmlNodeType get_NodeType()
public string get_Prefix()
public ReadState get_ReadState()
public string get_Value()
public string GetAttribute(int i)
public string GetAttribute(string name)
public string GetAttribute(string name, string namespaceURI)
public string LookupNamespace(string prefix)
public bool MoveToAttribute(string name)
public bool MoveToAttribute(string name, string ns)
public bool MoveToElement()
public bool MoveToFirstAttribute()
public bool MoveToNextAttribute()
public bool Read()
public bool ReadAttributeValue()
public void ResolveEntity()
}
public System.IdentityModel.DelegatingXmlDictionaryWriter : XmlDictionaryWriter {
public WriteState WriteState
public WriteState get_WriteState()
public void Flush()
public string LookupPrefix(string ns)
public void WriteBase64(Byte[] buffer, int index, int count)
public void WriteCData(string text)
public void WriteCharEntity(char ch)
public void WriteChars(Char[] buffer, int index, int count)
public void WriteComment(string text)
public void WriteDocType(string name, string pubid, string sysid, string subset)
public void WriteEndAttribute()
public void WriteEndDocument()
public void WriteEndElement()
public void WriteEntityRef(string name)
public void WriteFullEndElement()
public void WriteProcessingInstruction(string name, string text)
public void WriteRaw(Char[] buffer, int index, int count)
public void WriteRaw(string data)
public void WriteStartAttribute(string prefix, string localName, string ns)
public void WriteStartDocument()
public void WriteStartDocument(bool standalone)
public void WriteStartElement(string prefix, string localName, string ns)
public void WriteString(string text)
public void WriteSurrogateCharEntity(char lowChar, char highChar)
public void WriteWhitespace(string ws)
}
public System.IdentityModel.EnvelopedSignatureReader : DelegatingXmlDictionaryReader {
public SigningCredentials SigningCredentials
public void .ctor(XmlReader reader, SecurityTokenSerializer securityTokenSerializer)
public void .ctor(XmlReader reader, SecurityTokenSerializer securityTokenSerializer, SecurityTokenResolver signingTokenResolver)
public void .ctor(XmlReader reader, SecurityTokenSerializer securityTokenSerializer, SecurityTokenResolver signingTokenResolver, bool requireSignature, bool automaticallyReadSignature, bool resolveIntrinsicSigningKeys)
public SigningCredentials get_SigningCredentials()
public bool Read()
public bool TryReadSignature()
}
public System.IdentityModel.EnvelopedSignatureWriter : DelegatingXmlDictionaryWriter {
public void .ctor(XmlWriter innerWriter, SigningCredentials signingCredentials, string referenceId, SecurityTokenSerializer securityTokenSerializer)
public void WriteEndElement()
public void WriteFullEndElement()
public void WriteSignature()
public void WriteStartElement(string prefix, string localName, string ns)
}
public System.IdentityModel.LimitExceededException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.Metadata.ApplicationServiceDescriptor : WebServiceDescriptor {
public ICollection`1<EndpointReference> Endpoints
public ICollection`1<EndpointReference> PassiveRequestorEndpoints
public ICollection`1<EndpointReference> get_Endpoints()
public ICollection`1<EndpointReference> get_PassiveRequestorEndpoints()
}
public System.IdentityModel.Metadata.ContactPerson : object {
public string Company
public ICollection`1<string> EmailAddresses
public string GivenName
public string Surname
public ICollection`1<string> TelephoneNumbers
public ContactType Type
public void .ctor(ContactType contactType)
public string get_Company()
public void set_Company(string value)
public ICollection`1<string> get_EmailAddresses()
public string get_GivenName()
public void set_GivenName(string value)
public string get_Surname()
public void set_Surname(string value)
public ICollection`1<string> get_TelephoneNumbers()
public ContactType get_Type()
public void set_Type(ContactType value)
}
public System.IdentityModel.Metadata.ContactType : Enum {
public int value__
public ContactType Administrative
public ContactType Billing
public ContactType Other
public ContactType Support
public ContactType Technical
public ContactType Unspecified
}
public System.IdentityModel.Metadata.DisplayClaim : object {
public string ClaimType
public string Description
public string DisplayTag
public string DisplayValue
public bool Optional
public bool WriteOptionalAttribute
public void .ctor(string claimType)
public void .ctor(string claimType, string displayTag, string description)
public void .ctor(string claimType, string displayTag, string description, string displayValue)
public void .ctor(string claimType, string displayTag, string description, string displayValue, bool optional)
public string get_ClaimType()
public string get_Description()
public void set_Description(string value)
public string get_DisplayTag()
public void set_DisplayTag(string value)
public string get_DisplayValue()
public void set_DisplayValue(string value)
public bool get_Optional()
public void set_Optional(bool value)
public bool get_WriteOptionalAttribute()
public void set_WriteOptionalAttribute(bool value)
public DisplayClaim CreateDisplayClaimFromClaimType(string claimType)
}
public System.IdentityModel.Metadata.EncryptionMethod : object {
public Uri Algorithm
public void .ctor(Uri algorithm)
public Uri get_Algorithm()
public void set_Algorithm(Uri value)
}
public System.IdentityModel.Metadata.EntitiesDescriptor : MetadataBase {
public ICollection`1<EntityDescriptor> ChildEntities
public ICollection`1<EntitiesDescriptor> ChildEntityGroups
public string Name
public void .ctor(Collection`1<EntitiesDescriptor> entityGroupList)
public void .ctor(Collection`1<EntityDescriptor> entityList)
public void .ctor(Collection`1<EntityDescriptor> entityList, Collection`1<EntitiesDescriptor> entityGroupList)
public ICollection`1<EntityDescriptor> get_ChildEntities()
public ICollection`1<EntitiesDescriptor> get_ChildEntityGroups()
public string get_Name()
public void set_Name(string value)
}
public System.IdentityModel.Metadata.EntityDescriptor : MetadataBase {
public ICollection`1<ContactPerson> Contacts
public EntityId EntityId
public string FederationId
public Organization Organization
public ICollection`1<RoleDescriptor> RoleDescriptors
public void .ctor(EntityId entityId)
public ICollection`1<ContactPerson> get_Contacts()
public EntityId get_EntityId()
public void set_EntityId(EntityId value)
public string get_FederationId()
public void set_FederationId(string value)
public Organization get_Organization()
public void set_Organization(Organization value)
public ICollection`1<RoleDescriptor> get_RoleDescriptors()
}
public System.IdentityModel.Metadata.EntityId : object {
public string Id
public void .ctor(string id)
public string get_Id()
public void set_Id(string value)
}
public System.IdentityModel.Metadata.IdentityProviderSingleSignOnDescriptor : SingleSignOnDescriptor {
public ICollection`1<ProtocolEndpoint> SingleSignOnServices
public ICollection`1<Saml2Attribute> SupportedAttributes
public bool WantAuthenticationRequestsSigned
public ICollection`1<ProtocolEndpoint> get_SingleSignOnServices()
public ICollection`1<Saml2Attribute> get_SupportedAttributes()
public bool get_WantAuthenticationRequestsSigned()
public void set_WantAuthenticationRequestsSigned(bool value)
}
public System.IdentityModel.Metadata.IndexedProtocolEndpoint : ProtocolEndpoint {
public int Index
public Nullable`1<bool> IsDefault
public void .ctor(int index, Uri binding, Uri location)
public int get_Index()
public void set_Index(int value)
public Nullable`1<bool> get_IsDefault()
public void set_IsDefault(Nullable`1<bool> value)
}
public System.IdentityModel.Metadata.IndexedProtocolEndpointDictionary : SortedList`2<int, IndexedProtocolEndpoint> {
public IndexedProtocolEndpoint Default
public IndexedProtocolEndpoint get_Default()
}
public System.IdentityModel.Metadata.KeyDescriptor : object {
public ICollection`1<EncryptionMethod> EncryptionMethods
public SecurityKeyIdentifier KeyInfo
public KeyType Use
public void .ctor(SecurityKeyIdentifier ski)
public ICollection`1<EncryptionMethod> get_EncryptionMethods()
public SecurityKeyIdentifier get_KeyInfo()
public void set_KeyInfo(SecurityKeyIdentifier value)
public KeyType get_Use()
public void set_Use(KeyType value)
}
public System.IdentityModel.Metadata.KeyType : Enum {
public int value__
public KeyType Encryption
public KeyType Signing
public KeyType Unspecified
}
public System.IdentityModel.Metadata.LocalizedEntry : object {
public CultureInfo Language
public CultureInfo get_Language()
public void set_Language(CultureInfo value)
}
public System.IdentityModel.Metadata.LocalizedEntryCollection`1 : KeyedCollection`2<CultureInfo, T> {
protected CultureInfo GetKeyForItem(T item)
}
public System.IdentityModel.Metadata.LocalizedName : LocalizedEntry {
public string Name
public void .ctor(string name, CultureInfo language)
public string get_Name()
public void set_Name(string value)
}
public System.IdentityModel.Metadata.LocalizedUri : LocalizedEntry {
public Uri Uri
public void .ctor(Uri uri, CultureInfo language)
public Uri get_Uri()
public void set_Uri(Uri value)
}
public System.IdentityModel.Metadata.MetadataBase : object {
public SigningCredentials SigningCredentials
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
}
public System.IdentityModel.Metadata.MetadataSerializationException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.Metadata.MetadataSerializer : object {
public string LanguageAttribute
public string LanguageLocalName
public string LanguageNamespaceUri
public string LanguagePrefix
public X509CertificateValidationMode CertificateValidationMode
public X509CertificateValidator CertificateValidator
public X509RevocationMode RevocationMode
public SecurityTokenSerializer SecurityTokenSerializer
public List`1<string> TrustedIssuers
public StoreLocation TrustedStoreLocation
public void .ctor(SecurityTokenSerializer tokenSerializer)
public X509CertificateValidationMode get_CertificateValidationMode()
public void set_CertificateValidationMode(X509CertificateValidationMode value)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public SecurityTokenSerializer get_SecurityTokenSerializer()
public List`1<string> get_TrustedIssuers()
public StoreLocation get_TrustedStoreLocation()
public void set_TrustedStoreLocation(StoreLocation value)
public MetadataBase ReadMetadata(Stream stream)
public MetadataBase ReadMetadata(XmlReader reader)
public MetadataBase ReadMetadata(XmlReader reader, SecurityTokenResolver tokenResolver)
public bool ReadWebServiceDescriptorElement(XmlReader reader, WebServiceDescriptor roleDescriptor)
public void WriteMetadata(Stream stream, MetadataBase metadata)
public void WriteMetadata(XmlWriter writer, MetadataBase metadata)
}
public System.IdentityModel.Metadata.Organization : object {
public LocalizedEntryCollection`1<LocalizedName> DisplayNames
public LocalizedEntryCollection`1<LocalizedName> Names
public LocalizedEntryCollection`1<LocalizedUri> Urls
public void .ctor(LocalizedEntryCollection`1<LocalizedName> names, LocalizedEntryCollection`1<LocalizedName> displayNames, LocalizedEntryCollection`1<LocalizedUri> urls)
public LocalizedEntryCollection`1<LocalizedName> get_DisplayNames()
public LocalizedEntryCollection`1<LocalizedName> get_Names()
public LocalizedEntryCollection`1<LocalizedUri> get_Urls()
}
public System.IdentityModel.Metadata.ProtocolEndpoint : object {
public Uri Binding
public Uri Location
public Uri ResponseLocation
public void .ctor(Uri binding, Uri location)
public Uri get_Binding()
public void set_Binding(Uri value)
public Uri get_Location()
public void set_Location(Uri value)
public Uri get_ResponseLocation()
public void set_ResponseLocation(Uri value)
}
public System.IdentityModel.Metadata.RoleDescriptor : object {
public ICollection`1<ContactPerson> Contacts
public Uri ErrorUrl
public ICollection`1<KeyDescriptor> Keys
public Organization Organization
public ICollection`1<Uri> ProtocolsSupported
public DateTime ValidUntil
public ICollection`1<ContactPerson> get_Contacts()
public Uri get_ErrorUrl()
public void set_ErrorUrl(Uri value)
public ICollection`1<KeyDescriptor> get_Keys()
public Organization get_Organization()
public void set_Organization(Organization value)
public ICollection`1<Uri> get_ProtocolsSupported()
public DateTime get_ValidUntil()
public void set_ValidUntil(DateTime value)
}
public System.IdentityModel.Metadata.SecurityTokenServiceDescriptor : WebServiceDescriptor {
public Collection`1<EndpointReference> PassiveRequestorEndpoints
public Collection`1<EndpointReference> SecurityTokenServiceEndpoints
public Collection`1<EndpointReference> get_PassiveRequestorEndpoints()
public Collection`1<EndpointReference> get_SecurityTokenServiceEndpoints()
}
public System.IdentityModel.Metadata.ServiceProviderSingleSignOnDescriptor : SingleSignOnDescriptor {
public IndexedProtocolEndpointDictionary AssertionConsumerServices
public bool AuthenticationRequestsSigned
public bool WantAssertionsSigned
public void .ctor(IndexedProtocolEndpointDictionary collection)
public IndexedProtocolEndpointDictionary get_AssertionConsumerServices()
public bool get_AuthenticationRequestsSigned()
public void set_AuthenticationRequestsSigned(bool value)
public bool get_WantAssertionsSigned()
public void set_WantAssertionsSigned(bool value)
}
public System.IdentityModel.Metadata.SingleSignOnDescriptor : RoleDescriptor {
public IndexedProtocolEndpointDictionary ArtifactResolutionServices
public ICollection`1<Uri> NameIdentifierFormats
public Collection`1<ProtocolEndpoint> SingleLogoutServices
public IndexedProtocolEndpointDictionary get_ArtifactResolutionServices()
public ICollection`1<Uri> get_NameIdentifierFormats()
public Collection`1<ProtocolEndpoint> get_SingleLogoutServices()
}
public System.IdentityModel.Metadata.WebServiceDescriptor : RoleDescriptor {
public ICollection`1<DisplayClaim> ClaimTypesOffered
public ICollection`1<DisplayClaim> ClaimTypesRequested
public string ServiceDescription
public string ServiceDisplayName
public ICollection`1<EndpointReference> TargetScopes
public ICollection`1<Uri> TokenTypesOffered
public ICollection`1<DisplayClaim> get_ClaimTypesOffered()
public ICollection`1<DisplayClaim> get_ClaimTypesRequested()
public string get_ServiceDescription()
public void set_ServiceDescription(string value)
public string get_ServiceDisplayName()
public void set_ServiceDisplayName(string value)
public ICollection`1<EndpointReference> get_TargetScopes()
public ICollection`1<Uri> get_TokenTypesOffered()
}
public System.IdentityModel.OpenObject : object {
private Dictionary`2<string, object> properties
public Dictionary`2<string, object> Properties
public Dictionary`2<string, object> get_Properties()
}
public System.IdentityModel.Policy.AuthorizationContext : object {
public DateTime ExpirationTime
public string Id
public ReadOnlyCollection`1<ClaimSet> ClaimSets
public IDictionary`2<string, object> Properties
public AuthorizationContext CreateDefaultAuthorizationContext(IList`1<IAuthorizationPolicy> authorizationPolicies)
public DateTime get_ExpirationTime()
public string get_Id()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public IDictionary`2<string, object> get_Properties()
}
internal System.IdentityModel.Policy.DefaultEvaluationContext : EvaluationContext {
private DateTime expiration_time
private int generation
private Collection`1<ClaimSet> claim_sets
private ReadOnlyCollection`1<ClaimSet> exposed_claim_sets
private Dictionary`2<string, object> properties
private Dictionary`2<IAuthorizationPolicy, ClaimSet> claim_set_map
public int Generation
public IDictionary`2<string, object> Properties
public ReadOnlyCollection`1<ClaimSet> ClaimSets
internal DateTime ExpirationTime
public int get_Generation()
public IDictionary`2<string, object> get_Properties()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public void AddClaimSet(IAuthorizationPolicy authorizationPolicy, ClaimSet claimSet)
public void RecordExpirationTime(DateTime time)
internal DateTime get_ExpirationTime()
}
public System.IdentityModel.Policy.EvaluationContext : object {
public int Generation
public IDictionary`2<string, object> Properties
public ReadOnlyCollection`1<ClaimSet> ClaimSets
public int get_Generation()
public IDictionary`2<string, object> get_Properties()
public ReadOnlyCollection`1<ClaimSet> get_ClaimSets()
public void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet)
public void RecordExpirationTime(DateTime expirationTime)
}
public System.IdentityModel.Policy.IAuthorizationComponent {
public string Id
public string get_Id()
}
public System.IdentityModel.Policy.IAuthorizationPolicy {
public ClaimSet Issuer
public ClaimSet get_Issuer()
public bool Evaluate(EvaluationContext evaluationContext, Object& state)
}
public System.IdentityModel.ProtectedDataCookieTransform : CookieTransform {
public Byte[] Decode(Byte[] encoded)
public Byte[] Encode(Byte[] value)
}
public System.IdentityModel.Protocols.WSTrust.AdditionalContext : object {
public IList`1<ContextItem> Items
public void .ctor(IEnumerable`1<ContextItem> items)
public IList`1<ContextItem> get_Items()
}
public System.IdentityModel.Protocols.WSTrust.BinaryExchange : object {
private string defaultEncodingTypeUrl
private Byte[] <BinaryData>k__BackingField
private Uri <EncodingType>k__BackingField
private Uri <ValueType>k__BackingField
public Byte[] BinaryData
public Uri EncodingType
public Uri ValueType
public Byte[] get_BinaryData()
private void set_BinaryData(Byte[] value)
public Uri get_EncodingType()
private void set_EncodingType(Uri value)
public Uri get_ValueType()
private void set_ValueType(Uri value)
public void .ctor(Byte[] binaryData, Uri valueType)
public void .ctor(Byte[] binaryData, Uri valueType, Uri encodingType)
}
public System.IdentityModel.Protocols.WSTrust.ContextItem : object {
public Uri Name
public Uri Scope
public string Value
public void .ctor(Uri name)
public void .ctor(Uri name, string value)
public void .ctor(Uri name, string value, Uri scope)
public Uri get_Name()
public void set_Name(Uri value)
public Uri get_Scope()
public void set_Scope(Uri value)
public string get_Value()
public void set_Value(string value)
}
public System.IdentityModel.Protocols.WSTrust.EndpointReference : object {
private Collection`1<XmlElement> details
private Uri uri
public Collection`1<XmlElement> Details
public Uri Uri
public Collection`1<XmlElement> get_Details()
public Uri get_Uri()
public void .ctor(string uri)
public EndpointReference ReadFrom(XmlDictionaryReader reader)
public EndpointReference ReadFrom(XmlReader reader)
public void WriteTo(XmlWriter writer)
}
public System.IdentityModel.Protocols.WSTrust.Entropy : ProtectedKey {
public void .ctor(ProtectedKey protectedKey)
public void .ctor(Byte[] secret)
public void .ctor(int entropySizeInBits)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
private Byte[] GetRandomByteArray(int arraySize)
}
public System.IdentityModel.Protocols.WSTrust.InvalidRequestException : RequestException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.Protocols.WSTrust.KeyTypes : object {
public string Asymmetric
public string Bearer
public string Symmetric
}
public System.IdentityModel.Protocols.WSTrust.Lifetime : object {
private Nullable`1<DateTime> <Created>k__BackingField
private Nullable`1<DateTime> <Expires>k__BackingField
public Nullable`1<DateTime> Created
public Nullable`1<DateTime> Expires
public Nullable`1<DateTime> get_Created()
public void set_Created(Nullable`1<DateTime> value)
public Nullable`1<DateTime> get_Expires()
public void set_Expires(Nullable`1<DateTime> value)
public void .ctor(DateTime created, DateTime expires)
public void .ctor(Nullable`1<DateTime> created, Nullable`1<DateTime> expires)
}
public System.IdentityModel.Protocols.WSTrust.Participants : object {
public List`1<EndpointReference> Participant
public EndpointReference Primary
public List`1<EndpointReference> get_Participant()
public EndpointReference get_Primary()
public void set_Primary(EndpointReference value)
}
public System.IdentityModel.Protocols.WSTrust.ProtectedKey : object {
private Byte[] secret
private EncryptingCredentials <WrappingCredentials>k__BackingField
public EncryptingCredentials WrappingCredentials
public EncryptingCredentials get_WrappingCredentials()
private void set_WrappingCredentials(EncryptingCredentials value)
public void .ctor(Byte[] secret)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
public Byte[] GetKeyBytes()
}
public System.IdentityModel.Protocols.WSTrust.Renewing : object {
public bool AllowRenewal
public bool OkForRenewalAfterExpiration
public void .ctor(bool allowRenewal, bool okForRenewalAfterExpiration)
public bool get_AllowRenewal()
public void set_AllowRenewal(bool value)
public bool get_OkForRenewalAfterExpiration()
public void set_OkForRenewalAfterExpiration(bool value)
}
public System.IdentityModel.Protocols.WSTrust.RequestClaim : object {
public string ClaimType
public bool IsOptional
public string Value
public void .ctor(string claimType)
public void .ctor(string claimType, bool isOptional)
public void .ctor(string claimType, bool isOptional, string value)
public string get_ClaimType()
public bool get_IsOptional()
public void set_IsOptional(bool value)
public string get_Value()
public void set_Value(string value)
}
public System.IdentityModel.Protocols.WSTrust.RequestClaimCollection : Collection`1<RequestClaim> {
public string Dialect
public string get_Dialect()
public void set_Dialect(string value)
}
public System.IdentityModel.Protocols.WSTrust.RequestedProofToken : object {
private string <ComputedKeyAlgorithm>k__BackingField
private ProtectedKey <ProtectedKey>k__BackingField
public string ComputedKeyAlgorithm
public ProtectedKey ProtectedKey
public string get_ComputedKeyAlgorithm()
private void set_ComputedKeyAlgorithm(string value)
public ProtectedKey get_ProtectedKey()
private void set_ProtectedKey(ProtectedKey value)
public void .ctor(ProtectedKey protectedKey)
public void .ctor(Byte[] secret)
public void .ctor(string computedKeyAlgorithm)
public void .ctor(Byte[] secret, EncryptingCredentials wrappingCredentials)
}
public System.IdentityModel.Protocols.WSTrust.RequestedSecurityToken : object {
private SecurityToken <SecurityToken>k__BackingField
private XmlElement <SecurityTokenXml>k__BackingField
public SecurityToken SecurityToken
public XmlElement SecurityTokenXml
public SecurityToken get_SecurityToken()
private void set_SecurityToken(SecurityToken value)
public XmlElement get_SecurityTokenXml()
private void set_SecurityTokenXml(XmlElement value)
public void .ctor(SecurityToken token)
public void .ctor(XmlElement tokenAsXml)
}
public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken : WSTrustMessage {
public SecurityTokenElement ActAs
public AdditionalContext AdditionalContext
public SecurityTokenElement CancelTarget
public RequestClaimCollection Claims
public string ComputedKeyAlgorithm
public Nullable`1<bool> Delegatable
public SecurityTokenElement DelegateTo
public SecurityTokenElement Encryption
public Nullable`1<bool> Forwardable
public EndpointReference Issuer
public SecurityTokenElement OnBehalfOf
public Participants Participants
public SecurityTokenElement ProofEncryption
public Renewing Renewing
public SecurityTokenElement RenewTarget
public RequestSecurityToken SecondaryParameters
public SecurityTokenElement ValidateTarget
public void .ctor(string requestType)
public void .ctor(string requestType, string keyType)
public SecurityTokenElement get_ActAs()
public void set_ActAs(SecurityTokenElement value)
public AdditionalContext get_AdditionalContext()
public void set_AdditionalContext(AdditionalContext value)
public SecurityTokenElement get_CancelTarget()
public void set_CancelTarget(SecurityTokenElement value)
public RequestClaimCollection get_Claims()
public string get_ComputedKeyAlgorithm()
public void set_ComputedKeyAlgorithm(string value)
public Nullable`1<bool> get_Delegatable()
public void set_Delegatable(Nullable`1<bool> value)
public SecurityTokenElement get_DelegateTo()
public void set_DelegateTo(SecurityTokenElement value)
public SecurityTokenElement get_Encryption()
public void set_Encryption(SecurityTokenElement value)
public Nullable`1<bool> get_Forwardable()
public void set_Forwardable(Nullable`1<bool> value)
public EndpointReference get_Issuer()
public void set_Issuer(EndpointReference value)
public SecurityTokenElement get_OnBehalfOf()
public void set_OnBehalfOf(SecurityTokenElement value)
public Participants get_Participants()
public void set_Participants(Participants value)
public SecurityTokenElement get_ProofEncryption()
public void set_ProofEncryption(SecurityTokenElement value)
public Renewing get_Renewing()
public void set_Renewing(Renewing value)
public SecurityTokenElement get_RenewTarget()
public void set_RenewTarget(SecurityTokenElement value)
public RequestSecurityToken get_SecondaryParameters()
public void set_SecondaryParameters(RequestSecurityToken value)
public SecurityTokenElement get_ValidateTarget()
public void set_ValidateTarget(SecurityTokenElement value)
}
public System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse : WSTrustMessage {
private bool <IsFinal>k__BackingField
private SecurityKeyIdentifierClause <RequestedAttachedReference>k__BackingField
private RequestedProofToken <RequestedProofToken>k__BackingField
private RequestedSecurityToken <RequestedSecurityToken>k__BackingField
private bool <RequestedTokenCancelled>k__BackingField
private SecurityKeyIdentifierClause <RequestedUnattachedReference>k__BackingField
private Status <Status>k__BackingField
public bool IsFinal
public SecurityKeyIdentifierClause RequestedAttachedReference
public RequestedProofToken RequestedProofToken
public RequestedSecurityToken RequestedSecurityToken
public bool RequestedTokenCancelled
public SecurityKeyIdentifierClause RequestedUnattachedReference
public Status Status
public bool get_IsFinal()
public void set_IsFinal(bool value)
public SecurityKeyIdentifierClause get_RequestedAttachedReference()
public void set_RequestedAttachedReference(SecurityKeyIdentifierClause value)
public RequestedProofToken get_RequestedProofToken()
public void set_RequestedProofToken(RequestedProofToken value)
public RequestedSecurityToken get_RequestedSecurityToken()
public void set_RequestedSecurityToken(RequestedSecurityToken value)
public bool get_RequestedTokenCancelled()
public void set_RequestedTokenCancelled(bool value)
public SecurityKeyIdentifierClause get_RequestedUnattachedReference()
public void set_RequestedUnattachedReference(SecurityKeyIdentifierClause value)
public Status get_Status()
public void set_Status(Status value)
public void .ctor(WSTrustMessage message)
}
public System.IdentityModel.Protocols.WSTrust.RequestTypes : object {
public string Cancel
public string GetMetadata
public string Issue
public string IssueCard
public string Renew
public string Validate
}
public System.IdentityModel.Protocols.WSTrust.Status : object {
private string <Code>k__BackingField
private string <Reason>k__BackingField
public string Code
public string Reason
public string get_Code()
public void set_Code(string value)
public string get_Reason()
public void set_Reason(string value)
public void .ctor(string code, string reason)
}
public System.IdentityModel.Protocols.WSTrust.UseKey : object {
private SecurityKeyIdentifier <SecurityKeyIdentifier>k__BackingField
private SecurityToken <Token>k__BackingField
public SecurityKeyIdentifier SecurityKeyIdentifier
public SecurityToken Token
public SecurityKeyIdentifier get_SecurityKeyIdentifier()
private void set_SecurityKeyIdentifier(SecurityKeyIdentifier value)
public SecurityToken get_Token()
private void set_Token(SecurityToken value)
public void .ctor(SecurityKeyIdentifier ski)
public void .ctor(SecurityToken token)
public void .ctor(SecurityKeyIdentifier ski, SecurityToken token)
}
public System.IdentityModel.Protocols.WSTrust.WSTrust13RequestSerializer : WSTrustRequestSerializer {
public bool CanRead(XmlReader reader)
public RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityToken rst, WSTrustSerializationContext context)
public void WriteKnownRequestElement(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken rst, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrust13ResponseSerializer : WSTrustResponseSerializer {
public bool CanRead(XmlReader reader)
public RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context)
public void WriteKnownResponseElement(RequestSecurityTokenResponse rstr, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005RequestSerializer : WSTrustRequestSerializer {
public bool CanRead(XmlReader reader)
public RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityToken rst, WSTrustSerializationContext context)
public void WriteKnownRequestElement(RequestSecurityToken rst, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken rst, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustFeb2005ResponseSerializer : WSTrustResponseSerializer {
public bool CanRead(XmlReader reader)
public RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context)
public void WriteKnownResponseElement(RequestSecurityTokenResponse rstr, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse rstr, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustMessage : OpenObject {
private bool <AllowPostdating>k__BackingField
private EndpointReference <AppliesTo>k__BackingField
private string <AuthenticationType>k__BackingField
private BinaryExchange <BinaryExchange>k__BackingField
private string <CanonicalizationAlgorithm>k__BackingField
private string <Context>k__BackingField
private string <EncryptionAlgorithm>k__BackingField
private string <EncryptWith>k__BackingField
private Entropy <Entropy>k__BackingField
private Nullable`1<int> <KeySizeInBits>k__BackingField
private string <KeyType>k__BackingField
private string <KeyWrapAlgorithm>k__BackingField
private Lifetime <Lifetime>k__BackingField
private string <ReplyTo>k__BackingField
private string <RequestType>k__BackingField
private string <SignatureAlgorithm>k__BackingField
private string <SignWith>k__BackingField
private string <TokenType>k__BackingField
private UseKey <UseKey>k__BackingField
public bool AllowPostdating
public EndpointReference AppliesTo
public string AuthenticationType
public BinaryExchange BinaryExchange
public string CanonicalizationAlgorithm
public string Context
public string EncryptionAlgorithm
public string EncryptWith
public Entropy Entropy
public Nullable`1<int> KeySizeInBits
public string KeyType
public string KeyWrapAlgorithm
public Lifetime Lifetime
public string ReplyTo
public string RequestType
public string SignatureAlgorithm
public string SignWith
public string TokenType
public UseKey UseKey
public bool get_AllowPostdating()
public void set_AllowPostdating(bool value)
public EndpointReference get_AppliesTo()
public void set_AppliesTo(EndpointReference value)
public string get_AuthenticationType()
public void set_AuthenticationType(string value)
public BinaryExchange get_BinaryExchange()
public void set_BinaryExchange(BinaryExchange value)
public string get_CanonicalizationAlgorithm()
public void set_CanonicalizationAlgorithm(string value)
public string get_Context()
public void set_Context(string value)
public string get_EncryptionAlgorithm()
public void set_EncryptionAlgorithm(string value)
public string get_EncryptWith()
public void set_EncryptWith(string value)
public Entropy get_Entropy()
public void set_Entropy(Entropy value)
public Nullable`1<int> get_KeySizeInBits()
public void set_KeySizeInBits(Nullable`1<int> value)
public string get_KeyType()
public void set_KeyType(string value)
public string get_KeyWrapAlgorithm()
public void set_KeyWrapAlgorithm(string value)
public Lifetime get_Lifetime()
public void set_Lifetime(Lifetime value)
public string get_ReplyTo()
public void set_ReplyTo(string value)
public string get_RequestType()
public void set_RequestType(string value)
public string get_SignatureAlgorithm()
public void set_SignatureAlgorithm(string value)
public string get_SignWith()
public void set_SignWith(string value)
public string get_TokenType()
public void set_TokenType(string value)
public UseKey get_UseKey()
public void set_UseKey(UseKey value)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustRequestSerializer : object {
public bool CanRead(XmlReader reader)
public RequestSecurityToken CreateRequestSecurityToken()
public RequestSecurityToken ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityToken requestSecurityToken, WSTrustSerializationContext context)
public void Validate(RequestSecurityToken requestSecurityToken)
public void WriteKnownRequestElement(RequestSecurityToken requestSecurityToken, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityToken request, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityToken requestSecurityToken, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustResponseSerializer : object {
public bool CanRead(XmlReader reader)
public RequestSecurityTokenResponse CreateInstance()
public RequestSecurityTokenResponse ReadXml(XmlReader reader, WSTrustSerializationContext context)
public void ReadXmlElement(XmlReader reader, RequestSecurityTokenResponse requestSecurityTokenResponse, WSTrustSerializationContext context)
public void Validate(RequestSecurityTokenResponse requestSecurityTokenResponse)
public void WriteKnownResponseElement(RequestSecurityTokenResponse requestSecurityTokenResponse, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXml(RequestSecurityTokenResponse response, XmlWriter writer, WSTrustSerializationContext context)
public void WriteXmlElement(XmlWriter writer, string elementName, object elementValue, RequestSecurityTokenResponse requestSecurityTokenResponse, WSTrustSerializationContext context)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustSerializationContext : object {
public SecurityTokenHandlerCollectionManager SecurityTokenHandlerCollectionManager
public SecurityTokenHandlerCollection SecurityTokenHandlers
public SecurityTokenResolver TokenResolver
public SecurityTokenResolver UseKeyTokenResolver
public void .ctor(SecurityTokenHandlerCollectionManager securityTokenHandlerCollectionManager)
public void .ctor(SecurityTokenHandlerCollectionManager securityTokenHandlerCollectionManager, SecurityTokenResolver securityTokenResolver, SecurityTokenResolver useKeyTokenResolver)
public SecurityTokenHandlerCollectionManager get_SecurityTokenHandlerCollectionManager()
public void set_SecurityTokenHandlerCollectionManager(SecurityTokenHandlerCollectionManager value)
public SecurityTokenHandlerCollection get_SecurityTokenHandlers()
public SecurityTokenResolver get_TokenResolver()
public void set_TokenResolver(SecurityTokenResolver value)
public SecurityTokenResolver get_UseKeyTokenResolver()
public void set_UseKeyTokenResolver(SecurityTokenResolver value)
}
public System.IdentityModel.Protocols.WSTrust.WSTrustSerializationException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
public System.IdentityModel.RequestFailedException : RequestException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.RsaEncryptionCookieTransform : CookieTransform {
public RSA EncryptionKey
public string HashName
public void .ctor(RSA key)
public void .ctor(X509Certificate2 certificate)
public RSA get_EncryptionKey()
public void set_EncryptionKey(RSA value)
public string get_HashName()
public void set_HashName(string value)
public Byte[] Decode(Byte[] encoded)
public Byte[] Encode(Byte[] value)
}
public System.IdentityModel.RsaSignatureCookieTransform : CookieTransform {
public string HashName
public RSA SigningKey
public void .ctor(RSA key)
public void .ctor(X509Certificate2 certificate)
public string get_HashName()
public void set_HashName(string value)
public RSA get_SigningKey()
public void set_SigningKey(RSA value)
public Byte[] Decode(Byte[] encoded)
public Byte[] Encode(Byte[] value)
}
public System.IdentityModel.Scope : object {
public string AppliesToAddress
public EncryptingCredentials EncryptingCredentials
public Dictionary`2<string, object> Properties
public string ReplyToAddress
public SigningCredentials SigningCredentials
public bool SymmetricKeyEncryptionRequired
public bool TokenEncryptionRequired
public void .ctor(string appliesToAddress)
public void .ctor(string appliesToAddress, EncryptingCredentials encryptingCredentials)
public void .ctor(string appliesToAddress, SigningCredentials signingCredentials)
public void .ctor(string appliesToAddress, SigningCredentials signingCredentials, EncryptingCredentials encryptingCredentials)
public string get_AppliesToAddress()
public void set_AppliesToAddress(string value)
public EncryptingCredentials get_EncryptingCredentials()
public void set_EncryptingCredentials(EncryptingCredentials value)
public Dictionary`2<string, object> get_Properties()
public string get_ReplyToAddress()
public void set_ReplyToAddress(string value)
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public bool get_SymmetricKeyEncryptionRequired()
public void set_SymmetricKeyEncryptionRequired(bool value)
public bool get_TokenEncryptionRequired()
public void set_TokenEncryptionRequired(bool value)
}
public System.IdentityModel.SecurityMessageSerializationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.IdentityModel.SecurityTokenService : object {
public ClaimsPrincipal Principal
public RequestSecurityToken Request
public Scope Scope
public SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration
public ClaimsPrincipal get_Principal()
public void set_Principal(ClaimsPrincipal value)
public RequestSecurityToken get_Request()
public void set_Request(RequestSecurityToken value)
public Scope get_Scope()
public void set_Scope(Scope value)
public SecurityTokenServiceConfiguration get_SecurityTokenServiceConfiguration()
public IAsyncResult BeginCancel(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state)
public IAsyncResult BeginIssue(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state)
public IAsyncResult BeginRenew(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state)
public IAsyncResult BeginValidate(ClaimsPrincipal principal, RequestSecurityToken request, AsyncCallback callback, object state)
public RequestSecurityTokenResponse Cancel(ClaimsPrincipal principal, RequestSecurityToken request)
public RequestSecurityTokenResponse EndCancel(IAsyncResult result)
public RequestSecurityTokenResponse EndIssue(IAsyncResult result)
public RequestSecurityTokenResponse EndRenew(IAsyncResult result)
public RequestSecurityTokenResponse EndValidate(IAsyncResult result)
public RequestSecurityTokenResponse Issue(ClaimsPrincipal principal, RequestSecurityToken request)
public RequestSecurityTokenResponse Renew(ClaimsPrincipal principal, RequestSecurityToken request)
public RequestSecurityTokenResponse Validate(ClaimsPrincipal principal, RequestSecurityToken request)
}
public System.IdentityModel.Selectors.AudienceUriMode : Enum {
public int value__
public AudienceUriMode Never
public AudienceUriMode Always
public AudienceUriMode BearerKeyOnly
}
public System.IdentityModel.Selectors.AudienceUriModeValidationHelper : object {
public bool IsDefined(AudienceUriMode validationMode)
}
public System.IdentityModel.Selectors.CustomUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
private UserNamePasswordValidator validator
public void .ctor(UserNamePasswordValidator validator)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.KerberosSecurityTokenAuthenticator : WindowsSecurityTokenAuthenticator {
public void .ctor(bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.KerberosSecurityTokenProvider : SecurityTokenProvider {
private string name
private TokenImpersonationLevel impersonation_level
private NetworkCredential credential
public string ServicePrincipalName
public TokenImpersonationLevel TokenImpersonationLevel
public NetworkCredential NetworkCredential
public void .ctor(string servicePrincipalName)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential)
public string get_ServicePrincipalName()
public TokenImpersonationLevel get_TokenImpersonationLevel()
public NetworkCredential get_NetworkCredential()
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.Selectors.RsaSecurityTokenAuthenticator : SecurityTokenAuthenticator {
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator : SecurityTokenAuthenticator {
private IList`1<SecurityTokenAuthenticator> authenticators
private TimeSpan max_clock_skew
public IList`1<string> AllowedAudienceUris
public AudienceUriMode AudienceUriMode
public void .ctor(IList`1<SecurityTokenAuthenticator> supportingAuthenticators)
public void .ctor(IList`1<SecurityTokenAuthenticator> supportingAuthenticators, TimeSpan maxClockSkew)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
public ClaimSet ResolveClaimSet(SecurityKeyIdentifier keyIdentifier)
public ClaimSet ResolveClaimSet(SecurityToken token)
public IIdentity ResolveIdentity(SecurityKeyIdentifier keyIdentifier)
public IIdentity ResolveIdentity(SecurityToken token)
public IList`1<string> get_AllowedAudienceUris()
public AudienceUriMode get_AudienceUriMode()
public void set_AudienceUriMode(AudienceUriMode value)
}
public System.IdentityModel.Selectors.SecurityTokenAuthenticator : object {
public bool CanValidateToken(SecurityToken token)
protected bool CanValidateTokenCore(SecurityToken token)
public ReadOnlyCollection`1<IAuthorizationPolicy> ValidateToken(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.SecurityTokenManager : object {
public SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver)
public SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
public SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
}
public System.IdentityModel.Selectors.SecurityTokenProvider : object {
public bool SupportsTokenCancellation
public bool SupportsTokenRenewal
public bool get_SupportsTokenCancellation()
public bool get_SupportsTokenRenewal()
public SecurityToken GetToken(TimeSpan timeout)
public IAsyncResult BeginGetToken(TimeSpan timeout, AsyncCallback callback, object state)
public SecurityToken EndGetToken(IAsyncResult result)
public void CancelToken(TimeSpan timeout, SecurityToken token)
public IAsyncResult BeginCancelToken(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state)
public void EndCancelToken(IAsyncResult result)
public SecurityToken RenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed)
public IAsyncResult BeginRenewToken(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state)
public SecurityToken EndRenewToken(IAsyncResult result)
protected SecurityToken GetTokenCore(TimeSpan timeout)
protected void CancelTokenCore(TimeSpan timeout, SecurityToken token)
protected SecurityToken RenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed)
protected IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state)
protected IAsyncResult BeginCancelTokenCore(TimeSpan timeout, SecurityToken token, AsyncCallback callback, object state)
protected IAsyncResult BeginRenewTokenCore(TimeSpan timeout, SecurityToken tokenToBeRenewed, AsyncCallback callback, object state)
protected SecurityToken EndGetTokenCore(IAsyncResult result)
protected void EndCancelTokenCore(IAsyncResult result)
protected SecurityToken EndRenewTokenCore(IAsyncResult result)
}
public System.IdentityModel.Selectors.SecurityTokenRequirement : object {
private Dictionary`2<string, object> properties
public string KeySizeProperty
public string KeyTypeProperty
public string KeyUsageProperty
public string RequireCryptographicTokenProperty
public string TokenTypeProperty
public int KeySize
public SecurityKeyType KeyType
public string TokenType
public SecurityKeyUsage KeyUsage
public bool RequireCryptographicToken
public IDictionary`2<string, object> Properties
public string IsOptionalTokenProperty
public string PeerAuthenticationMode
public string get_KeySizeProperty()
public string get_KeyTypeProperty()
public string get_KeyUsageProperty()
public string get_RequireCryptographicTokenProperty()
public string get_TokenTypeProperty()
public int get_KeySize()
public void set_KeySize(int value)
public SecurityKeyType get_KeyType()
public void set_KeyType(SecurityKeyType value)
public string get_TokenType()
public void set_TokenType(string value)
public SecurityKeyUsage get_KeyUsage()
public void set_KeyUsage(SecurityKeyUsage value)
public bool get_RequireCryptographicToken()
public void set_RequireCryptographicToken(bool value)
public IDictionary`2<string, object> get_Properties()
public TValue GetProperty(string propertyName)
public bool TryGetProperty(string propertyName, TValue& result)
public string get_IsOptionalTokenProperty()
public string get_PeerAuthenticationMode()
}
public System.IdentityModel.Selectors.SecurityTokenResolver : object {
public SecurityTokenResolver CreateDefaultSecurityTokenResolver(ReadOnlyCollection`1<SecurityToken> tokens, bool canMatchLocalId)
public SecurityKey ResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause)
public SecurityToken ResolveToken(SecurityKeyIdentifier keyIdentifier)
public SecurityToken ResolveToken(SecurityKeyIdentifierClause keyIdentifierClause)
public bool TryResolveSecurityKey(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
public bool TryResolveToken(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
public bool TryResolveToken(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
protected bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
protected bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
protected bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.IdentityModel.Selectors.SecurityTokenSerializer : object {
public bool CanReadKeyIdentifier(XmlReader reader)
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanReadToken(XmlReader reader)
public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public bool CanWriteToken(SecurityToken token)
public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
public void WriteToken(XmlWriter writer, SecurityToken token)
protected bool CanReadKeyIdentifierClauseCore(XmlReader reader)
protected bool CanReadKeyIdentifierCore(XmlReader reader)
protected bool CanReadTokenCore(XmlReader reader)
protected SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader)
protected SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
protected SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver)
protected bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier)
protected bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause)
protected bool CanWriteTokenCore(SecurityToken token)
protected void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier)
protected void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
protected void WriteTokenCore(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Selectors.SecurityTokenVersion : object {
public ReadOnlyCollection`1<string> GetSecuritySpecifications()
}
internal System.IdentityModel.Selectors.SystemIdentityAuthorizationPolicy : object {
private string id
public string Id
public ClaimSet Issuer
public DateTime ExpirationTime
protected void .ctor(string id)
public string get_Id()
public ClaimSet get_Issuer()
public bool Evaluate(EvaluationContext ec, Object& state)
public DateTime get_ExpirationTime()
public ClaimSet CreateClaims()
public IIdentity CreateIdentity()
}
public System.IdentityModel.Selectors.UserNamePasswordValidator : object {
private UserNamePasswordValidator none_validator
public UserNamePasswordValidator None
public UserNamePasswordValidator get_None()
public UserNamePasswordValidator CreateMembershipProviderValidator(MembershipProvider provider)
public void Validate(string userName, string password)
}
public System.IdentityModel.Selectors.UserNameSecurityTokenAuthenticator : SecurityTokenAuthenticator {
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.UserNameSecurityTokenProvider : SecurityTokenProvider {
private string user
private string pass
public void .ctor(string userName, string password)
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.Selectors.WindowsSecurityTokenAuthenticator : SecurityTokenAuthenticator {
public void .ctor(bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
}
public System.IdentityModel.Selectors.WindowsUserNameSecurityTokenAuthenticator : UserNameSecurityTokenAuthenticator {
private bool include_win_groups
public void .ctor(bool includeWindowsGroups)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateUserNamePasswordCore(string userName, string password)
}
public System.IdentityModel.Selectors.X509CertificateValidator : object {
private X509CertificateValidator none
private X509CertificateValidator chain
private X509CertificateValidator peer_or_chain
private X509CertificateValidator peer
public X509CertificateValidator None
public X509CertificateValidator ChainTrust
public X509CertificateValidator PeerOrChainTrust
public X509CertificateValidator PeerTrust
public X509CertificateValidator get_None()
public X509CertificateValidator get_ChainTrust()
public X509CertificateValidator get_PeerOrChainTrust()
public X509CertificateValidator get_PeerTrust()
public X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy)
public X509CertificateValidator CreatePeerOrChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy)
public void Validate(X509Certificate2 certificate)
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.IdentityModel.Selectors.X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
private bool map_to_windows
private bool include_win_groups
private X509CertificateValidator validator
public bool MapCertificateToWindowsAccount
public void .ctor(X509CertificateValidator validator)
public void .ctor(X509CertificateValidator validator, bool mapToWindows)
public void .ctor(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups)
protected bool CanValidateTokenCore(SecurityToken token)
protected ReadOnlyCollection`1<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token)
public bool get_MapCertificateToWindowsAccount()
}
public System.IdentityModel.Selectors.X509SecurityTokenProvider : SecurityTokenProvider {
private X509Certificate2 cert
private X509Store store
public X509Certificate2 Certificate
public void .ctor(X509Certificate2 certificate)
public void .ctor(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue)
public X509Certificate2 get_Certificate()
public void Dispose()
protected SecurityToken GetTokenCore(TimeSpan timeout)
}
public System.IdentityModel.SignatureVerificationFailedException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.AggregateTokenResolver : SecurityTokenResolver {
public ReadOnlyCollection`1<SecurityTokenResolver> TokenResolvers
public void .ctor(IEnumerable`1<SecurityTokenResolver> tokenResolvers)
public ReadOnlyCollection`1<SecurityTokenResolver> get_TokenResolvers()
protected bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
protected bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
protected bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
}
internal System.IdentityModel.Tokens.AlgorithmSupportType : Enum {
public int value__
public AlgorithmSupportType Symmetric
public AlgorithmSupportType Asymmetric
public AlgorithmSupportType Unsupported
}
public System.IdentityModel.Tokens.AsymmetricProofDescriptor : ProofDescriptor {
public SecurityKeyIdentifier KeyIdentifier
public void .ctor(SecurityKeyIdentifier keyIdentifier)
public void .ctor(RSA rsaAlgorithm)
public SecurityKeyIdentifier get_KeyIdentifier()
public void ApplyTo(RequestSecurityTokenResponse response)
}
public System.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
}
public System.IdentityModel.Tokens.AudienceRestriction : object {
private Collection`1<Uri> <AllowedAudienceUris>k__BackingField
private AudienceUriMode <AudienceMode>k__BackingField
public Collection`1<Uri> AllowedAudienceUris
public AudienceUriMode AudienceMode
public Collection`1<Uri> get_AllowedAudienceUris()
private void set_AllowedAudienceUris(Collection`1<Uri> value)
public AudienceUriMode get_AudienceMode()
public void set_AudienceMode(AudienceUriMode value)
public void .ctor(AudienceUriMode audienceMode)
}
public System.IdentityModel.Tokens.AudienceUriValidationFailedException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
public System.IdentityModel.Tokens.AuthenticationContext : object {
private Collection`1<string> <Authorities>k__BackingField
private string <ContextClass>k__BackingField
private string <ContextDeclaration>k__BackingField
public Collection`1<string> Authorities
public string ContextClass
public string ContextDeclaration
public Collection`1<string> get_Authorities()
private void set_Authorities(Collection`1<string> value)
public string get_ContextClass()
public void set_ContextClass(string value)
public string get_ContextDeclaration()
public void set_ContextDeclaration(string value)
}
public System.IdentityModel.Tokens.AuthenticationMethods : object {
public string HardwareToken
public string Kerberos
public string Namespace
public string Password
public string Pgp
public string SecureRemotePassword
public string Signature
public string Smartcard
public string SmartcardPki
public string Spki
public string TlsClient
public string Unspecified
public string Windows
public string X509
public string Xkms
}
public System.IdentityModel.Tokens.BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
private Byte[] data
protected void .ctor(string clauseType, Byte[] identificationData, bool cloneBuffer)
protected void .ctor(string clauseType, Byte[] identificationData, bool cloneBuffer, Byte[] derivationNonce, int derivationLength)
public Byte[] GetBuffer()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(Byte[] data)
public bool Matches(Byte[] data, int offset)
protected Byte[] GetRawBuffer()
}
public System.IdentityModel.Tokens.BootstrapContext : object {
private string <Token>k__BackingField
private Byte[] <TokenBytes>k__BackingField
private SecurityToken <SecurityToken>k__BackingField
private SecurityTokenHandler <SecurityTokenHandler>k__BackingField
public string Token
public Byte[] TokenBytes
public SecurityToken SecurityToken
public SecurityTokenHandler SecurityTokenHandler
public string get_Token()
private void set_Token(string value)
public Byte[] get_TokenBytes()
private void set_TokenBytes(Byte[] value)
public SecurityToken get_SecurityToken()
private void set_SecurityToken(SecurityToken value)
public SecurityTokenHandler get_SecurityTokenHandler()
private void set_SecurityTokenHandler(SecurityTokenHandler value)
public void .ctor(string token)
public void .ctor(Byte[] token)
public void .ctor(SecurityToken token, SecurityTokenHandler tokenHandler)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.ComputedKeyAlgorithms : object {
public string Psha1
}
public System.IdentityModel.Tokens.ConfigurationBasedIssuerNameRegistry : IssuerNameRegistry {
public IDictionary`2<string, string> ConfiguredTrustedIssuers
public IDictionary`2<string, string> get_ConfiguredTrustedIssuers()
public void AddTrustedIssuer(string certificateThumbprint, string name)
public string GetIssuerName(SecurityToken securityToken)
}
public System.IdentityModel.Tokens.EmptySecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
public object Context
public void .ctor(object context)
public object get_Context()
}
public System.IdentityModel.Tokens.EncryptedKeyEncryptingCredentials : EncryptingCredentials {
public EncryptingCredentials WrappingCredentials
public void .ctor(EncryptingCredentials wrappingCredentials, int keySizeInBits, string encryptionAlgorithm)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, string keyWrappingAlgorithm, int keySizeInBits, string encryptionAlgorithm)
public EncryptingCredentials get_WrappingCredentials()
}
public System.IdentityModel.Tokens.EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
private string carried_key_name
private string enc_method
private SecurityKeyIdentifier identifier
public string CarriedKeyName
public string EncryptionMethod
public SecurityKeyIdentifier EncryptingKeyIdentifier
public void .ctor(Byte[] encryptedKey, string encryptionMethod)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName)
public void .ctor(Byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, Byte[] derivationNonce, int derivationLength)
public string get_CarriedKeyName()
public string get_EncryptionMethod()
public SecurityKeyIdentifier get_EncryptingKeyIdentifier()
public Byte[] GetEncryptedKey()
public bool Matches(Byte[] encryptedKey, string encryptionMethod, string carriedKeyName)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public string ToString()
}
public System.IdentityModel.Tokens.EncryptedSecurityToken : SecurityToken {
public EncryptingCredentials EncryptingCredentials
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public SecurityToken Token
public DateTime ValidFrom
public DateTime ValidTo
public void .ctor(SecurityToken token, EncryptingCredentials encryptingCredentials)
public EncryptingCredentials get_EncryptingCredentials()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public SecurityToken get_Token()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
}
public System.IdentityModel.Tokens.EncryptedSecurityTokenHandler : SecurityTokenHandler {
public SecurityTokenSerializer KeyInfoSerializer
public Type TokenType
public SecurityTokenSerializer get_KeyInfoSerializer()
public void set_KeyInfoSerializer(SecurityTokenSerializer value)
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.EncryptedTokenDecryptionFailedException : SecurityTokenException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
}
public System.IdentityModel.Tokens.EncryptingCredentials : object {
private string <Algorithm>k__BackingField
private SecurityKey <SecurityKey>k__BackingField
private SecurityKeyIdentifier <SecurityKeyIdentifier>k__BackingField
public string Algorithm
public SecurityKey SecurityKey
public SecurityKeyIdentifier SecurityKeyIdentifier
public string get_Algorithm()
public void set_Algorithm(string value)
public SecurityKey get_SecurityKey()
public void set_SecurityKey(SecurityKey value)
public SecurityKeyIdentifier get_SecurityKeyIdentifier()
public void set_SecurityKeyIdentifier(SecurityKeyIdentifier value)
public void .ctor(SecurityKey key, SecurityKeyIdentifier keyIdentifier, string algorithm)
}
public System.IdentityModel.Tokens.GenericXmlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
public XmlElement ReferenceXml
public void .ctor(XmlElement referenceXml)
public void .ctor(XmlElement referenceXml, Byte[] derivationNonce, int derivationLength)
public XmlElement get_ReferenceXml()
}
public System.IdentityModel.Tokens.GenericXmlSecurityToken : SecurityToken {
private XmlElement xml
private SecurityToken proof_token
private DateTime from
private DateTime to
private SecurityKeyIdentifierClause int_tokenref
private SecurityKeyIdentifierClause ext_tokenref
private ReadOnlyCollection`1<IAuthorizationPolicy> auth_policies
public string Id
public XmlElement TokenXml
public SecurityToken ProofToken
public DateTime ValidFrom
public DateTime ValidTo
public SecurityKeyIdentifierClause InternalTokenReference
public SecurityKeyIdentifierClause ExternalTokenReference
public ReadOnlyCollection`1<IAuthorizationPolicy> AuthorizationPolicies
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(XmlElement tokenXml, SecurityToken proofToken, DateTime effectiveTime, DateTime expirationTime, SecurityKeyIdentifierClause internalTokenReference, SecurityKeyIdentifierClause externalTokenReference, ReadOnlyCollection`1<IAuthorizationPolicy> authorizationPolicies)
public string get_Id()
public XmlElement get_TokenXml()
public SecurityToken get_ProofToken()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public SecurityKeyIdentifierClause get_InternalTokenReference()
public SecurityKeyIdentifierClause get_ExternalTokenReference()
public ReadOnlyCollection`1<IAuthorizationPolicy> get_AuthorizationPolicies()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.InMemorySymmetricSecurityKey : SymmetricSecurityKey {
private Byte[] key
public int KeySize
public void .ctor(Byte[] symmetricKey)
public void .ctor(Byte[] symmetricKey, bool cloneBuffer)
public Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset)
private Byte[] Expand(string hashName, Byte[] secret, Byte[] seed, int length)
public Byte[] GetSymmetricKey()
public KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm)
public SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm)
public ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv)
public ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv)
public int GetIVSize(string algorithm)
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.IssuerNameRegistry : object {
public string GetIssuerName(SecurityToken securityToken)
public string GetIssuerName(SecurityToken securityToken, string requestedIssuerName)
public string GetWindowsIssuerName()
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.IdentityModel.Tokens.IssuerTokenResolver : SecurityTokenResolver {
public StoreLocation DefaultStoreLocation
public StoreName DefaultStoreName
public SecurityTokenResolver WrappedTokenResolver
public void .ctor(SecurityTokenResolver wrappedTokenResolver)
public SecurityTokenResolver get_WrappedTokenResolver()
protected bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
protected bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
protected bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
}
public System.IdentityModel.Tokens.KerberosReceiverSecurityToken : WindowsSecurityToken {
public SymmetricSecurityKey SecurityKey
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public string ValueTypeUri
public void .ctor(Byte[] request)
public void .ctor(Byte[] request, string id)
public SymmetricSecurityKey get_SecurityKey()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public Byte[] GetRequest()
public void .ctor(Byte[] request, string id, string valueTypeUri)
public string get_ValueTypeUri()
}
public System.IdentityModel.Tokens.KerberosRequestorSecurityToken : SecurityToken {
private NetworkCredential cred
private TokenImpersonationLevel imp_level
private string svc_principal_name
private string id
public string ServicePrincipalName
public SymmetricSecurityKey SecurityKey
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(string servicePrincipalName)
public void .ctor(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential, string id)
public string get_ServicePrincipalName()
public SymmetricSecurityKey get_SecurityKey()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public Byte[] GetRequest()
}
public System.IdentityModel.Tokens.KerberosSecurityTokenHandler : SecurityTokenHandler {
public Type TokenType
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.KerberosTicketHashKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] ticketHash)
public void .ctor(Byte[] ticketHash, Byte[] derivationNonce, int derivationLength)
public Byte[] GetKerberosTicketHash()
}
public System.IdentityModel.Tokens.LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
private string local_id
private Type owner_type
public string LocalId
public Type OwnerType
public void .ctor(string localId)
public void .ctor(string localId, Type ownerType)
public void .ctor(string localId, Byte[] derivationNonce, int derivationLength, Type ownerType)
public string get_LocalId()
public Type get_OwnerType()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(string localId, Type ownerType)
public string ToString()
}
public System.IdentityModel.Tokens.ProofDescriptor : object {
public SecurityKeyIdentifier KeyIdentifier
public SecurityKeyIdentifier get_KeyIdentifier()
public void ApplyTo(RequestSecurityTokenResponse response)
}
public System.IdentityModel.Tokens.RsaKeyIdentifierClause : SecurityKeyIdentifierClause {
private RSA rsa
public RSA Rsa
public bool CanCreateKey
public void .ctor(RSA rsa)
public RSA get_Rsa()
public bool get_CanCreateKey()
public SecurityKey CreateKey()
public Byte[] GetExponent()
public void WriteExponentAsBase64(XmlWriter writer)
public Byte[] GetModulus()
public void WriteModulusAsBase64(XmlWriter writer)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(RSA rsa)
public string ToString()
}
public System.IdentityModel.Tokens.RsaSecurityKey : AsymmetricSecurityKey {
private RSA rsa
public int KeySize
public void .ctor(RSA rsa)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool requiresPrivateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.RsaSecurityToken : SecurityToken {
private RSA rsa
private string id
private DateTime valid_from
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public RSA Rsa
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(RSA rsa)
public void .ctor(RSA rsa, string id)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public RSA get_Rsa()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.RsaSecurityTokenHandler : SecurityTokenHandler {
public Type TokenType
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.Saml2Action : object {
public Uri Namespace
public string Value
public void .ctor(string value, Uri actionNamespace)
public Uri get_Namespace()
public void set_Namespace(Uri value)
public string get_Value()
public void set_Value(string value)
}
public System.IdentityModel.Tokens.Saml2Advice : object {
public Collection`1<Saml2Id> AssertionIdReferences
public Collection`1<Saml2Assertion> Assertions
public Collection`1<Uri> AssertionUriReferences
public Collection`1<Saml2Id> get_AssertionIdReferences()
public Collection`1<Saml2Assertion> get_Assertions()
public Collection`1<Uri> get_AssertionUriReferences()
}
public System.IdentityModel.Tokens.Saml2Assertion : object {
public Saml2Advice Advice
public bool CanWriteSourceData
public Saml2Conditions Conditions
public EncryptingCredentials EncryptingCredentials
public Collection`1<EncryptedKeyIdentifierClause> ExternalEncryptedKeys
public Saml2Id Id
public DateTime IssueInstant
public Saml2NameIdentifier Issuer
public SigningCredentials SigningCredentials
public Collection`1<Saml2Statement> Statements
public Saml2Subject Subject
public string Version
public void .ctor(Saml2NameIdentifier issuer)
public Saml2Advice get_Advice()
public void set_Advice(Saml2Advice value)
public bool get_CanWriteSourceData()
public Saml2Conditions get_Conditions()
public void set_Conditions(Saml2Conditions value)
public EncryptingCredentials get_EncryptingCredentials()
public void set_EncryptingCredentials(EncryptingCredentials value)
public Collection`1<EncryptedKeyIdentifierClause> get_ExternalEncryptedKeys()
public Saml2Id get_Id()
public void set_Id(Saml2Id value)
public DateTime get_IssueInstant()
public void set_IssueInstant(DateTime value)
public Saml2NameIdentifier get_Issuer()
public void set_Issuer(Saml2NameIdentifier value)
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public Collection`1<Saml2Statement> get_Statements()
public Saml2Subject get_Subject()
public void set_Subject(Saml2Subject value)
public string get_Version()
public void WriteSourceData(XmlWriter writer)
}
public System.IdentityModel.Tokens.Saml2AssertionKeyIdentifierClause : SecurityKeyIdentifierClause {
public void .ctor(string id)
public void .ctor(string id, Byte[] derivationNonce, int derivationLength)
public bool Matches(string assertionId, SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.Saml2Attribute : object {
public string AttributeValueXsiType
public string FriendlyName
public string Name
public Uri NameFormat
public string OriginalIssuer
public Collection`1<string> Values
public void .ctor(string name)
public void .ctor(string name, IEnumerable`1<string> values)
public void .ctor(string name, string value)
public string get_AttributeValueXsiType()
public void set_AttributeValueXsiType(string value)
public string get_FriendlyName()
public void set_FriendlyName(string value)
public string get_Name()
public void set_Name(string value)
public Uri get_NameFormat()
public void set_NameFormat(Uri value)
public string get_OriginalIssuer()
public void set_OriginalIssuer(string value)
public Collection`1<string> get_Values()
}
public System.IdentityModel.Tokens.Saml2AttributeStatement : Saml2Statement {
public Collection`1<Saml2Attribute> Attributes
public void .ctor(IEnumerable`1<Saml2Attribute> attributes)
public void .ctor(Saml2Attribute attribute)
public Collection`1<Saml2Attribute> get_Attributes()
}
public System.IdentityModel.Tokens.Saml2AudienceRestriction : object {
public Collection`1<Uri> Audiences
public void .ctor(IEnumerable`1<Uri> audiences)
public void .ctor(Uri audience)
public Collection`1<Uri> get_Audiences()
}
public System.IdentityModel.Tokens.Saml2AuthenticationContext : object {
public Collection`1<Uri> AuthenticatingAuthorities
public Uri ClassReference
public Uri DeclarationReference
public void .ctor(Uri classReference)
public void .ctor(Uri classReference, Uri declarationReference)
public Collection`1<Uri> get_AuthenticatingAuthorities()
public Uri get_ClassReference()
public void set_ClassReference(Uri value)
public Uri get_DeclarationReference()
public void set_DeclarationReference(Uri value)
}
public System.IdentityModel.Tokens.Saml2AuthenticationStatement : Saml2Statement {
public Saml2AuthenticationContext AuthenticationContext
public DateTime AuthenticationInstant
public string SessionIndex
public Nullable`1<DateTime> SessionNotOnOrAfter
public Saml2SubjectLocality SubjectLocality
public void .ctor(Saml2AuthenticationContext authenticationContext)
public void .ctor(Saml2AuthenticationContext authenticationContext, DateTime authenticationInstant)
public Saml2AuthenticationContext get_AuthenticationContext()
public void set_AuthenticationContext(Saml2AuthenticationContext value)
public DateTime get_AuthenticationInstant()
public void set_AuthenticationInstant(DateTime value)
public string get_SessionIndex()
public void set_SessionIndex(string value)
public Nullable`1<DateTime> get_SessionNotOnOrAfter()
public void set_SessionNotOnOrAfter(Nullable`1<DateTime> value)
public Saml2SubjectLocality get_SubjectLocality()
public void set_SubjectLocality(Saml2SubjectLocality value)
}
public System.IdentityModel.Tokens.Saml2AuthorizationDecisionStatement : Saml2Statement {
public Uri EmptyResource
public Collection`1<Saml2Action> Actions
public SamlAccessDecision Decision
public Saml2Evidence Evidence
public Uri Resource
public void .ctor(Uri resource, SamlAccessDecision decision)
public void .ctor(Uri resource, SamlAccessDecision decision, IEnumerable`1<Saml2Action> actions)
public Collection`1<Saml2Action> get_Actions()
public SamlAccessDecision get_Decision()
public void set_Decision(SamlAccessDecision value)
public Saml2Evidence get_Evidence()
public void set_Evidence(Saml2Evidence value)
public Uri get_Resource()
public void set_Resource(Uri value)
}
public System.IdentityModel.Tokens.Saml2Conditions : object {
public Collection`1<Saml2AudienceRestriction> AudienceRestrictions
public Nullable`1<DateTime> NotBefore
public Nullable`1<DateTime> NotOnOrAfter
public bool OneTimeUse
public Saml2ProxyRestriction ProxyRestriction
public Collection`1<Saml2AudienceRestriction> get_AudienceRestrictions()
public Nullable`1<DateTime> get_NotBefore()
public void set_NotBefore(Nullable`1<DateTime> value)
public Nullable`1<DateTime> get_NotOnOrAfter()
public void set_NotOnOrAfter(Nullable`1<DateTime> value)
public bool get_OneTimeUse()
public void set_OneTimeUse(bool value)
public Saml2ProxyRestriction get_ProxyRestriction()
public void set_ProxyRestriction(Saml2ProxyRestriction value)
}
public System.IdentityModel.Tokens.Saml2Evidence : object {
public Collection`1<Saml2Id> AssertionIdReferences
public Collection`1<Saml2Assertion> Assertions
public Collection`1<Uri> AssertionUriReferences
public void .ctor(Saml2Assertion assertion)
public void .ctor(Saml2Id idReference)
public void .ctor(Uri uriReference)
public Collection`1<Saml2Id> get_AssertionIdReferences()
public Collection`1<Saml2Assertion> get_Assertions()
public Collection`1<Uri> get_AssertionUriReferences()
}
public System.IdentityModel.Tokens.Saml2Id : object {
public string Value
public void .ctor(string value)
public string get_Value()
}
public System.IdentityModel.Tokens.Saml2NameIdentifier : object {
public EncryptingCredentials EncryptingCredentials
public Collection`1<EncryptedKeyIdentifierClause> ExternalEncryptedKeys
public Uri Format
public string NameQualifier
public string SPNameQualifier
public string SPProvidedId
public string Value
public void .ctor(string name)
public void .ctor(string name, Uri format)
public EncryptingCredentials get_EncryptingCredentials()
public void set_EncryptingCredentials(EncryptingCredentials value)
public Collection`1<EncryptedKeyIdentifierClause> get_ExternalEncryptedKeys()
public Uri get_Format()
public void set_Format(Uri value)
public string get_NameQualifier()
public void set_NameQualifier(string value)
public string get_SPNameQualifier()
public void set_SPNameQualifier(string value)
public string get_SPProvidedId()
public void set_SPProvidedId(string value)
public string get_Value()
public void set_Value(string value)
}
public System.IdentityModel.Tokens.Saml2ProxyRestriction : object {
public Collection`1<Uri> Audiences
public Nullable`1<int> Count
public Collection`1<Uri> get_Audiences()
public Nullable`1<int> get_Count()
public void set_Count(Nullable`1<int> value)
}
public System.IdentityModel.Tokens.Saml2SecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
public Saml2Assertion Assertion
public void .ctor(Saml2Assertion assertion)
public Saml2Assertion get_Assertion()
}
public System.IdentityModel.Tokens.Saml2SecurityToken : SecurityToken {
public Saml2Assertion Assertion
public string Id
public SecurityToken IssuerToken
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public DateTime ValidFrom
public DateTime ValidTo
public void .ctor(Saml2Assertion assertion)
public void .ctor(Saml2Assertion assertion, ReadOnlyCollection`1<SecurityKey> keys, SecurityToken issuerToken)
public Saml2Assertion get_Assertion()
public string get_Id()
public SecurityToken get_IssuerToken()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
}
public System.IdentityModel.Tokens.Saml2SecurityTokenHandler : SecurityTokenHandler {
public string TokenProfile11ValueType
public X509CertificateValidator CertificateValidator
public SecurityTokenSerializer KeyInfoSerializer
public SamlSecurityTokenRequirement SamlSecurityTokenRequirement
public Type TokenType
public void .ctor(SamlSecurityTokenRequirement samlSecurityTokenRequirement)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public SecurityTokenSerializer get_KeyInfoSerializer()
public void set_KeyInfoSerializer(SecurityTokenSerializer value)
public SamlSecurityTokenRequirement get_SamlSecurityTokenRequirement()
public void set_SamlSecurityTokenRequirement(SamlSecurityTokenRequirement value)
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.Saml2Subject : object {
public Saml2NameIdentifier NameId
public Collection`1<Saml2SubjectConfirmation> SubjectConfirmations
public void .ctor(Saml2NameIdentifier nameId)
public void .ctor(Saml2SubjectConfirmation subjectConfirmation)
public Saml2NameIdentifier get_NameId()
public void set_NameId(Saml2NameIdentifier value)
public Collection`1<Saml2SubjectConfirmation> get_SubjectConfirmations()
}
public System.IdentityModel.Tokens.Saml2SubjectConfirmation : object {
public Uri Method
public Saml2NameIdentifier NameIdentifier
public Saml2SubjectConfirmationData SubjectConfirmationData
public void .ctor(Uri method)
public void .ctor(Uri method, Saml2SubjectConfirmationData data)
public Uri get_Method()
public void set_Method(Uri value)
public Saml2NameIdentifier get_NameIdentifier()
public void set_NameIdentifier(Saml2NameIdentifier value)
public Saml2SubjectConfirmationData get_SubjectConfirmationData()
public void set_SubjectConfirmationData(Saml2SubjectConfirmationData value)
}
public System.IdentityModel.Tokens.Saml2SubjectConfirmationData : object {
public string Address
public Saml2Id InResponseTo
public Collection`1<SecurityKeyIdentifier> KeyIdentifiers
public Nullable`1<DateTime> NotBefore
public Nullable`1<DateTime> NotOnOrAfter
public Uri Recipient
public string get_Address()
public void set_Address(string value)
public Saml2Id get_InResponseTo()
public void set_InResponseTo(Saml2Id value)
public Collection`1<SecurityKeyIdentifier> get_KeyIdentifiers()
public Nullable`1<DateTime> get_NotBefore()
public void set_NotBefore(Nullable`1<DateTime> value)
public Nullable`1<DateTime> get_NotOnOrAfter()
public void set_NotOnOrAfter(Nullable`1<DateTime> value)
public Uri get_Recipient()
public void set_Recipient(Uri value)
}
public System.IdentityModel.Tokens.Saml2SubjectLocality : object {
public string Address
public string DnsName
public void .ctor(string address, string dnsName)
public string get_Address()
public void set_Address(string value)
public string get_DnsName()
public void set_DnsName(string value)
}
public System.IdentityModel.Tokens.SamlAccessDecision : Enum {
public int value__
public SamlAccessDecision Permit
public SamlAccessDecision Deny
public SamlAccessDecision Indeterminate
}
public System.IdentityModel.Tokens.SamlAction : object {
private string action
private string ns
private bool is_readonly
public string Action
public bool IsReadOnly
public string Namespace
public void .ctor(string action)
public void .ctor(string action, string ns)
public string get_Action()
public void set_Action(string value)
public bool get_IsReadOnly()
public string get_Namespace()
public void set_Namespace(string value)
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAdvice : object {
private List`1<string> idrefs
private List`1<SamlAssertion> assertions
private bool is_readonly
public bool IsReadOnly
public IList`1<SamlAssertion> Assertions
public IList`1<string> AssertionIdReferences
public void .ctor(IEnumerable`1<SamlAssertion> assertions)
public void .ctor(IEnumerable`1<string> references)
public void .ctor(IEnumerable`1<string> references, IEnumerable`1<SamlAssertion> assertions)
public bool get_IsReadOnly()
public IList`1<SamlAssertion> get_Assertions()
public IList`1<string> get_AssertionIdReferences()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAssertion : object {
private bool is_readonly
private SamlAdvice advice
private SamlConditions conditions
private string assertion_id
private string issuer
private DateTime issue_instant
private int major
private int minor
private SigningCredentials signing_credentials
private List`1<SamlStatement> statements
public SamlAdvice Advice
public string AssertionId
public SamlConditions Conditions
public DateTime IssueInstant
public string Issuer
public int MajorVersion
public int MinorVersion
public SigningCredentials SigningCredentials
public SecurityToken SigningToken
public IList`1<SamlStatement> Statements
public bool IsReadOnly
public bool CanWriteSourceData
public void .ctor(string assertionId, string issuer, DateTime issueInstant, SamlConditions samlConditions, SamlAdvice samlAdvice, IEnumerable`1<SamlStatement> samlStatements)
private bool IsInvalidAssertionId(string assertionId)
public SamlAdvice get_Advice()
public void set_Advice(SamlAdvice value)
public string get_AssertionId()
public void set_AssertionId(string value)
public SamlConditions get_Conditions()
public void set_Conditions(SamlConditions value)
public DateTime get_IssueInstant()
public void set_IssueInstant(DateTime value)
public string get_Issuer()
public void set_Issuer(string value)
public int get_MajorVersion()
public int get_MinorVersion()
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public SecurityToken get_SigningToken()
public IList`1<SamlStatement> get_Statements()
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void ReadSignature(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver, SamlSerializer samlSerializer)
public bool get_CanWriteSourceData()
public void set_SigningToken(SecurityToken value)
public void WriteSourceData(XmlWriter writer)
}
public System.IdentityModel.Tokens.SamlAssertionKeyIdentifierClause : SecurityKeyIdentifierClause {
private string id
public string AssertionId
public void .ctor(string assertionId)
public string get_AssertionId()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(string assertionId)
public string ToString()
public void .ctor(string assertionId, Byte[] derivationNonce, int derivationLength)
}
public System.IdentityModel.Tokens.SamlAttribute : object {
private bool is_readonly
private string name
private string ns
private List`1<string> attribute_values
public IList`1<string> AttributeValues
public string Name
public string Namespace
public bool IsReadOnly
public string AttributeValueXsiType
public string OriginalIssuer
public void .ctor(Claim claim)
public void .ctor(string attributeNamespace, string attributeName, IEnumerable`1<string> attributeValues)
public IList`1<string> get_AttributeValues()
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
public ReadOnlyCollection`1<Claim> ExtractClaims()
public string get_AttributeValueXsiType()
public void set_AttributeValueXsiType(string value)
public string get_OriginalIssuer()
public void set_OriginalIssuer(string value)
}
public System.IdentityModel.Tokens.SamlAttributeStatement : SamlSubjectStatement {
private bool is_readonly
private List`1<SamlAttribute> attributes
public IList`1<SamlAttribute> Attributes
public bool IsReadOnly
public void .ctor(SamlSubject samlSubject, IEnumerable`1<SamlAttribute> attributes)
public IList`1<SamlAttribute> get_Attributes()
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void AddClaimsToList(IList`1<Claim> claims)
}
public System.IdentityModel.Tokens.SamlAudienceRestrictionCondition : SamlCondition {
private List`1<Uri> audiences
private bool is_readonly
public IList`1<Uri> Audiences
public bool IsReadOnly
public void .ctor(IEnumerable`1<Uri> audiences)
public IList`1<Uri> get_Audiences()
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAuthenticationClaimResource : object {
private ReadOnlyCollection`1<SamlAuthorityBinding> bindings
private DateTime instant
private string method
private string dns
private string ip
public DateTime AuthenticationInstant
public string AuthenticationMethod
public string DnsAddress
public string IPAddress
public ReadOnlyCollection`1<SamlAuthorityBinding> AuthorityBindings
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress)
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings)
public void .ctor(DateTime authenticationInstant, string authenticationMethod, string dnsAddress, string ipAddress, ReadOnlyCollection`1<SamlAuthorityBinding> authorityBindings)
public DateTime get_AuthenticationInstant()
public string get_AuthenticationMethod()
public string get_DnsAddress()
public string get_IPAddress()
public ReadOnlyCollection`1<SamlAuthorityBinding> get_AuthorityBindings()
}
public System.IdentityModel.Tokens.SamlAuthenticationStatement : SamlSubjectStatement {
private bool is_readonly
private string auth_method
private string dns
private string ip
private IList`1<SamlAuthorityBinding> bindings
private DateTime instant
public string ClaimType
public DateTime AuthenticationInstant
public string AuthenticationMethod
public IList`1<SamlAuthorityBinding> AuthorityBindings
public string DnsAddress
public string IPAddress
public bool IsReadOnly
public string get_ClaimType()
public void .ctor(SamlSubject samlSubject, string authenticationMethod, DateTime authenticationInstant, string dnsAddress, string ipAddress, IEnumerable`1<SamlAuthorityBinding> authorityBindings)
public DateTime get_AuthenticationInstant()
public void set_AuthenticationInstant(DateTime value)
public string get_AuthenticationMethod()
public void set_AuthenticationMethod(string value)
public IList`1<SamlAuthorityBinding> get_AuthorityBindings()
public string get_DnsAddress()
public void set_DnsAddress(string value)
public string get_IPAddress()
public void set_IPAddress(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
protected void AddClaimsToList(IList`1<Claim> claims)
}
public System.IdentityModel.Tokens.SamlAuthorityBinding : object {
private XmlQualifiedName kind
private string binding
private string location
private bool is_readonly
public XmlQualifiedName AuthorityKind
public string Binding
public string Location
public bool IsReadOnly
public void .ctor(XmlQualifiedName authorityKind, string binding, string location)
public XmlQualifiedName get_AuthorityKind()
public void set_AuthorityKind(XmlQualifiedName value)
public string get_Binding()
public void set_Binding(string value)
public string get_Location()
public void set_Location(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlAuthorizationDecisionClaimResource : object {
private SamlAccessDecision decision
private string name
private string ns
private string resource
public SamlAccessDecision AccessDecision
public string ActionName
public string ActionNamespace
public string Resource
public void .ctor(string resource, SamlAccessDecision accessDecision, string actionNamespace, string actionName)
public SamlAccessDecision get_AccessDecision()
public string get_ActionName()
public string get_ActionNamespace()
public string get_Resource()
}
public System.IdentityModel.Tokens.SamlAuthorizationDecisionStatement : SamlSubjectStatement {
private SamlAccessDecision access_decision
private SamlEvidence evidence
private string resource
private List`1<SamlAction> actions
public string ClaimType
public IList`1<SamlAction> SamlActions
public SamlAccessDecision AccessDecision
public SamlEvidence Evidence
public string Resource
public bool IsReadOnly
public string get_ClaimType()
public void .ctor(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions)
public void .ctor(SamlSubject samlSubject, string resource, SamlAccessDecision accessDecision, IEnumerable`1<SamlAction> samlActions, SamlEvidence samlEvidence)
public IList`1<SamlAction> get_SamlActions()
public SamlAccessDecision get_AccessDecision()
public void set_AccessDecision(SamlAccessDecision value)
public SamlEvidence get_Evidence()
public void set_Evidence(SamlEvidence value)
public string get_Resource()
public void set_Resource(string value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
protected void AddClaimsToList(IList`1<Claim> claims)
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlCondition : object {
public bool IsReadOnly
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlConditions : object {
private DateTime not_before
private DateTime not_on_after
private bool is_readonly
private bool has_not_before
private bool has_not_on_after
private List`1<SamlCondition> conditions
public IList`1<SamlCondition> Conditions
public DateTime NotBefore
public DateTime NotOnOrAfter
public bool IsReadOnly
public void .ctor(DateTime notBefore, DateTime notOnOrAfter)
public void .ctor(DateTime notBefore, DateTime notOnOrAfter, IEnumerable`1<SamlCondition> conditions)
public IList`1<SamlCondition> get_Conditions()
public DateTime get_NotBefore()
public void set_NotBefore(DateTime value)
public DateTime get_NotOnOrAfter()
public void set_NotOnOrAfter(DateTime value)
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlConstants : object {
internal string DateFormat
public string Prefix
public string EmailName
public string EmailNamespace
public string HolderOfKey
public int MajorVersionValue
public int MinorVersionValue
public string Namespace
public string SenderVouches
public string UserName
public string UserNameNamespace
public string get_EmailName()
public string get_EmailNamespace()
public string get_HolderOfKey()
public int get_MajorVersionValue()
public int get_MinorVersionValue()
public string get_Namespace()
public string get_SenderVouches()
public string get_UserName()
public string get_UserNameNamespace()
}
public System.IdentityModel.Tokens.SamlDoNotCacheCondition : SamlCondition {
private bool is_readonly
public bool IsReadOnly
public bool get_IsReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlEvidence : object {
private bool is_readonly
private List`1<string> references
private List`1<SamlAssertion> assertions
public IList`1<string> AssertionIdReferences
public IList`1<SamlAssertion> Assertions
public bool IsReadOnly
public void .ctor(IEnumerable`1<string> assertionIdReferences)
public void .ctor(IEnumerable`1<SamlAssertion> assertions)
public void .ctor(IEnumerable`1<string> assertionIdReferences, IEnumerable`1<SamlAssertion> assertions)
public IList`1<string> get_AssertionIdReferences()
public IList`1<SamlAssertion> get_Assertions()
public bool get_IsReadOnly()
private void CheckReadOnly()
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlNameIdentifierClaimResource : object {
private string name
private string name_qualifier
private string format
public string Format
public string Name
public string NameQualifier
public void .ctor(string name, string nameQualifier, string format)
public string get_Format()
public string get_Name()
public string get_NameQualifier()
}
public System.IdentityModel.Tokens.SamlSecurityKeyIdentifierClause : SecurityKeyIdentifierClause {
public SamlAssertion Assertion
public void .ctor(SamlAssertion assertion)
public SamlAssertion get_Assertion()
}
public System.IdentityModel.Tokens.SamlSecurityToken : SecurityToken {
private SamlAssertion assertion
public SamlAssertion Assertion
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(SamlAssertion assertion)
public SamlAssertion get_Assertion()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
protected void Initialize(SamlAssertion assertion)
}
public System.IdentityModel.Tokens.SamlSecurityTokenHandler : SecurityTokenHandler {
public string Assertion
public string BearerConfirmationMethod
public string Namespace
public string UnspecifiedAuthenticationMethod
public X509CertificateValidator CertificateValidator
public SecurityTokenSerializer KeyInfoSerializer
public SamlSecurityTokenRequirement SamlSecurityTokenRequirement
public Type TokenType
public void .ctor(SamlSecurityTokenRequirement samlSecurityTokenRequirement)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public SecurityTokenSerializer get_KeyInfoSerializer()
public void set_KeyInfoSerializer(SecurityTokenSerializer value)
public SamlSecurityTokenRequirement get_SamlSecurityTokenRequirement()
public void set_SamlSecurityTokenRequirement(SamlSecurityTokenRequirement value)
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.SamlSecurityTokenRequirement : object {
public X509CertificateValidator CertificateValidator
public bool MapToWindows
public string NameClaimType
public string RoleClaimType
public void .ctor(XmlElement element)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public bool get_MapToWindows()
public void set_MapToWindows(bool value)
public string get_NameClaimType()
public void set_NameClaimType(string value)
public string get_RoleClaimType()
public void set_RoleClaimType(string value)
public bool ShouldEnforceAudienceRestriction(AudienceUriMode audienceUriMode, SecurityToken token)
public void ValidateAudienceRestriction(IList`1<Uri> allowedAudienceUris, IList`1<Uri> tokenAudiences)
}
public System.IdentityModel.Tokens.SamlSerializer : object {
public SamlAdvice LoadAdvice(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlAssertion LoadAssertion(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlAttribute LoadAttribute(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlCondition LoadCondition(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlConditions LoadConditions(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlStatement LoadStatement(XmlDictionaryReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public SamlSecurityToken ReadToken(XmlReader reader, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteToken(SamlSecurityToken token, XmlWriter writer, SecurityTokenSerializer keyInfoSerializer)
public void PopulateDictionary(IXmlDictionary dictionary)
}
public System.IdentityModel.Tokens.SamlStatement : object {
public bool IsReadOnly
public bool get_IsReadOnly()
public IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator)
public void MakeReadOnly()
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlSubject : object {
private bool is_readonly
private string name_format
private string name_qualifier
private string name
private SecurityKey crypto
private SecurityKeyIdentifier key_identifier
private List`1<string> confirmation_methods
private string confirmation_data
public string NameClaimType
public bool IsReadOnly
public string NameFormat
public string NameQualifier
public string Name
public IList`1<string> ConfirmationMethods
public string SubjectConfirmationData
public SecurityKey Crypto
public SecurityKeyIdentifier KeyIdentifier
public string get_NameClaimType()
public void .ctor(string nameFormat, string nameQualifier, string name)
public void .ctor(string nameFormat, string nameQualifier, string name, IEnumerable`1<string> confirmations, string confirmationData, SecurityKeyIdentifier securityKeyIdentifier)
public bool get_IsReadOnly()
public string get_NameFormat()
public void set_NameFormat(string value)
public string get_NameQualifier()
public void set_NameQualifier(string value)
public string get_Name()
public void set_Name(string value)
public IList`1<string> get_ConfirmationMethods()
public string get_SubjectConfirmationData()
public void set_SubjectConfirmationData(string value)
public SecurityKey get_Crypto()
public void set_Crypto(SecurityKey value)
public SecurityKeyIdentifier get_KeyIdentifier()
public void set_KeyIdentifier(SecurityKeyIdentifier value)
private void CheckReadOnly()
public void MakeReadOnly()
public ReadOnlyCollection`1<Claim> ExtractClaims()
public ClaimSet ExtractSubjectKeyClaimSet(SamlSecurityTokenAuthenticator samlAuthenticator)
public void ReadXml(XmlDictionaryReader reader, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer, SecurityTokenResolver outOfBandTokenResolver)
public void WriteXml(XmlDictionaryWriter writer, SamlSerializer samlSerializer, SecurityTokenSerializer keyInfoSerializer)
}
public System.IdentityModel.Tokens.SamlSubjectStatement : SamlStatement {
private bool is_readonly
private SamlSubject subject
public SamlSubject SamlSubject
public bool IsReadOnly
protected void .ctor(SamlSubject samlSubject)
public SamlSubject get_SamlSubject()
public void set_SamlSubject(SamlSubject value)
public bool get_IsReadOnly()
public IAuthorizationPolicy CreatePolicy(ClaimSet issuer, SamlSecurityTokenAuthenticator samlAuthenticator)
private void CheckReadOnly()
public void MakeReadOnly()
protected void AddClaimsToList(IList`1<Claim> claims)
protected void SetSubject(SamlSubject samlSubject)
}
public System.IdentityModel.Tokens.SecurityAlgorithms : object {
public string Aes128Encryption
public string Aes128KeyWrap
public string Aes192Encryption
public string Aes192KeyWrap
public string Aes256Encryption
public string Aes256KeyWrap
public string DesEncryption
public string DsaSha1Signature
public string ExclusiveC14n
public string ExclusiveC14nWithComments
public string HmacSha1Signature
public string Psha1KeyDerivation
public string Ripemd160Digest
public string RsaOaepKeyWrap
public string RsaSha1Signature
public string RsaV15KeyWrap
public string Sha1Digest
public string Sha256Digest
public string Sha512Digest
public string TripleDesEncryption
public string TripleDesKeyWrap
public string HmacSha256Signature
public string RsaSha256Signature
public string TlsSspiKeyWrap
public string WindowsSspiKeyWrap
public string Psha1KeyDerivationDec2005
public string StrTransform
}
public System.IdentityModel.Tokens.SecurityKey : object {
public int KeySize
internal AlgorithmSupportType GetAlgorithmSupportType(string algorithm)
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.SecurityKeyElement : SecurityKey {
public int KeySize
public void .ctor(SecurityKeyIdentifier securityKeyIdentifier, SecurityTokenResolver securityTokenResolver)
public void .ctor(SecurityKeyIdentifierClause securityKeyIdentifierClause, SecurityTokenResolver securityTokenResolver)
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.SecurityKeyIdentifier : object {
private List`1<SecurityKeyIdentifierClause> list
private bool is_readonly
public bool CanCreateKey
public int Count
public bool IsReadOnly
public SecurityKeyIdentifierClause Item
public void .ctor(SecurityKeyIdentifierClause[] clauses)
public bool get_CanCreateKey()
public int get_Count()
public bool get_IsReadOnly()
public SecurityKeyIdentifierClause get_Item(int index)
public void Add(SecurityKeyIdentifierClause clause)
public SecurityKey CreateKey()
public TClause Find()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public IEnumerator`1<SecurityKeyIdentifierClause> GetEnumerator()
public void MakeReadOnly()
public string ToString()
public bool TryFind(TClause& clause)
}
public System.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
private string clause_type
private Byte[] nonce
private int deriv_length
private string <Id>k__BackingField
public bool CanCreateKey
public string ClauseType
public int DerivationLength
public string Id
protected void .ctor(string clauseType)
protected void .ctor(string clauseType, Byte[] nonce, int length)
public bool get_CanCreateKey()
public string get_ClauseType()
public int get_DerivationLength()
public Byte[] GetDerivationNonce()
public string get_Id()
public void set_Id(string value)
public SecurityKey CreateKey()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.SecurityKeyIdentifierClauseSerializer : object {
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause)
}
public System.IdentityModel.Tokens.SecurityKeyType : Enum {
public int value__
public SecurityKeyType SymmetricKey
public SecurityKeyType AsymmetricKey
public SecurityKeyType BearerKey
}
public System.IdentityModel.Tokens.SecurityKeyUsage : Enum {
public int value__
public SecurityKeyUsage Exchange
public SecurityKeyUsage Signature
}
public System.IdentityModel.Tokens.SecurityToken : object {
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
public SecurityKey ResolveKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.IdentityModel.Tokens.SecurityTokenDescriptor : object {
private Dictionary`2<string, object> properties
private string <AppliesToAddress>k__BackingField
private SecurityKeyIdentifierClause <AttachedReference>k__BackingField
private AuthenticationInformation <AuthenticationInfo>k__BackingField
private EncryptingCredentials <EncryptingCredentials>k__BackingField
private Lifetime <Lifetime>k__BackingField
private ProofDescriptor <Proof>k__BackingField
private string <ReplyToAddress>k__BackingField
private SigningCredentials <SigningCredentials>k__BackingField
private ClaimsIdentity <Subject>k__BackingField
private SecurityToken <Token>k__BackingField
private string <TokenIssuerName>k__BackingField
private string <TokenType>k__BackingField
private SecurityKeyIdentifierClause <UnattachedReference>k__BackingField
public string AppliesToAddress
public SecurityKeyIdentifierClause AttachedReference
public AuthenticationInformation AuthenticationInfo
public EncryptingCredentials EncryptingCredentials
public Lifetime Lifetime
public ProofDescriptor Proof
public Dictionary`2<string, object> Properties
public string ReplyToAddress
public SigningCredentials SigningCredentials
public ClaimsIdentity Subject
public SecurityToken Token
public string TokenIssuerName
public string TokenType
public SecurityKeyIdentifierClause UnattachedReference
public string get_AppliesToAddress()
public void set_AppliesToAddress(string value)
public SecurityKeyIdentifierClause get_AttachedReference()
public void set_AttachedReference(SecurityKeyIdentifierClause value)
public AuthenticationInformation get_AuthenticationInfo()
public void set_AuthenticationInfo(AuthenticationInformation value)
public EncryptingCredentials get_EncryptingCredentials()
public void set_EncryptingCredentials(EncryptingCredentials value)
public Lifetime get_Lifetime()
public void set_Lifetime(Lifetime value)
public ProofDescriptor get_Proof()
public void set_Proof(ProofDescriptor value)
public Dictionary`2<string, object> get_Properties()
public string get_ReplyToAddress()
public void set_ReplyToAddress(string value)
public SigningCredentials get_SigningCredentials()
public void set_SigningCredentials(SigningCredentials value)
public ClaimsIdentity get_Subject()
public void set_Subject(ClaimsIdentity value)
public SecurityToken get_Token()
public void set_Token(SecurityToken value)
public string get_TokenIssuerName()
public void set_TokenIssuerName(string value)
public string get_TokenType()
public void set_TokenType(string value)
public SecurityKeyIdentifierClause get_UnattachedReference()
public void set_UnattachedReference(SecurityKeyIdentifierClause value)
public void AddAuthenticationClaims(string authType)
public void AddAuthenticationClaims(string authType, DateTime time)
public void ApplyTo(RequestSecurityTokenResponse response)
}
public System.IdentityModel.Tokens.SecurityTokenElement : object {
public XmlElement SecurityTokenXml
public void .ctor(SecurityToken securityToken)
public void .ctor(XmlElement securityTokenXml, SecurityTokenHandlerCollection securityTokenHandlers)
public XmlElement get_SecurityTokenXml()
public ReadOnlyCollection`1<ClaimsIdentity> GetIdentities()
public SecurityToken GetSecurityToken()
}
public System.IdentityModel.Tokens.SecurityTokenException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenExpiredException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenHandler : object {
private SecurityTokenHandlerConfiguration <Configuration>k__BackingField
private SecurityTokenHandlerCollection <ContainingCollection>k__BackingField
public bool CanValidateToken
public bool CanWriteToken
public SecurityTokenHandlerConfiguration Configuration
public SecurityTokenHandlerCollection ContainingCollection
public Type TokenType
public bool get_CanValidateToken()
public bool get_CanWriteToken()
public SecurityTokenHandlerConfiguration get_Configuration()
public void set_Configuration(SecurityTokenHandlerConfiguration value)
public SecurityTokenHandlerCollection get_ContainingCollection()
internal void set_ContainingCollection(SecurityTokenHandlerCollection value)
public Type get_TokenType()
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanReadToken(string tokenString)
public bool CanReadToken(XmlReader reader)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause)
public SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
protected void DetectReplayedToken(SecurityToken token)
public String[] GetTokenTypeIdentifiers()
public void LoadCustomConfiguration(XmlNodeList nodelist)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public SecurityToken ReadToken(string tokenString)
public SecurityToken ReadToken(XmlReader reader)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
protected void TraceTokenValidationFailure(SecurityToken token, string errorMessage)
protected void TraceTokenValidationSuccess(SecurityToken token)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause)
public string WriteToken(SecurityToken token)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SecurityTokenHandlerCollection : Collection`1<SecurityTokenHandler> {
private SecurityTokenHandlerConfiguration config
private IEnumerable`1<string> tokenTypeIdentifiers
private IEnumerable`1<Type> tokenTypes
public SecurityTokenHandlerConfiguration Configuration
public IEnumerable`1<string> TokenTypeIdentifiers
public IEnumerable`1<Type> TokenTypes
public SecurityTokenHandler Item
public SecurityTokenHandler Item
public SecurityTokenHandler Item
public SecurityTokenHandlerConfiguration get_Configuration()
public IEnumerable`1<string> get_TokenTypeIdentifiers()
public IEnumerable`1<Type> get_TokenTypes()
public SecurityTokenHandler get_Item(SecurityToken token)
public SecurityTokenHandler get_Item(string tokenTypeIdentifier)
public SecurityTokenHandler get_Item(Type tokenType)
public void .ctor(SecurityTokenHandlerConfiguration configuration)
public void .ctor(IEnumerable`1<SecurityTokenHandler> handlers)
public void .ctor(IEnumerable`1<SecurityTokenHandler> handlers, SecurityTokenHandlerConfiguration configuration)
public void AddOrReplace(SecurityTokenHandler handler)
public bool CanReadKeyIdentifierClause(XmlReader reader)
protected bool CanReadKeyIdentifierClauseCore(XmlReader reader)
public bool CanReadToken(string tokenString)
public bool CanReadToken(XmlReader reader)
public bool CanWriteToken(SecurityToken token)
protected void ClearItems()
public SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection()
public SecurityTokenHandlerCollection CreateDefaultSecurityTokenHandlerCollection(SecurityTokenHandlerConfiguration configuration)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
protected void InsertItem(int index, SecurityTokenHandler item)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
protected SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader)
public SecurityToken ReadToken(string tokenString)
public SecurityToken ReadToken(XmlReader reader)
protected void RemoveItem(int index)
protected void SetItem(int index, SecurityTokenHandler item)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
protected void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause)
public string WriteToken(SecurityToken token)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SecurityTokenHandlerCollectionManager : object {
public int Count
public SecurityTokenHandlerCollection Item
public IEnumerable`1<SecurityTokenHandlerCollection> SecurityTokenHandlerCollections
public string ServiceName
public void .ctor(string serviceName)
public int get_Count()
public SecurityTokenHandlerCollection get_Item(string usage)
public void set_Item(string usage, SecurityTokenHandlerCollection value)
public IEnumerable`1<SecurityTokenHandlerCollection> get_SecurityTokenHandlerCollections()
public string get_ServiceName()
public bool ContainsKey(string usage)
public SecurityTokenHandlerCollectionManager CreateDefaultSecurityTokenHandlerCollectionManager()
public SecurityTokenHandlerCollectionManager CreateEmptySecurityTokenHandlerCollectionManager()
}
public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration : object {
public X509CertificateValidationMode DefaultCertificateValidationMode
public X509CertificateValidator DefaultCertificateValidator
public bool DefaultDetectReplayedTokens
public IssuerNameRegistry DefaultIssuerNameRegistry
public SecurityTokenResolver DefaultIssuerTokenResolver
public TimeSpan DefaultMaxClockSkew
public X509RevocationMode DefaultRevocationMode
public bool DefaultSaveBootstrapContext
public TimeSpan DefaultTokenReplayCacheExpirationPeriod
public StoreLocation DefaultTrustedStoreLocation
private AudienceRestriction <AudienceRestriction>k__BackingField
private IdentityModelCaches <Caches>k__BackingField
private X509CertificateValidationMode <CertificateValidationMode>k__BackingField
private X509CertificateValidator <CertificateValidator>k__BackingField
private bool <DetectReplayedTokens>k__BackingField
private IssuerNameRegistry <IssuerNameRegistry>k__BackingField
private SecurityTokenResolver <IssuerTokenResolver>k__BackingField
private TimeSpan <MaxClockSkew>k__BackingField
private X509RevocationMode <RevocationMode>k__BackingField
private bool <SaveBootstrapContext>k__BackingField
private SecurityTokenResolver <ServiceTokenResolver>k__BackingField
private TimeSpan <TokenReplayCacheExpirationPeriod>k__BackingField
private StoreLocation <TrustedStoreLocation>k__BackingField
public AudienceRestriction AudienceRestriction
public IdentityModelCaches Caches
public X509CertificateValidationMode CertificateValidationMode
public X509CertificateValidator CertificateValidator
public bool DetectReplayedTokens
public IssuerNameRegistry IssuerNameRegistry
public SecurityTokenResolver IssuerTokenResolver
public TimeSpan MaxClockSkew
public X509RevocationMode RevocationMode
public bool SaveBootstrapContext
public SecurityTokenResolver ServiceTokenResolver
public TimeSpan TokenReplayCacheExpirationPeriod
public StoreLocation TrustedStoreLocation
public AudienceRestriction get_AudienceRestriction()
public void set_AudienceRestriction(AudienceRestriction value)
public IdentityModelCaches get_Caches()
public void set_Caches(IdentityModelCaches value)
public X509CertificateValidationMode get_CertificateValidationMode()
public void set_CertificateValidationMode(X509CertificateValidationMode value)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public bool get_DetectReplayedTokens()
public void set_DetectReplayedTokens(bool value)
public IssuerNameRegistry get_IssuerNameRegistry()
public void set_IssuerNameRegistry(IssuerNameRegistry value)
public SecurityTokenResolver get_IssuerTokenResolver()
public void set_IssuerTokenResolver(SecurityTokenResolver value)
public TimeSpan get_MaxClockSkew()
public void set_MaxClockSkew(TimeSpan value)
public X509RevocationMode get_RevocationMode()
public void set_RevocationMode(X509RevocationMode value)
public bool get_SaveBootstrapContext()
public void set_SaveBootstrapContext(bool value)
public SecurityTokenResolver get_ServiceTokenResolver()
public void set_ServiceTokenResolver(SecurityTokenResolver value)
public TimeSpan get_TokenReplayCacheExpirationPeriod()
public void set_TokenReplayCacheExpirationPeriod(TimeSpan value)
public StoreLocation get_TrustedStoreLocation()
public void set_TrustedStoreLocation(StoreLocation value)
}
public System.IdentityModel.Tokens.SecurityTokenNotYetValidException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenReplayDetectedException : SecurityTokenValidationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SecurityTokenTypes : object {
public string Kerberos
public string Rsa
public string Saml
public string UserName
public string X509Certificate
public string get_Kerberos()
public string get_Rsa()
public string get_Saml()
public string get_UserName()
public string get_X509Certificate()
}
public System.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SessionSecurityToken : SecurityToken {
private ReadOnlyCollection`1<SecurityKey> securityKeys
private DateTime validFrom
private DateTime validTo
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField
private string <Context>k__BackingField
private UniqueId <ContextId>k__BackingField
private string <EndpointId>k__BackingField
private bool <IsPersistent>k__BackingField
private bool <IsReferenceMode>k__BackingField
private DateTime <KeyEffectiveTime>k__BackingField
private DateTime <KeyExpirationTime>k__BackingField
private UniqueId <KeyGeneration>k__BackingField
private Uri <SecureConversationVersion>k__BackingField
public ClaimsPrincipal ClaimsPrincipal
public string Context
public UniqueId ContextId
public string EndpointId
public string Id
public bool IsPersistent
public bool IsReferenceMode
public DateTime KeyEffectiveTime
public DateTime KeyExpirationTime
public UniqueId KeyGeneration
public Uri SecureConversationVersion
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public DateTime ValidFrom
public DateTime ValidTo
public ClaimsPrincipal get_ClaimsPrincipal()
private void set_ClaimsPrincipal(ClaimsPrincipal value)
public string get_Context()
private void set_Context(string value)
public UniqueId get_ContextId()
private void set_ContextId(UniqueId value)
public string get_EndpointId()
private void set_EndpointId(string value)
public string get_Id()
public bool get_IsPersistent()
public void set_IsPersistent(bool value)
public bool get_IsReferenceMode()
public void set_IsReferenceMode(bool value)
public DateTime get_KeyEffectiveTime()
private void set_KeyEffectiveTime(DateTime value)
public DateTime get_KeyExpirationTime()
private void set_KeyExpirationTime(DateTime value)
public UniqueId get_KeyGeneration()
private void set_KeyGeneration(UniqueId value)
public Uri get_SecureConversationVersion()
private void set_SecureConversationVersion(Uri value)
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public void .ctor(ClaimsPrincipal claimsPrincipal)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context)
public void .ctor(ClaimsPrincipal claimsPrincipal, TimeSpan lifetime)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo)
public void .ctor(ClaimsPrincipal claimsPrincipal, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, TimeSpan lifetime, SymmetricSecurityKey key)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, DateTime validFrom, TimeSpan lifetime, SymmetricSecurityKey key)
public void .ctor(ClaimsPrincipal claimsPrincipal, UniqueId contextId, string context, string endpointId, Nullable`1<DateTime> validFrom, Nullable`1<DateTime> validTo, SymmetricSecurityKey key)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.IdentityModel.Tokens.SessionSecurityTokenCache : object {
public void AddOrUpdate(SessionSecurityTokenCacheKey key, SessionSecurityToken value, DateTime expiryTime)
public SessionSecurityToken Get(SessionSecurityTokenCacheKey key)
public IEnumerable`1<SessionSecurityToken> GetAll(string endpointId, UniqueId contextId)
public void LoadCustomConfiguration(XmlNodeList nodelist)
public void Remove(SessionSecurityTokenCacheKey key)
public void RemoveAll(string endpointId)
public void RemoveAll(string endpointId, UniqueId contextId)
}
public System.IdentityModel.Tokens.SessionSecurityTokenCacheKey : object {
private UniqueId <ContextId>k__BackingField
private string <EndpointId>k__BackingField
private bool <IgnoreKeyGeneration>k__BackingField
private UniqueId <KeyGeneration>k__BackingField
public UniqueId ContextId
public string EndpointId
public bool IgnoreKeyGeneration
public UniqueId KeyGeneration
public bool op_Inequality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second)
public bool op_Equality(SessionSecurityTokenCacheKey first, SessionSecurityTokenCacheKey second)
public UniqueId get_ContextId()
private void set_ContextId(UniqueId value)
public string get_EndpointId()
private void set_EndpointId(string value)
public bool get_IgnoreKeyGeneration()
public void set_IgnoreKeyGeneration(bool value)
public UniqueId get_KeyGeneration()
private void set_KeyGeneration(UniqueId value)
public void .ctor(string endpointId, UniqueId contextId, UniqueId keyGeneration)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.IdentityModel.Tokens.SessionSecurityTokenHandler : SecurityTokenHandler {
public ReadOnlyCollection`1<CookieTransform> DefaultCookieTransforms
public TimeSpan DefaultLifetime
private bool canValidateToken
private bool canWriteToken
private string cookieElementName
private string cookieNamespace
private Type tokenType
private TimeSpan <TokenLifetime>k__BackingField
private ReadOnlyCollection`1<CookieTransform> <Transforms>k__BackingField
public bool CanValidateToken
public bool CanWriteToken
public string CookieElementName
public string CookieNamespace
public TimeSpan DefaultTokenLifetime
public TimeSpan TokenLifetime
public Type TokenType
public ReadOnlyCollection`1<CookieTransform> Transforms
public bool get_CanValidateToken()
public bool get_CanWriteToken()
public string get_CookieElementName()
public string get_CookieNamespace()
public TimeSpan get_DefaultTokenLifetime()
public TimeSpan get_TokenLifetime()
public void set_TokenLifetime(TimeSpan value)
public Type get_TokenType()
public ReadOnlyCollection`1<CookieTransform> get_Transforms()
private void set_Transforms(ReadOnlyCollection`1<CookieTransform> value)
public void .ctor(ReadOnlyCollection`1<CookieTransform> transforms)
public void .ctor(ReadOnlyCollection`1<CookieTransform> transforms, TimeSpan tokenLifetime)
protected Byte[] ApplyTransforms(Byte[] cookie, bool outbound)
public bool CanReadToken(XmlReader reader)
public SessionSecurityToken CreateSessionSecurityToken(ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo)
public SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor)
public String[] GetTokenTypeIdentifiers()
public void LoadCustomConfiguration(XmlNodeList customConfigElements)
public SecurityToken ReadToken(XmlReader reader)
public SecurityToken ReadToken(Byte[] token, SecurityTokenResolver tokenResolver)
public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver)
protected void SetTransforms(IEnumerable`1<CookieTransform> transforms)
protected void ValidateSession(SessionSecurityToken securityToken)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SecurityToken token)
public ReadOnlyCollection`1<ClaimsIdentity> ValidateToken(SessionSecurityToken token, string endpointId)
public Byte[] WriteToken(SessionSecurityToken sessionToken)
public void WriteToken(XmlWriter writer, SecurityToken token)
}
public System.IdentityModel.Tokens.SigningCredentials : object {
private SecurityKey key
private string sig_alg
private string dig_alg
private SecurityKeyIdentifier identifier
public string DigestAlgorithm
public string SignatureAlgorithm
public SecurityKey SigningKey
public SecurityKeyIdentifier SigningKeyIdentifier
public void .ctor(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm)
public void .ctor(SecurityKey signingKey, string signatureAlgorithm, string digestAlgorithm, SecurityKeyIdentifier signingKeyIdentifier)
public string get_DigestAlgorithm()
public string get_SignatureAlgorithm()
public SecurityKey get_SigningKey()
public SecurityKeyIdentifier get_SigningKeyIdentifier()
}
public System.IdentityModel.Tokens.SymmetricProofDescriptor : ProofDescriptor {
public SecurityKeyIdentifier KeyIdentifier
public void .ctor(Byte[] key, EncryptingCredentials targetWrappingCredentials)
public void .ctor(EncryptingCredentials targetWrappingCredentials)
public void .ctor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials)
public void .ctor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials)
public void .ctor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, Byte[] sourceEntropy)
public void .ctor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, Byte[] sourceEntropy, string encryptWith)
public void .ctor(int keySizeInBits, EncryptingCredentials targetWrappingCredentials, EncryptingCredentials requestorWrappingCredentials, string encryptWith)
public SecurityKeyIdentifier get_KeyIdentifier()
public void ApplyTo(RequestSecurityTokenResponse response)
public Byte[] GetKeyBytes()
}
public System.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
public Byte[] GenerateDerivedKey(string algorithm, Byte[] label, Byte[] nonce, int derivedKeyLength, int offset)
public Byte[] GetSymmetricKey()
public KeyedHashAlgorithm GetKeyedHashAlgorithm(string algorithm)
public SymmetricAlgorithm GetSymmetricAlgorithm(string algorithm)
public ICryptoTransform GetDecryptionTransform(string algorithm, Byte[] iv)
public ICryptoTransform GetEncryptionTransform(string algorithm, Byte[] iv)
public int GetIVSize(string algorithm)
}
public System.IdentityModel.Tokens.TokenReplayCache : object {
public void AddOrUpdate(string key, SecurityToken securityToken, DateTime expirationTime)
public bool Contains(string key)
public SecurityToken Get(string key)
public void LoadCustomConfiguration(XmlNodeList nodelist)
public void Remove(string key)
}
public System.IdentityModel.Tokens.UserNameSecurityToken : SecurityToken {
private DateTime from
private string username
private string password
private string id
public string UserName
public string Password
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(string userName, string password)
public void .ctor(string userName, string password, string id)
public string get_UserName()
public string get_Password()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
}
public System.IdentityModel.Tokens.UserNameSecurityTokenHandler : SecurityTokenHandler {
public bool RetainPassword
public Type TokenType
public bool get_RetainPassword()
public void set_RetainPassword(bool value)
public Type get_TokenType()
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.WindowsSecurityToken : SecurityToken {
private WindowsIdentity identity
private string id
public WindowsIdentity WindowsIdentity
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public string AuthenticationType
public void .ctor(WindowsIdentity windowsIdentity)
public void .ctor(WindowsIdentity windowsIdentity, string id)
public WindowsIdentity get_WindowsIdentity()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public void .ctor(WindowsIdentity windowsIdentity, string id, string authenticationType)
public string get_AuthenticationType()
public void Dispose()
}
public System.IdentityModel.Tokens.X509AsymmetricSecurityKey : AsymmetricSecurityKey {
private X509Certificate2 cert
public int KeySize
public void .ctor(X509Certificate2 certificate)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(string algorithm, bool privateKey)
public HashAlgorithm GetHashAlgorithmForSignature(string algorithm)
public AsymmetricSignatureDeformatter GetSignatureDeformatter(string algorithm)
public AsymmetricSignatureFormatter GetSignatureFormatter(string algorithm)
public bool HasPrivateKey()
public int get_KeySize()
public Byte[] DecryptKey(string algorithm, Byte[] keyData)
public Byte[] EncryptKey(string algorithm, Byte[] keyData)
public bool IsAsymmetricAlgorithm(string algorithm)
public bool IsSupportedAlgorithm(string algorithm)
public bool IsSymmetricAlgorithm(string algorithm)
}
public System.IdentityModel.Tokens.X509CertificateStoreTokenResolver : SecurityTokenResolver {
public StoreLocation StoreLocation
public string StoreName
public void .ctor(StoreName storeName, StoreLocation storeLocation)
public void .ctor(string storeName, StoreLocation storeLocation)
public StoreLocation get_StoreLocation()
public string get_StoreName()
protected bool TryResolveSecurityKeyCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityKey& key)
protected bool TryResolveTokenCore(SecurityKeyIdentifier keyIdentifier, SecurityToken& token)
protected bool TryResolveTokenCore(SecurityKeyIdentifierClause keyIdentifierClause, SecurityToken& token)
}
public System.IdentityModel.Tokens.X509DataSecurityKeyIdentifierClauseSerializer : SecurityKeyIdentifierClauseSerializer {
public bool CanReadKeyIdentifierClause(XmlReader reader)
public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause securityKeyIdentifierClause)
public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader)
public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause securityKeyIdentifierClause)
}
public System.IdentityModel.Tokens.X509EncryptingCredentials : EncryptingCredentials {
public X509Certificate2 Certificate
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski, string keyWrappingAlgorithm)
public void .ctor(X509Certificate2 certificate, string keyWrappingAlgorithm)
public X509Certificate2 get_Certificate()
}
public System.IdentityModel.Tokens.X509IssuerSerialKeyIdentifierClause : SecurityKeyIdentifierClause {
private string name
private string serial
public string IssuerName
public string IssuerSerialNumber
private Byte[] FromBinHex(string s)
private byte DecodeHex(char c)
private string ToDecimalString(string hexString)
public void .ctor(X509Certificate2 certificate)
public void .ctor(string issuerName, string issuerSerialNumber)
public string get_IssuerName()
public string get_IssuerSerialNumber()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(X509Certificate2 certificate)
public bool Matches(string issuerName, string issuerSerialNumber)
public string ToString()
}
public System.IdentityModel.Tokens.X509NTAuthChainTrustValidator : X509CertificateValidator {
public void .ctor(bool useMachineContext, X509ChainPolicy chainPolicy)
public void Validate(X509Certificate2 certificate)
}
public System.IdentityModel.Tokens.X509RawDataKeyIdentifierClause : BinaryKeyIdentifierClause {
private X509Certificate2 cert
public bool CanCreateKey
public void .ctor(Byte[] certificateRawData)
public void .ctor(X509Certificate2 certificate)
public bool get_CanCreateKey()
public SecurityKey CreateKey()
public Byte[] GetX509RawData()
public bool Matches(X509Certificate2 certificate)
public string ToString()
}
public System.IdentityModel.Tokens.X509SecurityToken : SecurityToken {
private X509Certificate2 cert
private string id
private ReadOnlyCollection`1<SecurityKey> keys
public X509Certificate2 Certificate
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, string id)
public X509Certificate2 get_Certificate()
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public void Dispose()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
protected void ThrowIfDisposed()
}
public System.IdentityModel.Tokens.X509SecurityTokenHandler : SecurityTokenHandler {
public X509CertificateValidator CertificateValidator
public bool MapToWindows
public Type TokenType
public bool WriteXmlDSigDefinedClauseTypes
public X509NTAuthChainTrustValidator X509NTAuthChainTrustValidator
public void .ctor(bool mapToWindows)
public void .ctor(bool mapToWindows, X509CertificateValidator certificateValidator)
public void .ctor(X509CertificateValidator certificateValidator)
public X509CertificateValidator get_CertificateValidator()
public void set_CertificateValidator(X509CertificateValidator value)
public bool get_MapToWindows()
public void set_MapToWindows(bool value)
public Type get_TokenType()
public bool get_WriteXmlDSigDefinedClauseTypes()
public void set_WriteXmlDSigDefinedClauseTypes(bool value)
public X509NTAuthChainTrustValidator get_X509NTAuthChainTrustValidator()
public void set_X509NTAuthChainTrustValidator(X509NTAuthChainTrustValidator value)
public String[] GetTokenTypeIdentifiers()
}
public System.IdentityModel.Tokens.X509SigningCredentials : SigningCredentials {
private X509Certificate2 <Certificate>k__BackingField
public X509Certificate2 Certificate
public X509Certificate2 get_Certificate()
private void set_Certificate(X509Certificate2 value)
public void .ctor(X509Certificate2 certificate)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski)
public void .ctor(X509Certificate2 certificate, string signatureAlgorithm, string digestAlgorithm)
public void .ctor(X509Certificate2 certificate, SecurityKeyIdentifier ski, string signatureAlgorithm, string digestAlgorithm)
private SecurityKeyIdentifier GetSecurityKeyIdentifier(X509Certificate2 certificate)
}
public System.IdentityModel.Tokens.X509SubjectKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] ski)
public bool CanCreateFrom(X509Certificate2 certificate)
public Byte[] GetX509SubjectKeyIdentifier()
public bool Matches(X509Certificate2 certificate)
public string ToString()
public bool TryCreateFrom(X509Certificate2 certificate, X509SubjectKeyIdentifierClause& keyIdentifierClause)
}
public System.IdentityModel.Tokens.X509ThumbprintKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] thumbprint)
public void .ctor(X509Certificate2 certificate)
public Byte[] GetX509Thumbprint()
public bool Matches(X509Certificate2 certificate)
public string ToString()
}
public System.IdentityModel.Tokens.X509WindowsSecurityToken : X509SecurityToken {
private WindowsIdentity identity
public WindowsIdentity WindowsIdentity
public string AuthenticationType
public void .ctor(X509Certificate2 certificate, WindowsIdentity windowsIdentity)
public void .ctor(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string id)
public WindowsIdentity get_WindowsIdentity()
public void .ctor(X509Certificate2 certificate, WindowsIdentity windowsIdentity, string authenticationType, string id)
public string get_AuthenticationType()
}
public System.IdentityModel.TypedAsyncResult`1 : AsyncResult {
public T Result
public void .ctor(AsyncCallback callback, object state)
public void .ctor(object state)
public T get_Result()
public void Complete(T result, bool completedSynchronously)
public void Complete(T result, bool completedSynchronously, Exception exception)
public T End(IAsyncResult result)
}
public System.IdentityModel.UnsupportedTokenTypeBadRequestException : BadRequestException {
public string TokenType
public void .ctor(string tokenType)
public void .ctor(string message, Exception exception)
public string get_TokenType()
public void set_TokenType(string value)
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
public System.Security.Claims.AuthenticationInformation : object {
private Collection`1<AuthenticationContext> authorizationContexts
private string <Address>k__BackingField
private string <DnsName>k__BackingField
private Nullable`1<DateTime> <NotOnOrAfter>k__BackingField
private string <Session>k__BackingField
public string Address
public Collection`1<AuthenticationContext> AuthorizationContexts
public string DnsName
public Nullable`1<DateTime> NotOnOrAfter
public string Session
public string get_Address()
public void set_Address(string value)
public Collection`1<AuthenticationContext> get_AuthorizationContexts()
public string get_DnsName()
public void set_DnsName(string value)
public Nullable`1<DateTime> get_NotOnOrAfter()
public void set_NotOnOrAfter(Nullable`1<DateTime> value)
public string get_Session()
public void set_Session(string value)
}
public System.Security.Claims.AuthenticationTypes : object {
public string Basic
public string Federation
public string Kerberos
public string Negotiate
public string Password
public string Signature
public string Windows
public string X509
}
public System.Security.Claims.AuthorizationContext : object {
public Collection`1<Claim> Action
public ClaimsPrincipal Principal
public Collection`1<Claim> Resource
public void .ctor(ClaimsPrincipal principal, Collection`1<Claim> resource, Collection`1<Claim> action)
public void .ctor(ClaimsPrincipal principal, string resource, string action)
public Collection`1<Claim> get_Action()
public ClaimsPrincipal get_Principal()
public Collection`1<Claim> get_Resource()
}
public System.Security.Claims.ClaimProperties : object {
public string Namespace
public string SamlAttributeDisplayName
public string SamlAttributeNameFormat
public string SamlNameIdentifierFormat
public string SamlNameIdentifierNameQualifier
public string SamlNameIdentifierSPNameQualifier
public string SamlNameIdentifierSPProvidedId
}
public System.Security.Claims.ClaimsAuthenticationManager : object {
public ClaimsPrincipal Authenticate(string resourceName, ClaimsPrincipal incomingPrincipal)
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.Security.Claims.ClaimsAuthorizationManager : object {
public bool CheckAccess(AuthorizationContext context)
public void LoadCustomConfiguration(XmlNodeList nodelist)
}
public System.ServiceModel.Security.BinarySecretKeyIdentifierClause : BinaryKeyIdentifierClause {
public bool CanCreateKey
public void .ctor(Byte[] key)
public void .ctor(Byte[] key, bool cloneBuffer)
public void .ctor(Byte[] key, bool cloneBuffer, Byte[] derivationNonce, int derivationLength)
public bool get_CanCreateKey()
public Byte[] GetKeyBytes()
public SecurityKey CreateKey()
public bool Matches(SecurityKeyIdentifierClause clause)
}
public System.ServiceModel.Security.KeyNameIdentifierClause : SecurityKeyIdentifierClause {
private string key_name
public string KeyName
public void .ctor(string keyName)
public string get_KeyName()
public bool Matches(SecurityKeyIdentifierClause clause)
public bool Matches(string keyName)
public string ToString()
}
public System.ServiceModel.Security.SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
private UniqueId context
private UniqueId generation
public UniqueId ContextId
public UniqueId Generation
public void .ctor(UniqueId contextId)
public void .ctor(UniqueId contextId, UniqueId generation)
public void .ctor(UniqueId contextId, UniqueId generation, Byte[] derivationNonce, int derivationLength)
public UniqueId get_ContextId()
public UniqueId get_Generation()
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
public bool Matches(UniqueId contextId, UniqueId generation)
public string ToString()
}
public System.ServiceModel.Security.Tokens.BinarySecretSecurityToken : SecurityToken {
private ReadOnlyCollection`1<SecurityKey> keys
private string id
private Byte[] key
private bool allow_crypto
private DateTime valid_from
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public int KeySize
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
private void .ctor(string id, bool allowCrypto)
public void .ctor(Byte[] key)
public void .ctor(string id, Byte[] key)
protected void .ctor(string id, Byte[] key, bool allowCrypto)
public void .ctor(int keySizeInBits)
public void .ctor(string id, int keySizeInBits)
protected void .ctor(string id, int keySizeInBits, bool allowCrypto)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public int get_KeySize()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public Byte[] GetKeyBytes()
}
internal System.ServiceModel.Security.Tokens.InternalEncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
public void .ctor(Byte[] hash)
public bool Matches(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.ServiceModel.Security.Tokens.WrappedKeySecurityToken : SecurityToken {
private string id
private Byte[] raw_key
private Byte[] wrapped_key
private string wrap_alg
private SecurityToken wrap_token
private SecurityKeyIdentifier wrap_token_ref
private DateTime valid_from
private ReadOnlyCollection`1<SecurityKey> keys
private ReferenceList reference_list
private Byte[] keyhash
internal Byte[] RawKey
internal ReferenceList ReferenceList
public DateTime ValidFrom
public DateTime ValidTo
public string Id
public ReadOnlyCollection`1<SecurityKey> SecurityKeys
public string WrappingAlgorithm
public SecurityToken WrappingToken
public SecurityKeyIdentifier WrappingTokenReference
public void .ctor(string id, Byte[] keyToWrap, string wrappingAlgorithm, SecurityToken wrappingToken, SecurityKeyIdentifier wrappingTokenReference)
internal Byte[] get_RawKey()
internal ReferenceList get_ReferenceList()
internal void set_ReferenceList(ReferenceList value)
public DateTime get_ValidFrom()
public DateTime get_ValidTo()
public string get_Id()
public ReadOnlyCollection`1<SecurityKey> get_SecurityKeys()
public string get_WrappingAlgorithm()
public SecurityToken get_WrappingToken()
public SecurityKeyIdentifier get_WrappingTokenReference()
public Byte[] GetWrappedKey()
internal void SetWrappedKey(Byte[] value)
public bool CanCreateKeyIdentifierClause()
public T CreateKeyIdentifierClause()
public bool MatchesKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause)
}
public System.ServiceModel.Security.X509CertificateValidationMode : Enum {
public int value__
public X509CertificateValidationMode None
public X509CertificateValidationMode PeerTrust
public X509CertificateValidationMode ChainTrust
public X509CertificateValidationMode PeerOrChainTrust
public X509CertificateValidationMode Custom
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
