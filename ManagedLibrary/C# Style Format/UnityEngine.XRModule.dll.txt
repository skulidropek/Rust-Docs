[FlagsAttribute]
internal enum UnityEngine.XR.AvailableTrackingData : Enum {
    public int value__;
    public static AvailableTrackingData None;
    public static AvailableTrackingData PositionAvailable;
    public static AvailableTrackingData RotationAvailable;
    public static AvailableTrackingData VelocityAvailable;
    public static AvailableTrackingData AngularVelocityAvailable;
    public static AvailableTrackingData AccelerationAvailable;
    public static AvailableTrackingData AngularAccelerationAvailable;
}
[RequiredByNativeCodeAttribute]
[NativeConditionalAttribute("ENABLE_VR")]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[NativeHeaderAttribute("XRScriptingClasses.h")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
[StaticAccessorAttribute("XRInputDevices::Get()", "0")]
public class UnityEngine.XR.Bone : ValueType {
    private ulong m_DeviceId;
    private UInt32 m_FeatureIndex;
    internal ulong deviceId { get; }
    internal UInt32 featureIndex { get; }
    internal ulong get_deviceId();
    internal UInt32 get_featureIndex();
    public bool TryGetPosition(Vector3& position);
    private static bool Bone_TryGetPosition(Bone bone, Vector3& position);
    public bool TryGetRotation(Quaternion& rotation);
    private static bool Bone_TryGetRotation(Bone bone, Quaternion& rotation);
    public bool TryGetParentBone(Bone& parentBone);
    private static bool Bone_TryGetParentBone(Bone bone, Bone& parentBone);
    public bool TryGetChildBones(List`1<Bone> childBones);
    private static bool Bone_TryGetChildBones(Bone bone, List`1<Bone> childBones);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Bone other);
    public virtual int GetHashCode();
    public static bool op_Equality(Bone a, Bone b);
    public static bool op_Inequality(Bone a, Bone b);
    private static bool Bone_TryGetPosition_Injected(Bone& bone, Vector3& position);
    private static bool Bone_TryGetRotation_Injected(Bone& bone, Quaternion& rotation);
    private static bool Bone_TryGetParentBone_Injected(Bone& bone, Bone& parentBone);
    private static bool Bone_TryGetChildBones_Injected(Bone& bone, List`1<Bone> childBones);
}
public static class UnityEngine.XR.CommonUsages : object {
    public static InputFeatureUsage`1<bool> isTracked;
    public static InputFeatureUsage`1<bool> primaryButton;
    public static InputFeatureUsage`1<bool> primaryTouch;
    public static InputFeatureUsage`1<bool> secondaryButton;
    public static InputFeatureUsage`1<bool> secondaryTouch;
    public static InputFeatureUsage`1<bool> gripButton;
    public static InputFeatureUsage`1<bool> triggerButton;
    public static InputFeatureUsage`1<bool> menuButton;
    public static InputFeatureUsage`1<bool> primary2DAxisClick;
    public static InputFeatureUsage`1<bool> primary2DAxisTouch;
    public static InputFeatureUsage`1<bool> secondary2DAxisClick;
    public static InputFeatureUsage`1<bool> secondary2DAxisTouch;
    public static InputFeatureUsage`1<bool> userPresence;
    public static InputFeatureUsage`1<InputTrackingState> trackingState;
    public static InputFeatureUsage`1<float> batteryLevel;
    public static InputFeatureUsage`1<float> trigger;
    public static InputFeatureUsage`1<float> grip;
    public static InputFeatureUsage`1<Vector2> primary2DAxis;
    public static InputFeatureUsage`1<Vector2> secondary2DAxis;
    public static InputFeatureUsage`1<Vector3> devicePosition;
    public static InputFeatureUsage`1<Vector3> leftEyePosition;
    public static InputFeatureUsage`1<Vector3> rightEyePosition;
    public static InputFeatureUsage`1<Vector3> centerEyePosition;
    public static InputFeatureUsage`1<Vector3> colorCameraPosition;
    public static InputFeatureUsage`1<Vector3> deviceVelocity;
    public static InputFeatureUsage`1<Vector3> deviceAngularVelocity;
    public static InputFeatureUsage`1<Vector3> leftEyeVelocity;
    public static InputFeatureUsage`1<Vector3> leftEyeAngularVelocity;
    public static InputFeatureUsage`1<Vector3> rightEyeVelocity;
    public static InputFeatureUsage`1<Vector3> rightEyeAngularVelocity;
    public static InputFeatureUsage`1<Vector3> centerEyeVelocity;
    public static InputFeatureUsage`1<Vector3> centerEyeAngularVelocity;
    public static InputFeatureUsage`1<Vector3> colorCameraVelocity;
    public static InputFeatureUsage`1<Vector3> colorCameraAngularVelocity;
    public static InputFeatureUsage`1<Vector3> deviceAcceleration;
    public static InputFeatureUsage`1<Vector3> deviceAngularAcceleration;
    public static InputFeatureUsage`1<Vector3> leftEyeAcceleration;
    public static InputFeatureUsage`1<Vector3> leftEyeAngularAcceleration;
    public static InputFeatureUsage`1<Vector3> rightEyeAcceleration;
    public static InputFeatureUsage`1<Vector3> rightEyeAngularAcceleration;
    public static InputFeatureUsage`1<Vector3> centerEyeAcceleration;
    public static InputFeatureUsage`1<Vector3> centerEyeAngularAcceleration;
    public static InputFeatureUsage`1<Vector3> colorCameraAcceleration;
    public static InputFeatureUsage`1<Vector3> colorCameraAngularAcceleration;
    public static InputFeatureUsage`1<Quaternion> deviceRotation;
    public static InputFeatureUsage`1<Quaternion> leftEyeRotation;
    public static InputFeatureUsage`1<Quaternion> rightEyeRotation;
    public static InputFeatureUsage`1<Quaternion> centerEyeRotation;
    public static InputFeatureUsage`1<Quaternion> colorCameraRotation;
    public static InputFeatureUsage`1<Hand> handData;
    public static InputFeatureUsage`1<Eyes> eyesData;
    [ObsoleteAttribute("CommonUsages.dPad is not used by any XR platform and will be removed.")]
public static InputFeatureUsage`1<Vector2> dPad;
    [ObsoleteAttribute("CommonUsages.indexFinger is not used by any XR platform and will be removed.")]
public static InputFeatureUsage`1<float> indexFinger;
    [ObsoleteAttribute("CommonUsages.MiddleFinger is not used by any XR platform and will be removed.")]
public static InputFeatureUsage`1<float> middleFinger;
    [ObsoleteAttribute("CommonUsages.RingFinger is not used by any XR platform and will be removed.")]
public static InputFeatureUsage`1<float> ringFinger;
    [ObsoleteAttribute("CommonUsages.PinkyFinger is not used by any XR platform and will be removed.")]
public static InputFeatureUsage`1<float> pinkyFinger;
    [ObsoleteAttribute("CommonUsages.thumbrest is Oculus only, and is being moved to their package. Please use OculusUsages.thumbrest. These will still function until removed.")]
public static InputFeatureUsage`1<bool> thumbrest;
    [ObsoleteAttribute("CommonUsages.indexTouch is Oculus only, and is being moved to their package.  Please use OculusUsages.indexTouch. These will still function until removed.")]
public static InputFeatureUsage`1<float> indexTouch;
    [ObsoleteAttribute("CommonUsages.thumbTouch is Oculus only, and is being moved to their package.  Please use OculusUsages.thumbTouch. These will still function until removed.")]
public static InputFeatureUsage`1<float> thumbTouch;
    private static CommonUsages();
}
internal enum UnityEngine.XR.ConnectionChangeType : Enum {
    public UInt32 value__;
    public static ConnectionChangeType Connected;
    public static ConnectionChangeType Disconnected;
    public static ConnectionChangeType ConfigChange;
}
[NativeConditionalAttribute("ENABLE_VR")]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[NativeHeaderAttribute("XRScriptingClasses.h")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
[StaticAccessorAttribute("XRInputDevices::Get()", "0")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.XR.Eyes : ValueType {
    private ulong m_DeviceId;
    private UInt32 m_FeatureIndex;
    internal ulong deviceId { get; }
    internal UInt32 featureIndex { get; }
    internal ulong get_deviceId();
    internal UInt32 get_featureIndex();
    public bool TryGetLeftEyePosition(Vector3& position);
    public bool TryGetRightEyePosition(Vector3& position);
    public bool TryGetLeftEyeRotation(Quaternion& rotation);
    public bool TryGetRightEyeRotation(Quaternion& rotation);
    private static bool Eyes_TryGetEyePosition(Eyes eyes, EyeSide chirality, Vector3& position);
    private static bool Eyes_TryGetEyeRotation(Eyes eyes, EyeSide chirality, Quaternion& rotation);
    public bool TryGetFixationPoint(Vector3& fixationPoint);
    private static bool Eyes_TryGetFixationPoint(Eyes eyes, Vector3& fixationPoint);
    public bool TryGetLeftEyeOpenAmount(Single& openAmount);
    public bool TryGetRightEyeOpenAmount(Single& openAmount);
    private static bool Eyes_TryGetEyeOpenAmount(Eyes eyes, EyeSide chirality, Single& openAmount);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Eyes other);
    public virtual int GetHashCode();
    public static bool op_Equality(Eyes a, Eyes b);
    public static bool op_Inequality(Eyes a, Eyes b);
    private static bool Eyes_TryGetEyePosition_Injected(Eyes& eyes, EyeSide chirality, Vector3& position);
    private static bool Eyes_TryGetEyeRotation_Injected(Eyes& eyes, EyeSide chirality, Quaternion& rotation);
    private static bool Eyes_TryGetFixationPoint_Injected(Eyes& eyes, Vector3& fixationPoint);
    private static bool Eyes_TryGetEyeOpenAmount_Injected(Eyes& eyes, EyeSide chirality, Single& openAmount);
}
internal enum UnityEngine.XR.EyeSide : Enum {
    public int value__;
    public static EyeSide Left;
    public static EyeSide Right;
}
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[RequiredByNativeCodeAttribute]
[StaticAccessorAttribute("XRInputDevices::Get()", "0")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
[NativeHeaderAttribute("XRScriptingClasses.h")]
[NativeConditionalAttribute("ENABLE_VR")]
public class UnityEngine.XR.Hand : ValueType {
    private ulong m_DeviceId;
    private UInt32 m_FeatureIndex;
    internal ulong deviceId { get; }
    internal UInt32 featureIndex { get; }
    internal ulong get_deviceId();
    internal UInt32 get_featureIndex();
    public bool TryGetRootBone(Bone& boneOut);
    private static bool Hand_TryGetRootBone(Hand hand, Bone& boneOut);
    public bool TryGetFingerBones(HandFinger finger, List`1<Bone> bonesOut);
    private static bool Hand_TryGetFingerBonesAsList(Hand hand, HandFinger finger, List`1<Bone> bonesOut);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Hand other);
    public virtual int GetHashCode();
    public static bool op_Equality(Hand a, Hand b);
    public static bool op_Inequality(Hand a, Hand b);
    private static bool Hand_TryGetRootBone_Injected(Hand& hand, Bone& boneOut);
    private static bool Hand_TryGetFingerBonesAsList_Injected(Hand& hand, HandFinger finger, List`1<Bone> bonesOut);
}
public enum UnityEngine.XR.HandFinger : Enum {
    public int value__;
    public static HandFinger Thumb;
    public static HandFinger Index;
    public static HandFinger Middle;
    public static HandFinger Ring;
    public static HandFinger Pinky;
}
[NativeConditionalAttribute("ENABLE_VR")]
public class UnityEngine.XR.HapticCapabilities : ValueType {
    private UInt32 m_NumChannels;
    private bool m_SupportsImpulse;
    private bool m_SupportsBuffer;
    private UInt32 m_BufferFrequencyHz;
    private UInt32 m_BufferMaxSize;
    private UInt32 m_BufferOptimalSize;
    public UInt32 numChannels { get; internal set; }
    public bool supportsImpulse { get; internal set; }
    public bool supportsBuffer { get; internal set; }
    public UInt32 bufferFrequencyHz { get; internal set; }
    public UInt32 bufferMaxSize { get; internal set; }
    public UInt32 bufferOptimalSize { get; internal set; }
    public UInt32 get_numChannels();
    internal void set_numChannels(UInt32 value);
    public bool get_supportsImpulse();
    internal void set_supportsImpulse(bool value);
    public bool get_supportsBuffer();
    internal void set_supportsBuffer(bool value);
    public UInt32 get_bufferFrequencyHz();
    internal void set_bufferFrequencyHz(UInt32 value);
    public UInt32 get_bufferMaxSize();
    internal void set_bufferMaxSize(UInt32 value);
    public UInt32 get_bufferOptimalSize();
    internal void set_bufferOptimalSize(UInt32 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HapticCapabilities other);
    public virtual int GetHashCode();
    public static bool op_Equality(HapticCapabilities a, HapticCapabilities b);
    public static bool op_Inequality(HapticCapabilities a, HapticCapabilities b);
}
internal static class UnityEngine.XR.HashCodeHelper : object {
    private static int k_HashCodeMultiplier;
    public static int Combine(int hash1, int hash2);
    public static int Combine(int hash1, int hash2, int hash3);
    public static int Combine(int hash1, int hash2, int hash3, int hash4);
    public static int Combine(int hash1, int hash2, int hash3, int hash4, int hash5);
    public static int Combine(int hash1, int hash2, int hash3, int hash4, int hash5, int hash6);
    public static int Combine(int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7);
    public static int Combine(int hash1, int hash2, int hash3, int hash4, int hash5, int hash6, int hash7, int hash8);
}
[NativeConditionalAttribute("ENABLE_VR")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.InputDevice : ValueType {
    private static List`1<XRInputSubsystem> s_InputSubsystemCache;
    private ulong m_DeviceId;
    private bool m_Initialized;
    private ulong deviceId { get; }
    public XRInputSubsystem subsystem { get; }
    public bool isValid { get; }
    public string name { get; }
    [ObsoleteAttribute("This API has been marked as deprecated and will be removed in future versions. Please use InputDevice.characteristics instead.")]
public InputDeviceRole role { get; }
    public string manufacturer { get; }
    public string serialNumber { get; }
    public InputDeviceCharacteristics characteristics { get; }
    internal InputDevice(ulong deviceId);
    private ulong get_deviceId();
    public XRInputSubsystem get_subsystem();
    public bool get_isValid();
    public string get_name();
    public InputDeviceRole get_role();
    public string get_manufacturer();
    public string get_serialNumber();
    public InputDeviceCharacteristics get_characteristics();
    private bool IsValidId();
    public bool SendHapticImpulse(UInt32 channel, float amplitude, float duration);
    public bool SendHapticBuffer(UInt32 channel, Byte[] buffer);
    public bool TryGetHapticCapabilities(HapticCapabilities& capabilities);
    public void StopHaptics();
    public bool TryGetFeatureUsages(List`1<InputFeatureUsage> featureUsages);
    public bool TryGetFeatureValue(InputFeatureUsage`1<bool> usage, Boolean& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<UInt32> usage, UInt32& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<float> usage, Single& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Vector2> usage, Vector2& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Vector3> usage, Vector3& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Quaternion> usage, Quaternion& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Hand> usage, Hand& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Bone> usage, Bone& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Eyes> usage, Eyes& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Byte[]> usage, Byte[] value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<InputTrackingState> usage, InputTrackingState& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<bool> usage, DateTime time, Boolean& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<UInt32> usage, DateTime time, UInt32& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<float> usage, DateTime time, Single& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Vector2> usage, DateTime time, Vector2& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Vector3> usage, DateTime time, Vector3& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<Quaternion> usage, DateTime time, Quaternion& value);
    public bool TryGetFeatureValue(InputFeatureUsage`1<InputTrackingState> usage, DateTime time, InputTrackingState& value);
    private bool CheckValidAndSetDefault(T& value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InputDevice other);
    public virtual int GetHashCode();
    public static bool op_Equality(InputDevice a, InputDevice b);
    public static bool op_Inequality(InputDevice a, InputDevice b);
}
[FlagsAttribute]
public enum UnityEngine.XR.InputDeviceCharacteristics : Enum {
    public UInt32 value__;
    public static InputDeviceCharacteristics None;
    public static InputDeviceCharacteristics HeadMounted;
    public static InputDeviceCharacteristics Camera;
    public static InputDeviceCharacteristics HeldInHand;
    public static InputDeviceCharacteristics HandTracking;
    public static InputDeviceCharacteristics EyeTracking;
    public static InputDeviceCharacteristics TrackedDevice;
    public static InputDeviceCharacteristics Controller;
    public static InputDeviceCharacteristics TrackingReference;
    public static InputDeviceCharacteristics Left;
    public static InputDeviceCharacteristics Right;
    public static InputDeviceCharacteristics Simulated6DOF;
}
public enum UnityEngine.XR.InputDeviceRole : Enum {
    public UInt32 value__;
    public static InputDeviceRole Unknown;
    public static InputDeviceRole Generic;
    public static InputDeviceRole LeftHanded;
    public static InputDeviceRole RightHanded;
    public static InputDeviceRole GameController;
    public static InputDeviceRole TrackingReference;
    public static InputDeviceRole HardwareTracker;
    public static InputDeviceRole LegacyController;
}
[StaticAccessorAttribute("XRInputDevices::Get()", "0")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
[NativeConditionalAttribute("ENABLE_VR")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.InputDevices : object {
    private static List`1<InputDevice> s_InputDeviceList;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<InputDevice> deviceConnected;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`1<InputDevice> deviceDisconnected;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<InputDevice> deviceConfigChanged;
    public static InputDevice GetDeviceAtXRNode(XRNode node);
    public static void GetDevicesAtXRNode(XRNode node, List`1<InputDevice> inputDevices);
    public static void GetDevices(List`1<InputDevice> inputDevices);
    [ObsoleteAttribute("This API has been marked as deprecated and will be removed in future versions. Please use InputDevices.GetDevicesWithCharacteristics instead.")]
public static void GetDevicesWithRole(InputDeviceRole role, List`1<InputDevice> inputDevices);
    public static void GetDevicesWithCharacteristics(InputDeviceCharacteristics desiredCharacteristics, List`1<InputDevice> inputDevices);
    [CompilerGeneratedAttribute]
public static void add_deviceConnected(Action`1<InputDevice> value);
    [CompilerGeneratedAttribute]
public static void remove_deviceConnected(Action`1<InputDevice> value);
    [CompilerGeneratedAttribute]
public static void add_deviceDisconnected(Action`1<InputDevice> value);
    [CompilerGeneratedAttribute]
public static void remove_deviceDisconnected(Action`1<InputDevice> value);
    [CompilerGeneratedAttribute]
public static void add_deviceConfigChanged(Action`1<InputDevice> value);
    [CompilerGeneratedAttribute]
public static void remove_deviceConfigChanged(Action`1<InputDevice> value);
    [RequiredByNativeCodeAttribute]
private static void InvokeConnectionEvent(ulong deviceId, ConnectionChangeType change);
    private static void GetDevices_Internal(List`1<InputDevice> inputDevices);
    internal static bool SendHapticImpulse(ulong deviceId, UInt32 channel, float amplitude, float duration);
    internal static bool SendHapticBuffer(ulong deviceId, UInt32 channel, Byte[] buffer);
    internal static bool TryGetHapticCapabilities(ulong deviceId, HapticCapabilities& capabilities);
    internal static void StopHaptics(ulong deviceId);
    internal static bool TryGetFeatureUsages(ulong deviceId, List`1<InputFeatureUsage> featureUsages);
    internal static bool TryGetFeatureValue_bool(ulong deviceId, string usage, Boolean& value);
    internal static bool TryGetFeatureValue_UInt32(ulong deviceId, string usage, UInt32& value);
    internal static bool TryGetFeatureValue_float(ulong deviceId, string usage, Single& value);
    internal static bool TryGetFeatureValue_Vector2f(ulong deviceId, string usage, Vector2& value);
    internal static bool TryGetFeatureValue_Vector3f(ulong deviceId, string usage, Vector3& value);
    internal static bool TryGetFeatureValue_Quaternionf(ulong deviceId, string usage, Quaternion& value);
    internal static bool TryGetFeatureValue_Custom(ulong deviceId, string usage, Byte[] value);
    internal static bool TryGetFeatureValueAtTime_bool(ulong deviceId, string usage, long time, Boolean& value);
    internal static bool TryGetFeatureValueAtTime_UInt32(ulong deviceId, string usage, long time, UInt32& value);
    internal static bool TryGetFeatureValueAtTime_float(ulong deviceId, string usage, long time, Single& value);
    internal static bool TryGetFeatureValueAtTime_Vector2f(ulong deviceId, string usage, long time, Vector2& value);
    internal static bool TryGetFeatureValueAtTime_Vector3f(ulong deviceId, string usage, long time, Vector3& value);
    internal static bool TryGetFeatureValueAtTime_Quaternionf(ulong deviceId, string usage, long time, Quaternion& value);
    internal static bool TryGetFeatureValue_XRHand(ulong deviceId, string usage, Hand& value);
    internal static bool TryGetFeatureValue_XRBone(ulong deviceId, string usage, Bone& value);
    internal static bool TryGetFeatureValue_XREyes(ulong deviceId, string usage, Eyes& value);
    internal static bool IsDeviceValid(ulong deviceId);
    internal static string GetDeviceName(ulong deviceId);
    internal static string GetDeviceManufacturer(ulong deviceId);
    internal static string GetDeviceSerialNumber(ulong deviceId);
    internal static InputDeviceCharacteristics GetDeviceCharacteristics(ulong deviceId);
    internal static InputDeviceRole GetDeviceRole(ulong deviceId);
}
internal enum UnityEngine.XR.InputFeatureType : Enum {
    public UInt32 value__;
    public static InputFeatureType Custom;
    public static InputFeatureType Binary;
    public static InputFeatureType DiscreteStates;
    public static InputFeatureType Axis1D;
    public static InputFeatureType Axis2D;
    public static InputFeatureType Axis3D;
    public static InputFeatureType Rotation;
    public static InputFeatureType Hand;
    public static InputFeatureType Bone;
    public static InputFeatureType Eyes;
    public static InputFeatureType kUnityXRInputFeatureTypeInvalid;
}
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputDevices.h")]
[RequiredByNativeCodeAttribute]
[NativeConditionalAttribute("ENABLE_VR")]
public class UnityEngine.XR.InputFeatureUsage : ValueType {
    internal string m_Name;
    [NativeNameAttribute("m_FeatureType")]
internal InputFeatureType m_InternalType;
    public string name { get; internal set; }
    internal InputFeatureType internalType { get; internal set; }
    public Type type { get; }
    internal InputFeatureUsage(string name, InputFeatureType type);
    public string get_name();
    internal void set_name(string value);
    internal InputFeatureType get_internalType();
    internal void set_internalType(InputFeatureType value);
    public Type get_type();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InputFeatureUsage other);
    public virtual int GetHashCode();
    public static bool op_Equality(InputFeatureUsage a, InputFeatureUsage b);
    public static bool op_Inequality(InputFeatureUsage a, InputFeatureUsage b);
    public InputFeatureUsage`1<T> As();
}
public class UnityEngine.XR.InputFeatureUsage`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private string <name>k__BackingField;
    public string name { get; public set; }
    private Type usageType { get; }
    public InputFeatureUsage`1(string usageName);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
public void set_name(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InputFeatureUsage`1<T> other);
    public virtual int GetHashCode();
    public static bool op_Equality(InputFeatureUsage`1<T> a, InputFeatureUsage`1<T> b);
    public static bool op_Inequality(InputFeatureUsage`1<T> a, InputFeatureUsage`1<T> b);
    private Type get_usageType();
    public static InputFeatureUsage op_Explicit(InputFeatureUsage`1<T> self);
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputTrackingFacade.h")]
[NativeConditionalAttribute("ENABLE_VR")]
[StaticAccessorAttribute("XRInputTrackingFacade::Get()", "0")]
public static class UnityEngine.XR.InputTracking : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<XRNodeState> trackingAcquired;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<XRNodeState> trackingLost;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private static Action`1<XRNodeState> nodeAdded;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private static Action`1<XRNodeState> nodeRemoved;
    [NativeConditionalAttribute("ENABLE_VR")]
[ObsoleteAttribute("This API is obsolete, and should no longer be used. Please use the TrackedPoseDriver in the Legacy Input Helpers package for controlling a camera in XR.")]
public static bool disablePositionalTracking { get; public set; }
    [CompilerGeneratedAttribute]
public static void add_trackingAcquired(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void remove_trackingAcquired(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void add_trackingLost(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void remove_trackingLost(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void add_nodeAdded(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void remove_nodeAdded(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void add_nodeRemoved(Action`1<XRNodeState> value);
    [CompilerGeneratedAttribute]
public static void remove_nodeRemoved(Action`1<XRNodeState> value);
    [RequiredByNativeCodeAttribute]
private static void InvokeTrackingEvent(TrackingStateEventType eventType, XRNode nodeType, long uniqueID, bool tracked);
    [NativeConditionalAttribute("ENABLE_VR", "Vector3f::zero")]
[ObsoleteAttribute("This API is obsolete, and should no longer be used. Please use InputDevice.TryGetFeatureValue with the CommonUsages.devicePosition usage instead.")]
public static Vector3 GetLocalPosition(XRNode node);
    [ObsoleteAttribute("This API is obsolete, and should no longer be used. Please use InputDevice.TryGetFeatureValue with the CommonUsages.deviceRotation usage instead.")]
[NativeConditionalAttribute("ENABLE_VR", "Quaternionf::identity()")]
public static Quaternion GetLocalRotation(XRNode node);
    [ObsoleteAttribute("This API is obsolete, and should no longer be used. Please use XRInputSubsystem.TryRecenter() instead.")]
[NativeConditionalAttribute("ENABLE_VR")]
public static void Recenter();
    [ObsoleteAttribute("This API is obsolete, and should no longer be used. Please use InputDevice.name with the device associated with that tracking data instead.")]
[NativeConditionalAttribute("ENABLE_VR")]
public static string GetNodeName(ulong uniqueId);
    public static void GetNodeStates(List`1<XRNodeState> nodeStates);
    [NativeConditionalAttribute("ENABLE_VR")]
private static void GetNodeStates_Internal(List`1<XRNodeState> nodeStates);
    [NativeNameAttribute("GetPositionalTrackingDisabled")]
public static bool get_disablePositionalTracking();
    [NativeNameAttribute("SetPositionalTrackingDisabled")]
public static void set_disablePositionalTracking(bool value);
    [NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputTracking.h")]
[StaticAccessorAttribute("XRInputTracking::Get()", "0")]
internal static ulong GetDeviceIdAtXRNode(XRNode node);
    [StaticAccessorAttribute("XRInputTracking::Get()", "0")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Input/Public/XRInputTracking.h")]
internal static void GetDeviceIdsAtXRNode_Internal(XRNode node, List`1<ulong> deviceIds);
    private static void GetLocalPosition_Injected(XRNode node, Vector3& ret);
    private static void GetLocalRotation_Injected(XRNode node, Quaternion& ret);
}
[FlagsAttribute]
public enum UnityEngine.XR.InputTrackingState : Enum {
    public UInt32 value__;
    public static InputTrackingState None;
    public static InputTrackingState Position;
    public static InputTrackingState Rotation;
    public static InputTrackingState Velocity;
    public static InputTrackingState AngularVelocity;
    public static InputTrackingState Acceleration;
    public static InputTrackingState AngularAcceleration;
    public static InputTrackingState All;
}
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
[UsedByNativeCodeAttribute]
public enum UnityEngine.XR.MeshChangeState : Enum {
    public int value__;
    public static MeshChangeState Added;
    public static MeshChangeState Updated;
    public static MeshChangeState Removed;
    public static MeshChangeState Unchanged;
}
[UsedByNativeCodeAttribute]
[FlagsAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
public enum UnityEngine.XR.MeshGenerationOptions : Enum {
    public int value__;
    public static MeshGenerationOptions None;
    public static MeshGenerationOptions ConsumeTransform;
}
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
[RequiredByNativeCodeAttribute]
public class UnityEngine.XR.MeshGenerationResult : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private MeshId <MeshId>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Mesh <Mesh>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private MeshCollider <MeshCollider>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MeshGenerationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MeshVertexAttributes <Attributes>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private ulong <Timestamp>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Quaternion <Rotation>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Vector3 <Scale>k__BackingField;
    public MeshId MeshId { get; }
    public Mesh Mesh { get; }
    public MeshCollider MeshCollider { get; }
    public MeshGenerationStatus Status { get; }
    public MeshVertexAttributes Attributes { get; }
    public ulong Timestamp { get; }
    public Vector3 Position { get; }
    public Quaternion Rotation { get; }
    public Vector3 Scale { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshId get_MeshId();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Mesh get_Mesh();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public MeshCollider get_MeshCollider();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshGenerationStatus get_Status();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshVertexAttributes get_Attributes();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ulong get_Timestamp();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Vector3 get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Quaternion get_Rotation();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Vector3 get_Scale();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MeshGenerationResult other);
    public static bool op_Equality(MeshGenerationResult lhs, MeshGenerationResult rhs);
    public static bool op_Inequality(MeshGenerationResult lhs, MeshGenerationResult rhs);
    public virtual int GetHashCode();
}
[RequiredByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
public enum UnityEngine.XR.MeshGenerationStatus : Enum {
    public int value__;
    public static MeshGenerationStatus Success;
    public static MeshGenerationStatus InvalidMeshId;
    public static MeshGenerationStatus GenerationAlreadyInProgress;
    public static MeshGenerationStatus Canceled;
    public static MeshGenerationStatus UnknownError;
}
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.MeshId : ValueType {
    private static MeshId s_InvalidId;
    private ulong m_SubId1;
    private ulong m_SubId2;
    public static MeshId InvalidId { get; }
    private static MeshId();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MeshId other);
    public static bool op_Equality(MeshId id1, MeshId id2);
    public static bool op_Inequality(MeshId id1, MeshId id2);
    public static MeshId get_InvalidId();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
public class UnityEngine.XR.MeshInfo : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MeshId <MeshId>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private MeshChangeState <ChangeState>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private int <PriorityHint>k__BackingField;
    public MeshId MeshId { get; public set; }
    public MeshChangeState ChangeState { get; public set; }
    public int PriorityHint { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshId get_MeshId();
    [CompilerGeneratedAttribute]
public void set_MeshId(MeshId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MeshChangeState get_ChangeState();
    [CompilerGeneratedAttribute]
public void set_ChangeState(MeshChangeState value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_PriorityHint();
    [CompilerGeneratedAttribute]
public void set_PriorityHint(int value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MeshInfo other);
    public static bool op_Equality(MeshInfo lhs, MeshInfo rhs);
    public static bool op_Inequality(MeshInfo lhs, MeshInfo rhs);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.MeshTransform : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MeshId <MeshId>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ulong <Timestamp>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Vector3 <Position>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Quaternion <Rotation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Vector3 <Scale>k__BackingField;
    public MeshId MeshId { get; }
    public ulong Timestamp { get; }
    public Vector3 Position { get; }
    public Quaternion Rotation { get; }
    public Vector3 Scale { get; }
    public MeshTransform(MeshId& meshId, ulong timestamp, Vector3& position, Quaternion& rotation, Vector3& scale);
    [CompilerGeneratedAttribute]
public MeshId get_MeshId();
    [CompilerGeneratedAttribute]
public ulong get_Timestamp();
    [CompilerGeneratedAttribute]
public Vector3 get_Position();
    [CompilerGeneratedAttribute]
public Quaternion get_Rotation();
    [CompilerGeneratedAttribute]
public Vector3 get_Scale();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MeshTransform other);
    public static bool op_Equality(MeshTransform lhs, MeshTransform rhs);
    public static bool op_Inequality(MeshTransform lhs, MeshTransform rhs);
    public virtual int GetHashCode();
}
[UsedByNativeCodeAttribute]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshBindings.h")]
[FlagsAttribute]
public enum UnityEngine.XR.MeshVertexAttributes : Enum {
    public int value__;
    public static MeshVertexAttributes None;
    public static MeshVertexAttributes Normals;
    public static MeshVertexAttributes Tangents;
    public static MeshVertexAttributes UVs;
    public static MeshVertexAttributes Colors;
}
public static class UnityEngine.XR.Provider.XRStats : object {
    public static bool TryGetStat(IntegratedSubsystem xrSubsystem, string tag, Single& value);
    [NativeHeaderAttribute("Modules/XR/Stats/XRStats.h")]
[NativeConditionalAttribute("ENABLE_XR")]
[StaticAccessorAttribute("XRStats::Get()", "0")]
[NativeMethodAttribute("TryGetStatByName_Internal")]
private static bool TryGetStat_Internal(IntPtr ptr, string tag, Single& value);
}
internal static class UnityEngine.XR.TimeConverter : object {
    private static DateTime s_Epoch;
    public static DateTime now { get; }
    private static TimeConverter();
    public static DateTime get_now();
    public static long LocalDateTimeToUnixTimeMilliseconds(DateTime date);
    public static DateTime UnixTimeMillisecondsToLocalDateTime(long unixTimeInMilliseconds);
}
public enum UnityEngine.XR.TrackingOriginModeFlags : Enum {
    public int value__;
    public static TrackingOriginModeFlags Unknown;
    public static TrackingOriginModeFlags Device;
    public static TrackingOriginModeFlags Floor;
    public static TrackingOriginModeFlags TrackingReference;
    public static TrackingOriginModeFlags Unbounded;
}
[NativeConditionalAttribute("ENABLE_XR")]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[UsedByNativeCodeAttribute]
[NativeTypeAttribute]
public class UnityEngine.XR.XRDisplaySubsystem : IntegratedSubsystem`1<XRDisplaySubsystemDescriptor> {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Action`1<bool> displayFocusChanged;
    private HDROutputSettings m_HDROutputSettings;
    [ObsoleteAttribute("singlePassRenderingDisabled{get;set;} is deprecated. Use textureLayout and supportedTextureLayouts instead.", "False")]
public bool singlePassRenderingDisabled { get; public set; }
    public bool displayOpaque { get; }
    public bool contentProtectionEnabled { get; public set; }
    public float scaleOfAllViewports { get; public set; }
    public float scaleOfAllRenderTargets { get; public set; }
    public float zNear { get; public set; }
    public float zFar { get; public set; }
    public bool sRGB { get; public set; }
    public float occlusionMaskScale { get; public set; }
    public float foveatedRenderingLevel { get; public set; }
    public FoveatedRenderingFlags foveatedRenderingFlags { get; public set; }
    public TextureLayout textureLayout { get; public set; }
    public TextureLayout supportedTextureLayouts { get; }
    public ReprojectionMode reprojectionMode { get; public set; }
    public bool disableLegacyRenderer { get; public set; }
    public HDROutputSettings hdrOutputSettings { get; }
    [CompilerGeneratedAttribute]
public void add_displayFocusChanged(Action`1<bool> value);
    [CompilerGeneratedAttribute]
public void remove_displayFocusChanged(Action`1<bool> value);
    [RequiredByNativeCodeAttribute]
private void InvokeDisplayFocusChanged(bool focus);
    public bool get_singlePassRenderingDisabled();
    public void set_singlePassRenderingDisabled(bool value);
    public bool get_displayOpaque();
    public bool get_contentProtectionEnabled();
    public void set_contentProtectionEnabled(bool value);
    public float get_scaleOfAllViewports();
    public void set_scaleOfAllViewports(float value);
    public float get_scaleOfAllRenderTargets();
    public void set_scaleOfAllRenderTargets(float value);
    public float get_zNear();
    public void set_zNear(float value);
    public float get_zFar();
    public void set_zFar(float value);
    public bool get_sRGB();
    public void set_sRGB(bool value);
    public float get_occlusionMaskScale();
    public void set_occlusionMaskScale(float value);
    public float get_foveatedRenderingLevel();
    public void set_foveatedRenderingLevel(float value);
    public FoveatedRenderingFlags get_foveatedRenderingFlags();
    public void set_foveatedRenderingFlags(FoveatedRenderingFlags value);
    public void MarkTransformLateLatched(Transform transform, LateLatchNode nodeType);
    public TextureLayout get_textureLayout();
    public void set_textureLayout(TextureLayout value);
    public TextureLayout get_supportedTextureLayouts();
    public ReprojectionMode get_reprojectionMode();
    public void set_reprojectionMode(ReprojectionMode value);
    public void SetFocusPlane(Vector3 point, Vector3 normal, Vector3 velocity);
    public void SetMSAALevel(int level);
    public bool get_disableLegacyRenderer();
    public void set_disableLegacyRenderer(bool value);
    public int GetRenderPassCount();
    public void GetRenderPass(int renderPassIndex, XRRenderPass& renderPass);
    [NativeMethodAttribute("TryGetRenderPass")]
private bool Internal_TryGetRenderPass(int renderPassIndex, XRRenderPass& renderPass);
    public void EndRecordingIfLateLatched(Camera camera);
    [NativeMethodAttribute("TryEndRecordingIfLateLatched")]
private bool Internal_TryEndRecordingIfLateLatched(Camera camera);
    public void BeginRecordingIfLateLatched(Camera camera);
    [NativeMethodAttribute("TryBeginRecordingIfLateLatched")]
private bool Internal_TryBeginRecordingIfLateLatched(Camera camera);
    public void GetCullingParameters(Camera camera, int cullingPassIndex, ScriptableCullingParameters& scriptableCullingParameters);
    [NativeHeaderAttribute("Runtime/Graphics/ScriptableRenderLoop/ScriptableCulling.h")]
[NativeMethodAttribute("TryGetCullingParams")]
private bool Internal_TryGetCullingParams(Camera camera, int cullingPassIndex, ScriptableCullingParameters& scriptableCullingParameters);
    [NativeMethodAttribute("TryGetAppGPUTimeLastFrame")]
public bool TryGetAppGPUTimeLastFrame(Single& gpuTimeLastFrame);
    [NativeMethodAttribute("TryGetCompositorGPUTimeLastFrame")]
public bool TryGetCompositorGPUTimeLastFrame(Single& gpuTimeLastFrameCompositor);
    [NativeMethodAttribute("TryGetDroppedFrameCount")]
public bool TryGetDroppedFrameCount(Int32& droppedFrameCount);
    [NativeMethodAttribute("TryGetFramePresentCount")]
public bool TryGetFramePresentCount(Int32& framePresentCount);
    [NativeMethodAttribute("TryGetDisplayRefreshRate")]
public bool TryGetDisplayRefreshRate(Single& displayRefreshRate);
    [NativeMethodAttribute("TryGetMotionToPhoton")]
public bool TryGetMotionToPhoton(Single& motionToPhoton);
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute]
public RenderTexture GetRenderTexture(UInt32 unityXrRenderTextureId);
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute]
public RenderTexture GetRenderTextureForRenderPass(int renderPass);
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute]
public RenderTexture GetSharedDepthTextureForRenderPass(int renderPass);
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute]
public int GetPreferredMirrorBlitMode();
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_XR")]
public void SetPreferredMirrorBlitMode(int blitMode);
    [ObsoleteAttribute("GetMirrorViewBlitDesc(RenderTexture, out XRMirrorViewBlitDesc) is deprecated. Use GetMirrorViewBlitDesc(RenderTexture, out XRMirrorViewBlitDesc, int) instead.", "False")]
public bool GetMirrorViewBlitDesc(RenderTexture mirrorRt, XRMirrorViewBlitDesc& outDesc);
    [NativeMethodAttribute]
[NativeConditionalAttribute("ENABLE_XR")]
public bool GetMirrorViewBlitDesc(RenderTexture mirrorRt, XRMirrorViewBlitDesc& outDesc, int mode);
    [ObsoleteAttribute("AddGraphicsThreadMirrorViewBlit(CommandBuffer, bool) is deprecated. Use AddGraphicsThreadMirrorViewBlit(CommandBuffer, bool, int) instead.", "False")]
public bool AddGraphicsThreadMirrorViewBlit(CommandBuffer cmd, bool allowGraphicsStateInvalidate);
    [NativeMethodAttribute]
[NativeHeaderAttribute("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
[NativeConditionalAttribute("ENABLE_XR")]
public bool AddGraphicsThreadMirrorViewBlit(CommandBuffer cmd, bool allowGraphicsStateInvalidate, int mode);
    public HDROutputSettings get_hdrOutputSettings();
    private void SetFocusPlane_Injected(Vector3& point, Vector3& normal, Vector3& velocity);
}
[NativeTypeAttribute]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.XRDisplaySubsystemDescriptor : IntegratedSubsystemDescriptor`1<XRDisplaySubsystem> {
    [NativeConditionalAttribute("ENABLE_XR")]
public bool disablesLegacyVr { get; }
    [NativeConditionalAttribute("ENABLE_XR")]
public bool enableBackBufferMSAA { get; }
    public bool get_disablesLegacyVr();
    public bool get_enableBackBufferMSAA();
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute("TryGetAvailableMirrorModeCount")]
public int GetAvailableMirrorBlitModeCount();
    [NativeConditionalAttribute("ENABLE_XR")]
[NativeMethodAttribute("TryGetMirrorModeByIndex")]
public void GetMirrorBlitModeByIndex(int index, XRMirrorViewBlitModeDesc& mode);
}
[NativeTypeAttribute]
[NativeConditionalAttribute("ENABLE_XR")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.XRInputSubsystem : IntegratedSubsystem`1<XRInputSubsystemDescriptor> {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
private Action`1<XRInputSubsystem> trackingOriginUpdated;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Action`1<XRInputSubsystem> boundaryChanged;
    private List`1<ulong> m_DeviceIdsCache;
    internal UInt32 GetIndex();
    public bool TryRecenter();
    public bool TryGetInputDevices(List`1<InputDevice> devices);
    public bool TrySetTrackingOriginMode(TrackingOriginModeFlags origin);
    public TrackingOriginModeFlags GetTrackingOriginMode();
    public TrackingOriginModeFlags GetSupportedTrackingOriginModes();
    public bool TryGetBoundaryPoints(List`1<Vector3> boundaryPoints);
    private bool TryGetBoundaryPoints_AsList(List`1<Vector3> boundaryPoints);
    [CompilerGeneratedAttribute]
public void add_trackingOriginUpdated(Action`1<XRInputSubsystem> value);
    [CompilerGeneratedAttribute]
public void remove_trackingOriginUpdated(Action`1<XRInputSubsystem> value);
    [CompilerGeneratedAttribute]
public void add_boundaryChanged(Action`1<XRInputSubsystem> value);
    [CompilerGeneratedAttribute]
public void remove_boundaryChanged(Action`1<XRInputSubsystem> value);
    [RequiredByNativeCodeAttribute]
private static void InvokeTrackingOriginUpdatedEvent(IntPtr internalPtr);
    [RequiredByNativeCodeAttribute]
private static void InvokeBoundaryChangedEvent(IntPtr internalPtr);
    internal void TryGetDeviceIds_AsList(List`1<ulong> deviceIds);
}
[UsedByNativeCodeAttribute]
[NativeTypeAttribute]
[NativeConditionalAttribute("ENABLE_XR")]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
public class UnityEngine.XR.XRInputSubsystemDescriptor : IntegratedSubsystemDescriptor`1<XRInputSubsystem> {
    [NativeConditionalAttribute("ENABLE_XR")]
public bool disablesLegacyInput { get; }
    public bool get_disablesLegacyInput();
}
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[NativeHeaderAttribute("Modules/XR/Subsystems/Meshing/XRMeshingSubsystem.h")]
[NativeConditionalAttribute("ENABLE_XR")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.XRMeshSubsystem : IntegratedSubsystem`1<XRMeshSubsystemDescriptor> {
    public float meshDensity { get; public set; }
    public bool TryGetMeshInfos(List`1<MeshInfo> meshInfosOut);
    private bool GetMeshInfosAsList(List`1<MeshInfo> meshInfos);
    private MeshInfo[] GetMeshInfosAsFixedArray();
    public void GenerateMeshAsync(MeshId meshId, Mesh mesh, MeshCollider meshCollider, MeshVertexAttributes attributes, Action`1<MeshGenerationResult> onMeshGenerationComplete);
    public void GenerateMeshAsync(MeshId meshId, Mesh mesh, MeshCollider meshCollider, MeshVertexAttributes attributes, Action`1<MeshGenerationResult> onMeshGenerationComplete, MeshGenerationOptions options);
    [RequiredByNativeCodeAttribute]
private void InvokeMeshReadyDelegate(MeshGenerationResult result, Action`1<MeshGenerationResult> onMeshGenerationComplete);
    public float get_meshDensity();
    public void set_meshDensity(float value);
    public bool SetBoundingVolume(Vector3 origin, Vector3 extents);
    public NativeArray`1<MeshTransform> GetUpdatedMeshTransforms(Allocator allocator);
    private IntPtr GetUpdatedMeshTransforms();
    private void GenerateMeshAsync_Injected(MeshId& meshId, Mesh mesh, MeshCollider meshCollider, MeshVertexAttributes attributes, Action`1<MeshGenerationResult> onMeshGenerationComplete, MeshGenerationOptions options);
    private bool SetBoundingVolume_Injected(Vector3& origin, Vector3& extents);
}
[NativeTypeAttribute]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.XRMeshSubsystemDescriptor : IntegratedSubsystemDescriptor`1<XRMeshSubsystem> {
}
public class UnityEngine.XR.XRMirrorViewBlitMode : ValueType {
    public static int Default;
    public static int LeftEye;
    public static int RightEye;
    public static int SideBySide;
    public static int SideBySideOcclusionMesh;
    public static int Distort;
    public static int None;
}
[NativeTypeAttribute]
[NativeHeaderAttribute("Modules/XR/XRPrefix.h")]
public class UnityEngine.XR.XRMirrorViewBlitModeDesc : ValueType {
    public int blitMode;
    public string blitModeDesc;
}
public enum UnityEngine.XR.XRNode : Enum {
    public int value__;
    public static XRNode LeftEye;
    public static XRNode RightEye;
    public static XRNode CenterEye;
    public static XRNode Head;
    public static XRNode LeftHand;
    public static XRNode RightHand;
    public static XRNode GameController;
    public static XRNode TrackingReference;
    public static XRNode HardwareTracker;
}
[UsedByNativeCodeAttribute]
public class UnityEngine.XR.XRNodeState : ValueType {
    private XRNode m_Type;
    private AvailableTrackingData m_AvailableFields;
    private Vector3 m_Position;
    private Quaternion m_Rotation;
    private Vector3 m_Velocity;
    private Vector3 m_AngularVelocity;
    private Vector3 m_Acceleration;
    private Vector3 m_AngularAcceleration;
    private int m_Tracked;
    private ulong m_UniqueID;
    public ulong uniqueID { get; public set; }
    public XRNode nodeType { get; public set; }
    public bool tracked { get; public set; }
    unknown Vector3 position {public set; }
    unknown Quaternion rotation {public set; }
    unknown Vector3 velocity {public set; }
    unknown Vector3 angularVelocity {public set; }
    unknown Vector3 acceleration {public set; }
    unknown Vector3 angularAcceleration {public set; }
    public ulong get_uniqueID();
    public void set_uniqueID(ulong value);
    public XRNode get_nodeType();
    public void set_nodeType(XRNode value);
    public bool get_tracked();
    public void set_tracked(bool value);
    public void set_position(Vector3 value);
    public void set_rotation(Quaternion value);
    public void set_velocity(Vector3 value);
    public void set_angularVelocity(Vector3 value);
    public void set_acceleration(Vector3 value);
    public void set_angularAcceleration(Vector3 value);
    public bool TryGetPosition(Vector3& position);
    public bool TryGetRotation(Quaternion& rotation);
    public bool TryGetVelocity(Vector3& velocity);
    public bool TryGetAngularVelocity(Vector3& angularVelocity);
    public bool TryGetAcceleration(Vector3& acceleration);
    public bool TryGetAngularAcceleration(Vector3& angularAcceleration);
    private bool TryGet(Vector3 inValue, AvailableTrackingData availabilityFlag, Vector3& outValue);
    private bool TryGet(Quaternion inValue, AvailableTrackingData availabilityFlag, Quaternion& outValue);
}
