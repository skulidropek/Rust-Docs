internal Consts : object {
public string MonoCorlibVersion
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public string FxVersion
public string FxFileVersion
public string EnvironmentVersion
public string VsVersion
public string VsFileVersion
private string PublicKeyToken
public string AssemblyI18N
public string AssemblyMicrosoft_JScript
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_2_0
public string AssemblySystemCore_3_5
public string AssemblySystem_Core
public string WindowsBase_3_0
public string AssemblyWindowsBase
public string AssemblyPresentationCore_3_5
public string AssemblyPresentationCore_4_0
public string AssemblyPresentationFramework_3_5
public string AssemblySystemServiceModel_3_0
}
internal Microsoft.Internal.Assumes : object {
internal void NotNull(T value)
internal void NotNull(T1 value1, T2 value2)
internal void NotNull(T1 value1, T2 value2, T3 value3)
internal void NotNullOrEmpty(string value)
internal void IsTrue(bool condition)
internal void IsTrue(bool condition, string message)
internal T NotReachable()
private Exception UncatchableException(string message)
}
internal Microsoft.Internal.AttributeServices : object {
public T[] GetAttributes(ICustomAttributeProvider attributeProvider)
public T[] GetAttributes(ICustomAttributeProvider attributeProvider, bool inherit)
public T GetFirstAttribute(ICustomAttributeProvider attributeProvider)
public T GetFirstAttribute(ICustomAttributeProvider attributeProvider, bool inherit)
public bool IsAttributeDefined(ICustomAttributeProvider attributeProvider)
public bool IsAttributeDefined(ICustomAttributeProvider attributeProvider, bool inherit)
}
internal Microsoft.Internal.Collections.CollectionServices : object {
private Type StringType
private Type IEnumerableType
private Type IEnumerableOfTType
private Type ICollectionOfTType
public ICollection`1<object> GetCollectionWrapper(Type itemType, object collectionObject)
public bool IsEnumerableOfT(Type type)
public Type GetEnumerableElementType(Type type)
public Type GetCollectionElementType(Type type)
public ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source)
public IEnumerable`1<T> ConcatAllowingNull(IEnumerable`1<T> source, IEnumerable`1<T> second)
public ICollection`1<T> ConcatAllowingNull(ICollection`1<T> source, ICollection`1<T> second)
public List`1<T> FastAppendToListAllowNulls(List`1<T> source, IEnumerable`1<T> second)
public void ForEach(IEnumerable`1<T> source, Action`1<T> action)
public EnumerableCardinality GetCardinality(IEnumerable`1<T> source)
public bool FastAny(IEnumerable`1<T> source)
public Stack`1<T> Copy(Stack`1<T> stack)
public T[] AsArray(IEnumerable`1<T> enumerable)
public List`1<T> AsList(IEnumerable`1<T> enumerable)
public bool IsArrayEqual(T[] thisArray, T[] thatArray)
public bool IsCollectionEqual(IList`1<T> thisList, IList`1<T> thatList)
}
internal Microsoft.Internal.Collections.EnumerableCardinality : Enum {
public int value__
public EnumerableCardinality Zero
public EnumerableCardinality One
public EnumerableCardinality TwoOrMore
}
internal Microsoft.Internal.Collections.WeakReferenceCollection`1 : object {
private List`1<WeakReference> _items
public void Add(T item)
public void Remove(T item)
public bool Contains(T item)
public void Clear()
private int IndexOf(T item)
private void CleanupDeadReferences()
public List`1<T> AliveItemsToList()
}
internal Microsoft.Internal.ContractServices : object {
public bool TryCast(Type contractType, object value, Object& result)
}
internal Microsoft.Internal.GenerationServices : object {
private MethodInfo _typeGetTypeFromHandleMethod
private Type TypeType
private Type StringType
private Type CharType
private Type BooleanType
private Type ByteType
private Type SByteType
private Type Int16Type
private Type UInt16Type
private Type Int32Type
private Type UInt32Type
private Type Int64Type
private Type UInt64Type
private Type DoubleType
private Type SingleType
private Type IEnumerableTypeofT
private Type IEnumerableType
private MethodInfo ExceptionGetData
private MethodInfo DictionaryAdd
private ConstructorInfo ObjectCtor
public ILGenerator CreateGeneratorForPublicConstructor(TypeBuilder typeBuilder, Type[] ctrArgumentTypes)
public void LoadValue(ILGenerator ilGenerator, object value)
public void AddItemToLocalDictionary(ILGenerator ilGenerator, LocalBuilder dictionary, object key, object value)
public void AddLocalToLocalDictionary(ILGenerator ilGenerator, LocalBuilder dictionary, object key, LocalBuilder value)
public void GetExceptionDataAndStoreInLocal(ILGenerator ilGenerator, LocalBuilder exception, LocalBuilder dataStore)
private void LoadEnumerable(ILGenerator ilGenerator, IEnumerable enumerable)
private bool IsBoxingRequiredForValue(object value)
private void LoadNull(ILGenerator ilGenerator)
private void LoadString(ILGenerator ilGenerator, string s)
private void LoadInt(ILGenerator ilGenerator, int value)
private void LoadLong(ILGenerator ilGenerator, long value)
private void LoadFloat(ILGenerator ilGenerator, float value)
private void LoadDouble(ILGenerator ilGenerator, double value)
private void LoadTypeOf(ILGenerator ilGenerator, Type type)
}
internal Microsoft.Internal.LazyServices : object {
public T GetNotNullValue(Lazy`1<T> lazy, string argument)
}
internal Microsoft.Internal.Lock : object {
private ReaderWriterLockSlim _thisLock
private int _isDisposed
public void EnterReadLock()
public void EnterWriteLock()
public void ExitReadLock()
public void ExitWriteLock()
public void Dispose()
}
internal Microsoft.Internal.ReadLock : ValueType {
private Lock _lock
private int _isDisposed
public void .ctor(Lock lock)
public void Dispose()
}
internal Microsoft.Internal.ReflectionInvoke : object {
public object SafeCreateInstance(Type type, Object[] arguments)
public object SafeInvoke(ConstructorInfo constructor, Object[] arguments)
public object SafeInvoke(MethodInfo method, object instance, Object[] arguments)
public object SafeGetValue(FieldInfo field, object instance)
public void SafeSetValue(FieldInfo field, object instance, object value)
public void DemandMemberAccessIfNeeded(MethodInfo method)
private void DemandMemberAccessIfNeeded(ConstructorInfo constructor)
private void DemandMemberAccessIfNeeded(FieldInfo field)
public void DemandMemberAccessIfNeeded(Type type)
}
internal Microsoft.Internal.ReflectionServices : object {
public Assembly Assembly(MemberInfo member)
public bool IsVisible(ConstructorInfo constructor)
public bool IsVisible(FieldInfo field)
public bool IsVisible(MethodInfo method)
public string GetDisplayName(Type declaringType, string name)
public string GetDisplayName(MemberInfo member)
internal bool TryGetGenericInterfaceType(Type instanceType, Type targetOpenInterfaceType, Type& targetClosedInterfaceType)
internal IEnumerable`1<PropertyInfo> GetAllProperties(Type type)
internal IEnumerable`1<MethodInfo> GetAllMethods(Type type)
private IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type)
public IEnumerable`1<FieldInfo> GetAllFields(Type type)
private IEnumerable`1<FieldInfo> GetDeclaredFields(Type type)
}
internal Microsoft.Internal.Requires : object {
public void NotNull(T value, string parameterName)
public void NotNullOrEmpty(string value, string parameterName)
public void NotNullOrNullElements(IEnumerable`1<T> values, string parameterName)
public void NullOrNotNullElements(IEnumerable`1<KeyValuePair`2<TKey, TValue>> values, string parameterName)
public void NullOrNotNullElements(IEnumerable`1<T> values, string parameterName)
private void NotNullElements(IEnumerable`1<T> values, string parameterName)
private void NotNullElements(IEnumerable`1<KeyValuePair`2<TKey, TValue>> values, string parameterName)
public void IsInMembertypeSet(MemberTypes value, string parameterName, MemberTypes enumFlagSet)
}
internal Microsoft.Internal.Runtime.Serialization.SerializationServices : object {
public T GetValue(SerializationInfo info, string name)
}
internal Microsoft.Internal.StringComparers : object {
public StringComparer ContractName
public StringComparer MetadataKeyNames
public StringComparer get_ContractName()
public StringComparer get_MetadataKeyNames()
}
internal Microsoft.Internal.Strings : object {
private ResourceManager resourceMan
private CultureInfo resourceCulture
internal ResourceManager ResourceManager
internal CultureInfo Culture
internal string Argument_AssemblyReflectionOnly
internal string Argument_ElementReflectionOnlyType
internal string Argument_ExportsEmpty
internal string Argument_ExportsTooMany
internal string Argument_NullElement
internal string Argument_ReflectionContextReturnsReflectionOnlyType
internal string ArgumentException_EmptyString
internal string ArgumentOutOfRange_InvalidEnum
internal string ArgumentOutOfRange_InvalidEnumInSet
internal string ArgumentValueType
internal string AssemblyFileNotFoundOrWrongType
internal string AtomicComposition_AlreadyCompleted
internal string AtomicComposition_AlreadyNested
internal string AtomicComposition_PartOfAnotherAtomicComposition
internal string CardinalityMismatch_NoExports
internal string CardinalityMismatch_TooManyExports
internal string CatalogMutation_Invalid
internal string CompositionElement_UnknownOrigin
internal string CompositionException_ChangesRejected
internal string CompositionException_ElementPrefix
internal string CompositionException_ErrorPrefix
internal string CompositionException_MetadataViewInvalidConstructor
internal string CompositionException_MultipleErrorsWithMultiplePaths
internal string CompositionException_OriginFormat
internal string CompositionException_OriginSeparator
internal string CompositionException_PathsCountSeparator
internal string CompositionException_ReviewErrorProperty
internal string CompositionException_SingleErrorWithMultiplePaths
internal string CompositionException_SingleErrorWithSinglePath
internal string CompositionTrace_Discovery_AssemblyLoadFailed
internal string CompositionTrace_Discovery_DefinitionContainsNoExports
internal string CompositionTrace_Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute
internal string CompositionTrace_Discovery_DefinitionMismatchedExportArity
internal string CompositionTrace_Discovery_MemberMarkedWithMultipleImportAndImportMany
internal string CompositionTrace_Rejection_DefinitionRejected
internal string CompositionTrace_Rejection_DefinitionResurrected
internal string ContractMismatch_ExportedValueCannotBeCastToT
internal string ContractMismatch_InvalidCastOnMetadataField
internal string ContractMismatch_MetadataViewImplementationCanNotBeNull
internal string ContractMismatch_MetadataViewImplementationDoesNotImplementViewInterface
internal string ContractMismatch_NullReferenceOnMetadataField
internal string DirectoryNotFound
internal string Discovery_DuplicateMetadataNameValues
internal string Discovery_MetadataContainsValueWithInvalidType
internal string Discovery_ReservedMetadataNameUsed
internal string ExportDefinitionNotOnThisComposablePart
internal string ExportFactory_TooManyGenericParameters
internal string ExportNotValidOnIndexers
internal string ImportDefinitionNotOnThisComposablePart
internal string ImportEngine_ComposeTookTooManyIterations
internal string ImportEngine_InvalidStateForRecomposition
internal string ImportEngine_PartCannotActivate
internal string ImportEngine_PartCannotGetExportedValue
internal string ImportEngine_PartCannotSetImport
internal string ImportEngine_PartCycle
internal string ImportEngine_PreventedByExistingImport
internal string ImportNotSetOnPart
internal string ImportNotValidOnIndexers
internal string InternalExceptionMessage
internal string InvalidArgument_ReflectionContext
internal string InvalidMetadataValue
internal string InvalidMetadataView
internal string InvalidOperation_DefinitionCannotBeRecomposed
internal string InvalidOperation_GetExportedValueBeforePrereqImportSet
internal string InvalidOperationReentrantCompose
internal string InvalidPartCreationPolicyOnImport
internal string InvalidPartCreationPolicyOnPart
internal string InvalidSetterOnMetadataField
internal string LazyMemberInfo_AccessorsNull
internal string LazyMemberInfo_InvalidAccessorOnSimpleMember
internal string LazyMemberinfo_InvalidEventAccessors_AccessorType
internal string LazyMemberInfo_InvalidEventAccessors_Cardinality
internal string LazyMemberinfo_InvalidPropertyAccessors_AccessorType
internal string LazyMemberInfo_InvalidPropertyAccessors_Cardinality
internal string LazyMemberInfo_NoAccessors
internal string LazyServices_LazyResolvesToNull
internal string MetadataItemNotSupported
internal string NotImplemented_NotOverriddenByDerived
internal string NotSupportedCatalogChanges
internal string NotSupportedInterfaceMetadataView
internal string NotSupportedReadOnlyDictionary
internal string ObjectAlreadyInitialized
internal string ObjectMustBeInitialized
internal string ReentrantCompose
internal string ReflectionContext_Requires_DefaultConstructor
internal string ReflectionContext_Type_Required
internal string ReflectionModel_ExportNotReadable
internal string ReflectionModel_ExportThrewException
internal string ReflectionModel_ImportCollectionAddThrewException
internal string ReflectionModel_ImportCollectionClearThrewException
internal string ReflectionModel_ImportCollectionConstructionThrewException
internal string ReflectionModel_ImportCollectionGetThrewException
internal string ReflectionModel_ImportCollectionIsReadOnlyThrewException
internal string ReflectionModel_ImportCollectionNotWritable
internal string ReflectionModel_ImportCollectionNull
internal string ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned
internal string ReflectionModel_ImportNotAssignableFromExport
internal string ReflectionModel_ImportNotWritable
internal string ReflectionModel_ImportThrewException
internal string ReflectionModel_InvalidExportDefinition
internal string ReflectionModel_InvalidImportDefinition
internal string ReflectionModel_InvalidMemberImportDefinition
internal string ReflectionModel_InvalidParameterImportDefinition
internal string ReflectionModel_InvalidPartDefinition
internal string ReflectionModel_PartConstructorMissing
internal string ReflectionModel_PartConstructorThrewException
internal string ReflectionModel_PartOnImportsSatisfiedThrewException
internal string TypeCatalog_DisplayNameFormat
internal string TypeCatalog_Empty
internal ResourceManager get_ResourceManager()
internal CultureInfo get_Culture()
internal void set_Culture(CultureInfo value)
internal string get_Argument_AssemblyReflectionOnly()
internal string get_Argument_ElementReflectionOnlyType()
internal string get_Argument_ExportsEmpty()
internal string get_Argument_ExportsTooMany()
internal string get_Argument_NullElement()
internal string get_Argument_ReflectionContextReturnsReflectionOnlyType()
internal string get_ArgumentException_EmptyString()
internal string get_ArgumentOutOfRange_InvalidEnum()
internal string get_ArgumentOutOfRange_InvalidEnumInSet()
internal string get_ArgumentValueType()
internal string get_AssemblyFileNotFoundOrWrongType()
internal string get_AtomicComposition_AlreadyCompleted()
internal string get_AtomicComposition_AlreadyNested()
internal string get_AtomicComposition_PartOfAnotherAtomicComposition()
internal string get_CardinalityMismatch_NoExports()
internal string get_CardinalityMismatch_TooManyExports()
internal string get_CatalogMutation_Invalid()
internal string get_CompositionElement_UnknownOrigin()
internal string get_CompositionException_ChangesRejected()
internal string get_CompositionException_ElementPrefix()
internal string get_CompositionException_ErrorPrefix()
internal string get_CompositionException_MetadataViewInvalidConstructor()
internal string get_CompositionException_MultipleErrorsWithMultiplePaths()
internal string get_CompositionException_OriginFormat()
internal string get_CompositionException_OriginSeparator()
internal string get_CompositionException_PathsCountSeparator()
internal string get_CompositionException_ReviewErrorProperty()
internal string get_CompositionException_SingleErrorWithMultiplePaths()
internal string get_CompositionException_SingleErrorWithSinglePath()
internal string get_CompositionTrace_Discovery_AssemblyLoadFailed()
internal string get_CompositionTrace_Discovery_DefinitionContainsNoExports()
internal string get_CompositionTrace_Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute()
internal string get_CompositionTrace_Discovery_DefinitionMismatchedExportArity()
internal string get_CompositionTrace_Discovery_MemberMarkedWithMultipleImportAndImportMany()
internal string get_CompositionTrace_Rejection_DefinitionRejected()
internal string get_CompositionTrace_Rejection_DefinitionResurrected()
internal string get_ContractMismatch_ExportedValueCannotBeCastToT()
internal string get_ContractMismatch_InvalidCastOnMetadataField()
internal string get_ContractMismatch_MetadataViewImplementationCanNotBeNull()
internal string get_ContractMismatch_MetadataViewImplementationDoesNotImplementViewInterface()
internal string get_ContractMismatch_NullReferenceOnMetadataField()
internal string get_DirectoryNotFound()
internal string get_Discovery_DuplicateMetadataNameValues()
internal string get_Discovery_MetadataContainsValueWithInvalidType()
internal string get_Discovery_ReservedMetadataNameUsed()
internal string get_ExportDefinitionNotOnThisComposablePart()
internal string get_ExportFactory_TooManyGenericParameters()
internal string get_ExportNotValidOnIndexers()
internal string get_ImportDefinitionNotOnThisComposablePart()
internal string get_ImportEngine_ComposeTookTooManyIterations()
internal string get_ImportEngine_InvalidStateForRecomposition()
internal string get_ImportEngine_PartCannotActivate()
internal string get_ImportEngine_PartCannotGetExportedValue()
internal string get_ImportEngine_PartCannotSetImport()
internal string get_ImportEngine_PartCycle()
internal string get_ImportEngine_PreventedByExistingImport()
internal string get_ImportNotSetOnPart()
internal string get_ImportNotValidOnIndexers()
internal string get_InternalExceptionMessage()
internal string get_InvalidArgument_ReflectionContext()
internal string get_InvalidMetadataValue()
internal string get_InvalidMetadataView()
internal string get_InvalidOperation_DefinitionCannotBeRecomposed()
internal string get_InvalidOperation_GetExportedValueBeforePrereqImportSet()
internal string get_InvalidOperationReentrantCompose()
internal string get_InvalidPartCreationPolicyOnImport()
internal string get_InvalidPartCreationPolicyOnPart()
internal string get_InvalidSetterOnMetadataField()
internal string get_LazyMemberInfo_AccessorsNull()
internal string get_LazyMemberInfo_InvalidAccessorOnSimpleMember()
internal string get_LazyMemberinfo_InvalidEventAccessors_AccessorType()
internal string get_LazyMemberInfo_InvalidEventAccessors_Cardinality()
internal string get_LazyMemberinfo_InvalidPropertyAccessors_AccessorType()
internal string get_LazyMemberInfo_InvalidPropertyAccessors_Cardinality()
internal string get_LazyMemberInfo_NoAccessors()
internal string get_LazyServices_LazyResolvesToNull()
internal string get_MetadataItemNotSupported()
internal string get_NotImplemented_NotOverriddenByDerived()
internal string get_NotSupportedCatalogChanges()
internal string get_NotSupportedInterfaceMetadataView()
internal string get_NotSupportedReadOnlyDictionary()
internal string get_ObjectAlreadyInitialized()
internal string get_ObjectMustBeInitialized()
internal string get_ReentrantCompose()
internal string get_ReflectionContext_Requires_DefaultConstructor()
internal string get_ReflectionContext_Type_Required()
internal string get_ReflectionModel_ExportNotReadable()
internal string get_ReflectionModel_ExportThrewException()
internal string get_ReflectionModel_ImportCollectionAddThrewException()
internal string get_ReflectionModel_ImportCollectionClearThrewException()
internal string get_ReflectionModel_ImportCollectionConstructionThrewException()
internal string get_ReflectionModel_ImportCollectionGetThrewException()
internal string get_ReflectionModel_ImportCollectionIsReadOnlyThrewException()
internal string get_ReflectionModel_ImportCollectionNotWritable()
internal string get_ReflectionModel_ImportCollectionNull()
internal string get_ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned()
internal string get_ReflectionModel_ImportNotAssignableFromExport()
internal string get_ReflectionModel_ImportNotWritable()
internal string get_ReflectionModel_ImportThrewException()
internal string get_ReflectionModel_InvalidExportDefinition()
internal string get_ReflectionModel_InvalidImportDefinition()
internal string get_ReflectionModel_InvalidMemberImportDefinition()
internal string get_ReflectionModel_InvalidParameterImportDefinition()
internal string get_ReflectionModel_InvalidPartDefinition()
internal string get_ReflectionModel_PartConstructorMissing()
internal string get_ReflectionModel_PartConstructorThrewException()
internal string get_ReflectionModel_PartOnImportsSatisfiedThrewException()
internal string get_TypeCatalog_DisplayNameFormat()
internal string get_TypeCatalog_Empty()
}
internal Microsoft.Internal.WriteLock : ValueType {
private Lock _lock
private int _isDisposed
public void .ctor(Lock lock)
public void Dispose()
}
internal System.ComponentModel.Composition.AttributedModel.AttributedExportDefinition : ExportDefinition {
private AttributedPartCreationInfo _partCreationInfo
private MemberInfo _member
private ExportAttribute _exportAttribute
private Type _typeIdentityType
private IDictionary`2<string, object> _metadata
public IDictionary`2<string, object> Metadata
public void .ctor(AttributedPartCreationInfo partCreationInfo, MemberInfo member, ExportAttribute exportAttribute, Type typeIdentityType, string contractName)
public IDictionary`2<string, object> get_Metadata()
}
internal System.ComponentModel.Composition.AttributedModel.AttributedModelDiscovery : object {
public ComposablePartDefinition CreatePartDefinitionIfDiscoverable(Type type, ICompositionElement origin)
public ReflectionComposablePartDefinition CreatePartDefinition(Type type, PartCreationPolicyAttribute partCreationPolicy, bool ignoreConstructorImports, ICompositionElement origin)
public ReflectionComposablePart CreatePart(object attributedPart)
public ReflectionComposablePart CreatePart(object attributedPart, ReflectionContext reflectionContext)
public ReflectionComposablePart CreatePart(ComposablePartDefinition partDefinition, object attributedPart)
public ReflectionParameterImportDefinition CreateParameterImportDefinition(ParameterInfo parameter, ICompositionElement origin)
public ReflectionMemberImportDefinition CreateMemberImportDefinition(MemberInfo member, ICompositionElement origin)
private IAttributedImport GetAttributedImport(ReflectionItem item, ICustomAttributeProvider attributeProvider)
}
internal System.ComponentModel.Composition.AttributedModel.AttributedPartCreationInfo : object {
private Type _type
private bool _ignoreConstructorImports
private ICompositionElement _origin
private PartCreationPolicyAttribute _partCreationPolicy
private ConstructorInfo _constructor
private IEnumerable`1<ExportDefinition> _exports
private IEnumerable`1<ImportDefinition> _imports
private HashSet`1<string> _contractNamesOnNonInterfaces
public bool IsDisposalRequired
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
private CreationPolicy CreationPolicy
public void .ctor(Type type, PartCreationPolicyAttribute partCreationPolicy, bool ignoreConstructorImports, ICompositionElement origin)
public Type GetPartType()
public Lazy`1<Type> GetLazyPartType()
public ConstructorInfo GetConstructor()
public IDictionary`2<string, object> GetMetadata()
public IEnumerable`1<ExportDefinition> GetExports()
public IEnumerable`1<ImportDefinition> GetImports()
public bool get_IsDisposalRequired()
public bool IsPartDiscoverable()
private bool HasExports()
private bool AllExportsHaveMatchingArity()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public string ToString()
private string GetDisplayName()
private CreationPolicy get_CreationPolicy()
private ConstructorInfo SelectPartConstructor(Type type)
private void DiscoverExportsAndImports()
private IEnumerable`1<ExportDefinition> GetExportDefinitions()
private AttributedExportDefinition CreateExportDefinition(MemberInfo member, ExportAttribute exportAttribute)
private IEnumerable`1<MemberInfo> GetExportMembers(Type type)
private IEnumerable`1<Type> GetInheritedExports(Type type)
private bool IsExport(ICustomAttributeProvider attributeProvider)
private bool IsInheritedExport(ICustomAttributeProvider attributedProvider)
private IEnumerable`1<ImportDefinition> GetImportDefinitions()
private IEnumerable`1<MemberInfo> GetImportMembers(Type type)
private IEnumerable`1<MemberInfo> GetDeclaredOnlyImportMembers(Type type)
private bool IsImport(ICustomAttributeProvider attributeProvider)
}
public System.ComponentModel.Composition.AttributedModelServices : object {
public TMetadataView GetMetadataView(IDictionary`2<string, object> metadata)
public ComposablePart CreatePart(object attributedPart)
public ComposablePart CreatePart(object attributedPart, ReflectionContext reflectionContext)
public ComposablePart CreatePart(ComposablePartDefinition partDefinition, object attributedPart)
public ComposablePartDefinition CreatePartDefinition(Type type, ICompositionElement origin)
public ComposablePartDefinition CreatePartDefinition(Type type, ICompositionElement origin, bool ensureIsDiscoverable)
public string GetTypeIdentity(Type type)
public string GetTypeIdentity(MethodInfo method)
public string GetContractName(Type type)
public ComposablePart AddExportedValue(CompositionBatch batch, T exportedValue)
public void ComposeExportedValue(CompositionContainer container, T exportedValue)
public ComposablePart AddExportedValue(CompositionBatch batch, string contractName, T exportedValue)
public void ComposeExportedValue(CompositionContainer container, string contractName, T exportedValue)
public ComposablePart AddPart(CompositionBatch batch, object attributedPart)
public void ComposeParts(CompositionContainer container, Object[] attributedParts)
public ComposablePart SatisfyImportsOnce(ICompositionService compositionService, object attributedPart)
public ComposablePart SatisfyImportsOnce(ICompositionService compositionService, object attributedPart, ReflectionContext reflectionContext)
public bool Exports(ComposablePartDefinition part, Type contractType)
public bool Exports(ComposablePartDefinition part)
public bool Imports(ComposablePartDefinition part, Type contractType)
public bool Imports(ComposablePartDefinition part)
public bool Imports(ComposablePartDefinition part, Type contractType, ImportCardinality importCardinality)
public bool Imports(ComposablePartDefinition part, ImportCardinality importCardinality)
}
public System.ComponentModel.Composition.CatalogReflectionContextAttribute : Attribute {
private Type _reflectionContextType
public void .ctor(Type reflectionContextType)
public ReflectionContext CreateReflectionContext()
}
public System.ComponentModel.Composition.ChangeRejectedException : CompositionException {
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(IEnumerable`1<CompositionError> errors)
public string get_Message()
}
public System.ComponentModel.Composition.CompositionContractMismatchException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ComponentModel.Composition.CompositionError : object {
private CompositionErrorId _id
private string _description
private Exception _exception
private ICompositionElement _element
public ICompositionElement Element
public string Description
public Exception Exception
internal CompositionErrorId Id
internal Exception InnerException
public void .ctor(string message)
public void .ctor(string message, ICompositionElement element)
public void .ctor(string message, Exception exception)
public void .ctor(string message, ICompositionElement element, Exception exception)
internal void .ctor(CompositionErrorId id, string description, ICompositionElement element, Exception exception)
public ICompositionElement get_Element()
public string get_Description()
public Exception get_Exception()
internal CompositionErrorId get_Id()
internal Exception get_InnerException()
public string ToString()
internal CompositionError Create(CompositionErrorId id, string format, Object[] parameters)
internal CompositionError Create(CompositionErrorId id, ICompositionElement element, string format, Object[] parameters)
internal CompositionError Create(CompositionErrorId id, ICompositionElement element, Exception exception, string format, Object[] parameters)
}
internal System.ComponentModel.Composition.CompositionErrorDebuggerProxy : object {
private CompositionError _error
public string Description
public Exception Exception
public ICompositionElement Element
public void .ctor(CompositionError error)
public string get_Description()
public Exception get_Exception()
public ICompositionElement get_Element()
}
internal System.ComponentModel.Composition.CompositionErrorId : Enum {
public int value__
public CompositionErrorId Unknown
public CompositionErrorId InvalidExportMetadata
public CompositionErrorId ImportNotSetOnPart
public CompositionErrorId ImportEngine_ComposeTookTooManyIterations
public CompositionErrorId ImportEngine_ImportCardinalityMismatch
public CompositionErrorId ImportEngine_PartCycle
public CompositionErrorId ImportEngine_PartCannotSetImport
public CompositionErrorId ImportEngine_PartCannotGetExportedValue
public CompositionErrorId ImportEngine_PartCannotActivate
public CompositionErrorId ImportEngine_PreventedByExistingImport
public CompositionErrorId ImportEngine_InvalidStateForRecomposition
public CompositionErrorId ReflectionModel_ImportThrewException
public CompositionErrorId ReflectionModel_ImportNotAssignableFromExport
public CompositionErrorId ReflectionModel_ImportCollectionNull
public CompositionErrorId ReflectionModel_ImportCollectionNotWritable
public CompositionErrorId ReflectionModel_ImportCollectionConstructionThrewException
public CompositionErrorId ReflectionModel_ImportCollectionGetThrewException
public CompositionErrorId ReflectionModel_ImportCollectionIsReadOnlyThrewException
public CompositionErrorId ReflectionModel_ImportCollectionClearThrewException
public CompositionErrorId ReflectionModel_ImportCollectionAddThrewException
public CompositionErrorId ReflectionModel_ImportManyOnParameterCanOnlyBeAssigned
}
public System.ComponentModel.Composition.CompositionException : Exception {
private string ErrorsKey
private ReadOnlyCollection`1<CompositionError> _errors
public ReadOnlyCollection`1<CompositionError> Errors
public string Message
public ReadOnlyCollection`1<Exception> RootCauses
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(CompositionError error)
public void .ctor(IEnumerable`1<CompositionError> errors)
internal void .ctor(string message, Exception innerException, IEnumerable`1<CompositionError> errors)
public ReadOnlyCollection`1<CompositionError> get_Errors()
public string get_Message()
private string BuildDefaultMessage()
private void WriteHeader(StringBuilder writer, int errorsCount, int pathCount)
private void WritePaths(StringBuilder writer, IEnumerable`1<IEnumerable`1<CompositionError>> paths)
private void WritePath(StringBuilder writer, IEnumerable`1<CompositionError> path, int ordinal)
private void WriteError(StringBuilder writer, CompositionError error)
private void WriteElementGraph(StringBuilder writer, ICompositionElement element)
private IEnumerable`1<IEnumerable`1<CompositionError>> CalculatePaths(CompositionException exception)
private void VisitCompositionException(CompositionException exception, VisitContext context)
private void VisitError(CompositionError error, VisitContext context)
private void VisitException(Exception exception, VisitContext context)
private void <.ctor>b__8_0(object exception, SafeSerializationEventArgs eventArgs)
public ReadOnlyCollection`1<Exception> get_RootCauses()
}
internal System.ComponentModel.Composition.CompositionExceptionDebuggerProxy : object {
private CompositionException _exception
public ReadOnlyCollection`1<Exception> Exceptions
public string Message
public ReadOnlyCollection`1<Exception> RootCauses
public void .ctor(CompositionException exception)
public ReadOnlyCollection`1<Exception> get_Exceptions()
public string get_Message()
public ReadOnlyCollection`1<Exception> get_RootCauses()
}
internal System.ComponentModel.Composition.CompositionResult : ValueType {
public CompositionResult SucceededResult
private IEnumerable`1<CompositionError> _errors
public bool Succeeded
public IEnumerable`1<CompositionError> Errors
public void .ctor(CompositionError[] errors)
public void .ctor(IEnumerable`1<CompositionError> errors)
public bool get_Succeeded()
public IEnumerable`1<CompositionError> get_Errors()
public CompositionResult MergeResult(CompositionResult result)
public CompositionResult MergeError(CompositionError error)
public CompositionResult MergeErrors(IEnumerable`1<CompositionError> errors)
public CompositionResult`1<T> ToResult(T value)
public void ThrowOnErrors()
public void ThrowOnErrors(AtomicComposition atomicComposition)
}
internal System.ComponentModel.Composition.CompositionResult`1 : ValueType {
private IEnumerable`1<CompositionError> _errors
private T _value
public bool Succeeded
public IEnumerable`1<CompositionError> Errors
public T Value
public void .ctor(T value)
public void .ctor(CompositionError[] errors)
public void .ctor(IEnumerable`1<CompositionError> errors)
internal void .ctor(T value, IEnumerable`1<CompositionError> errors)
public bool get_Succeeded()
public IEnumerable`1<CompositionError> get_Errors()
public T get_Value()
internal CompositionResult`1<TValue> ToResult()
internal CompositionResult ToResult()
private void ThrowOnErrors()
}
internal System.ComponentModel.Composition.ConstraintServices : object {
private PropertyInfo _exportDefinitionContractNameProperty
private PropertyInfo _exportDefinitionMetadataProperty
private MethodInfo _metadataContainsKeyMethod
private MethodInfo _metadataItemMethod
private MethodInfo _metadataEqualsMethod
private MethodInfo _typeIsInstanceOfTypeMethod
public Expression`1<Func`2<ExportDefinition, bool>> CreateConstraint(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, CreationPolicy requiredCreationPolicy)
private Expression CreateContractConstraintBody(string contractName, ParameterExpression parameter)
private Expression CreateMetadataConstraintBody(IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ParameterExpression parameter)
private Expression CreateCreationPolicyContraint(CreationPolicy policy, ParameterExpression parameter)
private Expression CreateTypeIdentityContraint(string requiredTypeIdentity, ParameterExpression parameter)
private Expression CreateMetadataContainsKeyExpression(ParameterExpression parameter, string constantKey)
private Expression CreateMetadataOfTypeExpression(ParameterExpression parameter, string constantKey, Type constantType)
private Expression CreateMetadataValueEqualsExpression(ParameterExpression parameter, object constantValue, string metadataName)
public Expression`1<Func`2<ExportDefinition, bool>> CreatePartCreatorConstraint(Expression`1<Func`2<ExportDefinition, bool>> baseConstraint, ImportDefinition productImportDefinition)
}
internal System.ComponentModel.Composition.ContractNameServices : object {
private char NamespaceSeparator
private char ArrayOpeningBracket
private char ArrayClosingBracket
private char ArraySeparator
private char PointerSymbol
private char ReferenceSymbol
private char GenericArityBackQuote
private char NestedClassSeparator
private char ContractNameGenericOpeningBracket
private char ContractNameGenericClosingBracket
private char ContractNameGenericArgumentSeparator
private char CustomModifiersSeparator
private char GenericFormatOpeningBracket
private char GenericFormatClosingBracket
private Dictionary`2<Type, string> typeIdentityCache
private Dictionary`2<Type, string> TypeIdentityCache
private Dictionary`2<Type, string> get_TypeIdentityCache()
internal string GetTypeIdentity(Type type)
internal string GetTypeIdentity(Type type, bool formatGenericName)
internal string GetTypeIdentityFromMethod(MethodInfo method)
internal string GetTypeIdentityFromMethod(MethodInfo method, bool formatGenericName)
private void WriteTypeWithNamespace(StringBuilder typeName, Type type, bool formatGenericName)
private void WriteType(StringBuilder typeName, Type type, bool formatGenericName)
private void WriteNonGenericType(StringBuilder typeName, Type type, bool formatGenericName)
private void WriteArrayType(StringBuilder typeName, Type type, bool formatGenericName)
private void WritePointerType(StringBuilder typeName, Type type, bool formatGenericName)
private void WriteByRefType(StringBuilder typeName, Type type, bool formatGenericName)
private void WriteArrayTypeDimensions(StringBuilder typeName, Type type)
private void WriteGenericType(StringBuilder typeName, Type type, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName)
private void WriteGenericTypeName(StringBuilder typeName, Type type, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName)
private void WriteTypeArgumentsString(StringBuilder typeName, int argumentsCount, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName)
private void WriteTypeArgument(StringBuilder typeName, bool isDefinition, Type genericTypeArgument, bool formatGenericName)
internal void WriteCustomModifiers(StringBuilder typeName, string customKeyword, Type[] types, bool formatGenericName)
private Type FindArrayElementType(Type type)
private string FindGenericTypeName(string genericName)
private int GetGenericArity(Type type)
}
public System.ComponentModel.Composition.CreationPolicy : Enum {
public int value__
public CreationPolicy Any
public CreationPolicy Shared
public CreationPolicy NonShared
public CreationPolicy NewScope
}
internal System.ComponentModel.Composition.Diagnostics.CompositionTrace : object {
internal void PartDefinitionResurrected(ComposablePartDefinition definition)
internal void PartDefinitionRejected(ComposablePartDefinition definition, ChangeRejectedException exception)
internal void AssemblyLoadFailed(DirectoryCatalog catalog, string fileName, Exception exception)
internal void DefinitionMarkedWithPartNotDiscoverableAttribute(Type type)
internal void DefinitionMismatchedExportArity(Type type, MemberInfo member)
internal void DefinitionContainsNoExports(Type type)
internal void MemberMarkedWithMultipleImportAndImportMany(ReflectionItem item)
}
internal System.ComponentModel.Composition.Diagnostics.CompositionTraceId : Enum {
public ushort value__
public CompositionTraceId Rejection_DefinitionRejected
public CompositionTraceId Rejection_DefinitionResurrected
public CompositionTraceId Discovery_AssemblyLoadFailed
public CompositionTraceId Discovery_DefinitionMarkedWithPartNotDiscoverableAttribute
public CompositionTraceId Discovery_DefinitionMismatchedExportArity
public CompositionTraceId Discovery_DefinitionContainsNoExports
public CompositionTraceId Discovery_MemberMarkedWithMultipleImportAndImportMany
}
internal System.ComponentModel.Composition.Diagnostics.CompositionTraceSource : object {
private DebuggerTraceWriter Source
public bool CanWriteInformation
public bool CanWriteWarning
public bool CanWriteError
public bool get_CanWriteInformation()
public bool get_CanWriteWarning()
public bool get_CanWriteError()
public void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteError(CompositionTraceId traceId, string format, Object[] arguments)
private void EnsureEnabled(bool condition)
}
internal System.ComponentModel.Composition.Diagnostics.DebuggerTraceWriter : TraceWriter {
private string SourceName
public bool CanWriteInformation
public bool CanWriteWarning
public bool CanWriteError
public bool get_CanWriteInformation()
public bool get_CanWriteWarning()
public bool get_CanWriteError()
public void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteError(CompositionTraceId traceId, string format, Object[] arguments)
private void WriteEvent(TraceEventType eventType, CompositionTraceId traceId, string format, Object[] arguments)
internal string CreateLogMessage(TraceEventType eventType, CompositionTraceId traceId, string format, Object[] arguments)
}
internal System.ComponentModel.Composition.Diagnostics.TraceWriter : object {
public bool CanWriteInformation
public bool CanWriteWarning
public bool CanWriteError
public bool get_CanWriteInformation()
public bool get_CanWriteWarning()
public bool get_CanWriteError()
public void WriteInformation(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteWarning(CompositionTraceId traceId, string format, Object[] arguments)
public void WriteError(CompositionTraceId traceId, string format, Object[] arguments)
}
internal System.ComponentModel.Composition.ErrorBuilder : object {
public CompositionError PreventedByExistingImport(ComposablePart part, ImportDefinition import)
public CompositionError InvalidStateForRecompposition(ComposablePart part)
public CompositionError ComposeTookTooManyIterations(int maximumNumberOfCompositionIterations)
public CompositionError CreateImportCardinalityMismatch(ImportCardinalityMismatchException exception, ImportDefinition definition)
public CompositionError CreatePartCannotActivate(ComposablePart part, Exception innerException)
public CompositionError CreatePartCannotSetImport(ComposablePart part, ImportDefinition definition, Exception innerException)
public CompositionError CreateCannotGetExportedValue(ComposablePart part, ExportDefinition definition, Exception innerException)
public CompositionError CreatePartCycle(ComposablePart part)
}
internal System.ComponentModel.Composition.ExceptionBuilder : object {
public Exception CreateDiscoveryException(string messageFormat, String[] arguments)
public ArgumentException CreateContainsNullElement(string parameterName)
public ObjectDisposedException CreateObjectDisposed(object instance)
public NotImplementedException CreateNotOverriddenByDerived(string memberName)
public ArgumentException CreateExportDefinitionNotOnThisComposablePart(string parameterName)
public ArgumentException CreateImportDefinitionNotOnThisComposablePart(string parameterName)
public CompositionException CreateCannotGetExportedValue(ComposablePart part, ExportDefinition definition, Exception innerException)
public ArgumentException CreateReflectionModelInvalidPartDefinition(string parameterName, Type partDefinitionType)
public ArgumentException ExportFactory_TooManyGenericParameters(string typeName)
private string Format(string format, String[] arguments)
}
public System.ComponentModel.Composition.ExportAttribute : Attribute {
private string <ContractName>k__BackingField
private Type <ContractType>k__BackingField
public string ContractName
public Type ContractType
public void .ctor(Type contractType)
public void .ctor(string contractName)
public void .ctor(string contractName, Type contractType)
public string get_ContractName()
private void set_ContractName(string value)
public Type get_ContractType()
private void set_ContractType(Type value)
}
internal System.ComponentModel.Composition.ExportCardinalityCheckResult : Enum {
public int value__
public ExportCardinalityCheckResult Match
public ExportCardinalityCheckResult NoExports
public ExportCardinalityCheckResult TooManyExports
}
public System.ComponentModel.Composition.ExportFactory`1 : object {
private Func`1<Tuple`2<T, Action>> _exportLifetimeContextCreator
public void .ctor(Func`1<Tuple`2<T, Action>> exportLifetimeContextCreator)
public ExportLifetimeContext`1<T> CreateExport()
internal bool IncludeInScopedCatalog(ComposablePartDefinition composablePartDefinition)
protected bool OnFilterScopedCatalog(ComposablePartDefinition composablePartDefinition)
}
public System.ComponentModel.Composition.ExportFactory`2 : ExportFactory`1<T> {
private TMetadata _metadata
public TMetadata Metadata
public void .ctor(Func`1<Tuple`2<T, Action>> exportLifetimeContextCreator, TMetadata metadata)
public TMetadata get_Metadata()
}
public System.ComponentModel.Composition.ExportLifetimeContext`1 : object {
private T _value
private Action _disposeAction
public T Value
public void .ctor(T value, Action disposeAction)
public T get_Value()
public void Dispose()
}
public System.ComponentModel.Composition.ExportMetadataAttribute : Attribute {
private string <Name>k__BackingField
private object <Value>k__BackingField
private bool <IsMultiple>k__BackingField
public string Name
public object Value
public bool IsMultiple
public void .ctor(string name, object value)
public string get_Name()
private void set_Name(string value)
public object get_Value()
private void set_Value(object value)
public bool get_IsMultiple()
public void set_IsMultiple(bool value)
}
internal System.ComponentModel.Composition.ExportServices : object {
private MethodInfo _createStronglyTypedLazyOfTM
private MethodInfo _createStronglyTypedLazyOfT
private MethodInfo _createSemiStronglyTypedLazy
internal Type DefaultMetadataViewType
internal Type DefaultExportedValueType
internal bool IsDefaultMetadataViewType(Type metadataViewType)
internal bool IsDictionaryConstructorViewType(Type metadataViewType)
internal Func`2<Export, object> CreateStronglyTypedLazyFactory(Type exportType, Type metadataViewType)
internal Func`2<Export, Lazy`2<object, object>> CreateSemiStronglyTypedLazyFactory(Type exportType, Type metadataViewType)
internal Lazy`2<T, M> CreateStronglyTypedLazyOfTM(Export export)
internal Lazy`1<T> CreateStronglyTypedLazyOfT(Export export)
internal Lazy`2<object, object> CreateSemiStronglyTypedLazy(Export export)
internal T GetCastedExportedValue(Export export)
internal T CastExportedValue(ICompositionElement element, object exportedValue)
internal ExportCardinalityCheckResult CheckCardinality(ImportDefinition definition, IEnumerable`1<T> enumerable)
private ExportCardinalityCheckResult MatchCardinality(EnumerableCardinality actualCardinality, ImportCardinality importCardinality)
}
public System.ComponentModel.Composition.Hosting.AggregateCatalog : ComposablePartCatalog {
private ComposablePartCatalogCollection _catalogs
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
public ICollection`1<ComposablePartCatalog> Catalogs
public void .ctor(ComposablePartCatalog[] catalogs)
public void .ctor(IEnumerable`1<ComposablePartCatalog> catalogs)
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
public ICollection`1<ComposablePartCatalog> get_Catalogs()
protected void Dispose(bool disposing)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
protected void OnChanged(ComposablePartCatalogChangeEventArgs e)
protected void OnChanging(ComposablePartCatalogChangeEventArgs e)
private void ThrowIfDisposed()
}
public System.ComponentModel.Composition.Hosting.AggregateExportProvider : ExportProvider {
private ReadOnlyCollection`1<ExportProvider> _readOnlyProviders
private ExportProvider[] _providers
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
public ReadOnlyCollection`1<ExportProvider> Providers
public void .ctor(ExportProvider[] providers)
public void .ctor(IEnumerable`1<ExportProvider> providers)
public void Dispose()
protected void Dispose(bool disposing)
public ReadOnlyCollection`1<ExportProvider> get_Providers()
protected IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
private void OnExportChangedInternal(object sender, ExportsChangeEventArgs e)
private void OnExportChangingInternal(object sender, ExportsChangeEventArgs e)
private void ThrowIfDisposed()
}
public System.ComponentModel.Composition.Hosting.ApplicationCatalog : ComposablePartCatalog {
private bool _isDisposed
private AggregateCatalog modreq(System.Runtime.CompilerServices.IsVolatile) _innerCatalog
private object _thisLock
private ICompositionElement _definitionOrigin
private ReflectionContext _reflectionContext
private AggregateCatalog InnerCatalog
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(ICompositionElement definitionOrigin)
public void .ctor(ReflectionContext reflectionContext)
public void .ctor(ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
internal ComposablePartCatalog CreateCatalog(string location, string pattern)
private AggregateCatalog get_InnerCatalog()
protected void Dispose(bool disposing)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
private void ThrowIfDisposed()
private string GetDisplayName()
public string ToString()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
}
public System.ComponentModel.Composition.Hosting.AssemblyCatalog : ComposablePartCatalog {
private object _thisLock
private ICompositionElement _definitionOrigin
private Assembly modreq(System.Runtime.CompilerServices.IsVolatile) _assembly
private ComposablePartCatalog modreq(System.Runtime.CompilerServices.IsVolatile) _innerCatalog
private int _isDisposed
private ReflectionContext _reflectionContext
private ComposablePartCatalog InnerCatalog
public Assembly Assembly
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(string codeBase)
public void .ctor(string codeBase, ReflectionContext reflectionContext)
public void .ctor(string codeBase, ICompositionElement definitionOrigin)
public void .ctor(string codeBase, ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
public void .ctor(Assembly assembly, ReflectionContext reflectionContext)
public void .ctor(Assembly assembly, ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
public void .ctor(Assembly assembly)
public void .ctor(Assembly assembly, ICompositionElement definitionOrigin)
private void InitializeAssemblyCatalog(Assembly assembly)
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
private ComposablePartCatalog get_InnerCatalog()
public Assembly get_Assembly()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public string ToString()
protected void Dispose(bool disposing)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
private void ThrowIfDisposed()
private string GetDisplayName()
private Assembly LoadAssembly(string codeBase)
}
internal System.ComponentModel.Composition.Hosting.AssemblyCatalogDebuggerProxy : object {
private AssemblyCatalog _catalog
public Assembly Assembly
public ReadOnlyCollection`1<ComposablePartDefinition> Parts
public void .ctor(AssemblyCatalog catalog)
public Assembly get_Assembly()
public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts()
}
public System.ComponentModel.Composition.Hosting.AtomicComposition : object {
private AtomicComposition _outerAtomicComposition
private KeyValuePair`2[] _values
private int _valueCount
private List`1<Action> _completeActionList
private List`1<Action> _revertActionList
private bool _isDisposed
private bool _isCompleted
private bool _containsInnerAtomicComposition
private bool ContainsInnerAtomicComposition
public void .ctor(AtomicComposition outerAtomicComposition)
public void SetValue(object key, object value)
public bool TryGetValue(object key, T& value)
public bool TryGetValue(object key, bool localAtomicCompositionOnly, T& value)
public void AddCompleteAction(Action completeAction)
public void AddRevertAction(Action revertAction)
public void Complete()
public void Dispose()
protected void Dispose(bool disposing)
private void FinalComplete()
private void CopyComplete()
private void set_ContainsInnerAtomicComposition(bool value)
private bool TryGetValueInternal(object key, bool localAtomicCompositionOnly, T& value)
private void SetValueInternal(object key, object value)
private void ThrowIfContainsInnerAtomicComposition()
private void ThrowIfCompleted()
private void ThrowIfDisposed()
}
internal System.ComponentModel.Composition.Hosting.AtomicCompositionExtensions : object {
internal T GetValueAllowNull(AtomicComposition atomicComposition, T defaultResultAndKey)
internal T GetValueAllowNull(AtomicComposition atomicComposition, object key, T defaultResult)
internal void AddRevertActionAllowNull(AtomicComposition atomicComposition, Action action)
internal void AddCompleteActionAllowNull(AtomicComposition atomicComposition, Action action)
}
public System.ComponentModel.Composition.Hosting.CatalogExportProvider : ExportProvider {
private CompositionLock _lock
private Dictionary`2<ComposablePartDefinition, CatalogPart> _activatedParts
private HashSet`1<ComposablePartDefinition> _rejectedParts
private ConditionalWeakTable`2<object, List`1<ComposablePart>> _gcRoots
private HashSet`1<IDisposable> _partsToDispose
private ComposablePartCatalog _catalog
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isRunning
private ExportProvider _sourceProvider
private ImportEngine _importEngine
private CompositionOptions _compositionOptions
private ExportProvider _innerExportProvider
public ComposablePartCatalog Catalog
public ExportProvider SourceProvider
public void .ctor(ComposablePartCatalog catalog)
public void .ctor(ComposablePartCatalog catalog, bool isThreadSafe)
public void .ctor(ComposablePartCatalog catalog, CompositionOptions compositionOptions)
public ComposablePartCatalog get_Catalog()
public ExportProvider get_SourceProvider()
public void set_SourceProvider(ExportProvider value)
public void Dispose()
protected void Dispose(bool disposing)
protected IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
private IEnumerable`1<Export> InternalGetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
private Export CreateExport(ComposablePartDefinition partDefinition, ExportDefinition exportDefinition, bool isExportFactory, CreationPolicy importPolicy)
private void OnExportsChangingInternal(object sender, ExportsChangeEventArgs e)
private ExportDefinition[] GetExportsFromPartDefinitions(IEnumerable`1<ComposablePartDefinition> partDefinitions)
private void OnCatalogChanging(object sender, ComposablePartCatalogChangeEventArgs e)
private CatalogPart GetComposablePart(ComposablePartDefinition partDefinition, bool isSharedPart)
private CatalogPart GetSharedPart(ComposablePartDefinition partDefinition)
private object GetExportedValue(CatalogPart part, ExportDefinition export, bool isSharedPart)
private void ReleasePart(object exportedValue, CatalogPart catalogPart, AtomicComposition atomicComposition)
private void PreventPartCollection(object exportedValue, ComposablePart part)
private void AllowPartCollection(object gcRoot)
private bool IsRejected(ComposablePartDefinition definition, AtomicComposition atomicComposition)
private bool DetermineRejection(ComposablePartDefinition definition, AtomicComposition parentAtomicComposition)
private void UpdateRejections(IEnumerable`1<ExportDefinition> changedExports, AtomicComposition atomicComposition)
private void ThrowIfDisposed()
private void EnsureCanRun()
private void EnsureRunning()
private void EnsureCanSet(T currentValue)
private Func`2<ComposablePartDefinition, AtomicCompositionQueryState> GetAtomicCompositionQuery(AtomicComposition atomicComposition)
private void UpdateAtomicCompositionQuery(AtomicComposition atomicComposition, Func`2<ComposablePartDefinition, bool> query, AtomicCompositionQueryState state)
}
public System.ComponentModel.Composition.Hosting.CatalogExtensions : object {
public CompositionService CreateCompositionService(ComposablePartCatalog composablePartCatalog)
}
public System.ComponentModel.Composition.Hosting.ComposablePartCatalogChangeEventArgs : EventArgs {
private IEnumerable`1<ComposablePartDefinition> _addedDefinitions
private IEnumerable`1<ComposablePartDefinition> _removedDefinitions
private AtomicComposition <AtomicComposition>k__BackingField
public IEnumerable`1<ComposablePartDefinition> AddedDefinitions
public IEnumerable`1<ComposablePartDefinition> RemovedDefinitions
public AtomicComposition AtomicComposition
public void .ctor(IEnumerable`1<ComposablePartDefinition> addedDefinitions, IEnumerable`1<ComposablePartDefinition> removedDefinitions, AtomicComposition atomicComposition)
public IEnumerable`1<ComposablePartDefinition> get_AddedDefinitions()
public IEnumerable`1<ComposablePartDefinition> get_RemovedDefinitions()
public AtomicComposition get_AtomicComposition()
private void set_AtomicComposition(AtomicComposition value)
}
internal System.ComponentModel.Composition.Hosting.ComposablePartCatalogCollection : object {
private Lock _lock
private Action`1<ComposablePartCatalogChangeEventArgs> _onChanged
private Action`1<ComposablePartCatalogChangeEventArgs> _onChanging
private List`1<ComposablePartCatalog> _catalogs
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isCopyNeeded
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private bool _hasChanged
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changing
public int Count
public bool IsReadOnly
internal bool HasChanged
public void .ctor(IEnumerable`1<ComposablePartCatalog> catalogs, Action`1<ComposablePartCatalogChangeEventArgs> onChanged, Action`1<ComposablePartCatalogChangeEventArgs> onChanging)
public void Add(ComposablePartCatalog item)
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void Clear()
public bool Contains(ComposablePartCatalog item)
public void CopyTo(ComposablePartCatalog[] array, int arrayIndex)
public int get_Count()
public bool get_IsReadOnly()
public bool Remove(ComposablePartCatalog item)
internal bool get_HasChanged()
public IEnumerator`1<ComposablePartCatalog> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Dispose()
protected void Dispose(bool disposing)
private void RaiseChangedEvent(Lazy`1<IEnumerable`1<ComposablePartDefinition>> addedDefinitions, Lazy`1<IEnumerable`1<ComposablePartDefinition>> removedDefinitions)
public void OnChanged(object sender, ComposablePartCatalogChangeEventArgs e)
private void RaiseChangingEvent(Lazy`1<IEnumerable`1<ComposablePartDefinition>> addedDefinitions, Lazy`1<IEnumerable`1<ComposablePartDefinition>> removedDefinitions, AtomicComposition atomicComposition)
public void OnChanging(object sender, ComposablePartCatalogChangeEventArgs e)
private void OnContainedCatalogChanged(object sender, ComposablePartCatalogChangeEventArgs e)
private void OnContainedCatalogChanging(object sender, ComposablePartCatalogChangeEventArgs e)
private void SubscribeToCatalogNotifications(ComposablePartCatalog catalog)
private void SubscribeToCatalogNotifications(IEnumerable`1<ComposablePartCatalog> catalogs)
private void UnsubscribeFromCatalogNotifications(ComposablePartCatalog catalog)
private void UnsubscribeFromCatalogNotifications(IEnumerable`1<ComposablePartCatalog> catalogs)
private void ThrowIfDisposed()
}
public System.ComponentModel.Composition.Hosting.ComposablePartExportProvider : ExportProvider {
private List`1<ComposablePart> _parts
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isRunning
private CompositionLock _lock
private ExportProvider _sourceProvider
private ImportEngine _importEngine
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _currentlyComposing
private CompositionOptions _compositionOptions
public ExportProvider SourceProvider
private ImportEngine ImportEngine
public void .ctor(bool isThreadSafe)
public void .ctor(CompositionOptions compositionOptions)
public void Dispose()
protected void Dispose(bool disposing)
public ExportProvider get_SourceProvider()
public void set_SourceProvider(ExportProvider value)
private ImportEngine get_ImportEngine()
protected IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
public void Compose(CompositionBatch batch)
private List`1<ComposablePart> GetUpdatedPartsList(CompositionBatch& batch)
private void Recompose(CompositionBatch batch, AtomicComposition atomicComposition)
private Export CreateExport(ComposablePart part, ExportDefinition export)
private object GetExportedValue(ComposablePart part, ExportDefinition export)
private void ThrowIfDisposed()
private void EnsureCanRun()
private void EnsureRunning()
private void EnsureCanSet(T currentValue)
}
public System.ComponentModel.Composition.Hosting.CompositionBatch : object {
private object _lock
private bool _copyNeededForAdd
private bool _copyNeededForRemove
private List`1<ComposablePart> _partsToAdd
private ReadOnlyCollection`1<ComposablePart> _readOnlyPartsToAdd
private List`1<ComposablePart> _partsToRemove
private ReadOnlyCollection`1<ComposablePart> _readOnlyPartsToRemove
public ReadOnlyCollection`1<ComposablePart> PartsToAdd
public ReadOnlyCollection`1<ComposablePart> PartsToRemove
public void .ctor(IEnumerable`1<ComposablePart> partsToAdd, IEnumerable`1<ComposablePart> partsToRemove)
public ReadOnlyCollection`1<ComposablePart> get_PartsToAdd()
public ReadOnlyCollection`1<ComposablePart> get_PartsToRemove()
public void AddPart(ComposablePart part)
public void RemovePart(ComposablePart part)
public ComposablePart AddExport(Export export)
}
public System.ComponentModel.Composition.Hosting.CompositionConstants : object {
private string CompositionNamespace
public string PartCreationPolicyMetadataName
public string ImportSourceMetadataName
public string IsGenericPartMetadataName
public string GenericContractMetadataName
public string GenericParametersMetadataName
public string ExportTypeIdentityMetadataName
internal string GenericImportParametersOrderMetadataName
internal string GenericExportParametersOrderMetadataName
internal string GenericPartArityMetadataName
internal string GenericParameterConstraintsMetadataName
internal string GenericParameterAttributesMetadataName
internal string ProductDefinitionMetadataName
internal string PartCreatorContractName
internal string PartCreatorTypeIdentity
}
public System.ComponentModel.Composition.Hosting.CompositionContainer : ExportProvider {
private CompositionOptions _compositionOptions
private ImportEngine _importEngine
private ComposablePartExportProvider _partExportProvider
private ExportProvider _rootProvider
private CatalogExportProvider _catalogExportProvider
private AggregateExportProvider _localExportProvider
private AggregateExportProvider _ancestorExportProvider
private ReadOnlyCollection`1<ExportProvider> _providers
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private object _lock
private ReadOnlyCollection`1<ExportProvider> EmptyProviders
internal CompositionOptions CompositionOptions
public ComposablePartCatalog Catalog
internal CatalogExportProvider CatalogExportProvider
public ReadOnlyCollection`1<ExportProvider> Providers
public void .ctor(ExportProvider[] providers)
public void .ctor(CompositionOptions compositionOptions, ExportProvider[] providers)
public void .ctor(ComposablePartCatalog catalog, ExportProvider[] providers)
public void .ctor(ComposablePartCatalog catalog, bool isThreadSafe, ExportProvider[] providers)
public void .ctor(ComposablePartCatalog catalog, CompositionOptions compositionOptions, ExportProvider[] providers)
internal CompositionOptions get_CompositionOptions()
public ComposablePartCatalog get_Catalog()
internal CatalogExportProvider get_CatalogExportProvider()
public ReadOnlyCollection`1<ExportProvider> get_Providers()
public void Dispose()
protected void Dispose(bool disposing)
public void Compose(CompositionBatch batch)
public void ReleaseExport(Export export)
public void ReleaseExport(Lazy`1<T> export)
public void ReleaseExports(IEnumerable`1<Export> exports)
public void ReleaseExports(IEnumerable`1<Lazy`1<T>> exports)
public void ReleaseExports(IEnumerable`1<Lazy`2<T, TMetadataView>> exports)
public void SatisfyImportsOnce(ComposablePart part)
internal void OnExportsChangedInternal(object sender, ExportsChangeEventArgs e)
internal void OnExportsChangingInternal(object sender, ExportsChangeEventArgs e)
protected IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
private void ThrowIfDisposed()
}
internal System.ComponentModel.Composition.Hosting.CompositionLock : object {
private Lock _stateLock
private object _compositionLock
private int _isDisposed
private bool _isThreadSafe
private EmptyLockHolder _EmptyLockHolder
public bool IsThreadSafe
public void .ctor(bool isThreadSafe)
public void Dispose()
public bool get_IsThreadSafe()
private void EnterCompositionLock()
private void ExitCompositionLock()
public IDisposable LockComposition()
public IDisposable LockStateForRead()
public IDisposable LockStateForWrite()
}
public System.ComponentModel.Composition.Hosting.CompositionOptions : Enum {
public int value__
public CompositionOptions Default
public CompositionOptions DisableSilentRejection
public CompositionOptions IsThreadSafe
public CompositionOptions ExportCompositionService
}
public System.ComponentModel.Composition.Hosting.CompositionScopeDefinition : ComposablePartCatalog {
private ComposablePartCatalog _catalog
private IEnumerable`1<ExportDefinition> _publicSurface
private IEnumerable`1<CompositionScopeDefinition> _children
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changing
public IEnumerable`1<CompositionScopeDefinition> Children
public IEnumerable`1<ExportDefinition> PublicSurface
public void .ctor(ComposablePartCatalog catalog, IEnumerable`1<CompositionScopeDefinition> children)
public void .ctor(ComposablePartCatalog catalog, IEnumerable`1<CompositionScopeDefinition> children, IEnumerable`1<ExportDefinition> publicSurface)
private void InitializeCompositionScopeDefinition(ComposablePartCatalog catalog, IEnumerable`1<CompositionScopeDefinition> children, IEnumerable`1<ExportDefinition> publicSurface)
protected void Dispose(bool disposing)
public IEnumerable`1<CompositionScopeDefinition> get_Children()
public IEnumerable`1<ExportDefinition> get_PublicSurface()
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
internal IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExportsFromPublicSurface(ImportDefinition definition)
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
protected void OnChanged(ComposablePartCatalogChangeEventArgs e)
protected void OnChanging(ComposablePartCatalogChangeEventArgs e)
private void OnChangedInternal(object sender, ComposablePartCatalogChangeEventArgs e)
private void OnChangingInternal(object sender, ComposablePartCatalogChangeEventArgs e)
private void ThrowIfDisposed()
}
internal System.ComponentModel.Composition.Hosting.CompositionScopeDefinitionDebuggerProxy : object {
private CompositionScopeDefinition _compositionScopeDefinition
public ReadOnlyCollection`1<ComposablePartDefinition> Parts
public IEnumerable`1<ExportDefinition> PublicSurface
public IEnumerable`1<CompositionScopeDefinition> Children
public void .ctor(CompositionScopeDefinition compositionScopeDefinition)
public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts()
public IEnumerable`1<ExportDefinition> get_PublicSurface()
public IEnumerable`1<CompositionScopeDefinition> get_Children()
}
public System.ComponentModel.Composition.Hosting.CompositionService : object {
private CompositionContainer _compositionContainer
private INotifyComposablePartCatalogChanged _notifyCatalog
internal void .ctor(ComposablePartCatalog composablePartCatalog)
public void SatisfyImportsOnce(ComposablePart part)
public void Dispose()
private void OnCatalogChanging(object sender, ComposablePartCatalogChangeEventArgs e)
}
internal System.ComponentModel.Composition.Hosting.CompositionServices : object {
internal Type InheritedExportAttributeType
internal Type ExportAttributeType
internal Type AttributeType
internal Type ObjectType
private String[] reservedMetadataNames
internal Type GetDefaultTypeFromMember(MemberInfo member)
internal Type AdjustSpecifiedTypeIdentityType(Type specifiedContractType, MemberInfo member)
internal Type AdjustSpecifiedTypeIdentityType(Type specifiedContractType, Type memberType)
private string AdjustTypeIdentity(string originalTypeIdentity, Type typeIdentityType)
internal void GetContractInfoFromExport(MemberInfo member, ExportAttribute export, Type& typeIdentityType, String& contractName)
internal string GetTypeIdentityFromExport(MemberInfo member, Type typeIdentityType)
private Type GetTypeIdentityTypeFromExport(MemberInfo member, ExportAttribute export)
internal bool IsContractNameSameAsTypeIdentity(ExportAttribute export)
internal Type GetContractTypeFromImport(IAttributedImport import, ImportType importType)
internal string GetContractNameFromImport(IAttributedImport import, ImportType importType)
internal string GetTypeIdentityFromImport(IAttributedImport import, ImportType importType)
internal IDictionary`2<string, object> GetPartMetadataForType(Type type, CreationPolicy creationPolicy)
internal void TryExportMetadataForMember(MemberInfo member, IDictionary`2& dictionary)
private bool TryContributeMetadataValue(IDictionary`2<string, object> dictionary, string name, object value, Type valueType, bool allowsMultiple)
internal IEnumerable`1<KeyValuePair`2<string, Type>> GetRequiredMetadata(Type metadataViewType)
internal IDictionary`2<string, object> GetImportMetadata(ImportType importType, IAttributedImport attributedImport)
internal IDictionary`2<string, object> GetImportMetadata(Type type, IAttributedImport attributedImport)
internal object GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)
internal bool IsRecomposable(ComposablePart part)
internal CompositionResult TryInvoke(Action action)
internal CompositionResult TryFire(EventHandler`1<TEventArgs> _delegate, object sender, TEventArgs e)
internal CreationPolicy GetRequiredCreationPolicy(ImportDefinition definition)
internal bool IsAtMostOne(ImportCardinality cardinality)
private bool IsValidAttributeType(Type type)
private bool IsValidAttributeType(Type type, bool arrayAllowed)
}
public System.ComponentModel.Composition.Hosting.DirectoryCatalog : ComposablePartCatalog {
private Lock _thisLock
private ICompositionElement _definitionOrigin
private ComposablePartCatalogCollection _catalogCollection
private Dictionary`2<string, AssemblyCatalog> _assemblyCatalogs
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private string _path
private string _fullPath
private string _searchPattern
private ReadOnlyCollection`1<string> _loadedFiles
private ReflectionContext _reflectionContext
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changing
public string FullPath
public ReadOnlyCollection`1<string> LoadedFiles
public string Path
public string SearchPattern
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(string path)
public void .ctor(string path, ReflectionContext reflectionContext)
public void .ctor(string path, ICompositionElement definitionOrigin)
public void .ctor(string path, ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
public void .ctor(string path, string searchPattern)
public void .ctor(string path, string searchPattern, ICompositionElement definitionOrigin)
public void .ctor(string path, string searchPattern, ReflectionContext reflectionContext)
public void .ctor(string path, string searchPattern, ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
public string get_FullPath()
public ReadOnlyCollection`1<string> get_LoadedFiles()
public string get_Path()
public string get_SearchPattern()
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
protected void Dispose(bool disposing)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
protected void OnChanged(ComposablePartCatalogChangeEventArgs e)
protected void OnChanging(ComposablePartCatalogChangeEventArgs e)
public void Refresh()
public string ToString()
private AssemblyCatalog CreateAssemblyCatalogGuarded(string assemblyFilePath)
private void DiffChanges(String[] beforeFiles, String[] afterFiles, List`1& catalogsToAdd, List`1& catalogsToRemove)
private string GetDisplayName()
private String[] GetFiles()
private string GetFullPath(string path)
private void Initialize(string path, string searchPattern)
private void ThrowIfDisposed()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
}
public System.ComponentModel.Composition.Hosting.ExportProvider : object {
private Export[] EmptyExports
private EventHandler`1<ExportsChangeEventArgs> ExportsChanged
private EventHandler`1<ExportsChangeEventArgs> ExportsChanging
public Lazy`1<T> GetExport()
public Lazy`1<T> GetExport(string contractName)
public Lazy`2<T, TMetadataView> GetExport()
public Lazy`2<T, TMetadataView> GetExport(string contractName)
public IEnumerable`1<Lazy`2<object, object>> GetExports(Type type, Type metadataViewType, string contractName)
public IEnumerable`1<Lazy`1<T>> GetExports()
public IEnumerable`1<Lazy`1<T>> GetExports(string contractName)
public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports()
public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports(string contractName)
public T GetExportedValue()
public T GetExportedValue(string contractName)
public T GetExportedValueOrDefault()
public T GetExportedValueOrDefault(string contractName)
public IEnumerable`1<T> GetExportedValues()
public IEnumerable`1<T> GetExportedValues(string contractName)
private IEnumerable`1<T> GetExportedValuesCore(string contractName)
private T GetExportedValueCore(string contractName, ImportCardinality cardinality)
private IEnumerable`1<Lazy`1<T>> GetExportsCore(string contractName)
private IEnumerable`1<Lazy`2<T, TMetadataView>> GetExportsCore(string contractName)
private Lazy`2<T, TMetadataView> GetExportCore(string contractName)
private Lazy`1<T> GetExportCore(string contractName)
private IEnumerable`1<Export> GetExportsCore(Type type, Type metadataViewType, string contractName, ImportCardinality cardinality)
private ImportDefinition BuildImportDefinition(Type type, Type metadataViewType, string contractName, ImportCardinality cardinality)
public void add_ExportsChanged(EventHandler`1<ExportsChangeEventArgs> value)
public void remove_ExportsChanged(EventHandler`1<ExportsChangeEventArgs> value)
public void add_ExportsChanging(EventHandler`1<ExportsChangeEventArgs> value)
public void remove_ExportsChanging(EventHandler`1<ExportsChangeEventArgs> value)
public IEnumerable`1<Export> GetExports(ImportDefinition definition)
public IEnumerable`1<Export> GetExports(ImportDefinition definition, AtomicComposition atomicComposition)
public bool TryGetExports(ImportDefinition definition, AtomicComposition atomicComposition, IEnumerable`1& exports)
protected IEnumerable`1<Export> GetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition)
protected void OnExportsChanged(ExportsChangeEventArgs e)
protected void OnExportsChanging(ExportsChangeEventArgs e)
private ExportCardinalityCheckResult TryGetExportsCore(ImportDefinition definition, AtomicComposition atomicComposition, IEnumerable`1& exports)
}
public System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs : EventArgs {
private IEnumerable`1<ExportDefinition> _addedExports
private IEnumerable`1<ExportDefinition> _removedExports
private IEnumerable`1<string> _changedContractNames
private AtomicComposition <AtomicComposition>k__BackingField
public IEnumerable`1<ExportDefinition> AddedExports
public IEnumerable`1<ExportDefinition> RemovedExports
public IEnumerable`1<string> ChangedContractNames
public AtomicComposition AtomicComposition
public void .ctor(IEnumerable`1<ExportDefinition> addedExports, IEnumerable`1<ExportDefinition> removedExports, AtomicComposition atomicComposition)
public IEnumerable`1<ExportDefinition> get_AddedExports()
public IEnumerable`1<ExportDefinition> get_RemovedExports()
public IEnumerable`1<string> get_ChangedContractNames()
public AtomicComposition get_AtomicComposition()
private void set_AtomicComposition(AtomicComposition value)
}
public System.ComponentModel.Composition.Hosting.FilteredCatalog : ComposablePartCatalog {
private Func`2<ComposablePartDefinition, bool> _filter
private ComposablePartCatalog _innerCatalog
private FilteredCatalog _complement
private object _lock
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changed
private EventHandler`1<ComposablePartCatalogChangeEventArgs> Changing
public FilteredCatalog Complement
public FilteredCatalog IncludeDependencies()
public FilteredCatalog IncludeDependencies(Func`2<ImportDefinition, bool> importFilter)
public FilteredCatalog IncludeDependents()
public FilteredCatalog IncludeDependents(Func`2<ImportDefinition, bool> importFilter)
private FilteredCatalog Traverse(IComposablePartCatalogTraversal traversal)
private HashSet`1<ComposablePartDefinition> GetTraversalClosure(IEnumerable`1<ComposablePartDefinition> parts, IComposablePartCatalogTraversal traversal)
private void GetTraversalClosure(IEnumerable`1<ComposablePartDefinition> parts, HashSet`1<ComposablePartDefinition> traversedParts, IComposablePartCatalogTraversal traversal)
private void FreezeInnerCatalog()
private void UnfreezeInnerCatalog()
private void ThrowOnRecomposition(object sender, ComposablePartCatalogChangeEventArgs e)
public void .ctor(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter)
internal void .ctor(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter, FilteredCatalog complement)
protected void Dispose(bool disposing)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
public FilteredCatalog get_Complement()
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
protected void OnChanged(ComposablePartCatalogChangeEventArgs e)
protected void OnChanging(ComposablePartCatalogChangeEventArgs e)
private void OnChangedInternal(object sender, ComposablePartCatalogChangeEventArgs e)
private void OnChangingInternal(object sender, ComposablePartCatalogChangeEventArgs e)
private ComposablePartCatalogChangeEventArgs ProcessEventArgs(ComposablePartCatalogChangeEventArgs e)
private void ThrowIfDisposed()
private bool <get_Complement>b__23_0(ComposablePartDefinition p)
}
public System.ComponentModel.Composition.Hosting.ImportEngine : object {
private int MaximumNumberOfCompositionIterations
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private ExportProvider _sourceProvider
private Stack`1<PartManager> _recursionStateStack
private ConditionalWeakTable`2<ComposablePart, PartManager> _partManagers
private RecompositionManager _recompositionManager
private CompositionLock _lock
private CompositionOptions _compositionOptions
public void .ctor(ExportProvider sourceProvider)
public void .ctor(ExportProvider sourceProvider, bool isThreadSafe)
public void .ctor(ExportProvider sourceProvider, CompositionOptions compositionOptions)
public void PreviewImports(ComposablePart part, AtomicComposition atomicComposition)
public void SatisfyImports(ComposablePart part)
public void SatisfyImportsOnce(ComposablePart part)
public void ReleaseImports(ComposablePart part, AtomicComposition atomicComposition)
public void Dispose()
protected void Dispose(bool disposing)
private CompositionResult TryPreviewImportsStateMachine(PartManager partManager, ComposablePart part, AtomicComposition atomicComposition)
private CompositionResult TrySatisfyImportsStateMachine(PartManager partManager, ComposablePart part)
private CompositionResult TrySatisfyImports(PartManager partManager, ComposablePart part, bool shouldTrackImports)
private CompositionResult TrySatisfyImportSubset(PartManager partManager, IEnumerable`1<ImportDefinition> imports, AtomicComposition atomicComposition)
private void OnExportsChanging(object sender, ExportsChangeEventArgs e)
private CompositionResult TryRecomposeImports(PartManager partManager, IEnumerable`1<ExportDefinition> changedExports, AtomicComposition atomicComposition)
private CompositionResult TryRecomposeImport(PartManager partManager, bool partComposed, ImportDefinition import, AtomicComposition atomicComposition)
private void StartSatisfyingImports(PartManager partManager, AtomicComposition atomicComposition)
private void StopSatisfyingImports(PartManager partManager, AtomicComposition atomicComposition)
private PartManager GetPartManager(ComposablePart part, bool createIfNotpresent)
private EngineContext GetEngineContext(AtomicComposition atomicComposition)
private bool InPrerequisiteLoop()
private void ThrowIfDisposed()
private CompositionResult`1<IEnumerable`1<Export>> TryGetExports(ExportProvider provider, ComposablePart part, ImportDefinition definition, AtomicComposition atomicComposition)
internal bool IsRequiredImportForPreview(ImportDefinition import)
}
internal System.ComponentModel.Composition.Hosting.ImportSourceImportDefinitionHelpers : object {
public ImportDefinition RemoveImportSource(ImportDefinition definition)
}
public System.ComponentModel.Composition.Hosting.INotifyComposablePartCatalogChanged {
public void add_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changed(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void add_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
public void remove_Changing(EventHandler`1<ComposablePartCatalogChangeEventArgs> value)
}
public System.ComponentModel.Composition.Hosting.ScopingExtensions : object {
public bool Exports(ComposablePartDefinition part, string contractName)
public bool Imports(ComposablePartDefinition part, string contractName)
public bool Imports(ComposablePartDefinition part, string contractName, ImportCardinality importCardinality)
public bool ContainsPartMetadataWithKey(ComposablePartDefinition part, string key)
public bool ContainsPartMetadata(ComposablePartDefinition part, string key, T value)
public FilteredCatalog Filter(ComposablePartCatalog catalog, Func`2<ComposablePartDefinition, bool> filter)
}
public System.ComponentModel.Composition.Hosting.TypeCatalog : ComposablePartCatalog {
private object _thisLock
private Type[] _types
private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) _parts
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
private ICompositionElement _definitionOrigin
private Lazy`1<IDictionary`2<string, List`1<ComposablePartDefinition>>> _contractPartIndex
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
private IEnumerable`1<ComposablePartDefinition> PartsInternal
public void .ctor(Type[] types)
public void .ctor(IEnumerable`1<Type> types)
public void .ctor(IEnumerable`1<Type> types, ICompositionElement definitionOrigin)
public void .ctor(IEnumerable`1<Type> types, ReflectionContext reflectionContext)
public void .ctor(IEnumerable`1<Type> types, ReflectionContext reflectionContext, ICompositionElement definitionOrigin)
private void InitializeTypeCatalog(IEnumerable`1<Type> types, ReflectionContext reflectionContext)
private void InitializeTypeCatalog(IEnumerable`1<Type> types)
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
private IEnumerable`1<ComposablePartDefinition> get_PartsInternal()
internal IEnumerable`1<ComposablePartDefinition> GetCandidateParts(ImportDefinition definition)
private List`1<ComposablePartDefinition> GetCandidateParts(string contractName)
private IDictionary`2<string, List`1<ComposablePartDefinition>> CreateIndex()
public string ToString()
protected void Dispose(bool disposing)
private string GetDisplayName()
private string GetTypesDisplay()
private void ThrowIfDisposed()
}
internal System.ComponentModel.Composition.IAttributedImport {
public string ContractName
public Type ContractType
public bool AllowRecomposition
public CreationPolicy RequiredCreationPolicy
public ImportCardinality Cardinality
public ImportSource Source
public string get_ContractName()
public Type get_ContractType()
public bool get_AllowRecomposition()
public CreationPolicy get_RequiredCreationPolicy()
public ImportCardinality get_Cardinality()
public ImportSource get_Source()
}
public System.ComponentModel.Composition.ICompositionService {
public void SatisfyImportsOnce(ComposablePart part)
}
public System.ComponentModel.Composition.ImportAttribute : Attribute {
private string <ContractName>k__BackingField
private Type <ContractType>k__BackingField
private bool <AllowDefault>k__BackingField
private bool <AllowRecomposition>k__BackingField
private CreationPolicy <RequiredCreationPolicy>k__BackingField
private ImportSource <Source>k__BackingField
public string ContractName
public Type ContractType
public bool AllowDefault
public bool AllowRecomposition
public CreationPolicy RequiredCreationPolicy
public ImportSource Source
private ImportCardinality System.ComponentModel.Composition.IAttributedImport.Cardinality
public void .ctor(Type contractType)
public void .ctor(string contractName)
public void .ctor(string contractName, Type contractType)
public string get_ContractName()
private void set_ContractName(string value)
public Type get_ContractType()
private void set_ContractType(Type value)
public bool get_AllowDefault()
public void set_AllowDefault(bool value)
public bool get_AllowRecomposition()
public void set_AllowRecomposition(bool value)
public CreationPolicy get_RequiredCreationPolicy()
public void set_RequiredCreationPolicy(CreationPolicy value)
public ImportSource get_Source()
public void set_Source(ImportSource value)
private ImportCardinality System.ComponentModel.Composition.IAttributedImport.get_Cardinality()
}
public System.ComponentModel.Composition.ImportCardinalityMismatchException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.ComponentModel.Composition.ImportCardinalityMismatchExceptionDebuggerProxy : object {
private ImportCardinalityMismatchException _exception
public Exception InnerException
public string Message
public void .ctor(ImportCardinalityMismatchException exception)
public Exception get_InnerException()
public string get_Message()
}
public System.ComponentModel.Composition.ImportManyAttribute : Attribute {
private string <ContractName>k__BackingField
private Type <ContractType>k__BackingField
private bool <AllowRecomposition>k__BackingField
private CreationPolicy <RequiredCreationPolicy>k__BackingField
private ImportSource <Source>k__BackingField
public string ContractName
public Type ContractType
public bool AllowRecomposition
public CreationPolicy RequiredCreationPolicy
public ImportSource Source
private ImportCardinality System.ComponentModel.Composition.IAttributedImport.Cardinality
public void .ctor(Type contractType)
public void .ctor(string contractName)
public void .ctor(string contractName, Type contractType)
public string get_ContractName()
private void set_ContractName(string value)
public Type get_ContractType()
private void set_ContractType(Type value)
public bool get_AllowRecomposition()
public void set_AllowRecomposition(bool value)
public CreationPolicy get_RequiredCreationPolicy()
public void set_RequiredCreationPolicy(CreationPolicy value)
public ImportSource get_Source()
public void set_Source(ImportSource value)
private ImportCardinality System.ComponentModel.Composition.IAttributedImport.get_Cardinality()
}
public System.ComponentModel.Composition.ImportSource : Enum {
public int value__
public ImportSource Any
public ImportSource Local
public ImportSource NonLocal
}
public System.ComponentModel.Composition.InheritedExportAttribute : ExportAttribute {
public void .ctor(Type contractType)
public void .ctor(string contractName)
public void .ctor(string contractName, Type contractType)
}
public System.ComponentModel.Composition.IPartImportsSatisfiedNotification {
public void OnImportsSatisfied()
}
internal System.ComponentModel.Composition.MetadataServices : object {
public IDictionary`2<string, object> EmptyMetadata
public IDictionary`2<string, object> AsReadOnly(IDictionary`2<string, object> metadata)
public T GetValue(IDictionary`2<string, object> metadata, string key)
}
internal System.ComponentModel.Composition.MetadataViewGenerator : object {
public string MetadataViewType
public string MetadataItemKey
public string MetadataItemTargetType
public string MetadataItemSourceType
public string MetadataItemValue
private Lock _lock
private Dictionary`2<Type, Type> _proxies
private AssemblyName ProxyAssemblyName
private ModuleBuilder transparentProxyModuleBuilder
private Type[] CtorArgumentTypes
private MethodInfo _mdvDictionaryTryGet
private MethodInfo ObjectGetType
private AssemblyBuilder CreateProxyAssemblyBuilder(ConstructorInfo constructorInfo)
private ModuleBuilder GetProxyModuleBuilder(bool requiresCritical)
public Type GenerateView(Type viewType)
private void GenerateLocalAssignmentFromDefaultAttribute(ILGenerator IL, DefaultValueAttribute[] attrs, LocalBuilder local)
private void GenerateFieldAssignmentFromLocalValue(ILGenerator IL, LocalBuilder local, FieldBuilder field)
private void GenerateLocalAssignmentFromFlag(ILGenerator IL, LocalBuilder local, bool flag)
private Type GenerateInterfaceViewProxyType(Type viewType)
}
public System.ComponentModel.Composition.MetadataViewImplementationAttribute : Attribute {
private Type <ImplementationType>k__BackingField
public Type ImplementationType
public void .ctor(Type implementationType)
public Type get_ImplementationType()
private void set_ImplementationType(Type value)
}
internal System.ComponentModel.Composition.MetadataViewProvider : object {
public TMetadataView GetMetadataView(IDictionary`2<string, object> metadata)
public bool IsViewTypeValid(Type metadataViewType)
}
public System.ComponentModel.Composition.PartCreationPolicyAttribute : Attribute {
internal PartCreationPolicyAttribute Default
internal PartCreationPolicyAttribute Shared
private CreationPolicy <CreationPolicy>k__BackingField
public CreationPolicy CreationPolicy
public void .ctor(CreationPolicy creationPolicy)
public CreationPolicy get_CreationPolicy()
private void set_CreationPolicy(CreationPolicy value)
}
public System.ComponentModel.Composition.PartMetadataAttribute : Attribute {
private string <Name>k__BackingField
private object <Value>k__BackingField
public string Name
public object Value
public void .ctor(string name, object value)
public string get_Name()
private void set_Name(string value)
public object get_Value()
private void set_Value(object value)
}
public System.ComponentModel.Composition.Primitives.ComposablePart : object {
public IEnumerable`1<ExportDefinition> ExportDefinitions
public IEnumerable`1<ImportDefinition> ImportDefinitions
public IDictionary`2<string, object> Metadata
public IEnumerable`1<ExportDefinition> get_ExportDefinitions()
public IEnumerable`1<ImportDefinition> get_ImportDefinitions()
public IDictionary`2<string, object> get_Metadata()
public void Activate()
public object GetExportedValue(ExportDefinition definition)
public void SetImport(ImportDefinition definition, IEnumerable`1<Export> exports)
}
public System.ComponentModel.Composition.Primitives.ComposablePartCatalog : object {
private bool _isDisposed
private IQueryable`1 modreq(System.Runtime.CompilerServices.IsVolatile) _queryableParts
private List`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> _EmptyExportsList
public IQueryable`1<ComposablePartDefinition> Parts
public IQueryable`1<ComposablePartDefinition> get_Parts()
public IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
internal IEnumerable`1<ComposablePartDefinition> GetCandidateParts(ImportDefinition definition)
public void Dispose()
protected void Dispose(bool disposing)
private void ThrowIfDisposed()
public IEnumerator`1<ComposablePartDefinition> GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
}
internal System.ComponentModel.Composition.Primitives.ComposablePartCatalogDebuggerProxy : object {
private ComposablePartCatalog _catalog
public ReadOnlyCollection`1<ComposablePartDefinition> Parts
public void .ctor(ComposablePartCatalog catalog)
public ReadOnlyCollection`1<ComposablePartDefinition> get_Parts()
}
public System.ComponentModel.Composition.Primitives.ComposablePartDefinition : object {
internal IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> _EmptyExports
public IEnumerable`1<ExportDefinition> ExportDefinitions
public IEnumerable`1<ImportDefinition> ImportDefinitions
public IDictionary`2<string, object> Metadata
public IEnumerable`1<ExportDefinition> get_ExportDefinitions()
public IEnumerable`1<ImportDefinition> get_ImportDefinitions()
public IDictionary`2<string, object> get_Metadata()
public ComposablePart CreatePart()
internal IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
internal ComposablePartDefinition GetGenericPartDefinition()
}
public System.ComponentModel.Composition.Primitives.ComposablePartException : Exception {
private ICompositionElement _element
public ICompositionElement Element
public void .ctor(string message)
public void .ctor(string message, ICompositionElement element)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, ICompositionElement element, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public ICompositionElement get_Element()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.ComponentModel.Composition.Primitives.ComposablePartExceptionDebuggerProxy : object {
private ComposablePartException _exception
public ICompositionElement Element
public Exception InnerException
public string Message
public void .ctor(ComposablePartException exception)
public ICompositionElement get_Element()
public Exception get_InnerException()
public string get_Message()
}
internal System.ComponentModel.Composition.Primitives.CompositionElement : SerializableCompositionElement {
private ICompositionElement UnknownOrigin
private object _underlyingObject
public object UnderlyingObject
public void .ctor(object underlyingObject)
public object get_UnderlyingObject()
}
internal System.ComponentModel.Composition.Primitives.CompositionElementDebuggerProxy : object {
private CompositionElement _element
public string DisplayName
public ICompositionElement Origin
public object UnderlyingObject
public void .ctor(CompositionElement element)
public string get_DisplayName()
public ICompositionElement get_Origin()
public object get_UnderlyingObject()
}
internal System.ComponentModel.Composition.Primitives.CompositionElementExtensions : object {
public ICompositionElement ToSerializableElement(ICompositionElement element)
public ICompositionElement ToElement(Export export)
public ICompositionElement ToElement(ExportDefinition definition)
public ICompositionElement ToElement(ImportDefinition definition)
public ICompositionElement ToElement(ComposablePart part)
public ICompositionElement ToElement(ComposablePartDefinition definition)
public string GetDisplayName(ComposablePartDefinition definition)
public string GetDisplayName(ComposablePartCatalog catalog)
private string GetDisplayNameCore(object value)
private ICompositionElement ToElementCore(object value)
}
public System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : ImportDefinition {
private IEnumerable`1<KeyValuePair`2<string, Type>> _requiredMetadata
private Expression`1<Func`2<ExportDefinition, bool>> _constraint
private CreationPolicy _requiredCreationPolicy
private string _requiredTypeIdentity
private bool _isRequiredMetadataValidated
public string RequiredTypeIdentity
public IEnumerable`1<KeyValuePair`2<string, Type>> RequiredMetadata
public CreationPolicy RequiredCreationPolicy
public Expression`1<Func`2<ExportDefinition, bool>> Constraint
public void .ctor(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy)
public void .ctor(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata)
public string get_RequiredTypeIdentity()
public IEnumerable`1<KeyValuePair`2<string, Type>> get_RequiredMetadata()
private void ValidateRequiredMetadata()
public CreationPolicy get_RequiredCreationPolicy()
public Expression`1<Func`2<ExportDefinition, bool>> get_Constraint()
public bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition)
private bool MatchRequiredMatadata(ExportDefinition definition)
public string ToString()
}
public System.ComponentModel.Composition.Primitives.Export : object {
private ExportDefinition _definition
private Func`1<object> _exportedValueGetter
private object _EmptyValue
private Object modreq(System.Runtime.CompilerServices.IsVolatile) _exportedValue
public ExportDefinition Definition
public IDictionary`2<string, object> Metadata
public object Value
public void .ctor(string contractName, Func`1<object> exportedValueGetter)
public void .ctor(string contractName, IDictionary`2<string, object> metadata, Func`1<object> exportedValueGetter)
public void .ctor(ExportDefinition definition, Func`1<object> exportedValueGetter)
public ExportDefinition get_Definition()
public IDictionary`2<string, object> get_Metadata()
public object get_Value()
protected object GetExportedValueCore()
}
public System.ComponentModel.Composition.Primitives.ExportDefinition : object {
private IDictionary`2<string, object> _metadata
private string _contractName
public string ContractName
public IDictionary`2<string, object> Metadata
public void .ctor(string contractName, IDictionary`2<string, object> metadata)
public string get_ContractName()
public IDictionary`2<string, object> get_Metadata()
public string ToString()
}
public System.ComponentModel.Composition.Primitives.ExportedDelegate : object {
private object _instance
private MethodInfo _method
public void .ctor(object instance, MethodInfo method)
public Delegate CreateDelegate(Type delegateType)
private Type CreateStandardDelegateType()
}
public System.ComponentModel.Composition.Primitives.ICompositionElement {
public string DisplayName
public ICompositionElement Origin
public string get_DisplayName()
public ICompositionElement get_Origin()
}
public System.ComponentModel.Composition.Primitives.ImportCardinality : Enum {
public int value__
public ImportCardinality ZeroOrOne
public ImportCardinality ExactlyOne
public ImportCardinality ZeroOrMore
}
public System.ComponentModel.Composition.Primitives.ImportDefinition : object {
internal string EmptyContractName
private Expression`1<Func`2<ExportDefinition, bool>> _constraint
private ImportCardinality _cardinality
private string _contractName
private bool _isRecomposable
private bool _isPrerequisite
private Func`2<ExportDefinition, bool> _compiledConstraint
private IDictionary`2<string, object> _metadata
public string ContractName
public IDictionary`2<string, object> Metadata
public ImportCardinality Cardinality
public Expression`1<Func`2<ExportDefinition, bool>> Constraint
public bool IsPrerequisite
public bool IsRecomposable
public void .ctor(Expression`1<Func`2<ExportDefinition, bool>> constraint, string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite)
public void .ctor(Expression`1<Func`2<ExportDefinition, bool>> constraint, string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, IDictionary`2<string, object> metadata)
internal void .ctor(string contractName, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, IDictionary`2<string, object> metadata)
public string get_ContractName()
public IDictionary`2<string, object> get_Metadata()
public ImportCardinality get_Cardinality()
public Expression`1<Func`2<ExportDefinition, bool>> get_Constraint()
public bool get_IsPrerequisite()
public bool get_IsRecomposable()
public bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition)
public string ToString()
}
internal System.ComponentModel.Composition.Primitives.IPartCreatorImportDefinition {
public ContractBasedImportDefinition ProductImportDefinition
public ContractBasedImportDefinition get_ProductImportDefinition()
}
internal System.ComponentModel.Composition.Primitives.PrimitivesServices : object {
public bool IsGeneric(ComposablePartDefinition part)
public ImportDefinition GetProductImportDefinition(ImportDefinition import)
internal IEnumerable`1<string> GetCandidateContractNames(ImportDefinition import, ComposablePartDefinition part)
internal bool IsImportDependentOnPart(ImportDefinition import, ComposablePartDefinition part, ExportDefinition export, bool expandGenerics)
private ImportDefinition TranslateImport(ImportDefinition import, ComposablePartDefinition part)
}
internal System.ComponentModel.Composition.Primitives.SerializableCompositionElement : object {
private string _displayName
private ICompositionElement _origin
public string DisplayName
public ICompositionElement Origin
public void .ctor(string displayName, ICompositionElement origin)
public string get_DisplayName()
public ICompositionElement get_Origin()
public string ToString()
public ICompositionElement FromICompositionElement(ICompositionElement element)
}
internal System.ComponentModel.Composition.ReflectionModel.DisposableReflectionComposablePart : ReflectionComposablePart {
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed
public void .ctor(ReflectionComposablePartDefinition definition)
protected void ReleaseInstanceIfNecessary(object instance)
protected void EnsureRunning()
private void System.IDisposable.Dispose()
}
internal System.ComponentModel.Composition.ReflectionModel.ExportFactoryCreator : object {
private MethodInfo _createStronglyTypedExportFactoryOfT
private MethodInfo _createStronglyTypedExportFactoryOfTM
private Type _exportFactoryType
public void .ctor(Type exportFactoryType)
public Func`2<Export, object> CreateStronglyTypedExportFactoryFactory(Type exportType, Type metadataViewType)
private object CreateStronglyTypedExportFactoryOfT(Export export)
private object CreateStronglyTypedExportFactoryOfTM(Export export)
}
internal System.ComponentModel.Composition.ReflectionModel.ExportingMember : object {
private ExportDefinition _definition
private ReflectionMember _member
private object _cachedValue
private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isValueCached
public bool RequiresInstance
public ExportDefinition Definition
public void .ctor(ExportDefinition definition, ReflectionMember member)
public bool get_RequiresInstance()
public ExportDefinition get_Definition()
public object GetExportedValue(object instance, object lock)
private void EnsureReadable()
}
internal System.ComponentModel.Composition.ReflectionModel.GenericServices : object {
internal IList`1<Type> GetPureGenericParameters(Type type)
internal int GetPureGenericArity(Type type)
private void TraverseGenericType(Type type, Action`1<Type> onType)
public Int32[] GetGenericParametersOrder(Type type)
public string GetGenericName(string originalGenericName, Int32[] genericParametersOrder, int genericArity)
public T[] Reorder(T[] original, Int32[] genericParametersOrder)
public IEnumerable`1<Type> CreateTypeSpecializations(Type[] types, Type[] specializationTypes)
public Type CreateTypeSpecialization(Type type, Type[] specializationTypes)
public bool CanSpecialize(Type type, IEnumerable`1<Type> constraints, GenericParameterAttributes attributes)
public bool CanSpecialize(Type type, IEnumerable`1<Type> constraintTypes)
public bool CanSpecialize(Type type, GenericParameterAttributes attributes)
}
internal System.ComponentModel.Composition.ReflectionModel.GenericSpecializationPartCreationInfo : object {
private IReflectionPartCreationInfo _originalPartCreationInfo
private ReflectionComposablePartDefinition _originalPart
private Type[] _specialization
private String[] _specializationIdentities
private IEnumerable`1<ExportDefinition> _exports
private IEnumerable`1<ImportDefinition> _imports
private Lazy`1<Type> _lazyPartType
private List`1<LazyMemberInfo> _members
private List`1<Lazy`1<ParameterInfo>> _parameters
private Dictionary`2<LazyMemberInfo, MemberInfo[]> _membersTable
private Dictionary`2<Lazy`1<ParameterInfo>, ParameterInfo> _parametersTable
private ConstructorInfo _constructor
private object _lock
public ReflectionComposablePartDefinition OriginalPart
public bool IsDisposalRequired
public string DisplayName
public ICompositionElement Origin
public void .ctor(IReflectionPartCreationInfo originalPartCreationInfo, ReflectionComposablePartDefinition originalPart, Type[] specialization)
public ReflectionComposablePartDefinition get_OriginalPart()
public Type GetPartType()
public Lazy`1<Type> GetLazyPartType()
public ConstructorInfo GetConstructor()
public IDictionary`2<string, object> GetMetadata()
private MemberInfo[] GetAccessors(LazyMemberInfo originalLazyMember)
private ParameterInfo GetParameter(Lazy`1<ParameterInfo> originalParameter)
private void BuildTables()
private Dictionary`2<LazyMemberInfo, MemberInfo[]> BuildMembersTable(List`1<LazyMemberInfo> members)
private Dictionary`2<Lazy`1<ParameterInfo>, ParameterInfo> BuildParametersTable(List`1<Lazy`1<ParameterInfo>> parameters)
private List`1<ImportDefinition> PopulateImports(List`1<LazyMemberInfo> members, List`1<Lazy`1<ParameterInfo>> parameters)
private ImportDefinition TranslateImport(ReflectionImportDefinition reflectionImport, List`1<LazyMemberInfo> members, List`1<Lazy`1<ParameterInfo>> parameters)
private List`1<ExportDefinition> PopulateExports(List`1<LazyMemberInfo> members)
public ExportDefinition TranslateExpot(ReflectionMemberExportDefinition reflectionExport, List`1<LazyMemberInfo> members)
private string Translate(string originalValue, Int32[] genericParametersOrder)
private string Translate(string originalValue)
private IDictionary`2<string, object> TranslateImportMetadata(ContractBasedImportDefinition originalImport)
private IDictionary`2<string, object> TranslateExportMetadata(ReflectionMemberExportDefinition originalExport)
private void PopulateImportsAndExports()
public IEnumerable`1<ExportDefinition> GetExports()
public IEnumerable`1<ImportDefinition> GetImports()
public bool get_IsDisposalRequired()
public string get_DisplayName()
public ICompositionElement get_Origin()
public bool Equals(object obj)
public int GetHashCode()
public bool CanSpecialize(IDictionary`2<string, object> partMetadata, Type[] specialization)
}
internal System.ComponentModel.Composition.ReflectionModel.ImportingItem : object {
private ContractBasedImportDefinition _definition
private ImportType _importType
public ContractBasedImportDefinition Definition
public ImportType ImportType
protected void .ctor(ContractBasedImportDefinition definition, ImportType importType)
public ContractBasedImportDefinition get_Definition()
public ImportType get_ImportType()
public object CastExportsToImportType(Export[] exports)
private object CastExportsToCollectionImportType(Export[] exports)
private object CastExportsToSingleImportType(Export[] exports)
private object CastSingleExportToImportType(Type type, Export export)
private object Cast(Type type, Export export)
}
internal System.ComponentModel.Composition.ReflectionModel.ImportingMember : ImportingItem {
private ReflectionWritableMember _member
public void .ctor(ContractBasedImportDefinition definition, ReflectionWritableMember member, ImportType importType)
public void SetExportedValue(object instance, object value)
private bool RequiresCollectionNormalization()
private void SetSingleMemberValue(object instance, object value)
private void EnsureWritable()
private void SetCollectionMemberValue(object instance, IEnumerable values)
private ICollection`1<object> GetNormalizedCollection(Type itemType, object instance)
private void EnsureCollectionIsWritable(ICollection`1<object> collection)
private void PopulateCollection(ICollection`1<object> collection, IEnumerable values)
}
internal System.ComponentModel.Composition.ReflectionModel.ImportingParameter : ImportingItem {
public void .ctor(ContractBasedImportDefinition definition, ImportType importType)
}
internal System.ComponentModel.Composition.ReflectionModel.ImportType : object {
private Type LazyOfTType
private Type LazyOfTMType
private Type ExportFactoryOfTType
private Type ExportFactoryOfTMType
private Type _type
private bool _isAssignableCollectionType
private Type _contractType
private Func`2<Export, object> _castSingleValue
private bool _isOpenGeneric
private Type <ElementType>k__BackingField
private bool <IsPartCreator>k__BackingField
private Type <MetadataViewType>k__BackingField
public bool IsAssignableCollectionType
public Type ElementType
public Type ActualType
public bool IsPartCreator
public Type ContractType
public Func`2<Export, object> CastExport
public Type MetadataViewType
public void .ctor(Type type, ImportCardinality cardinality)
public bool get_IsAssignableCollectionType()
public Type get_ElementType()
private void set_ElementType(Type value)
public Type get_ActualType()
public bool get_IsPartCreator()
private void set_IsPartCreator(bool value)
public Type get_ContractType()
public Func`2<Export, object> get_CastExport()
public Type get_MetadataViewType()
private void set_MetadataViewType(Type value)
private Type CheckForCollection(Type type)
private bool IsGenericDescendentOf(Type type, Type baseGenericTypeDefinition)
public bool IsDescendentOf(Type type, Type baseType)
private Type CheckForLazyAndPartCreator(Type type)
private bool IsTypeAssignableCollectionType(Type type)
}
internal System.ComponentModel.Composition.ReflectionModel.IReflectionPartCreationInfo {
public bool IsDisposalRequired
public Type GetPartType()
public Lazy`1<Type> GetLazyPartType()
public ConstructorInfo GetConstructor()
public IDictionary`2<string, object> GetMetadata()
public IEnumerable`1<ExportDefinition> GetExports()
public IEnumerable`1<ImportDefinition> GetImports()
public bool get_IsDisposalRequired()
}
internal System.ComponentModel.Composition.ReflectionModel.LazyExportDefinition : ExportDefinition {
private Lazy`1<IDictionary`2<string, object>> _metadata
public IDictionary`2<string, object> Metadata
public void .ctor(string contractName, Lazy`1<IDictionary`2<string, object>> metadata)
public IDictionary`2<string, object> get_Metadata()
}
public System.ComponentModel.Composition.ReflectionModel.LazyMemberInfo : ValueType {
private MemberTypes _memberType
private MemberInfo[] _accessors
private Func`1<MemberInfo[]> _accessorsCreator
public MemberTypes MemberType
public void .ctor(MemberInfo member)
public void .ctor(MemberTypes memberType, MemberInfo[] accessors)
public void .ctor(MemberTypes memberType, Func`1<MemberInfo[]> accessorsCreator)
public MemberTypes get_MemberType()
public MemberInfo[] GetAccessors()
public int GetHashCode()
public bool Equals(object obj)
public bool op_Equality(LazyMemberInfo left, LazyMemberInfo right)
public bool op_Inequality(LazyMemberInfo left, LazyMemberInfo right)
private void EnsureSupportedMemberType(MemberTypes memberType, string argument)
private bool AreAccessorsValid(MemberTypes memberType, MemberInfo[] accessors, String& errorMessage)
}
internal System.ComponentModel.Composition.ReflectionModel.PartCreatorExportDefinition : ExportDefinition {
private ExportDefinition _productDefinition
private IDictionary`2<string, object> _metadata
public string ContractName
public IDictionary`2<string, object> Metadata
public void .ctor(ExportDefinition productDefinition)
public string get_ContractName()
public IDictionary`2<string, object> get_Metadata()
internal bool IsProductConstraintSatisfiedBy(ImportDefinition productImportDefinition, ExportDefinition exportDefinition)
}
internal System.ComponentModel.Composition.ReflectionModel.PartCreatorMemberImportDefinition : ReflectionMemberImportDefinition {
private ContractBasedImportDefinition _productImportDefinition
public ContractBasedImportDefinition ProductImportDefinition
public Expression`1<Func`2<ExportDefinition, bool>> Constraint
public void .ctor(LazyMemberInfo importingLazyMember, ICompositionElement origin, ContractBasedImportDefinition productImportDefinition)
public ContractBasedImportDefinition get_ProductImportDefinition()
public bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition)
public Expression`1<Func`2<ExportDefinition, bool>> get_Constraint()
}
internal System.ComponentModel.Composition.ReflectionModel.PartCreatorParameterImportDefinition : ReflectionParameterImportDefinition {
private ContractBasedImportDefinition _productImportDefinition
public ContractBasedImportDefinition ProductImportDefinition
public Expression`1<Func`2<ExportDefinition, bool>> Constraint
public void .ctor(Lazy`1<ParameterInfo> importingLazyParameter, ICompositionElement origin, ContractBasedImportDefinition productImportDefinition)
public ContractBasedImportDefinition get_ProductImportDefinition()
public bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition)
public Expression`1<Func`2<ExportDefinition, bool>> get_Constraint()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionComposablePart : ComposablePart {
private ReflectionComposablePartDefinition _definition
private Dictionary`2<ImportDefinition, object> _importValues
private Dictionary`2<ImportDefinition, ImportingItem> _importsCache
private Dictionary`2<int, ExportingMember> _exportsCache
private bool _invokeImportsSatisfied
private bool _invokingImportsSatisfied
private bool _initialCompositionComplete
private Object modreq(System.Runtime.CompilerServices.IsVolatile) _cachedInstance
private object _lock
protected object CachedInstance
public ReflectionComposablePartDefinition Definition
public IDictionary`2<string, object> Metadata
public IEnumerable`1<ImportDefinition> ImportDefinitions
public IEnumerable`1<ExportDefinition> ExportDefinitions
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(ReflectionComposablePartDefinition definition)
public void .ctor(ReflectionComposablePartDefinition definition, object attributedPart)
protected void EnsureRunning()
protected void RequiresRunning()
protected void ReleaseInstanceIfNecessary(object instance)
protected object get_CachedInstance()
public ReflectionComposablePartDefinition get_Definition()
public IDictionary`2<string, object> get_Metadata()
public IEnumerable`1<ImportDefinition> get_ImportDefinitions()
public IEnumerable`1<ExportDefinition> get_ExportDefinitions()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public object GetExportedValue(ExportDefinition definition)
public void SetImport(ImportDefinition definition, IEnumerable`1<Export> exports)
public void Activate()
public string ToString()
private object GetExportedValue(ExportingMember member)
private void SetImport(ImportingItem item, Export[] exports)
private object GetInstanceActivatingIfNeeded()
private Object[] GetConstructorArguments()
private bool RequiresActivation()
private void EnsureGettable()
private void EnsureSettable(ImportDefinition definition)
private void EnsureCardinality(ImportDefinition definition, Export[] exports)
private object CreateInstance(ConstructorInfo constructor, Object[] arguments)
private void SetNonPrerequisiteImports()
private void SetPrerequisiteImports()
private void SetExportedValueForImport(ImportingItem import, ImportDefinition definition, object value)
private void UseImportedValues(IEnumerable`1<TImportDefinition> definitions, Action`3<ImportingItem, TImportDefinition, object> useImportValue, bool errorIfMissing)
private bool TryGetImportValue(ImportDefinition definition, Object& value)
private void NotifyImportSatisfied()
private ExportingMember GetExportingMemberFromDefinition(ExportDefinition definition)
private ImportingItem GetImportingItemFromDefinition(ImportDefinition definition)
private ImportingItem GetImportingItem(ImportDefinition definition)
private ExportingMember GetExportingMember(ExportDefinition definition)
private string GetDisplayName()
private bool <RequiresActivation>b__36_0(ExportDefinition definition)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionComposablePartDefinition : ComposablePartDefinition {
private IReflectionPartCreationInfo _creationInfo
private IEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) _imports
private IEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) _exports
private IDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _metadata
private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _constructor
private object _lock
public IEnumerable`1<ExportDefinition> ExportDefinitions
public IEnumerable`1<ImportDefinition> ImportDefinitions
public IDictionary`2<string, object> Metadata
internal bool IsDisposalRequired
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(IReflectionPartCreationInfo creationInfo)
public Type GetPartType()
public Lazy`1<Type> GetLazyPartType()
public ConstructorInfo GetConstructor()
public IEnumerable`1<ExportDefinition> get_ExportDefinitions()
public IEnumerable`1<ImportDefinition> get_ImportDefinitions()
public IDictionary`2<string, object> get_Metadata()
internal bool get_IsDisposalRequired()
public ComposablePart CreatePart()
internal ComposablePartDefinition GetGenericPartDefinition()
internal IEnumerable`1<Tuple`2<ComposablePartDefinition, ExportDefinition>> GetExports(ImportDefinition definition)
private IEnumerable`1<Type[]> GetCandidateParameters(Type[] genericParameters)
private bool TryGetGenericTypeParameters(IEnumerable`1<object> genericParameters, Type[]& genericTypeParameters)
internal bool TryMakeGenericPartDefinition(Type[] genericTypeParameters, ComposablePartDefinition& genericPartDefinition)
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionExtensions : object {
public ReflectionMember ToReflectionMember(LazyMemberInfo lazyMember)
public LazyMemberInfo ToLazyMember(MemberInfo member)
public ReflectionWritableMember ToReflectionWriteableMember(LazyMemberInfo lazyMember)
public ReflectionProperty ToReflectionProperty(PropertyInfo property)
public ReflectionProperty CreateReflectionProperty(MethodInfo getMethod, MethodInfo setMethod)
public ReflectionParameter ToReflectionParameter(ParameterInfo parameter)
public ReflectionMethod ToReflectionMethod(MethodInfo method)
public ReflectionField ToReflectionField(FieldInfo field)
public ReflectionType ToReflectionType(Type type)
public ReflectionWritableMember ToReflectionWritableMember(MemberInfo member)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionField : ReflectionWritableMember {
private FieldInfo _field
public FieldInfo UndelyingField
public MemberInfo UnderlyingMember
public bool CanRead
public bool CanWrite
public bool RequiresInstance
public Type ReturnType
public ReflectionItemType ItemType
public void .ctor(FieldInfo field)
public FieldInfo get_UndelyingField()
public MemberInfo get_UnderlyingMember()
public bool get_CanRead()
public bool get_CanWrite()
public bool get_RequiresInstance()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
public object GetValue(object instance)
public void SetValue(object instance, object value)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionImportDefinition : ContractBasedImportDefinition {
private ICompositionElement _origin
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin)
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public ImportingItem ToImportingItem()
protected string GetDisplayName()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionItem : object {
public string Name
public Type ReturnType
public ReflectionItemType ItemType
public string get_Name()
public string GetDisplayName()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionItemType : Enum {
public int value__
public ReflectionItemType Parameter
public ReflectionItemType Field
public ReflectionItemType Property
public ReflectionItemType Method
public ReflectionItemType Type
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionMember : ReflectionItem {
public bool CanRead
public Type DeclaringType
public string Name
public bool RequiresInstance
public MemberInfo UnderlyingMember
public bool get_CanRead()
public Type get_DeclaringType()
public string get_Name()
public string GetDisplayName()
public bool get_RequiresInstance()
public MemberInfo get_UnderlyingMember()
public object GetValue(object instance)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionMemberExportDefinition : ExportDefinition {
private LazyMemberInfo _member
private ExportDefinition _exportDefinition
private ICompositionElement _origin
private IDictionary`2<string, object> _metadata
public string ContractName
public LazyMemberInfo ExportingLazyMember
public IDictionary`2<string, object> Metadata
private string System.ComponentModel.Composition.Primitives.ICompositionElement.DisplayName
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.Origin
public void .ctor(LazyMemberInfo member, ExportDefinition exportDefinition, ICompositionElement origin)
public string get_ContractName()
public LazyMemberInfo get_ExportingLazyMember()
public IDictionary`2<string, object> get_Metadata()
private string System.ComponentModel.Composition.Primitives.ICompositionElement.get_DisplayName()
private ICompositionElement System.ComponentModel.Composition.Primitives.ICompositionElement.get_Origin()
public string ToString()
public int GetIndex()
public ExportingMember ToExportingMember()
private ReflectionMember ToReflectionMember()
private string GetDisplayName()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionMemberImportDefinition : ReflectionImportDefinition {
private LazyMemberInfo _importingLazyMember
public LazyMemberInfo ImportingLazyMember
public void .ctor(LazyMemberInfo importingLazyMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin)
public ImportingItem ToImportingItem()
public LazyMemberInfo get_ImportingLazyMember()
protected string GetDisplayName()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionMethod : ReflectionMember {
private MethodInfo _method
public MethodInfo UnderlyingMethod
public MemberInfo UnderlyingMember
public bool CanRead
public bool RequiresInstance
public Type ReturnType
public ReflectionItemType ItemType
public void .ctor(MethodInfo method)
public MethodInfo get_UnderlyingMethod()
public MemberInfo get_UnderlyingMember()
public bool get_CanRead()
public bool get_RequiresInstance()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
public object GetValue(object instance)
private ExportedDelegate SafeCreateExportedDelegate(object instance, MethodInfo method)
}
public System.ComponentModel.Composition.ReflectionModel.ReflectionModelServices : object {
public Lazy`1<Type> GetPartType(ComposablePartDefinition partDefinition)
public bool IsDisposalRequired(ComposablePartDefinition partDefinition)
public LazyMemberInfo GetExportingMember(ExportDefinition exportDefinition)
public LazyMemberInfo GetImportingMember(ImportDefinition importDefinition)
public Lazy`1<ParameterInfo> GetImportingParameter(ImportDefinition importDefinition)
public bool IsImportingParameter(ImportDefinition importDefinition)
public bool IsExportFactoryImportDefinition(ImportDefinition importDefinition)
public ContractBasedImportDefinition GetExportFactoryProductImportDefinition(ImportDefinition importDefinition)
public ComposablePartDefinition CreatePartDefinition(Lazy`1<Type> partType, bool isDisposalRequired, Lazy`1<IEnumerable`1<ImportDefinition>> imports, Lazy`1<IEnumerable`1<ExportDefinition>> exports, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin)
public ExportDefinition CreateExportDefinition(LazyMemberInfo exportingMember, string contractName, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin)
public ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, CreationPolicy requiredCreationPolicy, ICompositionElement origin)
public ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin)
public ContractBasedImportDefinition CreateImportDefinition(LazyMemberInfo importingMember, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPreRequisite, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin)
public ContractBasedImportDefinition CreateImportDefinition(Lazy`1<ParameterInfo> parameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, ICompositionElement origin)
public ContractBasedImportDefinition CreateImportDefinition(Lazy`1<ParameterInfo> parameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, bool isExportFactory, ICompositionElement origin)
public bool TryMakeGenericPartDefinition(ComposablePartDefinition partDefinition, IEnumerable`1<Type> genericParameters, ComposablePartDefinition& specialization)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionParameter : ReflectionItem {
private ParameterInfo _parameter
public ParameterInfo UnderlyingParameter
public string Name
public Type ReturnType
public ReflectionItemType ItemType
public void .ctor(ParameterInfo parameter)
public ParameterInfo get_UnderlyingParameter()
public string get_Name()
public string GetDisplayName()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionParameterImportDefinition : ReflectionImportDefinition {
private Lazy`1<ParameterInfo> _importingLazyParameter
public Lazy`1<ParameterInfo> ImportingLazyParameter
public void .ctor(Lazy`1<ParameterInfo> importingLazyParameter, string contractName, string requiredTypeIdentity, IEnumerable`1<KeyValuePair`2<string, Type>> requiredMetadata, ImportCardinality cardinality, CreationPolicy requiredCreationPolicy, IDictionary`2<string, object> metadata, ICompositionElement origin)
public ImportingItem ToImportingItem()
public Lazy`1<ParameterInfo> get_ImportingLazyParameter()
protected string GetDisplayName()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionPartCreationInfo : object {
private Lazy`1<Type> _partType
private Lazy`1<IEnumerable`1<ImportDefinition>> _imports
private Lazy`1<IEnumerable`1<ExportDefinition>> _exports
private Lazy`1<IDictionary`2<string, object>> _metadata
private ICompositionElement _origin
private ConstructorInfo _constructor
private bool _isDisposalRequired
public bool IsDisposalRequired
public string DisplayName
public ICompositionElement Origin
public void .ctor(Lazy`1<Type> partType, bool isDisposalRequired, Lazy`1<IEnumerable`1<ImportDefinition>> imports, Lazy`1<IEnumerable`1<ExportDefinition>> exports, Lazy`1<IDictionary`2<string, object>> metadata, ICompositionElement origin)
public Type GetPartType()
public Lazy`1<Type> GetLazyPartType()
public ConstructorInfo GetConstructor()
public bool get_IsDisposalRequired()
public IDictionary`2<string, object> GetMetadata()
public IEnumerable`1<ExportDefinition> GetExports()
public IEnumerable`1<ImportDefinition> GetImports()
public string get_DisplayName()
public ICompositionElement get_Origin()
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionProperty : ReflectionWritableMember {
private MethodInfo _getMethod
private MethodInfo _setMethod
public MemberInfo UnderlyingMember
public bool CanRead
public bool CanWrite
public MethodInfo UnderlyingGetMethod
public MethodInfo UnderlyingSetMethod
public string Name
public bool RequiresInstance
public Type ReturnType
public ReflectionItemType ItemType
public void .ctor(MethodInfo getMethod, MethodInfo setMethod)
public MemberInfo get_UnderlyingMember()
public bool get_CanRead()
public bool get_CanWrite()
public MethodInfo get_UnderlyingGetMethod()
public MethodInfo get_UnderlyingSetMethod()
public string get_Name()
public string GetDisplayName()
public bool get_RequiresInstance()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
public object GetValue(object instance)
public void SetValue(object instance, object value)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionType : ReflectionMember {
private Type _type
public MemberInfo UnderlyingMember
public bool CanRead
public bool RequiresInstance
public Type ReturnType
public ReflectionItemType ItemType
public void .ctor(Type type)
public MemberInfo get_UnderlyingMember()
public bool get_CanRead()
public bool get_RequiresInstance()
public Type get_ReturnType()
public ReflectionItemType get_ItemType()
public object GetValue(object instance)
}
internal System.ComponentModel.Composition.ReflectionModel.ReflectionWritableMember : ReflectionMember {
public bool CanWrite
public bool get_CanWrite()
public void SetValue(object instance, object value)
}
internal System.ComponentModel.LocalizableAttribute : Attribute {
public void .ctor(bool isLocalizable)
}
public System.Lazy`2 : Lazy`1<T> {
private TMetadata _metadata
public TMetadata Metadata
public void .ctor(Func`1<T> valueFactory, TMetadata metadata)
public void .ctor(TMetadata metadata)
public void .ctor(TMetadata metadata, bool isThreadSafe)
public void .ctor(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe)
public void .ctor(TMetadata metadata, LazyThreadSafetyMode mode)
public void .ctor(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode)
public TMetadata get_Metadata()
}
internal Unity.ThrowStub : ObjectDisposedException {
public void ThrowNotSupportedException()
}
