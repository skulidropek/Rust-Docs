public Oxide.EnvironmentHelper : object {
public string GetVariable(string key)
public void SetVariable(string key, string value, bool throwOnExisting, bool force)
private string NormalizeKey(string key)
}
public Oxide.ExtensionMethods : object {
public AssemblyMetadataAttribute[] Metadata(Assembly assembly)
public String[] Metadata(Assembly assembly, string key)
public HashSet`1<T> ToHashSet(IEnumerable`1<T> collection)
public bool TryPop(Stack`1<T> stack, T& value)
public bool TryPeek(Stack`1<T> stack, T& value)
public bool TryDequeue(Queue`1<T> queue, T& value)
public bool TryPeek(Queue`1<T> queue, T& value)
}
public Oxide.Pooling.IArrayPoolProvider`1 {
public T[] Take(int length)
}
public Oxide.Pooling.IPoolFactory {
public IPoolProvider`1<T> GetProvider()
public bool IsHandledType()
public IDisposable RegisterProvider(TProvider& provider, Object[] args)
}
public Oxide.Pooling.IPoolProvider {
public void Return(object item)
}
public Oxide.Pooling.IPoolProvider`1 {
public T Take()
}
public Oxide.Pooling.PoolingExtensions : object {
public IArrayPoolProvider`1<T> GetArrayProvider(IPoolFactory factory)
public T[] PooledCopy(IArrayPoolProvider`1<T> provider, T[] source, int offset, int count)
public T[] PooledCopy(IPoolFactory factory, T[] source, int offset, int count)
}
public System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
private bool <ParameterValue>k__BackingField
public bool ParameterValue
public void .ctor(bool parameterValue)
public bool get_ParameterValue()
}
public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
public DynamicallyAccessedMemberTypes MemberTypes
public void .ctor(DynamicallyAccessedMemberTypes memberTypes)
public DynamicallyAccessedMemberTypes get_MemberTypes()
}
public System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
public int value__
public DynamicallyAccessedMemberTypes None
public DynamicallyAccessedMemberTypes PublicParameterlessConstructor
public DynamicallyAccessedMemberTypes PublicConstructors
public DynamicallyAccessedMemberTypes NonPublicConstructors
public DynamicallyAccessedMemberTypes PublicMethods
public DynamicallyAccessedMemberTypes NonPublicMethods
public DynamicallyAccessedMemberTypes PublicFields
public DynamicallyAccessedMemberTypes NonPublicFields
public DynamicallyAccessedMemberTypes PublicNestedTypes
public DynamicallyAccessedMemberTypes NonPublicNestedTypes
public DynamicallyAccessedMemberTypes PublicProperties
public DynamicallyAccessedMemberTypes NonPublicProperties
public DynamicallyAccessedMemberTypes PublicEvents
public DynamicallyAccessedMemberTypes NonPublicEvents
public DynamicallyAccessedMemberTypes Interfaces
public DynamicallyAccessedMemberTypes All
}
public System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
private string <MemberSignature>k__BackingField
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField
private Type <Type>k__BackingField
private string <TypeName>k__BackingField
private string <AssemblyName>k__BackingField
private string <Condition>k__BackingField
public string MemberSignature
public DynamicallyAccessedMemberTypes MemberTypes
public Type Type
public string TypeName
public string AssemblyName
public string Condition
public void .ctor(string memberSignature)
public void .ctor(string memberSignature, Type type)
public void .ctor(string memberSignature, string typeName, string assemblyName)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, Type type)
public void .ctor(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
public string get_MemberSignature()
public DynamicallyAccessedMemberTypes get_MemberTypes()
public Type get_Type()
public string get_TypeName()
public string get_AssemblyName()
public string get_Condition()
public void set_Condition(string value)
}
public System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
public System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
private String[] <Members>k__BackingField
public String[] Members
public void .ctor(string member)
public void .ctor(String[] members)
public String[] get_Members()
}
public System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
private String[] <Members>k__BackingField
public bool ReturnValue
public String[] Members
public void .ctor(bool returnValue, string member)
public void .ctor(bool returnValue, String[] members)
public bool get_ReturnValue()
public String[] get_Members()
}
public System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
public System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
private bool <ReturnValue>k__BackingField
public bool ReturnValue
public void .ctor(bool returnValue)
public bool get_ReturnValue()
}
public System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
public System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
public System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
public System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
private string <Syntax>k__BackingField
private Object[] <Arguments>k__BackingField
public string CompositeFormat
public string DateOnlyFormat
public string DateTimeFormat
public string EnumFormat
public string GuidFormat
public string Json
public string NumericFormat
public string Regex
public string TimeOnlyFormat
public string TimeSpanFormat
public string Uri
public string Xml
public string Syntax
public Object[] Arguments
public void .ctor(string syntax)
public void .ctor(string syntax, Object[] arguments)
public string get_Syntax()
public Object[] get_Arguments()
}
public System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
private string <Category>k__BackingField
private string <CheckId>k__BackingField
private string <Scope>k__BackingField
private string <Target>k__BackingField
private string <MessageId>k__BackingField
private string <Justification>k__BackingField
public string Category
public string CheckId
public string Scope
public string Target
public string MessageId
public string Justification
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Justification()
public void set_Justification(string value)
}
public System.Index : ValueType {
private int _value
public Index Start
public Index End
public int Value
public bool IsFromEnd
public void .ctor(int value, bool fromEnd)
private void .ctor(int value)
public Index get_Start()
public Index get_End()
public Index FromStart(int value)
public Index FromEnd(int value)
public int get_Value()
public bool get_IsFromEnd()
public int GetOffset(int length)
public bool Equals(object value)
public bool Equals(Index other)
public int GetHashCode()
public Index op_Implicit(int value)
public string ToString()
private string ToStringFromEnd()
}
public System.Range : ValueType {
private Index <Start>k__BackingField
private Index <End>k__BackingField
public Index Start
public Index End
public Range All
public Index get_Start()
public Index get_End()
public void .ctor(Index start, Index end)
public bool Equals(object value)
public bool Equals(Range other)
public int GetHashCode()
public string ToString()
public Range StartAt(Index start)
public Range EndAt(Index end)
public Range get_All()
public ValueTuple`2<int, int> GetOffsetAndLength(int length)
}
public System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
private Type <BuilderType>k__BackingField
public Type BuilderType
public void .ctor(Type builderType)
public Type get_BuilderType()
}
public System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
private string <ParameterName>k__BackingField
public string ParameterName
public void .ctor(string parameterName)
public string get_ParameterName()
}
public System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
private string <FeatureName>k__BackingField
private bool <IsOptional>k__BackingField
public string RefStructs
public string RequiredMembers
public string FeatureName
public bool IsOptional
public void .ctor(string featureName)
public string get_FeatureName()
public bool get_IsOptional()
public void set_IsOptional(bool value)
}
public System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
private String[] <Arguments>k__BackingField
public String[] Arguments
public void .ctor(string argument)
public void .ctor(String[] arguments)
public String[] get_Arguments()
}
internal System.Runtime.CompilerServices.NullableAttribute : Attribute {
public Byte[] NullableFlags
public void .ctor(byte )
public void .ctor(Byte[] )
}
internal System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
public byte Flag
public void .ctor(byte )
}
internal System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
public int Version
public void .ctor(int )
}
public System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute : Attribute {
public Type[] CallConvs
public string EntryPoint
}
public System.Runtime.Versioning.ObsoletedOSPlatformAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string platformName)
public void .ctor(string platformName, string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
public System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
private string <Message>k__BackingField
private string <Url>k__BackingField
public string Message
public string Url
public void .ctor(string message)
public string get_Message()
public string get_Url()
public void set_Url(string value)
}
public System.Runtime.Versioning.SupportedOSPlatformAttribute : Attribute {
public void .ctor(string platformName)
}
public System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : Attribute {
public void .ctor(string platformName)
}
public System.Runtime.Versioning.TargetPlatformAttribute : Attribute {
public void .ctor(string platformName)
}
public System.Runtime.Versioning.UnsupportedOSPlatformAttribute : Attribute {
private string <Message>k__BackingField
public string Message
public void .ctor(string platformName)
public void .ctor(string platformName, string message)
public string get_Message()
}
public System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : Attribute {
public void .ctor(string platformName)
}
