internal static class AssemblyRef : object {
    internal static string SystemConfiguration;
    internal static string System;
    public static string EcmaPublicKey;
    public static string FrameworkPublicKeyFull;
    public static string FrameworkPublicKeyFull2;
    public static string MicrosoftPublicKey;
    public static string MicrosoftJScript;
    public static string MicrosoftVSDesigner;
    public static string SystemData;
    public static string SystemDesign;
    public static string SystemDrawing;
    public static string SystemWeb;
    public static string SystemWebExtensions;
    public static string SystemWindowsForms;
}
internal static class Consts : object {
    public static string MonoCorlibVersion;
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string EnvironmentVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    private static string PublicKeyToken;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_JScript;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationCore_4_0;
    public static string AssemblyPresentationFramework_3_5;
    public static string AssemblySystemServiceModel_3_0;
}
internal static class Internal.Cryptography.ErrorCode : object {
    public static int CERT_E_CHAINING;
    public static int CERT_E_CRITICAL;
    public static int CERT_E_EXPIRED;
    public static int CERT_E_INVALID_NAME;
    public static int CERT_E_INVALID_POLICY;
    public static int CERT_E_UNTRUSTEDROOT;
    public static int CERT_E_VALIDITYPERIODNESTING;
    public static int CERT_E_WRONG_USAGE;
    public static int CERTSRV_E_WEAK_SIGNATURE_OR_KEY;
    public static int CRYPT_E_NO_REVOCATION_CHECK;
    public static int CRYPT_E_NOT_FOUND;
    public static int CRYPT_E_REVOCATION_OFFLINE;
    public static int CRYPT_E_REVOKED;
    public static int CRYPT_E_SIGNER_NOT_FOUND;
    public static int E_POINTER;
    public static int ERROR_INVALID_PARAMETER;
    public static int HRESULT_INVALID_HANDLE;
    public static int NTE_BAD_PUBLIC_KEY;
    public static int TRUST_E_BASIC_CONSTRAINTS;
    public static int TRUST_E_CERT_SIGNATURE;
    public static int TRUST_E_EXPLICIT_DISTRUST;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    public static Byte[] GenerateRandom(int count);
    public static void WriteInt(UInt32 i, Byte[] arr, int offset);
    [ExtensionAttribute]
public static Byte[] FixupKeyParity(Byte[] key);
    internal static void ConvertIntToByteArray(UInt32 value, Byte[] dest);
    [ExtensionAttribute]
public static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
public static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] DecodeHexString(string s);
    private static byte HexToByte(char val);
    private static char NibbleToHex(byte b);
    [ExtensionAttribute]
public static bool ContentsEqual(Byte[] a1, Byte[] a2);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> coll, IEnumerable`1<T> newData);
    [ExtensionAttribute]
public static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
    [ExtensionAttribute]
internal static void DisposeAll(IEnumerable`1<IDisposable> disposables);
}
internal class Internal.Cryptography.PinAndClear : ValueType {
    private Byte[] _data;
    private GCHandle _gcHandle;
    internal static PinAndClear Track(Byte[] data);
    public sealed virtual void Dispose();
}
internal static class Internal.IO.File : object {
    internal static bool InternalExists(string fullPath);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
}
internal enum Internal.Runtime.Augments.AsyncStatus : Enum {
    public int value__;
    public static AsyncStatus Started;
    public static AsyncStatus Completed;
    public static AsyncStatus Canceled;
    public static AsyncStatus Error;
}
internal enum Internal.Runtime.Augments.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum Internal.Runtime.Augments.CausalitySource : Enum {
    public int value__;
    public static CausalitySource Application;
    public static CausalitySource Library;
    public static CausalitySource System;
}
internal enum Internal.Runtime.Augments.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal enum Internal.Runtime.Augments.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
internal static class Internal.Runtime.Augments.EnvironmentAugments : object {
    public static string StackTrace;
    private static EnvironmentAugments();
}
internal class Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks : object {
    internal Exception CreateMissingMetadataException(Type attributeType);
}
internal class Internal.Runtime.Augments.RuntimeAugments : object {
    private static ReflectionExecutionDomainCallbacks s_reflectionExecutionDomainCallbacks;
    internal static ReflectionExecutionDomainCallbacks Callbacks { get; }
    private static RuntimeAugments();
    public static void ReportUnhandledException(Exception exception);
    internal static ReflectionExecutionDomainCallbacks get_Callbacks();
}
internal class Internal.Runtime.Augments.RuntimeThread : object {
    internal static int OptimalMaxSpinWaitsPerSpinIteration;
    private Thread thread;
    public bool IsBackground { get; public set; }
    private RuntimeThread(Thread t);
    private static RuntimeThread();
    public void ResetThreadPoolThread();
    public static RuntimeThread InitializeThreadPoolThread();
    public static RuntimeThread Create(ParameterizedThreadStart start, int maxStackSize);
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    public void Start();
    public void Start(object state);
    public static void Sleep(int millisecondsTimeout);
    public static bool Yield();
    public static bool SpinWait(int iterations);
    public static int GetCurrentProcessorId();
}
internal abstract class Internal.Runtime.Augments.TaskTraceCallbacks : object {
    public bool Enabled { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
    public abstract virtual void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
}
[ConditionalAttribute("ALWAYSREMOVED")]
[AttributeUsageAttribute("32767")]
internal class Internal.Runtime.CompilerServices.RelocatedTypeAttribute : Attribute {
    public RelocatedTypeAttribute(string originalAssemblySimpleName);
}
internal static class Internal.Threading.Tasks.Tracing.TaskTrace : object {
    private static TaskTraceCallbacks s_callbacks;
    public static bool Enabled { get; }
    public static bool get_Enabled();
    public static void Initialize(TaskTraceCallbacks callbacks);
    public static void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
    public static void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
}
internal static class Interop : object {
    internal static void GetRandomBytes(Byte* buffer, int length);
    internal static IntPtr MemAlloc(UIntPtr sizeInBytes);
    internal static void MemFree(IntPtr allocatedMemory);
}
internal class Locale : object {
    public static string GetText(string msg);
    public static string GetText(string fmt, Object[] args);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Microsoft.Win32.NativeMethods : object {
    public static int GetCurrentProcessId();
}
public static class Microsoft.Win32.Registry : object {
    public static RegistryKey CurrentUser;
    public static RegistryKey LocalMachine;
    public static RegistryKey ClassesRoot;
    public static RegistryKey Users;
    public static RegistryKey PerformanceData;
    public static RegistryKey CurrentConfig;
    [ObsoleteAttribute("Use PerformanceData instead")]
public static RegistryKey DynData;
    private static Registry();
    public static object GetValue(string keyName, string valueName, object defaultValue);
    public static void SetValue(string keyName, string valueName, object value);
    public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
    private static RegistryKey GetBaseKeyFromKeyName(string keyName, String& subKeyName);
}
public enum Microsoft.Win32.RegistryHive : Enum {
    public int value__;
    public static RegistryHive ClassesRoot;
    public static RegistryHive CurrentUser;
    public static RegistryHive LocalMachine;
    public static RegistryHive Users;
    public static RegistryHive PerformanceData;
    public static RegistryHive CurrentConfig;
    public static RegistryHive DynData;
}
public class Microsoft.Win32.RegistryKey : MarshalByRefObject {
    internal static IntPtr HKEY_CLASSES_ROOT;
    internal static IntPtr HKEY_CURRENT_USER;
    internal static IntPtr HKEY_LOCAL_MACHINE;
    internal static IntPtr HKEY_USERS;
    internal static IntPtr HKEY_PERFORMANCE_DATA;
    internal static IntPtr HKEY_CURRENT_CONFIG;
    internal static IntPtr HKEY_DYN_DATA;
    private static String[] s_hkeyNames;
    private static int MaxKeyLength;
    private static int MaxValueLength;
    private SafeRegistryHandle modreq(System.Runtime.CompilerServices.IsVolatile) _hkey;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _keyName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _remoteKey;
    private StateFlags modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private RegistryKeyPermissionCheck modreq(System.Runtime.CompilerServices.IsVolatile) _checkMode;
    private RegistryView modreq(System.Runtime.CompilerServices.IsVolatile) _regView;
    private SafeRegistryHandle SystemKeyHandle { get; }
    public int SubKeyCount { get; }
    public RegistryView View { get; }
    public SafeRegistryHandle Handle { get; }
    public int ValueCount { get; }
    public string Name { get; }
    private RegistryKey(SafeRegistryHandle hkey, bool writable, RegistryView view);
    private RegistryKey(SafeRegistryHandle hkey, bool writable, bool systemkey, bool remoteKey, bool isPerfData, RegistryView view);
    private static RegistryKey();
    private void ClosePerfDataKey();
    private void FlushCore();
    private RegistryKey CreateSubKeyInternalCore(string subkey, RegistryKeyPermissionCheck permissionCheck, object registrySecurityObj, RegistryOptions registryOptions);
    private void DeleteSubKeyCore(string subkey, bool throwOnMissingSubKey);
    private void DeleteSubKeyTreeCore(string subkey);
    private void DeleteValueCore(string name, bool throwOnMissingValue);
    private static RegistryKey OpenBaseKeyCore(RegistryHive hKeyHive, RegistryView view);
    private static RegistryKey OpenRemoteBaseKeyCore(RegistryHive hKey, string machineName, RegistryView view);
    private RegistryKey InternalOpenSubKeyCore(string name, RegistryKeyPermissionCheck permissionCheck, int rights, bool throwOnPermissionFailure);
    private RegistryKey InternalOpenSubKeyCore(string name, bool writable, bool throwOnPermissionFailure);
    internal RegistryKey InternalOpenSubKeyWithoutSecurityChecksCore(string name, bool writable);
    private SafeRegistryHandle get_SystemKeyHandle();
    private int InternalSubKeyCountCore();
    private String[] InternalGetSubKeyNamesCore(int subkeys);
    private int InternalValueCountCore();
    private String[] GetValueNamesCore(int values);
    private object InternalGetValueCore(string name, object defaultValue, bool doNotExpand);
    private RegistryValueKind GetValueKindCore(string name);
    private void SetValueCore(string name, object value, RegistryValueKind valueKind);
    private void Win32Error(int errorCode, string str);
    private static void Win32ErrorStatic(int errorCode, string str);
    private static int GetRegistryKeyAccess(bool isWritable);
    private static int GetRegistryKeyAccess(RegistryKeyPermissionCheck mode);
    public void Flush();
    public void Close();
    public sealed virtual void Dispose();
    public RegistryKey CreateSubKey(string subkey);
    public RegistryKey CreateSubKey(string subkey, bool writable);
    public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
    public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck);
    public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions);
    public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity);
    public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity);
    private RegistryKey CreateSubKeyInternal(string subkey, RegistryKeyPermissionCheck permissionCheck, object registrySecurityObj, RegistryOptions registryOptions);
    public void DeleteSubKey(string subkey);
    public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
    public void DeleteSubKeyTree(string subkey);
    public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
    private void DeleteSubKeyTreeInternal(string subkey);
    public void DeleteValue(string name);
    public void DeleteValue(string name, bool throwOnMissingValue);
    public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
    public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName);
    public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view);
    public RegistryKey OpenSubKey(string name);
    public RegistryKey OpenSubKey(string name, bool writable);
    public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck);
    public RegistryKey OpenSubKey(string name, RegistryRights rights);
    public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights);
    private RegistryKey InternalOpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, int rights);
    internal RegistryKey InternalOpenSubKeyWithoutSecurityChecks(string name, bool writable);
    public RegistrySecurity GetAccessControl();
    public RegistrySecurity GetAccessControl(AccessControlSections includeSections);
    public void SetAccessControl(RegistrySecurity registrySecurity);
    public int get_SubKeyCount();
    public RegistryView get_View();
    public SafeRegistryHandle get_Handle();
    public static RegistryKey FromHandle(SafeRegistryHandle handle);
    public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
    private int InternalSubKeyCount();
    public String[] GetSubKeyNames();
    private String[] InternalGetSubKeyNames();
    public int get_ValueCount();
    private int InternalValueCount();
    public String[] GetValueNames();
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue);
    public object GetValue(string name, object defaultValue, RegistryValueOptions options);
    private object InternalGetValue(string name, object defaultValue, bool doNotExpand, bool checkSecurity);
    public RegistryValueKind GetValueKind(string name);
    public string get_Name();
    public void SetValue(string name, object value);
    public void SetValue(string name, object value, RegistryValueKind valueKind);
    private RegistryValueKind CalculateValueKind(object value);
    public virtual string ToString();
    private static string FixupName(string name);
    private static void FixupPath(StringBuilder path);
    private void EnsureNotDisposed();
    private void EnsureWriteable();
    private RegistryKeyPermissionCheck GetSubKeyPermissionCheck(bool subkeyWritable);
    private static void ValidateKeyName(string name);
    private static void ValidateKeyMode(RegistryKeyPermissionCheck mode);
    private static void ValidateKeyOptions(RegistryOptions options);
    private static void ValidateKeyView(RegistryView view);
    private static void ValidateKeyRights(int rights);
    private bool IsDirty();
    private bool IsSystemKey();
    private bool IsWritable();
    private bool IsPerfDataKey();
    private void SetDirty();
}
public enum Microsoft.Win32.RegistryKeyPermissionCheck : Enum {
    public int value__;
    public static RegistryKeyPermissionCheck Default;
    public static RegistryKeyPermissionCheck ReadSubTree;
    public static RegistryKeyPermissionCheck ReadWriteSubTree;
}
[FlagsAttribute]
public enum Microsoft.Win32.RegistryOptions : Enum {
    public int value__;
    public static RegistryOptions None;
    public static RegistryOptions Volatile;
}
public enum Microsoft.Win32.RegistryValueKind : Enum {
    public int value__;
    public static RegistryValueKind String;
    public static RegistryValueKind ExpandString;
    public static RegistryValueKind Binary;
    public static RegistryValueKind DWord;
    public static RegistryValueKind MultiString;
    public static RegistryValueKind QWord;
    public static RegistryValueKind Unknown;
    public static RegistryValueKind None;
}
[FlagsAttribute]
public enum Microsoft.Win32.RegistryValueOptions : Enum {
    public int value__;
    public static RegistryValueOptions None;
    public static RegistryValueOptions DoNotExpandEnvironmentNames;
}
public enum Microsoft.Win32.RegistryView : Enum {
    public int value__;
    public static RegistryView Default;
    public static RegistryView Registry64;
    public static RegistryView Registry32;
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeAccessTokenHandle : SafeHandle {
    public static SafeAccessTokenHandle InvalidHandle { get; }
    public bool IsInvalid { get; }
    public SafeAccessTokenHandle(IntPtr handle);
    [SecurityCriticalAttribute]
public static SafeAccessTokenHandle get_InvalidHandle();
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeFindHandle(IntPtr preexistingHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeLibraryHandle(bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafePasswordHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafePasswordHandle InvalidHandle { get; }
    public SafePasswordHandle(string password);
    public SafePasswordHandle(SecureString password);
    private IntPtr CreateHandle(string password);
    private IntPtr CreateHandle(SecureString password);
    private void FreeHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsInvalid();
    public static SafePasswordHandle get_InvalidHandle();
    internal string Mono_DangerousGetString();
}
public class Microsoft.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle : SafeHandle {
    public bool IsInvalid { get; }
    private static SafeThreadPoolIOHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.ThrowHelper : object {
    internal static void ThrowArgumentException(string msg);
    internal static void ThrowArgumentException(string msg, string argument);
    internal static void ThrowArgumentNullException(string argument);
    internal static void ThrowInvalidOperationException(string msg);
    internal static void ThrowSecurityException(string msg);
    internal static void ThrowUnauthorizedAccessException(string msg);
    internal static void ThrowObjectDisposedException(string objectName, string msg);
}
internal static class Microsoft.Win32.Win32Native : object {
    internal static string ADVAPI32;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_INVALID_FUNCTION;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_HANDLE;
    internal static int ERROR_NOT_ENOUGH_MEMORY;
    internal static int ERROR_INVALID_DATA;
    internal static int ERROR_INVALID_DRIVE;
    internal static int ERROR_NO_MORE_FILES;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_BAD_LENGTH;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_NOT_SUPPORTED;
    internal static int ERROR_FILE_EXISTS;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_CALL_NOT_IMPLEMENTED;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_BAD_PATHNAME;
    internal static int ERROR_ALREADY_EXISTS;
    internal static int ERROR_ENVVAR_NOT_FOUND;
    internal static int ERROR_FILENAME_EXCED_RANGE;
    internal static int ERROR_NO_DATA;
    internal static int ERROR_PIPE_NOT_CONNECTED;
    internal static int ERROR_MORE_DATA;
    internal static int ERROR_DIRECTORY;
    internal static int ERROR_OPERATION_ABORTED;
    internal static int ERROR_NOT_FOUND;
    internal static int ERROR_NO_TOKEN;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_NON_ACCOUNT_SID;
    internal static int ERROR_NOT_ALL_ASSIGNED;
    internal static int ERROR_UNKNOWN_REVISION;
    internal static int ERROR_INVALID_OWNER;
    internal static int ERROR_INVALID_PRIMARY_GROUP;
    internal static int ERROR_NO_SUCH_PRIVILEGE;
    internal static int ERROR_PRIVILEGE_NOT_HELD;
    internal static int ERROR_NONE_MAPPED;
    internal static int ERROR_INVALID_ACL;
    internal static int ERROR_INVALID_SID;
    internal static int ERROR_INVALID_SECURITY_DESCR;
    internal static int ERROR_BAD_IMPERSONATION_LEVEL;
    internal static int ERROR_CANT_OPEN_ANONYMOUS;
    internal static int ERROR_NO_SECURITY_ON_OBJECT;
    internal static int ERROR_TRUSTED_RELATIONSHIP_FAILURE;
    internal static FileAttributes FILE_ATTRIBUTE_DIRECTORY;
    public static string GetMessage(int hr);
    public static int MakeHRFromErrorCode(int errorCode);
}
[FlagsAttribute]
internal enum Mono.CertificateImportFlags : Enum {
    public int value__;
    public static CertificateImportFlags None;
    public static CertificateImportFlags DisableNativeBackend;
    public static CertificateImportFlags DisableAutomaticFallback;
}
internal abstract class Mono.DataConverter : object {
    private static DataConverter SwapConv;
    private static DataConverter CopyConv;
    public static bool IsLittleEndian;
    public static DataConverter LittleEndian { get; }
    public static DataConverter BigEndian { get; }
    public static DataConverter Native { get; }
    private static DataConverter();
    public abstract virtual double GetDouble(Byte[] data, int index);
    public abstract virtual float GetFloat(Byte[] data, int index);
    public abstract virtual long GetInt64(Byte[] data, int index);
    public abstract virtual int GetInt32(Byte[] data, int index);
    public abstract virtual short GetInt16(Byte[] data, int index);
    [CLSCompliantAttribute("False")]
public abstract virtual UInt32 GetUInt32(Byte[] data, int index);
    [CLSCompliantAttribute("False")]
public abstract virtual ushort GetUInt16(Byte[] data, int index);
    [CLSCompliantAttribute("False")]
public abstract virtual ulong GetUInt64(Byte[] data, int index);
    public abstract virtual void PutBytes(Byte[] dest, int destIdx, double value);
    public abstract virtual void PutBytes(Byte[] dest, int destIdx, float value);
    public abstract virtual void PutBytes(Byte[] dest, int destIdx, int value);
    public abstract virtual void PutBytes(Byte[] dest, int destIdx, long value);
    public abstract virtual void PutBytes(Byte[] dest, int destIdx, short value);
    [CLSCompliantAttribute("False")]
public abstract virtual void PutBytes(Byte[] dest, int destIdx, ushort value);
    [CLSCompliantAttribute("False")]
public abstract virtual void PutBytes(Byte[] dest, int destIdx, UInt32 value);
    [CLSCompliantAttribute("False")]
public abstract virtual void PutBytes(Byte[] dest, int destIdx, ulong value);
    public Byte[] GetBytes(double value);
    public Byte[] GetBytes(float value);
    public Byte[] GetBytes(int value);
    public Byte[] GetBytes(long value);
    public Byte[] GetBytes(short value);
    [CLSCompliantAttribute("False")]
public Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public Byte[] GetBytes(ulong value);
    public static DataConverter get_LittleEndian();
    public static DataConverter get_BigEndian();
    public static DataConverter get_Native();
    private static int Align(int current, int align);
    public static Byte[] Pack(string description, Object[] args);
    public static Byte[] PackEnumerable(string description, IEnumerable args);
    private static bool PackOne(PackContext b, object oarg);
    private static bool Prepare(Byte[] buffer, Int32& idx, int size, Boolean& align);
    public static IList Unpack(string description, Byte[] buffer, int startIndex);
    internal void Check(Byte[] dest, int destIdx, int size);
}
internal static class Mono.DependencyInjector : object {
    private static string TypeName;
    private static object locker;
    private static ISystemDependencyProvider systemDependency;
    internal static ISystemDependencyProvider SystemProvider { get; }
    private static DependencyInjector();
    internal static ISystemDependencyProvider get_SystemProvider();
    internal static void Register(ISystemDependencyProvider provider);
    [PreserveDependencyAttribute("get_Instance()", "Mono.SystemDependencyProvider", "System")]
private static ISystemDependencyProvider ReflectionLoad();
}
internal class Mono.Globalization.Unicode.CodePointIndexer : object {
    private TableRange[] ranges;
    public int TotalCount;
    private int defaultIndex;
    private int defaultCP;
    public CodePointIndexer(Int32[] starts, Int32[] ends, int defaultIndex, int defaultCP);
    public static Array CompressArray(Array source, Type type, CodePointIndexer indexer);
    public int ToIndex(int cp);
    public int ToCodePoint(int i);
}
internal class Mono.Globalization.Unicode.Contraction : object {
    public int Index;
    public Char[] Source;
    public string Replacement;
    public Byte[] SortKey;
    public Contraction(int index, Char[] source, string replacement, Byte[] sortkey);
}
internal class Mono.Globalization.Unicode.ContractionComparer : object {
    public static ContractionComparer Instance;
    private static ContractionComparer();
    public sealed virtual int Compare(Contraction c1, Contraction c2);
}
internal class Mono.Globalization.Unicode.Level2Map : object {
    public byte Source;
    public byte Replace;
    public Level2Map(byte source, byte replace);
}
internal class Mono.Globalization.Unicode.MSCompatUnicodeTable : object {
    public static int MaxExpansionLength;
    private static Byte* ignorableFlags;
    private static Byte* categories;
    private static Byte* level1;
    private static Byte* level2;
    private static Byte* level3;
    private static Byte* cjkCHScategory;
    private static Byte* cjkCHTcategory;
    private static Byte* cjkJAcategory;
    private static Byte* cjkKOcategory;
    private static Byte* cjkCHSlv1;
    private static Byte* cjkCHTlv1;
    private static Byte* cjkJAlv1;
    private static Byte* cjkKOlv1;
    private static Byte* cjkKOlv2;
    private static int ResourceVersionSize;
    private static Char[] tailoringArr;
    private static TailoringInfo[] tailoringInfos;
    private static object forLock;
    public static bool isReady;
    public static bool IsReady { get; }
    private static MSCompatUnicodeTable();
    public static TailoringInfo GetTailoringInfo(int lcid);
    public static void BuildTailoringTables(CultureInfo culture, TailoringInfo t, Contraction[]& contractions, Level2Map[]& diacriticals);
    private static void SetCJKReferences(string name, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table);
    public static byte Category(int cp);
    public static byte Level1(int cp);
    public static byte Level2(int cp);
    public static byte Level3(int cp);
    public static bool IsSortable(string s);
    public static bool IsSortable(int cp);
    public static bool IsIgnorable(int cp);
    public static bool IsIgnorable(int cp, byte flag);
    public static bool IsIgnorableSymbol(int cp);
    public static bool IsIgnorableNonSpacing(int cp);
    public static int ToKanaTypeInsensitive(int i);
    public static int ToWidthCompat(int i);
    public static bool HasSpecialWeight(char c);
    public static byte GetJapaneseDashType(char c);
    public static bool IsHalfWidthKana(char c);
    public static bool IsHiragana(char c);
    public static bool IsJapaneseSmallLetter(char c);
    public static bool get_IsReady();
    private static IntPtr GetResource(string name);
    private static UInt32 UInt32FromBytePtr(Byte* raw, UInt32 idx);
    public static void FillCJK(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table);
    private static void FillCJKCore(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& cjkLv2Indexer, Byte*& lv2Table);
}
internal class Mono.Globalization.Unicode.MSCompatUnicodeTableUtil : object {
    public static byte ResourceVersion;
    public static CodePointIndexer Ignorable;
    public static CodePointIndexer Category;
    public static CodePointIndexer Level1;
    public static CodePointIndexer Level2;
    public static CodePointIndexer Level3;
    public static CodePointIndexer CjkCHS;
    public static CodePointIndexer Cjk;
    private static MSCompatUnicodeTableUtil();
}
internal class Mono.Globalization.Unicode.NormalizationTableUtil : object {
    public static CodePointIndexer Prop;
    public static CodePointIndexer Map;
    public static CodePointIndexer Combining;
    public static CodePointIndexer Composite;
    public static CodePointIndexer Helper;
    public static int PropCount { get; }
    public static int MapCount { get; }
    private static NormalizationTableUtil();
    public static int PropIdx(int cp);
    public static int PropCP(int index);
    public static int get_PropCount();
    public static int MapIdx(int cp);
    public static int MapCP(int index);
    public static int CbIdx(int cp);
    public static int CbCP(int index);
    public static int get_MapCount();
}
internal class Mono.Globalization.Unicode.SimpleCollator : object {
    private static SimpleCollator invariant;
    private TextInfo textInfo;
    private CodePointIndexer cjkIndexer;
    private Contraction[] contractions;
    private Level2Map[] level2Maps;
    private Byte[] unsafeFlags;
    private Byte* cjkCatTable;
    private Byte* cjkLv1Table;
    private Byte* cjkLv2Table;
    private CodePointIndexer cjkLv2Indexer;
    private int lcid;
    private bool frenchSort;
    private static int UnsafeFlagLength;
    public SimpleCollator(CultureInfo culture);
    private static SimpleCollator();
    private void SetCJKTable(CultureInfo culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table);
    private static CultureInfo GetNeutralCulture(CultureInfo info);
    private byte Category(int cp);
    private byte Level1(int cp);
    private byte Level2(int cp, ExtenderType ext);
    private static bool IsHalfKana(int cp, CompareOptions opt);
    private Contraction GetContraction(string s, int start, int end);
    private Contraction GetContraction(string s, int start, int end, Contraction[] clist);
    private Contraction GetTailContraction(string s, int start, int end);
    private Contraction GetTailContraction(string s, int start, int end, Contraction[] clist);
    private Contraction GetContraction(char c);
    private Contraction GetContraction(char c, Contraction[] clist);
    private int FilterOptions(int i, CompareOptions opt);
    private ExtenderType GetExtenderType(int i);
    private static byte ToDashTypeValue(ExtenderType ext, CompareOptions opt);
    private int FilterExtender(int i, ExtenderType ext, CompareOptions opt);
    private static bool IsIgnorable(int i, CompareOptions opt);
    private bool IsSafe(int i);
    public SortKey GetSortKey(string s);
    public sealed virtual SortKey GetSortKey(string s, CompareOptions options);
    public SortKey GetSortKey(string s, int start, int length, CompareOptions options);
    private void GetSortKey(string s, int start, int end, SortKeyBuffer buf, CompareOptions opt);
    private void FillSortKeyRaw(int i, ExtenderType ext, SortKeyBuffer buf, CompareOptions opt);
    private void FillSurrogateSortKeyRaw(int i, SortKeyBuffer buf);
    public sealed virtual int Compare(string s1, string s2);
    private sealed virtual override int System.Globalization.ISimpleCollator.Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options);
    internal int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options);
    private void ClearBuffer(Byte* buffer, int size);
    private int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, Boolean& targetConsumed, Boolean& sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, Context& ctx);
    private int CompareFlagPair(bool b1, bool b2);
    public sealed virtual bool IsPrefix(string src, string target, CompareOptions opt);
    public bool IsPrefix(string s, string target, int start, int length, CompareOptions opt);
    private bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, Context& ctx);
    public sealed virtual bool IsSuffix(string src, string target, CompareOptions opt);
    public bool IsSuffix(string s, string target, int start, int length, CompareOptions opt);
    public int IndexOf(string s, string target, CompareOptions opt);
    private int QuickIndexOf(string s, string target, int start, int length, Boolean& testWasUnable);
    public sealed virtual int IndexOf(string s, string target, int start, int length, CompareOptions opt);
    private int IndexOfOrdinal(string s, string target, int start, int length);
    public int IndexOf(string s, char target, CompareOptions opt);
    public sealed virtual int IndexOf(string s, char target, int start, int length, CompareOptions opt);
    private int IndexOfOrdinal(string s, char target, int start, int length);
    private int IndexOfSortKey(string s, int start, int length, Byte* sortkey, char target, int ti, bool noLv4, Context& ctx);
    private int IndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx);
    public sealed virtual int LastIndexOf(string s, string target, CompareOptions opt);
    public sealed virtual int LastIndexOf(string s, string target, int start, int length, CompareOptions opt);
    private int LastIndexOfOrdinal(string s, string target, int start, int length);
    public sealed virtual int LastIndexOf(string s, char target, CompareOptions opt);
    public sealed virtual int LastIndexOf(string s, char target, int start, int length, CompareOptions opt);
    private int LastIndexOfSortKey(string s, int start, int orgStart, int length, Byte* sortkey, int ti, bool noLv4, Context& ctx);
    private int LastIndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx);
    private bool MatchesForward(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, Context& ctx);
    private bool MatchesForwardCore(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx);
    private bool MatchesPrimitive(CompareOptions opt, Byte* source, int si, ExtenderType ext, Byte* target, int ti, bool noLv4);
    private bool MatchesBackward(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, Context& ctx);
    private bool MatchesBackwardCore(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx);
}
internal class Mono.Globalization.Unicode.SortKeyBuffer : object {
    private Byte[] l1b;
    private Byte[] l2b;
    private Byte[] l3b;
    private Byte[] l4sb;
    private Byte[] l4tb;
    private Byte[] l4kb;
    private Byte[] l4wb;
    private Byte[] l5b;
    private string source;
    private int l1;
    private int l2;
    private int l3;
    private int l4s;
    private int l4t;
    private int l4k;
    private int l4w;
    private int l5;
    private int lcid;
    private CompareOptions options;
    private bool processLevel2;
    private bool frenchSort;
    private bool frenchSorted;
    public SortKeyBuffer(int lcid);
    public void Reset();
    internal void ClearBuffer();
    internal void Initialize(CompareOptions options, int lcid, string s, bool frenchSort);
    internal void AppendCJKExtension(byte lv1msb, byte lv1lsb);
    internal void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth);
    internal void AppendNormal(byte category, byte lv1, byte lv2, byte lv3);
    private void AppendLevel5(byte category, byte lv1);
    private void AppendBufferPrimitive(byte value, Byte[]& buf, Int32& bidx);
    public SortKey GetResultAndReset();
    private int GetOptimizedLength(Byte[] data, int len, byte defaultValue);
    public SortKey GetResult();
}
internal class Mono.Globalization.Unicode.TailoringInfo : object {
    public int LCID;
    public int TailoringIndex;
    public int TailoringCount;
    public bool FrenchSort;
    public TailoringInfo(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort);
}
internal class Mono.Interop.ComInteropProxy : RealProxy {
    private __ComObject com_object;
    private int ref_count;
    private string type_name;
    public string TypeName { get; public set; }
    private ComInteropProxy(Type t);
    private ComInteropProxy(IntPtr pUnk);
    internal ComInteropProxy(IntPtr pUnk, Type t);
    private static void AddProxy(IntPtr pItf, ComInteropProxy& proxy);
    internal static void FindProxy(IntPtr pItf, ComInteropProxy& proxy);
    private void CacheProxy();
    internal static ComInteropProxy GetProxy(IntPtr pItf, Type t);
    internal static ComInteropProxy CreateProxy(Type t);
    public virtual IMessage Invoke(IMessage msg);
    public sealed virtual string get_TypeName();
    public sealed virtual void set_TypeName(string value);
    public sealed virtual bool CanCastTo(Type fromType, object o);
}
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
internal interface Mono.Interop.IDispatch {
}
[GuidAttribute("00000000-0000-0000-C000-000000000046")]
internal interface Mono.Interop.IUnknown {
}
[AttributeUsageAttribute("64")]
internal class Mono.Interop.MonoPInvokeCallbackAttribute : Attribute {
    public MonoPInvokeCallbackAttribute(Type t);
}
internal interface Mono.ISystemCertificateProvider {
    public abstract virtual X509CertificateImpl Import(Byte[] data, CertificateImportFlags importFlags);
    public abstract virtual X509CertificateImpl Import(Byte[] data, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags, CertificateImportFlags importFlags);
    public abstract virtual X509CertificateImpl Import(X509Certificate cert, CertificateImportFlags importFlags);
}
internal interface Mono.ISystemDependencyProvider {
    public ISystemCertificateProvider CertificateProvider { get; }
    public abstract virtual ISystemCertificateProvider get_CertificateProvider();
}
internal class Mono.Math.BigInteger : object {
    private UInt32 length;
    private UInt32[] data;
    private static UInt32 DEFAULT_LEN;
    internal static UInt32[] smallPrimes;
    private static string WouldReturnNegVal;
    private static RandomNumberGenerator rng;
    private static RandomNumberGenerator Rng { get; }
    public BigInteger(Sign sign, UInt32 len);
    public BigInteger(BigInteger bi);
    public BigInteger(BigInteger bi, UInt32 len);
    public BigInteger(Byte[] inData);
    public BigInteger(UInt32[] inData);
    public BigInteger(UInt32 ui);
    public BigInteger(ulong ul);
    private static BigInteger();
    public static BigInteger op_Implicit(UInt32 value);
    public static BigInteger op_Implicit(int value);
    public static BigInteger op_Implicit(ulong value);
    public static BigInteger Parse(string number);
    public static BigInteger op_Addition(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
    public static int op_Modulus(BigInteger bi, int i);
    public static UInt32 op_Modulus(BigInteger bi, UInt32 ui);
    public static BigInteger op_Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Division(BigInteger bi, int i);
    public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Multiply(BigInteger bi, int i);
    public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
    public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
    public static BigInteger Add(BigInteger bi1, BigInteger bi2);
    public static BigInteger Subtract(BigInteger bi1, BigInteger bi2);
    public static int Modulus(BigInteger bi, int i);
    public static UInt32 Modulus(BigInteger bi, UInt32 ui);
    public static BigInteger Modulus(BigInteger bi1, BigInteger bi2);
    public static BigInteger Divid(BigInteger bi, int i);
    public static BigInteger Divid(BigInteger bi1, BigInteger bi2);
    public static BigInteger Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger Multiply(BigInteger bi, int i);
    private static RandomNumberGenerator get_Rng();
    public static BigInteger GenerateRandom(int bits, RandomNumberGenerator rng);
    public static BigInteger GenerateRandom(int bits);
    public void Randomize(RandomNumberGenerator rng);
    public void Randomize();
    public int BitCount();
    public bool TestBit(UInt32 bitNum);
    public bool TestBit(int bitNum);
    public void SetBit(UInt32 bitNum);
    public void ClearBit(UInt32 bitNum);
    public void SetBit(UInt32 bitNum, bool value);
    public int LowestSetBit();
    public Byte[] GetBytes();
    public static bool op_Equality(BigInteger bi1, UInt32 ui);
    public static bool op_Inequality(BigInteger bi1, UInt32 ui);
    public static bool op_Equality(BigInteger bi1, BigInteger bi2);
    public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2);
    public Sign Compare(BigInteger bi);
    public string ToString(UInt32 radix);
    public string ToString(UInt32 radix, string characterSet);
    private void Normalize();
    public void Clear();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public BigInteger GCD(BigInteger bi);
    public BigInteger ModInverse(BigInteger modulus);
    public BigInteger ModPow(BigInteger exp, BigInteger n);
    public bool IsProbablePrime();
    public static BigInteger NextHighestPrime(BigInteger bi);
    public static BigInteger GeneratePseudoPrime(int bits);
    public void Incr2();
}
internal enum Mono.Math.Prime.ConfidenceFactor : Enum {
    public int value__;
    public static ConfidenceFactor ExtraLow;
    public static ConfidenceFactor Low;
    public static ConfidenceFactor Medium;
    public static ConfidenceFactor High;
    public static ConfidenceFactor ExtraHigh;
    public static ConfidenceFactor Provable;
}
internal class Mono.Math.Prime.Generator.NextPrimeFinder : SequentialSearchPrimeGeneratorBase {
    protected virtual BigInteger GenerateSearchBase(int bits, object Context);
}
internal abstract class Mono.Math.Prime.Generator.PrimeGeneratorBase : object {
    public ConfidenceFactor Confidence { get; }
    public PrimalityTest PrimalityTest { get; }
    public int TrialDivisionBounds { get; }
    public virtual ConfidenceFactor get_Confidence();
    public virtual PrimalityTest get_PrimalityTest();
    public virtual int get_TrialDivisionBounds();
    protected bool PostTrialDivisionTests(BigInteger bi);
    public abstract virtual BigInteger GenerateNewPrime(int bits);
}
internal class Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {
    protected virtual BigInteger GenerateSearchBase(int bits, object context);
    public virtual BigInteger GenerateNewPrime(int bits);
    public virtual BigInteger GenerateNewPrime(int bits, object context);
    protected virtual bool IsPrimeAcceptable(BigInteger bi, object context);
}
internal class Mono.Math.Prime.PrimalityTest : MulticastDelegate {
    public PrimalityTest(object object, IntPtr method);
    public virtual bool Invoke(BigInteger bi, ConfidenceFactor confidence);
    public virtual IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Mono.Math.Prime.PrimalityTests : object {
    private static int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence);
    public static bool Test(BigInteger n, ConfidenceFactor confidence);
    public static bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence);
    public static bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence);
}
internal class Mono.MonoAssemblyName : ValueType {
    private static int MONO_PUBLIC_KEY_TOKEN_LENGTH;
    internal IntPtr name;
    internal IntPtr culture;
    internal IntPtr hash_value;
    internal IntPtr public_key;
    [FixedBufferAttribute("System.Byte", "17")]
internal <public_key_token>e__FixedBuffer public_key_token;
    internal UInt32 hash_alg;
    internal UInt32 hash_len;
    internal UInt32 flags;
    internal ushort major;
    internal ushort minor;
    internal ushort build;
    internal ushort revision;
    internal ushort arch;
}
internal class Mono.NullByRefReturnException : Exception {
}
internal static class Mono.Runtime : object {
    private static object dump;
    private static Runtime();
    private static void mono_runtime_install_handlers();
    internal static void InstallSignalHandlers();
    internal static string GetDisplayName();
    private static string GetNativeStackTrace(Exception exception);
    public static bool SetGCAllowSynchronousMajor(bool flag);
    private static string ExceptionToState_internal(Exception exc, UInt64& portable_hash, UInt64& unportable_hash);
    private static Tuple`3<string, ulong, ulong> ExceptionToState(Exception exc);
    private static void DisableMicrosoftTelemetry();
    private static void EnableMicrosoftTelemetry_internal(IntPtr appBundleID, IntPtr appSignature, IntPtr appVersion, IntPtr merpGUIPath, IntPtr appPath, IntPtr configDir);
    private static void SendMicrosoftTelemetry_internal(IntPtr payload, ulong portable_hash, ulong unportable_hash);
    private static void WriteStateToFile_internal(IntPtr payload, ulong portable_hash, ulong unportable_hash);
    private static void WriteStateToFile(Exception exc);
    private static void SendMicrosoftTelemetry(string payload_str, ulong portable_hash, ulong unportable_hash);
    private static void SendExceptionToTelemetry(Exception exc);
    private static void EnableMicrosoftTelemetry(string appBundleID_str, string appSignature_str, string appVersion_str, string merpGUIPath_str, string unused, string appPath_str, string configDir_str);
    private static string DumpStateSingle_internal(UInt64& portable_hash, UInt64& unportable_hash);
    private static string DumpStateTotal_internal(UInt64& portable_hash, UInt64& unportable_hash);
    private static Tuple`3<string, ulong, ulong> DumpStateSingle();
    private static Tuple`3<string, ulong, ulong> DumpStateTotal();
    private static void RegisterReportingForAllNativeLibs_internal();
    private static void RegisterReportingForAllNativeLibs();
    private static void RegisterReportingForNativeLib_internal(IntPtr modulePathSuffix, IntPtr moduleName);
    private static void RegisterReportingForNativeLib(string modulePathSuffix_str, string moduleName_str);
    private static void EnableCrashReportLog_internal(IntPtr directory);
    private static void EnableCrashReportLog(string directory_str);
    private static int CheckCrashReportLog_internal(IntPtr directory, bool clear);
    private static CrashReportLogLevel CheckCrashReportLog(string directory_str, bool clear);
    private static string get_breadcrumb_value(string file_prefix, string directory_str, bool clear);
    private static long CheckCrashReportHash(string directory_str, bool clear);
    private static string CheckCrashReportReason(string directory_str, bool clear);
    private static void AnnotateMicrosoftTelemetry_internal(IntPtr key, IntPtr val);
    private static void AnnotateMicrosoftTelemetry(string key, string val);
}
internal class Mono.RuntimeClassHandle : ValueType {
    private MonoClass* value;
    internal MonoClass* Value { get; }
    internal RuntimeClassHandle(MonoClass* value);
    internal RuntimeClassHandle(IntPtr ptr);
    internal MonoClass* get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(RuntimeClassHandle handle);
    public static bool op_Equality(RuntimeClassHandle left, object right);
    public static bool op_Inequality(RuntimeClassHandle left, object right);
    public static bool op_Equality(object left, RuntimeClassHandle right);
    public static bool op_Inequality(object left, RuntimeClassHandle right);
    internal static IntPtr GetTypeFromClass(MonoClass* klass);
    internal RuntimeTypeHandle GetTypeHandle();
}
internal class Mono.RuntimeEventHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeEventHandle(IntPtr v);
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeEventHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeEventHandle left, RuntimeEventHandle right);
    public static bool op_Inequality(RuntimeEventHandle left, RuntimeEventHandle right);
}
internal class Mono.RuntimeGenericParamInfoHandle : ValueType {
    private GenericParamInfo* value;
    internal Type[] Constraints { get; }
    internal GenericParameterAttributes Attributes { get; }
    internal RuntimeGenericParamInfoHandle(GenericParamInfo* value);
    internal RuntimeGenericParamInfoHandle(IntPtr ptr);
    internal Type[] get_Constraints();
    internal GenericParameterAttributes get_Attributes();
    private Type[] GetConstraints();
    private int GetConstraintsCount();
}
[DefaultMemberAttribute("Item")]
internal class Mono.RuntimeGPtrArrayHandle : ValueType {
    private GPtrArray* value;
    internal int Length { get; }
    internal IntPtr Item { get; }
    internal RuntimeGPtrArrayHandle(GPtrArray* value);
    internal RuntimeGPtrArrayHandle(IntPtr ptr);
    internal int get_Length();
    internal IntPtr get_Item(int i);
    internal IntPtr Lookup(int i);
    private static void GPtrArrayFree(GPtrArray* value);
    internal static void DestroyAndFree(RuntimeGPtrArrayHandle& h);
}
internal static class Mono.RuntimeMarshal : object {
    internal static string PtrToUtf8String(IntPtr ptr);
    internal static SafeStringMarshal MarshalString(string str);
    private static int DecodeBlobSize(IntPtr in_ptr, IntPtr& out_ptr);
    internal static Byte[] DecodeBlobArray(IntPtr ptr);
    internal static int AsciHexDigitValue(int c);
    internal static void FreeAssemblyName(MonoAssemblyName& name, bool freeStruct);
}
internal class Mono.RuntimePropertyHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimePropertyHandle(IntPtr v);
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimePropertyHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimePropertyHandle left, RuntimePropertyHandle right);
    public static bool op_Inequality(RuntimePropertyHandle left, RuntimePropertyHandle right);
}
internal class Mono.RuntimeRemoteClassHandle : ValueType {
    private RemoteClass* value;
    internal RuntimeClassHandle ProxyClass { get; }
    internal RuntimeRemoteClassHandle(RemoteClass* value);
    internal RuntimeClassHandle get_ProxyClass();
}
internal static class Mono.RuntimeStructs : object {
}
[DefaultMemberAttribute("Item")]
internal class Mono.SafeGPtrArrayHandle : ValueType {
    private RuntimeGPtrArrayHandle handle;
    internal int Length { get; }
    internal IntPtr Item { get; }
    internal SafeGPtrArrayHandle(IntPtr ptr);
    public sealed virtual void Dispose();
    internal int get_Length();
    internal IntPtr get_Item(int i);
}
internal class Mono.SafeStringMarshal : ValueType {
    private string str;
    private IntPtr marshaled_string;
    public IntPtr Value { get; }
    public SafeStringMarshal(string str);
    private static IntPtr StringToUtf8_icall(String& str);
    public static IntPtr StringToUtf8(string str);
    public static void GFree(IntPtr ptr);
    public IntPtr get_Value();
    public sealed virtual void Dispose();
}
[DefaultMemberAttribute("Item")]
internal class Mono.Security.ASN1 : object {
    private byte m_nTag;
    private Byte[] m_aValue;
    private ArrayList elist;
    public int Count { get; }
    public byte Tag { get; }
    public int Length { get; }
    public Byte[] Value { get; public set; }
    public ASN1 Item { get; }
    public ASN1(byte tag);
    public ASN1(byte tag, Byte[] data);
    public ASN1(Byte[] data);
    public int get_Count();
    public byte get_Tag();
    public int get_Length();
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    private bool CompareArray(Byte[] array1, Byte[] array2);
    public bool Equals(Byte[] asn1);
    public bool CompareValue(Byte[] value);
    public ASN1 Add(ASN1 asn1);
    public virtual Byte[] GetBytes();
    protected void Decode(Byte[] asn1, Int32& anPos, int anLength);
    protected void DecodeTLV(Byte[] asn1, Int32& pos, Byte& tag, Int32& length, Byte[]& content);
    public ASN1 get_Item(int index);
    public ASN1 Element(int index, byte anTag);
    public virtual string ToString();
    public void SaveToFile(string filename);
}
internal static class Mono.Security.ASN1Convert : object {
    public static ASN1 FromDateTime(DateTime dt);
    public static ASN1 FromInt32(int value);
    public static ASN1 FromOid(string oid);
    public static ASN1 FromUnsignedBigInteger(Byte[] big);
    public static int ToInt32(ASN1 asn1);
    public static string ToOid(ASN1 asn1);
    public static DateTime ToDateTime(ASN1 time);
}
internal class Mono.Security.BitConverterLE : object {
    private static Byte[] GetUShortBytes(Byte* bytes);
    private static Byte[] GetUIntBytes(Byte* bytes);
    private static Byte[] GetULongBytes(Byte* bytes);
    internal static Byte[] GetBytes(bool value);
    internal static Byte[] GetBytes(char value);
    internal static Byte[] GetBytes(short value);
    internal static Byte[] GetBytes(int value);
    internal static Byte[] GetBytes(long value);
    internal static Byte[] GetBytes(ushort value);
    internal static Byte[] GetBytes(UInt32 value);
    internal static Byte[] GetBytes(ulong value);
    internal static Byte[] GetBytes(float value);
    internal static Byte[] GetBytes(double value);
    private static void UShortFromBytes(Byte* dst, Byte[] src, int startIndex);
    private static void UIntFromBytes(Byte* dst, Byte[] src, int startIndex);
    private static void ULongFromBytes(Byte* dst, Byte[] src, int startIndex);
    internal static bool ToBoolean(Byte[] value, int startIndex);
    internal static char ToChar(Byte[] value, int startIndex);
    internal static short ToInt16(Byte[] value, int startIndex);
    internal static int ToInt32(Byte[] value, int startIndex);
    internal static long ToInt64(Byte[] value, int startIndex);
    internal static ushort ToUInt16(Byte[] value, int startIndex);
    internal static UInt32 ToUInt32(Byte[] value, int startIndex);
    internal static ulong ToUInt64(Byte[] value, int startIndex);
    internal static float ToSingle(Byte[] value, int startIndex);
    internal static double ToDouble(Byte[] value, int startIndex);
}
internal class Mono.Security.Cryptography.ARC4Managed : RC4 {
    private Byte[] key;
    private Byte[] state;
    private byte x;
    private byte y;
    private bool m_disposed;
    public Byte[] Key { get; public set; }
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public sealed virtual bool get_CanReuseTransform();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgvIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgvIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    private void KeySetup(Byte[] key);
    private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal class Mono.Security.Cryptography.BlockProcessor : object {
    private ICryptoTransform transform;
    private Byte[] block;
    private int blockSize;
    private int blockCount;
    public BlockProcessor(ICryptoTransform transform);
    public BlockProcessor(ICryptoTransform transform, int blockSize);
    protected virtual override void Finalize();
    public void Initialize();
    public void Core(Byte[] rgb);
    public void Core(Byte[] rgb, int ib, int cb);
    public Byte[] Final();
}
internal class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] Trim(Byte[] array);
    internal static bool TryImportCapiPrivateKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiPrivateKeyBlob(Byte[] blob);
    public static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSAParameters GetParametersFromCapiPrivateKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiPrivateKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiPrivateKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiPrivateKeyBlob(RSA rsa);
    public static Byte[] ToCapiPrivateKeyBlob(DSA dsa);
    internal static bool TryImportCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiPublicKeyBlob(Byte[] blob);
    public static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    private static RSAParameters GetParametersFromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiPublicKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiPublicKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiPublicKeyBlob(RSA rsa);
    public static Byte[] ToCapiPublicKeyBlob(DSA dsa);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
    public static DSA FromCapiKeyBlobDSA(Byte[] blob);
    public static DSA FromCapiKeyBlobDSA(Byte[] blob, int offset);
    public static Byte[] ToCapiKeyBlob(AsymmetricAlgorithm keypair, bool includePrivateKey);
    public static Byte[] ToCapiKeyBlob(RSA rsa, bool includePrivateKey);
    public static Byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey);
    public static string ToHex(Byte[] input);
    private static byte FromHexChar(char c);
    public static Byte[] FromHex(string hex);
}
internal class Mono.Security.Cryptography.DSAManaged : DSA {
    private static int defaultKeySize;
    private bool keypairGenerated;
    private bool m_disposed;
    private BigInteger p;
    private BigInteger q;
    private BigInteger g;
    private BigInteger x;
    private BigInteger y;
    private BigInteger j;
    private BigInteger seed;
    private int counter;
    private bool j_missing;
    private RandomNumberGenerator rng;
    [CompilerGeneratedAttribute]
private KeyGeneratedEventHandler KeyGenerated;
    private RandomNumberGenerator Random { get; }
    public int KeySize { get; }
    public string KeyExchangeAlgorithm { get; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public DSAManaged(int dwKeySize);
    protected virtual override void Finalize();
    private void Generate();
    private void GenerateKeyPair();
    private void add(Byte[] a, Byte[] b, int value);
    private void GenerateParams(int keyLength);
    private RandomNumberGenerator get_Random();
    public virtual int get_KeySize();
    public virtual string get_KeyExchangeAlgorithm();
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    private Byte[] NormalizeArray(Byte[] array);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public void add_KeyGenerated(KeyGeneratedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_KeyGenerated(KeyGeneratedEventHandler value);
}
internal class Mono.Security.Cryptography.HMACAlgorithm : object {
    private Byte[] key;
    private Byte[] hash;
    private HashAlgorithm algo;
    private string hashName;
    private BlockProcessor block;
    public HashAlgorithm Algo { get; }
    public string HashName { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACAlgorithm(string algoName);
    protected virtual override void Finalize();
    private void CreateHash(string algoName);
    public void Dispose();
    public HashAlgorithm get_Algo();
    public string get_HashName();
    public void set_HashName(string value);
    public Byte[] get_Key();
    public void set_Key(Byte[] value);
    public void Initialize();
    private Byte[] KeySetup(Byte[] key, byte padding);
    public void Core(Byte[] rgb, int ib, int cb);
    public Byte[] Final();
}
internal class Mono.Security.Cryptography.KeyBuilder : object {
    private static RandomNumberGenerator rng;
    private static RandomNumberGenerator Rng { get; }
    private static RandomNumberGenerator get_Rng();
    public static Byte[] Key(int size);
    public static Byte[] IV(int size);
}
internal class Mono.Security.Cryptography.KeyPairPersistence : object {
    private static bool _userPathExists;
    private static string _userPath;
    private static bool _machinePathExists;
    private static string _machinePath;
    private CspParameters _params;
    private string _keyvalue;
    private string _filename;
    private string _container;
    private static object lockobj;
    public string Filename { get; }
    public string KeyValue { get; public set; }
    public CspParameters Parameters { get; }
    private static string UserPath { get; }
    private static string MachinePath { get; }
    private bool CanChange { get; }
    private bool UseDefaultKeyContainer { get; }
    private bool UseMachineKeyStore { get; }
    private string ContainerName { get; }
    public KeyPairPersistence(CspParameters parameters);
    public KeyPairPersistence(CspParameters parameters, string keyPair);
    private static KeyPairPersistence();
    public string get_Filename();
    public string get_KeyValue();
    public void set_KeyValue(string value);
    public CspParameters get_Parameters();
    public bool Load();
    public void Save();
    public void Remove();
    private static string get_UserPath();
    private static string get_MachinePath();
    internal static bool _CanSecure(Char* root);
    internal static bool _ProtectUser(Char* path);
    internal static bool _ProtectMachine(Char* path);
    internal static bool _IsUserProtected(Char* path);
    internal static bool _IsMachineProtected(Char* path);
    private static bool CanSecure(string path);
    private static bool ProtectUser(string path);
    private static bool ProtectMachine(string path);
    private static bool IsUserProtected(string path);
    private static bool IsMachineProtected(string path);
    private bool get_CanChange();
    private bool get_UseDefaultKeyContainer();
    private bool get_UseMachineKeyStore();
    private string get_ContainerName();
    private CspParameters Copy(CspParameters p);
    private void FromXml(string xml);
    private string ToXml();
}
internal class Mono.Security.Cryptography.MACAlgorithm : object {
    private SymmetricAlgorithm algo;
    private ICryptoTransform enc;
    private Byte[] block;
    private int blockSize;
    private int blockCount;
    public MACAlgorithm(SymmetricAlgorithm algorithm);
    public void Initialize(Byte[] key);
    public void Core(Byte[] rgb, int ib, int cb);
    public Byte[] Final();
}
internal abstract class Mono.Security.Cryptography.MD2 : HashAlgorithm {
    public static MD2 Create();
    public static MD2 Create(string hashName);
}
internal class Mono.Security.Cryptography.MD2Managed : MD2 {
    private Byte[] state;
    private Byte[] checksum;
    private Byte[] buffer;
    private int count;
    private Byte[] x;
    private static Byte[] PI_SUBST;
    private static MD2Managed();
    private Byte[] Padding(int nLength);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void MD2Transform(Byte[] state, Byte[] checksum, Byte[] block, int index);
}
internal abstract class Mono.Security.Cryptography.MD4 : HashAlgorithm {
    public static MD4 Create();
    public static MD4 Create(string hashName);
}
internal class Mono.Security.Cryptography.MD4Managed : MD4 {
    private UInt32[] state;
    private Byte[] buffer;
    private UInt32[] count;
    private UInt32[] x;
    private static int S11;
    private static int S12;
    private static int S13;
    private static int S14;
    private static int S21;
    private static int S22;
    private static int S23;
    private static int S24;
    private static int S31;
    private static int S32;
    private static int S33;
    private static int S34;
    private Byte[] digest;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private Byte[] Padding(int nLength);
    private UInt32 F(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 G(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 H(UInt32 x, UInt32 y, UInt32 z);
    private UInt32 ROL(UInt32 x, byte n);
    private void FF(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void GG(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void HH(UInt32& a, UInt32 b, UInt32 c, UInt32 d, UInt32 x, byte s);
    private void Encode(Byte[] output, UInt32[] input);
    private void Decode(UInt32[] output, Byte[] input, int index);
    private void MD4Transform(UInt32[] state, Byte[] block, int index);
}
internal class Mono.Security.Cryptography.PKCS1 : object {
    private static Byte[] emptySHA1;
    private static Byte[] emptySHA256;
    private static Byte[] emptySHA384;
    private static Byte[] emptySHA512;
    private static PKCS1();
    private static bool Compare(Byte[] array1, Byte[] array2);
    private static Byte[] xor(Byte[] array1, Byte[] array2);
    private static Byte[] GetEmptyHash(HashAlgorithm hash);
    public static Byte[] I2OSP(int x, int size);
    public static Byte[] I2OSP(Byte[] x, int size);
    public static Byte[] OS2IP(Byte[] x);
    public static Byte[] RSAEP(RSA rsa, Byte[] m);
    public static Byte[] RSADP(RSA rsa, Byte[] c);
    public static Byte[] RSASP1(RSA rsa, Byte[] m);
    public static Byte[] RSAVP1(RSA rsa, Byte[] s);
    public static Byte[] Encrypt_OAEP(RSA rsa, HashAlgorithm hash, RandomNumberGenerator rng, Byte[] M);
    public static Byte[] Decrypt_OAEP(RSA rsa, HashAlgorithm hash, Byte[] C);
    public static Byte[] Encrypt_v15(RSA rsa, RandomNumberGenerator rng, Byte[] M);
    public static Byte[] Decrypt_v15(RSA rsa, Byte[] C);
    public static Byte[] Sign_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue);
    internal static Byte[] Sign_v15(RSA rsa, string hashName, Byte[] hashValue);
    public static bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature);
    internal static bool Verify_v15(RSA rsa, string hashName, Byte[] hashValue, Byte[] signature);
    public static bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature, bool tryNonStandardEncoding);
    public static Byte[] Encode_v15(HashAlgorithm hash, Byte[] hashValue, int emLength);
    public static Byte[] MGF1(HashAlgorithm hash, Byte[] mgfSeed, int maskLen);
    internal static string HashNameFromOid(string oid, bool throwOnError);
    internal static HashAlgorithm CreateFromOid(string oid);
    internal static HashAlgorithm CreateFromName(string name);
}
internal abstract class Mono.Security.Cryptography.RC4 : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] IV { get; public set; }
    private static RC4();
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public static RC4 Create();
    public static RC4 Create(string algName);
}
internal class Mono.Security.Cryptography.RSAManaged : RSA {
    private static int defaultKeySize;
    private bool isCRTpossible;
    private bool keyBlinding;
    private bool keypairGenerated;
    private bool m_disposed;
    private BigInteger d;
    private BigInteger p;
    private BigInteger q;
    private BigInteger dp;
    private BigInteger dq;
    private BigInteger qInv;
    private BigInteger n;
    private BigInteger e;
    [CompilerGeneratedAttribute]
private KeyGeneratedEventHandler KeyGenerated;
    public int KeySize { get; }
    public string KeyExchangeAlgorithm { get; }
    public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public bool UseKeyBlinding { get; public set; }
    public bool IsCrtPossible { get; }
    public RSAManaged(int keySize);
    protected virtual override void Finalize();
    private void GenerateKeyPair();
    public virtual int get_KeySize();
    public virtual string get_KeyExchangeAlgorithm();
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public void add_KeyGenerated(KeyGeneratedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_KeyGenerated(KeyGeneratedEventHandler value);
    public virtual string ToXmlString(bool includePrivateParameters);
    public bool get_UseKeyBlinding();
    public void set_UseKeyBlinding(bool value);
    public bool get_IsCrtPossible();
    private Byte[] GetPaddedValue(BigInteger value, int length);
}
internal abstract class Mono.Security.Cryptography.SymmetricTransform : object {
    protected SymmetricAlgorithm algo;
    protected bool encrypt;
    protected int BlockSizeByte;
    protected Byte[] temp;
    protected Byte[] temp2;
    private Byte[] workBuff;
    private Byte[] workout;
    protected PaddingMode padmode;
    protected int FeedBackByte;
    private bool m_disposed;
    protected bool lastBlock;
    private RandomNumberGenerator _rng;
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    private bool KeepLastBlock { get; }
    public SymmetricTransform(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV);
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    protected virtual void Transform(Byte[] input, Byte[] output);
    protected abstract virtual void ECB(Byte[] input, Byte[] output);
    protected virtual void CBC(Byte[] input, Byte[] output);
    protected virtual void CFB(Byte[] input, Byte[] output);
    protected virtual void OFB(Byte[] input, Byte[] output);
    protected virtual void CTS(Byte[] input, Byte[] output);
    private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount);
    public virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private bool get_KeepLastBlock();
    private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    private void Random(Byte[] buffer, int start, int length);
    private void ThrowBadPaddingException(PaddingMode padding, int length, int position);
    protected virtual Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount);
    public virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal class Mono.Security.StrongName : object {
    private RSA rsa;
    private Byte[] publicKey;
    private Byte[] keyToken;
    private string tokenAlgorithm;
    private static object lockObject;
    private static bool initialized;
    public bool CanSign { get; }
    public RSA RSA { get; public set; }
    public Byte[] PublicKey { get; }
    public Byte[] PublicKeyToken { get; }
    public string TokenAlgorithm { get; public set; }
    public StrongName(int keySize);
    public StrongName(Byte[] data);
    public StrongName(RSA rsa);
    private static StrongName();
    private void InvalidateCache();
    public bool get_CanSign();
    public RSA get_RSA();
    public void set_RSA(RSA value);
    public Byte[] get_PublicKey();
    public Byte[] get_PublicKeyToken();
    private static HashAlgorithm GetHashAlgorithm(string algorithm);
    public string get_TokenAlgorithm();
    public void set_TokenAlgorithm(string value);
    public Byte[] GetBytes();
    private UInt32 RVAtoPosition(UInt32 r, int sections, Byte[] headers);
    private static StrongNameSignature Error(string a);
    private static Byte[] ReadMore(Stream stream, Byte[] a, int newSize);
    internal StrongNameSignature StrongHash(Stream stream, StrongNameOptions options);
    public Byte[] Hash(string fileName);
    public bool Sign(string fileName);
    public bool Verify(string fileName);
    public bool Verify(Stream stream);
    public static bool IsAssemblyStrongnamed(string assemblyName);
    public static bool VerifySignature(Byte[] publicKey, int algorithm, Byte[] hash, Byte[] signature);
    private static bool Verify(RSA rsa, AssemblyHashAlgorithm algorithm, Byte[] hash, Byte[] signature);
}
internal class Mono.Security.StrongNameManager : object {
    private static Hashtable mappings;
    private static Hashtable tokens;
    public static void LoadConfig(string filename);
    private static void LoadMapping(SecurityElement mapping);
    private static void LoadVerificationSettings(SecurityElement settings);
    public static Byte[] GetMappedPublicKey(Byte[] token);
    public static bool MustVerify(AssemblyName an);
    public virtual string ToString();
}
internal class Mono.Security.Uri : object {
    private bool isUnixFilePath;
    private string source;
    private string scheme;
    private string host;
    private int port;
    private string path;
    private string query;
    private string fragment;
    private string userinfo;
    private bool isUnc;
    private bool isOpaquePart;
    private String[] segments;
    private bool userEscaped;
    private string cachedAbsoluteUri;
    private string cachedToString;
    private string cachedLocalPath;
    private int cachedHashCode;
    private bool reduce;
    private static string hexUpperChars;
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeMailto;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    private static UriScheme[] schemes;
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string Authority { get; }
    public string Fragment { get; }
    public string Host { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public bool IsUnc { get; }
    public string LocalPath { get; }
    public string PathAndQuery { get; }
    public int Port { get; }
    public string Query { get; }
    public string Scheme { get; }
    public String[] Segments { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    public Uri(string uriString);
    public Uri(string uriString, bool dontEscape);
    public Uri(string uriString, bool dontEscape, bool reduce);
    public Uri(Uri baseUri, string relativeUri);
    public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    private static Uri();
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_Authority();
    public string get_Fragment();
    public string get_Host();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public bool get_IsUnc();
    public string get_LocalPath();
    public string get_PathAndQuery();
    public int get_Port();
    public string get_Query();
    public string get_Scheme();
    public String[] get_Segments();
    public bool get_UserEscaped();
    public string get_UserInfo();
    internal static bool IsIPv4Address(string name);
    internal static bool IsDomainAddress(string name);
    public static bool CheckSchemeName(string schemeName);
    public virtual bool Equals(object comparant);
    public virtual int GetHashCode();
    public string GetLeftPart(UriPartial part);
    public static int FromHex(char digit);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    public static bool IsHexDigit(char digit);
    public static bool IsHexEncoding(string pattern, int index);
    public string MakeRelative(Uri toUri);
    public virtual string ToString();
    protected void Escape();
    protected static string EscapeString(string str);
    internal static string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets);
    protected void Parse();
    protected string Unescape(string str);
    internal string Unescape(string str, bool excludeSharp);
    private void ParseAsWindowsUNC(string uriString);
    private void ParseAsWindowsAbsoluteFilePath(string uriString);
    private void ParseAsUnixAbsoluteFilePath(string uriString);
    private void Parse(string uriString);
    private static string Reduce(string path);
    internal static string GetSchemeDelimiter(string scheme);
    internal static int GetDefaultPort(string scheme);
    private string GetOpaqueWiseSchemeDelimiter();
    protected bool IsBadFileSystemCharacter(char ch);
    protected static bool IsExcludedCharacter(char ch);
    private static bool IsPredefinedScheme(string scheme);
    protected bool IsReservedCharacter(char ch);
}
internal enum Mono.Security.UriPartial : Enum {
    public int value__;
    public static UriPartial Scheme;
    public static UriPartial Authority;
    public static UriPartial Path;
}
internal class Mono.ValueTuple : ValueType {
}
internal class Mono.ValueTuple`1 : ValueType {
    public T1 Item1;
}
internal class Mono.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
}
internal class Mono.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
}
internal class Mono.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
}
internal class Mono.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
}
internal class Mono.Xml.DefaultHandler : object {
    public sealed virtual void OnStartParsing(SmallXmlParser parser);
    public sealed virtual void OnEndParsing(SmallXmlParser parser);
    public sealed virtual void OnStartElement(string name, IAttrList attrs);
    public sealed virtual void OnEndElement(string name);
    public sealed virtual void OnChars(string s);
    public sealed virtual void OnIgnorableWhitespace(string s);
    public sealed virtual void OnProcessingInstruction(string name, string text);
}
internal class Mono.Xml.SecurityParser : SmallXmlParser {
    private SecurityElement root;
    private SecurityElement current;
    private Stack stack;
    public void LoadXml(string xml);
    public SecurityElement ToXml();
    public sealed virtual void OnStartParsing(SmallXmlParser parser);
    public sealed virtual void OnProcessingInstruction(string name, string text);
    public sealed virtual void OnIgnorableWhitespace(string s);
    public sealed virtual void OnStartElement(string name, IAttrList attrs);
    public sealed virtual void OnEndElement(string name);
    public sealed virtual void OnChars(string ch);
    public sealed virtual void OnEndParsing(SmallXmlParser parser);
}
internal class Mono.Xml.SmallXmlParser : object {
    private IContentHandler handler;
    private TextReader reader;
    private Stack elementNames;
    private Stack xmlSpaces;
    private string xmlSpace;
    private StringBuilder buffer;
    private Char[] nameBuffer;
    private bool isWhitespace;
    private AttrListImpl attributes;
    private int line;
    private int column;
    private bool resetColumn;
    private Exception Error(string msg);
    private Exception UnexpectedEndError();
    private bool IsNameChar(char c, bool start);
    private bool IsWhitespace(int c);
    public void SkipWhitespaces();
    private void HandleWhitespaces();
    public void SkipWhitespaces(bool expected);
    private int Peek();
    private int Read();
    public void Expect(int c);
    private string ReadUntil(char until, bool handleReferences);
    public string ReadName();
    public void Parse(TextReader input, IContentHandler handler);
    private void Cleanup();
    public void ReadContent();
    private void HandleBufferedContent();
    private void ReadCharacters();
    private void ReadReference();
    private int ReadCharacterReference();
    private void ReadAttribute(AttrListImpl a);
    private void ReadCDATASection();
    private void ReadComment();
}
internal class Mono.Xml.SmallXmlParserException : SystemException {
    private int line;
    private int column;
    public int Line { get; }
    public int Column { get; }
    public SmallXmlParserException(string msg, int line, int column);
    public int get_Line();
    public int get_Column();
}
internal static class SR : object {
    public static string RTL;
    public static string ContinueButtonText;
    public static string DebugMessageTruncated;
    public static string DebugAssertTitleShort;
    public static string DebugAssertTitle;
    public static string NotSupported;
    public static string DebugLaunchFailed;
    public static string DebugLaunchFailedTitle;
    public static string ObjectDisposed;
    public static string ExceptionOccurred;
    public static string MustAddListener;
    public static string ToStringNull;
    public static string EnumConverterInvalidValue;
    public static string ConvertFromException;
    public static string ConvertToException;
    public static string ConvertInvalidPrimitive;
    public static string ErrorMissingPropertyAccessors;
    public static string ErrorInvalidPropertyType;
    public static string ErrorMissingEventAccessors;
    public static string ErrorInvalidEventHandler;
    public static string ErrorInvalidEventType;
    public static string InvalidMemberName;
    public static string ErrorBadExtenderType;
    public static string NullableConverterBadCtorArg;
    public static string TypeDescriptorExpectedElementType;
    public static string TypeDescriptorSameAssociation;
    public static string TypeDescriptorAlreadyAssociated;
    public static string TypeDescriptorProviderError;
    public static string TypeDescriptorUnsupportedRemoteObject;
    public static string TypeDescriptorArgsCountMismatch;
    public static string ErrorCreateSystemEvents;
    public static string ErrorCreateTimer;
    public static string ErrorKillTimer;
    public static string ErrorSystemEventsNotSupported;
    public static string ErrorGetTempPath;
    public static string CHECKOUTCanceled;
    public static string ErrorInvalidServiceInstance;
    public static string ErrorServiceExists;
    public static string Argument_InvalidNumberStyles;
    public static string Argument_InvalidHexStyle;
    public static string Argument_ByteArrayLengthMustBeAMultipleOf4;
    public static string Argument_InvalidCharactersInString;
    public static string Argument_ParsedStringWasInvalid;
    public static string Argument_MustBeBigInt;
    public static string Format_InvalidFormatSpecifier;
    public static string Format_TooLarge;
    public static string ArgumentOutOfRange_MustBeLessThanUInt32MaxValue;
    public static string ArgumentOutOfRange_MustBeNonNeg;
    public static string NotSupported_NumberStyle;
    public static string Overflow_BigIntInfinity;
    public static string Overflow_NotANumber;
    public static string Overflow_ParseBigInteger;
    public static string Overflow_Int32;
    public static string Overflow_Int64;
    public static string Overflow_UInt32;
    public static string Overflow_UInt64;
    public static string Overflow_Decimal;
    public static string Argument_FrameworkNameTooShort;
    public static string Argument_FrameworkNameInvalid;
    public static string Argument_FrameworkNameInvalidVersion;
    public static string Argument_FrameworkNameMissingVersion;
    public static string ArgumentNull_Key;
    public static string Argument_InvalidValue;
    public static string Arg_MultiRank;
    public static string Barrier_ctor_ArgumentOutOfRange;
    public static string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange;
    public static string Barrier_AddParticipants_Overflow_ArgumentOutOfRange;
    public static string Barrier_InvalidOperation_CalledFromPHA;
    public static string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange;
    public static string Barrier_RemoveParticipants_ArgumentOutOfRange;
    public static string Barrier_RemoveParticipants_InvalidOperation;
    public static string Barrier_SignalAndWait_ArgumentOutOfRange;
    public static string Barrier_SignalAndWait_InvalidOperation_ZeroTotal;
    public static string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded;
    public static string Barrier_Dispose;
    public static string BarrierPostPhaseException;
    public static string UriTypeConverter_ConvertFrom_CannotConvert;
    public static string UriTypeConverter_ConvertTo_CannotConvert;
    public static string ISupportInitializeDescr;
    public static string CantModifyListSortDescriptionCollection;
    public static string Argument_NullComment;
    public static string InvalidPrimitiveType;
    public static string Cannot_Specify_Both_Compiler_Path_And_Version;
    public static string CodeGenOutputWriter;
    public static string CodeGenReentrance;
    public static string InvalidLanguageIdentifier;
    public static string InvalidTypeName;
    public static string Empty_attribute;
    public static string Invalid_nonnegative_integer_attribute;
    public static string CodeDomProvider_NotDefined;
    public static string Language_Names_Cannot_Be_Empty;
    public static string Extension_Names_Cannot_Be_Empty_Or_Non_Period_Based;
    public static string Unable_To_Locate_Type;
    public static string NotSupported_CodeDomAPI;
    public static string ArityDoesntMatch;
    public static string PartialTrustErrorTextReplacement;
    public static string PartialTrustIllegalProvider;
    public static string IllegalAssemblyReference;
    public static string NullOrEmpty_Value_in_Property;
    public static string AutoGen_Comment_Line1;
    public static string AutoGen_Comment_Line2;
    public static string AutoGen_Comment_Line3;
    public static string AutoGen_Comment_Line4;
    public static string AutoGen_Comment_Line5;
    public static string CantContainNullEntries;
    public static string InvalidPathCharsInChecksum;
    public static string InvalidRegion;
    public static string Provider_does_not_support_options;
    public static string MetaExtenderName;
    public static string InvalidEnumArgument;
    public static string InvalidArgument;
    public static string InvalidNullArgument;
    public static string LicExceptionTypeOnly;
    public static string LicExceptionTypeAndInstance;
    public static string LicMgrContextCannotBeChanged;
    public static string LicMgrAlreadyLocked;
    public static string LicMgrDifferentUser;
    public static string InvalidElementType;
    public static string InvalidIdentifier;
    public static string ExecFailedToCreate;
    public static string ExecTimeout;
    public static string ExecBadreturn;
    public static string ExecCantGetRetCode;
    public static string ExecCantExec;
    public static string ExecCantRevert;
    public static string CompilerNotFound;
    public static string DuplicateFileName;
    public static string CollectionReadOnly;
    public static string BitVectorFull;
    public static string ArrayConverterText;
    public static string CollectionConverterText;
    public static string MultilineStringConverterText;
    public static string CultureInfoConverterDefaultCultureString;
    public static string CultureInfoConverterInvalidCulture;
    public static string InvalidPrimitive;
    public static string TimerInvalidInterval;
    public static string TraceSwitchLevelTooHigh;
    public static string TraceSwitchLevelTooLow;
    public static string TraceSwitchInvalidLevel;
    public static string TraceListenerIndentSize;
    public static string TraceListenerFail;
    public static string TraceAsTraceSource;
    public static string InvalidLowBoundArgument;
    public static string DuplicateComponentName;
    public static string NotImplemented;
    public static string OutOfMemory;
    public static string EOF;
    public static string IOError;
    public static string BadChar;
    public static string toStringNone;
    public static string toStringUnknown;
    public static string InvalidEnum;
    public static string IndexOutOfRange;
    public static string ErrorPropertyAccessorException;
    public static string InvalidOperation;
    public static string EmptyStack;
    public static string PerformanceCounterDesc;
    public static string PCCategoryName;
    public static string PCCounterName;
    public static string PCInstanceName;
    public static string PCMachineName;
    public static string PCInstanceLifetime;
    public static string PropertyCategoryAction;
    public static string PropertyCategoryAppearance;
    public static string PropertyCategoryAsynchronous;
    public static string PropertyCategoryBehavior;
    public static string PropertyCategoryData;
    public static string PropertyCategoryDDE;
    public static string PropertyCategoryDesign;
    public static string PropertyCategoryDragDrop;
    public static string PropertyCategoryFocus;
    public static string PropertyCategoryFont;
    public static string PropertyCategoryFormat;
    public static string PropertyCategoryKey;
    public static string PropertyCategoryList;
    public static string PropertyCategoryLayout;
    public static string PropertyCategoryDefault;
    public static string PropertyCategoryMouse;
    public static string PropertyCategoryPosition;
    public static string PropertyCategoryText;
    public static string PropertyCategoryScale;
    public static string PropertyCategoryWindowStyle;
    public static string PropertyCategoryConfig;
    public static string ArgumentNull_ArrayWithNullElements;
    public static string OnlyAllowedOnce;
    public static string BeginIndexNotNegative;
    public static string LengthNotNegative;
    public static string UnimplementedState;
    public static string UnexpectedOpcode;
    public static string NoResultOnFailed;
    public static string UnterminatedBracket;
    public static string TooManyParens;
    public static string NestedQuantify;
    public static string QuantifyAfterNothing;
    public static string InternalError;
    public static string IllegalRange;
    public static string NotEnoughParens;
    public static string BadClassInCharRange;
    public static string ReversedCharRange;
    public static string UndefinedReference;
    public static string MalformedReference;
    public static string UnrecognizedGrouping;
    public static string UnterminatedComment;
    public static string IllegalEndEscape;
    public static string MalformedNameRef;
    public static string UndefinedBackref;
    public static string UndefinedNameRef;
    public static string TooFewHex;
    public static string MissingControl;
    public static string UnrecognizedControl;
    public static string UnrecognizedEscape;
    public static string IllegalCondition;
    public static string TooManyAlternates;
    public static string MakeException;
    public static string IncompleteSlashP;
    public static string MalformedSlashP;
    public static string InvalidGroupName;
    public static string CapnumNotZero;
    public static string AlternationCantCapture;
    public static string AlternationCantHaveComment;
    public static string CaptureGroupOutOfRange;
    public static string SubtractionMustBeLast;
    public static string UnknownProperty;
    public static string ReplacementError;
    public static string CountTooSmall;
    public static string EnumNotStarted;
    public static string Arg_InvalidArrayType;
    public static string RegexMatchTimeoutException_Occurred;
    public static string IllegalDefaultRegexMatchTimeoutInAppDomain;
    public static string FileObject_AlreadyOpen;
    public static string FileObject_Closed;
    public static string FileObject_NotWhileWriting;
    public static string FileObject_FileDoesNotExist;
    public static string FileObject_MustBeClosed;
    public static string FileObject_MustBeFileName;
    public static string FileObject_InvalidInternalState;
    public static string FileObject_PathNotSet;
    public static string FileObject_Reading;
    public static string FileObject_Writing;
    public static string FileObject_InvalidEnumeration;
    public static string FileObject_NoReset;
    public static string DirectoryObject_MustBeDirName;
    public static string DirectoryObjectPathDescr;
    public static string FileObjectDetectEncodingDescr;
    public static string FileObjectEncodingDescr;
    public static string FileObjectPathDescr;
    public static string Arg_EnumIllegalVal;
    public static string Arg_OutOfRange_NeedNonNegNum;
    public static string Argument_InvalidPermissionState;
    public static string Argument_InvalidOidValue;
    public static string Argument_WrongType;
    public static string Arg_EmptyOrNullString;
    public static string Arg_EmptyOrNullArray;
    public static string Argument_InvalidClassAttribute;
    public static string Argument_InvalidNameType;
    public static string InvalidOperation_DuplicateItemNotAllowed;
    public static string Cryptography_Asn_MismatchedOidInCollection;
    public static string Cryptography_Cms_Envelope_Empty_Content;
    public static string Cryptography_Cms_Invalid_Recipient_Info_Type;
    public static string Cryptography_Cms_Invalid_Subject_Identifier_Type;
    public static string Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch;
    public static string Cryptography_Cms_Key_Agree_Date_Not_Available;
    public static string Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available;
    public static string Cryptography_Cms_MessageNotSigned;
    public static string Cryptography_Cms_MessageNotSignedByNoSignature;
    public static string Cryptography_Cms_MessageNotEncrypted;
    public static string Cryptography_Cms_Not_Supported;
    public static string Cryptography_Cms_RecipientCertificateNotFound;
    public static string Cryptography_Cms_Sign_Empty_Content;
    public static string Cryptography_Cms_Sign_No_Signature_First_Signer;
    public static string Cryptography_DpApi_InvalidMemoryLength;
    public static string Cryptography_InvalidHandle;
    public static string Cryptography_InvalidContextHandle;
    public static string Cryptography_InvalidStoreHandle;
    public static string Cryptography_Oid_InvalidValue;
    public static string Cryptography_Pkcs9_ExplicitAddNotAllowed;
    public static string Cryptography_Pkcs9_InvalidOid;
    public static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed;
    public static string Cryptography_Pkcs9_AttributeMismatch;
    public static string Cryptography_X509_AddFailed;
    public static string Cryptography_X509_BadEncoding;
    public static string Cryptography_X509_ExportFailed;
    public static string Cryptography_X509_ExtensionMismatch;
    public static string Cryptography_X509_InvalidFindType;
    public static string Cryptography_X509_InvalidFindValue;
    public static string Cryptography_X509_InvalidEncodingFormat;
    public static string Cryptography_X509_InvalidContentType;
    public static string Cryptography_X509_KeyMismatch;
    public static string Cryptography_X509_RemoveFailed;
    public static string Cryptography_X509_StoreNotOpen;
    public static string Environment_NotInteractive;
    public static string NotSupported_InvalidKeyImpl;
    public static string NotSupported_KeyAlgorithm;
    public static string NotSupported_PlatformRequiresNT;
    public static string NotSupported_UnreadableStream;
    public static string Security_InvalidValue;
    public static string Unknown_Error;
    public static string security_ServiceNameCollection_EmptyServiceName;
    public static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever;
    public static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection;
    public static string security_ExtendedProtection_NoOSSupport;
    public static string net_nonClsCompliantException;
    public static string net_illegalConfigWith;
    public static string net_illegalConfigWithout;
    public static string net_resubmitcanceled;
    public static string net_redirect_perm;
    public static string net_resubmitprotofailed;
    public static string net_invalidversion;
    public static string net_toolong;
    public static string net_connclosed;
    public static string net_mutualauthfailed;
    public static string net_invasync;
    public static string net_inasync;
    public static string net_mustbeuri;
    public static string net_format_shexp;
    public static string net_cannot_load_proxy_helper;
    public static string net_io_no_0timeouts;
    public static string net_tooManyRedirections;
    public static string net_authmodulenotregistered;
    public static string net_authschemenotregistered;
    public static string net_proxyschemenotsupported;
    public static string net_maxsrvpoints;
    public static string net_notconnected;
    public static string net_notstream;
    public static string net_nocontentlengthonget;
    public static string net_contentlengthmissing;
    public static string net_nonhttpproxynotallowed;
    public static string net_need_writebuffering;
    public static string net_nodefaultcreds;
    public static string net_stopped;
    public static string net_udpconnected;
    public static string net_no_concurrent_io_allowed;
    public static string net_needmorethreads;
    public static string net_MethodNotSupportedException;
    public static string net_ProtocolNotSupportedException;
    public static string net_SelectModeNotSupportedException;
    public static string net_InvalidSocketHandle;
    public static string net_InvalidAddressFamily;
    public static string net_InvalidEndPointAddressFamily;
    public static string net_InvalidSocketAddressSize;
    public static string net_invalidAddressList;
    public static string net_invalidPingBufferSize;
    public static string net_cant_perform_during_shutdown;
    public static string net_cant_create_environment;
    public static string net_protocol_invalid_family;
    public static string net_protocol_invalid_multicast_family;
    public static string net_empty_osinstalltype;
    public static string net_unknown_osinstalltype;
    public static string net_cant_determine_osinstalltype;
    public static string net_osinstalltype;
    public static string net_entire_body_not_written;
    public static string net_must_provide_request_body;
    public static string net_sockets_zerolist;
    public static string net_sockets_blocking;
    public static string net_sockets_useblocking;
    public static string net_sockets_select;
    public static string net_sockets_toolarge_select;
    public static string net_sockets_empty_select;
    public static string net_sockets_mustbind;
    public static string net_sockets_mustlisten;
    public static string net_sockets_mustnotlisten;
    public static string net_sockets_mustnotbebound;
    public static string net_sockets_namedmustnotbebound;
    public static string net_sockets_invalid_socketinformation;
    public static string net_sockets_invalid_ipaddress_length;
    public static string net_sockets_invalid_optionValue;
    public static string net_sockets_invalid_optionValue_all;
    public static string net_sockets_invalid_dnsendpoint;
    public static string net_sockets_disconnectedConnect;
    public static string net_sockets_disconnectedAccept;
    public static string net_tcplistener_mustbestopped;
    public static string net_sockets_no_duplicate_async;
    public static string net_socketopinprogress;
    public static string net_buffercounttoosmall;
    public static string net_multibuffernotsupported;
    public static string net_ambiguousbuffers;
    public static string net_sockets_ipv6only;
    public static string net_perfcounter_initialized_success;
    public static string net_perfcounter_initialized_error;
    public static string net_perfcounter_nocategory;
    public static string net_perfcounter_initialization_started;
    public static string net_perfcounter_cant_queue_workitem;
    public static string net_config_proxy;
    public static string net_config_proxy_module_not_public;
    public static string net_config_authenticationmodules;
    public static string net_config_webrequestmodules;
    public static string net_config_requestcaching;
    public static string net_config_section_permission;
    public static string net_config_element_permission;
    public static string net_config_property_permission;
    public static string net_WebResponseParseError_InvalidHeaderName;
    public static string net_WebResponseParseError_InvalidContentLength;
    public static string net_WebResponseParseError_IncompleteHeaderLine;
    public static string net_WebResponseParseError_CrLfError;
    public static string net_WebResponseParseError_InvalidChunkFormat;
    public static string net_WebResponseParseError_UnexpectedServerResponse;
    public static string net_webstatus_Success;
    public static string net_webstatus_ReceiveFailure;
    public static string net_webstatus_SendFailure;
    public static string net_webstatus_PipelineFailure;
    public static string net_webstatus_RequestCanceled;
    public static string net_webstatus_ConnectionClosed;
    public static string net_webstatus_TrustFailure;
    public static string net_webstatus_SecureChannelFailure;
    public static string net_webstatus_ServerProtocolViolation;
    public static string net_webstatus_KeepAliveFailure;
    public static string net_webstatus_ProxyNameResolutionFailure;
    public static string net_webstatus_MessageLengthLimitExceeded;
    public static string net_webstatus_CacheEntryNotFound;
    public static string net_webstatus_RequestProhibitedByCachePolicy;
    public static string net_webstatus_RequestProhibitedByProxy;
    public static string net_httpstatuscode_NoContent;
    public static string net_httpstatuscode_NonAuthoritativeInformation;
    public static string net_httpstatuscode_ResetContent;
    public static string net_httpstatuscode_PartialContent;
    public static string net_httpstatuscode_MultipleChoices;
    public static string net_httpstatuscode_Ambiguous;
    public static string net_httpstatuscode_MovedPermanently;
    public static string net_httpstatuscode_Moved;
    public static string net_httpstatuscode_Found;
    public static string net_httpstatuscode_Redirect;
    public static string net_httpstatuscode_SeeOther;
    public static string net_httpstatuscode_RedirectMethod;
    public static string net_httpstatuscode_NotModified;
    public static string net_httpstatuscode_UseProxy;
    public static string net_httpstatuscode_TemporaryRedirect;
    public static string net_httpstatuscode_RedirectKeepVerb;
    public static string net_httpstatuscode_BadRequest;
    public static string net_httpstatuscode_Unauthorized;
    public static string net_httpstatuscode_PaymentRequired;
    public static string net_httpstatuscode_Forbidden;
    public static string net_httpstatuscode_NotFound;
    public static string net_httpstatuscode_MethodNotAllowed;
    public static string net_httpstatuscode_NotAcceptable;
    public static string net_httpstatuscode_ProxyAuthenticationRequired;
    public static string net_httpstatuscode_RequestTimeout;
    public static string net_httpstatuscode_Conflict;
    public static string net_httpstatuscode_Gone;
    public static string net_httpstatuscode_LengthRequired;
    public static string net_httpstatuscode_InternalServerError;
    public static string net_httpstatuscode_NotImplemented;
    public static string net_httpstatuscode_BadGateway;
    public static string net_httpstatuscode_ServiceUnavailable;
    public static string net_httpstatuscode_GatewayTimeout;
    public static string net_httpstatuscode_HttpVersionNotSupported;
    public static string net_emptystringset;
    public static string net_emptystringcall;
    public static string net_headers_req;
    public static string net_headers_rsp;
    public static string net_headers_toolong;
    public static string net_WebHeaderInvalidNonAsciiChars;
    public static string net_WebHeaderMissingColon;
    public static string net_headerrestrict;
    public static string net_io_completionportwasbound;
    public static string net_io_writefailure;
    public static string net_io_readfailure;
    public static string net_io_connectionclosed;
    public static string net_io_transportfailure;
    public static string net_io_internal_bind;
    public static string net_io_invalidnestedcall;
    public static string net_io_must_be_rw_stream;
    public static string net_io_header_id;
    public static string net_io_out_range;
    public static string net_io_encrypt;
    public static string net_io_decrypt;
    public static string net_io_read;
    public static string net_io_write;
    public static string net_io_eof;
    public static string net_io_async_result;
    public static string net_tls_version;
    public static string net_perm_target;
    public static string net_perm_both_regex;
    public static string net_perm_none;
    public static string net_perm_attrib_count;
    public static string net_perm_invalid_val;
    public static string net_perm_attrib_multi;
    public static string net_perm_epname;
    public static string net_perm_invalid_val_in_element;
    public static string net_invalid_ip_addr;
    public static string dns_bad_ip_address;
    public static string net_bad_mac_address;
    public static string net_ping;
    public static string net_bad_ip_address_prefix;
    public static string net_max_ip_address_list_length_exceeded;
    public static string net_ipv4_not_installed;
    public static string net_ipv6_not_installed;
    public static string net_webclient;
    public static string net_webclient_ContentType;
    public static string net_webclient_Multipart;
    public static string net_webclient_no_concurrent_io_allowed;
    public static string net_webclient_invalid_baseaddress;
    public static string net_container_add_cookie;
    public static string net_cookie_invalid;
    public static string net_cookie_size;
    public static string net_cookie_parse_header;
    public static string net_cookie_attribute;
    public static string net_cookie_format;
    public static string net_cookie_capacity_range;
    public static string net_set_token;
    public static string net_revert_token;
    public static string net_ssl_io_async_context;
    public static string net_ssl_io_encrypt;
    public static string net_ssl_io_decrypt;
    public static string net_ssl_io_context_expired;
    public static string net_ssl_io_handshake_start;
    public static string net_ssl_io_handshake;
    public static string net_ssl_io_frame;
    public static string net_ssl_io_corrupted;
    public static string net_ssl_io_cert_validation;
    public static string net_ssl_io_invalid_end_call;
    public static string net_ssl_io_invalid_begin_call;
    public static string net_ssl_io_no_server_cert;
    public static string net_auth_bad_client_creds;
    public static string net_auth_bad_client_creds_or_target_mismatch;
    public static string net_auth_context_expectation;
    public static string net_auth_context_expectation_remote;
    public static string net_auth_supported_impl_levels;
    public static string net_auth_no_anonymous_support;
    public static string net_auth_reauth;
    public static string net_auth_noauth;
    public static string net_auth_client_server;
    public static string net_auth_noencryption;
    public static string net_auth_SSPI;
    public static string net_auth_failure;
    public static string net_auth_eof;
    public static string net_auth_alert;
    public static string net_auth_ignored_reauth;
    public static string net_auth_empty_read;
    public static string net_auth_must_specify_extended_protection_scheme;
    public static string net_frame_size;
    public static string net_frame_read_io;
    public static string net_frame_read_size;
    public static string net_frame_max_size;
    public static string net_jscript_load;
    public static string net_proxy_not_gmt;
    public static string net_proxy_invalid_dayofweek;
    public static string net_proxy_invalid_url_format;
    public static string net_param_not_string;
    public static string net_value_cannot_be_negative;
    public static string net_invalid_offset;
    public static string net_offset_plus_count;
    public static string net_cannot_be_false;
    public static string net_cache_shadowstream_not_writable;
    public static string net_cache_validator_fail;
    public static string net_cache_access_denied;
    public static string net_cache_validator_result;
    public static string net_cache_retrieve_failure;
    public static string net_cache_not_supported_body;
    public static string net_cache_not_supported_command;
    public static string net_cache_not_accept_response;
    public static string net_cache_method_failed;
    public static string net_cache_key_failed;
    public static string net_cache_no_stream;
    public static string net_cache_unsupported_partial_stream;
    public static string net_cache_not_configured;
    public static string net_cache_non_seekable_stream_not_supported;
    public static string net_invalid_cast;
    public static string net_collection_readonly;
    public static string net_not_ipermission;
    public static string net_no_classname;
    public static string net_no_typename;
    public static string net_servicePointAddressNotSupportedInHostMode;
    public static string net_Websockets_WebSocketBaseFaulted;
    public static string net_WebSockets_Generic;
    public static string net_WebSockets_NotAWebSocket_Generic;
    public static string net_WebSockets_UnsupportedWebSocketVersion_Generic;
    public static string net_WebSockets_HeaderError_Generic;
    public static string net_WebSockets_UnsupportedProtocol_Generic;
    public static string net_WebSockets_ClientSecWebSocketProtocolsBlank;
    public static string net_WebSockets_InvalidState_Generic;
    public static string net_WebSockets_InvalidMessageType_Generic;
    public static string net_WebSockets_ConnectionClosedPrematurely_Generic;
    public static string net_WebSockets_Scheme;
    public static string net_WebSockets_AlreadyStarted;
    public static string net_WebSockets_Connect101Expected;
    public static string net_WebSockets_InvalidResponseHeader;
    public static string net_WebSockets_NotConnected;
    public static string net_WebSockets_InvalidRegistration;
    public static string net_WebSockets_NoDuplicateProtocol;
    public static string net_log_exception;
    public static string net_log_sspi_enumerating_security_packages;
    public static string net_log_sspi_security_package_not_found;
    public static string net_log_sspi_security_context_input_buffer;
    public static string net_log_sspi_security_context_input_buffers;
    public static string net_log_sspi_selected_cipher_suite;
    public static string net_log_remote_certificate;
    public static string net_log_locating_private_key_for_certificate;
    public static string net_log_cert_is_of_type_2;
    public static string net_log_found_cert_in_store;
    public static string net_log_did_not_find_cert_in_store;
    public static string net_log_open_store_failed;
    public static string net_log_got_certificate_from_delegate;
    public static string net_log_no_delegate_and_have_no_client_cert;
    public static string net_log_no_delegate_but_have_client_cert;
    public static string net_log_attempting_restart_using_cert;
    public static string net_log_no_issuers_try_all_certs;
    public static string net_log_server_issuers_look_for_matching_certs;
    public static string net_log_selected_cert;
    public static string net_log_n_certs_after_filtering;
    public static string net_log_finding_matching_certs;
    public static string net_log_using_cached_credential;
    public static string net_log_remote_cert_user_declared_valid;
    public static string net_log_remote_cert_user_declared_invalid;
    public static string net_log_remote_cert_has_no_errors;
    public static string net_log_remote_cert_has_errors;
    public static string net_log_remote_cert_not_available;
    public static string net_log_remote_cert_name_mismatch;
    public static string net_log_proxy_autodetect_script_location_parse_error;
    public static string net_log_proxy_autodetect_failed;
    public static string net_log_proxy_script_execution_error;
    public static string net_log_proxy_script_download_compile_error;
    public static string net_log_proxy_system_setting_update;
    public static string net_log_proxy_update_due_to_ip_config_change;
    public static string net_log_proxy_called_with_null_parameter;
    public static string net_log_proxy_called_with_invalid_parameter;
    public static string net_log_proxy_ras_supported;
    public static string net_log_proxy_ras_notsupported_exception;
    public static string net_log_proxy_winhttp_cant_open_session;
    public static string net_log_proxy_winhttp_getproxy_failed;
    public static string net_log_proxy_winhttp_timeout_error;
    public static string net_log_cache_validation_failed_resubmit;
    public static string net_log_cache_refused_server_response;
    public static string net_log_cache_ftp_proxy_doesnt_support_partial;
    public static string net_log_cache_ftp_method;
    public static string net_log_cache_ftp_supports_bin_only;
    public static string net_log_cache_replacing_entry_with_HTTP_200;
    public static string net_log_cache_now_time;
    public static string net_log_cache_max_age_absolute;
    public static string net_log_cache_age1;
    public static string net_log_cache_age1_date_header;
    public static string net_log_cache_age1_last_synchronized;
    public static string net_log_cache_age1_last_synchronized_age_header;
    public static string net_log_cache_age2;
    public static string net_log_cache_max_age_cache_s_max_age;
    public static string net_log_cache_max_age_expires_date;
    public static string net_log_cache_max_age_cache_max_age;
    public static string net_log_cache_no_max_age_use_10_percent;
    public static string net_log_cache_no_max_age_use_default;
    public static string net_log_cache_validator_invalid_for_policy;
    public static string net_log_cache_response_last_modified;
    public static string net_log_cache_cache_last_modified;
    public static string net_log_cache_partial_and_non_zero_content_offset;
    public static string net_log_cache_response_valid_based_on_policy;
    public static string net_log_cache_null_response_failure;
    public static string net_log_cache_ftp_response_status;
    public static string net_log_cache_resp_valid_based_on_retry;
    public static string net_log_cache_no_update_based_on_method;
    public static string net_log_cache_removed_existing_invalid_entry;
    public static string net_log_cache_not_updated_based_on_policy;
    public static string net_log_cache_not_updated_because_no_response;
    public static string net_log_cache_removed_existing_based_on_method;
    public static string net_log_cache_existing_not_removed_because_unexpected_response_status;
    public static string net_log_cache_removed_existing_based_on_policy;
    public static string net_log_cache_not_updated_based_on_ftp_response_status;
    public static string net_log_cache_update_not_supported_for_ftp_restart;
    public static string net_log_cache_removed_entry_because_ftp_restart_response_changed;
    public static string net_log_cache_last_synchronized;
    public static string net_log_cache_suppress_update_because_synched_last_minute;
    public static string net_log_cache_updating_last_synchronized;
    public static string net_log_cache_cannot_remove;
    public static string net_log_cache_key_status;
    public static string net_log_cache_key_remove_failed_status;
    public static string net_log_cache_usecount_file;
    public static string net_log_cache_stream;
    public static string net_log_cache_filename;
    public static string net_log_cache_lookup_failed;
    public static string net_log_cache_exception;
    public static string net_log_cache_expected_length;
    public static string net_log_cache_last_modified;
    public static string net_log_cache_expires;
    public static string net_log_cache_max_stale;
    public static string net_log_cache_dumping_metadata;
    public static string net_log_cache_create_failed;
    public static string net_log_cache_set_expires;
    public static string net_log_cache_set_last_modified;
    public static string net_log_cache_set_last_synchronized;
    public static string net_log_cache_enable_max_stale;
    public static string net_log_cache_disable_max_stale;
    public static string net_log_cache_set_new_metadata;
    public static string net_log_cache_dumping;
    public static string net_log_cache_key;
    public static string net_log_cache_no_commit;
    public static string net_log_cache_error_deleting_filename;
    public static string net_log_cache_update_failed;
    public static string net_log_cache_delete_failed;
    public static string net_log_cache_commit_failed;
    public static string net_log_cache_committed_as_partial;
    public static string net_log_cache_max_stale_and_update_status;
    public static string net_log_cache_failing_request_with_exception;
    public static string net_log_cache_request_method;
    public static string net_log_cache_http_status_parse_failure;
    public static string net_log_cache_http_status_line;
    public static string net_log_cache_cache_control;
    public static string net_log_cache_invalid_http_version;
    public static string net_log_cache_no_http_response_header;
    public static string net_log_cache_http_header_parse_error;
    public static string net_log_cache_metadata_name_value_parse_error;
    public static string net_log_cache_content_range_error;
    public static string net_log_cache_cache_control_error;
    public static string net_log_cache_unexpected_status;
    public static string net_log_cache_object_and_exception;
    public static string net_log_cache_revalidation_not_needed;
    public static string net_log_cache_not_updated_based_on_cache_protocol_status;
    public static string net_log_cache_closing_cache_stream;
    public static string net_log_cache_exception_ignored;
    public static string net_log_cache_no_cache_entry;
    public static string net_log_cache_null_cached_stream;
    public static string net_log_cache_requested_combined_but_null_cached_stream;
    public static string net_log_cache_returned_range_cache;
    public static string net_log_cache_entry_not_found_freshness_undefined;
    public static string net_log_cache_dumping_cache_context;
    public static string net_log_cache_result;
    public static string net_log_cache_uri_with_query_has_no_expiration;
    public static string net_log_cache_uri_with_query_and_cached_resp_from_http_10;
    public static string net_log_cache_valid_as_fresh_or_because_policy;
    public static string net_log_cache_accept_based_on_retry_count;
    public static string net_log_cache_date_header_older_than_cache_entry;
    public static string net_log_cache_server_didnt_satisfy_range;
    public static string net_log_cache_304_received_on_unconditional_request;
    public static string net_log_cache_304_received_on_unconditional_request_expected_200_206;
    public static string net_log_cache_last_modified_header_older_than_cache_entry;
    public static string net_log_cache_freshness_outside_policy_limits;
    public static string net_log_cache_need_to_remove_invalid_cache_entry_304;
    public static string net_log_cache_resp_status;
    public static string net_log_cache_resp_304_or_request_head;
    public static string net_log_cache_dont_update_cached_headers;
    public static string net_log_cache_update_cached_headers;
    public static string net_log_cache_partial_resp_not_combined_with_existing_entry;
    public static string net_log_cache_request_contains_conditional_header;
    public static string net_log_cache_not_a_get_head_post;
    public static string net_log_cache_cannot_update_cache_if_304;
    public static string net_log_cache_cannot_update_cache_with_head_resp;
    public static string net_log_cache_http_resp_is_null;
    public static string net_log_cache_resp_cache_control_is_no_store;
    public static string net_log_cache_resp_cache_control_is_public;
    public static string net_log_cache_resp_cache_control_is_private;
    public static string net_log_cache_resp_cache_control_is_private_plus_headers;
    public static string net_log_cache_resp_older_than_cache;
    public static string net_log_cache_revalidation_required;
    public static string net_log_cache_needs_revalidation;
    public static string net_log_cache_resp_allows_caching;
    public static string net_log_cache_auth_header_and_no_s_max_age;
    public static string net_log_cache_post_resp_without_cache_control_or_expires;
    public static string net_log_cache_valid_based_on_status_code;
    public static string net_log_cache_resp_no_cache_control;
    public static string net_log_cache_age;
    public static string net_log_cache_policy_min_fresh;
    public static string net_log_cache_policy_max_age;
    public static string net_log_cache_policy_cache_sync_date;
    public static string net_log_cache_policy_max_stale;
    public static string net_log_cache_control_no_cache;
    public static string net_log_cache_control_no_cache_removing_some_headers;
    public static string net_log_cache_control_must_revalidate;
    public static string net_log_cache_cached_auth_header;
    public static string net_log_cache_cached_auth_header_no_control_directive;
    public static string net_log_cache_after_validation;
    public static string net_log_cache_resp_status_304;
    public static string net_log_cache_head_resp_has_different_content_length;
    public static string net_log_cache_head_resp_has_different_content_md5;
    public static string net_log_cache_head_resp_has_different_etag;
    public static string net_log_cache_304_head_resp_has_different_last_modified;
    public static string net_log_cache_existing_entry_has_to_be_discarded;
    public static string net_log_cache_existing_entry_should_be_discarded;
    public static string net_log_cache_206_resp_non_matching_entry;
    public static string net_log_cache_206_resp_starting_position_not_adjusted;
    public static string net_log_cache_combined_resp_requested;
    public static string net_log_cache_updating_headers_on_304;
    public static string net_log_cache_suppressing_headers_update_on_304;
    public static string net_log_cache_status_code_not_304_206;
    public static string net_log_cache_sxx_resp_cache_only;
    public static string net_log_cache_sxx_resp_can_be_replaced;
    public static string net_log_cache_vary_header_empty;
    public static string net_log_cache_vary_header_contains_asterisks;
    public static string net_log_cache_no_headers_in_metadata;
    public static string net_log_cache_vary_header_mismatched_count;
    public static string net_log_cache_vary_header_mismatched_field;
    public static string net_log_cache_vary_header_match;
    public static string net_log_cache_range;
    public static string net_log_cache_range_invalid_format;
    public static string net_log_cache_range_not_in_cache;
    public static string net_log_cache_range_in_cache;
    public static string net_log_cache_partial_resp;
    public static string net_log_cache_range_request_range;
    public static string net_log_cache_could_be_partial;
    public static string net_log_cache_condition_if_none_match;
    public static string net_log_cache_condition_if_modified_since;
    public static string net_log_cache_cannot_construct_conditional_request;
    public static string net_log_cache_cannot_construct_conditional_range_request;
    public static string net_log_cache_entry_size_too_big;
    public static string net_log_cache_condition_if_range;
    public static string net_log_cache_conditional_range_not_implemented_on_http_10;
    public static string net_log_cache_saving_request_headers;
    public static string net_log_cache_only_byte_range_implemented;
    public static string net_log_cache_multiple_complex_range_not_implemented;
    public static string net_log_digest_hash_algorithm_not_supported;
    public static string net_log_digest_qop_not_supported;
    public static string net_log_digest_requires_nonce;
    public static string net_log_auth_invalid_challenge;
    public static string net_log_unknown;
    public static string net_log_operation_returned_something;
    public static string net_log_buffered_n_bytes;
    public static string net_log_method_equal;
    public static string net_log_releasing_connection;
    public static string net_log_unexpected_exception;
    public static string net_log_server_response_error_code;
    public static string net_log_resubmitting_request;
    public static string net_log_retrieving_localhost_exception;
    public static string net_log_resolved_servicepoint_may_not_be_remote_server;
    public static string net_log_closed_idle;
    public static string net_log_received_status_line;
    public static string net_log_sending_headers;
    public static string net_log_received_headers;
    public static string net_log_shell_expression_pattern_format_warning;
    public static string net_log_exception_in_callback;
    public static string net_log_sending_command;
    public static string net_log_received_response;
    public static string net_log_socket_connected;
    public static string net_log_socket_accepted;
    public static string net_log_socket_not_logged_file;
    public static string net_log_socket_connect_dnsendpoint;
    public static string MailAddressInvalidFormat;
    public static string MailSubjectInvalidFormat;
    public static string MailBase64InvalidCharacter;
    public static string MailCollectionIsReadOnly;
    public static string MailDateInvalidFormat;
    public static string MailHeaderFieldAlreadyExists;
    public static string MailHeaderFieldInvalidCharacter;
    public static string MailHeaderFieldMalformedHeader;
    public static string MailHeaderFieldMismatchedName;
    public static string MailHeaderIndexOutOfBounds;
    public static string MailHeaderItemAccessorOnlySingleton;
    public static string MailHeaderListHasChanged;
    public static string MailHeaderResetCalledBeforeEOF;
    public static string MailHeaderTargetArrayTooSmall;
    public static string MailHeaderInvalidCID;
    public static string MailHostNotFound;
    public static string MailReaderGetContentStreamAlreadyCalled;
    public static string MailReaderTruncated;
    public static string MailWriterIsInContent;
    public static string MailServerDoesNotSupportStartTls;
    public static string MailServerResponse;
    public static string SSPIAuthenticationOrSPNNull;
    public static string SSPIPInvokeError;
    public static string SmtpAlreadyConnected;
    public static string SmtpAuthenticationFailed;
    public static string SmtpAuthenticationFailedNoCreds;
    public static string SmtpDataStreamOpen;
    public static string SmtpDefaultMimePreamble;
    public static string SmtpDefaultSubject;
    public static string SmtpInvalidResponse;
    public static string SmtpNotConnected;
    public static string SmtpSystemStatus;
    public static string SmtpHelpMessage;
    public static string SmtpServiceReady;
    public static string SmtpServiceClosingTransmissionChannel;
    public static string SmtpOK;
    public static string SmtpUserNotLocalWillForward;
    public static string SmtpStartMailInput;
    public static string SmtpServiceNotAvailable;
    public static string SmtpMailboxBusy;
    public static string SmtpLocalErrorInProcessing;
    public static string SmtpInsufficientStorage;
    public static string SmtpPermissionDenied;
    public static string SmtpCommandUnrecognized;
    public static string SmtpSyntaxError;
    public static string SmtpCommandNotImplemented;
    public static string SmtpBadCommandSequence;
    public static string SmtpCommandParameterNotImplemented;
    public static string SmtpMailboxUnavailable;
    public static string SmtpUserNotLocalTryAlternatePath;
    public static string SmtpExceededStorageAllocation;
    public static string SmtpMailboxNameNotAllowed;
    public static string SmtpTransactionFailed;
    public static string SmtpSendMailFailure;
    public static string SmtpRecipientFailed;
    public static string SmtpRecipientRequired;
    public static string SmtpFromRequired;
    public static string SmtpAllRecipientsFailed;
    public static string SmtpClientNotPermitted;
    public static string SmtpMustIssueStartTlsFirst;
    public static string SmtpNeedAbsolutePickupDirectory;
    public static string SmtpGetIisPickupDirectoryFailed;
    public static string SmtpPickupDirectoryDoesnotSupportSsl;
    public static string SmtpOperationInProgress;
    public static string SmtpAuthResponseInvalid;
    public static string SmtpEhloResponseInvalid;
    public static string SmtpNonAsciiUserNotSupported;
    public static string SmtpInvalidHostName;
    public static string MimeTransferEncodingNotSupported;
    public static string SeekNotSupported;
    public static string WriteNotSupported;
    public static string InvalidHexDigit;
    public static string InvalidSSPIContext;
    public static string InvalidSSPIContextKey;
    public static string InvalidSSPINegotiationElement;
    public static string InvalidHeaderName;
    public static string InvalidHeaderValue;
    public static string CannotGetEffectiveTimeOfSSPIContext;
    public static string CannotGetExpiryTimeOfSSPIContext;
    public static string ReadNotSupported;
    public static string InvalidAsyncResult;
    public static string UnspecifiedHost;
    public static string InvalidPort;
    public static string SmtpInvalidOperationDuringSend;
    public static string MimePartCantResetStream;
    public static string MediaTypeInvalid;
    public static string ContentTypeInvalid;
    public static string ContentDispositionInvalid;
    public static string AttributeNotSupported;
    public static string Cannot_remove_with_null;
    public static string Config_base_elements_only;
    public static string Config_base_no_child_nodes;
    public static string Config_base_required_attribute_empty;
    public static string Config_base_required_attribute_missing;
    public static string Config_base_time_overflow;
    public static string Config_base_type_must_be_configurationvalidation;
    public static string Config_base_type_must_be_typeconverter;
    public static string Config_base_unknown_format;
    public static string Config_base_unrecognized_attribute;
    public static string Config_base_unrecognized_element;
    public static string Config_invalid_boolean_attribute;
    public static string Config_invalid_integer_attribute;
    public static string Config_invalid_positive_integer_attribute;
    public static string Config_invalid_type_attribute;
    public static string Config_missing_required_attribute;
    public static string Config_name_value_file_section_file_invalid_root;
    public static string Config_provider_must_implement_type;
    public static string Config_provider_name_null_or_empty;
    public static string Config_provider_not_found;
    public static string Config_property_name_cannot_be_empty;
    public static string Config_section_cannot_clear_locked_section;
    public static string Config_section_record_not_found;
    public static string Config_source_cannot_contain_file;
    public static string Config_system_already_set;
    public static string Config_unable_to_read_security_policy;
    public static string Config_write_xml_returned_null;
    public static string Cannot_clear_sections_within_group;
    public static string Cannot_exit_up_top_directory;
    public static string Could_not_create_listener;
    public static string TL_InitializeData_NotSpecified;
    public static string Could_not_create_type_instance;
    public static string Could_not_find_type;
    public static string Could_not_get_constructor;
    public static string EmptyTypeName_NotAllowed;
    public static string Incorrect_base_type;
    public static string Only_specify_one;
    public static string Provider_Already_Initialized;
    public static string Reference_listener_cant_have_properties;
    public static string Reference_to_nonexistent_listener;
    public static string SettingsPropertyNotFound;
    public static string SettingsPropertyReadOnly;
    public static string SettingsPropertyWrongType;
    public static string Type_isnt_tracelistener;
    public static string Unable_to_convert_type_from_string;
    public static string Unable_to_convert_type_to_string;
    public static string Value_must_be_numeric;
    public static string Could_not_create_from_default_value;
    public static string Could_not_create_from_default_value_2;
    public static string InvalidDirName;
    public static string FSW_IOError;
    public static string PatternInvalidChar;
    public static string BufferSizeTooLarge;
    public static string FSW_ChangedFilter;
    public static string FSW_Enabled;
    public static string FSW_Filter;
    public static string FSW_IncludeSubdirectories;
    public static string FSW_Path;
    public static string FSW_SynchronizingObject;
    public static string FSW_Changed;
    public static string FSW_Created;
    public static string FSW_Deleted;
    public static string FSW_Renamed;
    public static string FSW_BufferOverflow;
    public static string FileSystemWatcherDesc;
    public static string NotSet;
    public static string TimerAutoReset;
    public static string TimerEnabled;
    public static string TimerInterval;
    public static string TimerIntervalElapsed;
    public static string TimerSynchronizingObject;
    public static string MismatchedCounterTypes;
    public static string NoPropertyForAttribute;
    public static string InvalidAttributeType;
    public static string Generic_ArgCantBeEmptyString;
    public static string BadLogName;
    public static string InvalidProperty;
    public static string CantMonitorEventLog;
    public static string InitTwice;
    public static string InvalidParameter;
    public static string MissingParameter;
    public static string ParameterTooLong;
    public static string LocalSourceAlreadyExists;
    public static string SourceAlreadyExists;
    public static string LocalLogAlreadyExistsAsSource;
    public static string LogAlreadyExistsAsSource;
    public static string DuplicateLogName;
    public static string RegKeyMissing;
    public static string LocalRegKeyMissing;
    public static string RegKeyMissingShort;
    public static string InvalidParameterFormat;
    public static string NoLogName;
    public static string RegKeyNoAccess;
    public static string MissingLog;
    public static string SourceNotRegistered;
    public static string LocalSourceNotRegistered;
    public static string CantRetrieveEntries;
    public static string IndexOutOfBounds;
    public static string CantReadLogEntryAt;
    public static string MissingLogProperty;
    public static string CantOpenLog;
    public static string NeedSourceToOpen;
    public static string NeedSourceToWrite;
    public static string CantOpenLogAccess;
    public static string LogEntryTooLong;
    public static string TooManyReplacementStrings;
    public static string LogSourceMismatch;
    public static string NoAccountInfo;
    public static string NoCurrentEntry;
    public static string MessageNotFormatted;
    public static string EventID;
    public static string LogDoesNotExists;
    public static string InvalidCustomerLogName;
    public static string CannotDeleteEqualSource;
    public static string RentionDaysOutOfRange;
    public static string MaximumKilobytesOutOfRange;
    public static string SomeLogsInaccessible;
    public static string SomeLogsInaccessibleToCreate;
    public static string BadConfigSwitchValue;
    public static string ConfigSectionsUnique;
    public static string ConfigSectionsUniquePerSection;
    public static string SourceListenerDoesntExist;
    public static string SourceSwitchDoesntExist;
    public static string CategoryHelpCorrupt;
    public static string CounterNameCorrupt;
    public static string CounterDataCorrupt;
    public static string ReadOnlyCounter;
    public static string ReadOnlyRemoveInstance;
    public static string NotCustomCounter;
    public static string CategoryNameMissing;
    public static string CounterNameMissing;
    public static string InstanceNameProhibited;
    public static string InstanceNameRequired;
    public static string MissingInstance;
    public static string PerformanceCategoryExists;
    public static string InvalidCounterName;
    public static string DuplicateCounterName;
    public static string CantChangeCategoryRegistration;
    public static string CantDeleteCategory;
    public static string MissingCategory;
    public static string MissingCategoryDetail;
    public static string CantReadCategory;
    public static string MissingCounter;
    public static string CategoryNameNotSet;
    public static string CounterExists;
    public static string CantReadCategoryIndex;
    public static string CantReadCounter;
    public static string CantReadInstance;
    public static string RemoteWriting;
    public static string CounterLayout;
    public static string PossibleDeadlock;
    public static string SharedMemoryGhosted;
    public static string HelpNotAvailable;
    public static string PerfInvalidHelp;
    public static string PerfInvalidCounterName;
    public static string PerfInvalidCategoryName;
    public static string MustAddCounterCreationData;
    public static string RemoteCounterAdmin;
    public static string NoInstanceInformation;
    public static string PerfCounterPdhError;
    public static string MultiInstanceOnly;
    public static string SingleInstanceOnly;
    public static string InstanceNameTooLong;
    public static string CategoryNameTooLong;
    public static string InstanceLifetimeProcessonReadOnly;
    public static string InstanceLifetimeProcessforSingleInstance;
    public static string InstanceAlreadyExists;
    public static string CantSetLifetimeAfterInitialized;
    public static string ProcessLifetimeNotValidInGlobal;
    public static string CantConvertProcessToGlobal;
    public static string CantConvertGlobalToProcess;
    public static string PCNotSupportedUnderAppContainer;
    public static string PriorityClassNotSupported;
    public static string WinNTRequired;
    public static string Win2kRequired;
    public static string NoAssociatedProcess;
    public static string ProcessIdRequired;
    public static string NotSupportedRemote;
    public static string NoProcessInfo;
    public static string WaitTillExit;
    public static string NoProcessHandle;
    public static string MissingProccess;
    public static string BadMinWorkset;
    public static string BadMaxWorkset;
    public static string WinNTRequiredForRemote;
    public static string ProcessHasExited;
    public static string ProcessHasExitedNoId;
    public static string ThreadExited;
    public static string Win2000Required;
    public static string ProcessNotFound;
    public static string CantGetProcessId;
    public static string ProcessDisabled;
    public static string WaitReasonUnavailable;
    public static string NotSupportedRemoteThread;
    public static string UseShellExecuteRequiresSTA;
    public static string CantRedirectStreams;
    public static string CantUseEnvVars;
    public static string CantStartAsUser;
    public static string CouldntConnectToRemoteMachine;
    public static string CouldntGetProcessInfos;
    public static string InputIdleUnkownError;
    public static string FileNameMissing;
    public static string EnvironmentBlock;
    public static string EnumProcessModuleFailed;
    public static string EnumProcessModuleFailedDueToWow;
    public static string PendingAsyncOperation;
    public static string NoAsyncOperation;
    public static string InvalidApplication;
    public static string StandardOutputEncodingNotAllowed;
    public static string StandardErrorEncodingNotAllowed;
    public static string CountersOOM;
    public static string MappingCorrupted;
    public static string SetSecurityDescriptorFailed;
    public static string CantCreateFileMapping;
    public static string CantMapFileView;
    public static string CantGetMappingSize;
    public static string CantGetStandardOut;
    public static string CantGetStandardIn;
    public static string CantGetStandardError;
    public static string CantMixSyncAsyncOperation;
    public static string NoFileMappingSize;
    public static string EnvironmentBlockTooLong;
    public static string Arg_SecurityException;
    public static string ArgumentNull_Array;
    public static string ArgumentNull_Buffer;
    public static string IO_UnknownError;
    public static string NotSupported_UnwritableStream;
    public static string ObjectDisposed_WriterClosed;
    public static string NotSupportedOS;
    public static string BaudRate;
    public static string DataBits;
    public static string DiscardNull;
    public static string DtrEnable;
    public static string EncodingMonitoringDescription;
    public static string Handshake;
    public static string NewLine;
    public static string Parity;
    public static string ParityReplace;
    public static string PortName;
    public static string ReadBufferSize;
    public static string ReadTimeout;
    public static string ReceivedBytesThreshold;
    public static string RtsEnable;
    public static string SerialPortDesc;
    public static string StopBits;
    public static string WriteBufferSize;
    public static string WriteTimeout;
    public static string SerialErrorReceived;
    public static string SerialPinChanged;
    public static string SerialDataReceived;
    public static string CounterType;
    public static string CounterName;
    public static string CounterHelp;
    public static string EventLogDesc;
    public static string ErrorDataReceived;
    public static string LogEntries;
    public static string LogLog;
    public static string LogMachineName;
    public static string LogMonitoring;
    public static string LogSynchronizingObject;
    public static string LogSource;
    public static string LogEntryWritten;
    public static string LogEntryMachineName;
    public static string LogEntryData;
    public static string LogEntryIndex;
    public static string LogEntryCategory;
    public static string LogEntryCategoryNumber;
    public static string LogEntryEventID;
    public static string LogEntryEntryType;
    public static string LogEntryMessage;
    public static string LogEntrySource;
    public static string LogEntryReplacementStrings;
    public static string LogEntryResourceId;
    public static string LogEntryTimeGenerated;
    public static string LogEntryTimeWritten;
    public static string LogEntryUserName;
    public static string OutputDataReceived;
    public static string PC_CounterHelp;
    public static string PC_CounterType;
    public static string PC_ReadOnly;
    public static string PC_RawValue;
    public static string ProcessAssociated;
    public static string ProcessDesc;
    public static string ProcessExitCode;
    public static string ProcessTerminated;
    public static string ProcessExitTime;
    public static string ProcessHandle;
    public static string ProcessHandleCount;
    public static string ProcessId;
    public static string ProcessMachineName;
    public static string ProcessMainModule;
    public static string ProcessModules;
    public static string ProcessSynchronizingObject;
    public static string ProcessSessionId;
    public static string ProcessThreads;
    public static string ProcessEnableRaisingEvents;
    public static string ProcessExited;
    public static string ProcessFileName;
    public static string ProcessWorkingDirectory;
    public static string ProcessBasePriority;
    public static string ProcessMainWindowHandle;
    public static string ProcessMainWindowTitle;
    public static string ProcessMaxWorkingSet;
    public static string ProcessMinWorkingSet;
    public static string ProcessNonpagedSystemMemorySize;
    public static string ProcessPagedMemorySize;
    public static string ProcessPagedSystemMemorySize;
    public static string ProcessPeakPagedMemorySize;
    public static string ProcessPeakWorkingSet;
    public static string ProcessPeakVirtualMemorySize;
    public static string ProcessPriorityBoostEnabled;
    public static string ProcessPriorityClass;
    public static string ProcessPrivateMemorySize;
    public static string ProcessPrivilegedProcessorTime;
    public static string ProcessProcessName;
    public static string ProcessProcessorAffinity;
    public static string ProcessResponding;
    public static string ProcessStandardError;
    public static string ProcessStandardInput;
    public static string ProcessStandardOutput;
    public static string ProcessStartInfo;
    public static string ProcessStartTime;
    public static string ProcessTotalProcessorTime;
    public static string ProcessUserProcessorTime;
    public static string ProcessVirtualMemorySize;
    public static string ProcessWorkingSet;
    public static string ProcModModuleName;
    public static string ProcModFileName;
    public static string ProcModBaseAddress;
    public static string ProcModModuleMemorySize;
    public static string ProcModEntryPointAddress;
    public static string ProcessVerb;
    public static string ProcessArguments;
    public static string ProcessErrorDialog;
    public static string ProcessWindowStyle;
    public static string ProcessCreateNoWindow;
    public static string ProcessEnvironmentVariables;
    public static string ProcessRedirectStandardInput;
    public static string ProcessRedirectStandardOutput;
    public static string ProcessRedirectStandardError;
    public static string ProcessUseShellExecute;
    public static string ThreadBasePriority;
    public static string ThreadCurrentPriority;
    public static string ThreadId;
    public static string ThreadPriorityBoostEnabled;
    public static string ThreadPriorityLevel;
    public static string ThreadPrivilegedProcessorTime;
    public static string ThreadStartAddress;
    public static string ThreadStartTime;
    public static string ThreadThreadState;
    public static string ThreadTotalProcessorTime;
    public static string ThreadUserProcessorTime;
    public static string ThreadWaitReason;
    public static string VerbEditorDefault;
    public static string AppSettingsReaderNoKey;
    public static string AppSettingsReaderNoParser;
    public static string AppSettingsReaderCantParse;
    public static string AppSettingsReaderEmptyString;
    public static string InvalidPermissionState;
    public static string PermissionNumberOfElements;
    public static string PermissionItemExists;
    public static string PermissionItemDoesntExist;
    public static string PermissionBadParameterEnum;
    public static string PermissionInvalidLength;
    public static string PermissionTypeMismatch;
    public static string Argument_NotAPermissionElement;
    public static string Argument_InvalidXMLBadVersion;
    public static string InvalidPermissionLevel;
    public static string TargetNotWebBrowserPermissionLevel;
    public static string WebBrowserBadXml;
    public static string KeyedCollNeedNonNegativeNum;
    public static string KeyedCollDuplicateKey;
    public static string KeyedCollReferenceKeyNotFound;
    public static string KeyedCollKeyNotFound;
    public static string KeyedCollInvalidKey;
    public static string KeyedCollCapacityOverflow;
    public static string OrderedDictionary_ReadOnly;
    public static string OrderedDictionary_SerializationMismatch;
    public static string Async_ExceptionOccurred;
    public static string Async_QueueingFailed;
    public static string Async_OperationCancelled;
    public static string Async_OperationAlreadyCompleted;
    public static string Async_NullDelegate;
    public static string BackgroundWorker_AlreadyRunning;
    public static string BackgroundWorker_CancellationNotSupported;
    public static string BackgroundWorker_OperationCompleted;
    public static string BackgroundWorker_ProgressNotSupported;
    public static string BackgroundWorker_WorkerAlreadyRunning;
    public static string BackgroundWorker_WorkerDoesntReportProgress;
    public static string BackgroundWorker_WorkerDoesntSupportCancellation;
    public static string Async_ProgressChangedEventArgs_ProgressPercentage;
    public static string Async_ProgressChangedEventArgs_UserState;
    public static string Async_AsyncEventArgs_Cancelled;
    public static string Async_AsyncEventArgs_Error;
    public static string Async_AsyncEventArgs_UserState;
    public static string BackgroundWorker_CancellationPending;
    public static string BackgroundWorker_DoWork;
    public static string BackgroundWorker_IsBusy;
    public static string BackgroundWorker_ProgressChanged;
    public static string BackgroundWorker_RunWorkerCompleted;
    public static string BackgroundWorker_WorkerReportsProgress;
    public static string BackgroundWorker_WorkerSupportsCancellation;
    public static string BackgroundWorker_DoWorkEventArgs_Argument;
    public static string BackgroundWorker_DoWorkEventArgs_Result;
    public static string BackgroundWorker_Desc;
    public static string InstanceCreationEditorDefaultText;
    public static string PropertyTabAttributeBadPropertyTabScope;
    public static string PropertyTabAttributeTypeLoadException;
    public static string PropertyTabAttributeArrayLengthMismatch;
    public static string PropertyTabAttributeParamsBothNull;
    public static string InstanceDescriptorCannotBeStatic;
    public static string InstanceDescriptorMustBeStatic;
    public static string InstanceDescriptorMustBeReadable;
    public static string InstanceDescriptorLengthMismatch;
    public static string ToolboxItemAttributeFailedGetType;
    public static string PropertyDescriptorCollectionBadValue;
    public static string PropertyDescriptorCollectionBadKey;
    public static string AspNetHostingPermissionBadXml;
    public static string CorruptedGZipHeader;
    public static string UnknownCompressionMode;
    public static string UnknownState;
    public static string InvalidHuffmanData;
    public static string InvalidCRC;
    public static string InvalidStreamSize;
    public static string UnknownBlockType;
    public static string InvalidBlockLength;
    public static string GenericInvalidData;
    public static string CannotReadFromDeflateStream;
    public static string CannotWriteToDeflateStream;
    public static string NotReadableStream;
    public static string NotWriteableStream;
    public static string InvalidArgumentOffsetCount;
    public static string InvalidBeginCall;
    public static string InvalidEndCall;
    public static string StreamSizeOverflow;
    public static string ZLibErrorDLLLoadError;
    public static string ZLibErrorUnexpected;
    public static string ZLibErrorInconsistentStream;
    public static string ZLibErrorSteamFreedPrematurely;
    public static string ZLibErrorNotEnoughMemory;
    public static string ZLibErrorIncorrectInitParameters;
    public static string ZLibErrorVersionMismatch;
    public static string InvalidOperation_HCCountOverflow;
    public static string Argument_InvalidThreshold;
    public static string Argument_SemaphoreInitialMaximum;
    public static string Argument_WaitHandleNameTooLong;
    public static string WaitHandleCannotBeOpenedException_InvalidHandle;
    public static string ArgumentNotAPermissionElement;
    public static string ArgumentWrongType;
    public static string BadXmlVersion;
    public static string BinarySerializationNotSupported;
    public static string BothScopeAttributes;
    public static string NoScopeAttributes;
    public static string PositionOutOfRange;
    public static string ProviderInstantiationFailed;
    public static string ProviderTypeLoadFailed;
    public static string SaveAppScopedNotSupported;
    public static string SettingsResetFailed;
    public static string SettingsSaveFailed;
    public static string SettingsSaveFailedNoSection;
    public static string StringDeserializationFailed;
    public static string StringSerializationFailed;
    public static string UnknownSerializationFormat;
    public static string UnknownSeekOrigin;
    public static string UnknownUserLevel;
    public static string UserSettingsNotSupported;
    public static string XmlDeserializationFailed;
    public static string XmlSerializationFailed;
    public static string MemberRelationshipService_RelationshipNotSupported;
    public static string MaskedTextProviderPasswordAndPromptCharError;
    public static string MaskedTextProviderInvalidCharError;
    public static string MaskedTextProviderMaskNullOrEmpty;
    public static string MaskedTextProviderMaskInvalidChar;
    public static string StandardOleMarshalObjectGetMarshalerFailed;
    public static string SoundAPIBadSoundLocation;
    public static string SoundAPIFileDoesNotExist;
    public static string SoundAPIFormatNotSupported;
    public static string SoundAPIInvalidWaveFile;
    public static string SoundAPIInvalidWaveHeader;
    public static string SoundAPILoadTimedOut;
    public static string SoundAPILoadTimeout;
    public static string SoundAPIReadError;
    public static string WrongActionForCtor;
    public static string MustBeResetAddOrRemoveActionForCtor;
    public static string ResetActionRequiresNullItem;
    public static string ResetActionRequiresIndexMinus1;
    public static string IndexCannotBeNegative;
    public static string ObservableCollectionReentrancyNotAllowed;
    public static string Arg_ArgumentOutOfRangeException;
    public static string mono_net_io_shutdown;
    public static string mono_net_io_renegotiate;
    public static string net_ssl_io_already_shutdown;
    public static string net_log_set_socketoption_reuseport_default_on;
    public static string net_log_set_socketoption_reuseport_not_supported;
    public static string net_log_set_socketoption_reuseport;
    public static string net_ssl_app_protocols_invalid;
    public static string net_ssl_app_protocol_invalid;
    public static string net_conflicting_options;
    public static string Arg_NonZeroLowerBound;
    public static string Arg_WrongType;
    public static string Arg_ArrayPlusOffTooSmall;
    public static string ArgumentOutOfRange_NeedNonNegNum;
    public static string ArgumentOutOfRange_SmallCapacity;
    public static string Argument_InvalidOffLen;
    public static string Argument_AddingDuplicate;
    public static string InvalidOperation_ConcurrentOperationsNotSupported;
    public static string InvalidOperation_EmptyQueue;
    public static string InvalidOperation_EnumOpCantHappen;
    public static string InvalidOperation_EnumFailedVersion;
    public static string InvalidOperation_EmptyStack;
    public static string InvalidOperation_EnumNotStarted;
    public static string InvalidOperation_EnumEnded;
    public static string NotSupported_KeyCollectionSet;
    public static string NotSupported_ValueCollectionSet;
    public static string Arg_ArrayLengthsDiffer;
    public static string Arg_BitArrayTypeUnsupported;
    public static string Arg_HSCapacityOverflow;
    public static string Arg_HTCapacityOverflow;
    public static string Arg_InsufficientSpace;
    public static string Arg_RankMultiDimNotSupported;
    public static string Argument_ArrayTooLarge;
    public static string Argument_InvalidArrayType;
    public static string ArgumentOutOfRange_BiggerThanCollection;
    public static string ArgumentOutOfRange_Index;
    public static string ExternalLinkedListNode;
    public static string LinkedListEmpty;
    public static string LinkedListNodeIsAttached;
    public static string NotSupported_SortedListNestedWrite;
    public static string SortedSet_LowerValueGreaterThanUpperValue;
    public static string Serialization_InvalidOnDeser;
    public static string Serialization_MismatchedCount;
    public static string Serialization_MissingKeys;
    public static string Serialization_MissingValues;
    public static string Arg_KeyNotFoundWithKey;
    public static string BlockingCollection_Add_ConcurrentCompleteAdd;
    public static string BlockingCollection_Add_Failed;
    public static string BlockingCollection_CantAddAnyWhenCompleted;
    public static string BlockingCollection_CantTakeAnyWhenAllDone;
    public static string BlockingCollection_CantTakeWhenDone;
    public static string BlockingCollection_Completed;
    public static string BlockingCollection_CopyTo_IncorrectType;
    public static string BlockingCollection_CopyTo_MultiDim;
    public static string BlockingCollection_CopyTo_NonNegative;
    public static string Collection_CopyTo_TooManyElems;
    public static string BlockingCollection_ctor_BoundedCapacityRange;
    public static string BlockingCollection_ctor_CountMoreThanCapacity;
    public static string BlockingCollection_Disposed;
    public static string BlockingCollection_Take_CollectionModified;
    public static string BlockingCollection_TimeoutInvalid;
    public static string BlockingCollection_ValidateCollectionsArray_DispElems;
    public static string BlockingCollection_ValidateCollectionsArray_LargeSize;
    public static string BlockingCollection_ValidateCollectionsArray_NullElems;
    public static string BlockingCollection_ValidateCollectionsArray_ZeroSize;
    public static string Common_OperationCanceled;
    public static string ConcurrentBag_Ctor_ArgumentNullException;
    public static string ConcurrentBag_CopyTo_ArgumentNullException;
    public static string Collection_CopyTo_ArgumentOutOfRangeException;
    public static string ConcurrentCollection_SyncRoot_NotSupported;
    public static string ConcurrentDictionary_ArrayIncorrectType;
    public static string ConcurrentDictionary_SourceContainsDuplicateKeys;
    public static string ConcurrentDictionary_ConcurrencyLevelMustBePositive;
    public static string ConcurrentDictionary_CapacityMustNotBeNegative;
    public static string ConcurrentDictionary_IndexIsNegative;
    public static string ConcurrentDictionary_ArrayNotLargeEnough;
    public static string ConcurrentDictionary_KeyAlreadyExisted;
    public static string ConcurrentDictionary_ItemKeyIsNull;
    public static string ConcurrentDictionary_TypeOfKeyIncorrect;
    public static string ConcurrentDictionary_TypeOfValueIncorrect;
    public static string ConcurrentStack_PushPopRange_CountOutOfRange;
    public static string ConcurrentStack_PushPopRange_InvalidCount;
    public static string ConcurrentStack_PushPopRange_StartOutOfRange;
    public static string Partitioner_DynamicPartitionsNotSupported;
    public static string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed;
    public static string PartitionerStatic_CurrentCalledBeforeMoveNext;
    public static string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished;
    public static string Argument_AddingDuplicate__;
    public static string Argument_ImplementIComparable;
    public static string Arg_RemoveArgNotFound;
    public static string ArgumentNull_Dictionary;
    public static string ArgumentOutOfRange_QueueGrowFactor;
    public static string Array;
    public static string Collection;
    public static string none;
    public static string Null;
    public static string Text;
    public static string InvalidColor;
    public static string TextParseFailedFormat;
    public static string PropertyValueInvalidEntry;
    public static string ArgumentException_BufferNotFromPool;
    public static string Arg_FileIsDirectory_Name;
    public static string Arg_HandleNotAsync;
    public static string Arg_HandleNotSync;
    public static string Arg_InvalidFileAttrs;
    public static string Arg_InvalidHandle;
    public static string Arg_InvalidSearchPattern;
    public static string Arg_Path2IsRooted;
    public static string Arg_PathIsVolume;
    public static string ArgumentNull_FileName;
    public static string ArgumentNull_Path;
    public static string ArgumentOutOfRange_Enum;
    public static string ArgumentOutOfRange_FileLengthTooBig;
    public static string ArgumentOutOfRange_NeedPosNum;
    public static string Argument_EmptyFileName;
    public static string Argument_EmptyPath;
    public static string Argument_FileNotResized;
    public static string Argument_InvalidAppendMode;
    public static string Argument_InvalidFileModeAndAccessCombo;
    public static string Argument_InvalidPathChars;
    public static string Argument_InvalidSeekOrigin;
    public static string Argument_InvalidSubPath;
    public static string Argument_PathEmpty;
    public static string IO_AlreadyExists_Name;
    public static string IO_BindHandleFailed;
    public static string IO_CannotCreateDirectory;
    public static string IO_EOF_ReadBeyondEOF;
    public static string IO_FileCreateAlreadyExists;
    public static string IO_FileExists_Name;
    public static string IO_FileNotFound;
    public static string IO_FileNotFound_FileName;
    public static string IO_FileStreamHandlePosition;
    public static string IO_FileTooLong2GB;
    public static string IO_FileTooLongOrHandleNotSync;
    public static string IO_PathNotFound_NoPathName;
    public static string IO_PathNotFound_Path;
    public static string IO_PathTooLong;
    public static string IO_SeekAppendOverwrite;
    public static string IO_SetLengthAppendTruncate;
    public static string IO_SharingViolation_File;
    public static string IO_SharingViolation_NoFileName;
    public static string IO_SourceDestMustBeDifferent;
    public static string IO_SourceDestMustHaveSameRoot;
    public static string IO_SyncOpOnUIThread;
    public static string IO_UnknownFileName;
    public static string IndexOutOfRange_IORaceCondition;
    public static string NotSupported_UnseekableStream;
    public static string ObjectDisposed_FileClosed;
    public static string UnauthorizedAccess_IODenied_NoPathName;
    public static string UnauthorizedAccess_IODenied_Path;
    public static string ObjectDisposed_StreamClosed;
    public static string PlatformNotSupported_FileEncryption;
    public static string IO_PathTooLong_Path;
    public static string InvalidDirName_NotExists;
    public static string EventStream_FailedToStart;
    public static string IOException_INotifyInstanceSystemLimitExceeded;
    public static string IOException_INotifyInstanceUserLimitExceeded_Value;
    public static string IOException_INotifyWatchesUserLimitExceeded_Value;
    public static string IOException_INotifyInstanceUserLimitExceeded;
    public static string IOException_INotifyWatchesUserLimitExceeded;
    public static string BaseStream_Invalid_Not_Open;
    public static string PortNameEmpty_String;
    public static string Port_not_open;
    public static string Port_already_open;
    public static string Cant_be_set_when_open;
    public static string Max_Baud;
    public static string In_Break_State;
    public static string Write_timed_out;
    public static string CantSetRtsWithHandshaking;
    public static string NotSupportedEncoding;
    public static string Arg_InvalidSerialPort;
    public static string Arg_InvalidSerialPortExtended;
    public static string ArgumentOutOfRange_Bounds_Lower_Upper;
    public static string ArgumentOutOfRange_NeedNonNegNumRequired;
    public static string ArgumentOutOfRange_Timeout;
    public static string ArgumentOutOfRange_WriteTimeout;
    public static string IO_OperationAborted;
    public static string InvalidNullEmptyArgument;
    public static string Arg_WrongAsyncResult;
    public static string InvalidOperation_EndReadCalledMultiple;
    public static string InvalidOperation_EndWriteCalledMultiple;
    public static string IO_PortNotFound;
    public static string IO_PortNotFoundFileName;
    public static string PlatformNotSupported_IOPorts;
    public static string PlatformNotSupported_SerialPort_GetPortNames;
    public static string NotSupported_CannotCallEqualsOnSpan;
    public static string NotSupported_CannotCallGetHashCodeOnSpan;
    public static string Argument_InvalidTypeWithPointersNotSupported;
    public static string Argument_DestinationTooShort;
    public static string MemoryDisposed;
    public static string OutstandingReferences;
    public static string Argument_BadFormatSpecifier;
    public static string Argument_GWithPrecisionNotSupported;
    public static string Argument_CannotParsePrecision;
    public static string Argument_PrecisionTooLarge;
    public static string Argument_OverlapAlignmentMismatch;
    public static string EndPositionNotReached;
    public static string UnexpectedSegmentType;
    public static string net_log_listener_delegate_exception;
    public static string net_log_listener_unsupported_authentication_scheme;
    public static string net_log_listener_unmatched_authentication_scheme;
    public static string net_io_invalidasyncresult;
    public static string net_io_invalidendcall;
    public static string net_listener_cannot_set_custom_cbt;
    public static string net_listener_detach_error;
    public static string net_listener_scheme;
    public static string net_listener_host;
    public static string net_listener_not_supported;
    public static string net_listener_mustcall;
    public static string net_listener_slash;
    public static string net_listener_already;
    public static string net_log_listener_no_cbt_disabled;
    public static string net_log_listener_no_cbt_http;
    public static string net_log_listener_no_cbt_trustedproxy;
    public static string net_log_listener_cbt;
    public static string net_log_listener_no_spn_kerberos;
    public static string net_log_listener_no_spn_disabled;
    public static string net_log_listener_no_spn_cbt;
    public static string net_log_listener_no_spn_whensupported;
    public static string net_log_listener_no_spn_loopback;
    public static string net_log_listener_spn;
    public static string net_log_listener_spn_passed;
    public static string net_log_listener_spn_failed;
    public static string net_log_listener_spn_failed_always;
    public static string net_log_listener_spn_failed_empty;
    public static string net_log_listener_spn_failed_dump;
    public static string net_log_listener_spn_add;
    public static string net_log_listener_spn_not_add;
    public static string net_log_listener_spn_remove;
    public static string net_log_listener_spn_not_remove;
    public static string net_listener_no_spns;
    public static string net_ssp_dont_support_cbt;
    public static string net_PropertyNotImplementedException;
    public static string net_array_too_small;
    public static string net_listener_mustcompletecall;
    public static string net_listener_invalid_cbt_type;
    public static string net_listener_callinprogress;
    public static string net_log_listener_cant_create_uri;
    public static string net_log_listener_cant_convert_raw_path;
    public static string net_log_listener_cant_convert_percent_value;
    public static string net_log_listener_cant_convert_to_utf8;
    public static string net_log_listener_cant_convert_bytes;
    public static string net_invalidstatus;
    public static string net_WebHeaderInvalidControlChars;
    public static string net_rspsubmitted;
    public static string net_nochunkuploadonhttp10;
    public static string net_cookie_exists;
    public static string net_clsmall;
    public static string net_wrongversion;
    public static string net_noseek;
    public static string net_writeonlystream;
    public static string net_entitytoobig;
    public static string net_io_notenoughbyteswritten;
    public static string net_listener_close_urlgroup_error;
    public static string net_WebSockets_NativeSendResponseHeaders;
    public static string net_WebSockets_ClientAcceptingNoProtocols;
    public static string net_WebSockets_AcceptUnsupportedProtocol;
    public static string net_WebSockets_AcceptNotAWebSocket;
    public static string net_WebSockets_AcceptHeaderNotFound;
    public static string net_WebSockets_AcceptUnsupportedWebSocketVersion;
    public static string net_WebSockets_InvalidEmptySubProtocol;
    public static string net_WebSockets_InvalidCharInProtocolString;
    public static string net_WebSockets_ReasonNotNull;
    public static string net_WebSockets_InvalidCloseStatusCode;
    public static string net_WebSockets_InvalidCloseStatusDescription;
    public static string net_WebSockets_ArgumentOutOfRange_TooSmall;
    public static string net_WebSockets_ArgumentOutOfRange_TooBig;
    public static string net_WebSockets_UnsupportedPlatform;
    public static string net_readonlystream;
    public static string net_WebSockets_InvalidState_ClosedOrAborted;
    public static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync;
    public static string net_Websockets_AlreadyOneOutstandingOperation;
    public static string net_WebSockets_InvalidMessageType;
    public static string net_WebSockets_InvalidBufferType;
    public static string net_WebSockets_ArgumentOutOfRange_InternalBuffer;
    public static string net_WebSockets_Argument_InvalidMessageType;
    public static string net_securitypackagesupport;
    public static string net_log_operation_failed_with_error;
    public static string net_MethodNotImplementedException;
    public static string event_OperationReturnedSomething;
    public static string net_invalid_enum;
    public static string net_auth_message_not_encrypted;
    public static string SSPIInvalidHandleType;
    public static string net_io_operation_aborted;
    public static string net_invalid_path;
    public static string net_listener_auth_errors;
    public static string net_listener_close;
    public static string net_invalid_port;
    public static string net_WebSockets_InvalidState;
    public static string net_unknown_prefix;
    public static string net_reqsubmitted;
    public static string net_io_timeout_use_ge_zero;
    public static string net_writestarted;
    public static string net_badmethod;
    public static string net_servererror;
    public static string net_reqaborted;
    public static string net_OperationNotSupportedException;
    public static string net_nouploadonget;
    public static string net_repcall;
    public static string net_securityprotocolnotsupported;
    public static string net_requestaborted;
    public static string net_webstatus_Timeout;
    public static string net_baddate;
    public static string net_connarg;
    public static string net_fromto;
    public static string net_needchunked;
    public static string net_no100;
    public static string net_nochunked;
    public static string net_nottoken;
    public static string net_rangetoosmall;
    public static string net_rangetype;
    public static string net_toosmall;
    public static string net_WebHeaderInvalidCRLFChars;
    public static string net_WebHeaderInvalidHeaderChars;
    public static string net_timeout;
    public static string net_completed_result;
    public static string net_PropertyNotSupportedException;
    public static string net_InvalidStatusCode;
    public static string net_io_timeout_use_gt_zero;
    public static string net_ftp_servererror;
    public static string net_ftp_active_address_different;
    public static string net_ftp_invalid_method_name;
    public static string net_ftp_invalid_renameto;
    public static string net_ftp_invalid_response_filename;
    public static string net_ftp_invalid_status_response;
    public static string net_ftp_invalid_uri;
    public static string net_ftp_no_defaultcreds;
    public static string net_ftp_response_invalid_format;
    public static string net_ftp_server_failed_passive;
    public static string net_ftp_unsupported_method;
    public static string net_ftp_protocolerror;
    public static string net_ftp_receivefailure;
    public static string net_webstatus_NameResolutionFailure;
    public static string net_webstatus_ConnectFailure;
    public static string net_ftpstatuscode_ServiceNotAvailable;
    public static string net_ftpstatuscode_CantOpenData;
    public static string net_ftpstatuscode_ConnectionClosed;
    public static string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy;
    public static string net_ftpstatuscode_ActionAbortedLocalProcessingError;
    public static string net_ftpstatuscode_ActionNotTakenInsufficientSpace;
    public static string net_ftpstatuscode_CommandSyntaxError;
    public static string net_ftpstatuscode_ArgumentSyntaxError;
    public static string net_ftpstatuscode_CommandNotImplemented;
    public static string net_ftpstatuscode_BadCommandSequence;
    public static string net_ftpstatuscode_NotLoggedIn;
    public static string net_ftpstatuscode_AccountNeeded;
    public static string net_ftpstatuscode_ActionNotTakenFileUnavailable;
    public static string net_ftpstatuscode_ActionAbortedUnknownPageType;
    public static string net_ftpstatuscode_FileActionAborted;
    public static string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed;
    public static string net_invalid_host;
    public static string net_sockets_connect_multiconnect_notsupported;
    public static string net_sockets_dualmode_receivefrom_notsupported;
    public static string net_sockets_accept_receive_notsupported;
    public static string net_sockets_duplicateandclose_notsupported;
    public static string net_sockets_transmitfileoptions_notsupported;
    public static string ArgumentOutOfRange_PathLengthInvalid;
    public static string net_io_readwritefailure;
    public static string PlatformNotSupported_AcceptSocket;
    public static string PlatformNotSupported_IOControl;
    public static string PlatformNotSupported_IPProtectionLevel;
    public static string InvalidOperation_BufferNotExplicitArray;
    public static string InvalidOperation_IncorrectToken;
    public static string InvalidOperation_MultipleContinuations;
    public static string net_http_httpmethod_format_error;
    public static string net_http_httpmethod_notsupported_error;
    public static string net_http_reasonphrase_format_error;
    public static string net_http_copyto_array_too_small;
    public static string net_http_headers_not_found;
    public static string net_http_headers_single_value_header;
    public static string net_http_headers_invalid_header_name;
    public static string net_http_headers_invalid_value;
    public static string net_http_headers_not_allowed_header_name;
    public static string net_http_headers_invalid_host_header;
    public static string net_http_headers_invalid_from_header;
    public static string net_http_headers_invalid_etag_name;
    public static string net_http_headers_invalid_range;
    public static string net_http_headers_no_newlines;
    public static string net_http_content_buffersize_exceeded;
    public static string net_http_content_no_task_returned;
    public static string net_http_content_stream_already_read;
    public static string net_http_content_readonly_stream;
    public static string net_http_content_invalid_charset;
    public static string net_http_content_stream_copy_error;
    public static string net_http_argument_empty_string;
    public static string net_http_client_request_already_sent;
    public static string net_http_operation_started;
    public static string net_http_client_execution_error;
    public static string net_http_client_absolute_baseaddress_required;
    public static string net_http_client_invalid_requesturi;
    public static string net_http_client_http_baseaddress_required;
    public static string net_http_parser_invalid_base64_string;
    public static string net_http_handler_noresponse;
    public static string net_http_handler_norequest;
    public static string net_http_message_not_success_statuscode;
    public static string net_http_content_field_too_long;
    public static string net_http_log_headers_no_newlines;
    public static string net_http_log_headers_invalid_quality;
    public static string net_http_log_headers_wrong_email_format;
    public static string net_http_handler_not_assigned;
    public static string net_http_invalid_enable_first;
    public static string net_http_content_buffersize_limit;
    public static string net_http_value_not_supported;
    public static string net_http_io_read;
    public static string net_http_io_read_incomplete;
    public static string net_http_io_write;
    public static string net_http_chunked_not_allowed_with_empty_content;
    public static string net_http_invalid_cookiecontainer;
    public static string net_http_invalid_proxyusepolicy;
    public static string net_http_invalid_proxy;
    public static string net_http_value_must_be_greater_than;
    public static string net_http_unix_invalid_credential;
    public static string net_http_unix_https_support_unavailable_libcurl;
    public static string net_http_content_no_concurrent_reads;
    public static string net_http_username_empty_string;
    public static string net_http_no_concurrent_io_allowed;
    public static string net_http_invalid_response;
    public static string net_http_unix_handler_disposed;
    public static string net_http_buffer_insufficient_length;
    public static string net_http_response_headers_exceeded_length;
    public static string ArgumentOutOfRange_NeedNonNegativeNum;
    public static string net_http_libcurl_callback_notsupported_sslbackend;
    public static string net_http_libcurl_callback_notsupported_os;
    public static string net_http_libcurl_clientcerts_notsupported_sslbackend;
    public static string net_http_libcurl_clientcerts_notsupported_os;
    public static string net_http_libcurl_revocation_notsupported_sslbackend;
    public static string net_http_feature_requires_Windows10Version1607;
    public static string net_http_feature_UWPClientCertSupportRequiresCertInPersonalCertificateStore;
    public static string net_http_invalid_proxy_scheme;
    public static string net_http_request_invalid_char_encoding;
    public static string net_http_ssl_connection_failed;
    public static string net_http_unsupported_chunking;
    public static string net_http_unsupported_version;
    public static string IO_SeekBeforeBegin;
    public static string net_http_request_no_host;
    public static string net_http_winhttp_error;
    public static string net_http_authconnectionfailure;
    public static string net_nego_server_not_supported;
    public static string net_nego_protection_level_not_supported;
    public static string net_context_buffer_too_small;
    public static string net_gssapi_operation_failed_detailed;
    public static string net_gssapi_operation_failed;
    public static string net_nego_channel_binding_not_supported;
    public static string net_ntlm_not_possible_default_cred;
    public static string net_nego_not_supported_empty_target_with_defaultcreds;
    public static string Arg_ElementsInSourceIsGreaterThanDestination;
    public static string Arg_NullArgumentNullRef;
    public static string Arg_TypeNotSupported;
    public static string Arg_InsufficientNumberOfElements;
    public static string NoMetadataTokenAvailable;
    public static string PlatformNotSupported_ReflectionTypeExtensions;
    public static string Argument_EmptyApplicationName;
    public static string ArgumentOutOfRange_GenericPositive;
    public static string ArgumentOutOfRange_MustBePositive;
    public static string InvalidOperation_ComputerName;
    public static string InvalidOperation_GetVersion;
    public static string PersistedFiles_NoHomeDirectory;
    public static string Argument_BadResourceScopeTypeBits;
    public static string Argument_BadResourceScopeVisibilityBits;
    public static string ArgumentNull_TypeRequiredByResourceScope;
    public static string Argument_ResourceScopeWrongDirection;
    public static string AppDomain_Name;
    public static string AppDomain_NoContextPolicies;
    public static string Arg_MustBeTrue;
    public static string Arg_CannotUnloadAppDomainException;
    public static string Arg_AppDomainUnloadedException;
    public static string ZeroLengthString;
    public static string EntryPointNotFound;
    public static string Arg_ContextMarshalException;
    public static string AppDomain_Policy_PrincipalTwice;
    public static string ArgumentNull_Collection;
    public static string ArgumentOutOfRange_ArrayListInsert;
    public static string ArgumentOutOfRange_Count;
    public static string ArgumentOutOfRange_HashtableLoadFactor;
    public static string ArgumentOutOfRange_MustBeNonNegNum;
    public static string Arg_CannotMixComparisonInfrastructure;
    public static string InvalidOperation_HashInsertFailed;
    public static string InvalidOperation_UnderlyingArrayListChanged;
    public static string NotSupported_FixedSizeCollection;
    public static string NotSupported_RangeCollection;
    public static string NotSupported_ReadOnlyCollection;
    public static string Serialization_KeyValueDifferentSizes;
    public static string Serialization_NullKey;
    public static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed;
    public static string Argument_StreamNotReadable;
    public static string Argument_StreamNotWritable;
    public static string ObjectDisposed_ReaderClosed;
    public static string ArgumentNull_Child;
    public static string Argument_AttributeNamesMustBeUnique;
    public static string Argument_InvalidElementName;
    public static string Argument_InvalidElementTag;
    public static string Argument_InvalidElementText;
    public static string Argument_InvalidElementValue;
    public static string Argument_InvalidFlag;
    public static string PlatformNotSupported_AppDomains;
    public static string PlatformNotSupported_CAS;
    public static string PlatformNotSupported_AppDomain_ResMon;
    public static string Argument_EmptyValue;
    public static string PlatformNotSupported_RuntimeInformation;
    public static string Overflow_Negative_Unsigned;
    public static string Cryptography_Oid_InvalidName;
    public static string Cryptography_SSE_InvalidDataSize;
    public static string Cryptography_Der_Invalid_Encoding;
    public static string ObjectDisposed_Generic;
    public static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum;
    public static string Cryptography_Asn_NamedBitListRequiresFlagsEnum;
    public static string Cryptography_Asn_NamedBitListValueTooBig;
    public static string Cryptography_Asn_UniversalValueIsFixed;
    public static string Cryptography_Asn_UnusedBitCountRange;
    public static string Cryptography_AsnSerializer_AmbiguousFieldType;
    public static string Cryptography_AsnSerializer_Choice_AllowNullNonNullable;
    public static string Cryptography_AsnSerializer_Choice_ConflictingTagMapping;
    public static string Cryptography_AsnSerializer_Choice_DefaultValueDisallowed;
    public static string Cryptography_AsnSerializer_Choice_NoChoiceWasMade;
    public static string Cryptography_AsnSerializer_Choice_NonNullableField;
    public static string Cryptography_AsnSerializer_Choice_TooManyValues;
    public static string Cryptography_AsnSerializer_Choice_TypeCycle;
    public static string Cryptography_AsnSerializer_MultipleAsnTypeAttributes;
    public static string Cryptography_AsnSerializer_NoJaggedArrays;
    public static string Cryptography_AsnSerializer_NoMultiDimensionalArrays;
    public static string Cryptography_AsnSerializer_NoOpenTypes;
    public static string Cryptography_AsnSerializer_Optional_NonNullableField;
    public static string Cryptography_AsnSerializer_PopulateFriendlyNameOnString;
    public static string Cryptography_AsnSerializer_SetValueException;
    public static string Cryptography_AsnSerializer_SpecificTagChoice;
    public static string Cryptography_AsnSerializer_UnexpectedTypeForAttribute;
    public static string Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall;
    public static string Cryptography_AsnSerializer_UnhandledType;
    public static string Cryptography_AsnWriter_EncodeUnbalancedStack;
    public static string Cryptography_AsnWriter_PopWrongTag;
    public static string Cryptography_BadHashValue;
    public static string Cryptography_BadSignature;
    public static string Cryptography_Cms_CannotDetermineSignatureAlgorithm;
    public static string Cryptography_Cms_IncompleteCertChain;
    public static string Cryptography_Cms_Invalid_Originator_Identifier_Choice;
    public static string Cryptography_Cms_InvalidMessageType;
    public static string Cryptography_Cms_InvalidSignerHashForSignatureAlg;
    public static string Cryptography_Cms_MissingAuthenticatedAttribute;
    public static string Cryptography_Cms_NoCounterCounterSigner;
    public static string Cryptography_Cms_NoRecipients;
    public static string Cryptography_Cms_NoSignerCert;
    public static string Cryptography_Cms_NoSignerAtIndex;
    public static string Cryptography_Cms_RecipientNotFound;
    public static string Cryptography_Cms_RecipientType_NotSupported;
    public static string Cryptography_Cms_SignerNotFound;
    public static string Cryptography_Cms_Signing_RequiresPrivateKey;
    public static string Cryptography_Cms_TrustFailure;
    public static string Cryptography_Cms_UnknownAlgorithm;
    public static string Cryptography_Cms_UnknownKeySpec;
    public static string Cryptography_Cms_WrongKeyUsage;
    public static string Cryptography_Pkcs_InvalidSignatureParameters;
    public static string Cryptography_Pkcs_PssParametersMissing;
    public static string Cryptography_Pkcs_PssParametersHashMismatch;
    public static string Cryptography_Pkcs_PssParametersMgfHashMismatch;
    public static string Cryptography_Pkcs_PssParametersMgfNotSupported;
    public static string Cryptography_Pkcs_PssParametersSaltMismatch;
    public static string Cryptography_TimestampReq_BadNonce;
    public static string Cryptography_TimestampReq_BadResponse;
    public static string Cryptography_TimestampReq_Failure;
    public static string Cryptography_TimestampReq_NoCertFound;
    public static string Cryptography_TimestampReq_UnexpectedCertFound;
    public static string InvalidOperation_WrongOidInAsnCollection;
    public static string PlatformNotSupported_CryptographyPkcs;
    public static string Cryptography_Invalid_IA5String;
    public static string Cryptography_UnknownHashAlgorithm;
    public static string Cryptography_WriteEncodedValue_OneValueAtATime;
    public static string Arg_CryptographyException;
    public static string Cryptography_CryptoStream_FlushFinalBlockTwice;
    public static string Cryptography_DefaultAlgorithm_NotSupported;
    public static string Cryptography_HashNotYetFinalized;
    public static string Cryptography_InvalidFeedbackSize;
    public static string Cryptography_InvalidBlockSize;
    public static string Cryptography_InvalidCipherMode;
    public static string Cryptography_InvalidIVSize;
    public static string Cryptography_InvalidKeySize;
    public static string Cryptography_InvalidPaddingMode;
    public static string HashNameMultipleSetNotSupported;
    public static string CryptoConfigNotSupported;
    public static string InvalidOperation_IncorrectImplementation;
    public static string Cryptography_DpApi_ProfileMayNotBeLoaded;
    public static string PlatformNotSupported_CryptographyProtectedData;
    public static string Cryptography_Partial_Chain;
    public static string Cryptography_Xml_BadWrappedKeySize;
    public static string Cryptography_Xml_CipherValueElementRequired;
    public static string Cryptography_Xml_CreateHashAlgorithmFailed;
    public static string Cryptography_Xml_CreateTransformFailed;
    public static string Cryptography_Xml_CreatedKeyFailed;
    public static string Cryptography_Xml_DigestMethodRequired;
    public static string Cryptography_Xml_DigestValueRequired;
    public static string Cryptography_Xml_EnvelopedSignatureRequiresContext;
    public static string Cryptography_Xml_InvalidElement;
    public static string Cryptography_Xml_InvalidEncryptionProperty;
    public static string Cryptography_Xml_InvalidKeySize;
    public static string Cryptography_Xml_InvalidReference;
    public static string Cryptography_Xml_InvalidSignatureLength;
    public static string Cryptography_Xml_InvalidSignatureLength2;
    public static string Cryptography_Xml_InvalidX509IssuerSerialNumber;
    public static string Cryptography_Xml_KeyInfoRequired;
    public static string Cryptography_Xml_KW_BadKeySize;
    public static string Cryptography_Xml_LoadKeyFailed;
    public static string Cryptography_Xml_MissingAlgorithm;
    public static string Cryptography_Xml_MissingCipherData;
    public static string Cryptography_Xml_MissingDecryptionKey;
    public static string Cryptography_Xml_MissingEncryptionKey;
    public static string Cryptography_Xml_NotSupportedCryptographicTransform;
    public static string Cryptography_Xml_ReferenceElementRequired;
    public static string Cryptography_Xml_ReferenceTypeRequired;
    public static string Cryptography_Xml_SelfReferenceRequiresContext;
    public static string Cryptography_Xml_SignatureDescriptionNotCreated;
    public static string Cryptography_Xml_SignatureMethodKeyMismatch;
    public static string Cryptography_Xml_SignatureMethodRequired;
    public static string Cryptography_Xml_SignatureValueRequired;
    public static string Cryptography_Xml_SignedInfoRequired;
    public static string Cryptography_Xml_TransformIncorrectInputType;
    public static string Cryptography_Xml_IncorrectObjectType;
    public static string Cryptography_Xml_UnknownTransform;
    public static string Cryptography_Xml_UriNotResolved;
    public static string Cryptography_Xml_UriNotSupported;
    public static string Cryptography_Xml_UriRequired;
    public static string Cryptography_Xml_XrmlMissingContext;
    public static string Cryptography_Xml_XrmlMissingIRelDecryptor;
    public static string Cryptography_Xml_XrmlMissingIssuer;
    public static string Cryptography_Xml_XrmlMissingLicence;
    public static string Cryptography_Xml_XrmlUnableToDecryptGrant;
    public static string Log_ActualHashValue;
    public static string Log_BeginCanonicalization;
    public static string Log_BeginSignatureComputation;
    public static string Log_BeginSignatureVerification;
    public static string Log_BuildX509Chain;
    public static string Log_CanonicalizationSettings;
    public static string Log_CanonicalizedOutput;
    public static string Log_CertificateChain;
    public static string Log_CheckSignatureFormat;
    public static string Log_CheckSignedInfo;
    public static string Log_FormatValidationSuccessful;
    public static string Log_FormatValidationNotSuccessful;
    public static string Log_KeyUsages;
    public static string Log_NoNamespacesPropagated;
    public static string Log_PropagatingNamespace;
    public static string Log_RawSignatureValue;
    public static string Log_ReferenceHash;
    public static string Log_RevocationMode;
    public static string Log_RevocationFlag;
    public static string Log_SigningAsymmetric;
    public static string Log_SigningHmac;
    public static string Log_SigningReference;
    public static string Log_TransformedReferenceContents;
    public static string Log_UnsafeCanonicalizationMethod;
    public static string Log_UrlTimeout;
    public static string Log_VerificationFailed;
    public static string Log_VerificationFailed_References;
    public static string Log_VerificationFailed_SignedInfo;
    public static string Log_VerificationFailed_X509Chain;
    public static string Log_VerificationFailed_X509KeyUsage;
    public static string Log_VerificationFlag;
    public static string Log_VerificationTime;
    public static string Log_VerificationWithKeySuccessful;
    public static string Log_VerificationWithKeyNotSuccessful;
    public static string Log_VerifyReference;
    public static string Log_VerifySignedInfoAsymmetric;
    public static string Log_VerifySignedInfoHmac;
    public static string Log_X509ChainError;
    public static string Log_XmlContext;
    public static string Log_SignedXmlRecursionLimit;
    public static string Log_UnsafeTransformMethod;
    public static string Arg_InvalidType;
    public static string Chain_NoPolicyMatch;
    public static string Cryptography_BadHashSize_ForAlgorithm;
    public static string Cryptography_Cert_AlreadyHasPrivateKey;
    public static string Cryptography_CertReq_AlgorithmMustMatch;
    public static string Cryptography_CertReq_BasicConstraintsRequired;
    public static string Cryptography_CertReq_DatesReversed;
    public static string Cryptography_CertReq_DateTooOld;
    public static string Cryptography_CertReq_DuplicateExtension;
    public static string Cryptography_CertReq_IssuerBasicConstraintsInvalid;
    public static string Cryptography_CertReq_IssuerKeyUsageInvalid;
    public static string Cryptography_CertReq_IssuerRequiresPrivateKey;
    public static string Cryptography_CertReq_NotAfterNotNested;
    public static string Cryptography_CertReq_NotBeforeNotNested;
    public static string Cryptography_CertReq_NoKeyProvided;
    public static string Cryptography_CertReq_RSAPaddingRequired;
    public static string Cryptography_CSP_NoPrivateKey;
    public static string Cryptography_CurveNotSupported;
    public static string Cryptography_ECC_NamedCurvesOnly;
    public static string Cryptography_Encryption_MessageTooLong;
    public static string Cryptography_HashAlgorithmNameNullOrEmpty;
    public static string Cryptography_InvalidOID;
    public static string Cryptography_InvalidPublicKey_Object;
    public static string Cryptography_InvalidRsaParameters;
    public static string Cryptography_KeyTooSmall;
    public static string Cryptography_OAEP_Decryption_Failed;
    public static string Cryptography_OpenInvalidHandle;
    public static string Cryptography_PrivateKey_DoesNotMatch;
    public static string Cryptography_PrivateKey_WrongAlgorithm;
    public static string Cryptography_RSA_DecryptWrongSize;
    public static string Cryptography_SignHash_WrongSize;
    public static string Cryptography_Unix_X509_DisallowedStoreNotEmpty;
    public static string Cryptography_Unix_X509_MachineStoresReadOnly;
    public static string Cryptography_Unix_X509_MachineStoresRootOnly;
    public static string Cryptography_Unix_X509_NoDisallowedStore;
    public static string Cryptography_Unix_X509_PropertyNotSettable;
    public static string Cryptography_UnknownKeyAlgorithm;
    public static string Cryptography_Unix_X509_SerializedExport;
    public static string Cryptography_Unmapped_System_Typed_Error;
    public static string Cryptography_X509_InvalidFlagCombination;
    public static string Cryptography_X509_PKCS7_NoSigner;
    public static string Cryptography_X509_StoreAddFailure;
    public static string Cryptography_X509_StoreNoFileAvailable;
    public static string Cryptography_X509_StoreNotFound;
    public static string Cryptography_X509_StoreReadOnly;
    public static string Cryptography_X509_StoreCannotCreate;
    public static string NotSupported_ECDsa_Csp;
    public static string NotSupported_Export_MultiplePrivateCerts;
    public static string NotSupported_LegacyBasicConstraints;
    public static string NotSupported_ImmutableX509Certificate;
    public static string Security_AccessDenied;
    public static string Cryptography_FileStatusError;
    public static string Cryptography_InvalidDirectoryPermissions;
    public static string Cryptography_OwnerNotCurrentUser;
    public static string Cryptography_InvalidFilePermissions;
    public static string Cryptography_Invalid_X500Name;
    public static string Cryptography_X509_NoEphemeralPfx;
    public static string Cryptography_X509Store_WouldModifyUserTrust;
    public static string Cryptography_X509Store_WouldModifyAdminTrust;
    public static string Cryptography_DSA_KeyGenNotSupported;
    public static string Cryptography_InvalidDsaParameters_MissingFields;
    public static string Cryptography_InvalidDsaParameters_MismatchedPGY;
    public static string Cryptography_InvalidDsaParameters_MismatchedQX;
    public static string Cryptography_InvalidDsaParameters_MismatchedPJ;
    public static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey;
    public static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey;
    public static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey;
    public static string InvalidEmptyArgument;
    public static string PlatformNotSupported_CompileToAssembly;
    public static string Parallel_Invoke_ActionNull;
    public static string Parallel_ForEach_OrderedPartitionerKeysNotNormalized;
    public static string Parallel_ForEach_PartitionerNotDynamic;
    public static string Parallel_ForEach_PartitionerReturnedNull;
    public static string Parallel_ForEach_NullEnumerator;
    public static string ParallelState_Break_InvalidOperationException_BreakAfterStop;
    public static string ParallelState_Stop_InvalidOperationException_StopAfterBreak;
    public static string ParallelState_NotSupportedException_UnsupportedMethod;
    public static string ArgumentOutOfRange_InvalidThreshold;
    public static string Argument_ItemNotExist;
    public static string AmbiguousImplementationException_NullMessage;
    public static string Arg_AccessException;
    public static string Arg_AccessViolationException;
    public static string Arg_ApplicationException;
    public static string Arg_ArgumentException;
    public static string Arg_ArithmeticException;
    public static string Arg_ArrayTypeMismatchException;
    public static string Arg_ArrayZeroError;
    public static string Arg_BadImageFormatException;
    public static string Arg_BogusIComparer;
    public static string Arg_CannotBeNaN;
    public static string Arg_CannotHaveNegativeValue;
    public static string Arg_CopyNonBlittableArray;
    public static string Arg_CopyOutOfRange;
    public static string Arg_DataMisalignedException;
    public static string Arg_DateTimeRange;
    public static string Arg_DirectoryNotFoundException;
    public static string Arg_DecBitCtor;
    public static string Arg_DivideByZero;
    public static string Arg_DlgtNullInst;
    public static string Arg_DlgtTypeMis;
    public static string Arg_DuplicateWaitObjectException;
    public static string Arg_EHClauseNotFilter;
    public static string Arg_EnumAndObjectMustBeSameType;
    public static string Arg_EntryPointNotFoundException;
    public static string Arg_EntryPointNotFoundExceptionParameterized;
    public static string Arg_ExecutionEngineException;
    public static string Arg_ExternalException;
    public static string Arg_FieldAccessException;
    public static string Arg_FormatException;
    public static string Arg_GuidArrayCtor;
    public static string Arg_HexStyleNotSupported;
    public static string Arg_IndexOutOfRangeException;
    public static string Arg_InsufficientExecutionStackException;
    public static string Arg_InvalidBase;
    public static string Arg_InvalidCastException;
    public static string Arg_InvalidHexStyle;
    public static string Arg_InvalidOperationException;
    public static string Arg_OleAutDateInvalid;
    public static string Arg_OleAutDateScale;
    public static string Arg_InvalidRuntimeTypeHandle;
    public static string Arg_IOException;
    public static string Arg_KeyNotFound;
    public static string Arg_LongerThanSrcString;
    public static string Arg_LowerBoundsMustMatch;
    public static string Arg_MissingFieldException;
    public static string Arg_MethodAccessException;
    public static string Arg_MissingMemberException;
    public static string Arg_MissingMethodException;
    public static string Arg_MulticastNotSupportedException;
    public static string Arg_MustBeBoolean;
    public static string Arg_MustBeByte;
    public static string Arg_MustBeChar;
    public static string Arg_MustBeDateTime;
    public static string Arg_MustBeDateTimeOffset;
    public static string Arg_MustBeDecimal;
    public static string Arg_MustBeDouble;
    public static string Arg_MustBeEnum;
    public static string Arg_MustBeGuid;
    public static string Arg_MustBeInt16;
    public static string Arg_MustBeInt32;
    public static string Arg_MustBeInt64;
    public static string Arg_MustBePrimArray;
    public static string Arg_MustBeSByte;
    public static string Arg_MustBeSingle;
    public static string Arg_MustBeStatic;
    public static string Arg_MustBeString;
    public static string Arg_MustBeStringPtrNotAtom;
    public static string Arg_MustBeTimeSpan;
    public static string Arg_MustBeUInt16;
    public static string Arg_MustBeUInt32;
    public static string Arg_MustBeUInt64;
    public static string Arg_MustBeVersion;
    public static string Arg_NeedAtLeast1Rank;
    public static string Arg_Need2DArray;
    public static string Arg_Need3DArray;
    public static string Arg_NegativeArgCount;
    public static string Arg_NotFiniteNumberException;
    public static string Arg_NotGenericParameter;
    public static string Arg_NotImplementedException;
    public static string Arg_NotSupportedException;
    public static string Arg_NotSupportedNonZeroLowerBound;
    public static string Arg_NullReferenceException;
    public static string Arg_ObjObjEx;
    public static string Arg_OverflowException;
    public static string Arg_OutOfMemoryException;
    public static string Arg_PlatformNotSupported;
    public static string Arg_ParamName_Name;
    public static string Arg_PathEmpty;
    public static string Arg_PathIllegalUNC_Path;
    public static string Arg_RankException;
    public static string Arg_RankIndices;
    public static string Arg_RanksAndBounds;
    public static string Arg_RegGetOverflowBug;
    public static string Arg_RegKeyNotFound;
    public static string Arg_RegInvalidKeyName;
    public static string Arg_StackOverflowException;
    public static string Arg_SynchronizationLockException;
    public static string Arg_SystemException;
    public static string Arg_TargetInvocationException;
    public static string Arg_TargetParameterCountException;
    public static string Arg_DefaultValueMissingException;
    public static string Arg_ThreadStartException;
    public static string Arg_ThreadStateException;
    public static string Arg_TimeoutException;
    public static string Arg_TypeAccessException;
    public static string Arg_TypeLoadException;
    public static string Arg_UnauthorizedAccessException;
    public static string Arg_VersionString;
    public static string Argument_AbsolutePathRequired;
    public static string Argument_AdjustmentRulesNoNulls;
    public static string Argument_AdjustmentRulesOutOfOrder;
    public static string Argument_CodepageNotSupported;
    public static string Argument_CompareOptionOrdinal;
    public static string Argument_ConflictingDateTimeRoundtripStyles;
    public static string Argument_ConflictingDateTimeStyles;
    public static string Argument_ConversionOverflow;
    public static string Argument_ConvertMismatch;
    public static string Argument_CultureInvalidIdentifier;
    public static string Argument_CultureIetfNotSupported;
    public static string Argument_CultureIsNeutral;
    public static string Argument_CultureNotSupported;
    public static string Argument_CustomCultureCannotBePassedByNumber;
    public static string Argument_DateTimeBadBinaryData;
    public static string Argument_DateTimeHasTicks;
    public static string Argument_DateTimeHasTimeOfDay;
    public static string Argument_DateTimeIsInvalid;
    public static string Argument_DateTimeIsNotAmbiguous;
    public static string Argument_DateTimeKindMustBeUnspecified;
    public static string Argument_DateTimeKindMustBeUnspecifiedOrUtc;
    public static string Argument_DateTimeOffsetInvalidDateTimeStyles;
    public static string Argument_DateTimeOffsetIsNotAmbiguous;
    public static string Argument_EmptyDecString;
    public static string Argument_EmptyName;
    public static string Argument_EmptyWaithandleArray;
    public static string Argument_EncoderFallbackNotEmpty;
    public static string Argument_EncodingConversionOverflowBytes;
    public static string Argument_EncodingConversionOverflowChars;
    public static string Argument_EncodingNotSupported;
    public static string Argument_EnumTypeDoesNotMatch;
    public static string Argument_FallbackBufferNotEmpty;
    public static string Argument_InvalidArgumentForComparison;
    public static string Argument_InvalidArrayLength;
    public static string Argument_InvalidCalendar;
    public static string Argument_InvalidCharSequence;
    public static string Argument_InvalidCharSequenceNoIndex;
    public static string Argument_InvalidCodePageBytesIndex;
    public static string Argument_InvalidCodePageConversionIndex;
    public static string Argument_InvalidCultureName;
    public static string Argument_InvalidDateTimeKind;
    public static string Argument_InvalidDateTimeStyles;
    public static string Argument_InvalidDigitSubstitution;
    public static string Argument_InvalidEnumValue;
    public static string Argument_InvalidGroupSize;
    public static string Argument_InvalidHighSurrogate;
    public static string Argument_InvalidId;
    public static string Argument_InvalidLowSurrogate;
    public static string Argument_InvalidNativeDigitCount;
    public static string Argument_InvalidNativeDigitValue;
    public static string Argument_InvalidNeutralRegionName;
    public static string Argument_InvalidNormalizationForm;
    public static string Argument_InvalidREG_TZI_FORMAT;
    public static string Argument_InvalidResourceCultureName;
    public static string Argument_InvalidSerializedString;
    public static string Argument_InvalidTimeSpanStyles;
    public static string Argument_MustBeFalse;
    public static string Argument_MustBeRuntimeType;
    public static string Argument_NoEra;
    public static string Argument_NoRegionInvariantCulture;
    public static string Argument_NotIsomorphic;
    public static string Argument_OffsetLocalMismatch;
    public static string Argument_OffsetPrecision;
    public static string Argument_OffsetOutOfRange;
    public static string Argument_OffsetUtcMismatch;
    public static string Argument_OneOfCulturesNotSupported;
    public static string Argument_OnlyMscorlib;
    public static string Argument_OutOfOrderDateTimes;
    public static string ArgumentOutOfRange_HugeArrayNotSupported;
    public static string ArgumentOutOfRange_Length;
    public static string ArgumentOutOfRange_LengthTooLarge;
    public static string ArgumentOutOfRange_NeedValidId;
    public static string Argument_InvalidTypeName;
    public static string Argument_PathFormatNotSupported_Path;
    public static string Argument_RecursiveFallback;
    public static string Argument_RecursiveFallbackBytes;
    public static string Argument_ResultCalendarRange;
    public static string Argument_TimeSpanHasSeconds;
    public static string Argument_TimeZoneNotFound;
    public static string Argument_TimeZoneInfoBadTZif;
    public static string Argument_TimeZoneInfoInvalidTZif;
    public static string Argument_ToExclusiveLessThanFromExclusive;
    public static string Argument_TransitionTimesAreIdentical;
    public static string Argument_UTCOutOfRange;
    public static string ArgumentException_OtherNotArrayOfCorrectLength;
    public static string ArgumentException_TupleIncorrectType;
    public static string ArgumentException_TupleLastArgumentNotATuple;
    public static string ArgumentException_ValueTupleIncorrectType;
    public static string ArgumentException_ValueTupleLastArgumentNotAValueTuple;
    public static string ArgumentNull_ArrayElement;
    public static string ArgumentNull_ArrayValue;
    public static string ArgumentNull_Generic;
    public static string ArgumentNull_Obj;
    public static string ArgumentNull_String;
    public static string ArgumentNull_Type;
    public static string ArgumentNull_Waithandles;
    public static string ArgumentOutOfRange_AddValue;
    public static string ArgumentOutOfRange_ActualValue;
    public static string ArgumentOutOfRange_BadYearMonthDay;
    public static string ArgumentOutOfRange_BadHourMinuteSecond;
    public static string ArgumentOutOfRange_CalendarRange;
    public static string ArgumentOutOfRange_Capacity;
    public static string ArgumentOutOfRange_DateArithmetic;
    public static string ArgumentOutOfRange_DateTimeBadMonths;
    public static string ArgumentOutOfRange_DateTimeBadTicks;
    public static string ArgumentOutOfRange_DateTimeBadYears;
    public static string ArgumentOutOfRange_Day;
    public static string ArgumentOutOfRange_DayOfWeek;
    public static string ArgumentOutOfRange_DayParam;
    public static string ArgumentOutOfRange_DecimalRound;
    public static string ArgumentOutOfRange_DecimalScale;
    public static string ArgumentOutOfRange_EndIndexStartIndex;
    public static string ArgumentOutOfRange_Era;
    public static string ArgumentOutOfRange_FileTimeInvalid;
    public static string ArgumentOutOfRange_GetByteCountOverflow;
    public static string ArgumentOutOfRange_GetCharCountOverflow;
    public static string ArgumentOutOfRange_IndexCount;
    public static string ArgumentOutOfRange_IndexCountBuffer;
    public static string ArgumentOutOfRange_IndexLength;
    public static string ArgumentOutOfRange_IndexString;
    public static string ArgumentOutOfRange_InvalidEraValue;
    public static string ArgumentOutOfRange_InvalidHighSurrogate;
    public static string ArgumentOutOfRange_InvalidLowSurrogate;
    public static string ArgumentOutOfRange_InvalidUTF32;
    public static string ArgumentOutOfRange_LengthGreaterThanCapacity;
    public static string ArgumentOutOfRange_ListInsert;
    public static string ArgumentOutOfRange_ListItem;
    public static string ArgumentOutOfRange_ListRemoveAt;
    public static string ArgumentOutOfRange_Month;
    public static string ArgumentOutOfRange_MonthParam;
    public static string ArgumentOutOfRange_MustBeNonNegInt32;
    public static string ArgumentOutOfRange_NeedNonNegOrNegative1;
    public static string ArgumentOutOfRange_NegativeCapacity;
    public static string ArgumentOutOfRange_NegativeCount;
    public static string ArgumentOutOfRange_NegativeLength;
    public static string ArgumentOutOfRange_NoGCLohSizeGreaterTotalSize;
    public static string ArgumentOutOfRange_OffsetLength;
    public static string ArgumentOutOfRange_OffsetOut;
    public static string ArgumentOutOfRange_PartialWCHAR;
    public static string ArgumentOutOfRange_Range;
    public static string ArgumentOutOfRange_RoundingDigits;
    public static string ArgumentOutOfRange_SmallMaxCapacity;
    public static string ArgumentOutOfRange_StartIndex;
    public static string ArgumentOutOfRange_StartIndexLargerThanLength;
    public static string ArgumentOutOfRange_StartIndexLessThanLength;
    public static string ArgumentOutOfRange_UtcOffset;
    public static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta;
    public static string ArgumentOutOfRange_Version;
    public static string ArgumentOutOfRange_Week;
    public static string ArgumentOutOfRange_Year;
    public static string Arithmetic_NaN;
    public static string ArrayTypeMismatch_CantAssignType;
    public static string BadImageFormatException_CouldNotLoadFileOrAssembly;
    public static string CollectionCorrupted;
    public static string Exception_EndOfInnerExceptionStack;
    public static string Exception_WasThrown;
    public static string Format_BadBase64Char;
    public static string Format_BadBase64CharArrayLength;
    public static string Format_BadBoolean;
    public static string Format_BadFormatSpecifier;
    public static string Format_NoFormatSpecifier;
    public static string Format_BadQuote;
    public static string Format_EmptyInputString;
    public static string Format_GuidHexPrefix;
    public static string Format_GuidInvLen;
    public static string Format_GuidInvalidChar;
    public static string Format_GuidBrace;
    public static string Format_GuidComma;
    public static string Format_GuidBraceAfterLastNumber;
    public static string Format_GuidDashes;
    public static string Format_GuidEndBrace;
    public static string Format_ExtraJunkAtEnd;
    public static string Format_GuidUnrecognized;
    public static string Format_IndexOutOfRange;
    public static string Format_InvalidGuidFormatSpecification;
    public static string Format_InvalidString;
    public static string Format_NeedSingleChar;
    public static string Format_NoParsibleDigits;
    public static string Format_BadTimeSpan;
    public static string InsufficientMemory_MemFailPoint;
    public static string InsufficientMemory_MemFailPoint_TooBig;
    public static string InsufficientMemory_MemFailPoint_VAFrag;
    public static string InvalidCast_CannotCastNullToValueType;
    public static string InvalidCast_DownCastArrayElement;
    public static string InvalidCast_FromTo;
    public static string InvalidCast_IConvertible;
    public static string InvalidCast_StoreArrayElement;
    public static string InvalidOperation_Calling;
    public static string InvalidOperation_DateTimeParsing;
    public static string InvalidOperation_HandleIsNotInitialized;
    public static string InvalidOperation_IComparerFailed;
    public static string InvalidOperation_NoValue;
    public static string InvalidOperation_NullArray;
    public static string InvalidOperation_Overlapped_Pack;
    public static string InvalidOperation_ReadOnly;
    public static string InvalidOperation_ThreadWrongThreadStart;
    public static string InvalidOperation_UnknownEnumType;
    public static string InvalidOperation_WriteOnce;
    public static string InvalidOperation_ArrayCreateInstance_NotARuntimeType;
    public static string InvalidOperation_TooEarly;
    public static string InvalidOperation_NullContext;
    public static string InvalidOperation_CannotUseAFCOtherThread;
    public static string InvalidOperation_CannotRestoreUnsupressedFlow;
    public static string InvalidOperation_CannotSupressFlowMultipleTimes;
    public static string InvalidOperation_CannotUseAFCMultiple;
    public static string InvalidOperation_AsyncFlowCtrlCtxMismatch;
    public static string InvalidOperation_AsyncIOInProgress;
    public static string InvalidProgram_Default;
    public static string InvalidProgram_Specific;
    public static string InvalidProgram_Vararg;
    public static string InvalidProgram_CallVirtFinalize;
    public static string InvalidProgram_NativeCallable;
    public static string InvalidTimeZone_InvalidRegistryData;
    public static string InvalidTimeZone_InvalidFileData;
    public static string InvalidTimeZone_InvalidJulianDay;
    public static string InvalidTimeZone_NJulianDayNotSupported;
    public static string InvalidTimeZone_NoTTInfoStructures;
    public static string InvalidTimeZone_UnparseablePosixMDateString;
    public static string IO_DriveNotFound_Drive;
    public static string IO_FileName_Name;
    public static string IO_FileLoad;
    public static string IO_FileLoad_FileName;
    public static string Lazy_CreateValue_NoParameterlessCtorForT;
    public static string Lazy_ctor_ModeInvalid;
    public static string Lazy_StaticInit_InvalidOperation;
    public static string Lazy_ToString_ValueNotCreated;
    public static string Lazy_Value_RecursiveCallsToValue;
    public static string MissingConstructor_Name;
    public static string MustUseCCRewrite;
    public static string NotSupported_MaxWaitHandles;
    public static string NotSupported_NoCodepageData;
    public static string NotSupported_StringComparison;
    public static string NotSupported_VoidArray;
    public static string NotSupported_ByRefLike;
    public static string NotSupported_Type;
    public static string NotSupported_WaitAllSTAThread;
    public static string ObjectDisposed_ObjectName_Name;
    public static string Overflow_Byte;
    public static string Overflow_Char;
    public static string Overflow_Double;
    public static string Overflow_TimeSpanElementTooLarge;
    public static string Overflow_Duration;
    public static string Overflow_Int16;
    public static string Overflow_NegateTwosCompNum;
    public static string Overflow_NegativeUnsigned;
    public static string Overflow_SByte;
    public static string Overflow_Single;
    public static string Overflow_TimeSpanTooLong;
    public static string Overflow_UInt16;
    public static string Rank_MultiDimNotSupported;
    public static string RuntimeWrappedException;
    public static string SpinWait_SpinUntil_ArgumentNull;
    public static string Serialization_CorruptField;
    public static string Serialization_InvalidData;
    public static string Serialization_InvalidEscapeSequence;
    public static string Serialization_InvalidType;
    public static string SpinWait_SpinUntil_TimeoutWrong;
    public static string Threading_AbandonedMutexException;
    public static string Threading_SemaphoreFullException;
    public static string Threading_ThreadInterrupted;
    public static string Threading_WaitHandleCannotBeOpenedException;
    public static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle;
    public static string TimeZoneNotFound_MissingData;
    public static string TypeInitialization_Default;
    public static string TypeInitialization_Type;
    public static string TypeInitialization_Type_NoTypeAvailable;
    public static string Verification_Exception;
    public static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType;
    public static string Format_InvalidEnumFormatSpecification;
    public static string Arg_MustBeEnumBaseTypeOrEnum;
    public static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType;
    public static string Arg_MustBeType;
    public static string Arg_MustContainEnumInfo;
    public static string Arg_EnumValueNotFound;
    public static string Argument_StringZeroLength;
    public static string Argument_StringFirstCharIsZero;
    public static string Argument_LongEnvVarValue;
    public static string Argument_IllegalEnvVarName;
    public static string AssumptionFailed;
    public static string AssumptionFailed_Cnd;
    public static string AssertionFailed;
    public static string AssertionFailed_Cnd;
    public static string PreconditionFailed;
    public static string PreconditionFailed_Cnd;
    public static string PostconditionFailed;
    public static string PostconditionFailed_Cnd;
    public static string PostconditionOnExceptionFailed;
    public static string PostconditionOnExceptionFailed_Cnd;
    public static string InvariantFailed;
    public static string InvariantFailed_Cnd;
    public static string MissingEncodingNameResource;
    public static string Globalization_cp_1200;
    public static string Globalization_cp_1201;
    public static string Globalization_cp_12000;
    public static string Globalization_cp_12001;
    public static string Globalization_cp_20127;
    public static string Globalization_cp_28591;
    public static string Globalization_cp_65000;
    public static string Globalization_cp_65001;
    public static string DebugAssertBanner;
    public static string DebugAssertLongMessage;
    public static string DebugAssertShortMessage;
    public static string InvalidCast_Empty;
    public static string Arg_UnknownTypeCode;
    public static string Format_BadDatePattern;
    public static string Format_BadDateTime;
    public static string Format_BadDateTimeCalendar;
    public static string Format_BadDayOfWeek;
    public static string Format_DateOutOfRange;
    public static string Format_MissingIncompleteDate;
    public static string Format_OffsetOutOfRange;
    public static string Format_RepeatDateTimePattern;
    public static string Format_UnknownDateTimeWord;
    public static string Format_UTCOutOfRange;
    public static string RFLCT_Ambiguous;
    public static string AggregateException_ctor_DefaultMessage;
    public static string AggregateException_ctor_InnerExceptionNull;
    public static string AggregateException_DeserializationFailure;
    public static string AggregateException_InnerException;
    public static string ArgumentOutOfRange_TimeoutTooLarge;
    public static string ArgumentOutOfRange_PeriodTooLarge;
    public static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent;
    public static string TaskScheduler_ExecuteTask_WrongTaskScheduler;
    public static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline;
    public static string TaskSchedulerException_ctor_DefaultMessage;
    public static string Task_MultiTaskContinuation_FireOptions;
    public static string Task_ContinueWith_ESandLR;
    public static string Task_MultiTaskContinuation_EmptyTaskList;
    public static string Task_MultiTaskContinuation_NullTask;
    public static string Task_FromAsync_PreferFairness;
    public static string Task_FromAsync_LongRunning;
    public static string AsyncMethodBuilder_InstanceNotInitialized;
    public static string TaskT_TransitionToFinal_AlreadyCompleted;
    public static string TaskT_DebuggerNoResult;
    public static string OperationCanceled;
    public static string CancellationToken_CreateLinkedToken_TokensIsEmpty;
    public static string CancellationTokenSource_Disposed;
    public static string CancellationToken_SourceDisposed;
    public static string TaskExceptionHolder_UnknownExceptionType;
    public static string TaskExceptionHolder_UnhandledException;
    public static string Task_Delay_InvalidMillisecondsDelay;
    public static string Task_Delay_InvalidDelay;
    public static string Task_Dispose_NotCompleted;
    public static string Task_WaitMulti_NullTask;
    public static string Task_ContinueWith_NotOnAnything;
    public static string Task_RunSynchronously_AlreadyStarted;
    public static string Task_ThrowIfDisposed;
    public static string Task_RunSynchronously_TaskCompleted;
    public static string Task_RunSynchronously_Promise;
    public static string Task_RunSynchronously_Continuation;
    public static string Task_Start_AlreadyStarted;
    public static string Task_Start_ContinuationTask;
    public static string Task_Start_Promise;
    public static string Task_Start_TaskCompleted;
    public static string TaskCanceledException_ctor_DefaultMessage;
    public static string TaskCompletionSourceT_TrySetException_NoExceptions;
    public static string TaskCompletionSourceT_TrySetException_NullException;
    public static string Argument_MinMaxValue;
    public static string ExecutionContext_ExceptionInAsyncLocalNotification;
    public static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple;
    public static string SpinLock_IsHeldByCurrentThread;
    public static string SpinLock_TryEnter_LockRecursionException;
    public static string SpinLock_Exit_SynchronizationLockException;
    public static string SpinLock_TryReliableEnter_ArgumentException;
    public static string SpinLock_TryEnter_ArgumentOutOfRange;
    public static string ManualResetEventSlim_Disposed;
    public static string ManualResetEventSlim_ctor_SpinCountOutOfRange;
    public static string ManualResetEventSlim_ctor_TooManyWaiters;
    public static string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext;
    public static string SemaphoreSlim_Disposed;
    public static string SemaphoreSlim_Release_CountWrong;
    public static string SemaphoreSlim_Wait_TimeoutWrong;
    public static string SemaphoreSlim_ctor_MaxCountWrong;
    public static string SemaphoreSlim_ctor_InitialCountWrong;
    public static string ThreadLocal_ValuesNotAvailable;
    public static string ThreadLocal_Value_RecursiveCallsToValue;
    public static string ThreadLocal_Disposed;
    public static string LockRecursionException_WriteAfterReadNotAllowed;
    public static string LockRecursionException_RecursiveWriteNotAllowed;
    public static string LockRecursionException_ReadAfterWriteNotAllowed;
    public static string LockRecursionException_RecursiveUpgradeNotAllowed;
    public static string LockRecursionException_RecursiveReadNotAllowed;
    public static string SynchronizationLockException_IncorrectDispose;
    public static string SynchronizationLockException_MisMatchedWrite;
    public static string LockRecursionException_UpgradeAfterReadNotAllowed;
    public static string LockRecursionException_UpgradeAfterWriteNotAllowed;
    public static string SynchronizationLockException_MisMatchedUpgrade;
    public static string SynchronizationLockException_MisMatchedRead;
    public static string InvalidOperation_TimeoutsNotSupported;
    public static string NotSupported_SubclassOverride;
    public static string InvalidOperation_NoPublicRemoveMethod;
    public static string InvalidOperation_NoPublicAddMethod;
    public static string SerializationException;
    public static string Serialization_NotFound;
    public static string Serialization_OptionalFieldVersionValue;
    public static string Serialization_SameNameTwice;
    public static string NotSupported_AbstractNonCLS;
    public static string NotSupported_NoTypeInfo;
    public static string Arg_CustomAttributeFormatException;
    public static string Argument_InvalidMemberForNamedArgument;
    public static string Arg_InvalidFilterCriteriaException;
    public static string Arg_ParmArraySize;
    public static string Arg_MustBePointer;
    public static string Argument_InvalidEnum;
    public static string Argument_MustHaveAttributeBaseClass;
    public static string InvalidFilterCriteriaException_CritString;
    public static string InvalidFilterCriteriaException_CritInt;
    public static string InvalidOperation_NotSupportedOnWinRTEvent;
    public static string PlatformNotSupported_ReflectionOnly;
    public static string PlatformNotSupported_OSXFileLocking;
    public static string PlatformNotSupported_ReflectionEmit;
    public static string MissingMember_Name;
    public static string MissingMethod_Name;
    public static string MissingField_Name;
    public static string Format_StringZeroLength;
    public static string Security_CannotReadFileData;
    public static string Security_CannotReadRegistryData;
    public static string Security_InvalidAssemblyPublicKey;
    public static string Security_RegistryPermission;
    public static string ClassLoad_General;
    public static string ClassLoad_RankTooLarge;
    public static string ClassLoad_ExplicitGeneric;
    public static string ClassLoad_BadFormat;
    public static string ClassLoad_ValueClassTooLarge;
    public static string ClassLoad_ExplicitLayout;
    public static string EE_MissingMethod;
    public static string EE_MissingField;
    public static string UnauthorizedAccess_RegistryKeyGeneric_Key;
    public static string UnknownError_Num;
    public static string Argument_NeedStructWithNoRefs;
    public static string ArgumentOutOfRange_AddressSpace;
    public static string ArgumentOutOfRange_UIntPtrMax;
    public static string Arg_BufferTooSmall;
    public static string InvalidOperation_MustCallInitialize;
    public static string Argument_InvalidSafeBufferOffLen;
    public static string Argument_NotEnoughBytesToRead;
    public static string Argument_NotEnoughBytesToWrite;
    public static string Argument_OffsetAndCapacityOutOfBounds;
    public static string ArgumentOutOfRange_UnmanagedMemStreamLength;
    public static string Argument_UnmanagedMemAccessorWrapAround;
    public static string ArgumentOutOfRange_StreamLength;
    public static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround;
    public static string InvalidOperation_CalledTwice;
    public static string IO_FixedCapacity;
    public static string IO_StreamTooLong;
    public static string Arg_BadDecimal;
    public static string NotSupported_Reading;
    public static string NotSupported_UmsSafeBuffer;
    public static string NotSupported_Writing;
    public static string IndexOutOfRange_UMSPosition;
    public static string ObjectDisposed_ViewAccessorClosed;
    public static string ArgumentOutOfRange_PositionLessThanCapacityRequired;
    public static string Arg_EndOfStreamException;
    public static string Argument_InvalidHandle;
    public static string Argument_AlreadyBoundOrSyncHandle;
    public static string Argument_PreAllocatedAlreadyAllocated;
    public static string Argument_NativeOverlappedAlreadyFree;
    public static string Argument_NativeOverlappedWrongBoundHandle;
    public static string NotSupported_FileStreamOnNonFiles;
    public static string Arg_ResourceFileUnsupportedVersion;
    public static string Resources_StreamNotValid;
    public static string BadImageFormat_ResourcesHeaderCorrupted;
    public static string BadImageFormat_NegativeStringLength;
    public static string BadImageFormat_ResourcesNameInvalidOffset;
    public static string BadImageFormat_TypeMismatch;
    public static string BadImageFormat_ResourceNameCorrupted_NameIndex;
    public static string BadImageFormat_ResourcesDataInvalidOffset;
    public static string Format_Bad7BitInt32;
    public static string BadImageFormat_InvalidType;
    public static string ResourceReaderIsClosed;
    public static string Arg_MissingManifestResourceException;
    public static string UnauthorizedAccess_MemStreamBuffer;
    public static string NotSupported_MemStreamNotExpandable;
    public static string ArgumentNull_Stream;
    public static string IO_InvalidStringLen_Len;
    public static string ArgumentOutOfRange_BinaryReaderFillBuffer;
    public static string Serialization_InsufficientDeserializationState;
    public static string NotSupported_UnitySerHolder;
    public static string Serialization_UnableToFindModule;
    public static string Argument_InvalidUnity;
    public static string InvalidOperation_InvalidHandle;
    public static string PlatformNotSupported_NamedSynchronizationPrimitives;
    public static string Overflow_MutexReacquireCount;
    public static string Serialization_InsufficientState;
    public static string Serialization_UnknownMember;
    public static string Serialization_NullSignature;
    public static string Serialization_MemberTypeNotRecognized;
    public static string Serialization_BadParameterInfo;
    public static string Serialization_NoParameterInfo;
    public static string ArgumentNull_Assembly;
    public static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture;
    public static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc;
    public static string Arg_InvalidSatelliteContract_Asm_Ver;
    public static string Arg_ResMgrNotResSet;
    public static string BadImageFormat_ResourceNameCorrupted;
    public static string BadImageFormat_ResourcesNameTooLong;
    public static string InvalidOperation_ResMgrBadResSet_Type;
    public static string InvalidOperation_ResourceNotStream_Name;
    public static string MissingManifestResource_MultipleBlobs;
    public static string MissingManifestResource_NoNeutralAsm;
    public static string MissingManifestResource_NoNeutralDisk;
    public static string MissingManifestResource_NoPRIresources;
    public static string MissingManifestResource_ResWFileNotLoaded;
    public static string MissingSatelliteAssembly_Culture_Name;
    public static string MissingSatelliteAssembly_Default;
    public static string NotSupported_ObsoleteResourcesFile;
    public static string NotSupported_ResourceObjectSerialization;
    public static string ObjectDisposed_ResourceSet;
    public static string Arg_ResourceNameNotExist;
    public static string BadImageFormat_ResourceDataLengthInvalid;
    public static string BadImageFormat_ResourcesIndexTooLong;
    public static string InvalidOperation_ResourceNotString_Name;
    public static string InvalidOperation_ResourceNotString_Type;
    public static string NotSupported_WrongResourceReader_Type;
    public static string Arg_MustBeDelegate;
    public static string NotSupported_GlobalMethodSerialization;
    public static string NotSupported_DelegateSerHolderSerial;
    public static string DelegateSer_InsufficientMetadata;
    public static string Argument_NoUninitializedStrings;
    public static string ArgumentOutOfRangeException_NoGCRegionSizeTooLarge;
    public static string InvalidOperationException_AlreadyInNoGCRegion;
    public static string InvalidOperationException_NoGCRegionAllocationExceeded;
    public static string InvalidOperationException_NoGCRegionInduced;
    public static string InvalidOperationException_NoGCRegionNotInProgress;
    public static string InvalidOperationException_SetLatencyModeNoGC;
    public static string InvalidOperation_NotWithConcurrentGC;
    public static string ThreadState_AlreadyStarted;
    public static string ThreadState_Dead_Priority;
    public static string ThreadState_Dead_State;
    public static string ThreadState_NotStarted;
    public static string ThreadState_SetPriorityFailed;
    public static string Serialization_InvalidFieldState;
    public static string Acc_CreateAbst;
    public static string Acc_CreateGeneric;
    public static string NotSupported_ManagedActivation;
    public static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod;
    public static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty;
    public static string Serialization_NonSerType;
    public static string InvalidCast_DBNull;
    public static string NotSupported_NYI;
    public static string Delegate_GarbageCollected;
    public static string Arg_AmbiguousMatchException;
    public static string NotSupported_ChangeType;
    public static string Arg_EmptyArray;
    public static string MissingMember;
    public static string MissingField;
    public static string InvalidCast_FromDBNull;
    public static string NotSupported_DBNullSerial;
    public static string Serialization_StringBuilderCapacity;
    public static string Serialization_StringBuilderMaxCapacity;
    public static string PlatformNotSupported_Remoting;
    public static string PlatformNotSupported_StrongNameSigning;
    public static string Serialization_MissingDateTimeData;
    public static string Serialization_DateTimeTicksOutOfRange;
    public static string FeatureRemoved_Message;
    public static string Arg_InvalidANSIString;
    public static string PlatformNotSupported_ArgIterator;
    public static string Arg_TypeUnloadedException;
    public static string Overflow_Currency;
    public static string PlatformNotSupported_SecureBinarySerialization;
    public static string Serialization_InvalidPtrValue;
    public static string EventSource_AbstractMustNotDeclareEventMethods;
    public static string EventSource_AbstractMustNotDeclareKTOC;
    public static string EventSource_AddScalarOutOfRange;
    public static string EventSource_BadHexDigit;
    public static string EventSource_ChannelTypeDoesNotMatchEventChannelValue;
    public static string EventSource_DataDescriptorsOutOfRange;
    public static string EventSource_DuplicateStringKey;
    public static string EventSource_EnumKindMismatch;
    public static string EventSource_EvenHexDigits;
    public static string EventSource_EventChannelOutOfRange;
    public static string EventSource_EventIdReused;
    public static string EventSource_EventMustHaveTaskIfNonDefaultOpcode;
    public static string EventSource_EventMustNotBeExplicitImplementation;
    public static string EventSource_EventNameDoesNotEqualTaskPlusOpcode;
    public static string EventSource_EventNameReused;
    public static string EventSource_EventParametersMismatch;
    public static string EventSource_EventSourceGuidInUse;
    public static string EventSource_EventTooBig;
    public static string EventSource_EventWithAdminChannelMustHaveMessage;
    public static string EventSource_IllegalKeywordsValue;
    public static string EventSource_IllegalOpcodeValue;
    public static string EventSource_IllegalTaskValue;
    public static string EventSource_IllegalValue;
    public static string EventSource_IncorrentlyAuthoredTypeInfo;
    public static string EventSource_InvalidCommand;
    public static string EventSource_InvalidEventFormat;
    public static string EventSource_KeywordCollision;
    public static string EventSource_KeywordNeedPowerOfTwo;
    public static string EventSource_ListenerCreatedInsideCallback;
    public static string EventSource_ListenerNotFound;
    public static string EventSource_ListenerWriteFailure;
    public static string EventSource_MaxChannelExceeded;
    public static string EventSource_MismatchIdToWriteEvent;
    public static string EventSource_NeedGuid;
    public static string EventSource_NeedName;
    public static string EventSource_NeedPositiveId;
    public static string EventSource_NoFreeBuffers;
    public static string EventSource_NonCompliantTypeError;
    public static string EventSource_NoRelatedActivityId;
    public static string EventSource_NotSupportedArrayOfBinary;
    public static string EventSource_NotSupportedArrayOfNil;
    public static string EventSource_NotSupportedArrayOfNullTerminatedString;
    public static string EventSource_NotSupportedCustomSerializedData;
    public static string EventSource_NotSupportedNestedArraysEnums;
    public static string EventSource_NullInput;
    public static string EventSource_OpcodeCollision;
    public static string EventSource_PinArrayOutOfRange;
    public static string EventSource_RecursiveTypeDefinition;
    public static string EventSource_SessionIdError;
    public static string EventSource_StopsFollowStarts;
    public static string EventSource_TaskCollision;
    public static string EventSource_TaskOpcodePairReused;
    public static string EventSource_TooManyArgs;
    public static string EventSource_TooManyFields;
    public static string EventSource_ToString;
    public static string EventSource_TraitEven;
    public static string EventSource_TypeMustBeSealedOrAbstract;
    public static string EventSource_TypeMustDeriveFromEventSource;
    public static string EventSource_UndefinedChannel;
    public static string EventSource_UndefinedKeyword;
    public static string EventSource_UndefinedOpcode;
    public static string EventSource_UnknownEtwTrait;
    public static string EventSource_UnsupportedEventTypeInManifest;
    public static string EventSource_UnsupportedMessageProperty;
    public static string EventSource_VarArgsParameterMismatch;
    public static string Arg_SurrogatesNotAllowedAsSingleChar;
    public static string CustomAttributeFormat_InvalidFieldFail;
    public static string CustomAttributeFormat_InvalidPropertyFail;
    public static string ArrayTypeMismatch_ConstrainedCopy;
    public static string Arg_DllNotFoundException;
    public static string Arg_DllNotFoundExceptionParameterized;
    public static string Arg_DriveNotFoundException;
    public static string WrongSizeArrayInNStruct;
    public static string Arg_InteropMarshalUnmappableChar;
    public static string Arg_MarshalDirectiveException;
    public static string Arg_RegSubKeyValueAbsent;
    public static string Arg_RegValStrLenBug;
    public static string Serialization_DelegatesNotSupported;
    public static string Arg_OpenType;
    public static string Arg_PlatformNotSupported_AssemblyName_GetAssemblyName;
    public static string NotSupported_OpenType;
    public static string NotSupported_ByRefLikeArray;
    public static string StackTrace_AtWord;
    public static string StackTrace_EndStackTraceFromPreviousThrow;
    public static string InvalidAssemblyName;
    public static string Argument_HasToBeArrayClass;
    public static string Argument_IdnBadBidi;
    public static string Argument_IdnBadLabelSize;
    public static string Argument_IdnBadNameSize;
    public static string Argument_IdnBadPunycode;
    public static string Argument_IdnBadStd3;
    public static string Argument_IdnIllegalName;
    public static string InvalidOperation_NotGenericType;
    public static string NotSupported_SignatureType;
    public static string Memory_OutstandingReferences;
    public static string HashCode_HashCodeNotSupported;
    public static string HashCode_EqualityNotSupported;
    public static string IO_InvalidReadLength;
    public static string Arg_BasePathNotFullyQualified;
    public static string NullReference_InvokeNullRefReturned;
    public static string Thread_Operation_RequiresCurrentThread;
    public static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple;
    public static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple;
    public static string ArgumentOutOfRange_Week_ISO;
    public static string net_uri_BadAuthority;
    public static string net_uri_BadAuthorityTerminator;
    public static string net_uri_BadFormat;
    public static string net_uri_NeedFreshParser;
    public static string net_uri_AlreadyRegistered;
    public static string net_uri_BadHostName;
    public static string net_uri_BadPort;
    public static string net_uri_BadScheme;
    public static string net_uri_BadString;
    public static string net_uri_BadUserPassword;
    public static string net_uri_CannotCreateRelative;
    public static string net_uri_SchemeLimit;
    public static string net_uri_EmptyUri;
    public static string net_uri_InvalidUriKind;
    public static string net_uri_MustRootedPath;
    public static string net_uri_NotAbsolute;
    public static string net_uri_PortOutOfRange;
    public static string net_uri_SizeLimit;
    public static string net_uri_UserDrivenParsing;
    public static string net_uri_NotJustSerialization;
    public static string net_uri_BadUnicodeHostForIdn;
    public static string Argument_ExtraNotValid;
    public static string Argument_InvalidUriSubcomponent;
    public static string AccessControl_InvalidHandle;
    public static string Arg_RegSubKeyAbsent;
    public static string Arg_RegKeyDelHive;
    public static string Arg_RegKeyNoRemoteConnect;
    public static string Arg_RegKeyOutOfRange;
    public static string Arg_RegKeyStrLenBug;
    public static string Arg_RegBadKeyKind;
    public static string Arg_RegSetMismatchedKind;
    public static string Arg_RegSetBadArrType;
    public static string Arg_RegSetStrArrNull;
    public static string Arg_DllInitFailure;
    public static string Argument_InvalidRegistryOptionsCheck;
    public static string Argument_InvalidRegistryViewCheck;
    public static string Argument_InvalidRegistryKeyPermissionCheck;
    public static string InvalidOperation_RegRemoveSubKey;
    public static string ObjectDisposed_RegKeyClosed;
    public static string PlatformNotSupported_Registry;
    public static string UnauthorizedAccess_RegistryNoWrite;
    public static string Cryptography_ArgECDHKeySizeMismatch;
    public static string Cryptography_ArgECDHRequiresECDHKey;
    public static string Cryptography_TlsRequiresLabelAndSeed;
    public static string Cryptography_TlsRequires64ByteSeed;
    public static string Cryptography_Config_EncodedOIDError;
    public static string Cryptography_ECXmlSerializationFormatRequired;
    public static string Cryptography_InvalidCurveOid;
    public static string Cryptography_InvalidCurveKeyParameters;
    public static string Cryptography_InvalidECCharacteristic2Curve;
    public static string Cryptography_InvalidECPrimeCurve;
    public static string Cryptography_InvalidECNamedCurve;
    public static string Cryptography_InvalidKey_SemiWeak;
    public static string Cryptography_InvalidKey_Weak;
    public static string Cryptography_InvalidOperation;
    public static string Cryptography_InvalidPadding;
    public static string Cryptography_MissingIV;
    public static string Cryptography_MissingKey;
    public static string Cryptography_MissingOID;
    public static string Cryptography_MustTransformWholeBlock;
    public static string Cryptography_NotValidPrivateKey;
    public static string Cryptography_NotValidPublicOrPrivateKey;
    public static string Cryptography_PartialBlock;
    public static string Cryptography_PasswordDerivedBytes_FewBytesSalt;
    public static string Cryptography_RC2_EKS40;
    public static string Cryptography_RC2_EKSKS;
    public static string Cryptography_RC2_EKSKS2;
    public static string Cryptography_Rijndael_BlockSize;
    public static string Cryptography_TransformBeyondEndOfBuffer;
    public static string Cryptography_CipherModeNotSupported;
    public static string Cryptography_UnknownPaddingMode;
    public static string Cryptography_UnexpectedTransformTruncation;
    public static string Cryptography_UnsupportedPaddingMode;
    public static string NotSupported_Method;
    public static string Cryptography_AlgorithmTypesMustBeVisible;
    public static string Cryptography_AddNullOrEmptyName;
    public static string ArgumentOutOfRange_ConsoleKey;
    public static string Arg_InvalidComObjectException;
    public static string Arg_MustBeNullTerminatedString;
    public static string Arg_InvalidOleVariantTypeException;
    public static string Arg_SafeArrayRankMismatchException;
    public static string Arg_SafeArrayTypeMismatchException;
    public static string TypeNotDelegate;
    public static string InvalidOperationException_ActorGraphCircular;
    public static string InvalidOperation_ClaimCannotBeRemoved;
    public static string PlatformNotSupported_Serialization;
    public static string PrivilegeNotHeld_Default;
    public static string PrivilegeNotHeld_Named;
    public static string CountdownEvent_Decrement_BelowZero;
    public static string CountdownEvent_Increment_AlreadyZero;
    public static string CountdownEvent_Increment_AlreadyMax;
    public static string ArrayWithOffsetOverflow;
    public static string Arg_NotIsomorphic;
    public static string StructArrayTooLarge;
    public static string IO_DriveNotFound;
    public static string Argument_MustSupplyParent;
    public static string Argument_MemberAndArray;
    public static string Argument_MustSupplyContainer;
    public static string Serialization_NoID;
    public static string Arg_SwitchExpressionException;
    public static string SwitchExpressionException_UnmatchedValue;
    public static string Argument_InvalidRandomRange;
    public static string BufferWriterAdvancedTooFar;
    public static string net_gssapi_operation_failed_detailed_majoronly;
    public static string net_gssapi_operation_failed_majoronly;
    internal static string GetString(string name, Object[] args);
    internal static string GetString(CultureInfo culture, string name, Object[] args);
    internal static string GetString(string name);
    internal static string GetString(CultureInfo culture, string name);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(CultureInfo ci, string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string GetResourceString(string str);
    public static object GetObject(string name);
}
internal class System.__ComObject : MarshalByRefObject {
    private IntPtr iunknown;
    private IntPtr hash_table;
    private SynchronizationContext synchronization_context;
    private ComInteropProxy proxy;
    internal IntPtr IUnknown { get; }
    internal IntPtr IDispatch { get; }
    internal static Guid IID_IUnknown { get; }
    internal static Guid IID_IDispatch { get; }
    internal __ComObject(Type t);
    internal __ComObject(IntPtr pItf, ComInteropProxy p);
    internal static __ComObject CreateRCW(Type t);
    private void ReleaseInterfaces();
    protected virtual override void Finalize();
    internal void Initialize(IntPtr pUnk, ComInteropProxy p);
    internal void Initialize(Type t);
    internal static IntPtr CreateIUnknown(Type t);
    private void InitializeApartmentDetails();
    private static Guid GetCLSID(Type t);
    internal IntPtr GetInterfaceInternal(Type t, bool throwException);
    internal IntPtr GetInterface(Type t, bool throwException);
    internal IntPtr GetInterface(Type t);
    private void CheckIUnknown();
    internal IntPtr get_IUnknown();
    internal IntPtr get_IDispatch();
    internal static Guid get_IID_IUnknown();
    internal static Guid get_IID_IDispatch();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int CoCreateInstance(Guid rclsid, IntPtr pUnkOuter, UInt32 dwClsContext, Guid riid, IntPtr& pUnk);
    [CompilerGeneratedAttribute]
private void <Finalize>b__6_0(object state);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.__DTString : ValueType {
    internal ReadOnlySpan`1<char> Value;
    internal int Index;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    private static Char[] WhiteSpaceChecks;
    internal int Length { get; }
    internal CompareInfo CompareInfo { get; }
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal int get_Length();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
internal class System.__Filters : object {
    internal static __Filters Instance;
    private static __Filters();
    internal virtual bool FilterAttribute(MemberInfo m, object filterCriteria);
    internal virtual bool FilterName(MemberInfo m, object filterCriteria);
    internal virtual bool FilterIgnoreCase(MemberInfo m, object filterCriteria);
}
internal static class System.__HResults : object {
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    internal static int E_FAIL;
    internal static int E_POINTER;
    internal static int E_NOTIMPL;
    internal static int REGDB_E_CLASSNOTREG;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_COMEMULATE;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTMEMORY;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SAFEHANDLEMISSINGATTRIBUTE;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SEMAPHOREFULL;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_THREADSTOP;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_UNSUPPORTEDFORMAT;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_HOSTPROTECTION;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int NTE_FAIL;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int DISP_E_OVERFLOW;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int TYPE_E_TYPEMISMATCH;
}
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("05F696DC-2B29-3663-AD8B-C4389CF2A713")]
public interface System._AppDomain {
    public string FriendlyName { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public bool ShadowCopyFiles { get; }
    public string DynamicDirectory { get; }
    public Evidence Evidence { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    [SecurityCriticalAttribute]
public abstract virtual object InitializeLifetimeService();
    [SecurityCriticalAttribute]
public abstract virtual object GetLifetimeService();
    [CompilerGeneratedAttribute]
public abstract virtual void add_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DomainUnload(EventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessExit(EventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void add_TypeResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void remove_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public abstract virtual void add_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public abstract virtual void remove_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public abstract virtual void add_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public abstract virtual void remove_AssemblyResolve(ResolveEventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [SecurityCriticalAttribute]
[CompilerGeneratedAttribute]
public abstract virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    public abstract virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    public abstract virtual ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public abstract virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public abstract virtual Assembly Load(AssemblyName assemblyRef);
    public abstract virtual Assembly Load(string assemblyString);
    public abstract virtual Assembly Load(Byte[] rawAssembly);
    public abstract virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public abstract virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    public abstract virtual Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    public abstract virtual Assembly Load(string assemblyString, Evidence assemblySecurity);
    public abstract virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
    public abstract virtual int ExecuteAssembly(string assemblyFile);
    public abstract virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args);
    public abstract virtual string get_FriendlyName();
    public abstract virtual string get_BaseDirectory();
    public abstract virtual string get_RelativeSearchPath();
    public abstract virtual bool get_ShadowCopyFiles();
    public abstract virtual Assembly[] GetAssemblies();
    [SecurityCriticalAttribute]
public abstract virtual void AppendPrivatePath(string path);
    [SecurityCriticalAttribute]
public abstract virtual void ClearPrivatePath();
    [SecurityCriticalAttribute]
public abstract virtual void SetShadowCopyPath(string s);
    [SecurityCriticalAttribute]
public abstract virtual void ClearShadowCopyPath();
    [SecurityCriticalAttribute]
public abstract virtual void SetCachePath(string s);
    [SecurityCriticalAttribute]
public abstract virtual void SetData(string name, object data);
    public abstract virtual object GetData(string name);
    public abstract virtual void DoCallBack(CrossAppDomainDelegate theDelegate);
    public abstract virtual string get_DynamicDirectory();
    public abstract virtual Evidence get_Evidence();
    [SecurityCriticalAttribute]
public abstract virtual void SetAppDomainPolicy(PolicyLevel domainPolicy);
    public abstract virtual void SetPrincipalPolicy(PrincipalPolicy policy);
    public abstract virtual void SetThreadPrincipal(IPrincipal principal);
}
public class System.AccessViolationException : SystemException {
    private IntPtr _ip;
    private IntPtr _target;
    private int _accessType;
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("False")]
public class System.ActivationContext : object {
    private ApplicationIdentity _appid;
    private ContextForm _form;
    private bool _disposed;
    public ContextForm Form { get; }
    public ApplicationIdentity Identity { get; }
    public Byte[] ApplicationManifestBytes { get; }
    public Byte[] DeploymentManifestBytes { get; }
    private ActivationContext(ApplicationIdentity identity);
    protected virtual override void Finalize();
    public ContextForm get_Form();
    public ApplicationIdentity get_Identity();
    [MonoTODOAttribute("Missing validation")]
public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity);
    [MonoTODOAttribute("Missing validation")]
public static ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, String[] manifestPaths);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [MonoTODOAttribute("Missing serialization support")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public Byte[] get_ApplicationManifestBytes();
    public Byte[] get_DeploymentManifestBytes();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Activator")]
public class System.Activator : object {
    internal static int LookupMask;
    internal static BindingFlags ConLookup;
    internal static BindingFlags ConstructorDefault;
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type, bool nonPublic);
    internal static object CreateInstance(Type type, bool nonPublic, bool wrapExceptions);
    public static T CreateInstance();
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
internal static ObjectHandle CreateInstance(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo, StackCrawlMark& stackMark);
    [ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    private static ObjectHandle CreateInstanceFromInternal(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName);
    [ObsoleteAttribute("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[SecurityCriticalAttribute]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecurityCriticalAttribute]
public static ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [SecurityCriticalAttribute]
public static object GetObject(Type type, string url);
    [SecurityCriticalAttribute]
public static object GetObject(Type type, string url, object state);
    [ConditionalAttribute("_DEBUG")]
private static void Log(bool test, string title, string success, string failure);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Activator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(ActivationContext activationContext);
    [SecuritySafeCriticalAttribute]
public static ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData);
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    private int InnerExceptionCount { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    private AggregateException(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    private int get_InnerExceptionCount();
}
public static class System.AppContext : object {
    private static Dictionary`2<string, SwitchValueState> s_switchMap;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultsInitialized;
    public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    private static AppContext();
    public static string get_BaseDirectory();
    public static string get_TargetFrameworkName();
    public static object GetData(string name);
    private static void InitializeDefaultSwitchValues();
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static void SetSwitch(string switchName, bool isEnabled);
    internal static void DefineSwitchDefault(string switchName, bool isEnabled);
    internal static void DefineSwitchOverride(string switchName, bool isEnabled);
}
internal static class System.AppContextDefaultValues : object {
    internal static string SwitchNoAsyncCurrentCulture;
    internal static string SwitchEnforceJapaneseEraYearRanges;
    internal static string SwitchFormatJapaneseFirstYearAsANumber;
    internal static string SwitchEnforceLegacyJapaneseDateParsing;
    internal static string SwitchThrowExceptionIfDisposedCancellationTokenSource;
    internal static string SwitchPreserveEventListnerObjectIdentity;
    internal static string SwitchUseLegacyPathHandling;
    internal static string SwitchBlockLongPaths;
    internal static string SwitchDoNotAddrOfCspParentWindowHandle;
    internal static string SwitchSetActorAsReferenceWhenCopyingClaimsIdentity;
    private static AppContextDefaultValues();
    public static void PopulateDefaultValues();
    public static bool TryGetSwitchOverride(string switchName, Boolean& overrideValue);
}
internal static class System.AppContextSwitches : object {
    private static int _noAsyncCurrentCulture;
    private static int _enforceJapaneseEraYearRanges;
    private static int _formatJapaneseFirstYearAsANumber;
    private static int _enforceLegacyJapaneseDateParsing;
    private static int _throwExceptionIfDisposedCancellationTokenSource;
    private static int _preserveEventListnerObjectIdentity;
    private static int _useLegacyPathHandling;
    private static int _blockLongPaths;
    private static int _cloneActor;
    private static int _doNotAddrOfCspParentWindowHandle;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    public static bool NoAsyncCurrentCulture { get; }
    public static bool EnforceJapaneseEraYearRanges { get; }
    public static bool FormatJapaneseFirstYearAsANumber { get; }
    public static bool EnforceLegacyJapaneseDateParsing { get; }
    public static bool ThrowExceptionIfDisposedCancellationTokenSource { get; }
    public static bool PreserveEventListnerObjectIdentity { get; }
    public static bool UseLegacyPathHandling { get; }
    public static bool BlockLongPaths { get; }
    public static bool SetActorAsReferenceWhenCopyingClaimsIdentity { get; }
    public static bool DoNotAddrOfCspParentWindowHandle { get; }
    private static bool DisableCaching { get; private set; }
    private static AppContextSwitches();
    public static bool get_NoAsyncCurrentCulture();
    public static bool get_EnforceJapaneseEraYearRanges();
    public static bool get_FormatJapaneseFirstYearAsANumber();
    public static bool get_EnforceLegacyJapaneseDateParsing();
    public static bool get_ThrowExceptionIfDisposedCancellationTokenSource();
    public static bool get_PreserveEventListnerObjectIdentity();
    public static bool get_UseLegacyPathHandling();
    public static bool get_BlockLongPaths();
    public static bool get_SetActorAsReferenceWhenCopyingClaimsIdentity();
    public static bool get_DoNotAddrOfCspParentWindowHandle();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System._AppDomain")]
[ComVisibleAttribute("True")]
public class System.AppDomain : MarshalByRefObject {
    private IntPtr _mono_app_domain;
    private static string _process_guid;
    [ThreadStaticAttribute]
private static Dictionary`2<string, object> type_resolve_in_progress;
    [ThreadStaticAttribute]
private static Dictionary`2<string, object> assembly_resolve_in_progress;
    [ThreadStaticAttribute]
private static Dictionary`2<string, object> assembly_resolve_in_progress_refonly;
    private Evidence _evidence;
    private PermissionSet _granted;
    private PrincipalPolicy _principalPolicy;
    [ThreadStaticAttribute]
private static IPrincipal _principal;
    private static AppDomain default_domain;
    [CompilerGeneratedAttribute]
private AssemblyLoadEventHandler AssemblyLoad;
    [CompilerGeneratedAttribute]
private ResolveEventHandler AssemblyResolve;
    [CompilerGeneratedAttribute]
private EventHandler DomainUnload;
    [CompilerGeneratedAttribute]
private EventHandler ProcessExit;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ResourceResolve;
    [CompilerGeneratedAttribute]
private ResolveEventHandler TypeResolve;
    [CompilerGeneratedAttribute]
private UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException;
    private AppDomainManager _domain_manager;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ReflectionOnlyAssemblyResolve;
    private ActivationContext _activation;
    private ApplicationIdentity _applicationIdentity;
    private List`1<string> compatibility_switch;
    private AppDomainSetup SetupInformationNoCopy { get; }
    public AppDomainSetup SetupInformation { get; }
    [MonoTODOAttribute]
public ApplicationTrust ApplicationTrust { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public string DynamicDirectory { get; }
    public bool ShadowCopyFiles { get; }
    public string FriendlyName { get; }
    public Evidence Evidence { get; }
    internal IPrincipal DefaultPrincipal { get; }
    internal PermissionSet GrantedPermissionSet { get; }
    public PermissionSet PermissionSet { get; }
    public static AppDomain CurrentDomain { get; }
    internal static AppDomain DefaultDomain { get; }
    [MonoTODOAttribute]
public bool IsHomogenous { get; }
    [MonoTODOAttribute]
public bool IsFullyTrusted { get; }
    public AppDomainManager DomainManager { get; }
    public ActivationContext ActivationContext { get; }
    public ApplicationIdentity ApplicationIdentity { get; }
    public int Id { get; }
    [MonoTODOAttribute("Currently always returns false")]
public static bool MonitoringIsEnabled { get; public set; }
    [MonoTODOAttribute]
public long MonitoringSurvivedMemorySize { get; }
    [MonoTODOAttribute]
public static long MonitoringSurvivedProcessMemorySize { get; }
    [MonoTODOAttribute]
public long MonitoringTotalAllocatedMemorySize { get; }
    [MonoTODOAttribute]
public TimeSpan MonitoringTotalProcessorTime { get; }
    internal static bool IsAppXModel();
    internal static bool IsAppXDesignMode();
    internal static void CheckReflectionOnlyLoadSupported();
    internal static void CheckLoadFromSupported();
    private AppDomainSetup getSetup();
    private AppDomainSetup get_SetupInformationNoCopy();
    public AppDomainSetup get_SetupInformation();
    public ApplicationTrust get_ApplicationTrust();
    public sealed virtual string get_BaseDirectory();
    public sealed virtual string get_RelativeSearchPath();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_DynamicDirectory();
    public sealed virtual bool get_ShadowCopyFiles();
    private string getFriendlyName();
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_FriendlyName();
    [SecuritySafeCriticalAttribute]
public sealed virtual Evidence get_Evidence();
    internal IPrincipal get_DefaultPrincipal();
    internal PermissionSet get_GrantedPermissionSet();
    public PermissionSet get_PermissionSet();
    private static AppDomain getCurDomain();
    public static AppDomain get_CurrentDomain();
    private static AppDomain getRootDomain();
    internal static AppDomain get_DefaultDomain();
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")]
[SecurityCriticalAttribute]
public sealed virtual void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")]
[SecurityCriticalAttribute]
public sealed virtual void ClearPrivatePath();
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Use AppDomainSetup.ShadowCopyDirectories")]
public sealed virtual void ClearShadowCopyPath();
    public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
    public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName);
    internal ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName);
    internal ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName);
    public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public sealed virtual ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public sealed virtual ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName);
    public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes);
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence);
    [SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized);
    [ObsoleteAttribute("Declarative security for assembly level is no longer enforced")]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    [MonoLimitationAttribute("The argument securityContextSource is ignored")]
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes, SecurityContextSource securityContextSource);
    internal AssemblyBuilder DefineInternalDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public sealed virtual void DoCallBack(CrossAppDomainDelegate callBackDelegate);
    public sealed virtual int ExecuteAssembly(string assemblyFile);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public sealed virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public sealed virtual int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    private int ExecuteAssemblyInternal(Assembly a, String[] args);
    private int ExecuteAssembly(Assembly a, String[] args);
    private Assembly[] GetAssemblies(bool refOnly);
    public sealed virtual Assembly[] GetAssemblies();
    [SecuritySafeCriticalAttribute]
public sealed virtual object GetData(string name);
    public sealed virtual Type GetType();
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    internal Assembly LoadAssembly(string assemblyRef, Evidence securityEvidence, bool refOnly, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(AssemblyName assemblyRef);
    internal Assembly LoadSatellite(AssemblyName assemblyRef, bool throwOnError, StackCrawlMark& stackMark);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
[SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(string assemblyString);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public sealed virtual Assembly Load(string assemblyString, Evidence assemblySecurity);
    internal Assembly Load(string assemblyString, Evidence assemblySecurity, bool refonly, StackCrawlMark& stackMark);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(Byte[] rawAssembly);
    [SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    internal Assembly LoadAssemblyRaw(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
[SecuritySafeCriticalAttribute]
public sealed virtual Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    internal Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly);
    [ObsoleteAttribute("AppDomain policy levels are obsolete")]
[SecurityCriticalAttribute]
public sealed virtual void SetAppDomainPolicy(PolicyLevel domainPolicy);
    [ObsoleteAttribute("Use AppDomainSetup.SetCachePath")]
[SecurityCriticalAttribute]
public sealed virtual void SetCachePath(string path);
    [SecuritySafeCriticalAttribute]
public sealed virtual void SetPrincipalPolicy(PrincipalPolicy policy);
    [ObsoleteAttribute("Use AppDomainSetup.ShadowCopyFiles")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("Use AppDomainSetup.ShadowCopyDirectories")]
[SecurityCriticalAttribute]
public sealed virtual void SetShadowCopyPath(string path);
    [SecuritySafeCriticalAttribute]
public sealed virtual void SetThreadPrincipal(IPrincipal principal);
    private static AppDomain InternalSetDomainByID(int domain_id);
    private static AppDomain InternalSetDomain(AppDomain context);
    internal static void InternalPushDomainRef(AppDomain domain);
    internal static void InternalPushDomainRefByID(int domain_id);
    internal static void InternalPopDomainRef();
    internal static Context InternalSetContext(Context context);
    internal static Context InternalGetContext();
    internal static Context InternalGetDefaultContext();
    internal static string InternalGetProcessGuid(string newguid);
    internal static object InvokeInDomain(AppDomain domain, MethodInfo method, object obj, Object[] args);
    internal static object InvokeInDomainByID(int domain_id, MethodInfo method, object obj, Object[] args);
    internal static string GetProcessGuid();
    public static AppDomain CreateDomain(string friendlyName);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo);
    private static AppDomain createDomain(string friendlyName, AppDomainSetup info);
    [MonoLimitationAttribute("Currently it does not allow the setup in the other domain")]
public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, StrongName[] fullTrustAssemblies);
    private static AppDomainSetup CreateDomainSetup(string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    private static bool InternalIsFinalizingForUnload(int domain_id);
    public bool IsFinalizingForUnload();
    private static void InternalUnload(int domain_id);
    private int getDomainID();
    [ReliabilityContractAttribute("1", "1")]
public static void Unload(AppDomain domain);
    [SecurityCriticalAttribute]
public sealed virtual void SetData(string name, object data);
    [MonoLimitationAttribute("The permission field is ignored")]
public void SetData(string name, object data, IPermission permission);
    [ObsoleteAttribute("Use AppDomainSetup.DynamicBase")]
public void SetDynamicBase(string path);
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")]
public static int GetCurrentThreadId();
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    private static void ValidateAssemblyName(string name);
    private void DoAssemblyLoad(Assembly assembly);
    private Assembly DoAssemblyResolve(string name, Assembly requestingAssembly, bool refonly);
    internal Assembly DoTypeBuilderResolve(TypeBuilder tb);
    internal Assembly DoTypeResolve(string name);
    internal Assembly DoResourceResolve(string name, Assembly requesting);
    private void DoDomainUnload();
    internal void DoUnhandledException(Exception e);
    internal void DoUnhandledException(UnhandledExceptionEventArgs args);
    internal Byte[] GetMarshalledDomainObjRef();
    internal void ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg, Byte[]& arrResponse, CADMethodReturnMessage& cadMrm);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public bool get_IsHomogenous();
    public bool get_IsFullyTrusted();
    public AppDomainManager get_DomainManager();
    [CompilerGeneratedAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public ActivationContext get_ActivationContext();
    public ApplicationIdentity get_ApplicationIdentity();
    [ReliabilityContractAttribute("3", "2")]
public int get_Id();
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("This routine only returns the parameter currently")]
public string ApplyPolicy(string assemblyName);
    public static AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, String[] adInitArgs);
    public int ExecuteAssemblyByName(string assemblyName);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, String[] args);
    [ObsoleteAttribute("Use an overload that does not take an Evidence parameter")]
public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, String[] args);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public bool IsDefaultAppDomain();
    public Assembly[] ReflectionOnlyGetAssemblies();
    private sealed virtual override void System._AppDomain.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System._AppDomain.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System._AppDomain.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System._AppDomain.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    internal void SetCompatibilitySwitch(string value);
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
}
[ComVisibleAttribute("True")]
public class System.AppDomainInitializer : MulticastDelegate {
    public AppDomainInitializer(object object, IntPtr method);
    public virtual void Invoke(String[] args);
    public virtual IAsyncResult BeginInvoke(String[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.AppDomainManager : MarshalByRefObject {
    private ApplicationActivator _activator;
    private AppDomainManagerInitializationOptions _flags;
    public ApplicationActivator ApplicationActivator { get; }
    public Assembly EntryAssembly { get; }
    [MonoTODOAttribute]
public HostExecutionContextManager HostExecutionContextManager { get; }
    public HostSecurityManager HostSecurityManager { get; }
    public AppDomainManagerInitializationOptions InitializationFlags { get; public set; }
    public virtual ApplicationActivator get_ApplicationActivator();
    public virtual Assembly get_EntryAssembly();
    public virtual HostExecutionContextManager get_HostExecutionContextManager();
    public virtual HostSecurityManager get_HostSecurityManager();
    public AppDomainManagerInitializationOptions get_InitializationFlags();
    public void set_InitializationFlags(AppDomainManagerInitializationOptions value);
    public virtual AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
    public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
    public virtual bool CheckSecuritySettings(SecurityState state);
    protected static AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.AppDomainManagerInitializationOptions : Enum {
    public int value__;
    public static AppDomainManagerInitializationOptions None;
    public static AppDomainManagerInitializationOptions RegisterWithHost;
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.AppDomainSetup : object {
    private string application_base;
    private string application_name;
    private string cache_path;
    private string configuration_file;
    private string dynamic_base;
    private string license_file;
    private string private_bin_path;
    private string private_bin_path_probe;
    private string shadow_copy_directories;
    private string shadow_copy_files;
    private bool publisher_policy;
    private bool path_changed;
    private LoaderOptimization loader_optimization;
    private bool disallow_binding_redirects;
    private bool disallow_code_downloads;
    private ActivationArguments _activationArguments;
    private AppDomainInitializer domain_initializer;
    private ApplicationTrust application_trust;
    private String[] domain_initializer_args;
    private bool disallow_appbase_probe;
    private Byte[] configuration_bytes;
    private Byte[] serialized_non_primitives;
    private string manager_assembly;
    private string manager_type;
    private String[] partial_visible_assemblies;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkName>k__BackingField;
    public string ApplicationBase { get; public set; }
    public string ApplicationName { get; public set; }
    public string CachePath { get; public set; }
    public string ConfigurationFile { get; public set; }
    public bool DisallowPublisherPolicy { get; public set; }
    public string DynamicBase { get; public set; }
    public string LicenseFile { get; public set; }
    [MonoLimitationAttribute("In Mono this is controlled by the --share-code flag")]
public LoaderOptimization LoaderOptimization { get; public set; }
    public string AppDomainManagerAssembly { get; public set; }
    public string AppDomainManagerType { get; public set; }
    public String[] PartialTrustVisibleAssemblies { get; public set; }
    public string PrivateBinPath { get; public set; }
    public string PrivateBinPathProbe { get; public set; }
    public string ShadowCopyDirectories { get; public set; }
    public string ShadowCopyFiles { get; public set; }
    public bool DisallowBindingRedirects { get; public set; }
    public bool DisallowCodeDownload { get; public set; }
    public string TargetFrameworkName { get; public set; }
    public ActivationArguments ActivationArguments { get; public set; }
    [MonoLimitationAttribute("it needs to be invoked within the created domain")]
public AppDomainInitializer AppDomainInitializer { get; public set; }
    [MonoLimitationAttribute("it needs to be used to invoke the initializer within the created domain")]
public String[] AppDomainInitializerArguments { get; public set; }
    [MonoNotSupportedAttribute("This property exists but not considered.")]
public ApplicationTrust ApplicationTrust { get; public set; }
    [MonoNotSupportedAttribute("This property exists but not considered.")]
public bool DisallowApplicationBaseProbing { get; public set; }
    public bool SandboxInterop { get; public set; }
    internal AppDomainSetup(AppDomainSetup setup);
    public AppDomainSetup(ActivationArguments activationArguments);
    public AppDomainSetup(ActivationContext activationContext);
    private static string GetAppBase(string appBase);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ApplicationBase();
    public sealed virtual void set_ApplicationBase(string value);
    public sealed virtual string get_ApplicationName();
    public sealed virtual void set_ApplicationName(string value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_CachePath();
    public sealed virtual void set_CachePath(string value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ConfigurationFile();
    public sealed virtual void set_ConfigurationFile(string value);
    public bool get_DisallowPublisherPolicy();
    public void set_DisallowPublisherPolicy(bool value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_DynamicBase();
    [SecuritySafeCriticalAttribute]
public sealed virtual void set_DynamicBase(string value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_LicenseFile();
    public sealed virtual void set_LicenseFile(string value);
    public LoaderOptimization get_LoaderOptimization();
    public void set_LoaderOptimization(LoaderOptimization value);
    public string get_AppDomainManagerAssembly();
    public void set_AppDomainManagerAssembly(string value);
    public string get_AppDomainManagerType();
    public void set_AppDomainManagerType(string value);
    public String[] get_PartialTrustVisibleAssemblies();
    public void set_PartialTrustVisibleAssemblies(String[] value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_PrivateBinPath();
    public sealed virtual void set_PrivateBinPath(string value);
    public sealed virtual string get_PrivateBinPathProbe();
    public sealed virtual void set_PrivateBinPathProbe(string value);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_ShadowCopyDirectories();
    public sealed virtual void set_ShadowCopyDirectories(string value);
    public sealed virtual string get_ShadowCopyFiles();
    public sealed virtual void set_ShadowCopyFiles(string value);
    public bool get_DisallowBindingRedirects();
    public void set_DisallowBindingRedirects(bool value);
    public bool get_DisallowCodeDownload();
    public void set_DisallowCodeDownload(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkName(string value);
    public ActivationArguments get_ActivationArguments();
    public void set_ActivationArguments(ActivationArguments value);
    public AppDomainInitializer get_AppDomainInitializer();
    public void set_AppDomainInitializer(AppDomainInitializer value);
    public String[] get_AppDomainInitializerArguments();
    public void set_AppDomainInitializerArguments(String[] value);
    public ApplicationTrust get_ApplicationTrust();
    public void set_ApplicationTrust(ApplicationTrust value);
    public bool get_DisallowApplicationBaseProbing();
    public void set_DisallowApplicationBaseProbing(bool value);
    [MonoNotSupportedAttribute("This method exists but not considered.")]
public Byte[] GetConfigurationBytes();
    [MonoNotSupportedAttribute("This method exists but not considered.")]
public void SetConfigurationBytes(Byte[] value);
    private void DeserializeNonPrimitives();
    internal void SerializeNonPrimitives();
    [MonoTODOAttribute("not implemented, does not throw because it's used in testing moonlight")]
public void SetCompatibilitySwitches(IEnumerable`1<string> switches);
    public bool get_SandboxInterop();
    public void set_SandboxInterop(bool value);
    [SecurityCriticalAttribute]
public void SetNativeFunction(string functionName, int functionVersion, IntPtr functionPointer);
}
public class System.AppDomainUnloadedException : SystemException {
    internal static int COR_E_APPDOMAINUNLOADED;
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
public class System.ApplicationId : object {
    private Byte[] _publicKeyToken;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Culture { get; }
    public string Name { get; }
    public string ProcessorArchitecture { get; }
    public Version Version { get; }
    public Byte[] PublicKeyToken { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public Byte[] get_PublicKeyToken();
    public ApplicationId Copy();
    public virtual string ToString();
    private static char HexDigit(int num);
    private static string EncodeHexString(Byte[] sArray);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("False")]
public class System.ApplicationIdentity : object {
    private string _fullName;
    private string _codeBase;
    public string CodeBase { get; }
    public string FullName { get; }
    public ApplicationIdentity(string applicationIdentityFullName);
    public string get_CodeBase();
    public string get_FullName();
    public virtual string ToString();
    [MonoTODOAttribute("Missing serialization")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArgIterator : ValueType {
    private IntPtr sig;
    private IntPtr args;
    private int next_arg;
    private int num_args;
    public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    private void Setup(IntPtr argsp, IntPtr start);
    public void End();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    private void IntGetNextArg(Void* res);
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    private void IntGetNextArgWithType(Void* res, IntPtr rth);
    public RuntimeTypeHandle GetNextArgType();
    private IntPtr IntGetNextArgType();
    public int GetRemainingCount();
}
public class System.ArgumentException : SystemException {
    private string _paramName;
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
}
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentOutOfRangeException : ArgumentException {
    private object _actualValue;
    public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual object get_ActualValue();
}
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Array : object {
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public long LongLength { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Length { get; }
    public int Rank { get; }
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static void Resize(T[]& array, int newSize);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    internal static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public void CopyTo(Array array, long index);
    public static void ForEach(T[] array, Action`1<T> action);
    public long get_LongLength();
    public long GetLongLength(int dimension);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    private static int GetMedian(int low, int hi);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    public static void Sort(Array array);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public sealed virtual IEnumerator GetEnumerator();
    internal int InternalArray__ICollection_get_Count();
    internal bool InternalArray__ICollection_get_IsReadOnly();
    internal Byte& GetRawSzArrayData();
    internal IEnumerator`1<T> InternalArray__IEnumerable_GetEnumerator();
    internal void InternalArray__ICollection_Clear();
    internal void InternalArray__ICollection_Add(T item);
    internal bool InternalArray__ICollection_Remove(T item);
    internal bool InternalArray__ICollection_Contains(T item);
    internal void InternalArray__ICollection_CopyTo(T[] array, int arrayIndex);
    internal T InternalArray__IReadOnlyList_get_Item(int index);
    internal int InternalArray__IReadOnlyCollection_get_Count();
    internal void InternalArray__Insert(int index, T item);
    internal void InternalArray__RemoveAt(int index);
    internal int InternalArray__IndexOf(T item);
    internal T InternalArray__get_Item(int index);
    internal void InternalArray__set_Item(int index, T item);
    private static void GetGenericValue_icall(Array& self, int pos, T& value);
    private static void SetGenericValue_icall(Array& self, int pos, T& value);
    internal void GetGenericValueImpl(int pos, T& value);
    internal void SetGenericValueImpl(int pos, T& value);
    [ReliabilityContractAttribute("3", "2")]
public int get_Length();
    [ReliabilityContractAttribute("3", "2")]
public int get_Rank();
    private int GetRank();
    public int GetLength(int dimension);
    [ReliabilityContractAttribute("3", "2")]
public int GetLowerBound(int dimension);
    public object GetValue(Int32[] indices);
    public void SetValue(object value, Int32[] indices);
    internal object GetValueImpl(int pos);
    internal void SetValueImpl(object value, int pos);
    internal static bool FastCopy(Array source, int source_idx, Array dest, int dest_idx, int length);
    internal static Array CreateInstanceImpl(Type elementType, Int32[] lengths, Int32[] bounds);
    [ReliabilityContractAttribute("3", "2")]
public int GetUpperBound(int dimension);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    internal static Array UnsafeCreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    internal static Array UnsafeCreateInstance(Type elementType, int length1, int length2);
    internal static Array UnsafeCreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    [ReliabilityContractAttribute("3", "2")]
public static void Clear(Array array, int index, int length);
    private static void ClearInternal(Array a, int index, int count);
    [ReliabilityContractAttribute("2", "1")]
public static void Copy(Array sourceArray, Array destinationArray, int length);
    [ReliabilityContractAttribute("2", "1")]
public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    private static ArrayTypeMismatchException CreateArrayTypeMismatchException();
    private static bool CanAssignArrayElement(Type source, Type target);
    [ReliabilityContractAttribute("3", "2")]
public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static T[] Empty();
    public void Initialize();
    private static int IndexOfImpl(T[] array, T value, int startIndex, int count);
    private static int LastIndexOfImpl(T[] array, T value, int startIndex, int count);
    private static void SortImpl(Array keys, Array items, int index, int length, IComparer comparer);
    internal static T UnsafeLoad(T[] array, int index);
    internal static void UnsafeStore(T[] array, int index, T value);
    internal static R UnsafeMov(S instance);
}
internal static class System.Array_ReferenceSources : object {
    internal static int MaxArrayLength;
    internal static int MaxByteArrayLength;
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    public static ArraySegment`1<T> Empty { get; }
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
internal class System.ArraySpec : object {
    private int dimensions;
    private bool bound;
    public int Rank { get; }
    public bool IsBound { get; }
    internal ArraySpec(int dimensions, bool bound);
    public sealed virtual Type Resolve(Type type);
    public sealed virtual StringBuilder Append(StringBuilder sb);
    public virtual string ToString();
    public int get_Rank();
    public bool get_IsBound();
}
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Attribute")]
[ComVisibleAttribute("True")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit);
    private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit);
    private static Attribute[] InternalParamGetCustomAttributes(ParameterInfo parameter, Type attributeType, bool inherit);
    private static bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit);
    private static bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit);
    private static bool InternalParamIsDefined(ParameterInfo parameter, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public virtual object get_TypeId();
    public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Attribute.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    public virtual string ToString();
    public string get_FusionLog();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
internal static class System.BCLDebug : object {
    [ConditionalAttribute("_DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("_DEBUG")]
internal static void Correctness(bool expr, string msg);
    [ConditionalAttribute("_DEBUG")]
public static void Log(string message);
    [ConditionalAttribute("_DEBUG")]
public static void Log(string switchName, string message);
    [ConditionalAttribute("_DEBUG")]
public static void Log(string switchName, BCLDebugLogLevel level, Object[] messages);
    [ConditionalAttribute("_DEBUG")]
internal static void Perf(bool expr, string msg);
    [ConditionalAttribute("_LOGGING")]
public static void Trace(string switchName, Object[] messages);
    internal static bool CheckEnabled(string switchName);
}
internal enum System.BCLDebugLogLevel : Enum {
    public int value__;
    public static BCLDebugLogLevel Trace;
    public static BCLDebugLogLevel Status;
    public static BCLDebugLogLevel Warning;
    public static BCLDebugLogLevel Error;
    public static BCLDebugLogLevel Panic;
}
public static class System.BitConverter : object {
    [IntrinsicAttribute]
public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static Byte[] GetBytes(char value);
    public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static Byte[] GetBytes(short value);
    public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static Byte[] GetBytes(int value);
    public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static Byte[] GetBytes(long value);
    public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    public static Byte[] GetBytes(float value);
    public static bool TryWriteBytes(Span`1<byte> destination, float value);
    public static Byte[] GetBytes(double value);
    public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static char ToChar(Byte[] value, int startIndex);
    public static char ToChar(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    public static long ToInt64(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static long DoubleToInt64Bits(double value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static float Int32BitsToSingle(int value);
}
[IsReadOnlyAttribute]
public class System.Boolean : ValueType {
    private bool m_value;
    internal static int True;
    internal static int False;
    internal static string TrueLiteral;
    internal static string FalseLiteral;
    public static string TrueString;
    public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    public static bool Parse(string value);
    public static bool Parse(ReadOnlySpan`1<char> value);
    public static bool TryParse(string value, Boolean& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    private static ReadOnlySpan`1<char> TrimWhiteSpaceAndNull(ReadOnlySpan`1<char> value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.BRECORD : ValueType {
    private IntPtr pvRecord;
    private IntPtr pRecInfo;
}
[ComVisibleAttribute("True")]
public static class System.Buffer : object {
    internal static bool InternalBlockCopy(Array src, int srcOffsetBytes, Array dst, int dstOffsetBytes, int byteCount);
    [SecurityCriticalAttribute]
internal static int IndexOfByte(Byte* src, byte value, int index, int count);
    private static int _ByteLength(Array array);
    [SecurityCriticalAttribute]
internal static void ZeroMemory(Byte* src, long len);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal static void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len);
    internal static void InternalMemcpy(Byte* dest, Byte* src, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    public static void SetByte(Array array, int index, byte value);
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    internal static void memcpy4(Byte* dest, Byte* src, int size);
    internal static void memcpy2(Byte* dest, Byte* src, int size);
    private static void memcpy1(Byte* dest, Byte* src, int size);
    internal static void Memcpy(Byte* dest, Byte* src, int len);
    internal static void Memmove(Byte* dest, Byte* src, UInt32 len);
    internal static void Memmove(T& destination, T& source, ulong elementCount);
}
public class System.Buffers.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private int _index;
    private static int DefaultInitialBufferSize;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
internal class System.Buffers.ArrayMemoryPool`1 : MemoryPool`1<T> {
    private static int s_maxBufferSize;
    public int MaxBufferSize { get; }
    public sealed virtual int get_MaxBufferSize();
    public sealed virtual IMemoryOwner`1<T> Rent(int minimumBufferSize);
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Buffers.ArrayPool`1 : object {
    [CompilerGeneratedAttribute]
private static ArrayPool`1<T> <Shared>k__BackingField;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    [CompilerGeneratedAttribute]
public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
    [EventAttribute("4")]
internal void BufferTrimmed(int bufferId, int bufferSize, int poolId);
    [EventAttribute("5")]
internal void BufferTrimPoll(int milliseconds, int pressure);
}
public static class System.Buffers.Binary.BinaryPrimitives : object {
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    public static short ReverseEndianness(short value);
    public static int ReverseEndianness(int value);
    public static long ReverseEndianness(long value);
    public static byte ReverseEndianness(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ReverseEndianness(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
[ExtensionAttribute]
public static class System.Buffers.BuffersExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    private static Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    private static void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination);
    [ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
    private static void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination);
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxNumberOfArraysPerBucket;
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
public interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
public interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class System.Buffers.MemoryPool`1 : object {
    private static MemoryPool`1<T> s_shared;
    public static MemoryPool`1<T> Shared { get; }
    public int MaxBufferSize { get; }
    private static MemoryPool`1();
    public static MemoryPool`1<T> get_Shared();
    public abstract virtual IMemoryOwner`1<T> Rent(int minBufferSize);
    public abstract virtual int get_MaxBufferSize();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
internal static class System.Buffers.ReadOnlySequence : object {
    public static int FlagBitMask;
    public static int IndexBitMask;
    public static int SegmentStartMask;
    public static int SegmentEndMask;
    public static int ArrayStartMask;
    public static int ArrayEndMask;
    public static int MemoryManagerStartMask;
    public static int MemoryManagerEndMask;
    public static int StringStartMask;
    public static int StringEndMask;
    public static int SegmentToSequenceStart(int startIndex);
    public static int SegmentToSequenceEnd(int endIndex);
    public static int ArrayToSequenceStart(int startIndex);
    public static int ArrayToSequenceEnd(int endIndex);
    public static int MemoryManagerToSequenceStart(int startIndex);
    public static int MemoryManagerToSequenceEnd(int endIndex);
    public static int StringToSequenceStart(int startIndex);
    public static int StringToSequenceEnd(int endIndex);
}
[DebuggerTypeProxyAttribute("System.Buffers.ReadOnlySequenceDebugView`1")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.Buffers.ReadOnlySequence`1 : ValueType {
    private object _startObject;
    private object _endObject;
    private int _startInteger;
    private int _endInteger;
    public static ReadOnlySequence`1<T> Empty;
    public long Length { get; }
    public bool IsEmpty { get; }
    public bool IsSingleSegment { get; }
    public ReadOnlyMemory`1<T> First { get; }
    public ReadOnlySpan`1<T> FirstSpan { get; }
    public SequencePosition Start { get; }
    public SequencePosition End { get; }
    private ReadOnlySequence`1(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags);
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    private static ReadOnlySequence`1();
    public long get_Length();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public ReadOnlyMemory`1<T> get_First();
    public ReadOnlySpan`1<T> get_FirstSpan();
    public SequencePosition get_Start();
    public SequencePosition get_End();
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(long start);
    public virtual string ToString();
    public Enumerator<T> GetEnumerator();
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
    internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next);
    private ReadOnlyMemory`1<T> GetFirstBuffer();
    private ReadOnlyMemory`1<T> GetFirstBufferSlow(object startObject, bool isMultiSegment);
    private ReadOnlySpan`1<T> GetFirstSpan();
    private ReadOnlySpan`1<T> GetFirstSpanSlow(object startObject, bool isMultiSegment);
    internal SequencePosition Seek(long offset, ExceptionArgument exceptionArgument);
    private SequencePosition Seek(SequencePosition& start, long offset);
    private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, ExceptionArgument argument);
    private void BoundsCheck(SequencePosition& position, bool positionIsNotNull);
    private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject);
    private static SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length);
    private SequenceType<T> GetSequenceType();
    private static int GetIndex(SequencePosition& position);
    private static int GetIndex(int Integer);
    private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end);
    private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start);
    private long GetLength();
    internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    internal bool TryGetArray(ArraySegment`1& segment);
    internal bool TryGetString(String& text, Int32& start, Int32& length);
    private static bool InRange(UInt32 value, UInt32 start, UInt32 end);
    private static bool InRange(ulong value, ulong start, ulong end);
    internal void GetFirstSpan(ReadOnlySpan`1& first, SequencePosition& next);
    private static ReadOnlySpan`1<T> GetFirstSpanSlow(object startObject, int startIndex, int endIndex, bool hasMultipleSegments);
}
internal class System.Buffers.ReadOnlySequenceDebugView`1 : object {
    private T[] _array;
    private ReadOnlySequenceDebugViewSegments<T> _segments;
    public ReadOnlySequenceDebugViewSegments<T> BufferSegments { get; }
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ReadOnlySequenceDebugView`1(ReadOnlySequence`1<T> sequence);
    public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments();
    public T[] get_Items();
}
public abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<T> <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequenceSegment`1<T> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RunningIndex>k__BackingField;
    public ReadOnlyMemory`1<T> Memory { get; protected set; }
    public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    public long RunningIndex { get; protected set; }
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<T> get_Memory();
    [CompilerGeneratedAttribute]
protected void set_Memory(ReadOnlyMemory`1<T> value);
    [CompilerGeneratedAttribute]
public ReadOnlySequenceSegment`1<T> get_Next();
    [CompilerGeneratedAttribute]
protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    [CompilerGeneratedAttribute]
public long get_RunningIndex();
    [CompilerGeneratedAttribute]
protected void set_RunningIndex(long value);
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.Buffers.SequenceReader`1 : ValueType {
    private SequencePosition _currentPosition;
    private SequencePosition _nextPosition;
    private bool _moreData;
    private long _length;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<T> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1<T> sequence);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter);
    private bool TryReadToInternal(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter, int skip);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    private bool TryReadToAnySlow(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    private bool TryReadToAnyInternal(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter, int skip);
    public bool TryReadTo(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiter, bool advancePastDelimiter);
    public bool TryAdvanceTo(T delimiter, bool advancePastDelimiter);
    public bool TryAdvanceToAny(ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public long AdvancePast(T value);
    public long AdvancePastAny(ReadOnlySpan`1<T> values);
    public long AdvancePastAny(T value0, T value1, T value2, T value3);
    public long AdvancePastAny(T value0, T value1, T value2);
    public long AdvancePastAny(T value0, T value1);
    public bool IsNext(T next, bool advancePast);
    public bool IsNext(ReadOnlySpan`1<T> next, bool advancePast);
    private bool IsNextSlow(ReadOnlySpan`1<T> next, bool advancePast);
    [IsReadOnlyAttribute]
public bool get_End();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ReadOnlySequence`1<T> get_Sequence();
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_UnreadSpan();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    [IsReadOnlyAttribute]
public long get_Remaining();
    [IsReadOnlyAttribute]
public long get_Length();
    [IsReadOnlyAttribute]
public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    private void AdvanceToNextSpan(long count);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<T> destination);
    [IsReadOnlyAttribute]
internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
public static class System.Buffers.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Buffers.StandardFormat : ValueType {
    public static byte NoPrecision;
    public static byte MaxPrecision;
    private byte _format;
    private byte _precision;
    internal static int FormatStringLength;
    public char Symbol { get; }
    public byte Precision { get; }
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    public static StandardFormat Parse(string format);
    public static bool TryParse(ReadOnlySpan`1<char> format, StandardFormat& result);
    private static bool ParseHelper(ReadOnlySpan`1<char> format, StandardFormat& standardFormat, bool throws);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    public virtual string ToString();
    internal int Format(Span`1<char> destination);
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
public static class System.Buffers.Text.Base64 : object {
    private static SByte[] s_decodingMap;
    private static Byte[] s_encodingMap;
    private static byte EncodingPad;
    private static int MaximumEncodeLength;
    private static Base64();
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    private static int Decode(Byte& encodedBytes, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxEncodedToUtf8Length(int length);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    private static int Encode(Byte& threeBytes, Byte& encodingMap);
    private static int EncodeAndPadOne(Byte& twoBytes, Byte& encodingMap);
    private static int EncodeAndPadTwo(Byte& oneByte, Byte& encodingMap);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    internal static string HexTableLower;
    internal static string HexTableUpper;
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
    public static char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol);
    public static void FillWithAsciiZeros(Span`1<byte> buffer);
    public static void WriteHexByte(byte value, Span`1<byte> buffer, int startingIndex, HexCasing casing);
    public static void WriteDigits(ulong value, Span`1<byte> buffer);
    public static void WriteDigitsWithGroupSeparator(ulong value, Span`1<byte> buffer);
    public static void WriteDigits(UInt32 value, Span`1<byte> buffer);
    public static void WriteFourDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static void WriteTwoDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static ulong DivMod(ulong numerator, ulong denominator, UInt64& modulo);
    public static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
}
internal static class System.Buffers.Text.Number : object {
    private static UInt64[] s_rgval64Power10;
    private static SByte[] s_rgexp64Power10;
    private static UInt64[] s_rgval64Power10By16;
    private static Int16[] s_rgexp64Power10By16;
    internal static int DECIMAL_PRECISION;
    private static Number();
    internal static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
    public static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    public static void DecimalToNumber(decimal value, NumberBuffer& number);
    private static UInt32 DigitsToInt(ReadOnlySpan`1<byte> digits, int count);
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static ulong Mul64Lossy(ulong a, ulong b, Int32& pexp);
    private static int abs(int value);
    private static double NumberToDouble(NumberBuffer& number);
    public static void RoundNumber(NumberBuffer& number, int pos);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.Buffers.Text.NumberBuffer : ValueType {
    public int Scale;
    public bool IsNegative;
    public static int BufferSize;
    private byte _b0;
    private byte _b1;
    private byte _b2;
    private byte _b3;
    private byte _b4;
    private byte _b5;
    private byte _b6;
    private byte _b7;
    private byte _b8;
    private byte _b9;
    private byte _b10;
    private byte _b11;
    private byte _b12;
    private byte _b13;
    private byte _b14;
    private byte _b15;
    private byte _b16;
    private byte _b17;
    private byte _b18;
    private byte _b19;
    private byte _b20;
    private byte _b21;
    private byte _b22;
    private byte _b23;
    private byte _b24;
    private byte _b25;
    private byte _b26;
    private byte _b27;
    private byte _b28;
    private byte _b29;
    private byte _b30;
    private byte _b31;
    private byte _b32;
    private byte _b33;
    private byte _b34;
    private byte _b35;
    private byte _b36;
    private byte _b37;
    private byte _b38;
    private byte _b39;
    private byte _b40;
    private byte _b41;
    private byte _b42;
    private byte _b43;
    private byte _b44;
    private byte _b45;
    private byte _b46;
    private byte _b47;
    private byte _b48;
    private byte _b49;
    private byte _b50;
    public Span`1<byte> Digits { get; }
    public Byte* UnsafeDigits { get; }
    public int NumDigits { get; }
    public Span`1<byte> get_Digits();
    public Byte* get_UnsafeDigits();
    public int get_NumDigits();
    [ConditionalAttribute("DEBUG")]
public void CheckConsistency();
    public virtual string ToString();
}
internal static class System.Buffers.Text.ParserHelpers : object {
    public static int ByteOverflowLength;
    public static int ByteOverflowLengthHex;
    public static int UInt16OverflowLength;
    public static int UInt16OverflowLengthHex;
    public static int UInt32OverflowLength;
    public static int UInt32OverflowLengthHex;
    public static int UInt64OverflowLength;
    public static int UInt64OverflowLengthHex;
    public static int SByteOverflowLength;
    public static int SByteOverflowLengthHex;
    public static int Int16OverflowLength;
    public static int Int16OverflowLengthHex;
    public static int Int32OverflowLength;
    public static int Int32OverflowLengthHex;
    public static int Int64OverflowLength;
    public static int Int64OverflowLengthHex;
    public static Byte[] s_hexLookup;
    private static ParserHelpers();
    public static bool IsDigit(int i);
}
internal static class System.Buffers.Text.Utf8Constants : object {
    public static byte Colon;
    public static byte Comma;
    public static byte Minus;
    public static byte Period;
    public static byte Plus;
    public static byte Slash;
    public static byte Space;
    public static byte Hyphen;
    public static byte Separator;
    public static int GroupSize;
    public static TimeSpan s_nullUtcOffset;
    public static int DateTimeMaxUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static ulong BillionMaxUIntValue;
    public static UInt32 Billion;
    private static Utf8Constants();
}
public static class System.Buffers.Text.Utf8Formatter : object {
    private static byte TimeMarker;
    private static byte UtcMarker;
    private static byte GMT1;
    private static byte GMT2;
    private static byte GMT3;
    private static byte GMT1Lowercase;
    private static byte GMT2Lowercase;
    private static byte GMT3Lowercase;
    private static UInt32[] DayAbbreviations;
    private static UInt32[] DayAbbreviationsLowercase;
    private static UInt32[] MonthAbbreviations;
    private static UInt32[] MonthAbbreviationsLowercase;
    private static byte OpenBrace;
    private static byte CloseBrace;
    private static byte OpenParen;
    private static byte CloseParen;
    private static byte Dash;
    private static Utf8Formatter();
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeR(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDecimalE(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision, byte exponentSymbol);
    private static bool TryFormatDecimalF(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision);
    private static bool TryFormatDecimalG(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatFloatingPoint(T value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64D(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64Default(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32Default(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32MultipleDigits(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MultipleDigits(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64N(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64(long value, ulong mask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatUInt64D(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64Default(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32Default(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32SingleDigit(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32MultipleDigits(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64SingleDigit(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MultipleDigits(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64N(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
public static class System.Buffers.Text.Utf8Parser : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static UInt32 FlipCase;
    private static UInt32 NoFlipCase;
    private static Utf8Parser();
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed);
    private static bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value);
    private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value);
    private static bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind);
    private static bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed);
    private static bool TryParseGuidCore(ReadOnlySpan`1<byte> source, bool ends, char begin, char end, Guid& value, Int32& bytesConsumed);
    private static bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    private static bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation);
    private static bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan);
}
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    private static int NumBuckets;
    private static int MaxPerCorePerArraySizeStacks;
    private static int MaxBuffersPerArraySizePerCore;
    private Int32[] _bucketArraySizes;
    private PerCoreLockedStacks[] _buckets;
    [ThreadStaticAttribute]
private static T[][] t_tlsBuckets;
    private int _callbackCreated;
    private static bool s_trimBuffers;
    private static ConditionalWeakTable`2<T[][], object> s_allTlsBuckets;
    private int Id { get; }
    private static TlsOverPerCoreLockedStacksArrayPool`1();
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private static bool Gen2GcCallbackFunc(object target);
    private static MemoryPressure<T> GetMemoryPressure();
    private static bool GetTrimBuffers();
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.ByReference`1 : ValueType {
    private IntPtr _value;
    public T& Value { get; }
    [IntrinsicAttribute]
public ByReference`1(T& value);
    [IntrinsicAttribute]
public T& get_Value();
}
[IsReadOnlyAttribute]
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, IFormatProvider provider);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Byte& result);
    public virtual string ToString();
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.ByteMatcher : object {
    private Hashtable map;
    private Hashtable starts;
    public void AddMapping(TermInfoStrings key, Byte[] val);
    public void Sort();
    public bool StartsWith(int c);
    public TermInfoStrings Match(Char[] buffer, int offset, int length, Int32& used);
}
public class System.CannotUnloadAppDomainException : SystemException {
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Char : ValueType {
    private char m_value;
    public static char MaxValue;
    public static char MinValue;
    private static Byte[] s_categoryForLatin1;
    internal static int UNICODE_PLANE00_END;
    internal static int UNICODE_PLANE01_START;
    internal static int UNICODE_PLANE16_END;
    internal static int HIGH_SURROGATE_START;
    internal static int LOW_SURROGATE_END;
    private static Char();
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    private char _currentElement;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
internal class System.CharInfo : ValueType {
    public char Character;
    public short Attributes;
}
[FriendAccessAllowedAttribute]
internal class System.CLRConfig : object {
    [FriendAccessAllowedAttribute]
[SecurityCriticalAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static bool CheckLegacyManagedDeflateStream();
    [SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static bool CheckThrowUnobservedTaskExceptions();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
public class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _defaultCapacity;
    internal static int MaxArrayLength;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    internal ArrayList(bool trash);
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    private void EnsureCapacity(int min);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class System.Collections.BitArray : object {
    private Int32[] m_array;
    private int m_length;
    private int _version;
    private object _syncRoot;
    private static int _ShrinkThreshold;
    private static int BitsPerInt32;
    private static int BytesPerInt32;
    private static int BitsPerByte;
    public bool Item { get; public set; }
    public int Length { get; public set; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public BitArray(int length);
    public BitArray(int length, bool defaultValue);
    public BitArray(Byte[] bytes);
    public BitArray(Boolean[] values);
    public BitArray(Int32[] values);
    public BitArray(BitArray bits);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public bool Get(int index);
    public void Set(int index, bool value);
    public void SetAll(bool value);
    public BitArray And(BitArray value);
    public BitArray Or(BitArray value);
    public BitArray Xor(BitArray value);
    public BitArray Not();
    public BitArray RightShift(int count);
    public BitArray LeftShift(int count);
    public int get_Length();
    public void set_Length(int value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public bool get_IsReadOnly();
    public sealed virtual object Clone();
    public sealed virtual IEnumerator GetEnumerator();
    private static int GetArrayLength(int n, int div);
}
public class System.Collections.CaseInsensitiveComparer : object {
    private CompareInfo _compareInfo;
    private static CaseInsensitiveComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_InvariantCaseInsensitiveComparer;
    public static CaseInsensitiveComparer Default { get; }
    public static CaseInsensitiveComparer DefaultInvariant { get; }
    public CaseInsensitiveComparer(CultureInfo culture);
    public static CaseInsensitiveComparer get_Default();
    public static CaseInsensitiveComparer get_DefaultInvariant();
    public sealed virtual int Compare(object a, object b);
}
[ObsoleteAttribute("Please use StringComparer instead.")]
public class System.Collections.CaseInsensitiveHashCodeProvider : object {
    private static CaseInsensitiveHashCodeProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantCaseInsensitiveHashCodeProvider;
    private CompareInfo _compareInfo;
    public static CaseInsensitiveHashCodeProvider Default { get; }
    public static CaseInsensitiveHashCodeProvider DefaultInvariant { get; }
    public CaseInsensitiveHashCodeProvider(CultureInfo culture);
    public static CaseInsensitiveHashCodeProvider get_Default();
    public static CaseInsensitiveHashCodeProvider get_DefaultInvariant();
    public sealed virtual int GetHashCode(object obj);
}
public abstract class System.Collections.CollectionBase : object {
    private ArrayList _list;
    protected ArrayList InnerList { get; }
    protected IList List { get; }
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    protected CollectionBase(int capacity);
    protected ArrayList get_InnerList();
    protected IList get_List();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual IEnumerator GetEnumerator();
    protected virtual void OnSet(int index, object oldValue, object newValue);
    protected virtual void OnInsert(int index, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(int index, object value);
    protected virtual void OnValidate(object value);
    protected virtual void OnSetComplete(int index, object oldValue, object newValue);
    protected virtual void OnInsertComplete(int index, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(int index, object value);
}
public class System.Collections.Comparer : object {
    private CompareInfo _compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.CompatibleComparer : object {
    private IHashCodeProvider _hcp;
    private IComparer _comparer;
    internal IHashCodeProvider HashCodeProvider { get; }
    internal IComparer Comparer { get; }
    internal CompatibleComparer(IHashCodeProvider hashCodeProvider, IComparer comparer);
    internal IHashCodeProvider get_HashCodeProvider();
    internal IComparer get_Comparer();
    public sealed virtual bool Equals(object a, object b);
    public int Compare(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[EventSourceAttribute]
internal class System.Collections.Concurrent.CDSCollectionETWBCLProvider : EventSource {
    public static CDSCollectionETWBCLProvider Log;
    private static EventKeywords ALL_KEYWORDS;
    private static int CONCURRENTSTACK_FASTPUSHFAILED_ID;
    private static int CONCURRENTSTACK_FASTPOPFAILED_ID;
    private static int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID;
    private static int CONCURRENTBAG_TRYTAKESTEALS_ID;
    private static int CONCURRENTBAG_TRYPEEKSTEALS_ID;
    private static CDSCollectionETWBCLProvider();
    [EventAttribute("1")]
public void ConcurrentStack_FastPushFailed(int spinCount);
    [EventAttribute("2")]
public void ConcurrentStack_FastPopFailed(int spinCount);
    [EventAttribute("3")]
public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
    [EventAttribute("4")]
public void ConcurrentBag_TryTakeSteals();
    [EventAttribute("5")]
public void ConcurrentBag_TryPeekSteals();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IDictionaryDebugView`2")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables;
    private IEqualityComparer`1<TKey> _comparer;
    private bool _growLockArray;
    private int _budget;
    private KeyValuePair`2[] _serializationArray;
    private int _serializationConcurrencyLevel;
    private int _serializationCapacity;
    private static int DefaultCapacity;
    private static int MaxLockNumber;
    private static bool s_isValueWriteAtomic;
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static int DefaultConcurrencyLevel { get; }
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public ConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer);
    internal ConcurrentDictionary`2(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<TKey> comparer);
    private static ConcurrentDictionary`2();
    private static bool IsValueWriteAtomic();
    private void InitializeFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    private bool TryRemoveInternal(TKey key, TValue& value, bool matchValue, TValue oldValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private bool TryGetValueInternal(TKey key, int hashcode, TValue& value);
    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
    private bool TryUpdateInternal(TKey key, int hashcode, TValue newValue, TValue comparisonValue);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    public KeyValuePair`2[] ToArray();
    private void CopyToPairs(KeyValuePair`2[] array, int index);
    private void CopyToEntries(DictionaryEntry[] array, int index);
    private void CopyToObjects(Object[] array, int index);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentDictionary`2/<GetEnumerator>d__35")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfExists, bool acquireLock, TValue& resultingValue);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private static void ThrowKeyNotFoundException(object key);
    private static void ThrowKeyNullException();
    public sealed virtual int get_Count();
    private int GetCountInternal();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue AddOrUpdate(TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public bool get_IsEmpty();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void GrowTable(Tables<TKey, TValue> tables);
    private static int GetBucket(int hashcode, int bucketCount);
    private static void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private static int get_DefaultConcurrencyLevel();
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private ReadOnlyCollection`1<TKey> GetKeys();
    private ReadOnlyCollection`1<TValue> GetValues();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnSerializedAttribute]
private void OnSerialized(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private static int InitialSegmentLength;
    private static int MaxSegmentLength;
    private object _crossSegmentLock;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(Segment<T> s, int head, int tail);
    private static long GetCount(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(Segment& head, Int32& headHead, Segment& tail, Int32& tailTail);
    private T GetItemWhenAvailable(Segment<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__28")]
private IEnumerator`1<T> Enumerate(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    public bool TryPeek(T& result);
    private bool TryPeek(T& result, bool resultUsed);
    public void Clear();
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentStack`1 : object {
    private Node modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private static int BACKOFF_MAX_YIELDS;
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentStack`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(T[] array, int index);
    public void Push(T item);
    public void PushRange(T[] items);
    public void PushRange(T[] items, int startIndex, int count);
    private void PushCore(Node<T> head, Node<T> tail);
    private static void ValidatePushPopRangeInput(T[] items, int startIndex, int count);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public bool TryPeek(T& result);
    public bool TryPop(T& result);
    public int TryPopRange(T[] items);
    public int TryPopRange(T[] items, int startIndex, int count);
    private bool TryPopCore(T& result);
    private int TryPopCore(int count, Node& poppedHead);
    private static void CopyRemovedItems(Node<T> head, T[] collection, int startIndex, int nodesCount);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public sealed virtual T[] ToArray();
    private List`1<T> ToList();
    private List`1<T> ToList(Node<T> curr);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentStack`1/<GetEnumerator>d__35")]
private IEnumerator`1<T> GetEnumerator(Node<T> head);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FlagsAttribute]
public enum System.Collections.Concurrent.EnumerablePartitionerOptions : Enum {
    public int value__;
    public static EnumerablePartitionerOptions None;
    public static EnumerablePartitionerOptions NoBuffering;
}
internal class System.Collections.Concurrent.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dictionary;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
internal class System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
public abstract class System.Collections.Concurrent.OrderablePartitioner`1 : Partitioner`1<TSource> {
    [CompilerGeneratedAttribute]
private bool <KeysOrderedInEachPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeysOrderedAcrossPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeysNormalized>k__BackingField;
    public bool KeysOrderedInEachPartition { get; private set; }
    public bool KeysOrderedAcrossPartitions { get; private set; }
    public bool KeysNormalized { get; private set; }
    protected OrderablePartitioner`1(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
    public abstract virtual IList`1<IEnumerator`1<KeyValuePair`2<long, TSource>>> GetOrderablePartitions(int partitionCount);
    public virtual IEnumerable`1<KeyValuePair`2<long, TSource>> GetOrderableDynamicPartitions();
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedInEachPartition();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedInEachPartition(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedAcrossPartitions();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedAcrossPartitions(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysNormalized();
    [CompilerGeneratedAttribute]
private void set_KeysNormalized(bool value);
    public virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
public static class System.Collections.Concurrent.Partitioner : object {
    private static int DEFAULT_BYTES_PER_UNIT;
    private static int DEFAULT_BYTES_PER_CHUNK;
    public static OrderablePartitioner`1<TSource> Create(IList`1<TSource> list, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(TSource[] array, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source, EnumerablePartitionerOptions partitionerOptions);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive);
    public static OrderablePartitioner`1<Tuple`2<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.Partitioner/<CreateRanges>d__6")]
private static IEnumerable`1<Tuple`2<long, long>> CreateRanges(long fromInclusive, long toExclusive, long rangeSize);
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive);
    public static OrderablePartitioner`1<Tuple`2<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.Partitioner/<CreateRanges>d__9")]
private static IEnumerable`1<Tuple`2<int, int>> CreateRanges(int fromInclusive, int toExclusive, int rangeSize);
    private static int GetDefaultChunkSize();
}
public abstract class System.Collections.Concurrent.Partitioner`1 : object {
    public bool SupportsDynamicPartitions { get; }
    public abstract virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual bool get_SupportsDynamicPartitions();
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
public abstract class System.Collections.DictionaryBase : object {
    private Hashtable _hashtable;
    protected Hashtable InnerHashtable { get; }
    protected IDictionary Dictionary { get; }
    public int Count { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    protected Hashtable get_InnerHashtable();
    protected IDictionary get_Dictionary();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual object OnGet(object key, object currentValue);
    protected virtual void OnSet(object key, object oldValue, object newValue);
    protected virtual void OnInsert(object key, object value);
    protected virtual void OnClear();
    protected virtual void OnRemove(object key, object value);
    protected virtual void OnValidate(object key, object value);
    protected virtual void OnSetComplete(object key, object oldValue, object newValue);
    protected virtual void OnInsertComplete(object key, object value);
    protected virtual void OnClearComplete();
    protected virtual void OnRemoveComplete(object key, object value);
}
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    public void Deconstruct(Object& key, Object& value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.EmptyReadOnlyDictionaryInternal : object {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private static int DefaultCapacity;
    private static int MaxCoreClrArrayLength;
    private T[] _array;
    private int _count;
    public int Capacity { get; }
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int capacity);
    public int get_Capacity();
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public T First();
    public T Last();
    public T[] ToArray();
    public void UncheckedAdd(T item);
    private void EnsureCapacity(int minimum);
}
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static ArraySortHelper`1<T> s_defaultArraySortHelper;
    public static ArraySortHelper`1<T> Default { get; }
    private static ArraySortHelper`1();
    public void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    public static ArraySortHelper`1<T> get_Default();
}
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static ArraySortHelper`2<TKey, TValue> s_defaultArraySortHelper;
    public static ArraySortHelper`2<TKey, TValue> Default { get; }
    private static ArraySortHelper`2();
    public void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    public static ArraySortHelper`2<TKey, TValue> get_Default();
}
internal class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    [SecuritySafeCriticalAttribute]
internal virtual int IndexOf(Byte[] array, byte value, int startIndex, int count);
    internal virtual int LastIndexOf(Byte[] array, byte value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.CollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool Remove(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue& value);
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectComparer`1")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    private static Comparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer;
    public static Comparer`1<T> Default { get; }
    public static Comparer`1<T> get_Default();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    [SecuritySafeCriticalAttribute]
private static Comparer`1<T> CreateComparer();
    public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[IsReadOnlyAttribute]
internal class System.Collections.Generic.CopyPosition : ValueType {
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public static CopyPosition Start { get; }
    internal int Row { get; }
    internal int Column { get; }
    private string DebuggerDisplay { get; }
    internal CopyPosition(int row, int column);
    public static CopyPosition get_Start();
    [CompilerGeneratedAttribute]
internal int get_Row();
    [CompilerGeneratedAttribute]
internal int get_Column();
    public CopyPosition Normalize(int endColumn);
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    private object _syncRoot;
    private static string VersionName;
    private static string HashSizeName;
    private static string KeyValuePairsName;
    private static string ComparerName;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private int FindEntry(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.DictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    protected EnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static void Copy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count);
    internal static void IterativeCopy(IEnumerable`1<T> source, T[] array, int arrayIndex, int count);
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectEqualityComparer`1")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    private static EqualityComparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer;
    public static EqualityComparer`1<T> Default { get; }
    public static EqualityComparer`1<T> get_Default();
    [SecuritySafeCriticalAttribute]
private static EqualityComparer`1<T> CreateComparer();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreaterWithItems(T[] keys, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi);
    private static void Heapsort(T[] keys, int lo, int hi);
    private static void DownHeap(T[] keys, int i, int n, int lo);
    private static void InsertionSort(T[] keys, int lo, int hi);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
}
internal class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public interface System.Collections.Generic.IAsyncEnumerator`1 {
    public T Current { get; }
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
internal class System.Collections.Generic.InternalStringComparer : EqualityComparer`1<string> {
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(string x, string y);
    internal virtual int IndexOf(String[] array, string value, int startIndex, int count);
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int IntrosortSizeThreshold;
    internal static int FloorLog2PlusOne(int n);
    internal static void ThrowOrIgnoreBadComparer(object comparer);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
[IsReadOnlyAttribute]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    public void Deconstruct(TKey& key, TValue& value);
}
internal class System.Collections.Generic.LargeArrayBuilder`1 : ValueType {
    private static int StartingCapacity;
    private static int ResizeLimit;
    private int _maxCapacity;
    private T[] _first;
    private ArrayBuilder`1<T[]> _buffers;
    private T[] _current;
    private int _index;
    private int _count;
    public int Count { get; }
    public LargeArrayBuilder`1(bool initialize);
    public LargeArrayBuilder`1(int maxCapacity);
    public int get_Count();
    public void Add(T item);
    private void AddWithBufferAllocation(T item);
    public void AddRange(IEnumerable`1<T> items);
    private void AddWithBufferAllocation(T item, T[]& destination, Int32& index);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public CopyPosition CopyTo(CopyPosition position, T[] array, int arrayIndex, int count);
    public T[] GetBuffer(int index);
    public void SlowAdd(T item);
    public T[] ToArray();
    public bool TryMove(T[]& array);
    private void AllocateBuffer();
    [CompilerGeneratedAttribute]
internal static int <CopyTo>g__CopyToCore|17_0(T[] sourceBuffer, int sourceIndex, <>c__DisplayClass17_0& );
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Generic.List`1 : object {
    private static int DefaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    private void AddEnumerable(IEnumerable`1<T> enumerable);
}
internal class System.Collections.Generic.LongEnumEqualityComparer`1 : EqualityComparer`1<T> {
    public LongEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public LowLevelDictionary`2(IEqualityComparer`1<TKey> comparer);
    public LowLevelDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    private void EnsureCapacity(int min);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public T[] ToArray();
}
internal class System.Collections.Generic.LowLevelListWithIList`1 : LowLevelList`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public LowLevelListWithIList`1(int capacity);
    public LowLevelListWithIList`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    internal virtual int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    internal virtual int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.QueueDebugView`1")]
public class System.Collections.Generic.Queue`1 : object {
    private T[] _array;
    private int _head;
    private int _tail;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int MinimumGrow;
    private static int GrowFactor;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Queue`1(int capacity);
    public Queue`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void Enqueue(T item);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Dequeue();
    public bool TryDequeue(T& result);
    public T Peek();
    public bool TryPeek(T& result);
    public bool Contains(T item);
    public T[] ToArray();
    private void SetCapacity(int capacity);
    private void MoveNext(Int32& index);
    private void ThrowForEmptyQueue();
    public void TrimExcess();
}
internal class System.Collections.Generic.QueueDebugView`1 : object {
    private Queue`1<T> _queue;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public QueueDebugView`1(Queue`1<T> queue);
    public T[] get_Items();
}
internal class System.Collections.Generic.ReferenceEqualityComparer`1 : object {
    internal static ReferenceEqualityComparer`1<T> Instance;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
internal class System.Collections.Generic.SByteEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    public SByteEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual int GetHashCode(T obj);
}
internal class System.Collections.Generic.ShortEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    public ShortEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual int GetHashCode(T obj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.StackDebugView`1")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Stack`1 : object {
    private T[] _array;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int DefaultCapacity;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Stack`1(int capacity);
    public Stack`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void TrimExcess();
    public T Peek();
    public bool TryPeek(T& result);
    public T Pop();
    public bool TryPop(T& result);
    public void Push(T item);
    private void PushWithResize(T item);
    public T[] ToArray();
    private void ThrowForEmptyStack();
}
internal class System.Collections.Generic.StackDebugView`1 : object {
    private Stack`1<T> _stack;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public StackDebugView`1(Stack`1<T> stack);
    public T[] get_Items();
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
[IsByRefLikeAttribute]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public T& get_Item(int index);
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
}
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    public static int HashPrime;
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    internal static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    internal static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Hashtable : object {
    internal static int HashPrime;
    private static int InitialSize;
    private static string LoadFactorName;
    private static string VersionName;
    private static string ComparerName;
    private static string HashCodeProviderName;
    private static string HashSizeName;
    private static string KeysName;
    private static string ValuesName;
    private static string KeyComparerName;
    private bucket[] _buckets;
    private int _count;
    private int _occupancy;
    private int _loadsize;
    private float _loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWriterInProgress;
    private ICollection _keys;
    private ICollection _values;
    private IEqualityComparer _keycomparer;
    private object _syncRoot;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    private static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    protected IEqualityComparer EqualityComparer { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    private static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    protected IEqualityComparer get_EqualityComparer();
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    [ReliabilityContractAttribute("3", "2")]
public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    [ReliabilityContractAttribute("3", "1")]
public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DebuggerDisplayAttribute("{_value}")]
internal class System.Collections.KeyValuePairs : object {
    [DebuggerBrowsableAttribute("0")]
private object _key;
    [DebuggerBrowsableAttribute("0")]
private object _value;
    public KeyValuePairs(object key, object value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    private object _syncRoot;
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public abstract class System.Collections.ObjectModel.KeyedCollection`2 : Collection`1<TItem> {
    private static int defaultThreshold;
    private IEqualityComparer`1<TKey> comparer;
    private Dictionary`2<TKey, TItem> dict;
    private int keyCount;
    private int threshold;
    private List`1<TItem> Items { get; }
    public IEqualityComparer`1<TKey> Comparer { get; }
    public TItem Item { get; }
    protected IDictionary`2<TKey, TItem> Dictionary { get; }
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer);
    protected KeyedCollection`2(IEqualityComparer`1<TKey> comparer, int dictionaryCreationThreshold);
    private List`1<TItem> get_Items();
    public IEqualityComparer`1<TKey> get_Comparer();
    public TItem get_Item(TKey key);
    public bool Contains(TKey key);
    public bool TryGetValue(TKey key, TItem& item);
    private bool ContainsItem(TItem item);
    public bool Remove(TKey key);
    protected IDictionary`2<TKey, TItem> get_Dictionary();
    protected void ChangeItemKey(TItem item, TKey newKey);
    protected virtual void ClearItems();
    protected abstract virtual TKey GetKeyForItem(TItem item);
    protected virtual void InsertItem(int index, TItem item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TItem item);
    private void AddKey(TKey key, TItem item);
    private void CreateDictionary();
    private void RemoveKey(TKey key);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    private object _syncRoot;
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.DictionaryDebugView`2")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> m_dictionary;
    private object _syncRoot;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
    internal static void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index);
}
[DebuggerTypeProxyAttribute("System.Collections.Queue/QueueDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Queue : object {
    private Object[] _array;
    private int _head;
    private int _tail;
    private int _size;
    private int _growFactor;
    private int _version;
    private object _syncRoot;
    private static int _MinimumGrow;
    private static int _ShrinkThreshold;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Queue(int capacity);
    public Queue(int capacity, float growFactor);
    public Queue(ICollection col);
    public virtual int get_Count();
    public virtual object Clone();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual void CopyTo(Array array, int index);
    public virtual void Enqueue(object obj);
    public virtual IEnumerator GetEnumerator();
    public virtual object Dequeue();
    public virtual object Peek();
    public static Queue Synchronized(Queue queue);
    public virtual bool Contains(object obj);
    internal object GetElement(int i);
    public virtual Object[] ToArray();
    private void SetCapacity(int capacity);
    public virtual void TrimToSize();
}
public abstract class System.Collections.ReadOnlyCollectionBase : object {
    private ArrayList _list;
    protected ArrayList InnerList { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected ArrayList get_InnerList();
    public virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.SortedList/SortedListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.SortedList : object {
    private Object[] keys;
    private Object[] values;
    private int _size;
    private int version;
    private IComparer comparer;
    private KeyList keyList;
    private ValueList valueList;
    private object _syncRoot;
    private static int _defaultCapacity;
    internal static int MaxArrayLength;
    public int Capacity { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public SortedList(int initialCapacity);
    public SortedList(IComparer comparer);
    public SortedList(IComparer comparer, int capacity);
    public SortedList(IDictionary d);
    public SortedList(IDictionary d, IComparer comparer);
    private void Init();
    public virtual void Add(object key, object value);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void EnsureCapacity(int min);
    public virtual object GetByIndex(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual object GetKey(int index);
    public virtual IList GetKeyList();
    public virtual IList GetValueList();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual int IndexOfKey(object key);
    public virtual int IndexOfValue(object value);
    private void Insert(int index, object key, object value);
    public virtual void RemoveAt(int index);
    public virtual void Remove(object key);
    public virtual void SetByIndex(int index, object value);
    public static SortedList Synchronized(SortedList list);
    public virtual void TrimToSize();
}
[DebuggerTypeProxyAttribute("System.Collections.Stack/StackDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Stack : object {
    private Object[] _array;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _defaultCapacity;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Stack(int initialCapacity);
    public Stack(ICollection col);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object obj);
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual object Peek();
    public virtual object Pop();
    public virtual void Push(object obj);
    public static Stack Synchronized(Stack stack);
    public virtual Object[] ToArray();
}
internal class System.Collections.StructuralComparer : object {
    public sealed virtual int Compare(object x, object y);
}
public static class System.Collections.StructuralComparisons : object {
    private static IComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralComparer;
    private static IEqualityComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralEqualityComparer;
    public static IComparer StructuralComparer { get; }
    public static IEqualityComparer StructuralEqualityComparer { get; }
    public static IComparer get_StructuralComparer();
    public static IEqualityComparer get_StructuralEqualityComparer();
}
internal class System.Collections.StructuralEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal static class System.CompatibilitySwitches : object {
    public static bool IsAppEarlierThanSilverlight4;
    public static bool IsAppEarlierThanWindowsPhone8;
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute]
public class System.Configuration.Assemblies.AssemblyHash : ValueType {
    private AssemblyHashAlgorithm _algorithm;
    private Byte[] _value;
    [ObsoleteAttribute]
public static AssemblyHash Empty;
    [ObsoleteAttribute]
public AssemblyHashAlgorithm Algorithm { get; public set; }
    [ObsoleteAttribute]
public AssemblyHash(AssemblyHashAlgorithm algorithm, Byte[] value);
    [ObsoleteAttribute]
public AssemblyHash(Byte[] value);
    private static AssemblyHash();
    public AssemblyHashAlgorithm get_Algorithm();
    public void set_Algorithm(AssemblyHashAlgorithm value);
    [ObsoleteAttribute]
public sealed virtual object Clone();
    [ObsoleteAttribute]
public Byte[] GetValue();
    [ObsoleteAttribute]
public void SetValue(Byte[] value);
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public static class System.Console : object {
    internal static TextWriter stdout;
    private static TextWriter stderr;
    private static TextReader stdin;
    private static string LibLog;
    private static string LibLog64;
    internal static bool IsRunningOnAndroid;
    private static Encoding inputEncoding;
    private static Encoding outputEncoding;
    private static ConsoleCancelEventHandler cancel_event;
    public static TextWriter Error { get; }
    public static TextWriter Out { get; }
    public static TextReader In { get; }
    public static Encoding InputEncoding { get; public set; }
    public static Encoding OutputEncoding { get; public set; }
    public static ConsoleColor BackgroundColor { get; public set; }
    public static int BufferHeight { get; public set; }
    public static int BufferWidth { get; public set; }
    [MonoLimitationAttribute("Implemented only on Windows")]
public static bool CapsLock { get; }
    public static int CursorLeft { get; public set; }
    public static int CursorTop { get; public set; }
    public static int CursorSize { get; public set; }
    public static bool CursorVisible { get; public set; }
    public static ConsoleColor ForegroundColor { get; public set; }
    public static bool KeyAvailable { get; }
    public static int LargestWindowHeight { get; }
    public static int LargestWindowWidth { get; }
    public static bool NumberLock { get; }
    public static string Title { get; public set; }
    public static bool TreatControlCAsInput { get; public set; }
    public static int WindowHeight { get; public set; }
    public static int WindowLeft { get; public set; }
    public static int WindowTop { get; public set; }
    public static int WindowWidth { get; public set; }
    public static bool IsErrorRedirected { get; }
    public static bool IsOutputRedirected { get; }
    public static bool IsInputRedirected { get; }
    private static Console();
    private static void SetupStreams(Encoding inputEncoding, Encoding outputEncoding);
    public static TextWriter get_Error();
    public static TextWriter get_Out();
    public static TextReader get_In();
    private static Stream Open(IntPtr handle, FileAccess access, int bufferSize);
    public static Stream OpenStandardError();
    public static Stream OpenStandardError(int bufferSize);
    public static Stream OpenStandardInput();
    public static Stream OpenStandardInput(int bufferSize);
    public static Stream OpenStandardOutput();
    public static Stream OpenStandardOutput(int bufferSize);
    public static void SetError(TextWriter newError);
    public static void SetIn(TextReader newIn);
    public static void SetOut(TextWriter newOut);
    public static void Write(bool value);
    public static void Write(char value);
    public static void Write(Char[] buffer);
    public static void Write(decimal value);
    public static void Write(double value);
    public static void Write(int value);
    public static void Write(long value);
    public static void Write(object value);
    public static void Write(float value);
    public static void Write(string value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void Write(ulong value);
    public static void Write(string format, object arg0);
    public static void Write(string format, Object[] arg);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(string format, object arg0, object arg1);
    public static void Write(string format, object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static void Write(string format, object arg0, object arg1, object arg2, object arg3);
    public static void WriteLine();
    public static void WriteLine(bool value);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(decimal value);
    public static void WriteLine(double value);
    public static void WriteLine(int value);
    public static void WriteLine(long value);
    public static void WriteLine(object value);
    public static void WriteLine(float value);
    public static void WriteLine(string value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(ulong value);
    public static void WriteLine(string format, object arg0);
    public static void WriteLine(string format, Object[] arg);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(string format, object arg0, object arg1);
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static void WriteLine(string format, object arg0, object arg1, object arg2, object arg3);
    public static int Read();
    public static string ReadLine();
    public static Encoding get_InputEncoding();
    public static void set_InputEncoding(Encoding value);
    public static Encoding get_OutputEncoding();
    public static void set_OutputEncoding(Encoding value);
    public static ConsoleColor get_BackgroundColor();
    public static void set_BackgroundColor(ConsoleColor value);
    public static int get_BufferHeight();
    [MonoLimitationAttribute("Implemented only on Windows")]
public static void set_BufferHeight(int value);
    public static int get_BufferWidth();
    [MonoLimitationAttribute("Implemented only on Windows")]
public static void set_BufferWidth(int value);
    public static bool get_CapsLock();
    public static int get_CursorLeft();
    public static void set_CursorLeft(int value);
    public static int get_CursorTop();
    public static void set_CursorTop(int value);
    public static int get_CursorSize();
    public static void set_CursorSize(int value);
    public static bool get_CursorVisible();
    public static void set_CursorVisible(bool value);
    public static ConsoleColor get_ForegroundColor();
    public static void set_ForegroundColor(ConsoleColor value);
    public static bool get_KeyAvailable();
    public static int get_LargestWindowHeight();
    public static int get_LargestWindowWidth();
    public static bool get_NumberLock();
    public static string get_Title();
    public static void set_Title(string value);
    public static bool get_TreatControlCAsInput();
    public static void set_TreatControlCAsInput(bool value);
    public static int get_WindowHeight();
    public static void set_WindowHeight(int value);
    public static int get_WindowLeft();
    public static void set_WindowLeft(int value);
    public static int get_WindowTop();
    public static void set_WindowTop(int value);
    public static int get_WindowWidth();
    public static void set_WindowWidth(int value);
    public static bool get_IsErrorRedirected();
    public static bool get_IsOutputRedirected();
    public static bool get_IsInputRedirected();
    public static void Beep();
    public static void Beep(int frequency, int duration);
    public static void Clear();
    [MonoLimitationAttribute("Implemented only on Windows")]
public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
    [MonoLimitationAttribute("Implemented only on Windows")]
public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public static ConsoleKeyInfo ReadKey();
    public static ConsoleKeyInfo ReadKey(bool intercept);
    public static void ResetColor();
    [MonoLimitationAttribute("Only works on windows")]
public static void SetBufferSize(int width, int height);
    public static void SetCursorPosition(int left, int top);
    public static void SetWindowPosition(int left, int top);
    public static void SetWindowSize(int width, int height);
    public static void add_CancelKeyPress(ConsoleCancelEventHandler value);
    public static void remove_CancelKeyPress(ConsoleCancelEventHandler value);
    private static void DoConsoleCancelEventInBackground();
    private static void DoConsoleCancelEvent();
}
public class System.ConsoleCancelEventArgs : EventArgs {
    private ConsoleSpecialKey _type;
    [CompilerGeneratedAttribute]
private bool <Cancel>k__BackingField;
    public bool Cancel { get; public set; }
    public ConsoleSpecialKey SpecialKey { get; }
    internal ConsoleCancelEventArgs(ConsoleSpecialKey type);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
    public ConsoleSpecialKey get_SpecialKey();
}
public class System.ConsoleCancelEventHandler : MulticastDelegate {
    public ConsoleCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ConsoleCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.ConsoleColor : Enum {
    public int value__;
    public static ConsoleColor Black;
    public static ConsoleColor DarkBlue;
    public static ConsoleColor DarkGreen;
    public static ConsoleColor DarkCyan;
    public static ConsoleColor DarkRed;
    public static ConsoleColor DarkMagenta;
    public static ConsoleColor DarkYellow;
    public static ConsoleColor Gray;
    public static ConsoleColor DarkGray;
    public static ConsoleColor Blue;
    public static ConsoleColor Green;
    public static ConsoleColor Cyan;
    public static ConsoleColor Red;
    public static ConsoleColor Magenta;
    public static ConsoleColor Yellow;
    public static ConsoleColor White;
}
internal class System.ConsoleCursorInfo : ValueType {
    public int Size;
    public bool Visible;
}
internal static class System.ConsoleDriver : object {
    internal static IConsoleDriver driver;
    private static bool is_console;
    private static bool called_isatty;
    public static bool Initialized { get; }
    public static ConsoleColor BackgroundColor { get; public set; }
    public static int BufferHeight { get; public set; }
    public static int BufferWidth { get; public set; }
    public static bool CapsLock { get; }
    public static int CursorLeft { get; public set; }
    public static int CursorSize { get; public set; }
    public static int CursorTop { get; public set; }
    public static bool CursorVisible { get; public set; }
    public static bool KeyAvailable { get; }
    public static ConsoleColor ForegroundColor { get; public set; }
    public static int LargestWindowHeight { get; }
    public static int LargestWindowWidth { get; }
    public static bool NumberLock { get; }
    public static string Title { get; public set; }
    public static bool TreatControlCAsInput { get; public set; }
    public static int WindowHeight { get; public set; }
    public static int WindowLeft { get; public set; }
    public static int WindowTop { get; public set; }
    public static int WindowWidth { get; public set; }
    public static bool IsErrorRedirected { get; }
    public static bool IsOutputRedirected { get; }
    public static bool IsInputRedirected { get; }
    public static bool IsConsole { get; }
    private static ConsoleDriver();
    private static IConsoleDriver CreateNullConsoleDriver();
    private static IConsoleDriver CreateWindowsConsoleDriver();
    private static IConsoleDriver CreateTermInfoDriver(string term);
    public static bool get_Initialized();
    public static ConsoleColor get_BackgroundColor();
    public static void set_BackgroundColor(ConsoleColor value);
    public static int get_BufferHeight();
    public static void set_BufferHeight(int value);
    public static int get_BufferWidth();
    public static void set_BufferWidth(int value);
    public static bool get_CapsLock();
    public static int get_CursorLeft();
    public static void set_CursorLeft(int value);
    public static int get_CursorSize();
    public static void set_CursorSize(int value);
    public static int get_CursorTop();
    public static void set_CursorTop(int value);
    public static bool get_CursorVisible();
    public static void set_CursorVisible(bool value);
    public static bool get_KeyAvailable();
    public static ConsoleColor get_ForegroundColor();
    public static void set_ForegroundColor(ConsoleColor value);
    public static int get_LargestWindowHeight();
    public static int get_LargestWindowWidth();
    public static bool get_NumberLock();
    public static string get_Title();
    public static void set_Title(string value);
    public static bool get_TreatControlCAsInput();
    public static void set_TreatControlCAsInput(bool value);
    public static int get_WindowHeight();
    public static void set_WindowHeight(int value);
    public static int get_WindowLeft();
    public static void set_WindowLeft(int value);
    public static int get_WindowTop();
    public static void set_WindowTop(int value);
    public static int get_WindowWidth();
    public static void set_WindowWidth(int value);
    public static bool get_IsErrorRedirected();
    public static bool get_IsOutputRedirected();
    public static bool get_IsInputRedirected();
    public static void Beep(int frequency, int duration);
    public static void Clear();
    public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
    public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public static void Init();
    public static int Read();
    public static string ReadLine();
    public static ConsoleKeyInfo ReadKey(bool intercept);
    public static void ResetColor();
    public static void SetBufferSize(int width, int height);
    public static void SetCursorPosition(int left, int top);
    public static void SetWindowPosition(int left, int top);
    public static void SetWindowSize(int width, int height);
    public static bool get_IsConsole();
    private static bool Isatty(IntPtr handle);
    internal static int InternalKeyAvailable(int ms_timeout);
    internal static bool TtySetup(string keypadXmit, string teardown, Byte[]& control_characters, Int32*& address);
    internal static bool SetEcho(bool wantEcho);
    internal static bool SetBreak(bool wantBreak);
}
public enum System.ConsoleKey : Enum {
    public int value__;
    public static ConsoleKey Backspace;
    public static ConsoleKey Tab;
    public static ConsoleKey Clear;
    public static ConsoleKey Enter;
    public static ConsoleKey Pause;
    public static ConsoleKey Escape;
    public static ConsoleKey Spacebar;
    public static ConsoleKey PageUp;
    public static ConsoleKey PageDown;
    public static ConsoleKey End;
    public static ConsoleKey Home;
    public static ConsoleKey LeftArrow;
    public static ConsoleKey UpArrow;
    public static ConsoleKey RightArrow;
    public static ConsoleKey DownArrow;
    public static ConsoleKey Select;
    public static ConsoleKey Print;
    public static ConsoleKey Execute;
    public static ConsoleKey PrintScreen;
    public static ConsoleKey Insert;
    public static ConsoleKey Delete;
    public static ConsoleKey Help;
    public static ConsoleKey D0;
    public static ConsoleKey D1;
    public static ConsoleKey D2;
    public static ConsoleKey D3;
    public static ConsoleKey D4;
    public static ConsoleKey D5;
    public static ConsoleKey D6;
    public static ConsoleKey D7;
    public static ConsoleKey D8;
    public static ConsoleKey D9;
    public static ConsoleKey A;
    public static ConsoleKey B;
    public static ConsoleKey C;
    public static ConsoleKey D;
    public static ConsoleKey E;
    public static ConsoleKey F;
    public static ConsoleKey G;
    public static ConsoleKey H;
    public static ConsoleKey I;
    public static ConsoleKey J;
    public static ConsoleKey K;
    public static ConsoleKey L;
    public static ConsoleKey M;
    public static ConsoleKey N;
    public static ConsoleKey O;
    public static ConsoleKey P;
    public static ConsoleKey Q;
    public static ConsoleKey R;
    public static ConsoleKey S;
    public static ConsoleKey T;
    public static ConsoleKey U;
    public static ConsoleKey V;
    public static ConsoleKey W;
    public static ConsoleKey X;
    public static ConsoleKey Y;
    public static ConsoleKey Z;
    public static ConsoleKey LeftWindows;
    public static ConsoleKey RightWindows;
    public static ConsoleKey Applications;
    public static ConsoleKey Sleep;
    public static ConsoleKey NumPad0;
    public static ConsoleKey NumPad1;
    public static ConsoleKey NumPad2;
    public static ConsoleKey NumPad3;
    public static ConsoleKey NumPad4;
    public static ConsoleKey NumPad5;
    public static ConsoleKey NumPad6;
    public static ConsoleKey NumPad7;
    public static ConsoleKey NumPad8;
    public static ConsoleKey NumPad9;
    public static ConsoleKey Multiply;
    public static ConsoleKey Add;
    public static ConsoleKey Separator;
    public static ConsoleKey Subtract;
    public static ConsoleKey Decimal;
    public static ConsoleKey Divide;
    public static ConsoleKey F1;
    public static ConsoleKey F2;
    public static ConsoleKey F3;
    public static ConsoleKey F4;
    public static ConsoleKey F5;
    public static ConsoleKey F6;
    public static ConsoleKey F7;
    public static ConsoleKey F8;
    public static ConsoleKey F9;
    public static ConsoleKey F10;
    public static ConsoleKey F11;
    public static ConsoleKey F12;
    public static ConsoleKey F13;
    public static ConsoleKey F14;
    public static ConsoleKey F15;
    public static ConsoleKey F16;
    public static ConsoleKey F17;
    public static ConsoleKey F18;
    public static ConsoleKey F19;
    public static ConsoleKey F20;
    public static ConsoleKey F21;
    public static ConsoleKey F22;
    public static ConsoleKey F23;
    public static ConsoleKey F24;
    public static ConsoleKey BrowserBack;
    public static ConsoleKey BrowserForward;
    public static ConsoleKey BrowserRefresh;
    public static ConsoleKey BrowserStop;
    public static ConsoleKey BrowserSearch;
    public static ConsoleKey BrowserFavorites;
    public static ConsoleKey BrowserHome;
    public static ConsoleKey VolumeMute;
    public static ConsoleKey VolumeDown;
    public static ConsoleKey VolumeUp;
    public static ConsoleKey MediaNext;
    public static ConsoleKey MediaPrevious;
    public static ConsoleKey MediaStop;
    public static ConsoleKey MediaPlay;
    public static ConsoleKey LaunchMail;
    public static ConsoleKey LaunchMediaSelect;
    public static ConsoleKey LaunchApp1;
    public static ConsoleKey LaunchApp2;
    public static ConsoleKey Oem1;
    public static ConsoleKey OemPlus;
    public static ConsoleKey OemComma;
    public static ConsoleKey OemMinus;
    public static ConsoleKey OemPeriod;
    public static ConsoleKey Oem2;
    public static ConsoleKey Oem3;
    public static ConsoleKey Oem4;
    public static ConsoleKey Oem5;
    public static ConsoleKey Oem6;
    public static ConsoleKey Oem7;
    public static ConsoleKey Oem8;
    public static ConsoleKey Oem102;
    public static ConsoleKey Process;
    public static ConsoleKey Packet;
    public static ConsoleKey Attention;
    public static ConsoleKey CrSel;
    public static ConsoleKey ExSel;
    public static ConsoleKey EraseEndOfFile;
    public static ConsoleKey Play;
    public static ConsoleKey Zoom;
    public static ConsoleKey NoName;
    public static ConsoleKey Pa1;
    public static ConsoleKey OemClear;
}
[IsReadOnlyAttribute]
public class System.ConsoleKeyInfo : ValueType {
    private char _keyChar;
    private ConsoleKey _key;
    private ConsoleModifiers _mods;
    public char KeyChar { get; }
    public ConsoleKey Key { get; }
    public ConsoleModifiers Modifiers { get; }
    public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
    public char get_KeyChar();
    public ConsoleKey get_Key();
    public ConsoleModifiers get_Modifiers();
    public virtual bool Equals(object value);
    public bool Equals(ConsoleKeyInfo obj);
    public static bool op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b);
    public static bool op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.ConsoleModifiers : Enum {
    public int value__;
    public static ConsoleModifiers Alt;
    public static ConsoleModifiers Shift;
    public static ConsoleModifiers Control;
}
internal class System.ConsoleScreenBufferInfo : ValueType {
    public Coord Size;
    public Coord CursorPosition;
    public short Attribute;
    public SmallRect Window;
    public Coord MaxWindowSize;
}
public enum System.ConsoleSpecialKey : Enum {
    public int value__;
    public static ConsoleSpecialKey ControlC;
    public static ConsoleSpecialKey ControlBreak;
}
[ComVisibleAttribute("True")]
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[ComVisibleAttribute("True")]
public class System.ContextMarshalException : SystemException {
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.ContextStaticAttribute : Attribute {
}
internal class System.ControlCharacters : object {
    public static int Intr;
    public static int Quit;
    public static int Erase;
    public static int Kill;
    public static int EOF;
    public static int Time;
    public static int Min;
    public static int SWTC;
    public static int Start;
    public static int Stop;
    public static int Susp;
    public static int EOL;
    public static int Reprint;
    public static int Discard;
    public static int WErase;
    public static int LNext;
    public static int EOL2;
}
[ExtensionAttribute]
public static class System.Convert : object {
    private static SByte[] s_decodingMap;
    private static byte EncodingPad;
    internal static Type[] ConvertTypes;
    private static Type EnumType;
    internal static Char[] base64Table;
    private static int base64LineBreakPosition;
    public static object DBNull;
    private static Convert();
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    private static void ThrowCharOverflowException();
    private static void ThrowByteOverflowException();
    private static void ThrowSByteOverflowException();
    private static void ThrowInt16OverflowException();
    private static void ThrowUInt16OverflowException();
    private static void ThrowInt32OverflowException();
    private static void ThrowUInt32OverflowException();
    private static void ThrowInt64OverflowException();
    private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    public static string ToString(byte value, int toBase);
    public static string ToString(short value, int toBase);
    public static string ToString(int value, int toBase);
    public static string ToString(long value, int toBase);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    public static Byte[] FromBase64String(string s);
    public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    [ExtensionAttribute]
private static bool IsSpace(char c);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
internal class System.Coord : ValueType {
    public short X;
    public short Y;
    public Coord(int x, int y);
}
[ComVisibleAttribute("True")]
public class System.CrossAppDomainDelegate : MulticastDelegate {
    public CrossAppDomainDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.CtorDelegate : MulticastDelegate {
    public CtorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.CultureAwareComparer : StringComparer {
    private static CompareOptions ValidCompareMaskOffFlags;
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, CompareOptions options);
    internal CultureAwareComparer(CompareInfo compareInfo, CompareOptions options);
    private CultureAwareComparer(SerializationInfo info, StreamingContext context);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    private Hashtable m_CachedDaylightChanges;
    public string StandardName { get; }
    public string DaylightName { get; }
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
    private DaylightTime GetCachedDaylightChanges(int year);
}
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.DateTime : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    internal static int DaysTo1970;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMillis;
    internal static long UnixEpochTicks;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    public static DateTime UnixEpoch;
    private static ulong TicksMask;
    private static ulong FlagsMask;
    private static ulong LocalMask;
    private static long TicksCeiling;
    private static ulong KindUnspecified;
    private static ulong KindUtc;
    private static ulong KindLocal;
    private static ulong KindLocalAmbiguousDst;
    private static int KindShift;
    private static string TicksField;
    private static string DateDataField;
    private ulong _dateData;
    internal long InternalTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public static DateTime UtcNow { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    internal long get_InternalTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime Add(double value, int scale);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static long DateToTicks(int year, int month, int day);
    private static long TimeToTicks(int hour, int minute, int second);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    private int GetDatePart(int part);
    internal void GetDatePart(Int32& year, Int32& month, Int32& day);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
    public static DateTime get_UtcNow();
    internal static long GetSystemTimeAsFileTime();
    internal long ToBinaryRaw();
}
internal static class System.DateTimeFormat : object {
    internal static int MaxSecondsFractionDigits;
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal static DateTimeFormatInfo InvariantFormatInfo;
    internal static String[] InvariantAbbreviatedMonthNames;
    internal static String[] InvariantAbbreviatedDayNames;
    internal static string Gmt;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
    internal static int ParseRepeatPattern(ReadOnlySpan`1<char> format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result);
    internal static int ParseNextChar(ReadOnlySpan`1<char> format, int pos);
    private static bool IsUseGenitiveForm(ReadOnlySpan`1<char> format, int index, int tokenLen, char patternToMatch);
    private static StringBuilder FormatCustomized(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset, StringBuilder result);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, ReadOnlySpan`1<char> format, int tokenLen, bool timeOnly, StringBuilder result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
    private static void Append2DigitNumber(StringBuilder result, int val);
    internal static string GetRealFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider, TimeSpan offset);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider, TimeSpan offset);
    private static StringBuilder FormatStringBuilder(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset);
    private static bool TryFormatO(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static bool TryFormatR(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDecimalDigits(UInt32 value, Span`1<char> destination, int offset);
    private static void WriteFourDecimalDigits(UInt32 value, Span`1<char> buffer, int startingIndex);
    private static void WriteDigits(ulong value, Span`1<char> buffer);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(ReadOnlySpan`1<char> format, DateTime dateTime);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[IsReadOnlyAttribute]
public class System.DateTimeOffset : ValueType {
    internal static long MaxOffset;
    internal static long MinOffset;
    private static long UnixEpochSeconds;
    private static long UnixEpochMilliseconds;
    internal static long UnixMinSeconds;
    internal static long UnixMaxSeconds;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset UnixEpoch;
    private DateTime _dateTime;
    private short _offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static int MaxDateTimeNumberDigits;
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DS[][] dateParsingStates;
    internal static string GMTName;
    internal static string ZuluName;
    private static int ORDER_YMD;
    private static int ORDER_MDY;
    private static int ORDER_DMY;
    private static int ORDER_YDM;
    private static int ORDER_YM;
    private static int ORDER_MY;
    private static int ORDER_MD;
    private static int ORDER_DM;
    private static DateTimeParse();
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    internal static bool IsDigit(char ch);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static Calendar GetJapaneseCalendarDefaultInstance();
    internal static Calendar GetTaiwanCalendarDefaultInstance();
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(__DTString& str, DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(__DTString& str, DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseJapaneseEraStart(__DTString& str, DateTimeFormatInfo dtfi);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result, Int32& returnValue);
    private static bool DoStrictParse(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
    [ConditionalAttribute("_LOGGING")]
private static void LexTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
private static void PTSTraceExit(DS dps, bool passed);
    [ConditionalAttribute("_LOGGING")]
private static void TPTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
private static void DTFITrace(DateTimeFormatInfo dtfi);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal ReadOnlySpan`1<char> originalDateTimeString;
    internal ReadOnlySpan`1<char> failedFormatSpecifier;
    internal void Init(ReadOnlySpan`1<char> originalDateTimeString);
    internal void SetDate(int year, int month, int day);
    internal void SetBadFormatSpecifierFailure();
    internal void SetBadFormatSpecifierFailure(ReadOnlySpan`1<char> failedFormatSpecifier);
    internal void SetBadDateTimeFailure();
    internal void SetFailure(ParseFailureKind failure, string failureMessageID);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
public class System.DBNull : object {
    public static DBNull Value;
    private DBNull(SerializationInfo info, StreamingContext context);
    private static DBNull();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
public class System.Decimal : ValueType {
    private static int SignMask;
    private static int ScaleMask;
    private static int ScaleShift;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    private ulong ulomidLE;
    internal UInt32 High { get; }
    internal UInt32 Low { get; }
    internal UInt32 Mid { get; }
    internal bool IsNegative { get; }
    internal int Scale { get; }
    private ulong Low64 { get; }
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private Decimal(Decimal& d, int flags);
    private static Decimal();
    internal UInt32 get_High();
    internal UInt32 get_Low();
    internal UInt32 get_Mid();
    internal bool get_IsNegative();
    internal int get_Scale();
    private ulong get_Low64();
    private static DecCalc& AsMutable(Decimal& d);
    internal static UInt32 DecDivMod1E9(Decimal& value);
    public static decimal FromOACurrency(long cy);
    public static long ToOACurrency(decimal value);
    private static bool IsValid(int flags);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(Decimal& d);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static decimal Floor(decimal d);
    public virtual string ToString();
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static Int32[] GetBits(decimal d);
    internal static void GetBytes(Decimal& d, Byte[] buffer);
    internal static decimal ToDecimal(Byte[] buffer);
    internal static Decimal& modreq(System.Runtime.InteropServices.InAttribute) Max(Decimal& d1, Decimal& d2);
    internal static Decimal& modreq(System.Runtime.InteropServices.InAttribute) Min(Decimal& d1, Decimal& d2);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static decimal Round(Decimal& d, int decimals, MidpointRounding mode);
    internal static int Sign(Decimal& d);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    public static double ToDouble(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static decimal Truncate(decimal d);
    private static void Truncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal static class System.DecimalDecCalc : object {
    private static UInt32 D32DivMod1E9(UInt32 hi32, UInt32& lo32);
    internal static UInt32 DecDivMod1E9(MutableDecimal& value);
    internal static void DecAddInt32(MutableDecimal& value, UInt32 i);
    private static bool D32AddCarry(UInt32& value, UInt32 i);
    internal static void DecMul10(MutableDecimal& value);
    private static void DecShiftLeft(MutableDecimal& value);
    private static void DecAdd(MutableDecimal& value, MutableDecimal d);
}
internal class System.DefaultBinder : Binder {
    private static Primitives[] _primitiveConversions;
    private static DefaultBinder();
    [SecuritySafeCriticalAttribute]
public virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    [SecuritySafeCriticalAttribute]
public virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    [SecuritySafeCriticalAttribute]
public virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    [SecuritySafeCriticalAttribute]
private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    internal static bool CompareMethodSigAndName(MethodBase m1, MethodBase m2);
    internal static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
    private static bool CanConvertPrimitive(RuntimeType source, RuntimeType target);
    private static bool CanConvertPrimitiveObjectToType(object source, RuntimeType type);
    internal static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    private static bool CanChangePrimitive(Type source, Type target);
    private static bool CanChangePrimitiveObjectToType(object source, Type type);
    private static bool CanPrimitiveWiden(Type source, Type target);
}
public abstract class System.Delegate : object {
    private IntPtr method_ptr;
    private IntPtr invoke_impl;
    private object m_target;
    private IntPtr method;
    private IntPtr delegate_trampoline;
    private IntPtr extra_arg;
    private IntPtr method_code;
    private IntPtr interp_method;
    private IntPtr interp_invoke_impl;
    private MethodInfo method_info;
    private MethodInfo original_method_info;
    private DelegateData data;
    private bool method_is_virtual;
    public MethodInfo Method { get; }
    public object Target { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public MethodInfo get_Method();
    private MethodInfo GetVirtualMethod_internal();
    public object get_Target();
    internal IntPtr GetNativeFunctionPointer();
    internal static Delegate CreateDelegate_internal(Type type, object target, MethodInfo info, bool throwOnBindFailure);
    private static bool arg_type_match(Type delArgType, Type argType);
    private static bool arg_type_match_this(Type delArgType, Type argType, bool boxedThis);
    private static bool return_type_match(Type delReturnType, Type returnType);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    private static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure, bool allowClosed);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object target, string method);
    private static MethodInfo GetCandidateMethod(Type type, Type target, string method, BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public object DynamicInvoke(Object[] args);
    private void InitializeDelegateData();
    protected virtual object DynamicInvokeImpl(Object[] args);
    public virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual MethodInfo GetMethodImpl();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Delegate[] GetInvocationList();
    public static Delegate Combine(Delegate a, Delegate b);
    [ComVisibleAttribute("True")]
public static Delegate Combine(Delegate[] delegates);
    protected virtual Delegate CombineImpl(Delegate d);
    public static Delegate Remove(Delegate source, Delegate value);
    protected virtual Delegate RemoveImpl(Delegate d);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    internal bool IsTransparentProxy();
    internal static Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method);
    internal static MulticastDelegate AllocDelegateLike_internal(Delegate d);
}
internal class System.DelegateData : object {
    public Type target_type;
    public string method_name;
    public bool curried_first_arg;
}
internal class System.DelegateSerializationHolder : object {
    private Delegate _delegate;
    private DelegateSerializationHolder(SerializationInfo info, StreamingContext ctx);
    public static void GetDelegateData(Delegate instance, SerializationInfo info, StreamingContext ctx);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual object GetRealObject(StreamingContext context);
}
[ComVisibleAttribute("False")]
public static class System.Deployment.Internal.InternalActivationContextHelper : object {
    [MonoTODOAttribute]
public static object GetActivationContextData(ActivationContext appInfo);
    [MonoTODOAttribute]
public static object GetApplicationComponentManifest(ActivationContext appInfo);
    [MonoTODOAttribute("2.0 SP1 member")]
public static Byte[] GetApplicationManifestBytes(ActivationContext appInfo);
    [MonoTODOAttribute]
public static object GetDeploymentComponentManifest(ActivationContext appInfo);
    [MonoTODOAttribute("2.0 SP1 member")]
public static Byte[] GetDeploymentManifestBytes(ActivationContext appInfo);
    [MonoTODOAttribute]
public static bool IsFirstRun(ActivationContext appInfo);
    [MonoTODOAttribute]
public static void PrepareForExecution(ActivationContext appInfo);
}
[ComVisibleAttribute("False")]
public static class System.Deployment.Internal.InternalApplicationIdentityHelper : object {
    [MonoTODOAttribute]
public static object GetInternalAppId(ApplicationIdentity id);
}
internal static class System.Diagnostics.Assert : object {
    internal static int COR_E_FAILFAST;
    private static AssertFilter Filter;
    private static Assert();
    internal static void Check(bool condition, string conditionString, string message);
    internal static void Check(bool condition, string conditionString, string message, int exitCode);
    internal static void Fail(string conditionString, string message);
    internal static void Fail(string conditionString, string message, string windowTitle, int exitCode);
    internal static void Fail(string conditionString, string message, int exitCode, TraceFormat stackTraceFormat);
    [SecuritySafeCriticalAttribute]
internal static void Fail(string conditionString, string message, string windowTitle, int exitCode, TraceFormat stackTraceFormat, int numStackFramesToSkip);
    internal static int ShowDefaultAssertDialog(string conditionString, string message, string stackTrace, string windowTitle);
}
internal abstract class System.Diagnostics.AssertFilter : object {
    public abstract virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
internal enum System.Diagnostics.AssertFilters : Enum {
    public int value__;
    public static AssertFilters FailDebug;
    public static AssertFilters FailIgnore;
    public static AssertFilters FailTerminate;
    public static AssertFilters FailContinueFilter;
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    [ThreadStaticAttribute]
private static bool _assertingMustUseRewriter;
    [ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assume(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
[ReliabilityContractAttribute("3", "1")]
public static void Assert(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition);
    [ReliabilityContractAttribute("3", "1")]
public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Ensures(bool condition);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void EnsuresOnThrow(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "2")]
public static T Result();
    [ReliabilityContractAttribute("3", "2")]
public static T ValueAtReturn(T& value);
    [ReliabilityContractAttribute("3", "2")]
public static T OldValue(T value);
    [ReliabilityContractAttribute("3", "1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "1")]
public static void Invariant(bool condition, string userMessage);
    [ReliabilityContractAttribute("3", "1")]
public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    [ReliabilityContractAttribute("3", "1")]
public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ReliabilityContractAttribute("3", "2")]
public static void EndContractBlock();
    [ReliabilityContractAttribute("3", "1")]
[DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [SecuritySafeCriticalAttribute]
private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    [SecurityCriticalAttribute]
public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("5124")]
[ConditionalAttribute("DEBUG")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
internal class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _Kind;
    private string _UserMessage;
    private string _Condition;
    public ContractFailureKind Kind { get; }
    public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    [ReliabilityContractAttribute("3", "1")]
public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    [SecurityCriticalAttribute]
public void SetHandled();
    public bool get_Unwind();
    [SecurityCriticalAttribute]
public void SetUnwind();
}
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    public string get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("256")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[AttributeUsageAttribute("237")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ObsoleteAttribute("Use the ContractHelper class in the System.Runtime.CompilerServices namespace instead.")]
public static class System.Diagnostics.Contracts.Internal.ContractHelper : object {
    [ReliabilityContractAttribute("3", "1")]
[DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("6884")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    private DebuggingModes m_debuggingModes;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    public DebuggingModes get_DebuggingFlags();
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    public static bool get_IsAttached();
    private static bool IsAttached_internal();
    public static void Break();
    public static bool IsLogging();
    public static bool Launch();
    private static void Log_icall(int level, String& category, String& message);
    public static void Log(int level, string category, string message);
    public static void NotifyOfCrossThreadDependency();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    private DebuggerBrowsableState state;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    public DebuggerBrowsableState get_State();
}
[ComVisibleAttribute("True")]
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[AttributeUsageAttribute("4509")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private string name;
    private string value;
    private string type;
    private string targetName;
    private Type target;
    public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    public string get_Value();
    public string get_Name();
    public void set_Name(string value);
    public string get_Type();
    public void set_Type(string value);
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("13")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private string typeName;
    private string targetName;
    private Type target;
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(Type type);
    public DebuggerTypeProxyAttribute(string typeName);
    public string get_ProxyTypeName();
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("13")]
[ComVisibleAttribute("True")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    private string visualizerObjectSourceName;
    private string visualizerName;
    private string description;
    private string targetName;
    private Type target;
    public string VisualizerObjectSourceTypeName { get; }
    public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerVisualizerAttribute(string visualizerTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer);
    public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    public string get_VisualizerObjectSourceTypeName();
    public string get_VisualizerTypeName();
    public string get_Description();
    public void set_Description(string value);
    public void set_Target(Type value);
    public Type get_Target();
    public void set_TargetTypeName(string value);
    public string get_TargetTypeName();
}
internal static class System.Diagnostics.DebugPrivate : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
}
internal class System.Diagnostics.DefaultFilter : AssertFilter {
    [SecuritySafeCriticalAttribute]
public virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
[ComVisibleAttribute("True")]
[MonoTODOAttribute("Serialized objects are not compatible with MS.NET")]
public class System.Diagnostics.StackFrame : object {
    public static int OFFSET_UNKNOWN;
    private int ilOffset;
    private int nativeOffset;
    private long methodAddress;
    private UInt32 methodIndex;
    private MethodBase methodBase;
    private string fileName;
    private int lineNumber;
    private int columnNumber;
    private string internalMethodName;
    public StackFrame(bool fNeedFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool fNeedFileInfo);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    private static bool get_frame_info(int skip, bool needFileInfo, MethodBase& method, Int32& iloffset, Int32& native_offset, String& file, Int32& line, Int32& column);
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    public virtual string GetFileName();
    internal string GetSecureFileName();
    public virtual int GetILOffset();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    internal long GetMethodAddress();
    internal UInt32 GetMethodIndex();
    internal string GetInternalMethodName();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
[MonoTODOAttribute("Serialized objects are not compatible with .NET")]
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    private static string prefix;
    private StackFrame[] frames;
    private StackTrace[] captured_traces;
    private bool debug_info;
    private static bool isAotidSet;
    private static string aotid;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    [MonoLimitationAttribute("Not possible to create StackTraces from other threads")]
[ObsoleteAttribute]
public StackTrace(Thread targetThread, bool needFileInfo);
    internal StackTrace(StackFrame[] frames);
    private void init_frames(int skipFrames, bool fNeedFileInfo);
    private static StackFrame[] get_trace(Exception e, int skipFrames, bool fNeedFileInfo);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    [ComVisibleAttribute("False")]
public virtual StackFrame[] GetFrames();
    private static string GetAotId();
    private bool AddFrames(StringBuilder sb, bool separator, Boolean& isAsync);
    private void GetFullNameForStackTrace(StringBuilder sb, MethodBase mi, bool needsNewLine, Boolean& skipped, Boolean& isAsync);
    private static void ConvertAsyncStateMachineMethod(MethodBase& method, Type& declaringType);
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolBinder {
    [ObsoleteAttribute("This interface is not 64-bit clean.  Use ISymbolBinder1 instead")]
public abstract virtual ISymbolReader GetReader(int importer, string filename, string searchPath);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolBinder1 {
    public abstract virtual ISymbolReader GetReader(IntPtr importer, string filename, string searchPath);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolDocument {
    public Guid CheckSumAlgorithmId { get; }
    public Guid DocumentType { get; }
    public bool HasEmbeddedSource { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public int SourceLength { get; }
    public string URL { get; }
    public abstract virtual Guid get_CheckSumAlgorithmId();
    public abstract virtual Guid get_DocumentType();
    public abstract virtual bool get_HasEmbeddedSource();
    public abstract virtual Guid get_Language();
    public abstract virtual Guid get_LanguageVendor();
    public abstract virtual int get_SourceLength();
    public abstract virtual string get_URL();
    public abstract virtual int FindClosestLine(int line);
    public abstract virtual Byte[] GetCheckSum();
    public abstract virtual Byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public abstract virtual void SetSource(Byte[] source);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolMethod {
    public ISymbolScope RootScope { get; }
    public int SequencePointCount { get; }
    public SymbolToken Token { get; }
    public abstract virtual ISymbolScope get_RootScope();
    public abstract virtual int get_SequencePointCount();
    public abstract virtual SymbolToken get_Token();
    public abstract virtual ISymbolNamespace GetNamespace();
    public abstract virtual int GetOffset(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolVariable[] GetParameters();
    public abstract virtual Int32[] GetRanges(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolScope GetScope(int offset);
    public abstract virtual void GetSequencePoints(Int32[] offsets, ISymbolDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual bool GetSourceStartEnd(ISymbolDocument[] docs, Int32[] lines, Int32[] columns);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolNamespace {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
    public abstract virtual ISymbolVariable[] GetVariables();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolReader {
    public SymbolToken UserEntryPoint { get; }
    public abstract virtual SymbolToken get_UserEntryPoint();
    public abstract virtual ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual ISymbolDocument[] GetDocuments();
    public abstract virtual ISymbolVariable[] GetGlobalVariables();
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method);
    public abstract virtual ISymbolMethod GetMethod(SymbolToken method, int version);
    public abstract virtual ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column);
    public abstract virtual ISymbolNamespace[] GetNamespaces();
    public abstract virtual Byte[] GetSymAttribute(SymbolToken parent, string name);
    public abstract virtual ISymbolVariable[] GetVariables(SymbolToken parent);
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolScope {
    public int EndOffset { get; }
    public ISymbolMethod Method { get; }
    public ISymbolScope Parent { get; }
    public int StartOffset { get; }
    public abstract virtual int get_EndOffset();
    public abstract virtual ISymbolMethod get_Method();
    public abstract virtual ISymbolScope get_Parent();
    public abstract virtual int get_StartOffset();
    public abstract virtual ISymbolScope[] GetChildren();
    public abstract virtual ISymbolVariable[] GetLocals();
    public abstract virtual ISymbolNamespace[] GetNamespaces();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolVariable {
    public int AddressField1 { get; }
    public int AddressField2 { get; }
    public int AddressField3 { get; }
    public SymAddressKind AddressKind { get; }
    public object Attributes { get; }
    public int EndOffset { get; }
    public string Name { get; }
    public int StartOffset { get; }
    public abstract virtual int get_AddressField1();
    public abstract virtual int get_AddressField2();
    public abstract virtual int get_AddressField3();
    public abstract virtual SymAddressKind get_AddressKind();
    public abstract virtual object get_Attributes();
    public abstract virtual int get_EndOffset();
    public abstract virtual string get_Name();
    public abstract virtual int get_StartOffset();
    public abstract virtual Byte[] GetSignature();
}
[ComVisibleAttribute("True")]
public interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual void Close();
    public abstract virtual void CloseMethod();
    public abstract virtual void CloseNamespace();
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void Initialize(IntPtr emitter, string filename, bool fFullBuild);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
    public abstract virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void SetUnderlyingWriter(IntPtr underlyingWriter);
    public abstract virtual void SetUserEntryPoint(SymbolToken entryMethod);
    public abstract virtual void UsingNamespace(string fullName);
}
[ComVisibleAttribute("True")]
public enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeStackRegister;
    public static SymAddressKind BitField;
    public static SymAddressKind NativeSectionOffset;
}
[IsReadOnlyAttribute]
public class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    private int _token;
    public SymbolToken(int val);
    public int GetToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SymbolToken obj);
    public static bool op_Equality(SymbolToken a, SymbolToken b);
    public static bool op_Inequality(SymbolToken a, SymbolToken b);
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymDocumentType : object {
    public static Guid Text;
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymLanguageType : object {
    public static Guid Basic;
    public static Guid C;
    public static Guid Cobol;
    public static Guid CPlusPlus;
    public static Guid CSharp;
    public static Guid ILAssembly;
    public static Guid Java;
    public static Guid JScript;
    public static Guid MCPlusPlus;
    public static Guid Pascal;
    public static Guid SMC;
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymLanguageVendor : object {
    public static Guid Microsoft;
}
public abstract class System.Diagnostics.Tracing.DiagnosticCounter : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string DisplayName { get; public set; }
    public string DisplayUnits { get; public set; }
    public EventSource EventSource { get; }
    public string Name { get; }
    internal DiagnosticCounter(string name, EventSource eventSource);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
public string get_Name();
    public void AddMetadata(string key, string value);
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventOpcode <Opcode>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    public int EventId { get; private set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    public EventChannel Channel { get; public set; }
    public string Message { get; public set; }
    public EventTask Task { get; public set; }
    public EventTags Tags { get; public set; }
    public byte Version { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
public EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
public void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    public IDictionary`2<string, string> Arguments { get; }
    public EventCommand Command { get; }
    public IDictionary`2<string, string> get_Arguments();
    public EventCommand get_Command();
    public bool DisableEvent(int eventId);
    public bool EnableEvent(int eventId);
}
public class System.Diagnostics.Tracing.EventCounter : DiagnosticCounter {
    public EventCounter(string name, EventSource eventSource);
    public void WriteMetric(float value);
    public void WriteMetric(double value);
}
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    [MonoTODOAttribute]
public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [MonoTODOAttribute]
public EventFieldFormat Format { get; public set; }
    [MonoTODOAttribute]
public EventFieldTags Tags { get; public set; }
    public EventFieldFormat get_Format();
    public void set_Format(EventFieldFormat value);
    public EventFieldTags get_Tags();
    public void set_Tags(EventFieldTags value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Default;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat HResult;
    public static EventFieldFormat Json;
    public static EventFieldFormat String;
    public static EventFieldFormat Xml;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    public static int EventSourceIndex(EventSource eventSource);
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions AllowEventSourceOverride;
    public static EventManifestOptions None;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions Strict;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
public class System.Diagnostics.Tracing.EventSource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSourceSettings <Settings>k__BackingField;
    public Exception ConstructionException { get; }
    public static Guid CurrentThreadActivityId { get; }
    public Guid Guid { get; }
    public string Name { get; private set; }
    public EventSourceSettings Settings { get; private set; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    protected virtual override void Finalize();
    public Exception get_ConstructionException();
    public static Guid get_CurrentThreadActivityId();
    public Guid get_Guid();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public EventSourceSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(EventSourceSettings value);
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public sealed virtual void Dispose();
    public string GetTrait(string key);
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    [CLSCompliantAttribute("False")]
public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    protected virtual void Dispose(bool disposing);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    [CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static IEnumerable`1<EventSource> GetSources();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OSThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <PayloadNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    public Guid ActivityId { get; }
    public EventChannel Channel { get; }
    public int EventId { get; internal set; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    public string EventName { get; internal set; }
    public EventSource EventSource { get; private set; }
    public EventKeywords Keywords { get; }
    public EventLevel Level { get; }
    public string Message { get; internal set; }
    public EventOpcode Opcode { get; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    public Guid RelatedActivityId { get; internal set; }
    public EventTags Tags { get; }
    public EventTask Task { get; }
    public byte Version { get; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public Guid get_ActivityId();
    public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    [CompilerGeneratedAttribute]
public long get_OSThreadId();
    [CompilerGeneratedAttribute]
internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
internal void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
private void set_EventSource(EventSource value);
    public EventKeywords get_Keywords();
    public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
internal void set_Message(string value);
    public EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_PayloadNames();
    [CompilerGeneratedAttribute]
internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    public EventTags get_Tags();
    public EventTask get_Task();
    public byte get_Version();
}
public class System.Diagnostics.Tracing.IncrementingEventCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingEventCounter(string name, EventSource eventSource);
    public void Increment(double increment);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
}
public class System.Diagnostics.Tracing.IncrementingPollingCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingPollingCounter(string name, EventSource eventSource, Func`1<double> totalValueProvider);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
public class System.Diagnostics.Tracing.PollingCounter : DiagnosticCounter {
    public PollingCounter(string name, EventSource eventSource, Func`1<double> metricProvider);
}
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Double : ValueType {
    private double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    internal static double NegativeZero;
    [NonVersionableAttribute]
public static bool IsFinite(double d);
    [NonVersionableAttribute]
public static bool IsInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNaN(double d);
    [NonVersionableAttribute]
public static bool IsNegative(double d);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNormal(double d);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static bool IsSubnormal(double d);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, IFormatProvider provider);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.DTSubString : ValueType {
    internal ReadOnlySpan`1<char> s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
public class System.DuplicateWaitObjectException : ArgumentException {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_duplicateWaitObjectMessage;
    private static string DuplicateWaitObjectMessage { get; }
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    private static string get_DuplicateWaitObjectMessage();
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class System.EmptyArray`1 : object {
    public static T[] Value;
    private static EmptyArray`1();
}
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public abstract class System.Enum : ValueType {
    private static Char[] enumSeperatorCharArray;
    private static string enumSeperator;
    private static Enum();
    [SecuritySafeCriticalAttribute]
private static ValuesAndNames GetCachedValuesAndNames(RuntimeType enumType, bool getNames);
    private static string InternalFormattedHexString(object value);
    private static string InternalFormat(RuntimeType eT, object value);
    private static string InternalFlagsFormat(RuntimeType eT, object value);
    internal static ulong ToUInt64(object value);
    private static int InternalCompareTo(object o1, object o2);
    internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    private static bool GetEnumValuesAndNames(RuntimeType enumType, UInt64[]& values, String[]& names);
    private static object InternalBoxEnum(RuntimeType enumType, long value);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    [ComVisibleAttribute("True")]
public static object Parse(Type enumType, string value);
    [ComVisibleAttribute("True")]
public static object Parse(Type enumType, string value, bool ignoreCase);
    private static bool TryParseEnum(Type enumType, string value, bool ignoreCase, EnumResult& parseResult);
    [ComVisibleAttribute("True")]
public static Type GetUnderlyingType(Type enumType);
    [ComVisibleAttribute("True")]
public static Array GetValues(Type enumType);
    internal static UInt64[] InternalGetValues(RuntimeType enumType);
    [ComVisibleAttribute("True")]
public static string GetName(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static String[] GetNames(Type enumType);
    internal static String[] InternalGetNames(RuntimeType enumType);
    [ComVisibleAttribute("True")]
public static object ToObject(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static bool IsDefined(Type enumType, object value);
    [ComVisibleAttribute("True")]
public static string Format(Type enumType, object value, string format);
    private object get_value();
    [SecuritySafeCriticalAttribute]
internal object GetValue();
    private bool InternalHasFlag(Enum flags);
    private int get_hashcode();
    public virtual bool Equals(object obj);
    [SecuritySafeCriticalAttribute]
public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual int CompareTo(object target);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public bool HasFlag(Enum flag);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    [ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, sbyte value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, short value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, int value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, ushort value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public static object ToObject(Type enumType, UInt32 value);
    [ComVisibleAttribute("True")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, long value);
    [ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[SecuritySafeCriticalAttribute]
public static object ToObject(Type enumType, ulong value);
    [SecuritySafeCriticalAttribute]
private static object ToObject(Type enumType, char value);
    [SecuritySafeCriticalAttribute]
private static object ToObject(Type enumType, bool value);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(Type enumType, string value, Object& result);
}
[ComVisibleAttribute("True")]
public static class System.Environment : object {
    private static string mono_corlib_version;
    private static string nl;
    private static OperatingSystem os;
    [CompilerGeneratedAttribute]
private static PlatformID <Platform>k__BackingField;
    internal static bool IsWindows8OrAbove { get; }
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static string MachineName { get; }
    public static string NewLine { get; }
    internal static PlatformID Platform { get; }
    public static OperatingSystem OSVersion { get; }
    public static string StackTrace { get; }
    public static string SystemDirectory { get; }
    public static int TickCount { get; }
    public static string UserDomainName { get; }
    [MonoTODOAttribute("Currently always returns false, regardless of interactive state")]
public static bool UserInteractive { get; }
    public static string UserName { get; }
    public static Version Version { get; }
    [MonoTODOAttribute("Currently always returns zero")]
public static long WorkingSet { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static int SystemPageSize { get; }
    public static bool Is64BitProcess { get; }
    public static int ProcessorCount { get; }
    internal static bool IsRunningOnWindows { get; }
    private static string GacPath { get; }
    internal static bool IsUnix { get; }
    internal static bool IsMacOS { get; }
    internal static bool IsCLRHosted { get; }
    internal static bool IsWinRTSupported { get; }
    internal static string GetResourceString(string key);
    internal static string GetResourceString(string key, CultureInfo culture);
    internal static string GetResourceString(string key, Object[] values);
    internal static string GetRuntimeResourceString(string key);
    internal static string GetRuntimeResourceString(string key, Object[] values);
    internal static string GetResourceStringEncodingName(int codePage);
    internal static bool get_IsWindows8OrAbove();
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static bool get_HasShutdownStarted();
    public static string get_MachineName();
    private static string GetNewLine();
    public static string get_NewLine();
    [CompilerGeneratedAttribute]
internal static PlatformID get_Platform();
    internal static string GetOSVersionString();
    public static OperatingSystem get_OSVersion();
    internal static Version CreateVersionFromString(string info);
    public static string get_StackTrace();
    public static string get_SystemDirectory();
    public static int get_TickCount();
    public static string get_UserDomainName();
    public static bool get_UserInteractive();
    public static string get_UserName();
    public static Version get_Version();
    public static long get_WorkingSet();
    public static void Exit(int exitCode);
    internal static void _Exit(int exitCode);
    public static string ExpandEnvironmentVariables(string name);
    public static String[] GetCommandLineArgs();
    internal static string internalGetEnvironmentVariable_native(IntPtr variable);
    internal static string internalGetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable);
    private static Hashtable GetEnvironmentVariablesNoCase();
    public static IDictionary GetEnvironmentVariables();
    public static string GetFolderPath(SpecialFolder folder);
    private static string GetWindowsFolderPath(int folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    private static string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback);
    internal static string UnixGetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static String[] GetLogicalDrives();
    private static void internalBroadcastSettingChange();
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    internal static void InternalSetEnvironmentVariable(Char* variable, int variable_length, Char* value, int value_length);
    internal static void InternalSetEnvironmentVariable(string variable, string value);
    public static void FailFast(string message);
    internal static void FailFast(string message, UInt32 exitCode);
    [SecurityCriticalAttribute]
public static void FailFast(string message, Exception exception);
    internal static void FailFast(string message, Exception exception, string errorSource);
    private static bool GetIs64BitOperatingSystem();
    public static bool get_Is64BitOperatingSystem();
    public static int get_SystemPageSize();
    public static bool get_Is64BitProcess();
    public static int get_ProcessorCount();
    internal static bool get_IsRunningOnWindows();
    private static string get_GacPath();
    internal static string internalGetGacPath();
    internal static String[] GetLogicalDrivesInternal();
    private static String[] GetEnvironmentVariableNames();
    internal static string GetMachineConfigPath();
    internal static string internalGetHome();
    internal static int GetPageSize();
    private static string get_bundled_machine_config();
    internal static string GetBundledMachineConfig();
    internal static bool get_IsUnix();
    internal static bool get_IsMacOS();
    internal static bool get_IsCLRHosted();
    internal static void TriggerCodeContractFailure(ContractFailureKind failureKind, string message, string condition, string exceptionAsString);
    internal static string GetStackTrace(Exception e, bool needFileInfo);
    internal static bool get_IsWinRTSupported();
}
[ComVisibleAttribute("True")]
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
public class System.EventArgs : object {
    public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public class System.Exception : object {
    [OptionalFieldAttribute]
private static object s_EDILock;
    private string _className;
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private object _stackTrace;
    private string _stackTraceString;
    private string _remoteStackTraceString;
    private int _remoteStackIndex;
    private object _dynamicMethods;
    internal int _HResult;
    private string _source;
    [OptionalFieldAttribute]
private SafeSerializationManager _safeSerializationManager;
    internal StackTrace[] captured_traces;
    private IntPtr[] native_trace_ips;
    private int caught_in_unmanaged;
    private static int _COMPlusExceptionCode;
    public string Message { get; }
    public IDictionary Data { get; }
    public Exception InnerException { get; }
    public MethodBase TargetSite { get; }
    public string StackTrace { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    internal string RemoteStackTrace { get; }
    public int HResult { get; protected set; }
    internal bool IsTransient { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    private void Init();
    public virtual string get_Message();
    [SecuritySafeCriticalAttribute]
public virtual IDictionary get_Data();
    private static bool IsImmutableAgileException(Exception e);
    internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject);
    internal bool TryGetRestrictedLanguageErrorObject(Object& restrictedErrorObject);
    private string GetClassName();
    public virtual Exception GetBaseException();
    public sealed virtual Exception get_InnerException();
    [SecuritySafeCriticalAttribute]
public sealed virtual MethodBase get_TargetSite();
    public virtual string get_StackTrace();
    private string GetStackTrace(bool needFileInfo);
    internal void SetErrorCode(int hr);
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string ToString();
    private string ToString(bool needFileLineInfo, bool needMessage);
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Exception PrepForRemoting();
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    internal void InternalPreserveStackTrace();
    private string StripFileInfo(string stackTrace, bool isRemoteStackTrace);
    internal string get_RemoteStackTrace();
    [SecuritySafeCriticalAttribute]
internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo);
    public int get_HResult();
    protected void set_HResult(int value);
    [SecurityCriticalAttribute]
internal virtual string InternalToString();
    public sealed virtual Type GetType();
    [SecuritySafeCriticalAttribute]
internal bool get_IsTransient();
    private static bool nIsTransient(int hr);
    [SecuritySafeCriticalAttribute]
internal static string GetMessageFromNativeResources(ExceptionMessageKind kind);
    internal void SetMessage(string s);
    internal void SetStackTrace(string s);
    internal Exception FixRemotingException();
    internal static void ReportUnhandledException(Exception exception);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument dictionaryCreationThreshold;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument collection;
    public static ExceptionArgument list;
    public static ExceptionArgument match;
    public static ExceptionArgument converter;
    public static ExceptionArgument queue;
    public static ExceptionArgument stack;
    public static ExceptionArgument capacity;
    public static ExceptionArgument index;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument value;
    public static ExceptionArgument count;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument name;
    public static ExceptionArgument mode;
    public static ExceptionArgument item;
    public static ExceptionArgument options;
    public static ExceptionArgument view;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument start;
    public static ExceptionArgument pointer;
    public static ExceptionArgument ownedMemory;
    public static ExceptionArgument text;
    public static ExceptionArgument length;
    public static ExceptionArgument comparer;
    public static ExceptionArgument comparable;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument startSegment;
    public static ExceptionArgument endSegment;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument task;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
    public static ExceptionArgument culture;
    public static ExceptionArgument destination;
    public static ExceptionArgument byteOffset;
    public static ExceptionArgument minimumBufferSize;
    public static ExceptionArgument offset;
    public static ExceptionArgument values;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument s;
    public static ExceptionArgument input;
    public static ExceptionArgument format;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_ImplementIComparable;
    public static ExceptionResource Argument_InvalidType;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Argument_InvalidRegistryKeyPermissionCheck;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_RegKeyDelHive;
    public static ExceptionResource Arg_RegKeyStrLenBug;
    public static ExceptionResource Arg_RegSetStrArrNull;
    public static ExceptionResource Arg_RegSetMismatchedKind;
    public static ExceptionResource Arg_RegSubKeyAbsent;
    public static ExceptionResource Arg_RegSubKeyValueAbsent;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Serialization_InvalidOnDeser;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource Argument_InvalidArrayType;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_ItemNotExist;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource ArgumentOutOfRange_InvalidThreshold;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
    public static ExceptionResource InvalidOperation_EmptyQueue;
    public static ExceptionResource InvalidOperation_EnumOpCantHappen;
    public static ExceptionResource InvalidOperation_EnumFailedVersion;
    public static ExceptionResource InvalidOperation_EmptyStack;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource InvalidOperation_EnumNotStarted;
    public static ExceptionResource InvalidOperation_EnumEnded;
    public static ExceptionResource NotSupported_SortedListNestedWrite;
    public static ExceptionResource InvalidOperation_NoValue;
    public static ExceptionResource InvalidOperation_RegRemoveSubKey;
    public static ExceptionResource Security_RegistryPermission;
    public static ExceptionResource UnauthorizedAccess_RegistryNoWrite;
    public static ExceptionResource ObjectDisposed_RegKeyClosed;
    public static ExceptionResource NotSupported_InComparableType;
    public static ExceptionResource Argument_InvalidRegistryOptionsCheck;
    public static ExceptionResource Argument_InvalidRegistryViewCheck;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource InvalidOperation_NullArray;
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.FixedBufferExtensions : object {
    [ExtensionAttribute]
internal static string GetStringFromFixedBuffer(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static int GetFixedBufferStringLength(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static bool FixedBufferEqualsString(ReadOnlySpan`1<char> span, string value);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
public abstract class System.FormattableString : object {
    public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    internal static object EPHEMERON_TOMBSTONE;
    public static int MaxGeneration { get; }
    private static GC();
    private static int GetCollectionCount(int generation);
    private static int GetMaxGeneration();
    private static void InternalCollect(int generation);
    private static void RecordPressure(long bytesAllocated);
    internal static void register_ephemeron_array(Ephemeron[] array);
    private static object get_ephemeron_tombstone();
    internal static void GetMemoryInfo(UInt32& highMemLoadThreshold, UInt64& totalPhysicalMem, UInt32& lastRecordedMemLoad, UIntPtr& lastRecordedHeapSize, UIntPtr& lastRecordedFragmentation);
    public static long GetAllocatedBytesForCurrentThread();
    [SecurityCriticalAttribute]
public static void AddMemoryPressure(long bytesAllocated);
    [SecurityCriticalAttribute]
public static void RemoveMemoryPressure(long bytesAllocated);
    [SecuritySafeCriticalAttribute]
public static int GetGeneration(object obj);
    public static void Collect(int generation);
    [SecuritySafeCriticalAttribute]
public static void Collect();
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode);
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    [SecuritySafeCriticalAttribute]
public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static int CollectionCount(int generation);
    [ReliabilityContractAttribute("3", "2")]
public static void KeepAlive(object obj);
    [SecuritySafeCriticalAttribute]
public static int GetGeneration(WeakReference wo);
    [SecuritySafeCriticalAttribute]
public static int get_MaxGeneration();
    public static void WaitForPendingFinalizers();
    [ReliabilityContractAttribute("3", "2")]
private static void _SuppressFinalize(object o);
    [ReliabilityContractAttribute("3", "2")]
[SecuritySafeCriticalAttribute]
public static void SuppressFinalize(object obj);
    private static void _ReRegisterForFinalize(object o);
    [SecuritySafeCriticalAttribute]
public static void ReRegisterForFinalize(object obj);
    public static long GetTotalMemory(bool forceFullCollection);
    private static bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
    private static bool _CancelFullGCNotification();
    private static int _WaitForFullGCApproach(int millisecondsTimeout);
    private static int _WaitForFullGCComplete(int millisecondsTimeout);
    [SecurityCriticalAttribute]
public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    [SecurityCriticalAttribute]
public static void CancelFullGCNotification();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCApproach();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCComplete();
    [SecurityCriticalAttribute]
public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    [SecurityCriticalAttribute]
private static bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    [SecurityCriticalAttribute]
public static bool TryStartNoGCRegion(long totalSize);
    [SecurityCriticalAttribute]
public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    [SecurityCriticalAttribute]
public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    [SecurityCriticalAttribute]
public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    [SecurityCriticalAttribute]
private static EndNoGCRegionStatus EndNoGCRegionWorker();
    [SecurityCriticalAttribute]
public static void EndNoGCRegion();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`2<object, bool> _callback;
    private GCHandle _weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    private void Setup(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
    public static BidiCategory LeftToRightIsolate;
    public static BidiCategory RightToLeftIsolate;
    public static BidiCategory FirstStrongIsolate;
    public static BidiCategory PopDirectionIsolate;
}
internal class System.Globalization.Bootstring : object {
    private char delimiter;
    private int base_num;
    private int tmin;
    private int tmax;
    private int skew;
    private int damp;
    private int initial_bias;
    private int initial_n;
    public Bootstring(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN);
    public string Encode(string s, int offset);
    private char EncodeDigit(int d);
    private int DecodeDigit(char c);
    private int Adapt(int delta, int numPoints, bool firstTime);
    public string Decode(string s, int offset);
}
[ComVisibleAttribute("True")]
public abstract class System.Globalization.Calendar : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int CAL_GREGORIAN;
    internal static int CAL_GREGORIAN_US;
    internal static int CAL_JAPAN;
    internal static int CAL_TAIWAN;
    internal static int CAL_KOREA;
    internal static int CAL_HIJRI;
    internal static int CAL_THAI;
    internal static int CAL_HEBREW;
    internal static int CAL_GREGORIAN_ME_FRENCH;
    internal static int CAL_GREGORIAN_ARABIC;
    internal static int CAL_GREGORIAN_XLIT_ENGLISH;
    internal static int CAL_GREGORIAN_XLIT_FRENCH;
    internal static int CAL_JULIAN;
    internal static int CAL_JAPANESELUNISOLAR;
    internal static int CAL_CHINESELUNISOLAR;
    internal static int CAL_SAKA;
    internal static int CAL_LUNAR_ETO_CHN;
    internal static int CAL_LUNAR_ETO_KOR;
    internal static int CAL_LUNAR_ETO_ROKUYOU;
    internal static int CAL_KOREANLUNISOLAR;
    internal static int CAL_TAIWANLUNISOLAR;
    internal static int CAL_PERSIAN;
    internal static int CAL_UMALQURA;
    internal int m_currentEraValue;
    [OptionalFieldAttribute]
private bool m_isReadOnly;
    public static int CurrentEra;
    internal int twoDigitYearMax;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    internal int ID { get; }
    internal int BaseCalendarID { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    internal virtual int get_ID();
    internal virtual int get_BaseCalendarID();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public bool get_IsReadOnly();
    [ComVisibleAttribute("False")]
public virtual object Clone();
    [ComVisibleAttribute("False")]
public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    [SecuritySafeCriticalAttribute]
internal static int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal static int MAX_CALENDARS;
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    private static String[] HEBREW_MONTH_NAMES;
    private static String[] HEBREW_LEAP_MONTH_NAMES;
    private static CalendarData();
    internal CalendarData(string localeName, int calendarId, bool bUseUserOverrides);
    private void InitializeEraNames(string localeName, int calendarId);
    private static String[] GetJapaneseEraNames();
    private static String[] GetJapaneseEnglishEraNames();
    private void InitializeAbbreviatedEraNames(string localeName, int calendarId);
    internal static CalendarData GetCalendarData(int calendarId);
    private static string CalendarIdToCultureName(int calendarId);
    public static int nativeGetTwoDigitYearMax(int calID);
    private static bool nativeGetCalendarData(CalendarData data, string localeName, int calendarId);
    private bool fill_calendar_data(string localeName, int datetimeIndex);
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal class System.Globalization.CalendricalCalculationsHelper : object {
    private static double FullCircleOfArc;
    private static int HalfCircleOfArc;
    private static double TwelveHours;
    private static double Noon2000Jan01;
    internal static double MeanTropicalYearInDays;
    private static double MeanSpeedOfSun;
    private static double LongitudeSpring;
    private static double TwoDegreesAfterSpring;
    private static int SecondsPerDay;
    private static int DaysInUniformLengthCentury;
    private static int SecondsPerMinute;
    private static int MinutesPerDegree;
    private static long StartOf1810;
    private static long StartOf1900Century;
    private static Double[] Coefficients1900to1987;
    private static Double[] Coefficients1800to1899;
    private static Double[] Coefficients1700to1799;
    private static Double[] Coefficients1620to1699;
    private static Double[] LambdaCoefficients;
    private static Double[] AnomalyCoefficients;
    private static Double[] EccentricityCoefficients;
    private static Double[] Coefficients;
    private static Double[] CoefficientsA;
    private static Double[] CoefficientsB;
    private static EphemerisCorrectionAlgorithmMap[] EphemerisCorrectionTable;
    private static CalendricalCalculationsHelper();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    public static double Angle(int degrees, int minutes, double seconds);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(Double[] coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static bool IsNegative(double value);
    private static double CopySign(double value, double sign);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    internal static char HIGH_SURROGATE_START;
    internal static char HIGH_SURROGATE_END;
    internal static char LOW_SURROGATE_START;
    internal static char LOW_SURROGATE_END;
    internal static int HIGH_SURROGATE_RANGE;
    internal static int UNICODE_CATEGORY_OFFSET;
    internal static int BIDI_CATEGORY_OFFSET;
    internal static int UNICODE_PLANE01_START;
    private static ReadOnlySpan`1<byte> CategoryLevel1Index { get; }
    private static ReadOnlySpan`1<byte> CategoryLevel2Index { get; }
    private static ReadOnlySpan`1<byte> CategoryLevel3Index { get; }
    private static ReadOnlySpan`1<byte> CategoriesValue { get; }
    private static ReadOnlySpan`1<byte> NumericLevel1Index { get; }
    private static ReadOnlySpan`1<byte> NumericLevel2Index { get; }
    private static ReadOnlySpan`1<byte> NumericLevel3Index { get; }
    private static ReadOnlySpan`1<byte> NumericValues { get; }
    private static ReadOnlySpan`1<byte> DigitValues { get; }
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(StringBuilder s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static double InternalGetNumericValue(int ch);
    internal static byte InternalGetDigitValues(int ch, int offset);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static BidiCategory GetBidiCategory(StringBuilder s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
    internal static bool IsWhiteSpace(string s, int index);
    internal static bool IsWhiteSpace(char c);
    private static ReadOnlySpan`1<byte> get_CategoryLevel1Index();
    private static ReadOnlySpan`1<byte> get_CategoryLevel2Index();
    private static ReadOnlySpan`1<byte> get_CategoryLevel3Index();
    private static ReadOnlySpan`1<byte> get_CategoriesValue();
    private static ReadOnlySpan`1<byte> get_NumericLevel1Index();
    private static ReadOnlySpan`1<byte> get_NumericLevel2Index();
    private static ReadOnlySpan`1<byte> get_NumericLevel3Index();
    private static ReadOnlySpan`1<byte> get_NumericValues();
    private static ReadOnlySpan`1<byte> get_DigitValues();
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] yinfo;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int ID { get; }
    internal int BaseCalendarID { get; }
    [ComVisibleAttribute("False")]
public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetEra(DateTime time);
    internal virtual int get_ID();
    internal virtual int get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
internal class System.Globalization.CodePageDataItem : object {
    internal int m_dataIndex;
    internal int m_uiFamilyCodePage;
    internal string m_webName;
    internal string m_headerName;
    internal string m_bodyName;
    internal UInt32 m_flags;
    private static Char[] sep;
    public string WebName { get; }
    public int UIFamilyCodePage { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public UInt32 Flags { get; }
    [SecurityCriticalAttribute]
internal CodePageDataItem(int dataIndex);
    private static CodePageDataItem();
    [SecurityCriticalAttribute]
internal static string CreateString(string pStrings, UInt32 index);
    [SecuritySafeCriticalAttribute]
public string get_WebName();
    public virtual int get_UIFamilyCodePage();
    [SecuritySafeCriticalAttribute]
public string get_HeaderName();
    [SecuritySafeCriticalAttribute]
public string get_BodyName();
    public UInt32 get_Flags();
}
public class System.Globalization.CompareInfo : object {
    private static CompareOptions ValidIndexMaskOffFlags;
    private static CompareOptions ValidCompareMaskOffFlags;
    private static CompareOptions ValidHashCodeOfStringMaskOffFlags;
    private static CompareOptions ValidSortkeyCtorMaskOffFlags;
    internal static CompareInfo Invariant;
    [OptionalFieldAttribute]
private string m_name;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion m_SortVersion;
    private int culture;
    private ISimpleCollator collator;
    private static Dictionary`2<string, ISimpleCollator> collators;
    private static bool managedCollation;
    private static bool managedCollationChecked;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    private static bool UseManagedCollation { get; }
    internal CompareInfo(CultureInfo culture);
    private static CompareInfo();
    internal static int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int InvariantIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal static int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int InvariantFindString(Char* source, int sourceCount, Char* value, int valueCount, bool ignoreCase, bool start);
    private static char InvariantToUpper(char c);
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public virtual string get_Name();
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    internal int Compare(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    internal int CompareOptionNone(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    internal int CompareOptionIgnoreCase(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    internal static int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
    internal static int CompareOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    internal bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    internal bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int IndexOfOrdinal(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int IndexOf(string source, string value, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal static int GetIgnoreCaseHash(string source);
    internal int GetHashCodeOfString(string source, CompareOptions options);
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    private static bool get_UseManagedCollation();
    private ISimpleCollator GetCollator();
    private SortKey CreateSortKeyCore(string source, CompareOptions options);
    private int internal_index_switch(string s1, int sindex, int count, string s2, CompareOptions opt, bool first);
    private int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
    private int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
    private int internal_index_managed(string s, int sindex, int count, char c, CompareOptions opt, bool first);
    private int internal_index_managed(string s1, int sindex, int count, string s2, CompareOptions opt, bool first);
    private static int internal_compare_icall(Char* str1, int length1, Char* str2, int length2, CompareOptions options);
    private static int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
    private static int internal_index_icall(Char* source, int sindex, int count, Char* value, int value_length, bool first);
    private static int internal_index(string source, int sindex, int count, string value, bool first);
    private void InitSort(CultureInfo culture);
    private static int CompareStringOrdinalIgnoreCase(Char* pString1, int length1, Char* pString2, int length2);
    internal static int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    private int LastIndexOfCore(string source, string target, int startIndex, int count, CompareOptions options);
    private int IndexOfCore(string source, string target, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    private int IndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr);
    private int IndexOfOrdinalCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    private int CompareString(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    private int CompareString(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    private static bool IsSortable(Char* text, int length);
    private SortKey CreateSortKey(string source, CompareOptions options);
    private bool StartsWith(string source, string prefix, CompareOptions options);
    private bool StartsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool EndsWith(string source, string suffix, CompareOptions options);
    private bool EndsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    internal int GetHashCodeOfStringCore(string source, CompareOptions options);
    private SortVersion GetSortVersion();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private string sAM1159;
    private string sPM2359;
    private string sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) saShortTimes;
    private int iFirstDayOfWeek;
    private int iFirstWeekOfYear;
    private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) waCalendars;
    private CalendarData[] calendars;
    private string sISO639Language;
    private string sRealName;
    private bool bUseOverrides;
    private int calendarId;
    private int numberIndex;
    private int iDefaultAnsiCodePage;
    private int iDefaultOemCodePage;
    private int iDefaultMacCodePage;
    private int iDefaultEbcdicCodePage;
    private bool isRightToLeft;
    private string sListSeparator;
    private static CultureData s_Invariant;
    public static CultureData Invariant { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal string SISO639LANGNAME { get; }
    internal int IFIRSTDAYOFWEEK { get; }
    internal int IFIRSTWEEKOFYEAR { get; }
    internal string SAM1159 { get; }
    internal string SPM2359 { get; }
    internal string TimeSeparator { get; }
    internal Int32[] CalendarIds { get; }
    internal bool IsInvariantCulture { get; }
    internal string CultureName { get; }
    internal string SCOMPAREINFO { get; }
    internal string STEXTINFO { get; }
    internal int ILANGUAGE { get; }
    internal int IDEFAULTANSICODEPAGE { get; }
    internal int IDEFAULTOEMCODEPAGE { get; }
    internal int IDEFAULTMACCODEPAGE { get; }
    internal int IDEFAULTEBCDICCODEPAGE { get; }
    internal bool IsRightToLeft { get; }
    internal string SLIST { get; }
    internal bool UseUserOverride { get; }
    private CultureData(string name);
    public static CultureData get_Invariant();
    public static CultureData GetCultureData(string cultureName, bool useUserOverride);
    public static CultureData GetCultureData(string cultureName, bool useUserOverride, int datetimeIndex, int calendarId, int numberIndex, string iso2lang, int ansiCodePage, int oemCodePage, int macCodePage, int ebcdicCodePage, bool rightToLeft, string listSeparator);
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    private void fill_culture_data(int datetimeIndex);
    public CalendarData GetCalendar(int calendarId);
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    internal string get_SISO639LANGNAME();
    internal int get_IFIRSTDAYOFWEEK();
    internal int get_IFIRSTWEEKOFYEAR();
    internal string get_SAM1159();
    internal string get_SPM2359();
    internal string get_TimeSeparator();
    internal Int32[] get_CalendarIds();
    internal CalendarId[] GetCalendarIds();
    internal bool get_IsInvariantCulture();
    internal string get_CultureName();
    internal string get_SCOMPAREINFO();
    internal string get_STEXTINFO();
    internal int get_ILANGUAGE();
    internal int get_IDEFAULTANSICODEPAGE();
    internal int get_IDEFAULTOEMCODEPAGE();
    internal int get_IDEFAULTMACCODEPAGE();
    internal int get_IDEFAULTEBCDICCODEPAGE();
    internal bool get_IsRightToLeft();
    internal string get_SLIST();
    internal bool get_UseUserOverride();
    internal string CalendarName(int calendarId);
    internal String[] EraNames(int calendarId);
    internal String[] AbbrevEraNames(int calendarId);
    internal String[] AbbreviatedEnglishEraNames(int calendarId);
    internal String[] ShortDates(int calendarId);
    internal String[] LongDates(int calendarId);
    internal String[] YearMonths(int calendarId);
    internal String[] DayNames(int calendarId);
    internal String[] AbbreviatedDayNames(int calendarId);
    internal String[] SuperShortDayNames(int calendarId);
    internal String[] MonthNames(int calendarId);
    internal String[] GenitiveMonthNames(int calendarId);
    internal String[] AbbreviatedMonthNames(int calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(int calendarId);
    internal String[] LeapYearMonthNames(int calendarId);
    internal string MonthDay(int calendarId);
    internal string DateSeparator(int calendarId);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    private static string UnescapeNlsString(string str, int start, int end);
    internal static String[] ReescapeWin32Strings(String[] array);
    internal static string ReescapeWin32String(string str);
    internal static bool IsCustomCultureId(int cultureId);
    private static int strlen(Byte* s);
    private static string idx2string(Byte* data, int idx);
    private Int32[] create_group_sizes_array(int gs0, int gs1);
    internal void GetNFIValues(NumberFormatInfo nfi);
    private static Byte* fill_number_data(int index, NumberFormatEntryManaged& nfe);
}
[ComVisibleAttribute("True")]
public class System.Globalization.CultureInfo : object {
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariant_culture_info;
    private static object shared_table_lock;
    private static CultureInfo default_current_culture;
    private bool m_isReadOnly;
    private int cultureID;
    private int parent_lcid;
    private int datetime_index;
    private int number_index;
    private int default_calendar_type;
    private bool m_useUserOverride;
    internal NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) numInfo;
    internal DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) dateTimeInfo;
    private TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) textInfo;
    internal string m_name;
    private string englishname;
    private string nativename;
    private string iso3lang;
    private string iso2lang;
    private string win3lang;
    private string territory;
    private String[] native_calendar_names;
    private CompareInfo modreq(System.Runtime.CompilerServices.IsVolatile) compareInfo;
    private Void* textinfo_data;
    private int m_dataItem;
    private Calendar calendar;
    private CultureInfo parent_culture;
    private bool constructed;
    internal Byte[] cached_serialized_form;
    internal CultureData m_cultureData;
    internal bool m_isInherited;
    internal static int InvariantCultureId;
    private static int CalendarTypeBits;
    internal static int LOCALE_INVARIANT;
    private static string MSG_READONLY;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    private static Dictionary`2<int, CultureInfo> shared_by_number;
    private static Dictionary`2<string, CultureInfo> shared_by_name;
    private static CultureInfo s_UserPreferredCultureInfoInAppX;
    internal static bool IsTaiwanSku;
    internal CultureData _cultureData { get; }
    internal bool _isInherited { get; }
    public static CultureInfo InvariantCulture { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    internal string Territory { get; }
    internal string _name { get; }
    [ComVisibleAttribute("False")]
public CultureTypes CultureTypes { get; }
    [ComVisibleAttribute("False")]
public string IetfLanguageTag { get; }
    [ComVisibleAttribute("False")]
public int KeyboardLayoutId { get; }
    public int LCID { get; }
    public string Name { get; }
    public string NativeName { get; }
    internal string NativeCalendarName { get; }
    public Calendar Calendar { get; }
    [MonoLimitationAttribute("Optional calendars are not supported only default calendar is returned")]
public Calendar[] OptionalCalendars { get; }
    public CultureInfo Parent { get; }
    public TextInfo TextInfo { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public string TwoLetterISOLanguageName { get; }
    public bool UseUserOverride { get; }
    public CompareInfo CompareInfo { get; }
    public bool IsNeutralCulture { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public static CultureInfo InstalledUICulture { get; }
    public bool IsReadOnly { get; }
    internal int CalendarType { get; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    internal string SortName { get; }
    internal static CultureInfo UserDefaultUICulture { get; }
    internal static CultureInfo UserDefaultCulture { get; }
    internal bool HasInvariantCultureName { get; }
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    private CultureInfo(int culture, bool useUserOverride, bool read_only);
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    private CultureInfo(string name, bool useUserOverride, bool read_only);
    private static CultureInfo();
    internal CultureData get__cultureData();
    internal bool get__isInherited();
    public static CultureInfo get_InvariantCulture();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    internal static CultureInfo ConstructCurrentCulture();
    internal static CultureInfo ConstructCurrentUICulture();
    internal string get_Territory();
    internal string get__name();
    public CultureTypes get_CultureTypes();
    [ComVisibleAttribute("False")]
public CultureInfo GetConsoleFallbackUICulture();
    public string get_IetfLanguageTag();
    public virtual int get_KeyboardLayoutId();
    public virtual int get_LCID();
    public virtual string get_Name();
    public virtual string get_NativeName();
    internal string get_NativeCalendarName();
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public virtual CultureInfo get_Parent();
    public virtual TextInfo get_TextInfo();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual string get_TwoLetterISOLanguageName();
    public bool get_UseUserOverride();
    public void ClearCachedData();
    public virtual object Clone();
    public virtual bool Equals(object value);
    public static CultureInfo[] GetCultures(CultureTypes types);
    private Data GetTextInfoData();
    public virtual int GetHashCode();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public virtual string ToString();
    public virtual CompareInfo get_CompareInfo();
    public virtual bool get_IsNeutralCulture();
    private void CheckNeutral();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public static CultureInfo get_InstalledUICulture();
    public bool get_IsReadOnly();
    public virtual object GetFormat(Type formatType);
    private void Construct();
    private bool construct_internal_locale_from_lcid(int lcid);
    private bool construct_internal_locale_from_name(string name);
    private static string get_current_locale_name();
    private static CultureInfo[] internal_get_cultures(bool neutral, bool specific, bool installed);
    private void ConstructInvariant(bool read_only);
    private TextInfo CreateTextInfo(bool readOnly);
    private static void insert_into_shared_tables(CultureInfo c);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    [MonoTODOAttribute("Currently it ignores the altName parameter")]
public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    internal static CultureInfo CreateCulture(string name, bool reference);
    public static CultureInfo CreateSpecificCulture(string name);
    private bool ConstructLocaleFromName(string name);
    private static CultureInfo CreateSpecificCultureFromNeutral(string name);
    internal int get_CalendarType();
    private static Calendar CreateCalendar(int calendarType);
    private static Exception CreateNotFoundException(string name);
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    internal string get_SortName();
    internal static CultureInfo get_UserDefaultUICulture();
    internal static CultureInfo get_UserDefaultCulture();
    private static void InitializeUserPreferredCultureInfoInAppX(OnCultureInfoChangedDelegate onCultureInfoChangedInAppX);
    private static void SetUserPreferredCultureInfoInAppX(string name);
    [MonoPInvokeCallbackAttribute("System.Globalization.CultureInfo/OnCultureInfoChangedDelegate")]
private static void OnCultureInfoChangedInAppX(string language);
    internal static CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
    internal static void SetCultureInfoForUserPreferredLanguageInAppX(CultureInfo cultureInfo);
    internal static void CheckDomainSafetyObject(object obj, object container);
    internal bool get_HasInvariantCultureName();
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
}
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    private static string DefaultMessage { get; }
    private string FormatedInvalidCultureId { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormatedInvalidCultureId();
    public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
public class System.Globalization.DateTimeFormatInfo : object {
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    private CultureData _cultureData;
    private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private static string rfc1123Pattern;
    private static string sortableDateTimePattern;
    private static string universalSortableDateTimePattern;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    private static Char[] s_monthSpaces;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    internal static DateTimeStyles InvalidDateTimeStyles;
    private TokenHashValue[] _dtfiTokenHash;
    private static int TOKEN_HASH_SIZE;
    private static int SECOND_PRIME;
    private static string dateSeparatorOrTimeZoneOffset;
    private static string invariantDateSeparator;
    private static string invariantTimeSeparator;
    internal static string IgnorablePeriod;
    internal static string IgnorableComma;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal static string JapaneseEraStart;
    internal static string LocalTimeMark;
    internal static string GMTName;
    internal static string ZuluName;
    internal static string KoreanLangName;
    internal static string JapaneseLangName;
    internal static string EnglishLangName;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] internalGetAbbreviatedDayOfWeekNames();
    private String[] internalGetAbbreviatedDayOfWeekNamesCore();
    private String[] internalGetSuperShortDayNames();
    private String[] internalGetSuperShortDayNamesCore();
    private String[] internalGetDayOfWeekNames();
    private String[] internalGetDayOfWeekNamesCore();
    private String[] internalGetAbbreviatedMonthNames();
    private String[] internalGetAbbreviatedMonthNamesCore();
    private String[] internalGetMonthNames();
    private String[] internalGetMonthNamesCore();
    private void InitializeOverridableProperties(CultureData cultureData, int calendarId);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    private String[] internalGetGenitiveMonthNames(bool abbreviated);
    internal String[] internalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    private DateTimeFormatFlags InitializeFormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void PopulateSpecialTokenHashTable(TokenHashValue[] temp, Boolean& useDateSepAsIgnorableSymbol);
    private static bool IsJapaneseCalendar(Calendar calendar);
    private void AddMonthNames(TokenHashValue[] temp, string monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    private bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal static char MonthPostfixChar;
    internal static char IgnorableSymbolChar;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal List`1<string> m_dateWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords;
    private FoundDatePattern _ymdFlags;
    private static Dictionary`2<string, string> KnownWords { get; }
    private static Dictionary`2<string, string> get_KnownWords();
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool EqualStringArrays(String[] array1, String[] array2);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[IsReadOnlyAttribute]
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
[ComVisibleAttribute("True")]
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    internal static int LeapMonth;
    internal static int Jan1Month;
    internal static int Jan1Date;
    internal static int nDaysPerMonth;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    private static int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static int GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate);
    internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay);
    internal DateTime LunarToTime(DateTime time, int year, int month, int day);
    internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.EncodingTable : object {
    internal static InternalEncodingDataItem[] encodingDataPtr;
    internal static InternalCodePageDataItem[] codePageDataPtr;
    private static int MIMECONTF_MAILNEWS;
    private static int MIMECONTF_BROWSER;
    private static int MIMECONTF_MINIMAL;
    private static int MIMECONTF_IMPORT;
    private static int MIMECONTF_SAVABLE_MAILNEWS;
    private static int MIMECONTF_SAVABLE_BROWSER;
    private static int MIMECONTF_EXPORT;
    private static int MIMECONTF_PRIVCONVERTER;
    private static int MIMECONTF_VALID;
    private static int MIMECONTF_VALID_NLS;
    private static int MIMECONTF_MIME_IE4;
    private static int MIMECONTF_MIME_LATEST;
    private static int MIMECONTF_MIME_REGISTRY;
    private static int lastEncodingItem;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lastCodePageItem;
    private static Dictionary`2<string, int> hashByName;
    private static Dictionary`2<int, CodePageDataItem> hashByCodePage;
    [SecuritySafeCriticalAttribute]
private static EncodingTable();
    private static int GetNumEncodingItems();
    private static InternalEncodingDataItem ENC(string name, ushort cp);
    private static InternalCodePageDataItem MapCodePageDataItem(ushort cp, ushort fcp, string names, UInt32 flags);
    [SecuritySafeCriticalAttribute]
private static int internalGetCodePageFromName(string name);
    [SecuritySafeCriticalAttribute]
internal static EncodingInfo[] GetEncodings();
    internal static int GetCodePageFromName(string name);
    [SecuritySafeCriticalAttribute]
internal static CodePageDataItem GetCodePageDataItem(int codepage);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    [OptionalFieldAttribute]
internal string eraName;
    [OptionalFieldAttribute]
internal string abbrevEraName;
    [OptionalFieldAttribute]
internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
internal class System.Globalization.GlobalizationAssembly : object {
    [SecurityCriticalAttribute]
internal static Byte* GetGlobalizationResourceBytePtr(Assembly assembly, string tableName);
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
internal static class System.Globalization.GlobalizationMode : object {
    private static string c_InvariantModeConfigSwitch;
    [CompilerGeneratedAttribute]
private static bool <Invariant>k__BackingField;
    internal static bool Invariant { get; }
    private static GlobalizationMode();
    [CompilerGeneratedAttribute]
internal static bool get_Invariant();
    private static bool GetGlobalizationInvariantMode();
}
[ComVisibleAttribute("True")]
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxYear;
    internal static int MinYear;
    internal GregorianCalendarTypes m_type;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual int get_ID();
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    [OptionalFieldAttribute]
internal int m_maxYear;
    [OptionalFieldAttribute]
internal int m_minYear;
    internal Calendar m_Cal;
    [OptionalFieldAttribute]
internal EraInfo[] m_EraInfo;
    [OptionalFieldAttribute]
internal Int32[] m_eras;
    [OptionalFieldAttribute]
internal DateTime m_minDate;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    private int GetYearOffset(int year, int era, bool throwOnError);
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
[ComVisibleAttribute("True")]
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
[ComVisibleAttribute("True")]
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int DatePartDayOfWeek;
    private static int HebrewYearOf1AD;
    private static int FirstGregorianTableYear;
    private static int LastGregorianTableYear;
    private static int TABLESIZE;
    private static int MinHebrewYear;
    private static int MaxHebrewYear;
    private static Int32[] HebrewTable;
    private static Int32[0...,0...] LunarMonthLen;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    internal static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    internal static int GetResult(__DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static int minHebrewNumberCh;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPasingState;
    private static int HebrewTokenCount;
    private static HebrewNumber();
    internal static string ToString(int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
[ComVisibleAttribute("True")]
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MinAdvancedHijri;
    internal static int MaxAdvancedHijri;
    internal static Int32[] HijriMonthDays;
    private static string HijriAdvanceRegKeyEntry;
    private int m_HijriAdvance;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    [SecuritySafeCriticalAttribute]
public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    [SecurityCriticalAttribute]
private static int GetAdvanceHijriDate();
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.IdnMapping : object {
    private bool allow_unassigned;
    private bool use_std3;
    private Punycode puny;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    private string Convert(string input, int index, int count, bool toAscii);
    private string ToAscii(string s, int offset);
    private void VerifyLength(string s, int offset);
    private string NamePrep(string s, int offset);
    private void VerifyProhibitedCharacters(string s, int offset);
    private void VerifyStd3AsciiRules(string s, int offset);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    private string ToUnicode(string s, int offset);
}
internal class System.Globalization.InternalCodePageDataItem : ValueType {
    internal ushort codePage;
    internal ushort uiFamilyCodePage;
    internal UInt32 flags;
    [SecurityCriticalAttribute]
internal string Names;
}
internal class System.Globalization.InternalEncodingDataItem : ValueType {
    [SecurityCriticalAttribute]
internal string webName;
    internal ushort codePage;
}
internal class System.Globalization.InternalGlobalizationHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerTenthSecond;
    internal static long TicksPerSecond;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo10000;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    internal static long MaxTicks;
    internal static long MinTicks;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static int StringBuilderDefaultCapacity;
    internal static long MaxOffset;
    internal static long MinOffset;
    internal static long TimeToTicks(int hour, int minute, int second);
}
internal interface System.Globalization.ISimpleCollator {
    public abstract virtual SortKey GetSortKey(string source, CompareOptions options);
    public abstract virtual int Compare(string s1, string s2);
    public abstract virtual int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options);
    public abstract virtual bool IsPrefix(string src, string target, CompareOptions opt);
    public abstract virtual bool IsSuffix(string src, string target, CompareOptions opt);
    public abstract virtual int IndexOf(string s, string target, int start, int length, CompareOptions opt);
    public abstract virtual int IndexOf(string s, char target, int start, int length, CompareOptions opt);
    public abstract virtual int LastIndexOf(string s, string target, CompareOptions opt);
    public abstract virtual int LastIndexOf(string s, string target, int start, int length, CompareOptions opt);
    public abstract virtual int LastIndexOf(string s, char target, CompareOptions opt);
    public abstract virtual int LastIndexOf(string s, char target, int start, int length, CompareOptions opt);
}
public static class System.Globalization.ISOWeek : object {
    private static int WeeksInLongYear;
    private static int WeeksInShortYear;
    private static int MinWeek;
    private static int MaxWeek;
    public static int GetWeekOfYear(DateTime date);
    public static int GetYear(DateTime date);
    public static DateTime GetYearStart(int year);
    public static DateTime GetYearEnd(int year);
    public static int GetWeeksInYear(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
    private static int GetWeekNumber(DateTime date);
    private static int GetWeekday(DayOfWeek dayOfWeek);
    [CompilerGeneratedAttribute]
internal static int <GetWeeksInYear>g__P|8_0(int y);
}
[ComVisibleAttribute("True")]
public class System.Globalization.JapaneseCalendar : Calendar {
    internal static DateTime calendarMinValue;
    internal static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo;
    private static string c_japaneseErasHive;
    private static string c_japaneseErasHivePermissionList;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    [SecuritySafeCriticalAttribute]
private static EraInfo[] GetErasFromRegistry();
    private static int CompareEraRanges(EraInfo a, EraInfo b);
    private static EraInfo GetEraFromValue(string value, string data);
    internal static Calendar GetDefaultInstance();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[ComVisibleAttribute("True")]
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static int JulianDaysPerYear;
    private static int JulianDaysPer4Years;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    internal int MaxYear;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[ComVisibleAttribute("True")]
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    internal static EraInfo[] koreanEraInfo;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
[ComVisibleAttribute("True")]
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariantInfo;
    internal Int32[] numberGroupSizes;
    internal Int32[] currencyGroupSizes;
    internal Int32[] percentGroupSizes;
    internal string positiveSign;
    internal string negativeSign;
    internal string numberDecimalSeparator;
    internal string numberGroupSeparator;
    internal string currencyGroupSeparator;
    internal string currencyDecimalSeparator;
    internal string currencySymbol;
    internal string ansiCurrencySymbol;
    internal string nanSymbol;
    internal string positiveInfinitySymbol;
    internal string negativeInfinitySymbol;
    internal string percentDecimalSeparator;
    internal string percentGroupSeparator;
    internal string percentSymbol;
    internal string perMilleSymbol;
    [OptionalFieldAttribute]
internal String[] nativeDigits;
    [OptionalFieldAttribute]
internal int m_dataItem;
    internal int numberDecimalDigits;
    internal int currencyDecimalDigits;
    internal int currencyPositivePattern;
    internal int currencyNegativePattern;
    internal int numberNegativePattern;
    internal int percentPositivePattern;
    internal int percentNegativePattern;
    internal int percentDecimalDigits;
    [OptionalFieldAttribute]
internal int digitSubstitution;
    internal bool isReadOnly;
    [OptionalFieldAttribute]
internal bool m_useUserOverride;
    [OptionalFieldAttribute]
internal bool m_isInvariant;
    [OptionalFieldAttribute]
internal bool validForParseAsNumber;
    [OptionalFieldAttribute]
internal bool validForParseAsCurrency;
    private static NumberStyles InvalidNumberStyles;
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    [ComVisibleAttribute("False")]
public String[] NativeDigits { get; public set; }
    [ComVisibleAttribute("False")]
public DigitShapes DigitSubstitution { get; public set; }
    [SecuritySafeCriticalAttribute]
internal NumberFormatInfo(CultureData cultureData);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private static void VerifyDecimalSeparator(string decSep, string propertyName);
    private static void VerifyGroupSeparator(string groupSep, string propertyName);
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    internal static long PersianEpoch;
    private static int ApproximateHalfYear;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MonthsPerYear;
    internal static Int32[] DaysToMonth;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    private long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.Punycode : Bootstring {
}
[ComVisibleAttribute("True")]
public class System.Globalization.RegionInfo : object {
    private static RegionInfo currentRegion;
    private int regionId;
    private string iso2Name;
    private string iso3Name;
    private string win3Name;
    private string englishName;
    private string nativeName;
    private string currencySymbol;
    private string isoCurrencySymbol;
    private string currencyEnglishName;
    private string currencyNativeName;
    public static RegionInfo CurrentRegion { get; }
    [ComVisibleAttribute("False")]
public string CurrencyEnglishName { get; }
    public string CurrencySymbol { get; }
    [MonoTODOAttribute("DisplayName currently only returns the EnglishName")]
public string DisplayName { get; }
    public string EnglishName { get; }
    [ComVisibleAttribute("False")]
public int GeoId { get; }
    public bool IsMetric { get; }
    public string ISOCurrencySymbol { get; }
    [ComVisibleAttribute("False")]
public string NativeName { get; }
    [ComVisibleAttribute("False")]
public string CurrencyNativeName { get; }
    public string Name { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public string TwoLetterISORegionName { get; }
    public RegionInfo(int culture);
    public RegionInfo(string name);
    private RegionInfo(CultureInfo ci);
    public static RegionInfo get_CurrentRegion();
    private bool GetByTerritory(CultureInfo ci);
    private bool construct_internal_region_from_name(string name);
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencySymbol();
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public virtual int get_GeoId();
    public virtual bool get_IsMetric();
    public virtual string get_ISOCurrencySymbol();
    public virtual string get_NativeName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_Name();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual string get_TwoLetterISORegionName();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static void ClearCachedData();
}
[ComVisibleAttribute("True")]
public class System.Globalization.SortKey : object {
    private string source;
    private Byte[] key;
    private CompareOptions options;
    private int lcid;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(int lcid, string source, CompareOptions opt);
    internal SortKey(int lcid, string source, Byte[] buffer, CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength);
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortVersion : object {
    private int m_NlsVersion;
    private Guid m_SortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
[ComVisibleAttribute("True")]
public class System.Globalization.StringInfo : object {
    [OptionalFieldAttribute]
private string m_str;
    private Int32[] m_indexes;
    private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object value);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
[ComVisibleAttribute("True")]
public class System.Globalization.TaiwanCalendar : Calendar {
    internal static EraInfo[] taiwanEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    internal static DateTime calendarMinValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    internal static EraInfo[] taiwanLunisolarEraInfo;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int LunarYear, int Index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    public virtual Int32[] get_Eras();
}
[ComVisibleAttribute("True")]
public class System.Globalization.TextElementEnumerator : object {
    private string str;
    private int index;
    private int startIndex;
    private int strLen;
    private int currTextElementLen;
    [OptionalFieldAttribute]
private UnicodeCategory uc;
    [OptionalFieldAttribute]
private int charLen;
    private int endIndex;
    private int nextTextElementLen;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
public class System.Globalization.TextInfo : object {
    [OptionalFieldAttribute]
private string m_listSeparator;
    [OptionalFieldAttribute]
private bool m_isReadOnly;
    [OptionalFieldAttribute]
private string m_cultureName;
    private CultureData m_cultureData;
    private string m_textInfoName;
    private Nullable`1<bool> m_IsAsciiCasingSameAsInvariant;
    internal static TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    [OptionalFieldAttribute]
private string customCultureName;
    [OptionalFieldAttribute]
internal int m_nDataItem;
    [OptionalFieldAttribute]
internal bool m_useUserOverride;
    [OptionalFieldAttribute]
internal int m_win32LangID;
    private static int wordSeparatorMask;
    internal static TextInfo Invariant { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    [ComVisibleAttribute("False")]
public int LCID { get; }
    [ComVisibleAttribute("False")]
public string CultureName { get; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    [ComVisibleAttribute("False")]
public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    internal static TextInfo get_Invariant();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private void OnDeserialized();
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    internal static int GetHashCodeOrdinalIgnoreCase(string s);
    internal static int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy);
    [SecuritySafeCriticalAttribute]
internal static int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB);
    internal static int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    internal static int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    [ComVisibleAttribute("False")]
public virtual object Clone();
    [ComVisibleAttribute("False")]
public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    [SecuritySafeCriticalAttribute]
public virtual string get_ListSeparator();
    [ComVisibleAttribute("False")]
public virtual void set_ListSeparator(string value);
    [SecuritySafeCriticalAttribute]
public virtual char ToLower(char c);
    [SecuritySafeCriticalAttribute]
public virtual string ToLower(string str);
    private static char ToLowerAsciiInvariant(char c);
    [SecuritySafeCriticalAttribute]
public virtual char ToUpper(char c);
    [SecuritySafeCriticalAttribute]
public virtual string ToUpper(string str);
    internal static char ToUpperAsciiInvariant(char c);
    private static bool IsAscii(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    public bool get_IsRightToLeft();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecuritySafeCriticalAttribute]
internal int GetCaseInsensitiveHashCode(string str);
    [SecuritySafeCriticalAttribute]
internal int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy);
    private int GetInvariantCaseInsensitiveHashCode(string str);
    private string ToUpperInternal(string str);
    private string ToLowerInternal(string str);
    private char ToUpperInternal(char c);
    private char ToLowerInternal(char c);
    internal static int InternalCompareStringOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int lenA, int lenB);
    internal void ToLowerAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal void ToUpperAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal void ChangeCase(ReadOnlySpan`1<char> source, Span`1<char> destination, bool toUpper);
}
internal static class System.Globalization.TextInfoToLowerData : object {
    public static Char[] range_00c0_0556;
    public static Char[] range_10a0_10c5;
    public static Char[] range_1e00_1ffc;
    public static Char[] range_2160_216f;
    public static Char[] range_24b6_24cf;
    public static Char[] range_2c00_2c2e;
    public static Char[] range_2c60_2ce2;
    public static Char[] range_a640_a696;
    public static Char[] range_a722_a78b;
    private static TextInfoToLowerData();
}
internal static class System.Globalization.TextInfoToUpperData : object {
    public static Char[] range_00e0_0586;
    public static Char[] range_1e01_1ff3;
    public static Char[] range_2170_2184;
    public static Char[] range_24d0_24e9;
    public static Char[] range_2c30_2ce3;
    public static Char[] range_2d00_2d25;
    public static Char[] range_a641_a697;
    public static Char[] range_a723_a78c;
    private static TextInfoToUpperData();
}
[ComVisibleAttribute("True")]
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    internal static EraInfo[] thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    [ComVisibleAttribute("False")]
public DateTime MinSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public DateTime MaxSupportedDateTime { get; }
    [ComVisibleAttribute("False")]
public CalendarAlgorithmType AlgorithmType { get; }
    internal int ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    [ComVisibleAttribute("False")]
public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    private static void AppendNonNegativeInt32(StringBuilder sb, int n, int digits);
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static bool TryFormat(TimeSpan value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    private static StringBuilder FormatToBuilder(TimeSpan value, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    private static StringBuilder FormatStandard(TimeSpan value, bool isInvariant, ReadOnlySpan`1<char> format, Pattern pattern);
    private static StringBuilder FormatCustomized(TimeSpan value, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, StringBuilder result);
}
internal static class System.Globalization.TimeSpanParse : object {
    private static int MaxFractionDigits;
    private static int MaxDays;
    private static int MaxHours;
    private static int MaxMinutes;
    private static int MaxSeconds;
    private static int MaxFraction;
    internal static long Pow10(int pow);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    internal static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(ReadOnlySpan`1<char> input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString);
    private static bool TryParseTimeSpanConstant(ReadOnlySpan`1<char> input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    internal static void ValidateStyles(TimeSpanStyles style, string parameterName);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    internal static int MinCalendarYear;
    internal static int MaxCalendarYear;
    private static DateMapping[] HijriYearInfo;
    public static int UmAlQuraEra;
    internal static int DateCycle;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int BaseCalendarID { get; }
    internal int ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual int get_BaseCalendarID();
    internal virtual int get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    internal virtual int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[NonVersionableAttribute]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    public Guid(Byte[] b);
    public Guid(ReadOnlySpan`1<byte> b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(string g);
    private static Guid();
    public static Guid NewGuid();
    public static Guid Parse(string input);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    public static Guid ParseExact(string input, string format);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    public static bool TryParseExact(string input, string format, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    private static bool TryParseGuid(ReadOnlySpan`1<char> guidString, GuidStyles flags, GuidResult& result);
    private static bool TryParseGuidWithHexPrefix(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithNoStyle(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithDashes(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool StringToShort(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToShort(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToLong(ReadOnlySpan`1<char> str, Int32& parsePos, int flags, Int64& result, GuidResult& parseResult);
    private static ReadOnlySpan`1<char> EatAllWhitespace(ReadOnlySpan`1<char> str);
    private static bool IsHexPrefix(ReadOnlySpan`1<char> str, int i);
    private void WriteByteHelper(Span`1<byte> destination);
    public Byte[] ToByteArray();
    public bool TryWriteBytes(Span`1<byte> destination);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private int GetResult(UInt32 me, UInt32 them);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public string ToString(string format);
    private static char HexToChar(int a);
    private static int HexsToChars(Char* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(Char* guidChars, int a, int b);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static Byte[] FastNewGuidArray();
}
internal enum System.Handles : Enum {
    public int value__;
    public static Handles STD_INPUT;
    public static Handles STD_OUTPUT;
    public static Handles STD_ERROR;
}
public class System.HashCode : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static UInt32 Rol(UInt32 value, int count);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
public virtual bool Equals(object obj);
}
internal static class System.HResults : object {
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_AMBIGUOUSIMPLEMENTATION;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_BADEXEFORMAT;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_COMEMULATE;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIRECTORYNOTFOUND;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENDOFSTREAM;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FILELOAD;
    internal static int COR_E_FILENOTFOUND;
    internal static int COR_E_FORMAT;
    internal static int COR_E_HOSTPROTECTION;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INSUFFICIENTMEMORY;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_IO;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PATHTOOLONG;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SAFEHANDLEMISSINGATTRIBUTE;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SEMAPHOREFULL;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_THREADSTOP;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_UNSUPPORTEDFORMAT;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int DISP_E_OVERFLOW;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_INVALIDARG;
    internal static int E_NOTIMPL;
    internal static int E_POINTER;
    internal static int ERROR_MRM_MAP_NOT_FOUND;
    internal static int RO_E_CLOSED;
    internal static int TYPE_E_TYPEMISMATCH;
}
[GuidAttribute("27FFF232-A7A8-40dd-8D4A-734AD59FCD41")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.IAppDomainSetup {
    public string ApplicationBase { get; public set; }
    public string ApplicationName { get; public set; }
    public string CachePath { get; public set; }
    public string ConfigurationFile { get; public set; }
    public string DynamicBase { get; public set; }
    public string LicenseFile { get; public set; }
    public string PrivateBinPath { get; public set; }
    public string PrivateBinPathProbe { get; public set; }
    public string ShadowCopyDirectories { get; public set; }
    public string ShadowCopyFiles { get; public set; }
    public abstract virtual string get_ApplicationBase();
    public abstract virtual void set_ApplicationBase(string value);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_CachePath();
    public abstract virtual void set_CachePath(string value);
    public abstract virtual string get_ConfigurationFile();
    public abstract virtual void set_ConfigurationFile(string value);
    public abstract virtual string get_DynamicBase();
    public abstract virtual void set_DynamicBase(string value);
    public abstract virtual string get_LicenseFile();
    public abstract virtual void set_LicenseFile(string value);
    public abstract virtual string get_PrivateBinPath();
    public abstract virtual void set_PrivateBinPath(string value);
    public abstract virtual string get_PrivateBinPathProbe();
    public abstract virtual void set_PrivateBinPathProbe(string value);
    public abstract virtual string get_ShadowCopyDirectories();
    public abstract virtual void set_ShadowCopyDirectories(string value);
    public abstract virtual string get_ShadowCopyFiles();
    public abstract virtual void set_ShadowCopyFiles(string value);
}
public interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
internal interface System.IConsoleDriver {
    public ConsoleColor BackgroundColor { get; public set; }
    public int BufferHeight { get; public set; }
    public int BufferWidth { get; public set; }
    public bool CapsLock { get; }
    public int CursorLeft { get; public set; }
    public int CursorSize { get; public set; }
    public int CursorTop { get; public set; }
    public bool CursorVisible { get; public set; }
    public ConsoleColor ForegroundColor { get; public set; }
    public bool KeyAvailable { get; }
    public bool Initialized { get; }
    public int LargestWindowHeight { get; }
    public int LargestWindowWidth { get; }
    public bool NumberLock { get; }
    public string Title { get; public set; }
    public bool TreatControlCAsInput { get; public set; }
    public int WindowHeight { get; public set; }
    public int WindowLeft { get; public set; }
    public int WindowTop { get; public set; }
    public int WindowWidth { get; public set; }
    public abstract virtual ConsoleColor get_BackgroundColor();
    public abstract virtual void set_BackgroundColor(ConsoleColor value);
    public abstract virtual int get_BufferHeight();
    public abstract virtual void set_BufferHeight(int value);
    public abstract virtual int get_BufferWidth();
    public abstract virtual void set_BufferWidth(int value);
    public abstract virtual bool get_CapsLock();
    public abstract virtual int get_CursorLeft();
    public abstract virtual void set_CursorLeft(int value);
    public abstract virtual int get_CursorSize();
    public abstract virtual void set_CursorSize(int value);
    public abstract virtual int get_CursorTop();
    public abstract virtual void set_CursorTop(int value);
    public abstract virtual bool get_CursorVisible();
    public abstract virtual void set_CursorVisible(bool value);
    public abstract virtual ConsoleColor get_ForegroundColor();
    public abstract virtual void set_ForegroundColor(ConsoleColor value);
    public abstract virtual bool get_KeyAvailable();
    public abstract virtual bool get_Initialized();
    public abstract virtual int get_LargestWindowHeight();
    public abstract virtual int get_LargestWindowWidth();
    public abstract virtual bool get_NumberLock();
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual bool get_TreatControlCAsInput();
    public abstract virtual void set_TreatControlCAsInput(bool value);
    public abstract virtual int get_WindowHeight();
    public abstract virtual void set_WindowHeight(int value);
    public abstract virtual int get_WindowLeft();
    public abstract virtual void set_WindowLeft(int value);
    public abstract virtual int get_WindowTop();
    public abstract virtual void set_WindowTop(int value);
    public abstract virtual int get_WindowWidth();
    public abstract virtual void set_WindowWidth(int value);
    public abstract virtual void Init();
    public abstract virtual void Beep(int frequency, int duration);
    public abstract virtual void Clear();
    public abstract virtual void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public abstract virtual ConsoleKeyInfo ReadKey(bool intercept);
    public abstract virtual void ResetColor();
    public abstract virtual void SetBufferSize(int width, int height);
    public abstract virtual void SetCursorPosition(int left, int top);
    public abstract virtual void SetWindowPosition(int left, int top);
    public abstract virtual void SetWindowSize(int width, int height);
    public abstract virtual string ReadLine();
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    public virtual string ToString();
    private string ToStringFromEnd();
}
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
internal class System.InputRecord : ValueType {
    public short EventType;
    public bool KeyDown;
    public short RepeatCount;
    public short VirtualKeyCode;
    public short VirtualScanCode;
    public char Character;
    public int ControlKeyState;
    private int pad1;
    private bool pad2;
}
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    internal InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Int16 : ValueType {
    private short m_value;
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, IFormatProvider provider);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
public class System.Int32 : ValueType {
    private int m_value;
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, IFormatProvider provider);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
public class System.Int64 : ValueType {
    private long m_value;
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, IFormatProvider provider);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal enum System.InternalGCCollectionMode : Enum {
    public int value__;
    public static InternalGCCollectionMode NonBlocking;
    public static InternalGCCollectionMode Blocking;
    public static InternalGCCollectionMode Optimized;
    public static InternalGCCollectionMode Compacting;
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.IntPtr : ValueType {
    private Void* m_value;
    public static IntPtr Zero;
    public static int Size { get; }
    [ReliabilityContractAttribute("2", "1")]
public IntPtr(int value);
    [ReliabilityContractAttribute("2", "1")]
public IntPtr(long value);
    [ReliabilityContractAttribute("2", "1")]
[CLSCompliantAttribute("False")]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    [ReliabilityContractAttribute("3", "2")]
public static int get_Size();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [ReliabilityContractAttribute("3", "2")]
public int ToInt32();
    [ReliabilityContractAttribute("3", "2")]
public long ToInt64();
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
public Void* ToPointer();
    public virtual string ToString();
    public string ToString(string format);
    [ReliabilityContractAttribute("3", "2")]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [ReliabilityContractAttribute("3", "2")]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Explicit(int value);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Explicit(long value);
    [ReliabilityContractAttribute("2", "1")]
[CLSCompliantAttribute("False")]
public static IntPtr op_Explicit(Void* value);
    public static int op_Explicit(IntPtr value);
    public static long op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(IntPtr value);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr Add(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("2", "1")]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [ReliabilityContractAttribute("3", "2")]
internal bool IsNull();
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
}
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.__ConsoleStream : object {
}
internal static class System.IO.__Error : object {
    internal static void EndOfFile();
    internal static void FileNotOpen();
    internal static void StreamIsClosed();
    internal static void MemoryStreamNotExpandable();
    internal static void ReaderClosed();
    internal static void ReadNotSupported();
    internal static void SeekNotSupported();
    internal static void WrongAsyncResult();
    internal static void EndReadCalledTwice();
    internal static void EndWriteCalledTwice();
    [SecurityCriticalAttribute]
internal static string GetDisplayablePath(string path, bool isInvalidPath);
    [SecurityCriticalAttribute]
internal static void WinIOError(int errorCode, string maybeFullPath);
    internal static void WriteNotSupported();
    internal static void WriterClosed();
}
internal static class System.IO.__HResults : object {
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_PATHTOOLONG;
    public static int COR_E_IO;
}
[ComVisibleAttribute("True")]
public class System.IO.BinaryReader : object {
    private static int MaxCharBytesSize;
    private Stream m_stream;
    private Byte[] m_buffer;
    private Decoder m_decoder;
    private Byte[] m_charBytes;
    private Char[] m_singleChar;
    private Char[] m_charBuffer;
    private int m_maxCharsSize;
    private bool m_2BytesPerChar;
    private bool m_isMemoryStream;
    private bool m_leaveOpen;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    [SecuritySafeCriticalAttribute]
public virtual float ReadSingle();
    [SecuritySafeCriticalAttribute]
public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    [SecuritySafeCriticalAttribute]
public virtual int Read(Char[] buffer, int index, int count);
    [SecurityCriticalAttribute]
private int InternalReadChars(Char[] buffer, int index, int count);
    private int InternalReadOneChar();
    [SecuritySafeCriticalAttribute]
public virtual Char[] ReadChars(int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual Byte[] ReadBytes(int count);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
[ComVisibleAttribute("True")]
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Byte[] _buffer;
    private Encoding _encoding;
    private Encoder _encoder;
    [OptionalFieldAttribute]
private bool _leaveOpen;
    [OptionalFieldAttribute]
private Char[] _tmpOneCharBuffer;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    private static int LargeByteBufferSize;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual ValueTask DisposeAsync();
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    [SecuritySafeCriticalAttribute]
public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    [SecuritySafeCriticalAttribute]
public virtual void Write(float value);
    [SecuritySafeCriticalAttribute]
public virtual void Write(string value);
    protected void Write7BitEncodedInt(int value);
}
public class System.IO.BufferedStream : Stream {
    private static int MaxShadowBufferSize;
    private static int DefaultBufferSize;
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private Task`1<int> _lastSyncCompletedReadTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public Stream UnderlyingStream { get; }
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    internal SemaphoreSlim LazyEnsureAsyncActiveSemaphoreInitialized();
    private void EnsureNotClosed();
    private void EnsureCanSeek();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public Stream get_UnderlyingStream();
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<DisposeAsync>d__34")]
public virtual ValueTask DisposeAsync();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushAsyncInternal>d__38")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushRead();
    private void ClearReadBufferBeforeWrite();
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushWriteAsync>d__42")]
private Task FlushWriteAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    private int ReadFromBuffer(Span`1<byte> destination);
    private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    private Task`1<int> LastSyncCompletedReadTask(int val);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<ReadFromUnderlyingStreamAsync>d__51")]
private ValueTask`1<int> ReadFromUnderlyingStreamAsync(Memory`1<byte> buffer, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    private int ReadByteSlow();
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private int WriteToBuffer(ReadOnlySpan`1<byte> buffer);
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count, Exception& error);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<WriteToUnderlyingStreamAsync>d__63")]
private Task WriteToUnderlyingStreamAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<CopyToAsyncCore>d__71")]
private Task CopyToAsyncCore(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
internal class System.IO.CStreamReader : StreamReader {
    private TermInfoDriver driver;
    public CStreamReader(Stream stream, Encoding encoding);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] dest, int index, int count);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
internal class System.IO.CStreamWriter : StreamWriter {
    private TermInfoDriver driver;
    public CStreamWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(char val);
    public void InternalWriteString(string val);
    public void InternalWriteChar(char val);
    public void InternalWriteChars(Char[] buffer, int n);
    public virtual void Write(Char[] val);
    public virtual void Write(string val);
    public virtual void WriteLine(string val);
}
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    public static DirectoryInfo CreateDirectory(string path);
    public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<string> InternalEnumeratePaths(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static string GetDirectoryRoot(string path);
    internal static string InternalGetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static String[] GetLogicalDrives();
    public static DirectoryInfo CreateDirectory(string path, DirectorySecurity directorySecurity);
    public static DirectorySecurity GetAccessControl(string path, AccessControlSections includeSections);
    public static DirectorySecurity GetAccessControl(string path);
    public static void SetAccessControl(string path, DirectorySecurity directorySecurity);
    internal static string InsecureGetCurrentDirectory();
    internal static void InsecureSetCurrentDirectory(string path);
}
public class System.IO.DirectoryInfo : FileSystemInfo {
    public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    internal DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private DirectoryInfo(SerializationInfo info, StreamingContext context);
    private void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
    public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    public void Create();
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public DirectoryInfo get_Root();
    public void MoveTo(string destDirName);
    public virtual void Delete();
    public void Delete(bool recursive);
    public void Create(DirectorySecurity directorySecurity);
    public DirectoryInfo CreateSubdirectory(string path, DirectorySecurity directorySecurity);
    public DirectorySecurity GetAccessControl();
    public DirectorySecurity GetAccessControl(AccessControlSections includeSections);
    public void SetAccessControl(DirectorySecurity directorySecurity);
}
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
[ComVisibleAttribute("True")]
public class System.IO.DriveInfo : object {
    private string drive_format;
    private string path;
    public long AvailableFreeSpace { get; }
    public long TotalFreeSpace { get; }
    public long TotalSize { get; }
    [MonoTODOAttribute("Currently get only works on Mono/Unix; set not implemented")]
public string VolumeLabel { get; public set; }
    public string DriveFormat { get; }
    public DriveType DriveType { get; }
    public string Name { get; }
    public DirectoryInfo RootDirectory { get; }
    public bool IsReady { get; }
    private DriveInfo(string path, string fstype);
    public DriveInfo(string driveName);
    private static void GetDiskFreeSpace(string path, UInt64& availableFreeSpace, UInt64& totalSize, UInt64& totalFreeSpace);
    public long get_AvailableFreeSpace();
    public long get_TotalFreeSpace();
    public long get_TotalSize();
    public string get_VolumeLabel();
    public void set_VolumeLabel(string value);
    public string get_DriveFormat();
    public DriveType get_DriveType();
    public string get_Name();
    public DirectoryInfo get_RootDirectory();
    public bool get_IsReady();
    [MonoTODOAttribute("In windows, alldrives are 'Fixed'")]
public static DriveInfo[] GetDrives();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    private static bool GetDiskFreeSpaceInternal(Char* pathName, int pathName_length, UInt64& freeBytesAvail, UInt64& totalNumberOfBytes, UInt64& totalNumberOfFreeBytes, MonoIOError& error);
    private static bool GetDiskFreeSpaceInternal(string pathName, UInt64& freeBytesAvail, UInt64& totalNumberOfBytes, UInt64& totalNumberOfFreeBytes, MonoIOError& error);
    private static UInt32 GetDriveTypeInternal(Char* rootPathName, int rootPathName_length);
    private static UInt32 GetDriveTypeInternal(string rootPathName);
    private static string GetDriveFormatInternal(Char* rootPathName, int rootPathName_length);
    private static string GetDriveFormat(string rootPathName);
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
}
public class System.IO.DriveNotFoundException : IOException {
    public DriveNotFoundException(string message);
    public DriveNotFoundException(string message, Exception innerException);
    protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
}
public enum System.IO.DriveType : Enum {
    public int value__;
    public static DriveType Unknown;
    public static DriveType NoRootDirectory;
    public static DriveType Removable;
    public static DriveType Fixed;
    public static DriveType Network;
    public static DriveType CDRom;
    public static DriveType Ram;
}
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    internal FILE_FULL_DIR_INFORMATION* _info;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <OriginalRootDirectory>k__BackingField;
    public ReadOnlySpan`1<char> Directory { get; private set; }
    public ReadOnlySpan`1<char> RootDirectory { get; private set; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; private set; }
    public ReadOnlySpan`1<char> FileName { get; }
    public FileAttributes Attributes { get; }
    public long Length { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    internal static void Initialize(FileSystemEntry& entry, FILE_FULL_DIR_INFORMATION* info, ReadOnlySpan`1<char> directory, ReadOnlySpan`1<char> rootDirectory, ReadOnlySpan`1<char> originalRootDirectory);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ReadOnlySpan`1<char> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [CompilerGeneratedAttribute]
private void set_OriginalRootDirectory(ReadOnlySpan`1<char> value);
    public ReadOnlySpan`1<char> get_FileName();
    public FileAttributes get_Attributes();
    public long get_Length();
    public DateTimeOffset get_CreationTimeUtc();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    public FileSystemInfo ToFileSystemInfo();
    public string ToFullPath();
    public string ToSpecifiedFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    private DelegateEnumerator<TResult> _enumerator;
    private FindTransform<TResult> _transform;
    private EnumerationOptions _options;
    private string _directory;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;
    public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldIncludePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldRecursePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.IO.Enumeration.FileSystemEnumerableFactory : object {
    private static Char[] s_unixEscapeChars;
    private static FileSystemEnumerableFactory();
    internal static void NormalizeInputs(String& directory, String& expression, EnumerationOptions options);
    private static bool MatchesPattern(string expression, ReadOnlySpan`1<char> name, EnumerationOptions options);
    internal static IEnumerable`1<string> UserFiles(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserDirectories(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserEntries(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileInfo> FileInfos(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<DirectoryInfo> DirectoryInfos(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileSystemInfo> FileSystemInfos(string directory, string expression, EnumerationOptions options);
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    private static int StandardBufferSize;
    private static int MinimumBufferSize;
    private string _originalRootDirectory;
    private string _rootDirectory;
    private EnumerationOptions _options;
    private object _lock;
    private FILE_FULL_DIR_INFORMATION* _entry;
    private TResult _current;
    private IntPtr _buffer;
    private int _bufferLength;
    private IntPtr _directoryHandle;
    private string _currentPath;
    private bool _lastEntryFound;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ValueTuple`2<IntPtr, string>> _pending;
    public TResult Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    private bool GetData();
    private IntPtr CreateRelativeDirectoryHandle(ReadOnlySpan`1<char> relativePath, string fullPath);
    private void CloseDirectoryHandle();
    private IntPtr CreateDirectoryHandle(string path, bool ignoreNotFound);
    private bool ContinueOnDirectoryError(int error, bool ignoreNotFound);
    public sealed virtual bool MoveNext();
    private void FindNextEntry();
    private bool DequeueNextDirectory();
    private void InternalDispose(bool disposing);
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    protected virtual bool ContinueOnError(int error);
    public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void DirectoryFinished();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public static class System.IO.Enumeration.FileSystemName : object {
    private static Char[] s_wildcardChars;
    private static Char[] s_simpleWildcardChars;
    private static FileSystemName();
    public static string TranslateWin32Expression(string expression);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    private static bool MatchPattern(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase, bool useExtendedWildcards);
}
public class System.IO.EnumerationOptions : object {
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <CompatibleRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubdirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInaccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <AttributesToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchCasing <MatchCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnSpecialDirectories>k__BackingField;
    internal static EnumerationOptions Compatible { get; }
    private static EnumerationOptions CompatibleRecursive { get; }
    internal static EnumerationOptions Default { get; }
    public bool RecurseSubdirectories { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public int BufferSize { get; public set; }
    public FileAttributes AttributesToSkip { get; public set; }
    public MatchType MatchType { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    private static EnumerationOptions();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Compatible();
    [CompilerGeneratedAttribute]
private static EnumerationOptions get_CompatibleRecursive();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Default();
    internal static EnumerationOptions FromSearchOption(SearchOption searchOption);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubdirectories();
    [CompilerGeneratedAttribute]
public void set_RecurseSubdirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInaccessible();
    [CompilerGeneratedAttribute]
public void set_IgnoreInaccessible(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public FileAttributes get_AttributesToSkip();
    [CompilerGeneratedAttribute]
public void set_AttributesToSkip(FileAttributes value);
    [CompilerGeneratedAttribute]
public MatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(MatchType value);
    [CompilerGeneratedAttribute]
public MatchCasing get_MatchCasing();
    [CompilerGeneratedAttribute]
public void set_MatchCasing(MatchCasing value);
    [CompilerGeneratedAttribute]
public bool get_ReturnSpecialDirectories();
    [CompilerGeneratedAttribute]
public void set_ReturnSpecialDirectories(bool value);
}
internal static class System.IO.Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
public static class System.IO.File : object {
    private static int MaxByteArrayLength;
    private static Encoding s_UTF8NoBOM;
    internal static int DefaultBufferSize;
    private static Encoding UTF8NoBOM { get; }
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static void Delete(string path);
    public static bool Exists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static FileAttributes GetAttributes(string path);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    private static string InternalReadAllText(string path, Encoding encoding);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Byte[] ReadAllBytes(string path);
    private static Byte[] ReadAllBytesUnknownLength(FileStream fs);
    public static void WriteAllBytes(string path, Byte[] bytes);
    private static void InternalWriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    private static String[] InternalReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(TextWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void Move(string sourceFileName, string destFileName);
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static Encoding get_UTF8NoBOM();
    private static StreamReader AsyncStreamReader(string path, Encoding encoding);
    private static StreamWriter AsyncStreamWriter(string path, Encoding encoding, bool append);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllTextAsync>d__67")]
private static Task`1<string> InternalReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesAsync>d__71")]
private static Task`1<Byte[]> InternalReadAllBytesAsync(FileStream fs, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesUnknownLengthAsync>d__72")]
private static Task`1<Byte[]> InternalReadAllBytesUnknownLengthAsync(FileStream fs, CancellationToken cancellationToken);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllBytesAsync>d__74")]
private static Task InternalWriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllLinesAsync>d__77")]
private static Task`1<String[]> InternalReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllLinesAsync>d__80")]
private static Task InternalWriteAllLinesAsync(TextWriter writer, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllTextAsync>d__81")]
private static Task InternalWriteAllTextAsync(StreamWriter sw, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static FileStream Create(string path, int bufferSize, FileOptions options, FileSecurity fileSecurity);
    public static FileSecurity GetAccessControl(string path);
    public static FileSecurity GetAccessControl(string path, AccessControlSections includeSections);
    public static void SetAccessControl(string path, FileSecurity fileSecurity);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[FlagsAttribute]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes ReadOnly;
    public static FileAttributes Hidden;
    public static FileAttributes System;
    public static FileAttributes Directory;
    public static FileAttributes Archive;
    public static FileAttributes Device;
    public static FileAttributes Normal;
    public static FileAttributes Temporary;
    public static FileAttributes SparseFile;
    public static FileAttributes ReparsePoint;
    public static FileAttributes Compressed;
    public static FileAttributes Offline;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Encrypted;
    public static FileAttributes IntegrityStream;
    public static FileAttributes NoScrubData;
}
public class System.IO.FileInfo : FileSystemInfo {
    public long Length { get; }
    public string DirectoryName { get; }
    public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public string Name { get; }
    public FileInfo(string fileName);
    internal FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private FileInfo(SerializationInfo info, StreamingContext context);
    internal FileInfo(string fullPath, bool ignoreThis);
    public long get_Length();
    public string get_DirectoryName();
    public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public virtual void Delete();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    public void MoveTo(string destFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public void Decrypt();
    public void Encrypt();
    public FileSecurity GetAccessControl();
    public FileSecurity GetAccessControl(AccessControlSections includeSections);
    public void SetAccessControl(FileSecurity fileSecurity);
    public virtual string get_Name();
}
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
[ComVisibleAttribute("True")]
public class System.IO.FileStream : Stream {
    internal static int DefaultBufferSize;
    private static Byte[] buf_recycle;
    private static object buf_recycle_lock;
    private Byte[] buf;
    private string name;
    private SafeFileHandle safeHandle;
    private bool isExposed;
    private long append_startpos;
    private FileAccess access;
    private bool owner;
    private bool async;
    private bool canseek;
    private bool anonymous;
    private bool buf_dirty;
    private int buf_size;
    private int buf_length;
    private int buf_offset;
    private long buf_start;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool IsAsync { get; }
    public string Name { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [ObsoleteAttribute("Use SafeFileHandle instead")]
public IntPtr Handle { get; }
    public SafeFileHandle SafeFileHandle { get; }
    [ObsoleteAttribute("Use FileStream(SafeFileHandle handle, FileAccess access) instead")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("Use FileStream(SafeFileHandle handle, FileAccess access) instead")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    internal FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    [MonoLimitationAttribute("This ignores the rights parameter")]
public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options);
    [MonoLimitationAttribute("This ignores the rights and fileSecurity parameters")]
public FileStream(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity);
    internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy, bool useLongPath, bool checkHost);
    internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool isAsync, bool anonymous);
    internal FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool anonymous, FileOptions options);
    private static FileStream();
    private void Init(SafeFileHandle safeHandle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_IsAsync();
    public virtual string get_Name();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IntPtr get_Handle();
    public virtual SafeFileHandle get_SafeFileHandle();
    private void ExposeHandle();
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] array, int offset, int count);
    private int ReadInternal(Byte[] dest, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] array, int offset, int count);
    private void WriteInternal(Byte[] src, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public FileSecurity GetAccessControl();
    public void SetAccessControl(FileSecurity fileSecurity);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private int ReadSegment(Byte[] dest, int dest_offset, int count);
    private int WriteSegment(Byte[] src, int src_offset, int count);
    private void FlushBuffer();
    private void FlushBufferIfDirty();
    private void RefillBuffer();
    private int ReadData(SafeHandle safeHandle, Byte[] buf, int offset, int count);
    private void InitBuffer(int size, bool isZeroSize);
    private string GetSecureFileName(string filename);
    private string GetSecureFileName(string filename, bool full);
}
internal class System.IO.FileStreamAsyncResult : object {
    private object state;
    private bool completed;
    private bool done;
    private Exception exc;
    private ManualResetEvent wh;
    private AsyncCallback cb;
    private bool completedSynch;
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    public int OriginalCount;
    public int BytesRead;
    private AsyncCallback realcb;
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool IsCompleted { get; }
    public Exception Exception { get; }
    public bool Done { get; public set; }
    public FileStreamAsyncResult(AsyncCallback cb, object state);
    private static void CBWrapper(IAsyncResult ares);
    public void SetComplete(Exception e);
    public void SetComplete(Exception e, int nbytes);
    public void SetComplete(Exception e, int nbytes, bool synch);
    public sealed virtual object get_AsyncState();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_IsCompleted();
    public Exception get_Exception();
    public bool get_Done();
    public void set_Done(bool value);
}
internal static class System.IO.FileSystem : object {
    internal static int GENERIC_READ;
    public static void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    public static void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
    public static void CreateDirectory(string fullPath);
    public static void DeleteFile(string fullPath);
    public static bool DirectoryExists(string fullPath);
    private static bool DirectoryExists(string path, Int32& lastError);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
    public static bool FileExists(string fullPath);
    public static FileAttributes GetAttributes(string fullPath);
    public static DateTimeOffset GetCreationTime(string fullPath);
    public static FileSystemInfo GetFileSystemInfo(string fullPath, bool asDirectory);
    public static DateTimeOffset GetLastAccessTime(string fullPath);
    public static DateTimeOffset GetLastWriteTime(string fullPath);
    public static void MoveDirectory(string sourceFullPath, string destFullPath);
    public static void MoveFile(string sourceFullPath, string destFullPath);
    private static SafeFileHandle OpenHandle(string fullPath, bool asDirectory);
    public static void RemoveDirectory(string fullPath, bool recursive);
    private static void GetFindData(string fullPath, WIN32_FIND_DATA& findData);
    private static bool IsNameSurrogateReparsePoint(WIN32_FIND_DATA& data);
    private static void RemoveDirectoryRecursive(string fullPath, WIN32_FIND_DATA& findData, bool topLevel);
    private static void RemoveDirectoryInternal(string fullPath, bool topLevel, bool allowDirectoryNotEmpty);
    public static void SetAttributes(string fullPath, FileAttributes attributes);
    public static void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static String[] GetLogicalDrives();
    private static bool UnityCreateDirectory(string name);
    private static bool UnityRemoveDirectory(string fullPath);
    private static bool UnityGetFileAttributesEx(string path, WIN32_FILE_ATTRIBUTE_DATA& data);
    private static bool UnitySetFileAttributes(string fullPath, FileAttributes attributes);
    internal static IntPtr UnityCreateFile_IntPtr(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, FileMode dwCreationDisposition, int dwFlagsAndAttributes);
    private static int UnityCopyFile(string sourceFullPath, string destFullPath, bool failIfExists);
    private static bool UnityDeleteFile(string path);
    private static bool UnityMoveFile(string sourceFullPath, string destFullPath);
    private static SafeFindHandle UnityFindFirstFile(string path, WIN32_FIND_DATA& findData);
    private static bool UnityFindNextFile(SafeFindHandle handle, WIN32_FIND_DATA& findData);
}
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    private WIN32_FILE_ATTRIBUTE_DATA _data;
    private int _dataInitialized;
    protected string FullPath;
    protected string OriginalPath;
    internal string _name;
    public FileAttributes Attributes { get; public set; }
    internal bool ExistsCore { get; }
    internal DateTimeOffset CreationTimeCore { get; internal set; }
    internal DateTimeOffset LastAccessTimeCore { get; internal set; }
    internal DateTimeOffset LastWriteTimeCore { get; internal set; }
    internal long LengthCore { get; }
    internal string NormalizedPath { get; }
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    internal static FileSystemInfo Create(string fullPath, FileSystemEntry& findData);
    internal void Invalidate();
    internal void Init(FILE_FULL_DIR_INFORMATION* info);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal bool get_ExistsCore();
    internal DateTimeOffset get_CreationTimeCore();
    internal void set_CreationTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastAccessTimeCore();
    internal void set_LastAccessTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastWriteTimeCore();
    internal void set_LastWriteTimeCore(DateTimeOffset value);
    internal long get_LengthCore();
    private void EnsureDataInitialized();
    public void Refresh();
    internal string get_NormalizedPath();
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_FullName();
    public string get_Extension();
    public virtual string get_Name();
    public virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public virtual string ToString();
}
internal class System.IO.HGlobalUnmanagedMemoryStream : UnmanagedMemoryStream {
    private IntPtr ptr;
    public HGlobalUnmanagedMemoryStream(Byte* pointer, long length, IntPtr ptr);
    protected virtual void Dispose(bool disposing);
}
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    public IOException(string message, Exception innerException);
    protected IOException(SerializationInfo info, StreamingContext context);
}
public interface System.IO.IsolatedStorage.INormalizeForIsolatedStorage {
    public abstract virtual object Normalize();
}
[ComVisibleAttribute("True")]
public abstract class System.IO.IsolatedStorage.IsolatedStorage : MarshalByRefObject {
    internal IsolatedStorageScope storage_scope;
    internal object _assemblyIdentity;
    internal object _domainIdentity;
    internal object _applicationIdentity;
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("Does not currently use the manifest support")]
public object ApplicationIdentity { get; }
    public object AssemblyIdentity { get; }
    [ObsoleteAttribute]
[CLSCompliantAttribute("False")]
public ulong CurrentSize { get; }
    public object DomainIdentity { get; }
    [ObsoleteAttribute]
[CLSCompliantAttribute("False")]
public ulong MaximumSize { get; }
    public IsolatedStorageScope Scope { get; }
    [ComVisibleAttribute("False")]
public long AvailableFreeSpace { get; }
    [ComVisibleAttribute("False")]
public long Quota { get; }
    [ComVisibleAttribute("False")]
public long UsedSize { get; }
    protected char SeparatorExternal { get; }
    protected char SeparatorInternal { get; }
    public object get_ApplicationIdentity();
    public object get_AssemblyIdentity();
    public virtual ulong get_CurrentSize();
    public object get_DomainIdentity();
    public virtual ulong get_MaximumSize();
    public IsolatedStorageScope get_Scope();
    public virtual long get_AvailableFreeSpace();
    public virtual long get_Quota();
    public virtual long get_UsedSize();
    protected virtual char get_SeparatorExternal();
    protected virtual char get_SeparatorInternal();
    protected virtual IsolatedStoragePermission GetPermission(PermissionSet ps);
    protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    [MonoTODOAttribute("requires manifest support")]
protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType);
    public abstract virtual void Remove();
    [ComVisibleAttribute("False")]
public virtual bool IncreaseQuotaTo(long newQuotaSize);
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageException : Exception {
    public IsolatedStorageException(string message);
    public IsolatedStorageException(string message, Exception inner);
    protected IsolatedStorageException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageFile : IsolatedStorage {
    private bool _resolved;
    private ulong _maxSize;
    private Evidence _fullEvidences;
    private static Mutex mutex;
    private bool closed;
    private bool disposed;
    private DirectoryInfo directory;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute]
public ulong CurrentSize { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute]
public ulong MaximumSize { get; }
    internal string Root { get; }
    [ComVisibleAttribute("False")]
public long AvailableFreeSpace { get; }
    [ComVisibleAttribute("False")]
public long Quota { get; }
    [ComVisibleAttribute("False")]
public long UsedSize { get; }
    [ComVisibleAttribute("False")]
public static bool IsEnabled { get; }
    internal bool IsClosed { get; }
    internal bool IsDisposed { get; }
    private IsolatedStorageFile(IsolatedStorageScope scope);
    internal IsolatedStorageFile(IsolatedStorageScope scope, string location);
    private static IsolatedStorageFile();
    public static IEnumerator GetEnumerator(IsolatedStorageScope scope);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Evidence domainEvidence, Type domainEvidenceType, Evidence assemblyEvidence, Type assemblyEvidenceType);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity);
    public static IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType);
    public static IsolatedStorageFile GetMachineStoreForApplication();
    public static IsolatedStorageFile GetMachineStoreForAssembly();
    public static IsolatedStorageFile GetMachineStoreForDomain();
    public static IsolatedStorageFile GetUserStoreForApplication();
    public static IsolatedStorageFile GetUserStoreForAssembly();
    public static IsolatedStorageFile GetUserStoreForDomain();
    [ComVisibleAttribute("False")]
public static IsolatedStorageFile GetUserStoreForSite();
    public static void Remove(IsolatedStorageScope scope);
    internal static string GetIsolatedStorageRoot(IsolatedStorageScope scope);
    private static void Demand(IsolatedStorageScope scope);
    private static IsolatedStorageContainment ScopeToContainment(IsolatedStorageScope scope);
    internal static ulong GetDirectorySize(DirectoryInfo di);
    protected virtual override void Finalize();
    private void PostInit();
    public virtual ulong get_CurrentSize();
    public virtual ulong get_MaximumSize();
    internal string get_Root();
    public virtual long get_AvailableFreeSpace();
    public virtual long get_Quota();
    public virtual long get_UsedSize();
    public static bool get_IsEnabled();
    internal bool get_IsClosed();
    internal bool get_IsDisposed();
    public void Close();
    public void CreateDirectory(string dir);
    [ComVisibleAttribute("False")]
public void CopyFile(string sourceFileName, string destinationFileName);
    [ComVisibleAttribute("False")]
public void CopyFile(string sourceFileName, string destinationFileName, bool overwrite);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream CreateFile(string path);
    public void DeleteDirectory(string dir);
    public void DeleteFile(string file);
    public sealed virtual void Dispose();
    [ComVisibleAttribute("False")]
public bool DirectoryExists(string path);
    [ComVisibleAttribute("False")]
public bool FileExists(string path);
    [ComVisibleAttribute("False")]
public DateTimeOffset GetCreationTime(string path);
    [ComVisibleAttribute("False")]
public DateTimeOffset GetLastAccessTime(string path);
    [ComVisibleAttribute("False")]
public DateTimeOffset GetLastWriteTime(string path);
    public String[] GetDirectoryNames(string searchPattern);
    [ComVisibleAttribute("False")]
public String[] GetDirectoryNames();
    private String[] GetNames(FileSystemInfo[] afsi);
    public String[] GetFileNames(string searchPattern);
    [ComVisibleAttribute("False")]
public String[] GetFileNames();
    [ComVisibleAttribute("False")]
public virtual bool IncreaseQuotaTo(long newQuotaSize);
    [ComVisibleAttribute("False")]
public void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName);
    [ComVisibleAttribute("False")]
public void MoveFile(string sourceFileName, string destinationFileName);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access);
    [ComVisibleAttribute("False")]
public IsolatedStorageFileStream OpenFile(string path, FileMode mode, FileAccess access, FileShare share);
    public virtual void Remove();
    protected virtual IsolatedStoragePermission GetPermission(PermissionSet ps);
    private void CheckOpen();
    private void CheckOpen(bool checkDirExists);
    private bool IsPathInStorage(string path);
    private string GetNameFromIdentity(object identity);
    private static object GetTypeFromEvidence(Evidence e, Type t);
    internal static object GetAssemblyIdentityFromEvidence(Evidence e);
    internal static object GetDomainIdentityFromEvidence(Evidence e);
    private void SaveIdentities(string root);
}
internal class System.IO.IsolatedStorage.IsolatedStorageFileEnumerator : object {
    private IsolatedStorageScope _scope;
    private String[] _storages;
    private int _pos;
    public object Current { get; }
    public IsolatedStorageFileEnumerator(IsolatedStorageScope scope, string root);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
public class System.IO.IsolatedStorage.IsolatedStorageFileStream : FileStream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    [ObsoleteAttribute("Use SafeFileHandle - once available")]
public IntPtr Handle { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public IsolatedStorageFileStream(string path, FileMode mode);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf);
    public IsolatedStorageFileStream(string path, FileMode mode, IsolatedStorageFile isf);
    private static string CreateIsolatedPath(IsolatedStorageFile isf, string path, FileMode mode);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual IntPtr get_Handle();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
}
[FlagsAttribute]
public enum System.IO.IsolatedStorage.IsolatedStorageScope : Enum {
    public int value__;
    public static IsolatedStorageScope None;
    public static IsolatedStorageScope User;
    public static IsolatedStorageScope Domain;
    public static IsolatedStorageScope Assembly;
    public static IsolatedStorageScope Roaming;
    public static IsolatedStorageScope Machine;
    public static IsolatedStorageScope Application;
}
public enum System.IO.IsolatedStorage.IsolatedStorageSecurityOptions : Enum {
    public int value__;
    public static IsolatedStorageSecurityOptions IncreaseQuotaForApplication;
}
public class System.IO.IsolatedStorage.IsolatedStorageSecurityState : SecurityState {
    public IsolatedStorageSecurityOptions Options { get; }
    public long Quota { get; public set; }
    public long UsedSize { get; }
    public IsolatedStorageSecurityOptions get_Options();
    public long get_Quota();
    public void set_Quota(long value);
    public long get_UsedSize();
    public virtual void EnsureState();
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    private static int MemStreamMaxLength;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    internal void InternalGetOriginAndLength(Int32& origin, Int32& length);
    internal int InternalGetPosition();
    internal int InternalReadInt32();
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
internal enum System.IO.MonoFileType : Enum {
    public int value__;
    public static MonoFileType Unknown;
    public static MonoFileType Disk;
    public static MonoFileType Char;
    public static MonoFileType Pipe;
    public static MonoFileType Remote;
}
internal static class System.IO.MonoIO : object {
    public static int FileAlreadyExistsHResult;
    public static FileAttributes InvalidFileAttributes;
    public static IntPtr InvalidHandle;
    private static bool dump_handles;
    public static IntPtr ConsoleOutput { get; }
    public static IntPtr ConsoleInput { get; }
    public static IntPtr ConsoleError { get; }
    public static char VolumeSeparatorChar { get; }
    public static char DirectorySeparatorChar { get; }
    public static char AltDirectorySeparatorChar { get; }
    public static char PathSeparator { get; }
    private static MonoIO();
    public static Exception GetException(MonoIOError error);
    public static Exception GetException(string path, MonoIOError error);
    private static bool CreateDirectory(Char* path, MonoIOError& error);
    public static bool CreateDirectory(string path, MonoIOError& error);
    private static bool RemoveDirectory(Char* path, MonoIOError& error);
    public static bool RemoveDirectory(string path, MonoIOError& error);
    public static string GetCurrentDirectory(MonoIOError& error);
    private static bool SetCurrentDirectory(Char* path, MonoIOError& error);
    public static bool SetCurrentDirectory(string path, MonoIOError& error);
    private static bool MoveFile(Char* path, Char* dest, MonoIOError& error);
    public static bool MoveFile(string path, string dest, MonoIOError& error);
    private static bool CopyFile(Char* path, Char* dest, bool overwrite, MonoIOError& error);
    public static bool CopyFile(string path, string dest, bool overwrite, MonoIOError& error);
    private static bool DeleteFile(Char* path, MonoIOError& error);
    public static bool DeleteFile(string path, MonoIOError& error);
    private static bool ReplaceFile(Char* sourceFileName, Char* destinationFileName, Char* destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError& error);
    public static bool ReplaceFile(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError& error);
    private static FileAttributes GetFileAttributes(Char* path, MonoIOError& error);
    public static FileAttributes GetFileAttributes(string path, MonoIOError& error);
    private static bool SetFileAttributes(Char* path, FileAttributes attrs, MonoIOError& error);
    public static bool SetFileAttributes(string path, FileAttributes attrs, MonoIOError& error);
    private static MonoFileType GetFileType(IntPtr handle, MonoIOError& error);
    public static MonoFileType GetFileType(SafeHandle safeHandle, MonoIOError& error);
    private static IntPtr FindFirstFile(Char* pathWithPattern, String& fileName, Int32& fileAttr, Int32& error);
    public static IntPtr FindFirstFile(string pathWithPattern, String& fileName, Int32& fileAttr, Int32& error);
    public static bool FindNextFile(IntPtr hnd, String& fileName, Int32& fileAttr, Int32& error);
    public static bool FindCloseFile(IntPtr hnd);
    public static bool Exists(string path, MonoIOError& error);
    public static bool ExistsFile(string path, MonoIOError& error);
    public static bool ExistsDirectory(string path, MonoIOError& error);
    public static bool ExistsSymlink(string path, MonoIOError& error);
    private static bool GetFileStat(Char* path, MonoIOStat& stat, MonoIOError& error);
    public static bool GetFileStat(string path, MonoIOStat& stat, MonoIOError& error);
    private static IntPtr Open(Char* filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError& error);
    public static IntPtr Open(string filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError& error);
    private static bool Cancel_internal(IntPtr handle, MonoIOError& error);
    internal static bool Cancel(SafeHandle safeHandle, MonoIOError& error);
    public static bool Close(IntPtr handle, MonoIOError& error);
    private static int Read(IntPtr handle, Byte[] dest, int dest_offset, int count, MonoIOError& error);
    public static int Read(SafeHandle safeHandle, Byte[] dest, int dest_offset, int count, MonoIOError& error);
    private static int Write(IntPtr handle, Byte[] src, int src_offset, int count, MonoIOError& error);
    public static int Write(SafeHandle safeHandle, Byte[] src, int src_offset, int count, MonoIOError& error);
    private static long Seek(IntPtr handle, long offset, SeekOrigin origin, MonoIOError& error);
    public static long Seek(SafeHandle safeHandle, long offset, SeekOrigin origin, MonoIOError& error);
    private static bool Flush(IntPtr handle, MonoIOError& error);
    public static bool Flush(SafeHandle safeHandle, MonoIOError& error);
    private static long GetLength(IntPtr handle, MonoIOError& error);
    public static long GetLength(SafeHandle safeHandle, MonoIOError& error);
    private static bool SetLength(IntPtr handle, long length, MonoIOError& error);
    public static bool SetLength(SafeHandle safeHandle, long length, MonoIOError& error);
    private static bool SetFileTime(IntPtr handle, long creation_time, long last_access_time, long last_write_time, MonoIOError& error);
    public static bool SetFileTime(SafeHandle safeHandle, long creation_time, long last_access_time, long last_write_time, MonoIOError& error);
    public static bool SetFileTime(string path, long creation_time, long last_access_time, long last_write_time, MonoIOError& error);
    public static bool SetCreationTime(string path, DateTime dateTime, MonoIOError& error);
    public static bool SetLastAccessTime(string path, DateTime dateTime, MonoIOError& error);
    public static bool SetLastWriteTime(string path, DateTime dateTime, MonoIOError& error);
    public static bool SetFileTime(string path, int type, long creation_time, long last_access_time, long last_write_time, DateTime dateTime, MonoIOError& error);
    private static void Lock(IntPtr handle, long position, long length, MonoIOError& error);
    public static void Lock(SafeHandle safeHandle, long position, long length, MonoIOError& error);
    private static void Unlock(IntPtr handle, long position, long length, MonoIOError& error);
    public static void Unlock(SafeHandle safeHandle, long position, long length, MonoIOError& error);
    public static IntPtr get_ConsoleOutput();
    public static IntPtr get_ConsoleInput();
    public static IntPtr get_ConsoleError();
    public static bool CreatePipe(IntPtr& read_handle, IntPtr& write_handle, MonoIOError& error);
    public static bool DuplicateHandle(IntPtr source_process_handle, IntPtr source_handle, IntPtr target_process_handle, IntPtr& target_handle, int access, int inherit, int options, MonoIOError& error);
    public static char get_VolumeSeparatorChar();
    public static char get_DirectorySeparatorChar();
    public static char get_AltDirectorySeparatorChar();
    public static char get_PathSeparator();
    private static void DumpHandles();
    public static bool RemapPath(string path, String& newPath);
}
internal enum System.IO.MonoIOError : Enum {
    public int value__;
    public static MonoIOError ERROR_SUCCESS;
    public static MonoIOError ERROR_FILE_NOT_FOUND;
    public static MonoIOError ERROR_PATH_NOT_FOUND;
    public static MonoIOError ERROR_TOO_MANY_OPEN_FILES;
    public static MonoIOError ERROR_ACCESS_DENIED;
    public static MonoIOError ERROR_INVALID_HANDLE;
    public static MonoIOError ERROR_INVALID_DRIVE;
    public static MonoIOError ERROR_NOT_SAME_DEVICE;
    public static MonoIOError ERROR_NO_MORE_FILES;
    public static MonoIOError ERROR_NOT_READY;
    public static MonoIOError ERROR_WRITE_FAULT;
    public static MonoIOError ERROR_READ_FAULT;
    public static MonoIOError ERROR_GEN_FAILURE;
    public static MonoIOError ERROR_SHARING_VIOLATION;
    public static MonoIOError ERROR_LOCK_VIOLATION;
    public static MonoIOError ERROR_HANDLE_DISK_FULL;
    public static MonoIOError ERROR_NOT_SUPPORTED;
    public static MonoIOError ERROR_FILE_EXISTS;
    public static MonoIOError ERROR_CANNOT_MAKE;
    public static MonoIOError ERROR_INVALID_PARAMETER;
    public static MonoIOError ERROR_BROKEN_PIPE;
    public static MonoIOError ERROR_INVALID_NAME;
    public static MonoIOError ERROR_DIR_NOT_EMPTY;
    public static MonoIOError ERROR_ALREADY_EXISTS;
    public static MonoIOError ERROR_FILENAME_EXCED_RANGE;
    public static MonoIOError ERROR_DIRECTORY;
    public static MonoIOError ERROR_ENCRYPTION_FAILED;
}
internal class System.IO.MonoIOStat : ValueType {
    public FileAttributes fileAttributes;
    public long Length;
    public long CreationTime;
    public long LastAccessTime;
    public long LastWriteTime;
}
[ExtensionAttribute]
internal static class System.IO.MonoLinqHelper : object {
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> source);
}
[ComVisibleAttribute("True")]
public static class System.IO.Path : object {
    [ObsoleteAttribute("see GetInvalidPathChars and GetInvalidFileNameChars methods.")]
public static Char[] InvalidPathChars;
    public static char AltDirectorySeparatorChar;
    public static char DirectorySeparatorChar;
    public static char PathSeparator;
    internal static string DirectorySeparatorStr;
    public static char VolumeSeparatorChar;
    internal static Char[] PathSeparatorChars;
    private static bool dirEqualsVolume;
    internal static int MAX_PATH;
    internal static Char[] trimEndCharsWindows;
    internal static Char[] trimEndCharsUnix;
    internal static string DirectorySeparatorCharAsString { get; }
    internal static Char[] TrimEndChars { get; }
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static bool IsWindows { get; }
    private static Path();
    public static string ChangeExtension(string path, string extension);
    public static string Combine(string path1, string path2);
    internal static string CleanPath(string s);
    public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    public static string GetExtension(string path);
    public static string GetFileName(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetFullPath(string path);
    internal static string GetFullPathInternal(string path);
    private static int GetFullPathName(string path, int numBufferChars, StringBuilder buffer, IntPtr& lpFilePartOrNull);
    internal static string GetFullPathName(string path);
    internal static string WindowsDriveAdjustment(string path);
    internal static string InsecureGetFullPath(string path);
    internal static bool IsDirectorySeparator(char c);
    public static string GetPathRoot(string path);
    public static string GetTempFileName();
    public static string GetTempPath();
    private static string get_temp_path();
    public static bool HasExtension(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    public static bool IsPathRooted(string path);
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetRandomFileName();
    private static int findExtension(string path);
    private static string GetServerAndShare(string path);
    private static bool SameRoot(string root, string path);
    private static string CanonicalizePath(string path);
    internal static bool IsPathSubsetOf(string subset, string path);
    public static string Combine(String[] paths);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    internal static void Validate(string path);
    internal static void Validate(string path, string parameterName);
    internal static string get_DirectorySeparatorCharAsString();
    internal static Char[] get_TrimEndChars();
    internal static void CheckSearchPattern(string searchPattern);
    internal static void CheckInvalidPathChars(string path, bool checkAdditional);
    internal static string InternalCombine(string path1, string path2);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool get_IsWindows();
    public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    public static string GetFullPath(string path, string basePath);
    private static string CombineInternal(string first, string second);
}
internal static class System.IO.PathInternal : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    private static bool s_isCaseSensitive;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static PathInternal();
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static bool HasWildCardCharacters(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool GetIsCaseSensitive();
    public static bool IsPartiallyQualified(string path);
    public static bool HasIllegalCharacters(string path, bool checkAdditional);
}
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal class System.IO.SearchPattern : object {
    internal static Char[] WildcardChars;
    private static SearchPattern();
}
internal enum System.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private static int DefaultCopyBufferSize;
    private ReadWriteTask _activeReadWriteTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<CopyToAsyncInternal>d__28")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    private int GetCopyBufferSize();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<FinishWriteAsync>d__57")]
private Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
    private bool HasOverriddenBeginEndRead();
    private bool HasOverriddenBeginEndWrite();
    public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.IO.Stream/<<ReadAsync>g__FinishReadAsync|44_0>d")]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|44_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    private static int DefaultBufferSize;
    private static int DefaultFileStreamBufferSize;
    private static int MinBufferSize;
    private Stream _stream;
    private Encoding _encoding;
    private Decoder _decoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private int _byteLen;
    private int _bytePos;
    private int _maxCharsPerBuffer;
    private bool _detectEncoding;
    private bool _checkPreamble;
    private bool _isBlocked;
    private bool _closable;
    private Task _asyncReadTask;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    private static StreamReader();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    internal void Init(Stream stream);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    private void CompressBuffer(int n);
    private void DetectEncoding();
    private bool IsPreamble();
    internal virtual int ReadBuffer();
    private int ReadBuffer(Span`1<char> userBuffer, Boolean& readToUserBuffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadLineAsyncInternal>d__61")]
private Task`1<string> ReadLineAsyncInternal();
    public virtual Task`1<string> ReadToEndAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadToEndAsyncInternal>d__63")]
private Task`1<string> ReadToEndAsyncInternal();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__66")]
internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadBufferAsync>d__69")]
private Task`1<int> ReadBufferAsync();
    internal bool DataAvailable();
}
public class System.IO.StreamWriter : TextWriter {
    internal static int DefaultBufferSize;
    private static int DefaultFileStreamBufferSize;
    private static int MinBufferSize;
    private static int DontCopyOnWriteLineThreshold;
    public static StreamWriter Null;
    private Stream _stream;
    private Encoding _encoding;
    private Encoder _encoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private bool _autoFlush;
    private bool _haveWrittenPreamble;
    private bool _closable;
    private Task _asyncWriteTask;
    private static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    unknown bool HaveWrittenPreamble {internal set; }
    public Encoding Encoding { get; }
    unknown int CharPos_Prop {private set; }
    unknown bool HaveWrittenPreamble_Prop {private set; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    private static StreamWriter();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private static Encoding get_UTF8NoBOM();
    private void Init(Stream streamArg, Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<DisposeAsyncCore>d__33")]
private ValueTask DisposeAsyncCore();
    private void CloseStreamFromDispose(bool disposing);
    public virtual void Flush();
    private void Flush(bool flushStream, bool flushEncoder);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    internal void set_HaveWrittenPreamble(bool value);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    private void WriteSpan(ReadOnlySpan`1<char> buffer, bool appendNewLine);
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> value);
    public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__57")]
private static Task WriteAsyncInternal(StreamWriter _this, char value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(string value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__59")]
private static Task WriteAsyncInternal(StreamWriter _this, string value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__62")]
private static Task WriteAsyncInternal(StreamWriter _this, ReadOnlyMemory`1<char> source, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    private void set_CharPos_Prop(int value);
    private void set_HaveWrittenPreamble_Prop(bool value);
    private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, Char[] sCharBuffer, int sCharPos, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<FlushAsyncInternal>d__74")]
private static Task FlushAsyncInternal(StreamWriter _this, bool flushStream, bool flushEncoder, Char[] charBuffer, int charPos, bool haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream stream, CancellationToken cancellationToken);
}
[ComVisibleAttribute("True")]
public class System.IO.StringReader : TextReader {
    private string _s;
    private int _pos;
    private int _length;
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadLineAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<string> ReadToEndAsync();
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
}
[ComVisibleAttribute("True")]
public class System.IO.StringWriter : TextWriter {
    private static UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) m_encoding;
    private StringBuilder _sb;
    private bool _isOpen;
    public Encoding Encoding { get; }
    public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual StringBuilder GetStringBuilder();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(char value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(string value);
    [ComVisibleAttribute("False")]
public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [ComVisibleAttribute("False")]
public virtual Task FlushAsync();
    public virtual string ToString();
}
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__14")]
public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadBlockAsyncInternal>d__20")]
internal ValueTask`1<int> ReadBlockAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    private static Char[] s_coreNewLine;
    protected Char[] CoreNewLine;
    private string CoreNewLineStr;
    private IFormatProvider _internalFormatProvider;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
}
internal class System.IO.UnexceptionalStreamReader : StreamReader {
    private static Boolean[] newline;
    private static char newlineChar;
    private static UnexceptionalStreamReader();
    public UnexceptionalStreamReader(Stream stream, Encoding encoding);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] dest_buffer, int index, int count);
    private bool CheckEOL(char current);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
internal class System.IO.UnexceptionalStreamWriter : StreamWriter {
    public UnexceptionalStreamWriter(Stream stream, Encoding encoding);
    public virtual void Flush();
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(char value);
    public virtual void Write(Char[] value);
    public virtual void Write(string value);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private SafeBuffer _buffer;
    private Byte* _mem;
    private long _length;
    private long _capacity;
    private long _position;
    private long _offset;
    private FileAccess _access;
    internal bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed();
    private void EnsureReadable();
    private void EnsureWriteable();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.IRuntimeMethodInfo {
    public RuntimeMethodHandleInternal Value { get; }
    public abstract virtual RuntimeMethodHandleInternal get_Value();
}
public interface System.IServiceProvider {
    public abstract virtual object GetService(Type serviceType);
}
internal interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
internal static class System.KnownTerminals : object {
    public static Byte[] linux { get; }
    public static Byte[] xterm { get; }
    public static Byte[] ansi { get; }
    public static Byte[] get_linux();
    public static Byte[] get_xterm();
    public static Byte[] get_ansi();
}
[DebuggerTypeProxyAttribute("System.LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static object CreateViaDefaultConstructor(Type type);
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    private byte _val;
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
internal class System.LocalDataStore : object {
    private LocalDataStoreElement[] m_DataTable;
    private LocalDataStoreMgr m_Manager;
    public LocalDataStore(LocalDataStoreMgr mgr, int InitialCapacity);
    internal void Dispose();
    public object GetData(LocalDataStoreSlot slot);
    public void SetData(LocalDataStoreSlot slot, object data);
    internal void FreeData(int slot, long cookie);
    [SecuritySafeCriticalAttribute]
private LocalDataStoreElement PopulateElement(LocalDataStoreSlot slot);
}
internal class System.LocalDataStoreElement : object {
    private object m_value;
    private long m_cookie;
    public object Value { get; public set; }
    public long Cookie { get; }
    public LocalDataStoreElement(long cookie);
    public object get_Value();
    public void set_Value(object value);
    public long get_Cookie();
}
internal class System.LocalDataStoreHolder : object {
    private LocalDataStore m_Store;
    public LocalDataStore Store { get; }
    public LocalDataStoreHolder(LocalDataStore store);
    protected virtual override void Finalize();
    public LocalDataStore get_Store();
}
internal class System.LocalDataStoreMgr : object {
    private static int InitialSlotTableSize;
    private static int SlotTableDoubleThreshold;
    private static int LargeSlotTableSizeIncrease;
    private Boolean[] m_SlotInfoTable;
    private int m_FirstAvailableSlot;
    private List`1<LocalDataStore> m_ManagedLocalDataStores;
    private Dictionary`2<string, LocalDataStoreSlot> m_KeyToSlotMap;
    private long m_CookieGenerator;
    [SecuritySafeCriticalAttribute]
public LocalDataStoreHolder CreateLocalDataStore();
    [SecuritySafeCriticalAttribute]
public void DeleteLocalDataStore(LocalDataStore store);
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot AllocateDataSlot();
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot AllocateNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
public LocalDataStoreSlot GetNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
public void FreeNamedDataSlot(string name);
    [SecuritySafeCriticalAttribute]
internal void FreeDataSlot(int slot, long cookie);
    public void ValidateSlot(LocalDataStoreSlot slot);
    internal int GetSlotTableLength();
}
[ComVisibleAttribute("True")]
public class System.LocalDataStoreSlot : object {
    private LocalDataStoreMgr m_mgr;
    private int m_slot;
    private long m_cookie;
    internal LocalDataStoreMgr Manager { get; }
    internal int Slot { get; }
    internal long Cookie { get; }
    internal LocalDataStoreSlot(LocalDataStoreMgr mgr, int slot, long cookie);
    internal LocalDataStoreMgr get_Manager();
    internal int get_Slot();
    internal long get_Cookie();
    protected virtual override void Finalize();
}
[ComVisibleAttribute("True")]
public abstract class System.MarshalByRefObject : object {
    private ServerIdentity _identity;
    internal ServerIdentity ObjectIdentity { get; internal set; }
    internal Identity GetObjectIdentity(MarshalByRefObject obj, Boolean& IsClient);
    internal ServerIdentity get_ObjectIdentity();
    internal void set_ObjectIdentity(ServerIdentity value);
    public virtual ObjRef CreateObjRef(Type requestedType);
    public sealed virtual object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static int ComputeHash32(Byte& data, int count, ulong seed);
    private static void Block(UInt32& rp0, UInt32& rp1);
    private static UInt32 _rotl(UInt32 value, int shift);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    private static int maxRoundingDigits;
    private static double doubleRoundLimit;
    private static Double[] roundPower10Double;
    private static Math();
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static decimal Abs(decimal value);
    [StackTraceHiddenAttribute]
private static void ThrowAbsOverflow();
    public static long BigMul(int a, int b);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    internal static UInt32 DivRem(UInt32 a, UInt32 b, UInt32& result);
    internal static ulong DivRem(ulong a, ulong b, UInt64& result);
    public static decimal Ceiling(decimal d);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static decimal Floor(decimal d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double a, double newBase);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort Max(ushort val1, ushort val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong Max(ulong val1, ulong val2);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong Min(ulong val1, ulong val2);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    private static double copysign(double x, double y);
    private static void ThrowMinMaxException(T min, T max);
    public static double Abs(double value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static double Cbrt(double d);
    public static double Ceiling(double a);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static double Exp(double d);
    public static double Floor(double d);
    public static double Log(double d);
    public static double Log10(double d);
    public static double Pow(double x, double y);
    public static double Sin(double a);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    private static double FMod(double x, double y);
    private static double ModF(double x, Double* intptr);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    private static int maxRoundingDigits;
    private static Single[] roundPower10Single;
    private static float singleRoundLimit;
    private static MathF();
    public static float Abs(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x, float y);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    [IntrinsicAttribute]
public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, MidpointRounding mode);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static int Sign(float x);
    public static float Truncate(float x);
    private static float CopySign(float x, float y);
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float Log(float x);
    public static float Log10(float x);
    public static float Pow(float x, float y);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    private static float FMod(float x, float y);
    private static float ModF(float x, Single* intptr);
}
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[IsReadOnlyAttribute]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    private static int RemoveFlagsBitMask;
    public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Memory`1<T> other);
    public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool Contains(ReadOnlySpan`1<char> source, char value);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Index startIndex);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Index startIndex);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Range range);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Index startIndex);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Range range);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    private static bool IsTypeComparableAsBytes(UInt64& size);
}
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    public MissingFieldException(string className, string fieldName);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
}
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
    internal static string FormatSignature(Byte[] signature);
}
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    public MissingMethodException(string className, string methodName);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
}
internal interface System.ModifierSpec {
    public abstract virtual Type Resolve(Type type);
    public abstract virtual StringBuilder Append(StringBuilder sb);
}
[ComVisibleAttribute("True")]
public class System.ModuleHandle : ValueType {
    private IntPtr value;
    public static ModuleHandle EmptyHandle;
    internal IntPtr Value { get; }
    public int MDStreamVersion { get; }
    internal ModuleHandle(IntPtr v);
    private static ModuleHandle();
    internal IntPtr get_Value();
    public int get_MDStreamVersion();
    internal void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    private IntPtr[] ptrs_from_handles(RuntimeTypeHandle[] handles);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(ModuleHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
}
internal class System.MonoAsyncCall : object {
    private object msg;
    private IntPtr cb_method;
    private object cb_target;
    private object state;
    private object res;
    private object out_args;
}
internal class System.MonoCQItem : object {
    private Object[] array;
    private Byte[] array_state;
    private int head;
    private int tail;
}
internal static class System.MonoCustomAttrs : object {
    private static Assembly corlib;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, AttributeUsageAttribute> usage_cache;
    private static AttributeUsageAttribute DefaultAttributeUsage;
    private static MonoCustomAttrs();
    private static bool IsUserCattrProvider(object obj);
    internal static Attribute[] GetCustomAttributesInternal(ICustomAttributeProvider obj, Type attributeType, bool pseudoAttrs);
    internal static Object[] GetPseudoCustomAttributes(ICustomAttributeProvider obj, Type attributeType);
    private static Object[] GetPseudoCustomAttributes(Type type);
    internal static Object[] GetCustomAttributesBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider obj, bool inherit);
    [PreserveDependencyAttribute(".ctor(System.Reflection.ConstructorInfo,System.Reflection.Assembly,System.IntPtr,System.UInt32)", "System.Reflection.CustomAttributeData")]
[PreserveDependencyAttribute(".ctor(System.Type,System.Object)", "System.Reflection.CustomAttributeTypedArgument")]
[PreserveDependencyAttribute(".ctor(System.Reflection.MemberInfo,System.Object)", "System.Reflection.CustomAttributeNamedArgument")]
private static CustomAttributeData[] GetCustomAttributesDataInternal(ICustomAttributeProvider obj);
    internal static IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj, bool inherit);
    internal static IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    internal static IList`1<CustomAttributeData> GetCustomAttributesDataBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly);
    internal static CustomAttributeData[] GetPseudoCustomAttributesData(ICustomAttributeProvider obj, Type attributeType);
    private static CustomAttributeData[] GetPseudoCustomAttributesData(Type type);
    internal static bool IsDefined(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    internal static bool IsDefinedInternal(ICustomAttributeProvider obj, Type AttributeType);
    private static PropertyInfo GetBasePropertyDefinition(RuntimePropertyInfo property);
    private static EventInfo GetBaseEventDefinition(RuntimeEventInfo evt);
    private static ICustomAttributeProvider GetBase(ICustomAttributeProvider obj);
    private static AttributeUsageAttribute RetrieveAttributeUsageNoCache(Type attributeType);
    private static AttributeUsageAttribute RetrieveAttributeUsage(Type attributeType);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
    public MonoDocumentationNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoExtensionAttribute : MonoTODOAttribute {
    public MonoExtensionAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoInternalNoteAttribute : MonoTODOAttribute {
    public MonoInternalNoteAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoLimitationAttribute : MonoTODOAttribute {
    public MonoLimitationAttribute(string comment);
}
internal class System.MonoListItem : object {
    private MonoListItem next;
    private object data;
}
[AttributeUsageAttribute("32767")]
internal class System.MonoNotSupportedAttribute : MonoTODOAttribute {
    public MonoNotSupportedAttribute(string comment);
}
[AttributeUsageAttribute("32767")]
internal class System.MonoTODOAttribute : Attribute {
    private string comment;
    public string Comment { get; }
    public MonoTODOAttribute(string comment);
    public string get_Comment();
}
internal class System.MonoType : RuntimeType {
}
internal class System.MonoTypeInfo : object {
    public string full_name;
    public RuntimeConstructorInfo default_ctor;
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public abstract class System.MulticastDelegate : Delegate {
    private Delegate[] delegates;
    internal bool HasSingleTarget { get; }
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected sealed virtual object DynamicInvokeImpl(Object[] args);
    internal bool get_HasSingleTarget();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected virtual MethodInfo GetMethodImpl();
    public sealed virtual Delegate[] GetInvocationList();
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    private int LastIndexOf(Delegate[] haystack, Delegate[] needle);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
}
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class System.MutableDecimal : ValueType {
    public UInt32 Flags;
    public UInt32 High;
    public UInt32 Low;
    public UInt32 Mid;
    private static UInt32 SignMask;
    private static UInt32 ScaleMask;
    private static int ScaleShift;
    public bool IsNegative { get; public set; }
    public int Scale { get; public set; }
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public int get_Scale();
    public void set_Scale(int value);
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
[NonVersionableAttribute]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    [NonVersionableAttribute]
public bool get_HasValue();
    public T get_Value();
    [NonVersionableAttribute]
public T GetValueOrDefault();
    [NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
    private static object Box(Nullable`1<T> o);
    private static Nullable`1<T> Unbox(object o);
    private static Nullable`1<T> UnboxExact(object o);
}
internal class System.NullConsoleDriver : object {
    private static ConsoleKeyInfo EmptyConsoleKeyInfo;
    public ConsoleColor BackgroundColor { get; public set; }
    public int BufferHeight { get; public set; }
    public int BufferWidth { get; public set; }
    public bool CapsLock { get; }
    public int CursorLeft { get; public set; }
    public int CursorSize { get; public set; }
    public int CursorTop { get; public set; }
    public bool CursorVisible { get; public set; }
    public ConsoleColor ForegroundColor { get; public set; }
    public bool KeyAvailable { get; }
    public bool Initialized { get; }
    public int LargestWindowHeight { get; }
    public int LargestWindowWidth { get; }
    public bool NumberLock { get; }
    public string Title { get; public set; }
    public bool TreatControlCAsInput { get; public set; }
    public int WindowHeight { get; public set; }
    public int WindowLeft { get; public set; }
    public int WindowTop { get; public set; }
    public int WindowWidth { get; public set; }
    private static NullConsoleDriver();
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual void set_BackgroundColor(ConsoleColor value);
    public sealed virtual int get_BufferHeight();
    public sealed virtual void set_BufferHeight(int value);
    public sealed virtual int get_BufferWidth();
    public sealed virtual void set_BufferWidth(int value);
    public sealed virtual bool get_CapsLock();
    public sealed virtual int get_CursorLeft();
    public sealed virtual void set_CursorLeft(int value);
    public sealed virtual int get_CursorSize();
    public sealed virtual void set_CursorSize(int value);
    public sealed virtual int get_CursorTop();
    public sealed virtual void set_CursorTop(int value);
    public sealed virtual bool get_CursorVisible();
    public sealed virtual void set_CursorVisible(bool value);
    public sealed virtual ConsoleColor get_ForegroundColor();
    public sealed virtual void set_ForegroundColor(ConsoleColor value);
    public sealed virtual bool get_KeyAvailable();
    public sealed virtual bool get_Initialized();
    public sealed virtual int get_LargestWindowHeight();
    public sealed virtual int get_LargestWindowWidth();
    public sealed virtual bool get_NumberLock();
    public sealed virtual string get_Title();
    public sealed virtual void set_Title(string value);
    public sealed virtual bool get_TreatControlCAsInput();
    public sealed virtual void set_TreatControlCAsInput(bool value);
    public sealed virtual int get_WindowHeight();
    public sealed virtual void set_WindowHeight(int value);
    public sealed virtual int get_WindowLeft();
    public sealed virtual void set_WindowLeft(int value);
    public sealed virtual int get_WindowTop();
    public sealed virtual void set_WindowTop(int value);
    public sealed virtual int get_WindowWidth();
    public sealed virtual void set_WindowWidth(int value);
    public sealed virtual void Beep(int frequency, int duration);
    public sealed virtual void Clear();
    public sealed virtual void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public sealed virtual void Init();
    public sealed virtual string ReadLine();
    public sealed virtual ConsoleKeyInfo ReadKey(bool intercept);
    public sealed virtual void ResetColor();
    public sealed virtual void SetBufferSize(int width, int height);
    public sealed virtual void SetCursorPosition(int left, int top);
    public sealed virtual void SetWindowPosition(int left, int top);
    public sealed virtual void SetWindowSize(int width, int height);
}
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
internal static class System.Number : object {
    internal static int DecimalPrecision;
    private static int FloatPrecision;
    private static int DoublePrecision;
    private static int ScaleNAN;
    private static int ScaleINF;
    private static int MaxUInt32DecDigits;
    private static int CharStackBufferSize;
    private static string PosNumberFormat;
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    private static int NumberMaxDigits;
    private static int Int32Precision;
    private static int UInt32Precision;
    private static int Int64Precision;
    private static int UInt64Precision;
    private static Int32[] s_charToHexLookup;
    private static int _CVTBUFSIZE;
    private static UInt64[] s_rgval64Power10;
    private static SByte[] s_rgexp64Power10;
    private static UInt64[] s_rgval64Power10By16;
    private static Int16[] s_rgexp64Power10By16;
    private static Number();
    public static string FormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static void DecimalToNumber(decimal value, NumberBuffer& number);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static bool TryFormatDouble(double value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatDouble(ValueStringBuilder& sb, double value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool TryFormatSingle(float value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatSingle(ValueStringBuilder& sb, float value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static bool TryCopyTo(string source, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    private static void Int32ToNumber(int value, NumberBuffer& number);
    private static string NegativeInt32ToDecStr(int value, int digits, string sNegative);
    private static bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int32ToHexStr(int value, char hexBase, int digits);
    private static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static Char* Int32ToHexChars(Char* buffer, UInt32 value, int hexBase, int digits);
    private static void UInt32ToNumber(UInt32 value, NumberBuffer& number);
    internal static Char* UInt32ToDecChars(Char* bufferEnd, UInt32 value, int digits);
    private static string UInt32ToDecStr(UInt32 value, int digits);
    private static bool TryUInt32ToDecStr(UInt32 value, int digits, Span`1<char> destination, Int32& charsWritten);
    private static bool TryCopyTo(Char* src, int length, Span`1<char> destination, Int32& charsWritten);
    private static void Int64ToNumber(long input, NumberBuffer& number);
    private static string NegativeInt64ToDecStr(long input, int digits, string sNegative);
    private static bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int64ToHexStr(long value, char hexBase, int digits);
    private static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void UInt64ToNumber(ulong value, NumberBuffer& number);
    private static string UInt64ToDecStr(ulong value, int digits);
    private static bool TryUInt64ToDecStr(ulong value, int digits, Span`1<char> destination, Int32& charsWritten);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static void NumberToString(ValueStringBuilder& sb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info, bool isDecimal);
    internal static void NumberToStringFormat(ValueStringBuilder& sb, NumberBuffer& number, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static void FormatCurrency(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void FormatFixed(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, Int32[] groupDigits, string sDecimal, string sGroup);
    private static void FormatNumber(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(ValueStringBuilder& sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    private static void FormatGeneral(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific);
    private static void FormatPercent(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void RoundNumber(NumberBuffer& number, int pos);
    private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static UInt32 Low32(ulong value);
    private static UInt32 High32(ulong value);
    private static UInt32 Int64DivMod1E9(UInt64& value);
    private static bool NumberToInt32(NumberBuffer& number, Int32& value);
    private static bool NumberToInt64(NumberBuffer& number, Int64& value);
    private static bool NumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool NumberToUInt64(NumberBuffer& number, UInt64& value);
    internal static int ParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static long ParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static ulong ParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    private static bool ParseNumber(Char*& str, Char* strEnd, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    internal static bool TryParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result);
    private static bool TryParseInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result, Boolean& failureIsOverflow);
    private static bool TryParseInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result, Boolean& failureIsOverflow);
    internal static bool TryParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result);
    internal static bool TryParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result);
    private static bool TryParseUInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result, Boolean& failureIsOverflow);
    private static bool TryParseUInt32HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result, Boolean& failureIsOverflow);
    internal static bool TryParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result);
    private static bool TryParseUInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result, Boolean& failureIsOverflow);
    private static bool TryParseUInt64HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result, Boolean& failureIsOverflow);
    internal static decimal ParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    private static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    internal static double ParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static float ParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static bool TryParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Decimal& result);
    internal static bool TryParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Single& result);
    private static void StringToNumber(ReadOnlySpan`1<char> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    internal static bool TryStringToNumber(ReadOnlySpan`1<char> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    private static bool TrailingZeros(ReadOnlySpan`1<char> value, int index);
    private static Char* MatchChars(Char* p, Char* pEnd, string value);
    private static bool IsWhite(int ch);
    private static bool IsDigit(int ch);
    private static void ThrowOverflowOrFormatException(bool overflow, string overflowResourceKey);
    private static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
    private static UInt32 DigitsToInt(Char* p, int count);
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static ulong Mul64Lossy(ulong a, ulong b, Int32& pexp);
    private static int abs(int value);
    private static double NumberToDouble(NumberBuffer& number);
    private static void DoubleToNumber(double value, int precision, NumberBuffer& number);
}
internal class System.NumberFormatter : object {
    private static int DefaultExpPrecision;
    private static int HundredMillion;
    private static long SeventeenDigitsThreshold;
    private static ulong ULongDivHundredMillion;
    private static ulong ULongModHundredMillion;
    private static int DoubleBitsExponentShift;
    private static int DoubleBitsExponentMask;
    private static long DoubleBitsMantissaMask;
    private static int DecimalBitsScaleMask;
    private static int SingleDefPrecision;
    private static int DoubleDefPrecision;
    private static int Int32DefPrecision;
    private static int UInt32DefPrecision;
    private static int Int64DefPrecision;
    private static int UInt64DefPrecision;
    private static int DecimalDefPrecision;
    private static int TenPowersListLength;
    private static double MinRoundtripVal;
    private static double MaxRoundtripVal;
    private static UInt64* MantissaBitsTable;
    private static Int32* TensExponentTable;
    private static Char* DigitLowerTable;
    private static Char* DigitUpperTable;
    private static Int64* TenPowersList;
    private static Int32* DecHexDigits;
    private NumberFormatInfo _nfi;
    private Char[] _cbuf;
    private bool _NaN;
    private bool _infinity;
    private bool _isCustomFormat;
    private bool _specifierIsUpper;
    private bool _positive;
    private char _specifier;
    private int _precision;
    private int _defPrecision;
    private int _digitsLen;
    private int _offset;
    private int _decPointPos;
    private UInt32 _val1;
    private UInt32 _val2;
    private UInt32 _val3;
    private UInt32 _val4;
    private int _ind;
    [ThreadStaticAttribute]
private static NumberFormatter threadNumberFormatter;
    [ThreadStaticAttribute]
private static NumberFormatter userFormatProvider;
    unknown CultureInfo CurrentCulture {private set; }
    private int IntegerDigits { get; }
    private int DecimalDigits { get; }
    private bool IsFloatingSource { get; }
    private bool IsZero { get; }
    private bool IsZeroInteger { get; }
    private static NumberFormatter();
    private NumberFormatter(Thread current);
    private static void GetFormatterTables(UInt64*& MantissaBitsTable, Int32*& TensExponentTable, Char*& DigitLowerTable, Char*& DigitUpperTable, Int64*& TenPowersList, Int32*& DecHexDigits);
    private static long GetTenPowerOf(int i);
    private void InitDecHexDigits(UInt32 value);
    private void InitDecHexDigits(ulong value);
    private void InitDecHexDigits(UInt32 hi, ulong lo);
    private static UInt32 FastToDecHex(int val);
    private static UInt32 ToDecHex(int val);
    private static int FastDecHexLen(int val);
    private static int DecHexLen(UInt32 val);
    private int DecHexLen();
    private static int ScaleOrder(long hi);
    private int InitialFloatingPrecision();
    private static int ParsePrecision(string format);
    private void Init(string format);
    private void InitHex(ulong value);
    private void Init(string format, int value, int defPrecision);
    private void Init(string format, UInt32 value, int defPrecision);
    private void Init(string format, long value);
    private void Init(string format, ulong value);
    private void Init(string format, double value, int defPrecision);
    private void Init(string format, decimal value);
    private void ResetCharBuf(int size);
    private void Resize(int len);
    private void Append(char c);
    private void Append(char c, int cnt);
    private void Append(string s);
    private NumberFormatInfo GetNumberFormatInstance(IFormatProvider fp);
    private void set_CurrentCulture(CultureInfo value);
    private int get_IntegerDigits();
    private int get_DecimalDigits();
    private bool get_IsFloatingSource();
    private bool get_IsZero();
    private bool get_IsZeroInteger();
    private void RoundPos(int pos);
    private bool RoundDecimal(int decimals);
    private bool RoundBits(int shift);
    private void RemoveTrailingZeros();
    private void AddOneToDecHex();
    private static UInt32 AddOneToDecHex(UInt32 val);
    private int CountTrailingZeros();
    private static int CountTrailingZeros(UInt32 val);
    private static NumberFormatter GetInstance(IFormatProvider fp);
    private void Release();
    public static string NumberToString(string format, UInt32 value, IFormatProvider fp);
    public static string NumberToString(string format, int value, IFormatProvider fp);
    public static string NumberToString(string format, ulong value, IFormatProvider fp);
    public static string NumberToString(string format, long value, IFormatProvider fp);
    public static string NumberToString(string format, float value, IFormatProvider fp);
    public static string NumberToString(string format, double value, IFormatProvider fp);
    public static string NumberToString(string format, decimal value, IFormatProvider fp);
    private string IntegerToString(string format, IFormatProvider fp);
    private string NumberToString(string format, NumberFormatInfo nfi);
    private string FormatCurrency(int precision, NumberFormatInfo nfi);
    private string FormatDecimal(int precision, NumberFormatInfo nfi);
    private string FormatHexadecimal(int precision);
    private string FormatFixedPoint(int precision, NumberFormatInfo nfi);
    private string FormatRoundtrip(double origval, NumberFormatInfo nfi);
    private string FormatRoundtrip(float origval, NumberFormatInfo nfi);
    private string FormatGeneral(int precision, NumberFormatInfo nfi);
    private string FormatNumber(int precision, NumberFormatInfo nfi);
    private string FormatPercent(int precision, NumberFormatInfo nfi);
    private string FormatExponential(int precision, NumberFormatInfo nfi);
    private string FormatExponential(int precision, NumberFormatInfo nfi, int expDigits);
    private string FormatCustom(string format, NumberFormatInfo nfi);
    private static void ZeroTrimEnd(StringBuilder sb, bool canEmpty);
    private static bool IsZeroOnly(StringBuilder sb);
    private static void AppendNonNegativeNumber(StringBuilder sb, int v);
    private void AppendIntegerString(int minLength, StringBuilder sb);
    private void AppendIntegerString(int minLength);
    private void AppendDecimalString(int precision, StringBuilder sb);
    private void AppendDecimalString(int precision);
    private void AppendIntegerStringWithGroupSeparator(Int32[] groups, string groupSeparator);
    private void AppendExponent(NumberFormatInfo nfi, int exponent, int minDigits);
    private void AppendOneDigit(int start);
    private void AppendDigits(int start, int end);
    private void AppendDigits(int start, int end, StringBuilder sb);
    private void Multiply10(int count);
    private void Divide10(int count);
    private NumberFormatter GetClone();
}
internal class System.Numerics.ConstantHelper : object {
    public static byte GetByteWithAllBitsSet();
    public static sbyte GetSByteWithAllBitsSet();
    public static ushort GetUInt16WithAllBitsSet();
    public static short GetInt16WithAllBitsSet();
    public static UInt32 GetUInt32WithAllBitsSet();
    public static int GetInt32WithAllBitsSet();
    public static ulong GetUInt64WithAllBitsSet();
    public static long GetInt64WithAllBitsSet();
    public static float GetSingleWithAllBitsSet();
    public static double GetDoubleWithAllBitsSet();
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
internal class System.Numerics.Register : ValueType {
    internal byte byte_0;
    internal byte byte_1;
    internal byte byte_2;
    internal byte byte_3;
    internal byte byte_4;
    internal byte byte_5;
    internal byte byte_6;
    internal byte byte_7;
    internal byte byte_8;
    internal byte byte_9;
    internal byte byte_10;
    internal byte byte_11;
    internal byte byte_12;
    internal byte byte_13;
    internal byte byte_14;
    internal byte byte_15;
    internal sbyte sbyte_0;
    internal sbyte sbyte_1;
    internal sbyte sbyte_2;
    internal sbyte sbyte_3;
    internal sbyte sbyte_4;
    internal sbyte sbyte_5;
    internal sbyte sbyte_6;
    internal sbyte sbyte_7;
    internal sbyte sbyte_8;
    internal sbyte sbyte_9;
    internal sbyte sbyte_10;
    internal sbyte sbyte_11;
    internal sbyte sbyte_12;
    internal sbyte sbyte_13;
    internal sbyte sbyte_14;
    internal sbyte sbyte_15;
    internal ushort uint16_0;
    internal ushort uint16_1;
    internal ushort uint16_2;
    internal ushort uint16_3;
    internal ushort uint16_4;
    internal ushort uint16_5;
    internal ushort uint16_6;
    internal ushort uint16_7;
    internal short int16_0;
    internal short int16_1;
    internal short int16_2;
    internal short int16_3;
    internal short int16_4;
    internal short int16_5;
    internal short int16_6;
    internal short int16_7;
    internal UInt32 uint32_0;
    internal UInt32 uint32_1;
    internal UInt32 uint32_2;
    internal UInt32 uint32_3;
    internal int int32_0;
    internal int int32_1;
    internal int int32_2;
    internal int int32_3;
    internal ulong uint64_0;
    internal ulong uint64_1;
    internal long int64_0;
    internal long int64_1;
    internal float single_0;
    internal float single_1;
    internal float single_2;
    internal float single_3;
    internal double double_0;
    internal double double_1;
}
[IntrinsicAttribute]
public static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    public static Vector`1<T> Abs(Vector`1<T> value);
    public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    public static T Dot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
}
[IntrinsicAttribute]
[DefaultMemberAttribute("Item")]
public class System.Numerics.Vector`1 : ValueType {
    private Register register;
    private static int s_count;
    private static Vector`1<T> s_zero;
    private static Vector`1<T> s_one;
    private static Vector`1<T> s_allOnes;
    public static int Count { get; }
    public static Vector`1<T> Zero { get; }
    public static Vector`1<T> One { get; }
    internal static Vector`1<T> AllOnes { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public Vector`1(T value);
    [IntrinsicAttribute]
public Vector`1(T[] values);
    public Vector`1(Span`1<T> values);
    public Vector`1(T[] values, int index);
    internal Vector`1(Void* dataPointer);
    internal Vector`1(Void* dataPointer, int offset);
    private Vector`1(Register& existingRegister);
    private static Vector`1();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    internal static Vector`1<T> get_AllOnes();
    private static int InitializeCount();
    [IntrinsicAttribute]
public void CopyTo(T[] destination);
    [IntrinsicAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IntrinsicAttribute]
public T get_Item(int index);
    public virtual bool Equals(object obj);
    [IntrinsicAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static T DotProduct(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> SquareRoot(Vector`1<T> value);
    private static bool ScalarEquals(T left, T right);
    private static bool ScalarLessThan(T left, T right);
    private static bool ScalarGreaterThan(T left, T right);
    private static T ScalarAdd(T left, T right);
    private static T ScalarSubtract(T left, T right);
    private static T ScalarMultiply(T left, T right);
    private static T ScalarDivide(T left, T right);
    private static T GetOneValue();
    private static T GetAllBitsSetValue();
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
public class System.Object {
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    [ReliabilityContractAttribute("3", "2")]
protected virtual void Finalize();
    public virtual int GetHashCode();
    public Type GetType();
    protected object MemberwiseClone();
    public virtual string ToString();
    [ReliabilityContractAttribute("3", "2")]
public static bool ReferenceEquals(object objA, object objB);
    internal static int InternalGetHashCode(object o);
    private void FieldGetter(string typeName, string fieldName, Object& val);
    private void FieldSetter(string typeName, string fieldName, object val);
}
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string objectName, string message);
    public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    private string _message;
    private bool _error;
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
public class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalCaseSensitiveComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.OrdinalComparer : StringComparer {
    private bool _ignoreCase;
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.OrdinalIgnoreCaseComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
internal static class System.ParameterizedStrings : object {
    [ThreadStaticAttribute]
private static LowLevelStack _cachedStack;
    public static string Evaluate(string format, FormatParam[] args);
    private static string EvaluateInternal(string format, Int32& pos, FormatParam[] args, LowLevelStack stack, FormatParam[]& dynamicVars, FormatParam[]& staticVars);
    private static bool AsBool(int i);
    private static int AsInt(bool b);
    private static string StringFromAsciiBytes(Byte[] buffer, int offset, int length);
    private static int snprintf(Byte* str, IntPtr size, string format, string arg1);
    private static int snprintf(Byte* str, IntPtr size, string format, int arg1);
    private static string FormatPrintF(string format, object arg);
    private static FormatParam[] GetDynamicOrStaticVariables(char c, FormatParam[]& dynamicVars, FormatParam[]& staticVars, Int32& index);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.ParamsArray : ValueType {
    private static Object[] s_oneArgArray;
    private static Object[] s_twoArgArray;
    private static Object[] s_threeArgArray;
    private object _arg0;
    private object _arg1;
    private object _arg2;
    private Object[] _args;
    public int Length { get; }
    public object Item { get; }
    public ParamsArray(object arg0);
    public ParamsArray(object arg0, object arg1);
    public ParamsArray(object arg0, object arg1, object arg2);
    public ParamsArray(Object[] args);
    private static ParamsArray();
    public int get_Length();
    public object get_Item(int index);
    private object GetAtSlow(int index);
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatWithOriginalDateTime;
    public static ParseFailureKind FormatWithFormatSpecifier;
    public static ParseFailureKind FormatWithOriginalDateTimeAndParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    internal static int LeftAlign;
    internal static int RightAlign;
    internal static int PrefixSpace;
    internal static int PrintSign;
    internal static int PrintBase;
    internal static int PrintAsI1;
    internal static int PrintAsI2;
    internal static int PrintAsI4;
    internal static int TreatAsUnsigned;
    internal static int TreatAsI1;
    internal static int TreatAsI2;
    internal static int IsTight;
    internal static int NoSpace;
    internal static int PrintRadixBase;
    private static int MinRadix;
    private static int MaxRadix;
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static string IntToString(int n, int radix, int width, char paddingChar, int flags);
    public static string LongToString(long n, int radix, int width, char paddingChar, int flags);
    private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static long GrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static int GrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static void ThrowOverflowInt32Exception();
    private static void ThrowOverflowInt64Exception();
    private static void ThrowOverflowUInt32Exception();
    private static void ThrowOverflowUInt64Exception();
    private static bool IsDigit(char c, int radix, Int32& result);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
internal class System.Pinnable`1 : object {
    public T Data;
}
[ComVisibleAttribute("True")]
public enum System.PlatformID : Enum {
    public int value__;
    public static PlatformID Win32S;
    public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    public static PlatformID WinCE;
    public static PlatformID Unix;
    public static PlatformID Xbox;
    public static PlatformID MacOSX;
}
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class System.PointerSpec : object {
    private int pointer_level;
    internal PointerSpec(int pointer_level);
    public sealed virtual Type Resolve(Type type);
    public sealed virtual StringBuilder Append(StringBuilder sb);
    public virtual string ToString();
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
public class System.Random : object {
    private static int MBIG;
    private static int MSEED;
    private static int MZ;
    private int _inext;
    private int _inextp;
    private Int32[] _seedArray;
    [ThreadStaticAttribute]
private static Random t_threadRandom;
    private static Random s_globalRandom;
    public Random(int Seed);
    private static Random();
    protected virtual double Sample();
    private int InternalSample();
    private static int GenerateSeed();
    private static int GenerateGlobalSeed();
    public virtual int Next();
    private double GetSampleForLargeRange();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Span`1<byte> buffer);
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("{ToString(),raw}")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory`1<T> other);
    public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[IsByRefLikeAttribute]
[IsReadOnlyAttribute]
[NonVersionableAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.ReadOnlySpan`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(T& ptr, int length);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
}
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Assembly")]
[ClassInterfaceAttribute("0")]
public abstract class System.Reflection.Assembly : object {
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public Evidence Evidence { get; }
    internal IntPtr MonoAssembly { get; }
    unknown bool FromByteArray {internal set; }
    public string Location { get; }
    [ComVisibleAttribute("False")]
public string ImageRuntimeVersion { get; }
    [MonoTODOAttribute("Currently it always returns zero")]
[ComVisibleAttribute("False")]
public long HostContext { get; }
    [ComVisibleAttribute("False")]
public bool ReflectionOnly { get; }
    internal PermissionSet GrantedPermissionSet { get; }
    internal PermissionSet DeniedPermissionSet { get; }
    public PermissionSet PermissionSet { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    [MonoTODOAttribute]
public bool IsFullyTrusted { get; }
    public Module ManifestModule { get; }
    public bool GlobalAssemblyCache { get; }
    public bool IsDynamic { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public IEnumerable`1<Module> Modules { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual string get_CodeBase();
    [SecuritySafeCriticalAttribute]
public virtual string get_EscapedCodeBase();
    public virtual string get_FullName();
    public virtual MethodInfo get_EntryPoint();
    public virtual Evidence get_Evidence();
    internal virtual Evidence UnprotectedGetEvidence();
    internal virtual IntPtr get_MonoAssembly();
    internal virtual void set_FromByteArray(bool value);
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual FileStream GetFile(string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    internal Stream GetManifestResourceStream(Type type, string name, bool skipSecurityCheck, StackCrawlMark& stackMark);
    internal Stream GetManifestResourceStream(string name, StackCrawlMark& stackMark, bool skipSecurityCheck);
    internal string GetSimpleName();
    internal Byte[] GetPublicKey();
    internal Version GetVersion();
    private AssemblyNameFlags GetFlags();
    internal virtual Type[] GetTypes(bool exportedOnly);
    public virtual Type[] GetTypes();
    public virtual Type[] GetExportedTypes();
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name);
    internal Type InternalGetType(Module module, string name, bool throwOnError, bool ignoreCase);
    internal static void InternalGetAssemblyName(string assemblyFile, MonoAssemblyName& aname, String& codebase);
    public virtual AssemblyName GetName(bool copiedName);
    public virtual AssemblyName GetName();
    public virtual string ToString();
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static Assembly GetEntryAssembly();
    internal Assembly GetSatelliteAssembly(CultureInfo culture, Version version, bool throwOnError, StackCrawlMark& stackMark);
    internal RuntimeAssembly InternalGetSatelliteAssembly(string name, CultureInfo culture, Version version, bool throwOnFileNotFound, StackCrawlMark& stackMark);
    private sealed virtual override Type System.Runtime.InteropServices._Assembly.GetType();
    private static Assembly LoadFrom(string assemblyFile, bool refOnly, StackCrawlMark& stackMark);
    private static Assembly LoadFile_internal(string assemblyFile, StackCrawlMark& stackMark);
    public static Assembly LoadFrom(string assemblyFile);
    [ObsoleteAttribute]
public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence);
    [ObsoleteAttribute]
[MonoTODOAttribute("This overload is not currently implemented")]
public static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [MonoTODOAttribute]
public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    [ObsoleteAttribute]
public static Assembly LoadFile(string path, Evidence securityEvidence);
    public static Assembly LoadFile(string path);
    public static Assembly Load(string assemblyString);
    [ObsoleteAttribute]
public static Assembly Load(string assemblyString, Evidence assemblySecurity);
    public static Assembly Load(AssemblyName assemblyRef);
    [ObsoleteAttribute]
public static Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity);
    public static Assembly Load(Byte[] rawAssembly);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    [ObsoleteAttribute]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence);
    [MonoLimitationAttribute("Argument securityContextSource is ignored")]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, SecurityContextSource securityContextSource);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    [MonoTODOAttribute("Not implemented")]
public sealed virtual Module LoadModule(string moduleName, Byte[] rawModule);
    [MonoTODOAttribute("Not implemented")]
public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    private static Assembly load_with_partial_name(string name, Evidence e);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence);
    internal static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence, bool oldBehavior);
    public sealed virtual object CreateInstance(string typeName);
    public sealed virtual object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public sealed virtual Module[] GetLoadedModules();
    public sealed virtual Module[] GetModules();
    internal virtual Module[] GetModulesInternal();
    public static Assembly GetExecutingAssembly();
    public static Assembly GetCallingAssembly();
    internal static IntPtr InternalGetReferencedAssemblies(Assembly module);
    public virtual String[] GetManifestResourceNames();
    internal static AssemblyName[] GetReferencedAssemblies(Assembly module);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual long get_HostContext();
    internal virtual Module GetManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal virtual PermissionSet get_GrantedPermissionSet();
    internal virtual PermissionSet get_DeniedPermissionSet();
    public virtual PermissionSet get_PermissionSet();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    private static Exception CreateNIE();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public bool get_IsFullyTrusted();
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Module[] GetModules(bool getResourceModules);
    [MonoTODOAttribute("Always returns the same as GetModules")]
public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Module get_ManifestModule();
    public virtual bool get_GlobalAssemblyCache();
    public virtual bool get_IsDynamic();
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    [IteratorStateMachineAttribute("System.Reflection.Assembly/<get_DefinedTypes>d__127")]
public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual IEnumerable`1<Module> get_Modules();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual Type[] GetForwardedTypes();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
public static class System.Reflection.AssemblyExtensions : object {
    public static Type[] GetExportedTypes(Assembly assembly);
    public static Module[] GetModules(Assembly assembly);
    public static Type[] GetTypes(Assembly assembly);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._AssemblyName")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.Reflection.AssemblyName : object {
    private string name;
    private string codebase;
    private int major;
    private int minor;
    private int build;
    private int revision;
    private CultureInfo cultureinfo;
    private AssemblyNameFlags flags;
    private AssemblyHashAlgorithm hashalg;
    private StrongNameKeyPair keypair;
    private Byte[] publicKey;
    private Byte[] keyToken;
    private AssemblyVersionCompatibility versioncompat;
    private Version version;
    private ProcessorArchitecture processor_architecture;
    private AssemblyContentType contentType;
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public string Name { get; public set; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public CultureInfo CultureInfo { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public Version Version { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    private bool IsPublicKeyValid { get; }
    public string CultureName { get; public set; }
    [ComVisibleAttribute("False")]
public AssemblyContentType ContentType { get; public set; }
    public AssemblyName(string assemblyName);
    internal AssemblyName(SerializationInfo si, StreamingContext sc);
    private static bool ParseAssemblyName(IntPtr name, MonoAssemblyName& aname, Boolean& is_version_definited, Boolean& is_token_defined);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public string get_Name();
    public void set_Name(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public string get_FullName();
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public virtual string ToString();
    public Byte[] GetPublicKey();
    public Byte[] GetPublicKeyToken();
    private bool get_IsPublicKeyValid();
    private Byte[] InternalGetPublicKeyToken();
    private static void get_public_token(Byte* token, Byte* pubkey, int len);
    private Byte[] ComputePublicKeyToken();
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    public void SetPublicKey(Byte[] publicKey);
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual object Clone();
    public sealed virtual void OnDeserialization(object sender);
    public static AssemblyName GetAssemblyName(string assemblyFile);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyName.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public string get_CultureName();
    public void set_CultureName(string value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    private static MonoAssemblyName* GetNativeName(IntPtr assembly_ptr);
    internal void FillName(MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken, bool assemblyRef);
    internal static AssemblyName Create(Assembly assembly, bool fillCodebase);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual bool CanChangeType(object value, Type type, CultureInfo culture);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    public virtual MemberTypes get_MemberType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._ConstructorInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, Object[] parameters);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    private sealed virtual override object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(Object[] parameters);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType End;
    public static CorElementType Void;
    public static CorElementType Boolean;
    public static CorElementType Char;
    public static CorElementType I1;
    public static CorElementType U1;
    public static CorElementType I2;
    public static CorElementType U2;
    public static CorElementType I4;
    public static CorElementType U4;
    public static CorElementType I8;
    public static CorElementType U8;
    public static CorElementType R4;
    public static CorElementType R8;
    public static CorElementType String;
    public static CorElementType Ptr;
    public static CorElementType ByRef;
    public static CorElementType ValueType;
    public static CorElementType Class;
    public static CorElementType Var;
    public static CorElementType Array;
    public static CorElementType GenericInst;
    public static CorElementType TypedByRef;
    public static CorElementType I;
    public static CorElementType U;
    public static CorElementType FnPtr;
    public static CorElementType Object;
    public static CorElementType SzArray;
    public static CorElementType MVar;
    public static CorElementType CModReqd;
    public static CorElementType CModOpt;
    public static CorElementType Internal;
    public static CorElementType Max;
    public static CorElementType Modifier;
    public static CorElementType Sentinel;
    public static CorElementType Pinned;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_INTERNAL;
    public static CorElementType ELEMENT_TYPE_MAX;
    public static CorElementType ELEMENT_TYPE_MODIFIER;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
[ComVisibleAttribute("True")]
public class System.Reflection.CustomAttributeData : object {
    private ConstructorInfo ctorInfo;
    private IList`1<CustomAttributeTypedArgument> ctorArgs;
    private IList`1<CustomAttributeNamedArgument> namedArgs;
    private LazyCAttrData lazyData;
    [ComVisibleAttribute("True")]
public ConstructorInfo Constructor { get; }
    [ComVisibleAttribute("True")]
public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public Type AttributeType { get; }
    internal CustomAttributeData(ConstructorInfo ctorInfo, Assembly assembly, IntPtr data, UInt32 data_length);
    internal CustomAttributeData(ConstructorInfo ctorInfo);
    internal CustomAttributeData(ConstructorInfo ctorInfo, IList`1<CustomAttributeTypedArgument> ctorArgs, IList`1<CustomAttributeNamedArgument> namedArgs);
    private static void ResolveArgumentsInternal(ConstructorInfo ctor, Assembly assembly, IntPtr data, UInt32 data_length, Object[]& ctorArgs, Object[]& namedArgs);
    private void ResolveArguments();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    public Type get_AttributeType();
    public virtual string ToString();
    private static T[] UnboxValues(Object[] values);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    [CompilerGeneratedAttribute]
private CustomAttributeTypedArgument <TypedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    private Type _attributeType;
    private MemberInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMemberInfo;
    public CustomAttributeTypedArgument TypedValue { get; }
    public bool IsField { get; }
    public string MemberName { get; }
    public MemberInfo MemberInfo { get; }
    internal CustomAttributeNamedArgument(Type attributeType, string memberName, bool isField, CustomAttributeTypedArgument typedValue);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public CustomAttributeTypedArgument get_TypedValue();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public bool get_IsField();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_MemberName();
    public MemberInfo get_MemberInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    [CompilerGeneratedAttribute]
private Type <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(object value);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public Type get_ArgumentType();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
    internal string ToString(bool typed);
    private static object CanonicalizeValue(object value);
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
internal class System.Reflection.Emit.ArrayType : SymbolType {
    private int rank;
    internal ArrayType(Type elementType, int rank);
    internal int GetEffectiveRank();
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    protected virtual bool IsArrayImpl();
    public virtual int GetArrayRank();
    internal virtual string FormatName(string elementName);
}
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._AssemblyBuilder")]
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    internal IntPtr _mono_assembly;
    internal Evidence _evidence;
    private UIntPtr dynamic_assembly;
    private MethodInfo entry_point;
    private ModuleBuilder[] modules;
    private string name;
    private string dir;
    private CustomAttributeBuilder[] cattrs;
    private MonoResource[] resources;
    private Byte[] public_key;
    private string version;
    private string culture;
    private UInt32 algid;
    private UInt32 flags;
    private PEFileKinds pekind;
    private bool delay_sign;
    private UInt32 access;
    private Module[] loaded_modules;
    private MonoWin32Resource[] win32_resources;
    private RefEmitPermissionSet[] permissions_minimum;
    private RefEmitPermissionSet[] permissions_optional;
    private RefEmitPermissionSet[] permissions_refused;
    private PortableExecutableKinds peKind;
    private ImageFileMachine machine;
    private bool corlib_internal;
    private Type[] type_forwarders;
    private Byte[] pktoken;
    internal PermissionSet _minimum;
    internal PermissionSet _optional;
    internal PermissionSet _refuse;
    internal PermissionSet _granted;
    internal PermissionSet _denied;
    private string assemblyName;
    internal Type corlib_object_type;
    internal Type corlib_value_type;
    internal Type corlib_enum_type;
    internal Type corlib_void_type;
    private ArrayList resource_writers;
    private Win32VersionResource version_res;
    private bool created;
    private bool is_module_only;
    private StrongName sn;
    private NativeResourceType native_resource;
    private string versioninfo_culture;
    private static AssemblyBuilderAccess COMPILER_ACCESS;
    private ModuleBuilder manifest_module;
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public bool ReflectionOnly { get; }
    internal bool IsSave { get; }
    internal bool IsRun { get; }
    internal string AssemblyDir { get; }
    internal bool IsModuleOnly { get; internal set; }
    public Module ManifestModule { get; }
    public bool GlobalAssemblyCache { get; }
    public bool IsDynamic { get; }
    public string FullName { get; }
    internal IntPtr MonoAssembly { get; }
    public Evidence Evidence { get; }
    [PreserveDependencyAttribute("RuntimeResolve", "System.Reflection.Emit.ModuleBuilder")]
internal AssemblyBuilder(AssemblyName n, string directory, AssemblyBuilderAccess access, bool corlib_internal);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._AssemblyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private static void basic_init(AssemblyBuilder ab);
    private static void UpdateNativeCustomAttributes(AssemblyBuilder ab);
    public virtual string get_CodeBase();
    public virtual string get_EscapedCodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_ReflectionOnly();
    public void AddResourceFile(string name, string fileName);
    public void AddResourceFile(string name, string fileName, ResourceAttributes attribute);
    private void AddResourceFile(string name, string fileName, ResourceAttributes attribute, bool fileNeedsToExists);
    internal void AddPermissionRequests(PermissionSet required, PermissionSet optional, PermissionSet refused);
    internal void EmbedResourceFile(string name, string fileName);
    private void EmbedResourceFile(string name, string fileName, ResourceAttributes attribute);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
    public ModuleBuilder DefineDynamicModule(string name, string fileName);
    public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo);
    private ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo, bool transient);
    public IResourceWriter DefineResource(string name, string description, string fileName);
    public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute);
    private void AddUnmanagedResource(Win32Resource res);
    [MonoTODOAttribute("Not currently implemenented")]
public void DefineUnmanagedResource(Byte[] resource);
    public void DefineUnmanagedResource(string resourceFileName);
    public void DefineVersionInfoResource();
    public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark);
    private void DefineVersionInfoResourceImpl(string fileName);
    public ModuleBuilder GetDynamicModule(string name);
    public virtual Type[] GetExportedTypes();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    internal virtual Module[] GetModulesInternal();
    internal virtual Type[] GetTypes(bool exportedOnly);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    internal bool get_IsSave();
    internal bool get_IsRun();
    internal string get_AssemblyDir();
    internal bool get_IsModuleOnly();
    internal void set_IsModuleOnly(bool value);
    internal virtual Module GetManifestModule();
    [MonoLimitationAttribute("No support for PE32+ assemblies for AMD64 and IA64")]
public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine);
    public void Save(string assemblyFileName);
    public void SetEntryPoint(MethodInfo entryMethod);
    public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private Exception not_supported();
    private void check_name_and_filename(string name, string fileName, bool fileNeedsToExists);
    private string create_assembly_version(string version);
    private string GetCultureString(string str);
    internal Type MakeGenericType(Type gtd, Type[] typeArguments);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName(bool copiedName);
    [MonoTODOAttribute("This always returns an empty array")]
public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Module get_ManifestModule();
    public virtual bool get_GlobalAssemblyCache();
    public virtual bool get_IsDynamic();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_FullName();
    internal virtual IntPtr get_MonoAssembly();
    public virtual Evidence get_Evidence();
    internal virtual Evidence UnprotectedGetEvidence();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess Save;
    public static AssemblyBuilderAccess RunAndSave;
    public static AssemblyBuilderAccess ReflectionOnly;
    public static AssemblyBuilderAccess RunAndCollect;
}
internal class System.Reflection.Emit.ByRefType : SymbolType {
    internal ByRefType(Type elementType);
    internal virtual Type InternalResolve();
    protected virtual bool IsByRefImpl();
    internal virtual string FormatName(string elementName);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ConstructorBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    private RuntimeMethodHandle mhandle;
    private ILGenerator ilgen;
    internal Type[] parameters;
    private MethodAttributes attrs;
    private MethodImplAttributes iattrs;
    private int table_idx;
    private CallingConventions call_conv;
    private TypeBuilder type;
    internal ParameterBuilder[] pinfo;
    private CustomAttributeBuilder[] cattrs;
    private bool init_locals;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    private RefEmitPermissionSet[] permissions;
    [MonoTODOAttribute]
public CallingConventions CallingConvention { get; }
    public bool InitLocals { get; public set; }
    internal TypeBuilder TypeBuilder { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    [ObsoleteAttribute]
public Type ReturnType { get; }
    public string Name { get; }
    public string Signature { get; }
    public Module Module { get; }
    internal ConstructorBuilder(TypeBuilder tb, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ConstructorBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual CallingConventions get_CallingConvention();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal TypeBuilder get_TypeBuilder();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    internal MethodBase RuntimeResolve();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public Type get_ReturnType();
    public virtual string get_Name();
    public string get_Signature();
    public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public Module GetModule();
    public MethodToken GetToken();
    [MonoTODOAttribute]
public void SetSymCustomAttribute(string name, Byte[] data);
    public virtual Module get_Module();
    public virtual string ToString();
    internal void fixup();
    internal void ResolveUserTypes();
    internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map);
    internal void GenerateDebugInfo(ISymbolWriter symbolWriter);
    internal virtual int get_next_table_index(object obj, int table, int count);
    private void RejectIfCreated();
    private Exception not_supported();
    private Exception not_after_created();
    private Exception not_created();
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInst : ConstructorInfo {
    internal TypeBuilderInstantiation instantiation;
    internal ConstructorInfo cb;
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public ConstructorOnTypeBuilderInst(TypeBuilderInstantiation instantiation, ConstructorInfo cb);
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual Type[] GetParameterTypes();
    internal ConstructorInfo RuntimeResolve();
    public virtual int get_MetadataToken();
    internal virtual int GetParametersCount();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._CustomAttributeBuilder")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    private ConstructorInfo ctor;
    private Byte[] data;
    private Object[] args;
    private PropertyInfo[] namedProperties;
    private Object[] propertyValues;
    private FieldInfo[] namedFields;
    private Object[] fieldValues;
    internal ConstructorInfo Ctor { get; }
    internal Byte[] Data { get; }
    internal CustomAttributeBuilder(ConstructorInfo con, Byte[] binaryAttribute);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal ConstructorInfo get_Ctor();
    internal Byte[] get_Data();
    private static Byte[] GetBlob(Assembly asmb, ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    internal object Invoke();
    private bool IsValidType(Type t);
    private bool IsValidParam(object o, Type paramType);
    private static bool IsValidValue(Type type, object value);
    private void Initialize(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    internal static int decode_len(Byte[] data, int pos, Int32& rpos);
    internal static string string_from_bytes(Byte[] data, int pos, int len);
    internal static string decode_string(Byte[] data, int pos, Int32& rpos);
    internal string string_arg();
    internal static UnmanagedMarshal get_umarshal(CustomAttributeBuilder customBuilder, bool is_field);
    private static Type elementTypeToType(int elementType);
    private static object decode_cattr_value(Type t, Byte[] data, int pos, Int32& rpos);
    internal static CustomAttributeInfo decode_cattr(CustomAttributeBuilder customBuilder);
    private static ParameterInfo[] GetParameters(ConstructorInfo ctor);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.DynamicILInfo : object {
    private DynamicMethod method;
    public DynamicMethod DynamicMethod { get; }
    internal DynamicILInfo(DynamicMethod method);
    public DynamicMethod get_DynamicMethod();
    [MonoTODOAttribute]
public int GetTokenFor(Byte[] signature);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    [MonoTODOAttribute]
public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    [MonoTODOAttribute]
public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    public void SetCode(Byte[] code, int maxStackSize);
    [CLSCompliantAttribute("False")]
public void SetCode(Byte* code, int codeSize, int maxStackSize);
    [MonoTODOAttribute]
public void SetExceptions(Byte[] exceptions);
    [CLSCompliantAttribute("False")]
[MonoTODOAttribute]
public void SetExceptions(Byte* exceptions, int exceptionsSize);
    [MonoTODOAttribute]
public void SetLocalSignature(Byte[] localSignature);
    [CLSCompliantAttribute("False")]
public void SetLocalSignature(Byte* localSignature, int signatureSize);
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    private RuntimeMethodHandle mhandle;
    private string name;
    private Type returnType;
    private Type[] parameters;
    private MethodAttributes attributes;
    private CallingConventions callingConvention;
    private Module module;
    private bool skipVisibility;
    private bool init_locals;
    private ILGenerator ilgen;
    private int nrefs;
    private Object[] refs;
    private IntPtr referenced_by;
    private Type owner;
    private Delegate deleg;
    private RuntimeMethodInfo method;
    private ParameterBuilder[] pinfo;
    internal bool creating;
    private DynamicILInfo il_info;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    [MonoTODOAttribute("Not implemented")]
public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    [MonoTODOAttribute("Not implemented")]
public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    [MonoTODOAttribute("Visibility is not restricted")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    private DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, Module m, bool skipVisibility, bool anonHosted);
    private static void create_dynamic_method(DynamicMethod m);
    private void CreateDynMethod();
    [ComVisibleAttribute("True")]
public sealed virtual Delegate CreateDelegate(Type delegateType);
    [ComVisibleAttribute("True")]
public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public DynamicILInfo GetDynamicILInfo();
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    [SecuritySafeCriticalAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    private void RejectIfCreated();
    internal int AddRef(object reference);
}
internal class System.Reflection.Emit.DynamicMethodTokenGenerator : object {
    private DynamicMethod m;
    public DynamicMethodTokenGenerator(DynamicMethod m);
    public sealed virtual int GetToken(string str);
    public sealed virtual int GetToken(MethodBase method, Type[] opt_param_types);
    public sealed virtual int GetToken(MemberInfo member, bool create_open_instance);
    public sealed virtual int GetToken(SignatureHelper helper);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._EnumBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    private TypeBuilder _tb;
    private FieldBuilder _underlyingField;
    private Type _underlyingType;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public TypeToken TypeToken { get; }
    public FieldBuilder UnderlyingField { get; }
    public Type UnderlyingSystemType { get; }
    internal bool IsUserType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsTypeDefinition { get; }
    internal EnumBuilder(ModuleBuilder mb, string name, TypeAttributes visibility, Type underlyingType);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EnumBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal TypeBuilder GetTypeBuilder();
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public TypeToken get_TypeToken();
    public FieldBuilder get_UnderlyingField();
    public virtual Type get_UnderlyingSystemType();
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    public virtual Type GetEnumUnderlyingType();
    private void setup_enum_type(Type t);
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private Exception CreateNotSupportedException();
    internal virtual bool get_IsUserType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool get_IsTypeDefinition();
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._EventBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.EventBuilder : object {
    internal string name;
    private Type type;
    private TypeBuilder typeb;
    private CustomAttributeBuilder[] cattrs;
    internal MethodBuilder add_method;
    internal MethodBuilder remove_method;
    internal MethodBuilder raise_method;
    internal MethodBuilder[] other_methods;
    internal EventAttributes attrs;
    private int table_idx;
    internal EventBuilder(TypeBuilder tb, string eventName, EventAttributes eventAttrs, Type eventType);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal int get_next_table_index(object obj, int table, int count);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public EventToken GetEventToken();
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private void RejectIfCreated();
}
internal class System.Reflection.Emit.EventOnTypeBuilderInst : EventInfo {
    private TypeBuilderInstantiation instantiation;
    private EventBuilder event_builder;
    private EventInfo event_info;
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    internal EventOnTypeBuilderInst(TypeBuilderInstantiation instantiation, EventBuilder evt);
    internal EventOnTypeBuilderInst(TypeBuilderInstantiation instantiation, EventInfo evt);
    public virtual EventAttributes get_Attributes();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.EventToken : ValueType {
    internal int tokValue;
    public static EventToken Empty;
    public int Token { get; }
    internal EventToken(int val);
    private static EventToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EventToken obj);
    public static bool op_Equality(EventToken a, EventToken b);
    public static bool op_Inequality(EventToken a, EventToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
[ComVisibleAttribute("False")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.ExceptionHandler : ValueType {
    internal int m_exceptionClass;
    internal int m_tryStartOffset;
    internal int m_tryEndOffset;
    internal int m_filterOffset;
    internal int m_handlerStartOffset;
    internal int m_handlerEndOffset;
    internal ExceptionHandlingClauseOptions m_kind;
    public int ExceptionTypeToken { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int FilterOffset { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public ExceptionHandlingClauseOptions Kind { get; }
    public ExceptionHandler(int tryOffset, int tryLength, int filterOffset, int handlerOffset, int handlerLength, ExceptionHandlingClauseOptions kind, int exceptionTypeToken);
    internal ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
    public int get_ExceptionTypeToken();
    public int get_TryOffset();
    public int get_TryLength();
    public int get_FilterOffset();
    public int get_HandlerOffset();
    public int get_HandlerLength();
    public ExceptionHandlingClauseOptions get_Kind();
    private static bool IsValidKind(ExceptionHandlingClauseOptions kind);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExceptionHandler other);
    public static bool op_Equality(ExceptionHandler left, ExceptionHandler right);
    public static bool op_Inequality(ExceptionHandler left, ExceptionHandler right);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._FieldBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    private FieldAttributes attrs;
    private Type type;
    private string name;
    private object def_value;
    private int offset;
    internal TypeBuilder typeb;
    private Byte[] rva_data;
    private CustomAttributeBuilder[] cattrs;
    private UnmanagedMarshal marshal_info;
    private RuntimeFieldHandle handle;
    private Type[] modReq;
    private Type[] modOpt;
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    internal FieldBuilder(TypeBuilder tb, string fieldName, Type type, FieldAttributes attributes, Type[] modReq, Type[] modOpt);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual int get_MetadataToken();
    public FieldToken GetToken();
    public virtual object GetValue(object obj);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal virtual int GetFieldOffset();
    internal void SetRVAData(Byte[] data);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead.")]
public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
    public void SetOffset(int iOffset);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    private Exception CreateNotSupportedException();
    private void RejectIfCreated();
    internal void ResolveUserTypes();
    internal FieldInfo RuntimeResolve();
    public virtual Module get_Module();
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInst : FieldInfo {
    internal TypeBuilderInstantiation instantiation;
    internal FieldInfo fb;
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public int MetadataToken { get; }
    public Type FieldType { get; }
    public FieldOnTypeBuilderInst(TypeBuilderInstantiation instantiation, FieldInfo fb);
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string ToString();
    public virtual FieldAttributes get_Attributes();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual int get_MetadataToken();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    internal FieldInfo RuntimeResolve();
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.FieldToken : ValueType {
    internal int tokValue;
    public static FieldToken Empty;
    public int Token { get; }
    internal FieldToken(int val);
    private static FieldToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FieldToken obj);
    public static bool op_Equality(FieldToken a, FieldToken b);
    public static bool op_Inequality(FieldToken a, FieldToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated.")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class System.Reflection.Emit.GenericInstanceKey : object {
    private Type gtd;
    internal Type[] args;
    private int hash_code;
    internal GenericInstanceKey(Type gtd, Type[] args);
    private static bool IsBoundedVector(Type type);
    private static bool TypeEquals(Type a, Type b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    private TypeBuilder tbuilder;
    private MethodBuilder mbuilder;
    private string name;
    private int index;
    private Type base_type;
    private Type[] iface_constraints;
    private CustomAttributeBuilder[] cattrs;
    private GenericParameterAttributes attrs;
    public Type UnderlyingSystemType { get; }
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    internal bool IsUserType { get; }
    internal GenericTypeParameterBuilder(TypeBuilder tbuilder, MethodBuilder mbuilder, string name, int index);
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    [ComVisibleAttribute("True")]
public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Type GetElementType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual MethodBase get_DeclaringMethod();
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [MonoTODOAttribute("unverified implementation")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private Exception not_supported();
    public virtual string ToString();
    [MonoTODOAttribute]
public virtual bool Equals(object o);
    [MonoTODOAttribute]
public virtual int GetHashCode();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    internal virtual bool get_IsUserType();
}
internal class System.Reflection.Emit.ILExceptionBlock : ValueType {
    public static int CATCH;
    public static int FILTER;
    public static int FINALLY;
    public static int FAULT;
    public static int FILTER_START;
    internal Type extype;
    internal int type;
    internal int start;
    internal int len;
    internal int filter_offset;
    internal void Debug();
}
internal class System.Reflection.Emit.ILExceptionInfo : ValueType {
    internal ILExceptionBlock[] handlers;
    internal int start;
    internal int len;
    internal Label end;
    internal int NumHandlers();
    internal void AddCatch(Type extype, int offset);
    internal void AddFinally(int offset);
    internal void AddFault(int offset);
    internal void AddFilter(int offset);
    internal void End(int offset);
    internal int LastClauseType();
    internal void PatchFilterClause(int start);
    internal void Debug(int b);
    private void add_block(int offset);
}
public class System.Reflection.Emit.ILGenerator : object {
    private Byte[] code;
    private int code_len;
    private int max_stack;
    private int cur_stack;
    private LocalBuilder[] locals;
    private ILExceptionInfo[] ex_handlers;
    private int num_token_fixups;
    private ILTokenInfo[] token_fixups;
    private LabelData[] labels;
    private int num_labels;
    private LabelFixup[] fixups;
    private int num_fixups;
    internal Module module;
    private int cur_block;
    private Stack open_blocks;
    private TokenGenerator token_gen;
    private static int defaultFixupSize;
    private static int defaultLabelsSize;
    private static int defaultExceptionStackSize;
    private ArrayList sequencePointLists;
    private SequencePointList currentSequence;
    internal bool HasDebugInfo { get; }
    internal TokenGenerator TokenGenerator { get; }
    public int ILOffset { get; }
    internal ILGenerator(Module m, TokenGenerator token_gen, int size);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ILGenerator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private void add_token_fixup(MemberInfo mi);
    private void make_room(int nbytes);
    private void emit_int(int val);
    private void ll_emit(OpCode opcode);
    private static int target_len(OpCode opcode);
    private void InternalEndClause();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual Label BeginExceptionBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void BeginScope();
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual Label DefineLabel();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    [ComVisibleAttribute("True")]
public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    private void Emit(OpCode opcode, MethodInfo method, int token);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    [MonoLimitationAttribute("vararg methods are not supported")]
public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(string value);
    public virtual void EndExceptionBlock();
    public virtual void EndScope();
    public virtual void MarkLabel(Label loc);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    internal void GenerateDebugInfo(ISymbolWriter symbolWriter);
    internal bool get_HasDebugInfo();
    public virtual void ThrowException(Type excType);
    [MonoTODOAttribute("Not implemented")]
public virtual void UsingNamespace(string usingNamespace);
    internal void label_fixup(MethodBase mb);
    internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map);
    internal void SetExceptionHandlers(ILExceptionInfo[] exHandlers);
    internal void SetTokenFixups(ILTokenInfo[] tokenFixups);
    internal void SetCode(Byte[] code, int max_stack);
    internal void SetCode(Byte* code, int code_size, int max_stack);
    internal void Init(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups);
    internal TokenGenerator get_TokenGenerator();
    [ObsoleteAttribute("Use ILOffset", "True")]
internal static int Mono_GetCurrentOffset(ILGenerator ig);
    public virtual int get_ILOffset();
}
internal class System.Reflection.Emit.ILTokenInfo : ValueType {
    public MemberInfo member;
    public int code_pos;
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.Label : ValueType {
    internal int label;
    internal Label(int val);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._LocalBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    private string name;
    internal ILGenerator ilgen;
    private int startOffset;
    private int endOffset;
    public Type LocalType { get; }
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    internal string Name { get; }
    internal int StartOffset { get; }
    internal int EndOffset { get; }
    internal LocalBuilder(Type t, ILGenerator ilgen);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._LocalBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public void SetLocalSymInfo(string name, int startOffset, int endOffset);
    public void SetLocalSymInfo(string name);
    public virtual Type get_LocalType();
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    internal string get_Name();
    internal int get_StartOffset();
    internal int get_EndOffset();
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    private RuntimeMethodHandle mhandle;
    private Type rtype;
    internal Type[] parameters;
    private MethodAttributes attrs;
    private MethodImplAttributes iattrs;
    private string name;
    private int table_idx;
    private Byte[] code;
    private ILGenerator ilgen;
    private TypeBuilder type;
    internal ParameterBuilder[] pinfo;
    private CustomAttributeBuilder[] cattrs;
    private MethodInfo[] override_methods;
    private string pi_dll;
    private string pi_entry;
    private CharSet charset;
    private UInt32 extra_flags;
    private CallingConvention native_cc;
    private CallingConventions call_conv;
    private bool init_locals;
    private IntPtr generic_container;
    internal GenericTypeParameterBuilder[] generic_params;
    private Type[] returnModReq;
    private Type[] returnModOpt;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    private RefEmitPermissionSet[] permissions;
    public bool ContainsGenericParameters { get; }
    public bool InitLocals { get; public set; }
    internal TypeBuilder TypeBuilder { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    internal RuntimeMethodHandle MethodHandleInternal { get; }
    public Type ReturnType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public CallingConventions CallingConvention { get; }
    [MonoTODOAttribute("Not implemented")]
public string Signature { get; }
    unknown bool BestFitMapping {internal set; }
    unknown bool ThrowOnUnmappableChar {internal set; }
    unknown bool ExactSpelling {internal set; }
    unknown bool SetLastError {internal set; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public Module Module { get; }
    public ParameterInfo ReturnParameter { get; }
    internal MethodBuilder(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    internal MethodBuilder(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt, string dllName, string entryName, CallingConvention nativeCConv, CharSet nativeCharset);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual bool get_ContainsGenericParameters();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal TypeBuilder get_TypeBuilder();
    public virtual RuntimeMethodHandle get_MethodHandle();
    internal RuntimeMethodHandle get_MethodHandleInternal();
    public virtual Type get_ReturnType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual MethodAttributes get_Attributes();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual CallingConventions get_CallingConvention();
    public string get_Signature();
    internal void set_BestFitMapping(bool value);
    internal void set_ThrowOnUnmappableChar(bool value);
    internal void set_ExactSpelling(bool value);
    internal void set_SetLastError(bool value);
    public MethodToken GetToken();
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    internal MethodBase RuntimeResolve();
    public Module GetModule();
    public void CreateMethodBody(Byte[] il, int count);
    public void SetMethodBody(Byte[] il, int maxStack, Byte[] localSignature, IEnumerable`1<ExceptionHandler> exceptionHandlers, IEnumerable`1<int> tokenFixups);
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    internal void check_override();
    internal void fixup();
    internal void ResolveUserTypes();
    internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map);
    internal void GenerateDebugInfo(ISymbolWriter symbolWriter);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    [ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead.")]
public void SetMarshal(UnmanagedMarshal unmanagedMarshal);
    [MonoTODOAttribute]
public void SetSymCustomAttribute(string name, Byte[] data);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
    [MonoTODOAttribute]
[SecuritySafeCriticalAttribute]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int get_next_table_index(object obj, int table, int count);
    private void ExtendArray(T[]& array, T elem);
    internal void set_override(MethodInfo mdecl);
    private void RejectIfCreated();
    private Exception NotSupported();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public void SetReturnType(Type returnType);
    public void SetParameters(Type[] parameterTypes);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public virtual Module get_Module();
    public virtual ParameterInfo get_ReturnParameter();
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInst : MethodInfo {
    private Type instantiation;
    private MethodInfo base_method;
    private Type[] method_arguments;
    private MethodInfo generic_method_definition;
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public Type ReturnType { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public MethodOnTypeBuilderInst(TypeBuilderInstantiation instantiation, MethodInfo base_method);
    internal MethodOnTypeBuilderInst(MethodOnTypeBuilderInst gmd, Type[] typeArguments);
    internal MethodOnTypeBuilderInst(MethodInfo method, Type[] typeArguments);
    private static MethodInfo ExtractBaseMethod(MethodInfo info);
    internal Type[] GetTypeArgs();
    internal MethodInfo RuntimeResolve();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Type get_ReturnType();
    public virtual Module get_Module();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string ToString();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    public virtual int get_MetadataToken();
    internal virtual int GetParametersCount();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodRental")]
public class System.Reflection.Emit.MethodRental : object {
    public static int JitImmediate;
    public static int JitOnDemand;
    [MonoTODOAttribute]
public static void SwapMethodBody(Type cls, int methodtoken, IntPtr rgIL, int methodSize, int flags);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodRental.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.MethodToken : ValueType {
    internal int tokValue;
    public static MethodToken Empty;
    public int Token { get; }
    internal MethodToken(int val);
    private static MethodToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodToken obj);
    public static bool op_Equality(MethodToken a, MethodToken b);
    public static bool op_Inequality(MethodToken a, MethodToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ModuleBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.ModuleBuilder : Module {
    internal IntPtr _impl;
    internal Assembly assembly;
    internal string fqname;
    internal string name;
    internal string scopename;
    internal bool is_resource;
    internal int token;
    private UIntPtr dynamic_image;
    private int num_types;
    private TypeBuilder[] types;
    private CustomAttributeBuilder[] cattrs;
    private Byte[] guid;
    private int table_idx;
    internal AssemblyBuilder assemblyb;
    private MethodBuilder[] global_methods;
    private FieldBuilder[] global_fields;
    private bool is_main;
    private MonoResource[] resources;
    private IntPtr unparented_classes;
    private Int32[] table_indexes;
    private TypeBuilder global_type;
    private Type global_type_created;
    private Dictionary`2<TypeName, TypeBuilder> name_cache;
    private Dictionary`2<string, int> us_string_cache;
    private bool transient;
    private ModuleBuilderTokenGenerator token_gen;
    private Hashtable resource_writers;
    private ISymbolWriter symbolWriter;
    private static bool has_warned_about_symbolWriter;
    private static int typeref_tokengen;
    private static int typedef_tokengen;
    private static int typespec_tokengen;
    private static int memberref_tokengen;
    private static int methoddef_tokengen;
    private Dictionary`2<MemberInfo, int> inst_tokens;
    private Dictionary`2<MemberInfo, int> inst_tokens_open;
    public string FullyQualifiedName { get; }
    internal string FileName { get; }
    unknown bool IsMain {internal set; }
    public Assembly Assembly { get; }
    public string Name { get; }
    public string ScopeName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    internal ModuleBuilder(AssemblyBuilder assb, string name, string fullyqname, bool emitSymbolInfo, bool transient);
    private static ModuleBuilder();
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ModuleBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private static void basic_init(ModuleBuilder ab);
    private static void set_wrappers_type(ModuleBuilder mb, Type ab);
    private static void WarnAboutSymbolWriter(string message);
    public virtual string get_FullyQualifiedName();
    public bool IsTransient();
    public void CreateGlobalFunctions();
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineDataImpl(string name, int size, FieldAttributes attributes);
    private void addGlobalMethod(MethodBuilder mb);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    private void AddType(TypeBuilder tb);
    private TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    internal void RegisterTypeName(TypeBuilder tb, TypeName name);
    internal TypeBuilder GetRegisteredType(TypeName name);
    [ComVisibleAttribute("True")]
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool ignoreCase);
    private TypeBuilder search_in_array(TypeBuilder[] arr, int validElementsInArray, TypeName className);
    private TypeBuilder search_nested_in_array(TypeBuilder[] arr, int validElementsInArray, TypeName className);
    private TypeBuilder GetMaybeNested(TypeBuilder t, IEnumerable`1<TypeName> nested);
    [ComVisibleAttribute("True")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal int get_next_table_index(object obj, int table, int count);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public ISymbolWriter GetSymWriter();
    public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public virtual Type[] GetTypes();
    public IResourceWriter DefineResource(string name, string description, ResourceAttributes attribute);
    public IResourceWriter DefineResource(string name, string description);
    [MonoTODOAttribute]
public void DefineUnmanagedResource(Byte[] resource);
    [MonoTODOAttribute]
public void DefineUnmanagedResource(string resourceFileName);
    public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute);
    [MonoTODOAttribute]
public void SetSymCustomAttribute(string name, Byte[] data);
    [MonoTODOAttribute]
public void SetUserEntryPoint(MethodInfo entryPoint);
    public MethodToken GetMethodToken(MethodInfo method);
    public MethodToken GetMethodToken(MethodInfo method, IEnumerable`1<Type> optionalParameterTypes);
    public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    [ComVisibleAttribute("True")]
public MethodToken GetConstructorToken(ConstructorInfo con);
    public MethodToken GetConstructorToken(ConstructorInfo constructor, IEnumerable`1<Type> optionalParameterTypes);
    public FieldToken GetFieldToken(FieldInfo field);
    [MonoTODOAttribute]
public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength);
    public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
    public StringToken GetStringConstant(string str);
    public TypeToken GetTypeToken(Type type);
    public TypeToken GetTypeToken(string name);
    private static int getUSIndex(ModuleBuilder mb, string str);
    private static int getToken(ModuleBuilder mb, object obj, bool create_open_instance);
    private static int getMethodToken(ModuleBuilder mb, MethodBase method, Type[] opt_param_types);
    internal int GetToken(string str);
    private int GetPseudoToken(MemberInfo member, bool create_open_instance);
    internal int GetToken(MemberInfo member);
    internal int GetToken(MemberInfo member, bool create_open_instance);
    internal int GetToken(MethodBase method, IEnumerable`1<Type> opt_param_types);
    internal int GetToken(MethodBase method, Type[] opt_param_types);
    internal int GetToken(SignatureHelper helper);
    internal void RegisterToken(object obj, int token);
    internal object GetRegisteredToken(int token);
    internal TokenGenerator GetTokenGenerator();
    internal static object RuntimeResolve(object obj);
    private static void build_metadata(ModuleBuilder mb);
    private void WriteToFile(IntPtr handle);
    private void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map, Dictionary`2<MemberInfo, int> inst_tokens, bool open);
    private void FixupTokens();
    internal void Save();
    internal string get_FileName();
    internal void set_IsMain(bool value);
    internal void CreateGlobalType();
    internal virtual Guid GetModuleVersionId();
    public virtual Assembly get_Assembly();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual Guid get_ModuleVersionId();
    public virtual bool IsResource();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal MemberInfo ResolveOrGetRegisteredToken(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual int get_MetadataToken();
}
internal class System.Reflection.Emit.ModuleBuilderTokenGenerator : object {
    private ModuleBuilder mb;
    public ModuleBuilderTokenGenerator(ModuleBuilder mb);
    public sealed virtual int GetToken(string str);
    public sealed virtual int GetToken(MemberInfo member, bool create_open_instance);
    public sealed virtual int GetToken(MethodBase method, Type[] opt_param_types);
    public sealed virtual int GetToken(SignatureHelper helper);
}
internal class System.Reflection.Emit.MonoResource : ValueType {
    public Byte[] data;
    public string name;
    public string filename;
    public ResourceAttributes attrs;
    public int offset;
    public Stream stream;
}
internal class System.Reflection.Emit.MonoWin32Resource : ValueType {
    public int res_type;
    public int res_id;
    public int lang_id;
    public Byte[] data;
    public MonoWin32Resource(int res_type, int res_id, int lang_id, Byte[] data);
}
internal enum System.Reflection.Emit.NativeResourceType : Enum {
    public int value__;
    public static NativeResourceType None;
    public static NativeResourceType Unmanaged;
    public static NativeResourceType Assembly;
    public static NativeResourceType Explicit;
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.OpCode : ValueType {
    internal byte op1;
    internal byte op2;
    private byte push;
    private byte pop;
    private byte size;
    private byte type;
    private byte args;
    private byte flow;
    public string Name { get; }
    public int Size { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public short Value { get; }
    internal OpCode(int p, int q);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode obj);
    public virtual string ToString();
    public string get_Name();
    public int get_Size();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public short get_Value();
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
}
internal static class System.Reflection.Emit.OpCodeNames : object {
    internal static String[] names;
    private static OpCodeNames();
}
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    [ComVisibleAttribute("True")]
public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ParameterBuilder")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.ParameterBuilder : object {
    private MethodBase methodb;
    private string name;
    private CustomAttributeBuilder[] cattrs;
    private UnmanagedMarshal marshal_info;
    private ParameterAttributes attrs;
    private int position;
    private int table_idx;
    private object def_value;
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsOptional { get; }
    public string Name { get; }
    public int Position { get; }
    internal ParameterBuilder(MethodBase mb, int pos, ParameterAttributes attributes, string strParamName);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsOptional();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual ParameterToken GetToken();
    public virtual void SetConstant(object defaultValue);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead.")]
public virtual void SetMarshal(UnmanagedMarshal unmanagedMarshal);
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.ParameterToken : ValueType {
    internal int tokValue;
    public static ParameterToken Empty;
    public int Token { get; }
    internal ParameterToken(int val);
    private static ParameterToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterToken obj);
    public static bool op_Equality(ParameterToken a, ParameterToken b);
    public static bool op_Inequality(ParameterToken a, ParameterToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
[ComVisibleAttribute("True")]
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
internal class System.Reflection.Emit.PointerType : SymbolType {
    internal PointerType(Type elementType);
    internal virtual Type InternalResolve();
    protected virtual bool IsPointerImpl();
    internal virtual string FormatName(string elementName);
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._PropertyBuilder")]
[ClassInterfaceAttribute("0")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    private PropertyAttributes attrs;
    private string name;
    private Type type;
    private Type[] parameters;
    private CustomAttributeBuilder[] cattrs;
    private object def_value;
    private MethodBuilder set_method;
    private MethodBuilder get_method;
    private int table_idx;
    internal TypeBuilder typeb;
    private Type[] returnModReq;
    private Type[] returnModOpt;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    private CallingConventions callingConvention;
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public PropertyToken PropertyToken { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    internal PropertyBuilder(TypeBuilder tb, string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public PropertyToken get_PropertyToken();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Module get_Module();
    private Exception not_supported();
}
internal class System.Reflection.Emit.PropertyOnTypeBuilderInst : PropertyInfo {
    private TypeBuilderInstantiation instantiation;
    private PropertyInfo prop;
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    internal PropertyOnTypeBuilderInst(TypeBuilderInstantiation instantiation, PropertyInfo prop);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_PropertyType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual string ToString();
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.PropertyToken : ValueType {
    internal int tokValue;
    public static PropertyToken Empty;
    public int Token { get; }
    internal PropertyToken(int val);
    private static PropertyToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyToken obj);
    public static bool op_Equality(PropertyToken a, PropertyToken b);
    public static bool op_Inequality(PropertyToken a, PropertyToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
internal class System.Reflection.Emit.RefEmitPermissionSet : ValueType {
    public SecurityAction action;
    public string pset;
    public RefEmitPermissionSet(SecurityAction action, string pset);
}
internal class System.Reflection.Emit.SequencePoint : ValueType {
    public int Offset;
    public int Line;
    public int Col;
    public int EndLine;
    public int EndCol;
}
internal class System.Reflection.Emit.SequencePointList : object {
    private ISymbolDocumentWriter doc;
    private SequencePoint[] points;
    private int count;
    private static int arrayGrow;
    public ISymbolDocumentWriter Document { get; }
    public int StartLine { get; }
    public int EndLine { get; }
    public int StartColumn { get; }
    public int EndColumn { get; }
    public SequencePointList(ISymbolDocumentWriter doc);
    public ISymbolDocumentWriter get_Document();
    public Int32[] GetOffsets();
    public Int32[] GetLines();
    public Int32[] GetColumns();
    public Int32[] GetEndLines();
    public Int32[] GetEndColumns();
    public int get_StartLine();
    public int get_EndLine();
    public int get_StartColumn();
    public int get_EndColumn();
    public void AddSequencePoint(int offset, int line, int col, int endLine, int endCol);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._SignatureHelper")]
public class System.Reflection.Emit.SignatureHelper : object {
    private ModuleBuilder module;
    private Type[] arguments;
    private SignatureHelperType type;
    private Type returnType;
    private CallingConventions callConv;
    private CallingConvention unmanagedCallConv;
    private Type[][] modreqs;
    private Type[][] modopts;
    internal SignatureHelper(ModuleBuilder module, SignatureHelperType type);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [MonoTODOAttribute("Not implemented")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [MonoTODOAttribute("Not implemented")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [MonoTODOAttribute("Not implemented")]
public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    private static int AppendArray(Type[]& array, Type t);
    private static void AppendArrayAt(Type[][]& array, Type[] t, int pos);
    private static void ValidateParameterModifiers(string name, Type[] parameter_modifiers);
    private static void ValidateCustomModifier(int n, Type[][] custom_modifiers, string name);
    private static Exception MissingFeature();
    [MonoTODOAttribute("Currently we ignore requiredCustomModifiers and optionalCustomModifiers")]
public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    [MonoTODOAttribute("pinned is ignored")]
public void AddArgument(Type argument, bool pinned);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddArgument(Type clsArgument);
    [MonoTODOAttribute("Not implemented")]
public void AddSentinel();
    private static bool CompareOK(Type[][] one, Type[][] two);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Byte[] get_signature_local();
    internal Byte[] get_signature_field();
    public Byte[] GetSignature();
    public virtual string ToString();
    internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, CallingConvention unmanagedCallingConvention, Type returnType, Type[] parameters);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._SignatureHelper.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.SignatureToken : ValueType {
    internal int tokValue;
    public static SignatureToken Empty;
    public int Token { get; }
    internal SignatureToken(int val);
    private static SignatureToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SignatureToken obj);
    public static bool op_Equality(SignatureToken a, SignatureToken b);
    public static bool op_Inequality(SignatureToken a, SignatureToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.StringToken : ValueType {
    internal int tokValue;
    public int Token { get; }
    internal StringToken(int val);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringToken obj);
    public static bool op_Equality(StringToken a, StringToken b);
    public static bool op_Inequality(StringToken a, StringToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
internal abstract class System.Reflection.Emit.SymbolType : TypeInfo {
    internal Type m_baseType;
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public string Name { get; }
    public Type UnderlyingSystemType { get; }
    internal bool IsUserType { get; }
    internal SymbolType(Type elementType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal abstract virtual string FormatName(string elementName);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public virtual string ToString();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_FullName();
    public virtual string get_Name();
    public virtual Type get_UnderlyingSystemType();
    internal virtual bool get_IsUserType();
    internal virtual Type RuntimeResolve();
}
internal interface System.Reflection.Emit.TokenGenerator {
    public abstract virtual int GetToken(string str);
    public abstract virtual int GetToken(MemberInfo member, bool create_open_instance);
    public abstract virtual int GetToken(MethodBase method, Type[] opt_param_types);
    public abstract virtual int GetToken(SignatureHelper helper);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._TypeBuilder")]
[ClassInterfaceAttribute("0")]
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    private string tname;
    private string nspace;
    private Type parent;
    private Type nesting_type;
    internal Type[] interfaces;
    internal int num_methods;
    internal MethodBuilder[] methods;
    internal ConstructorBuilder[] ctors;
    internal PropertyBuilder[] properties;
    internal int num_fields;
    internal FieldBuilder[] fields;
    internal EventBuilder[] events;
    private CustomAttributeBuilder[] cattrs;
    internal TypeBuilder[] subtypes;
    internal TypeAttributes attrs;
    private int table_idx;
    private ModuleBuilder pmodule;
    private int class_size;
    private PackingSize packing_size;
    private IntPtr generic_container;
    private GenericTypeParameterBuilder[] generic_params;
    private RefEmitPermissionSet[] permissions;
    private TypeInfo created;
    private int state;
    private TypeName fullname;
    private bool createTypeCalled;
    private Type underlying_type;
    public static int UnspecifiedTypeSize;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public Type UnderlyingSystemType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public PackingSize PackingSize { get; }
    public int Size { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public TypeToken TypeToken { get; }
    internal bool is_created { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericParameter { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    [MonoTODOAttribute]
public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    internal bool IsUserType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsTypeDefinition { get; }
    [PreserveDependencyAttribute("DoTypeBuilderResolve", "System.AppDomain")]
internal TypeBuilder(ModuleBuilder mb, TypeAttributes attr, int table_idx);
    internal TypeBuilder(ModuleBuilder mb, string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packing_size, int type_size, Type nesting_type);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    private TypeName GetFullName();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public PackingSize get_PackingSize();
    public int get_Size();
    public virtual Type get_ReflectedType();
    public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset);
    [ComVisibleAttribute("True")]
public void AddInterfaceImplementation(Type interfaceType);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    private TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    [ComVisibleAttribute("True")]
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    private void append_method(MethodBuilder mb);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [ComVisibleAttribute("True")]
public ConstructorBuilder DefineTypeInitializer();
    private TypeInfo create_runtime_class();
    private bool is_nested_in(Type t);
    private bool has_ctor_method();
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    private void ResolveUserTypes();
    internal static void ResolveUserTypes(Type[] types);
    internal static Type ResolveUserType(Type t);
    internal void FixupTokens(Dictionary`2<int, int> token_map, Dictionary`2<int, MemberInfo> member_map);
    internal void GenerateDebugInfo(ISymbolWriter symbolWriter);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    internal ConstructorInfo[] GetConstructorsInternal(BindingFlags bindingAttr);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    private MethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, Type reflected_type);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [ComVisibleAttribute("True")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    public TypeToken get_TypeToken();
    public void SetParent(Type parent);
    internal int get_next_table_index(object obj, int table, int count);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal bool get_is_created();
    private Exception not_supported();
    private void check_not_created();
    private void check_created();
    private void check_name(string argName, string name);
    public virtual string ToString();
    [MonoTODOAttribute]
public virtual bool IsAssignableFrom(Type c);
    [MonoTODOAttribute("arrays")]
internal bool IsAssignableTo(Type c);
    public bool IsCreated();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericParameter();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    private static bool IsValidGetMethodType(Type type);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    public static FieldInfo GetField(Type type, FieldInfo field);
    internal virtual bool get_IsUserType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static bool SetConstantValue(Type destType, object value, Object& destValue);
    private static void throw_argument_ConstantDoesntMatch();
    public virtual bool get_IsTypeDefinition();
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    internal Type generic_type;
    private Type[] type_arguments;
    private Hashtable fields;
    private Hashtable ctors;
    private Hashtable methods;
    private static BindingFlags flags;
    internal bool IsCreated { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Guid GUID { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public Type DeclaringType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    internal bool IsUserType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    internal TypeBuilderInstantiation(Type tb, Type[] args);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal bool get_IsCreated();
    private Type GetParentType();
    internal Type InflateType(Type type);
    internal Type InflateType(Type type, Type[] method_args);
    internal static Type InflateType(Type type, Type[] type_args, Type[] method_args);
    public virtual Type get_BaseType();
    public virtual Type[] GetInterfaces();
    protected virtual bool IsValueTypeImpl();
    internal virtual MethodInfo GetMethod(MethodInfo fromNoninstanciated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    public virtual MethodInfo[] GetMethods(BindingFlags bf);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bf);
    public virtual FieldInfo[] GetFields(BindingFlags bf);
    public virtual PropertyInfo[] GetProperties(BindingFlags bf);
    public virtual EventInfo[] GetEvents(BindingFlags bf);
    public virtual Type[] GetNestedTypes(BindingFlags bf);
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Assembly get_Assembly();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual Guid get_GUID();
    private string format_name(bool full_name, bool assembly_qualified);
    public virtual string ToString();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual Type get_DeclaringType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal virtual bool get_IsUserType();
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsConstructedGenericType();
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
[ComVisibleAttribute("True")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.TypeToken : ValueType {
    internal int tokValue;
    public static TypeToken Empty;
    public int Token { get; }
    internal TypeToken(int val);
    private static TypeToken();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeToken obj);
    public static bool op_Equality(TypeToken a, TypeToken b);
    public static bool op_Inequality(TypeToken a, TypeToken b);
    public virtual int GetHashCode();
    public int get_Token();
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute("An alternate API is available: Emit the MarshalAs custom attribute instead.")]
public class System.Reflection.Emit.UnmanagedMarshal : object {
    private int count;
    private UnmanagedType t;
    private UnmanagedType tbase;
    private string guid;
    private string mcookie;
    private string marshaltype;
    internal Type marshaltyperef;
    private int param_num;
    private bool has_size;
    public UnmanagedType BaseType { get; }
    public int ElementCount { get; }
    public UnmanagedType GetUnmanagedType { get; }
    public Guid IIDGuid { get; }
    private UnmanagedMarshal(UnmanagedType maint, int cnt);
    private UnmanagedMarshal(UnmanagedType maint, UnmanagedType elemt);
    public UnmanagedType get_BaseType();
    public int get_ElementCount();
    public UnmanagedType get_GetUnmanagedType();
    public Guid get_IIDGuid();
    public static UnmanagedMarshal DefineByValArray(int elemCount);
    public static UnmanagedMarshal DefineByValTStr(int elemCount);
    public static UnmanagedMarshal DefineLPArray(UnmanagedType elemType);
    public static UnmanagedMarshal DefineSafeArray(UnmanagedType elemType);
    public static UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType);
    internal static UnmanagedMarshal DefineCustom(Type typeref, string cookie, string mtype, Guid id);
    internal static UnmanagedMarshal DefineLPArrayInternal(UnmanagedType elemType, int sizeConst, int sizeParamIndex);
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    private AddEventAdapter cached_add_event;
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public sealed virtual bool get_IsSpecialName();
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public sealed virtual MethodInfo GetAddMethod();
    public sealed virtual MethodInfo GetRemoveMethod();
    public sealed virtual MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    private static void AddEventFrame(AddEvent`2<T, D> addEvent, object obj, object dele);
    private static void StaticAddEventAdapterFrame(StaticAddEvent`1<D> addEvent, object obj, object dele);
    private static AddEventAdapter CreateAddEventDelegate(MethodInfo method);
    private static EventInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
    internal static EventInfo GetEventFromHandle(RuntimeEventHandle handle, RuntimeTypeHandle reflectedType);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._EventInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._EventInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
public static class System.Reflection.EventInfoExtensions : object {
    public static MethodInfo GetAddMethod(EventInfo eventInfo);
    public static MethodInfo GetAddMethod(EventInfo eventInfo, bool nonPublic);
    public static MethodInfo GetRaiseMethod(EventInfo eventInfo);
    public static MethodInfo GetRaiseMethod(EventInfo eventInfo, bool nonPublic);
    public static MethodInfo GetRemoveMethod(EventInfo eventInfo);
    public static MethodInfo GetRemoveMethod(EventInfo eventInfo, bool nonPublic);
}
[ComVisibleAttribute("True")]
public class System.Reflection.ExceptionHandlingClause : object {
    internal Type catch_type;
    internal int filter_offset;
    internal ExceptionHandlingClauseOptions flags;
    internal int try_offset;
    internal int try_length;
    internal int handler_offset;
    internal int handler_length;
    public Type CatchType { get; }
    public int FilterOffset { get; }
    public ExceptionHandlingClauseOptions Flags { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public virtual Type get_CatchType();
    public virtual int get_FilterOffset();
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_HandlerLength();
    public virtual int get_HandlerOffset();
    public virtual int get_TryLength();
    public virtual int get_TryOffset();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_FieldType();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsLiteral();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsPinvokeImpl();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public abstract virtual object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual object GetRawConstantValue();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    private static FieldInfo internal_from_handle_type(IntPtr field_handle, IntPtr type_handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    [ComVisibleAttribute("False")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    internal virtual int GetFieldOffset();
    private MarshalAsAttribute get_marshal_info();
    internal Object[] GetPseudoCustomAttributes();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._FieldInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._FieldInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class System.Reflection.Getter`2 : MulticastDelegate {
    public Getter`2(object object, IntPtr method);
    public virtual R Invoke(T _this);
    public virtual IAsyncResult BeginInvoke(T _this, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
internal class System.Reflection.GetterAdapter : MulticastDelegate {
    public GetterAdapter(object object, IntPtr method);
    public virtual object Invoke(object _this);
    public virtual IAsyncResult BeginInvoke(object _this, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
[ComVisibleAttribute("True")]
public class System.Reflection.LocalVariableInfo : object {
    internal Type type;
    internal bool is_pinned;
    internal ushort position;
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
    public virtual string ToString();
}
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
[FlagsAttribute]
internal enum System.Reflection.MdSigCallingConvention : Enum {
    public byte value__;
    public static MdSigCallingConvention CallConvMask;
    public static MdSigCallingConvention Default;
    public static MdSigCallingConvention C;
    public static MdSigCallingConvention StdCall;
    public static MdSigCallingConvention ThisCall;
    public static MdSigCallingConvention FastCall;
    public static MdSigCallingConvention Vararg;
    public static MdSigCallingConvention Field;
    public static MdSigCallingConvention LocalSig;
    public static MdSigCallingConvention Property;
    public static MdSigCallingConvention Unmgd;
    public static MdSigCallingConvention GenericInst;
    public static MdSigCallingConvention Generic;
    public static MdSigCallingConvention HasThis;
    public static MdSigCallingConvention ExplicitThis;
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
    internal virtual bool CacheEquals(object o);
    internal bool HasSameMetadataDefinitionAsCore(MemberInfo other);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._MemberInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MemberInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ExtensionAttribute]
public static class System.Reflection.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static bool HasMetadataToken(MemberInfo member);
    [ExtensionAttribute]
public static int GetMetadataToken(MemberInfo member);
    private static int GetMetadataTokenOrZeroOrThrow(MemberInfo member);
}
internal class System.Reflection.MemberInfoSerializationHolder : object {
    private string m_memberName;
    private RuntimeType m_reflectedType;
    private string m_signature;
    private string m_signature2;
    private MemberTypes m_memberType;
    private SerializationInfo m_info;
    internal MemberInfoSerializationHolder(SerializationInfo info, StreamingContext context);
    public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, MemberTypes type);
    public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, string signature2, MemberTypes type, Type[] genericArguments);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.AssemblyExtensions : object {
    [CLSCompliantAttribute("False")]
[ExtensionAttribute]
public static bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length);
}
internal enum System.Reflection.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldDef;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamDef;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType Permission;
    public static MetadataTokenType Signature;
    public static MetadataTokenType Event;
    public static MetadataTokenType Property;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType GenericPar;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType String;
    public static MetadataTokenType Name;
    public static MetadataTokenType BaseType;
    public static MetadataTokenType Invalid;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsFinal();
    public sealed virtual bool get_IsHideBySig();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsAssembly();
    public sealed virtual bool get_IsFamily();
    public sealed virtual bool get_IsFamilyAndAssembly();
    public sealed virtual bool get_IsFamilyOrAssembly();
    public sealed virtual bool get_IsPrivate();
    public sealed virtual bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public sealed virtual object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    internal virtual int get_next_table_index(object obj, int table, int count);
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual Type[] GetParameterTypes();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    [ComVisibleAttribute("False")]
public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    internal static string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization);
    public static MethodBase GetCurrentMethod();
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._MethodBase.GetType();
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodBase.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
public class System.Reflection.MethodBody : object {
    private ExceptionHandlingClause[] clauses;
    private LocalVariableInfo[] locals;
    private Byte[] il;
    private bool init_locals;
    private int sig_token;
    private int max_stack;
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public int MaxStackSize { get; }
    internal MethodBody(ExceptionHandlingClause[] clauses, LocalVariableInfo[] locals, Byte[] il, bool init_locals, int sig_token, int max_stack);
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
    public virtual int get_MaxStackSize();
    public virtual Byte[] GetILAsByteArray();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
    public static MethodImplAttributes SecurityMitigations;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._MethodInfo")]
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal int GenericParameterCount { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._MethodInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override Type System.Runtime.InteropServices._MethodInfo.GetType();
    internal virtual int get_GenericParameterCount();
}
public static class System.Reflection.MethodInfoExtensions : object {
    public static MethodInfo GetBaseDefinition(MethodInfo method);
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.MissingMetadataException : TypeAccessException {
    public MissingMetadataException(string message);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    internal Guid MvId { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    internal virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual Type[] GetTypes();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria);
    private static bool FilterTypeNameIgnoreCaseImpl(Type cls, object filterCriteria);
    internal Guid get_MvId();
    internal static Guid Mono_GetGuid(Module module);
    internal virtual Guid GetModuleVersionId();
    public virtual X509Certificate GetSignerCertificate();
    private sealed virtual override void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Module.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Module.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Module.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ExtensionAttribute]
public static class System.Reflection.ModuleExtensions : object {
    [ExtensionAttribute]
public static bool HasModuleVersionId(Module module);
    [ExtensionAttribute]
public static Guid GetModuleVersionId(Module module);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
internal class System.Reflection.MonoArrayMethod : MethodInfo {
    internal RuntimeMethodHandle mhandle;
    internal Type parent;
    internal Type ret;
    internal Type[] parameters;
    internal string name;
    internal int table_idx;
    internal CallingConventions call_conv;
    public Type ReturnType { get; }
    [MonoTODOAttribute("Not implemented.  Always returns null")]
public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    [MonoTODOAttribute("Not implemented.  Always returns zero")]
public MethodAttributes Attributes { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    internal MonoArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    [MonoTODOAttribute("Always returns this")]
public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [MonoTODOAttribute("Not implemented.  Always returns zero")]
public virtual MethodImplAttributes GetMethodImplementationFlags();
    [MonoTODOAttribute("Not implemented.  Always returns an empty array")]
public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    [MonoTODOAttribute("Not implemented.  Always returns 0")]
internal virtual int GetParametersCount();
    [MonoTODOAttribute("Not implemented")]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal class System.Reflection.MonoEventInfo : ValueType {
    public Type declaring_type;
    public Type reflected_type;
    public string name;
    public MethodInfo add_method;
    public MethodInfo remove_method;
    public MethodInfo raise_method;
    public EventAttributes attrs;
    public MethodInfo[] other_methods;
}
internal class System.Reflection.MonoMethodInfo : ValueType {
    private Type parent;
    private Type ret;
    internal MethodAttributes attrs;
    internal MethodImplAttributes iattrs;
    private CallingConventions callconv;
    private static void get_method_info(IntPtr handle, MonoMethodInfo& info);
    private static int get_method_attributes(IntPtr handle);
    internal static MonoMethodInfo GetMethodInfo(IntPtr handle);
    internal static Type GetDeclaringType(IntPtr handle);
    internal static Type GetReturnType(IntPtr handle);
    internal static MethodAttributes GetAttributes(IntPtr handle);
    internal static CallingConventions GetCallingConvention(IntPtr handle);
    internal static MethodImplAttributes GetMethodImplementationFlags(IntPtr handle);
    private static ParameterInfo[] get_parameter_info(IntPtr handle, MemberInfo member);
    internal static ParameterInfo[] GetParametersInfo(IntPtr handle, MemberInfo member);
    private static MarshalAsAttribute get_retval_marshal(IntPtr handle);
    internal static ParameterInfo GetReturnParameterInfo(RuntimeMethodInfo method);
}
internal class System.Reflection.MonoPropertyInfo : ValueType {
    public Type parent;
    public Type declaring_type;
    public string name;
    public MethodInfo get_method;
    public MethodInfo set_method;
    public PropertyAttributes attrs;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    protected Type ClassImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    protected string NameImpl;
    protected int PositionImpl;
    private static int MetadataToken_ParamDef;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    [SecurityCriticalAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._ParameterInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[FlagsAttribute]
internal enum System.Reflection.PInfo : Enum {
    public int value__;
    public static PInfo Attributes;
    public static PInfo GetMethod;
    public static PInfo SetMethod;
    public static PInfo ReflectedType;
    public static PInfo DeclaringType;
    public static PInfo Name;
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private Type _ptrType;
    private Pointer(Void* ptr, Type ptrType);
    public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal Type GetPointerType();
    internal IntPtr GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual Type get_PropertyType();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public sealed virtual bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public sealed virtual MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public sealed virtual MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public sealed virtual MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override Type System.Runtime.InteropServices._PropertyInfo.GetType();
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._PropertyInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
public static class System.Reflection.PropertyInfoExtensions : object {
    public static MethodInfo[] GetAccessors(PropertyInfo property);
    public static MethodInfo[] GetAccessors(PropertyInfo property, bool nonPublic);
    public static MethodInfo GetGetMethod(PropertyInfo property);
    public static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic);
    public static MethodInfo GetSetMethod(PropertyInfo property);
    public static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic);
}
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    public Type[] Types { get; }
    public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    private ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public Exception[] get_LoaderExceptions();
    public virtual string get_Message();
    public virtual string ToString();
    private string CreateString(bool isMessage);
}
internal static class System.Reflection.Requires : object {
    internal static void NotNull(object obj, string name);
}
internal enum System.Reflection.ResolveTokenError : Enum {
    public int value__;
    public static ResolveTokenError OutOfRange;
    public static ResolveTokenError BadTable;
    public static ResolveTokenError Other;
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
internal abstract class System.Reflection.RtFieldInfo : FieldInfo {
    internal abstract virtual object UnsafeGetValue(object obj);
    internal abstract virtual void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    internal abstract virtual void CheckConsistency(object target);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Assembly")]
[ClassInterfaceAttribute("0")]
internal class System.Reflection.RuntimeAssembly : Assembly {
    internal IntPtr _mono_assembly;
    internal Evidence _evidence;
    internal ResolveEventHolder resolve_event_holder;
    internal PermissionSet _minimum;
    internal PermissionSet _optional;
    internal PermissionSet _refuse;
    internal PermissionSet _granted;
    internal PermissionSet _denied;
    internal bool fromByteArray;
    internal string assemblyName;
    [ComVisibleAttribute("False")]
public Module ManifestModule { get; }
    public bool GlobalAssemblyCache { get; }
    public MethodInfo EntryPoint { get; }
    [ComVisibleAttribute("False")]
public bool ReflectionOnly { get; }
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public string FullName { get; }
    [ComVisibleAttribute("False")]
public string ImageRuntimeVersion { get; }
    internal IntPtr MonoAssembly { get; }
    unknown bool FromByteArray {internal set; }
    public string Location { get; }
    public Evidence Evidence { get; }
    internal PermissionSet GrantedPermissionSet { get; }
    internal PermissionSet DeniedPermissionSet { get; }
    public PermissionSet PermissionSet { get; }
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
internal static AssemblyName CreateAssemblyName(string assemblyString, bool forIntrospection, RuntimeAssembly& assemblyFromResolveEvent);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks);
    internal static RuntimeAssembly LoadWithPartialNameInternal(string partialName, Evidence securityEvidence, StackCrawlMark& stackMark);
    internal static RuntimeAssembly LoadWithPartialNameInternal(AssemblyName an, Evidence securityEvidence, StackCrawlMark& stackMark);
    public virtual AssemblyName GetName(bool copiedName);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Module[] GetModules(bool getResourceModules);
    [MonoTODOAttribute("Always returns the same as GetModules")]
public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Module get_ManifestModule();
    public virtual bool get_GlobalAssemblyCache();
    public virtual Type[] GetExportedTypes();
    internal static Byte[] GetAotId();
    private static string get_code_base(Assembly a, bool escaped);
    private string get_location();
    internal static string get_fullname(Assembly a);
    internal static bool GetAotIdInternal(Byte[] aotid);
    internal static string InternalImageRuntimeVersion(Assembly a);
    internal bool get_global_assembly_cache();
    public virtual MethodInfo get_EntryPoint();
    public virtual bool get_ReflectionOnly();
    internal static string GetCodeBase(Assembly a, bool escaped);
    public virtual string get_CodeBase();
    public virtual string get_EscapedCodeBase();
    public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    internal virtual IntPtr get_MonoAssembly();
    internal virtual void set_FromByteArray(bool value);
    public virtual string get_Location();
    private bool GetManifestResourceInfoInternal(string name, ManifestResourceInfo info);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    internal IntPtr GetManifestResourceInternal(string name, Int32& size, Module& module);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    internal virtual Module GetManifestModule();
    internal Module GetManifestModuleInternal();
    internal virtual Module[] GetModulesInternal();
    private object GetFilesInternal(string name, bool getResourceModules);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual FileStream GetFile(string name);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
    public virtual Evidence get_Evidence();
    internal virtual Evidence UnprotectedGetEvidence();
    internal void Resolve();
    internal virtual PermissionSet get_GrantedPermissionSet();
    internal virtual PermissionSet get_DeniedPermissionSet();
    internal static bool LoadPermissions(Assembly a, IntPtr& minimum, Int32& minLength, IntPtr& optional, Int32& optLength, IntPtr& refused, Int32& refLength);
    private void LoadAssemblyPermissions();
    public virtual PermissionSet get_PermissionSet();
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    internal IntPtr mhandle;
    private string name;
    private Type reftype;
    public Module Module { get; }
    internal BindingFlags BindingFlags { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public int MetadataToken { get; }
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    internal BindingFlags get_BindingFlags();
    private RuntimeType get_ReflectedTypeInternal();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    internal void SerializationInvoke(object target, SerializationInfo info, StreamingContext context);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal object InternalInvoke(object obj, Object[] parameters, Exception& exc);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    private object DoInvoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public object InternalInvoke(object obj, Object[] parameters, bool wrapExceptions);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodBody GetMethodBody();
    public virtual string ToString();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public int get_core_clr_security_level();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimeConstructorInfo method);
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    private IntPtr klass;
    private IntPtr handle;
    public Module Module { get; }
    internal BindingFlags BindingFlags { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    private static void get_event_info(RuntimeEventInfo ev, MonoEventInfo& info);
    internal static MonoEventInfo GetEventInfo(RuntimeEventInfo ev);
    public virtual Module get_Module();
    internal BindingFlags get_BindingFlags();
    internal RuntimeType GetDeclaringTypeInternal();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal BindingFlags GetBindingFlags();
    public virtual EventAttributes get_Attributes();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual string ToString();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    internal static int get_metadata_token(RuntimeEventInfo monoEvent);
}
internal class System.Reflection.RuntimeFieldInfo : RtFieldInfo {
    internal IntPtr klass;
    internal RuntimeFieldHandle fhandle;
    private string name;
    private Type type;
    private FieldAttributes attrs;
    internal BindingFlags BindingFlags { get; }
    public Module Module { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public int MetadataToken { get; }
    internal BindingFlags get_BindingFlags();
    public virtual Module get_Module();
    internal RuntimeType GetDeclaringTypeInternal();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual object UnsafeGetValue(object obj);
    internal virtual void CheckConsistency(object target);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal virtual void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValueDirect(TypedReference obj);
    public virtual FieldAttributes get_Attributes();
    public virtual RuntimeFieldHandle get_FieldHandle();
    private Type ResolveType();
    public virtual Type get_FieldType();
    private Type GetParentType(bool declaring);
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal virtual int GetFieldOffset();
    private object GetValueInternal(object obj);
    public virtual object GetValue(object obj);
    public virtual string ToString();
    private static void SetValueInternal(FieldInfo fi, object obj, object value);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    internal RuntimeFieldInfo Clone(string newName);
    public virtual object GetRawConstantValue();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    private void CheckGeneric();
    public int get_core_clr_security_level();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimeFieldInfo monoField);
    private Type[] GetTypeModifiers(bool optional);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool optional);
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    internal IntPtr mhandle;
    private string name;
    private Type reftype;
    internal BindingFlags BindingFlags { get; }
    public Module Module { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    internal RuntimeMethodInfo(RuntimeMethodHandle mhandle);
    internal BindingFlags get_BindingFlags();
    public virtual Module get_Module();
    private RuntimeType get_ReflectedTypeInternal();
    internal virtual string FormatNameAndSig(bool serialization);
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual string ToString();
    internal RuntimeModule GetRuntimeModule();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle);
    internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle, RuntimeTypeHandle reflectedType);
    [PreserveDependencyAttribute(".ctor(System.Reflection.ExceptionHandlingClause[],System.Reflection.LocalVariableInfo[],System.Byte[],System.Boolean,System.Int32,System.Int32)", "System.Reflection.MethodBody")]
internal static MethodBody GetMethodBodyInternal(IntPtr handle);
    internal static MethodBody GetMethodBody(IntPtr handle);
    internal static MethodBase GetMethodFromHandleInternalType(IntPtr method_handle, IntPtr type_handle);
    private static MethodBase GetMethodFromHandleInternalType_native(IntPtr method_handle, IntPtr type_handle, bool genericCheck);
    internal static string get_name(MethodBase method);
    internal static RuntimeMethodInfo get_base_method(RuntimeMethodInfo method, bool definition);
    internal static int get_metadata_token(RuntimeMethodInfo method);
    public virtual MethodInfo GetBaseDefinition();
    internal MethodInfo GetBaseMethod();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual int get_MetadataToken();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal object InternalInvoke(object obj, Object[] parameters, Exception& exc);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal static void ConvertValues(Binder binder, Object[] args, ParameterInfo[] pinfo, CultureInfo culture, BindingFlags invokeAttr);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal void GetPInvoke(PInvokeAttributes& flags, String& entryPoint, String& dllName);
    internal Object[] GetPseudoCustomAttributes();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    private CustomAttributeData GetDllImportAttributeData();
    public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    private MethodInfo MakeGenericMethod_impl(Type[] types);
    public virtual Type[] GetGenericArguments();
    private MethodInfo GetGenericMethodDefinition_impl();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBody GetMethodBody();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public int get_core_clr_security_level();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Module")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class System.Reflection.RuntimeModule : Module {
    internal IntPtr _impl;
    internal Assembly assembly;
    internal string fqname;
    internal string name;
    internal string scopename;
    internal bool is_resource;
    internal int token;
    public Assembly Assembly { get; }
    public string Name { get; }
    public string ScopeName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string FullyQualifiedName { get; }
    public int MetadataToken { get; }
    internal IntPtr MonoModule { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_FullyQualifiedName();
    public virtual bool IsResource();
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual int get_MetadataToken();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    internal virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static FieldInfo ResolveField(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static MemberInfo ResolveMember(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static MethodBase ResolveMethod(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    internal static string ResolveString(Module module, IntPtr monoModule, int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static Type ResolveType(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    internal static Byte[] ResolveSignature(Module module, IntPtr monoModule, int metadataToken);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual X509Certificate GetSignerCertificate();
    public virtual Type[] GetTypes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal RuntimeAssembly GetRuntimeAssembly();
    internal IntPtr get_MonoModule();
    internal virtual Guid GetModuleVersionId();
    internal static Exception resolve_token_exception(string name, int metadataToken, ResolveTokenError error, string tokenType);
    internal static IntPtr[] ptrs_from_types(Type[] types);
    internal static int get_MetadataToken(Module module);
    internal static int GetMDStreamVersion(IntPtr module);
    internal static Type[] InternalGetTypes(IntPtr module);
    internal static IntPtr GetHINSTANCE(IntPtr module);
    private static void GetGuidInternal(IntPtr module, Byte[] guid);
    internal static Type GetGlobalType(IntPtr module);
    internal static IntPtr ResolveTypeToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static IntPtr ResolveMethodToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static IntPtr ResolveFieldToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static string ResolveStringToken(IntPtr module, int token, ResolveTokenError& error);
    internal static MemberInfo ResolveMemberToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static Byte[] ResolveSignature(IntPtr module, int metadataToken, ResolveTokenError& error);
    internal static void GetPEKind(IntPtr module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
}
[ClassInterfaceAttribute("0")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._ParameterInfo")]
[ComVisibleAttribute("True")]
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    internal MarshalAsAttribute marshalAs;
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    public bool HasDefaultValue { get; }
    internal RuntimeParameterInfo(string name, Type type, int position, int attrs, object defaultValue, MemberInfo member, MarshalAsAttribute marshalAs);
    internal RuntimeParameterInfo(ParameterBuilder pb, Type type, MemberInfo member, int position);
    internal RuntimeParameterInfo(ParameterInfo pinfo, Type type, MemberInfo member, int position);
    internal RuntimeParameterInfo(ParameterInfo pinfo, MemberInfo member);
    internal RuntimeParameterInfo(Type type, MemberInfo member, MarshalAsAttribute marshalAs);
    internal static void FormatParameters(StringBuilder sb, ParameterInfo[] p, CallingConventions callingConvention, bool serialization);
    internal static ParameterInfo New(ParameterBuilder pb, Type type, MemberInfo member, int position);
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual int get_MetadataToken();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal object GetDefaultValueImpl(ParameterInfo pinfo);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal int GetMetadataToken();
    public virtual Type[] GetOptionalCustomModifiers();
    internal Object[] GetPseudoCustomAttributes();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool get_HasDefaultValue();
    internal static Type[] GetTypeModifiers(Type type, MemberInfo member, int position, bool optional);
    internal static ParameterInfo New(ParameterInfo pinfo, Type type, MemberInfo member, int position);
    internal static ParameterInfo New(ParameterInfo pinfo, MemberInfo member);
    internal static ParameterInfo New(Type type, MemberInfo member, MarshalAsAttribute marshalAs);
    private Type[] GetCustomModifiers(bool optional);
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    internal IntPtr klass;
    internal IntPtr prop;
    private MonoPropertyInfo info;
    private PInfo cached;
    private GetterAdapter cached_getter;
    internal BindingFlags BindingFlags { get; }
    public Module Module { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    internal static void get_property_info(RuntimePropertyInfo prop, MonoPropertyInfo& info, PInfo req_info);
    internal static Type[] GetTypeModifiers(RuntimePropertyInfo prop, bool optional);
    internal static object get_default_value(RuntimePropertyInfo prop);
    internal BindingFlags get_BindingFlags();
    public virtual Module get_Module();
    internal RuntimeType GetDeclaringTypeInternal();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    public virtual string ToString();
    private string FormatNameAndSig(bool serialization);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    private void CachePropertyInfo(PInfo flags);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    private static object GetterAdapterFrame(Getter`2<T, R> getter, object obj);
    private static object StaticGetterAdapterFrame(StaticGetter`1<R> getter, object obj);
    private static GetterAdapter CreateGetterDelegate(MethodInfo method);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool optional);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimePropertyInfo monoProperty);
    private static PropertyInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
    internal static PropertyInfo GetPropertyFromHandle(RuntimePropertyHandle handle, RuntimeTypeHandle reflectedType);
}
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    private static BindingFlags Everything;
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
}
internal class System.Reflection.SignatureArrayType : SignatureHasElementType {
    private int _rank;
    private bool _isMultiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureArrayType(SignatureType elementType, int rank, bool isMultiDim);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureByRefType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureByRefType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureConstructedGenericType : SignatureType {
    private Type _genericTypeDefinition;
    private Type[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal SignatureConstructedGenericType(Type genericTypeDefinition, Type[] typeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal class System.Reflection.SignatureGenericMethodParameterType : SignatureGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public string Name { get; }
    internal SignatureGenericMethodParameterType(int position);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual string get_Name();
}
internal abstract class System.Reflection.SignatureGenericParameterType : SignatureType {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SignatureGenericParameterType(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public abstract virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.SignatureHasElementType : SignatureType {
    private SignatureType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected string Suffix { get; }
    protected SignatureHasElementType(SignatureType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public abstract virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
    protected abstract virtual string get_Suffix();
}
internal class System.Reflection.SignaturePointerType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignaturePointerType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.SignatureType : Type {
    public bool IsSignatureType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MemberTypes MemberType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    internal SignatureType ElementType { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsEnum { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public sealed virtual bool get_IsSignatureType();
    public abstract virtual bool get_IsTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    public abstract virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsGenericType();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual MemberTypes get_MemberType();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterPosition();
    internal abstract virtual SignatureType get_ElementType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual Type get_BaseType();
    public sealed virtual Type[] GetInterfaces();
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual Guid get_GUID();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetDefaultMembers();
    public sealed virtual EventInfo[] GetEvents();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    protected sealed virtual bool IsContextfulImpl();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool IsEquivalentTo(Type other);
    public sealed virtual bool IsInstanceOfType(object o);
    protected sealed virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool IsSubclassOf(Type c);
    protected sealed virtual bool IsValueTypeImpl();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
}
[ExtensionAttribute]
internal static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(SignatureType pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(SignatureType signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
private static Type TryResolve(SignatureType signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
[ComVisibleAttribute("True")]
public class System.Reflection.StrongNameKeyPair : object {
    private Byte[] _publicKey;
    private string _keyPairContainer;
    private bool _keyPairExported;
    private Byte[] _keyPairArray;
    private RSA _rsa;
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(Byte[] keyPairArray);
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(string keyPairContainer);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private RSA GetRSA();
    private void LoadKey(Byte[] key);
    public Byte[] get_PublicKey();
    internal StrongName StrongName();
}
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsCollectible();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public static class System.Reflection.TypeExtensions : object {
    public static ConstructorInfo GetConstructor(Type type, Type[] types);
    public static ConstructorInfo[] GetConstructors(Type type);
    public static ConstructorInfo[] GetConstructors(Type type, BindingFlags bindingAttr);
    public static MemberInfo[] GetDefaultMembers(Type type);
    public static EventInfo GetEvent(Type type, string name);
    public static EventInfo GetEvent(Type type, string name, BindingFlags bindingAttr);
    public static EventInfo[] GetEvents(Type type);
    public static EventInfo[] GetEvents(Type type, BindingFlags bindingAttr);
    public static FieldInfo GetField(Type type, string name);
    public static FieldInfo GetField(Type type, string name, BindingFlags bindingAttr);
    public static FieldInfo[] GetFields(Type type);
    public static FieldInfo[] GetFields(Type type, BindingFlags bindingAttr);
    public static Type[] GetGenericArguments(Type type);
    public static Type[] GetInterfaces(Type type);
    public static MemberInfo[] GetMember(Type type, string name);
    public static MemberInfo[] GetMember(Type type, string name, BindingFlags bindingAttr);
    public static MemberInfo[] GetMembers(Type type);
    public static MemberInfo[] GetMembers(Type type, BindingFlags bindingAttr);
    public static MethodInfo GetMethod(Type type, string name);
    public static MethodInfo GetMethod(Type type, string name, BindingFlags bindingAttr);
    public static MethodInfo GetMethod(Type type, string name, Type[] types);
    public static MethodInfo[] GetMethods(Type type);
    public static MethodInfo[] GetMethods(Type type, BindingFlags bindingAttr);
    public static Type GetNestedType(Type type, string name, BindingFlags bindingAttr);
    public static Type[] GetNestedTypes(Type type, BindingFlags bindingAttr);
    public static PropertyInfo[] GetProperties(Type type);
    public static PropertyInfo[] GetProperties(Type type, BindingFlags bindingAttr);
    public static PropertyInfo GetProperty(Type type, string name);
    public static PropertyInfo GetProperty(Type type, string name, BindingFlags bindingAttr);
    public static PropertyInfo GetProperty(Type type, string name, Type returnType);
    public static PropertyInfo GetProperty(Type type, string name, Type returnType, Type[] types);
    public static bool IsAssignableFrom(Type type, Type c);
    public static bool IsInstanceOfType(Type type, object o);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    private static BindingFlags DeclaredOnlyLookup;
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
}
internal class System.ReflectionOnlyType : RuntimeType {
    public RuntimeTypeHandle TypeHandle { get; }
    public virtual RuntimeTypeHandle get_TypeHandle();
}
internal static class System.ResId : object {
    internal static string Arg_ArrayLengthsDiffer;
    internal static string Argument_InvalidNumberOfMembers;
    internal static string Argument_UnequalMembers;
    internal static string Argument_SpecifyValueSize;
    internal static string Argument_UnmatchingSymScope;
    internal static string Argument_NotInExceptionBlock;
    internal static string Argument_NotExceptionType;
    internal static string Argument_InvalidLabel;
    internal static string Argument_UnclosedExceptionBlock;
    internal static string Argument_MissingDefaultConstructor;
    internal static string Argument_TooManyFinallyClause;
    internal static string Argument_NotInTheSameModuleBuilder;
    internal static string Argument_BadCurrentLocalVariable;
    internal static string Argument_DuplicateModuleName;
    internal static string Argument_BadPersistableModuleInTransientAssembly;
    internal static string Argument_HasToBeArrayClass;
    internal static string Argument_InvalidDirectory;
    internal static string MissingType;
    internal static string MissingModule;
    internal static string ArgumentOutOfRange_Index;
    internal static string ArgumentOutOfRange_Range;
    internal static string ExecutionEngine_YoureHosed;
    internal static string Format_NeedSingleChar;
    internal static string Format_StringZeroLength;
    internal static string InvalidOperation_EnumEnded;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumNotStarted;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string InvalidOperation_InternalState;
    internal static string InvalidOperation_ModifyRONumFmtInfo;
    internal static string InvalidOperation_MethodBaked;
    internal static string InvalidOperation_NotADebugModule;
    internal static string InvalidOperation_MethodHasBody;
    internal static string InvalidOperation_OpenLocalVariableScope;
    internal static string InvalidOperation_TypeHasBeenCreated;
    internal static string InvalidOperation_RefedAssemblyNotSaved;
    internal static string InvalidOperation_AssemblyHasBeenSaved;
    internal static string InvalidOperation_ModuleHasBeenSaved;
    internal static string InvalidOperation_CannotAlterAssembly;
    internal static string NotSupported_CannotSaveModuleIndividually;
    internal static string NotSupported_Constructor;
    internal static string NotSupported_Method;
    internal static string NotSupported_NYI;
    internal static string NotSupported_DynamicModule;
    internal static string NotSupported_NotDynamicModule;
    internal static string NotSupported_NotAllTypesAreBaked;
    internal static string NotSupported_SortedListNestedWrite;
    internal static string Serialization_ArrayInvalidLength;
    internal static string Serialization_ArrayNoLength;
    internal static string Serialization_CannotGetType;
    internal static string Serialization_InsufficientState;
    internal static string Serialization_InvalidID;
    internal static string Serialization_MalformedArray;
    internal static string Serialization_MultipleMembers;
    internal static string Serialization_NoID;
    internal static string Serialization_NoType;
    internal static string Serialization_NoBaseType;
    internal static string Serialization_NullSignature;
    internal static string Serialization_UnknownMember;
    internal static string Serialization_BadParameterInfo;
    internal static string Serialization_NoParameterInfo;
    internal static string WeakReference_NoLongerValid;
    internal static string Loader_InvalidPath;
}
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    [SecurityCriticalAttribute]
public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    [SecurityCriticalAttribute]
public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    [SecurityCriticalAttribute]
internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    [SecuritySafeCriticalAttribute]
public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public sealed virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
    private string FindResourceFile(CultureInfo culture, string fileName);
    [SecurityCriticalAttribute]
private ResourceSet CreateResourceSet(string file);
}
internal class System.Resources.ICONDIRENTRY : object {
    public byte bWidth;
    public byte bHeight;
    public byte bColorCount;
    public byte bReserved;
    public short wPlanes;
    public short wBitCount;
    public int dwBytesInRes;
    public int dwImageOffset;
    public Byte[] image;
    public virtual string ToString();
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public abstract virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
public interface System.Resources.IResourceWriter {
    public abstract virtual void AddResource(string name, string value);
    public abstract virtual void AddResource(string name, object value);
    public abstract virtual void AddResource(string name, Byte[] value);
    public abstract virtual void Close();
    public abstract virtual void Generate();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    [SecuritySafeCriticalAttribute]
public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    public sealed virtual bool HasNeutralResources(CultureInfo culture, string defaultResName);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    [SecurityCriticalAttribute]
internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    [SecurityCriticalAttribute]
internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    [SecurityCriticalAttribute]
private Stream GetManifestResourceStream(RuntimeAssembly satellite, string fileName, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
private Stream CaseInsensitiveManifestResourceStreamLookup(RuntimeAssembly satellite, string name);
    [SecurityCriticalAttribute]
private RuntimeAssembly GetSatelliteAssembly(CultureInfo lookForCulture, StackCrawlMark& stackMark);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    [SecurityCriticalAttribute]
private string GetSatelliteAssemblyName();
    [SecurityCriticalAttribute]
private void HandleSatelliteMissing();
    [SecurityCriticalAttribute]
private void HandleResourceStreamMissing(string fileName);
    private static bool GetNeutralResourcesLanguageAttribute(Assembly assembly, String& cultureName, Int16& fallbackLocation);
}
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
internal class System.Resources.NameOrId : object {
    private string name;
    private int id;
    public bool IsName { get; }
    public string Name { get; }
    public int Id { get; }
    public NameOrId(string name);
    public NameOrId(int id);
    public bool get_IsName();
    public string get_Name();
    public int get_Id();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceManager : object {
    protected string BaseNameField;
    [ObsoleteAttribute("call InternalGetResourceSet instead")]
protected Hashtable ResourceSets;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string moduleDir;
    protected Assembly MainAssembly;
    private Type _locationInfo;
    private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool UseManifest;
    [OptionalFieldAttribute]
private bool UseSatelliteAssem;
    [OptionalFieldAttribute]
private UltimateResourceFallbackLocation _fallbackLoc;
    [OptionalFieldAttribute]
private Version _satelliteContractVersion;
    [OptionalFieldAttribute]
private bool _lookedForSatelliteContractVersion;
    [OptionalFieldAttribute]
private Assembly _callingAssembly;
    [OptionalFieldAttribute]
private RuntimeAssembly m_callingAssembly;
    private IResourceGroveler resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    private static Type _minResourceSet;
    internal static string ResReaderTypeName;
    internal static string ResSetTypeName;
    internal static string MscorlibName;
    internal static string ResFileExtension;
    internal static int ResFileExtensionLength;
    internal static int DEBUG;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    private void Init();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [SecuritySafeCriticalAttribute]
[OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [SecuritySafeCriticalAttribute]
private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    [SecuritySafeCriticalAttribute]
public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    [SecuritySafeCriticalAttribute]
protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    [SecurityCriticalAttribute]
private ResourceSet InternalGetResourceSet(CultureInfo requestedCulture, bool createIfNotExists, bool tryParents, StackCrawlMark& stackMark);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    [SecuritySafeCriticalAttribute]
protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
    private void SetAppXConfiguration();
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    [ComVisibleAttribute("False")]
public UnmanagedMemoryStream GetStream(string name);
    [ComVisibleAttribute("False")]
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceReader : object {
    private static int DefaultFileStreamBufferSize;
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    [SecurityCriticalAttribute]
private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    [SecurityCriticalAttribute]
private Int32* _namePositionsPtr;
    private RuntimeType[] _typeTable;
    private Int32[] _typeNamePositions;
    private BinaryFormatter _objFormatter;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    [SecuritySafeCriticalAttribute]
public ResourceReader(string fileName);
    [SecurityCriticalAttribute]
public ResourceReader(Stream stream);
    [SecurityCriticalAttribute]
internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
private void Dispose(bool disposing);
    [SecurityCriticalAttribute]
internal static int ReadUnalignedI4(Int32* p);
    private void SkipInt32();
    private void SkipString();
    [SecuritySafeCriticalAttribute]
private int GetNameHash(int index);
    [SecuritySafeCriticalAttribute]
private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    [SecuritySafeCriticalAttribute]
private bool CompareStringEqualsName(string name);
    [SecurityCriticalAttribute]
private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    [SecuritySafeCriticalAttribute]
private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    [SecuritySafeCriticalAttribute]
private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    [SecurityCriticalAttribute]
private object DeserializeObject(int typeIndex);
    [SecurityCriticalAttribute]
private void ReadResources();
    [SecurityCriticalAttribute]
private void _ReadResources();
    private RuntimeType FindType(int typeIndex);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceSet : object {
    protected IResourceReader Reader;
    protected Hashtable Table;
    private Hashtable _caseInsensitiveTable;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    [SecurityCriticalAttribute]
public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    private void CommonInit();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    [ComVisibleAttribute("False")]
public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
[ComVisibleAttribute("True")]
public class System.Resources.ResourceWriter : object {
    private Func`2<Type, string> typeConverter;
    private static int _ExpectedNumberOfResources;
    private static int AverageNameSize;
    private static int AverageValueSize;
    private Dictionary`2<string, object> _resourceList;
    internal Stream _output;
    private Dictionary`2<string, object> _caseInsensitiveDups;
    private Dictionary`2<string, PrecannedResource> _preserializedData;
    private static int _DefaultBufferSize;
    public Func`2<Type, string> TypeNameConverter { get; public set; }
    public ResourceWriter(string fileName);
    public ResourceWriter(Stream stream);
    public Func`2<Type, string> get_TypeNameConverter();
    public void set_TypeNameConverter(Func`2<Type, string> value);
    public sealed virtual void AddResource(string name, string value);
    public sealed virtual void AddResource(string name, object value);
    public void AddResource(string name, Stream value);
    public void AddResource(string name, Stream value, bool closeAfterWrite);
    private void AddResourceInternal(string name, Stream value, bool closeAfterWrite);
    public sealed virtual void AddResource(string name, Byte[] value);
    public void AddResourceData(string name, string typeName, Byte[] serializedData);
    public sealed virtual void Close();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Generate();
    private ResourceTypeCode FindTypeCode(object value, List`1<string> types);
    private void WriteValue(ResourceTypeCode typeCode, object value, BinaryWriter writer, IFormatter objFormatter);
    private static void Write7BitEncodedInt(BinaryWriter store, int value);
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    internal static int Version;
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    private bool _haveReadFromReader;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase);
}
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
internal class System.Resources.Win32EncodedResource : Win32Resource {
    private Byte[] data;
    public Byte[] Data { get; }
    internal Win32EncodedResource(NameOrId type, NameOrId name, int language, Byte[] data);
    public Byte[] get_Data();
    public virtual void WriteTo(Stream s);
}
internal class System.Resources.Win32GroupIconResource : Win32Resource {
    private Win32IconResource[] icons;
    public Win32GroupIconResource(int id, int language, Win32IconResource[] icons);
    public virtual void WriteTo(Stream s);
}
internal class System.Resources.Win32IconFileReader : object {
    private Stream iconFile;
    public Win32IconFileReader(Stream s);
    public ICONDIRENTRY[] ReadIcons();
}
internal class System.Resources.Win32IconResource : Win32Resource {
    private ICONDIRENTRY icon;
    public ICONDIRENTRY Icon { get; }
    public Win32IconResource(int id, int language, ICONDIRENTRY icon);
    public ICONDIRENTRY get_Icon();
    public virtual void WriteTo(Stream s);
}
internal class System.Resources.Win32ResFileReader : object {
    private Stream res_file;
    public Win32ResFileReader(Stream s);
    private int read_int16();
    private int read_int32();
    private bool read_padding();
    private NameOrId read_ordinal();
    public ICollection ReadResources();
}
internal abstract class System.Resources.Win32Resource : object {
    private NameOrId type;
    private NameOrId name;
    private int language;
    public Win32ResourceType ResourceType { get; }
    public NameOrId Name { get; }
    public NameOrId Type { get; }
    public int Language { get; }
    internal Win32Resource(NameOrId type, NameOrId name, int language);
    internal Win32Resource(Win32ResourceType type, int name, int language);
    public Win32ResourceType get_ResourceType();
    public NameOrId get_Name();
    public NameOrId get_Type();
    public int get_Language();
    public abstract virtual void WriteTo(Stream s);
    public virtual string ToString();
}
internal enum System.Resources.Win32ResourceType : Enum {
    public int value__;
    public static Win32ResourceType RT_CURSOR;
    public static Win32ResourceType RT_FONT;
    public static Win32ResourceType RT_BITMAP;
    public static Win32ResourceType RT_ICON;
    public static Win32ResourceType RT_MENU;
    public static Win32ResourceType RT_DIALOG;
    public static Win32ResourceType RT_STRING;
    public static Win32ResourceType RT_FONTDIR;
    public static Win32ResourceType RT_ACCELERATOR;
    public static Win32ResourceType RT_RCDATA;
    public static Win32ResourceType RT_MESSAGETABLE;
    public static Win32ResourceType RT_GROUP_CURSOR;
    public static Win32ResourceType RT_GROUP_ICON;
    public static Win32ResourceType RT_VERSION;
    public static Win32ResourceType RT_DLGINCLUDE;
    public static Win32ResourceType RT_PLUGPLAY;
    public static Win32ResourceType RT_VXD;
    public static Win32ResourceType RT_ANICURSOR;
    public static Win32ResourceType RT_ANIICON;
    public static Win32ResourceType RT_HTML;
}
[DefaultMemberAttribute("Item")]
internal class System.Resources.Win32VersionResource : Win32Resource {
    public String[] WellKnownProperties;
    private long signature;
    private int struct_version;
    private long file_version;
    private long product_version;
    private int file_flags_mask;
    private int file_flags;
    private int file_os;
    private int file_type;
    private int file_subtype;
    private long file_date;
    private int file_lang;
    private int file_codepage;
    private Hashtable properties;
    public string Version { get; public set; }
    unknown string Item {public set; }
    public string Comments { get; public set; }
    public string CompanyName { get; public set; }
    public string LegalCopyright { get; public set; }
    public string LegalTrademarks { get; public set; }
    public string OriginalFilename { get; public set; }
    public string ProductName { get; public set; }
    public string ProductVersion { get; public set; }
    public string InternalName { get; public set; }
    public string FileDescription { get; public set; }
    public int FileLanguage { get; public set; }
    public string FileVersion { get; public set; }
    public Win32VersionResource(int id, int language, bool compilercontext);
    public string get_Version();
    public void set_Version(string value);
    public virtual void set_Item(string key, string value);
    public virtual string get_Comments();
    public virtual void set_Comments(string value);
    public virtual string get_CompanyName();
    public virtual void set_CompanyName(string value);
    public virtual string get_LegalCopyright();
    public virtual void set_LegalCopyright(string value);
    public virtual string get_LegalTrademarks();
    public virtual void set_LegalTrademarks(string value);
    public virtual string get_OriginalFilename();
    public virtual void set_OriginalFilename(string value);
    public virtual string get_ProductName();
    public virtual void set_ProductName(string value);
    public virtual string get_ProductVersion();
    public virtual void set_ProductVersion(string value);
    public virtual string get_InternalName();
    public virtual void set_InternalName(string value);
    public virtual string get_FileDescription();
    public virtual void set_FileDescription(string value);
    public virtual int get_FileLanguage();
    public virtual void set_FileLanguage(int value);
    public virtual string get_FileVersion();
    public virtual void set_FileVersion(string value);
    private void emit_padding(BinaryWriter w);
    private void patch_length(BinaryWriter w, long len_pos);
    public virtual void WriteTo(Stream ms);
}
public class System.Runtime.AmbiguousImplementationException : Exception {
    public AmbiguousImplementationException(string message);
    public AmbiguousImplementationException(string message, Exception innerException);
    private AmbiguousImplementationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TargetedPatchBand>k__BackingField;
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    [CompilerGeneratedAttribute]
public string get_TargetedPatchBand();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHere : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereM : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereS : object {
}
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.AssemblyAttributesGoHereSM : object {
}
public class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    internal object ObjectIdForDebugger { get; }
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal class System.Runtime.CompilerServices.AsyncMethodBuilderCore : ValueType {
    internal IAsyncStateMachine m_stateMachine;
    internal Action m_defaultContextAction;
    [DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
internal static void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    [SecuritySafeCriticalAttribute]
internal Action GetCompletionAction(Task taskForTracing, MoveNextRunner& runnerToInitialize);
    private Action OutputAsyncCausalityEvents(Task innerTask, Action continuation);
    internal void PostBoxInitialization(IAsyncStateMachine stateMachine, MoveNextRunner runner, Task builtTask);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
    internal static Action CreateContinuationWrapper(Action continuation, Action invokeAction, Task innerTask);
    internal static Action TryGetStateMachineForDebugger(Action action);
    internal static Task TryGetContinuationTask(Action action);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static Task`1<bool> TrueTask;
    internal static Task`1<bool> FalseTask;
    internal static Task`1[] Int32Tasks;
    internal static int INCLUSIVE_INT32_MIN;
    internal static int EXCLUSIVE_INT32_MAX;
    private static AsyncTaskCache();
    private static Task`1[] CreateInt32Tasks();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_cachedCompleted;
    private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;
    public Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal object get_ObjectIdForDebugger();
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_defaultResultTask;
    private AsyncMethodBuilderCore m_coreState;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    private object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder`1();
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task`1<TResult> get_Task();
    public void SetResult(TResult result);
    internal void SetResult(Task`1<TResult> completedTask);
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    private object get_ObjectIdForDebugger();
    [SecuritySafeCriticalAttribute]
internal static Task`1<TResult> GetTaskForResult(TResult result);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext m_synchronizationContext;
    private AsyncMethodBuilderCore m_coreState;
    private Task m_task;
    internal Task Task { get; }
    private object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private void NotifySynchronizationContextOfCompletion();
    internal Task get_Task();
    private object get_ObjectIdForDebugger();
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvCdecl : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvFastcall : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvStdcall : object {
}
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.CallConvThiscall : object {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    private int m_relaxations;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.CompilerMarshalOverride : object {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private static int INITIAL_SIZE;
    private static float LOAD_FACTOR;
    private static float COMPACT_FACTOR;
    private static float EXPAND_FACTOR;
    private Ephemeron[] data;
    private object _lock;
    private int size;
    internal ICollection`1<TKey> Keys { get; }
    internal ICollection`1<TValue> Values { get; }
    protected virtual override void Finalize();
    private void RehashWithoutResize();
    private void RecomputeSize();
    private void Rehash();
    public void AddOrUpdate(TKey key, TValue value);
    public void Add(TKey key, TValue value);
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrCreateValue(TKey key);
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    internal TKey FindEquivalentKeyUnsafe(TKey key, TValue& value);
    [SecuritySafeCriticalAttribute]
public void Clear();
    [SecuritySafeCriticalAttribute]
internal ICollection`1<TKey> get_Keys();
    [SecuritySafeCriticalAttribute]
internal ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private IAsyncDisposable _source;
    private bool _continueOnCapturedContext;
    internal ConfiguredAsyncDisposable(IAsyncDisposable source, bool continueOnCapturedContext);
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private IAsyncEnumerable`1<T> _enumerable;
    private CancellationToken _cancellationToken;
    private bool _continueOnCapturedContext;
    internal ConfiguredCancelableAsyncEnumerable`1(IAsyncEnumerable`1<T> enumerable, bool continueOnCapturedContext, CancellationToken cancellationToken);
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
    public Enumerator<T> GetAsyncEnumerator();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1<TResult> value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    private static EventHandler`1 modreq(System.Runtime.CompilerServices.IsVolatile) contractFailedEvent;
    private static object lockObject;
    internal static int COR_E_CODECONTRACTFAILED;
    private static ContractHelper();
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "1")]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
[SecuritySafeCriticalAttribute]
private static void RaiseContractFailedEventImplementation(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException, String& resultFailureMessage);
    [DebuggerNonUserCodeAttribute]
[SecuritySafeCriticalAttribute]
private static void TriggerFailureImplementation(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    [SecurityCriticalAttribute]
internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [SecurityCriticalAttribute]
internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    private static string GetResourceNameForFailure(ContractFailureKind failureKind, bool withCondition);
    [ReliabilityContractAttribute("3", "1")]
private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
    [SecuritySafeCriticalAttribute]
[DebuggerNonUserCodeAttribute]
[ReliabilityContractAttribute("3", "2")]
private static void TriggerCodeContractEscalationPolicy(ContractFailureKind failureKind, string message, string conditionText, Exception innerException);
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime _date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal _dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
}
[AttributeUsageAttribute("32767")]
[ComVisibleAttribute("False")]
internal class System.Runtime.CompilerServices.DecoratedNameAttribute : Attribute {
    public DecoratedNameAttribute(string decoratedName);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    private LoadHint loadHint;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    private string dependentAssembly;
    private LoadHint loadHint;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    public string get_DependentAssembly();
    public LoadHint get_LoadHint();
}
[ConditionalAttribute("NOT_MONO")]
internal class System.Runtime.CompilerServices.DependencyReductionRootAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.Ephemeron : ValueType {
    internal object key;
    internal object value;
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
[AttributeUsageAttribute("2044")]
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.HasCopySemanticsAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
internal interface System.Runtime.CompilerServices.IConfiguredTaskAwaiter {
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.IDispatchConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public virtual object get_Value();
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    private string _assemblyName;
    private bool _allInternalsVisible;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    public string get_AssemblyName();
    public bool get_AllInternalsVisible();
    public void set_AllInternalsVisible(bool value);
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsBoxed : object {
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsByValue : object {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[ComVisibleAttribute("True")]
public static class System.Runtime.CompilerServices.IsCopyConstructed : object {
}
public static class System.Runtime.CompilerServices.IsExplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsImplicitlyDereferenced : object {
}
public static class System.Runtime.CompilerServices.IsJitIntrinsic : object {
}
public static class System.Runtime.CompilerServices.IsLong : object {
}
public static class System.Runtime.CompilerServices.IsPinned : object {
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsSignUnspecifiedByte : object {
}
public static class System.Runtime.CompilerServices.IsUdtReturn : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
internal interface System.Runtime.CompilerServices.ITaskAwaiter {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
[AttributeUsageAttribute("2304")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.IUnknownConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public virtual object get_Value();
}
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    internal static T UnsafeCast(object o);
    internal static int UnsafeEnumCast(T val);
    internal static long UnsafeEnumCastLong(T val);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    internal MethodImplOptions _val;
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    internal MethodImplAttribute(MethodImplAttributes methodImplAttributes);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions InternalCall;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoInlining;
    [ComVisibleAttribute("False")]
public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions SecurityMitigations;
}
[AttributeUsageAttribute("8")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.NativeCppClassAttribute : Attribute {
}
[AttributeUsageAttribute("352")]
internal class System.Runtime.CompilerServices.PreserveDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string Condition { get; public set; }
    public PreserveDependencyAttribute(string memberSignature);
    public PreserveDependencyAttribute(string memberSignature, string typeName);
    public PreserveDependencyAttribute(string memberSignature, string typeName, string assembly);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("5148")]
internal class System.Runtime.CompilerServices.ReflectionBlockedAttribute : Attribute {
}
[AttributeUsageAttribute("1052")]
[ComVisibleAttribute("True")]
public class System.Runtime.CompilerServices.RequiredAttributeAttribute : Attribute {
    private Type requiredContract;
    public Type RequiredContract { get; }
    public RequiredAttributeAttribute(Type requiredContract);
    public Type get_RequiredContract();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string PortablePdb;
    public static string DefaultImplementationsOfInterfaces;
    public static bool IsDynamicCodeSupported { get; }
    public static bool IsDynamicCodeCompiled { get; }
    public static bool IsSupported(string feature);
    public static bool get_IsDynamicCodeSupported();
    public static bool get_IsDynamicCodeCompiled();
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    private static void InitializeArray(Array array, IntPtr fldHandle);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static int get_OffsetToStringData();
    public static int GetHashCode(object o);
    public static bool Equals(object o1, object o2);
    public static object GetObjectValue(object obj);
    private static void RunClassConstructor(IntPtr type);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    private static bool SufficientExecutionStack();
    [ReliabilityContractAttribute("3", "2")]
public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    [ReliabilityContractAttribute("3", "1")]
public static void PrepareConstrainedRegions();
    [ReliabilityContractAttribute("3", "1")]
public static void PrepareConstrainedRegionsNoOP();
    [ReliabilityContractAttribute("3", "1")]
public static void ProbeForSufficientStack();
    [SecurityCriticalAttribute]
public static void PrepareDelegate(Delegate d);
    [SecurityCriticalAttribute]
public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareMethod(RuntimeMethodHandle method);
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void RunModuleConstructor(ModuleHandle module);
    private static void RunModuleConstructor(IntPtr module);
    public static bool IsReferenceOrContainsReferences();
    public static object GetUninitializedObject(Type type);
    public static T[] GetSubArray(T[] array, Range range);
}
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object _wrappedException;
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    private RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
}
[AttributeUsageAttribute("16")]
public class System.Runtime.CompilerServices.ScopelessEnumAttribute : Attribute {
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[AttributeUsageAttribute("996")]
internal class System.Runtime.CompilerServices.SuppressMergeCheckAttribute : Attribute {
}
public class System.Runtime.CompilerServices.SwitchExpressionException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private object <UnmatchedValue>k__BackingField;
    public object UnmatchedValue { get; }
    public string Message { get; }
    public SwitchExpressionException(Exception innerException);
    public SwitchExpressionException(object unmatchedValue);
    private SwitchExpressionException(SerializationInfo info, StreamingContext context);
    public SwitchExpressionException(string message);
    public SwitchExpressionException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public object get_UnmatchedValue();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    internal Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public void GetResult();
    [StackTraceHiddenAttribute]
internal static void ValidateEnd(Task task);
    [StackTraceHiddenAttribute]
private static void HandleNonSuccessAndDebuggerNotification(Task task);
    [StackTraceHiddenAttribute]
private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    [SecuritySafeCriticalAttribute]
public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public TResult GetResult();
}
[AttributeUsageAttribute("11148")]
[CLSCompliantAttribute("False")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("1036")]
internal class System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
    private string typeName;
    public TypeDependencyAttribute(string typeName);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
internal static class System.Runtime.CompilerServices.Unsafe : object {
    public static T& Add(T& source, int elementOffset);
    public static T& Add(T& source, IntPtr elementOffset);
    public static Void* Add(Void* source, int elementOffset);
    public static T& AddByteOffset(T& source, IntPtr byteOffset);
    public static bool AreSame(T& left, T& right);
    public static T As(object o);
    public static TTo& As(TFrom& source);
    public static Void* AsPointer(T& value);
    public static T& AsRef(Void* source);
    public static T& AsRef(T& source);
    public static IntPtr ByteOffset(T& origin, T& target);
    public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    public static T Read(Void* source);
    public static T ReadUnaligned(Void* source);
    public static T ReadUnaligned(Byte& source);
    public static int SizeOf();
    public static T& Subtract(T& source, int elementOffset);
    public static void WriteUnaligned(Byte& destination, T value);
    public static void WriteUnaligned(Void* destination, T value);
    public static bool IsAddressGreaterThan(T& left, T& right);
    public static bool IsAddressLessThan(T& left, T& right);
    internal static T& AddByteOffset(T& source, ulong byteOffset);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1<TResult> value);
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
public class System.Runtime.DesignerServices.WindowsRuntimeDesignerContext : object {
    public string Name { get; }
    [SecurityCriticalAttribute]
public WindowsRuntimeDesignerContext(IEnumerable`1<string> paths, string name);
    public string get_Name();
    [SecurityCriticalAttribute]
public Assembly GetAssembly(string assemblyName);
    [SecurityCriticalAttribute]
public Type GetType(string typeName);
    [SecurityCriticalAttribute]
public static void InitializeSharedContext(IEnumerable`1<string> paths);
    [SecurityCriticalAttribute]
public static void SetIterationContext(WindowsRuntimeDesignerContext context);
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception m_Exception;
    private object m_stackTrace;
    internal object BinaryStackTraceArray { get; }
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    internal object get_BinaryStackTraceArray();
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    [StackTraceHiddenAttribute]
public void Throw();
    [StackTraceHiddenAttribute]
public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    [CompilerGeneratedAttribute]
private static GCLargeObjectHeapCompactionMode <LargeObjectHeapCompactionMode>k__BackingField;
    [MonoTODOAttribute("Always returns false")]
public static bool IsServerGC { get; }
    [MonoTODOAttribute("Always returns GCLatencyMode.Interactive and ignores set")]
public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool get_IsServerGC();
    [ReliabilityContractAttribute("3", "2")]
public static GCLatencyMode get_LatencyMode();
    [ReliabilityContractAttribute("3", "2")]
public static void set_LatencyMode(GCLatencyMode value);
    [CompilerGeneratedAttribute]
[ReliabilityContractAttribute("3", "2")]
public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    [CompilerGeneratedAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Hosting.ActivationArguments : EvidenceBase {
    private ActivationContext _context;
    private ApplicationIdentity _identity;
    private String[] _data;
    public ActivationContext ActivationContext { get; }
    public String[] ActivationData { get; }
    public ApplicationIdentity ApplicationIdentity { get; }
    public ActivationArguments(ActivationContext activationData);
    public ActivationArguments(ApplicationIdentity applicationIdentity);
    public ActivationArguments(ActivationContext activationContext, String[] activationData);
    public ActivationArguments(ApplicationIdentity applicationIdentity, String[] activationData);
    public ActivationContext get_ActivationContext();
    public String[] get_ActivationData();
    public ApplicationIdentity get_ApplicationIdentity();
}
[ComVisibleAttribute("True")]
[MonoTODOAttribute("missing manifest support")]
public class System.Runtime.Hosting.ApplicationActivator : object {
    public virtual ObjectHandle CreateInstance(ActivationContext activationContext);
    public virtual ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData);
    protected static ObjectHandle CreateInstanceHelper(AppDomainSetup adSetup);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("03973551-57A1-3900-A2B5-9083E3FF2943")]
[TypeLibImportClassAttribute("System.Activator")]
public interface System.Runtime.InteropServices._Activator {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("0")]
[GuidAttribute("17156360-2F1A-384A-BC52-FDE93C215C5B")]
[TypeLibImportClassAttribute("System.Reflection.Assembly")]
public interface System.Runtime.InteropServices._Assembly {
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public string Location { get; }
    public Evidence Evidence { get; }
    public bool GlobalAssemblyCache { get; }
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual string get_CodeBase();
    public abstract virtual string get_EscapedCodeBase();
    public abstract virtual AssemblyName GetName();
    public abstract virtual AssemblyName GetName(bool copiedName);
    public abstract virtual string get_FullName();
    public abstract virtual MethodInfo get_EntryPoint();
    public abstract virtual Type GetType(string name);
    public abstract virtual Type GetType(string name, bool throwOnError);
    public abstract virtual Type[] GetExportedTypes();
    public abstract virtual Type[] GetTypes();
    public abstract virtual Stream GetManifestResourceStream(Type type, string name);
    public abstract virtual Stream GetManifestResourceStream(string name);
    public abstract virtual FileStream GetFile(string name);
    public abstract virtual FileStream[] GetFiles();
    public abstract virtual FileStream[] GetFiles(bool getResourceModules);
    public abstract virtual String[] GetManifestResourceNames();
    public abstract virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public abstract virtual string get_Location();
    public abstract virtual Evidence get_Evidence();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public abstract virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public abstract virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public abstract virtual Module LoadModule(string moduleName, Byte[] rawModule);
    public abstract virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public abstract virtual object CreateInstance(string typeName);
    public abstract virtual object CreateInstance(string typeName, bool ignoreCase);
    public abstract virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public abstract virtual Module[] GetLoadedModules();
    public abstract virtual Module[] GetLoadedModules(bool getResourceModules);
    public abstract virtual Module[] GetModules();
    public abstract virtual Module[] GetModules(bool getResourceModules);
    public abstract virtual Module GetModule(string name);
    public abstract virtual AssemblyName[] GetReferencedAssemblies();
    public abstract virtual bool get_GlobalAssemblyCache();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.AssemblyBuilder")]
[GuidAttribute("BEBB2505-8B54-3443-AEAD-142A16DD9CC7")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._AssemblyBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("B42B6AAC-317E-34D5-9FA9-093BB4160C50")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.AssemblyName")]
public interface System.Runtime.InteropServices._AssemblyName {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Attribute")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[GuidAttribute("917B14D0-2D9E-38B8-92A9-381ACF52F7C0")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._Attribute {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("ED3E4384-D7E2-3FA7-8FFD-8940D330519A")]
[TypeLibImportClassAttribute("System.Reflection.Emit.ConstructorBuilder")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._ConstructorBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[GuidAttribute("E9A19478-9646-3679-9B10-8411AE1FD57D")]
[TypeLibImportClassAttribute("System.Reflection.ConstructorInfo")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._ConstructorInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public MemberTypes MemberType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual int GetHashCode();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual Type GetType();
    public abstract virtual object Invoke_5(Object[] parameters);
    public abstract virtual object Invoke_3(object obj, Object[] parameters);
    public abstract virtual object Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual object Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual string ToString();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
}
[GuidAttribute("BE9ACCE8-AAFF-3B91-81AE-8211663F5CAD")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.Emit.CustomAttributeBuilder")]
public interface System.Runtime.InteropServices._CustomAttributeBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[GuidAttribute("C7BD73DE-9F85-3290-88EE-090B8BDFE2DF")]
[TypeLibImportClassAttribute("System.Reflection.Emit.EnumBuilder")]
public interface System.Runtime.InteropServices._EnumBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.Emit.EventBuilder")]
[GuidAttribute("AADABA99-895D-3D65-9760-B1F12621FAE8")]
public interface System.Runtime.InteropServices._EventBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Reflection.EventInfo")]
[GuidAttribute("9DE59C64-D889-35A1-B897-587D74469E5B")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._EventInfo {
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public abstract virtual void AddEventHandler(object target, Delegate handler);
    public abstract virtual bool Equals(object other);
    public abstract virtual MethodInfo GetAddMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual int GetHashCode();
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod();
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual Type GetType();
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual void RemoveEventHandler(object target, Delegate handler);
    public abstract virtual string ToString();
    public abstract virtual EventAttributes get_Attributes();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_EventHandlerType();
    public abstract virtual bool get_IsMulticast();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("0")]
[GuidAttribute("b36b5c63-42ef-38bc-a07e-0b34c98f164a")]
public interface System.Runtime.InteropServices._Exception {
    public string HelpLink { get; public set; }
    public Exception InnerException { get; }
    public string Message { get; }
    public string Source { get; public set; }
    public string StackTrace { get; }
    public MethodBase TargetSite { get; }
    public abstract virtual string get_HelpLink();
    public abstract virtual void set_HelpLink(string value);
    public abstract virtual Exception get_InnerException();
    public abstract virtual string get_Message();
    public abstract virtual string get_Source();
    public abstract virtual void set_Source(string value);
    public abstract virtual string get_StackTrace();
    public abstract virtual MethodBase get_TargetSite();
    public abstract virtual bool Equals(object obj);
    public abstract virtual Exception GetBaseException();
    public abstract virtual int GetHashCode();
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual Type GetType();
    public abstract virtual string ToString();
}
[TypeLibImportClassAttribute("System.Reflection.Emit.FieldBuilder")]
[GuidAttribute("CE1A3BF5-975E-30CC-97C9-1EF70F8F3993")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._FieldBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("8A7C1442-A9FB-366B-80D8-4939FFA6DBE0")]
[TypeLibImportClassAttribute("System.Reflection.FieldInfo")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._FieldInfo {
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual object GetValue(object obj);
    public abstract virtual object GetValueDirect(TypedReference obj);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public abstract virtual void SetValueDirect(TypedReference obj, object value);
    public abstract virtual string ToString();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public abstract virtual Type get_FieldType();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool get_IsNotSerialized();
    public abstract virtual bool get_IsPinvokeImpl();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("A4924B27-6E3B-37F7-9B83-A4501955E6A7")]
[TypeLibImportClassAttribute("System.Reflection.Emit.ILGenerator")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._ILGenerator {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.Emit.LocalBuilder")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[GuidAttribute("4E6350D1-A08B-3DEC-9A3E-C465F9AEEC0C")]
public interface System.Runtime.InteropServices._LocalBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[GuidAttribute("f7102fa9-cabb-3a74-a6da-b4567ef1b079")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.MemberInfo")]
public interface System.Runtime.InteropServices._MemberInfo {
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual string ToString();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[TypeLibImportClassAttribute("System.Reflection.MethodBase")]
[ComVisibleAttribute("True")]
[GuidAttribute("6240837A-707F-3181-8E98-A36AE086766B")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._MethodBase {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public MemberTypes MemberType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual int GetHashCode();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual Type GetType();
    public abstract virtual object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual string ToString();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("007D8A14-FDF3-363E-9A0B-FEC0618260A2")]
[TypeLibImportClassAttribute("System.Reflection.Emit.MethodBuilder")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._MethodBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.MethodInfo")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("FFCC1B5D-ECB8-38DD-9B01-3DC8ABC2AA5F")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._MethodInfo {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsFamily { get; }
    public bool IsAssembly { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsStatic { get; }
    public bool IsFinal { get; }
    public bool IsVirtual { get; }
    public bool IsHideBySig { get; }
    public bool IsAbstract { get; }
    public bool IsSpecialName { get; }
    public bool IsConstructor { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsPrivate();
    public abstract virtual bool get_IsFamily();
    public abstract virtual bool get_IsAssembly();
    public abstract virtual bool get_IsFamilyAndAssembly();
    public abstract virtual bool get_IsFamilyOrAssembly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsFinal();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsHideBySig();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual object Invoke(object obj, Object[] parameters);
    public abstract virtual Type get_ReturnType();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public abstract virtual MethodInfo GetBaseDefinition();
}
[GuidAttribute("C2323C25-F57F-3880-8A4D-12EBEA7A5852")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[TypeLibImportClassAttribute("System.Reflection.Emit.MethodRental")]
public interface System.Runtime.InteropServices._MethodRental {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("D002E9BA-D9E3-3749-B1D3-D565A08B13E7")]
[TypeLibImportClassAttribute("System.Reflection.Module")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._Module {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("D05FFA9A-04AF-3519-8EE1-8D93AD73430B")]
[TypeLibImportClassAttribute("System.Reflection.Emit.ModuleBuilder")]
public interface System.Runtime.InteropServices._ModuleBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.ParameterBuilder")]
[GuidAttribute("36329EBA-F97A-3565-BC07-0ED5C6EF19FC")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._ParameterBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("993634C4-E47A-32CC-BE08-85F567DC27D6")]
[TypeLibImportClassAttribute("System.Reflection.ParameterInfo")]
public interface System.Runtime.InteropServices._ParameterInfo {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[GuidAttribute("15F9A479-9397-3A63-ACBD-F51977FB0F02")]
[TypeLibImportClassAttribute("System.Reflection.Emit.PropertyBuilder")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.InteropServices._PropertyBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[GuidAttribute("F59ED4E4-E68F-3218-BD77-061AA82824BF")]
[TypeLibImportClassAttribute("System.Reflection.PropertyInfo")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._PropertyInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public abstract virtual int GetHashCode();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual Type GetType();
    public abstract virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual string ToString();
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_PropertyType();
    public abstract virtual Type get_ReflectedType();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
[GuidAttribute("7D13DD37-5A04-393C-BBCA-A5FEA802893D")]
[TypeLibImportClassAttribute("System.Reflection.Emit.SignatureHelper")]
public interface System.Runtime.InteropServices._SignatureHelper {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[TypeLibImportClassAttribute("System.Threading.Thread")]
[GuidAttribute("C281C7F1-4AA9-3517-961A-463CFED57E75")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._Thread {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[ComVisibleAttribute("True")]
[GuidAttribute("BCA8B44D-AAD6-3A86-8AB7-03349F4F2DA2")]
[CLSCompliantAttribute("False")]
[TypeLibImportClassAttribute("System.Type")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices._Type {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public ConstructorInfo TypeInitializer { get; }
    public TypeAttributes Attributes { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsNestedPublic { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsAutoLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsExplicitLayout { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsEnum { get; }
    public bool IsSpecialName { get; }
    public bool IsImport { get; }
    public bool IsSerializable { get; }
    public bool IsAnsiClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsAutoClass { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsCOMObject { get; }
    public bool HasElementType { get; }
    public bool IsContextful { get; }
    public bool IsMarshalByRef { get; }
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual Type GetType();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Guid get_GUID();
    public abstract virtual Module get_Module();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual RuntimeTypeHandle get_TypeHandle();
    public abstract virtual string get_FullName();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type get_BaseType();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public abstract virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public abstract virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetDefaultMembers();
    public abstract virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public abstract virtual Type GetElementType();
    public abstract virtual bool IsSubclassOf(Type c);
    public abstract virtual bool IsInstanceOfType(object o);
    public abstract virtual bool IsAssignableFrom(Type c);
    public abstract virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    public abstract virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual ConstructorInfo GetConstructor(Type[] types);
    public abstract virtual ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo get_TypeInitializer();
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, Type[] types);
    public abstract virtual MethodInfo GetMethod(string name);
    public abstract virtual MethodInfo[] GetMethods();
    public abstract virtual FieldInfo GetField(string name);
    public abstract virtual FieldInfo[] GetFields();
    public abstract virtual Type GetInterface(string name);
    public abstract virtual EventInfo GetEvent(string name);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public abstract virtual PropertyInfo GetProperty(string name, Type[] types);
    public abstract virtual PropertyInfo GetProperty(string name, Type returnType);
    public abstract virtual PropertyInfo GetProperty(string name);
    public abstract virtual PropertyInfo[] GetProperties();
    public abstract virtual Type[] GetNestedTypes();
    public abstract virtual Type GetNestedType(string name);
    public abstract virtual MemberInfo[] GetMember(string name);
    public abstract virtual MemberInfo[] GetMembers();
    public abstract virtual TypeAttributes get_Attributes();
    public abstract virtual bool get_IsNotPublic();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsNestedPublic();
    public abstract virtual bool get_IsNestedPrivate();
    public abstract virtual bool get_IsNestedFamily();
    public abstract virtual bool get_IsNestedAssembly();
    public abstract virtual bool get_IsNestedFamANDAssem();
    public abstract virtual bool get_IsNestedFamORAssem();
    public abstract virtual bool get_IsAutoLayout();
    public abstract virtual bool get_IsLayoutSequential();
    public abstract virtual bool get_IsExplicitLayout();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsImport();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsAnsiClass();
    public abstract virtual bool get_IsUnicodeClass();
    public abstract virtual bool get_IsAutoClass();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsByRef();
    public abstract virtual bool get_IsPointer();
    public abstract virtual bool get_IsPrimitive();
    public abstract virtual bool get_IsCOMObject();
    public abstract virtual bool get_HasElementType();
    public abstract virtual bool get_IsContextful();
    public abstract virtual bool get_IsMarshalByRef();
    public abstract virtual bool Equals(Type o);
}
[TypeLibImportClassAttribute("System.Reflection.Emit.TypeBuilder")]
[GuidAttribute("7E5678EE-48B3-3F83-B076-C58543498A58")]
[InterfaceTypeAttribute("1")]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices._TypeBuilder {
    public abstract virtual void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    public abstract virtual void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    public abstract virtual void GetTypeInfoCount(UInt32& pcTInfo);
    public abstract virtual void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal static class System.Runtime.InteropServices.AddrofIntrinsics : object {
    internal static IntPtr AddrOf(T ftn);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public enum System.Runtime.InteropServices.Architecture : Enum {
    public int value__;
    public static Architecture X86;
    public static Architecture X64;
    public static Architecture Arm;
    public static Architecture Arm64;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object m_array;
    private int m_offset;
    private int m_count;
    [SecuritySafeCriticalAttribute]
public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
    private int CalculateCount();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.AssemblyRegistrationFlags : Enum {
    public int value__;
    public static AssemblyRegistrationFlags None;
    public static AssemblyRegistrationFlags SetCodeBase;
}
[AttributeUsageAttribute("1029")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.AutomationProxyAttribute : Attribute {
    internal bool _val;
    public bool Value { get; }
    public AutomationProxyAttribute(bool val);
    public bool get_Value();
}
[AttributeUsageAttribute("1037")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    internal bool _bestFitMapping;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    public bool get_BestFitMapping();
}
[ObsoleteAttribute]
public class System.Runtime.InteropServices.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
[ObsoleteAttribute]
public class System.Runtime.InteropServices.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lptcomp;
    public IntPtr lpvardesc;
}
public class System.Runtime.InteropServices.BStrWrapper : object {
    private string m_WrappedObject;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    public string get_WrappedObject();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.CALLCONV instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    internal ClassInterfaceType _val;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceType get_Value();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[AttributeUsageAttribute("1024")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    internal Type _CoClass;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("10624")]
public class System.Runtime.InteropServices.ComAliasNameAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComAliasNameAttribute(string alias);
    public string get_Value();
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComCompatibleVersionAttribute : Attribute {
    internal int _major;
    internal int _minor;
    internal int _build;
    internal int _revision;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public int BuildNumber { get; }
    public int RevisionNumber { get; }
    public ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
    public int get_MajorVersion();
    public int get_MinorVersion();
    public int get_BuildNumber();
    public int get_RevisionNumber();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.InteropServices.ComConversionLossAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    internal Type _val;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
[AttributeUsageAttribute("1024")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    internal Type _SourceInterface;
    internal Type _EventProvider;
    public Type SourceInterface { get; }
    public Type EventProvider { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    public Type get_SourceInterface();
    public Type get_EventProvider();
}
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    [MonoTODOAttribute]
public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    [MonoTODOAttribute]
public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
public class System.Runtime.InteropServices.COMException : ExternalException {
    internal COMException(int hr);
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    protected COMException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    [ComVisibleAttribute("False")]
public static ComInterfaceType InterfaceIsIInspectable;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComRegisterFunctionAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.ComTypes.IEnumerable {
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[GuidAttribute("496B0ABF-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.ComTypes.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.ComTypes.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual PropertyInfo AddProperty(string name);
    public abstract virtual MethodInfo AddMethod(string name, Delegate method);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[GuidAttribute("AFBF15E5-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.ComTypes.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ComUnregisterFunctionAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    internal bool _val;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.CONNECTDATA instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected CriticalHandle(IntPtr invalidHandleValue);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual override void Finalize();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
private void Cleanup();
    private static void FireCustomerDebugProbe();
    [ReliabilityContractAttribute("3", "2")]
protected void SetHandle(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsClosed();
    [ReliabilityContractAttribute("3", "2")]
public abstract virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void Close();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public sealed virtual void Dispose();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [ReliabilityContractAttribute("3", "2")]
public void SetHandleAsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected abstract virtual bool ReleaseHandle();
}
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    private decimal m_WrappedObject;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
[ComVisibleAttribute("False")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    internal CharSet _CharSet;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    internal DllImportSearchPath _paths;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    public DllImportSearchPath get_Paths();
}
[ObsoleteAttribute]
public enum System.Runtime.InteropServices.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.DispatchWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    [SecuritySafeCriticalAttribute]
public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.DISPPARAMS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    internal string _val;
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public bool PreserveSig;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    internal DllImportAttribute(string dllName, string entryPoint, CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
    public DllImportAttribute(string dllName);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ELEMDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ErrorWrapper : object {
    private int m_ErrorCode;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    public int get_ErrorCode();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.EXCEPINFO instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
}
[ComVisibleAttribute("True")]
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
public interface System.Runtime.InteropServices.Expando.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual PropertyInfo AddProperty(string name);
    public abstract virtual MethodInfo AddMethod(string name, Delegate method);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ExporterEventKind : Enum {
    public int value__;
    public static ExporterEventKind NOTIF_TYPECONVERTED;
    public static ExporterEventKind NOTIF_CONVERTWARNING;
    public static ExporterEventKind ERROR_REFTOINVALIDASSEMBLY;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ExtensibleClassFactory : object {
    private static Hashtable hashtable;
    private static ExtensibleClassFactory();
    internal static ObjectCreationDelegate GetObjectCreationCallback(Type t);
    public static void RegisterObjectCreationCallback(ObjectCreationDelegate callback);
}
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [SecurityCriticalAttribute]
internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    [SecurityCriticalAttribute]
internal static bool IsDefined(RuntimeFieldInfo field);
    public int get_Value();
}
[ObsoleteAttribute]
public class System.Runtime.InteropServices.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.FUNCKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private IntPtr handle;
    public bool IsAllocated { get; }
    public object Target { get; public set; }
    private GCHandle(IntPtr h);
    private GCHandle(object obj);
    internal GCHandle(object value, GCHandleType type);
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public static IntPtr op_Explicit(GCHandle value);
    public static GCHandle op_Explicit(IntPtr value);
    private static bool CheckCurrentDomain(IntPtr handle);
    private static object GetTarget(IntPtr handle);
    private static IntPtr GetTargetHandle(object obj, IntPtr handle, GCHandleType type);
    private static void FreeHandle(IntPtr handle);
    private static IntPtr GetAddrOfPinnedObject(IntPtr handle);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(GCHandle value);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public GuidAttribute(string guid);
    public string get_Value();
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _wrapper;
    private IntPtr _handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
[ComVisibleAttribute("False")]
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    [SecurityCriticalAttribute]
public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[AttributeUsageAttribute("5")]
[ComVisibleAttribute("True")]
[ObsoleteAttribute("This attribute is deprecated and will be removed in a future version.", "False")]
public class System.Runtime.InteropServices.IDispatchImplAttribute : Attribute {
    internal IDispatchImplType _val;
    public IDispatchImplType Value { get; }
    public IDispatchImplAttribute(IDispatchImplType implType);
    public IDispatchImplAttribute(short implType);
    public IDispatchImplType get_Value();
}
[ComVisibleAttribute("True")]
[ObsoleteAttribute("The IDispatchImplAttribute is deprecated.", "False")]
public enum System.Runtime.InteropServices.IDispatchImplType : Enum {
    public int value__;
    public static IDispatchImplType SystemDefinedImpl;
    public static IDispatchImplType InternalImpl;
    public static IDispatchImplType CompatibleImpl;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IDLDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.IDLDESC : ValueType {
    public int dwReserved;
    public IDLFLAG wIDLFlags;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IDLFLAG instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[SuppressUnmanagedCodeSecurityAttribute]
[GuidAttribute("1CF2B120-547D-101B-8E65-08002B2BD119")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.IErrorInfo {
    public abstract virtual int GetGUID(Guid& pGuid);
    public abstract virtual int GetSource(String& pBstrSource);
    public abstract virtual int GetDescription(String& pbstrDescription);
    public abstract virtual int GetHelpFile(String& pBstrHelpFile);
    public abstract virtual int GetHelpContext(UInt32& pdwHelpContext);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ImportedFromTypeLibAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ImportedFromTypeLibAttribute(string tlbFile);
    public string get_Value();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.ImporterEventKind : Enum {
    public int value__;
    public static ImporterEventKind NOTIF_TYPECONVERTED;
    public static ImporterEventKind NOTIF_CONVERTWARNING;
    public static ImporterEventKind ERROR_REFTOINVALIDTYPELIB;
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[AttributeUsageAttribute("1024")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    internal ComInterfaceType _val;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    public ComInterfaceType get_Value();
}
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.INVOKEKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[GuidAttribute("CCBD682C-73A5-4568-B8B0-C7007E11ABA2")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.IRegistrationServices {
    [SecurityCriticalAttribute]
public abstract virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
    [SecurityCriticalAttribute]
public abstract virtual bool UnregisterAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public abstract virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
public abstract virtual string GetProgIdForType(Type type);
    [SecurityCriticalAttribute]
public abstract virtual void RegisterTypeForComClients(Type type, Guid& g);
    public abstract virtual Guid GetManagedCategoryGuid();
    [SecurityCriticalAttribute]
public abstract virtual bool TypeRequiresRegistration(Type type);
    public abstract virtual bool TypeRepresentsComType(Type type);
}
[ComVisibleAttribute("True")]
[GuidAttribute("F1C3BF78-C3E4-11D3-88E7-00902754C43A")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibConverter {
    public abstract virtual object ConvertAssemblyToTypeLib(Assembly assembly, string typeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
    public abstract virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
    public abstract virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
    public abstract virtual bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("fa1f3615-acb9-486d-9eac-1bef87e36b09")]
[ComVisibleAttribute("True")]
public interface System.Runtime.InteropServices.ITypeLibExporterNameProvider {
    public abstract virtual String[] GetNames();
}
[GuidAttribute("f1c3bf77-c3e4-11d3-88e7-00902754c43a")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibExporterNotifySink {
    public abstract virtual void ReportEvent(ExporterEventKind eventKind, int eventCode, string eventMsg);
    public abstract virtual object ResolveRef(Assembly assembly);
}
[ComVisibleAttribute("True")]
[GuidAttribute("f1c3bf76-c3e4-11d3-88e7-00902754c43a")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ITypeLibImporterNotifySink {
    public abstract virtual void ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg);
    public abstract virtual Assembly ResolveRef(object typeLib);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
[ObsoleteAttribute]
[FlagsAttribute]
public enum System.Runtime.InteropServices.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
internal class System.Runtime.InteropServices.ManagedErrorInfo : object {
    private Exception m_Exception;
    public Exception Exception { get; }
    public ManagedErrorInfo(Exception e);
    public Exception get_Exception();
    public sealed virtual int GetGUID(Guid& guid);
    public sealed virtual int GetSource(String& source);
    public sealed virtual int GetDescription(String& description);
    public sealed virtual int GetHelpFile(String& helpFile);
    public sealed virtual int GetHelpContext(UInt32& helpContext);
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute : Attribute {
    internal Type _classType;
    internal string _methodName;
    public Type ClassType { get; }
    public string MethodName { get; }
    public ManagedToNativeComInteropStubAttribute(Type classType, string methodName);
    public Type get_ClassType();
    public string get_MethodName();
}
public static class System.Runtime.InteropServices.Marshal : object {
    public static int SystemMaxDBCSCharSize;
    public static int SystemDefaultCharSize;
    private static bool SetErrorInfoNotAvailable;
    private static bool GetErrorInfoNotAvailable;
    internal static Dictionary`2<ValueTuple`2<Type, string>, ICustomMarshaler> MarshalerInstanceCache;
    internal static object MarshalerInstanceCacheLock;
    private static Marshal();
    private static int AddRefInternal(IntPtr pUnk);
    public static int AddRef(IntPtr pUnk);
    public static bool AreComObjectsAvailableForCleanup();
    public static void CleanupUnusedObjectsInCurrentContext();
    public static IntPtr AllocCoTaskMem(int cb);
    internal static IntPtr AllocCoTaskMemSize(UIntPtr sizet);
    [ReliabilityContractAttribute("3", "1")]
public static IntPtr AllocHGlobal(IntPtr cb);
    [ReliabilityContractAttribute("3", "1")]
public static IntPtr AllocHGlobal(int cb);
    public static object BindToMoniker(string monikerName);
    public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    internal static void copy_to_unmanaged(Array source, int startIndex, IntPtr destination, int length);
    private static void copy_to_unmanaged_fixed(Array source, int startIndex, IntPtr destination, int length, Void* fixed_source_element);
    private static bool skip_fixed(Array array, int startIndex);
    internal static void copy_to_unmanaged(Byte[] source, int startIndex, IntPtr destination, int length);
    internal static void copy_to_unmanaged(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    internal static void copy_from_unmanaged(IntPtr source, int startIndex, Array destination, int length);
    private static void copy_from_unmanaged_fixed(IntPtr source, int startIndex, Array destination, int length, Void* fixed_destination_element);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    public static object CreateWrapperOfType(object o, Type t);
    public static TWrapper CreateWrapperOfType(T o);
    [ComVisibleAttribute("True")]
public static void DestroyStructure(IntPtr ptr, Type structuretype);
    public static void DestroyStructure(IntPtr ptr);
    public static void FreeBSTR(IntPtr ptr);
    public static void FreeCoTaskMem(IntPtr ptr);
    [ReliabilityContractAttribute("3", "2")]
public static void FreeHGlobal(IntPtr hglobal);
    private static void ClearBSTR(IntPtr ptr);
    public static void ZeroFreeBSTR(IntPtr s);
    private static void ClearAnsi(IntPtr ptr);
    private static void ClearUnicode(IntPtr ptr);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    public static object GetActiveObject(string progID);
    private static IntPtr GetCCW(object o, Type T);
    private static IntPtr GetComInterfaceForObjectInternal(object o, Type T);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetComInterfaceForObjectInContext(object o, Type t);
    public static object GetComObjectData(object obj, object key);
    private static int GetComSlotForMethodInfoInternal(MemberInfo m);
    public static int GetComSlotForMethodInfo(MemberInfo m);
    public static int GetEndComSlot(Type t);
    [ComVisibleAttribute("True")]
public static IntPtr GetExceptionPointers();
    public static IntPtr GetHINSTANCE(Module m);
    public static int GetExceptionCode();
    public static int GetHRForException(Exception e);
    [ReliabilityContractAttribute("3", "2")]
public static int GetHRForLastWin32Error();
    private static IntPtr GetIDispatchForObjectInternal(object o);
    public static IntPtr GetIDispatchForObject(object o);
    public static IntPtr GetIDispatchForObjectInContext(object o);
    public static IntPtr GetITypeInfoForType(Type t);
    public static IntPtr GetIUnknownForObjectInContext(object o);
    [ObsoleteAttribute("This method has been deprecated")]
public static IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
    public static MemberInfo GetMethodInfoForComSlot(Type t, int slot, ComMemberType& memberType);
    private static IntPtr GetIUnknownForObjectInternal(object o);
    public static IntPtr GetIUnknownForObject(object o);
    public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    private static object GetObjectForCCW(IntPtr pUnk);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static int GetStartComSlot(Type t);
    [ObsoleteAttribute("This method has been deprecated")]
public static Thread GetThreadFromFiberCookie(int cookie);
    public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    public static Type GetTypeForITypeInfo(IntPtr piTypeInfo);
    [ObsoleteAttribute]
public static string GetTypeInfoName(UCOMITypeInfo pTI);
    [ObsoleteAttribute]
public static Guid GetTypeLibGuid(UCOMITypeLib pTLB);
    public static Guid GetTypeLibGuid(ITypeLib typelib);
    public static Guid GetTypeLibGuidForAssembly(Assembly asm);
    [ObsoleteAttribute]
public static int GetTypeLibLcid(UCOMITypeLib pTLB);
    public static int GetTypeLibLcid(ITypeLib typelib);
    [ObsoleteAttribute]
public static string GetTypeLibName(UCOMITypeLib pTLB);
    public static string GetTypeLibName(ITypeLib typelib);
    public static void GetTypeLibVersionForAssembly(Assembly inputAssembly, Int32& majorVersion, Int32& minorVersion);
    [ObsoleteAttribute("This method has been deprecated")]
public static IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);
    public static bool IsTypeVisibleFromCom(Type t);
    public static int NumParamBytes(MethodInfo m);
    public static Type GetTypeFromCLSID(Guid clsid);
    public static string GetTypeInfoName(ITypeInfo typeInfo);
    public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static bool IsComObject(object o);
    [ReliabilityContractAttribute("3", "2")]
public static int GetLastWin32Error();
    public static IntPtr OffsetOf(Type t, string fieldName);
    public static IntPtr OffsetOf(string fieldName);
    public static void Prelink(MethodInfo m);
    public static void PrelinkAll(Type c);
    public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    public static string PtrToStringAuto(IntPtr ptr);
    public static string PtrToStringAuto(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringBSTR(IntPtr ptr);
    [ComVisibleAttribute("True")]
public static void PtrToStructure(IntPtr ptr, object structure);
    [ComVisibleAttribute("True")]
public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static void PtrToStructure(IntPtr ptr, T structure);
    public static T PtrToStructure(IntPtr ptr);
    private static int QueryInterfaceInternal(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static byte ReadByte(IntPtr ptr);
    public static byte ReadByte(IntPtr ptr, int ofs);
    [SuppressUnmanagedCodeSecurityAttribute]
public static byte ReadByte(object ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static short ReadInt16(IntPtr ptr, int ofs);
    [SuppressUnmanagedCodeSecurityAttribute]
public static short ReadInt16(object ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
public static int ReadInt32(IntPtr ptr);
    [ReliabilityContractAttribute("3", "2")]
public static int ReadInt32(IntPtr ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
[SuppressUnmanagedCodeSecurityAttribute]
public static int ReadInt32(object ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
public static long ReadInt64(IntPtr ptr);
    public static long ReadInt64(IntPtr ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
[SuppressUnmanagedCodeSecurityAttribute]
public static long ReadInt64(object ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
public static IntPtr ReadIntPtr(IntPtr ptr);
    [ReliabilityContractAttribute("3", "2")]
public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    [ReliabilityContractAttribute("3", "2")]
public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    [ReliabilityContractAttribute("3", "2")]
private static int ReleaseInternal(IntPtr pUnk);
    [ReliabilityContractAttribute("3", "2")]
public static int Release(IntPtr pUnk);
    private static int ReleaseComObjectInternal(object co);
    public static int ReleaseComObject(object o);
    [ObsoleteAttribute]
public static void ReleaseThreadCache();
    public static bool SetComObjectData(object obj, object key, object data);
    [ComVisibleAttribute("True")]
public static int SizeOf(object structure);
    public static int SizeOf(Type t);
    public static int SizeOf();
    public static int SizeOf(T structure);
    internal static UInt32 SizeOfType(Type type);
    internal static UInt32 AlignedSizeOf();
    public static IntPtr StringToBSTR(string s);
    public static IntPtr StringToCoTaskMemAnsi(string s);
    public static IntPtr StringToCoTaskMemAuto(string s);
    public static IntPtr StringToCoTaskMemUni(string s);
    private static IntPtr StringToHGlobalAnsi(Char* s, int length);
    public static IntPtr StringToHGlobalAnsi(string s);
    public static IntPtr StringToAllocatedMemoryUTF8(string s);
    public static IntPtr StringToHGlobalAuto(string s);
    private static IntPtr StringToHGlobalUni(Char* s, int length);
    public static IntPtr StringToHGlobalUni(string s);
    public static IntPtr SecureStringToBSTR(SecureString s);
    internal static IntPtr SecureStringCoTaskMemAllocator(int len);
    internal static IntPtr SecureStringGlobalAllocator(int len);
    internal static IntPtr SecureStringToAnsi(SecureString s, SecureStringAllocator allocator);
    internal static IntPtr SecureStringToUnicode(SecureString s, SecureStringAllocator allocator);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    [ComVisibleAttribute("True")]
[ReliabilityContractAttribute("3", "1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    private static IntPtr BufferToBSTR(Char* ptr, int slen);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    [SuppressUnmanagedCodeSecurityAttribute]
public static void WriteByte(object ptr, int ofs, byte val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    [SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt16(object ptr, int ofs, short val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    public static void WriteInt16(object ptr, int ofs, char val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    [SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt32(object ptr, int ofs, int val);
    public static void WriteInt64(IntPtr ptr, long val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    [SuppressUnmanagedCodeSecurityAttribute]
public static void WriteInt64(object ptr, int ofs, long val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    private static Exception ConvertHrToException(int errorCode);
    private static int _SetErrorInfo(int dwReserved, IErrorInfo pIErrorInfo);
    private static int _GetErrorInfo(int dwReserved, IErrorInfo& ppIErrorInfo);
    internal static int SetErrorInfo(int dwReserved, IErrorInfo errorInfo);
    internal static int GetErrorInfo(int dwReserved, IErrorInfo& errorInfo);
    public static Exception GetExceptionForHR(int errorCode);
    public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    public static int FinalReleaseComObject(object o);
    private static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    private static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    internal static void SetLastWin32Error(int error);
    internal static IntPtr GetRawIUnknownForComObjectNoAddRef(object o);
    internal static int GetHRForException_WinRT(Exception e);
    internal static object GetNativeActivationFactory(Type type);
    internal static ICustomMarshaler GetCustomMarshalerInstance(Type type, string cookie);
    public static IntPtr StringToCoTaskMemUTF8(string s);
}
[AttributeUsageAttribute("10496")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    public string MarshalCookie;
    [ComVisibleAttribute("True")]
public string MarshalType;
    [ComVisibleAttribute("True")]
[PreserveDependencyAttribute("GetCustomMarshalerInstance", "System.Runtime.InteropServices.Marshal")]
public Type MarshalTypeRef;
    public Type SafeArrayUserDefinedSubType;
    private UnmanagedType utype;
    public UnmanagedType ArraySubType;
    public VarEnum SafeArraySubType;
    public int SizeConst;
    public int IidParameterIndex;
    public short SizeParamIndex;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(short unmanagedType);
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public UnmanagedType get_Value();
    internal MarshalAsAttribute Copy();
}
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& GetReference(Span`1<T> span);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    internal static T& GetNonNullPinnableReference(Span`1<T> span);
    internal static T& GetNonNullPinnableReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    public static Span`1<T> CreateSpan(T& reference, int length);
    public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__14`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public string EntryPoint;
    public CallingConvention CallingConvention;
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ObjectCreationDelegate : MulticastDelegate {
    public ObjectCreationDelegate(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr aggregator);
    public virtual IAsyncResult BeginInvoke(IntPtr aggregator, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.OSPlatform : ValueType {
    private string _osPlatform;
    [CompilerGeneratedAttribute]
private static OSPlatform <Linux>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <OSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <Windows>k__BackingField;
    public static OSPlatform Linux { get; }
    public static OSPlatform OSX { get; }
    public static OSPlatform Windows { get; }
    private OSPlatform(string osPlatform);
    private static OSPlatform();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Linux();
    [CompilerGeneratedAttribute]
public static OSPlatform get_OSX();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Windows();
    public static OSPlatform Create(string osPlatform);
    public sealed virtual bool Equals(OSPlatform other);
    internal bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OSPlatform left, OSPlatform right);
    public static bool op_Inequality(OSPlatform left, OSPlatform right);
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.PARAMDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.PARAMFLAG instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute : Attribute {
    internal int _major;
    internal int _minor;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public PrimaryInteropAssemblyAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.RegistrationClassContext : Enum {
    public int value__;
    public static RegistrationClassContext DisableActivateAsActivator;
    public static RegistrationClassContext EnableActivateAsActivator;
    public static RegistrationClassContext EnableCodeDownload;
    public static RegistrationClassContext FromDefaultContext;
    public static RegistrationClassContext InProcessHandler;
    public static RegistrationClassContext InProcessHandler16;
    public static RegistrationClassContext InProcessServer;
    public static RegistrationClassContext InProcessServer16;
    public static RegistrationClassContext LocalServer;
    public static RegistrationClassContext NoCodeDownload;
    public static RegistrationClassContext NoCustomMarshal;
    public static RegistrationClassContext NoFailureLog;
    public static RegistrationClassContext RemoteServer;
    public static RegistrationClassContext Reserved1;
    public static RegistrationClassContext Reserved2;
    public static RegistrationClassContext Reserved3;
    public static RegistrationClassContext Reserved4;
    public static RegistrationClassContext Reserved5;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.RegistrationConnectionType : Enum {
    public int value__;
    public static RegistrationConnectionType SingleUse;
    public static RegistrationConnectionType MultipleUse;
    public static RegistrationConnectionType MultiSeparate;
    public static RegistrationConnectionType Suspended;
    public static RegistrationConnectionType Surrogate;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
[GuidAttribute("475e398f-8afa-43a7-a3be-f4ef8d6787c9")]
public class System.Runtime.InteropServices.RegistrationServices : object {
    private static Guid guidManagedCategory;
    private static RegistrationServices();
    public virtual Guid GetManagedCategoryGuid();
    [SecurityCriticalAttribute]
public virtual string GetProgIdForType(Type type);
    [MonoTODOAttribute("implement")]
[SecurityCriticalAttribute]
public virtual Type[] GetRegistrableTypesInAssembly(Assembly assembly);
    [SecurityCriticalAttribute]
[MonoTODOAttribute("implement")]
public virtual bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags);
    [SecurityCriticalAttribute]
[MonoTODOAttribute("implement")]
public virtual void RegisterTypeForComClients(Type type, Guid& g);
    [MonoTODOAttribute("implement")]
[SecuritySafeCriticalAttribute]
public virtual bool TypeRepresentsComType(Type type);
    [MonoTODOAttribute("implement")]
[SecurityCriticalAttribute]
public virtual bool TypeRequiresRegistration(Type type);
    [MonoTODOAttribute("implement")]
[SecurityCriticalAttribute]
public virtual bool UnregisterAssembly(Assembly assembly);
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("implement")]
public virtual int RegisterTypeForComClients(Type type, RegistrationClassContext classContext, RegistrationConnectionType flags);
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("implement")]
public virtual void UnregisterTypeForComClients(int cookie);
}
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.RuntimeEnvironment : object {
    public static string SystemConfigurationFile { get; }
    public static bool FromGlobalAccessCache(Assembly a);
    [SecuritySafeCriticalAttribute]
public static string GetSystemVersion();
    [SecuritySafeCriticalAttribute]
public static string GetRuntimeDirectory();
    private static string GetRuntimeDirectoryImpl();
    [SecuritySafeCriticalAttribute]
public static string get_SystemConfigurationFile();
    private static IntPtr GetRuntimeInterfaceImpl(Guid clsid, Guid riid);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public static IntPtr GetRuntimeInterfaceAsIntPtr(Guid clsid, Guid riid);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public static object GetRuntimeInterfaceAsObject(Guid clsid, Guid riid);
}
public static class System.Runtime.InteropServices.RuntimeInformation : object {
    private static Architecture _osArchitecture;
    private static Architecture _processArchitecture;
    private static OSPlatform _osPlatform;
    public static string FrameworkDescription { get; }
    public static string OSDescription { get; }
    public static Architecture OSArchitecture { get; }
    public static Architecture ProcessArchitecture { get; }
    private static RuntimeInformation();
    private static string GetRuntimeArchitecture();
    private static string GetOSName();
    public static string get_FrameworkDescription();
    public static bool IsOSPlatform(OSPlatform osPlatform);
    public static string get_OSDescription();
    public static Architecture get_OSArchitecture();
    public static Architecture get_ProcessArchitecture();
}
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private static UIntPtr Uninitialized;
    private UIntPtr _numBytes;
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, ulong sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOf();
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private int _state;
    private bool _ownsHandle;
    private bool _fullyInitialized;
    private static int RefCount_Mask;
    private static int RefCount_One;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    [ReliabilityContractAttribute("3", "1")]
protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
    [ReliabilityContractAttribute("3", "2")]
protected void SetHandle(IntPtr handle);
    [ReliabilityContractAttribute("3", "2")]
public IntPtr DangerousGetHandle();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsClosed();
    [ReliabilityContractAttribute("3", "2")]
public abstract virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public void Close();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
protected virtual void Dispose(bool disposing);
    [ReliabilityContractAttribute("3", "2")]
protected abstract virtual bool ReleaseHandle();
    [ReliabilityContractAttribute("3", "2")]
public void SetHandleAsInvalid();
    [ReliabilityContractAttribute("3", "1")]
public void DangerousAddRef(Boolean& success);
    [ReliabilityContractAttribute("3", "2")]
public void DangerousRelease();
    private void InternalDispose();
    private void InternalFinalize();
    private void DangerousReleaseInternal(bool dispose);
}
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
public static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    internal static bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length);
    public static bool TryRead(SequenceReader`1& reader, T& value);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
[ObsoleteAttribute("This attribute has been deprecated.  Application Domains no longer respect Activation Context boundaries in IDispatch calls.", "False")]
public class System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute : Attribute {
}
[ObsoleteAttribute]
public class System.Runtime.InteropServices.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
[AttributeUsageAttribute("12")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    private static int DEFAULT_PACKING_SIZE;
    internal LayoutKind _val;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    internal StructLayoutAttribute(LayoutKind layoutKind, int pack, int size, CharSet charSet);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [SecurityCriticalAttribute]
internal static StructLayoutAttribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
    public LayoutKind get_Value();
}
[ObsoleteAttribute]
public enum System.Runtime.InteropServices.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEATTR instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
[ComVisibleAttribute("False")]
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    internal string Scope_;
    internal string Identifier_;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Scope();
    public string get_Identifier();
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.TYPEKIND instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public enum System.Runtime.InteropServices.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
[ObsoleteAttribute]
public class System.Runtime.InteropServices.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
[GuidAttribute("f1c3bf79-c3e4-11d3-88e7-00902754c43a")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
public class System.Runtime.InteropServices.TypeLibConverter : object {
    [SecuritySafeCriticalAttribute]
[MonoTODOAttribute("implement")]
public sealed virtual object ConvertAssemblyToTypeLib(Assembly assembly, string strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink);
    [MonoTODOAttribute("implement")]
[SecuritySafeCriticalAttribute]
public sealed virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces);
    [SecuritySafeCriticalAttribute]
[MonoTODOAttribute("implement")]
public sealed virtual AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion);
    [MonoTODOAttribute("implement")]
public sealed virtual bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibExporterFlags : Enum {
    public int value__;
    public static TypeLibExporterFlags OnlyReferenceRegistered;
    public static TypeLibExporterFlags None;
    public static TypeLibExporterFlags CallerResolvedReferences;
    public static TypeLibExporterFlags OldNames;
    public static TypeLibExporterFlags ExportAs32Bit;
    public static TypeLibExporterFlags ExportAs64Bit;
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibFuncAttribute : Attribute {
    internal TypeLibFuncFlags _val;
    public TypeLibFuncFlags Value { get; }
    public TypeLibFuncAttribute(TypeLibFuncFlags flags);
    public TypeLibFuncAttribute(short flags);
    public TypeLibFuncFlags get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibFuncFlags : Enum {
    public int value__;
    public static TypeLibFuncFlags FRestricted;
    public static TypeLibFuncFlags FSource;
    public static TypeLibFuncFlags FBindable;
    public static TypeLibFuncFlags FRequestEdit;
    public static TypeLibFuncFlags FDisplayBind;
    public static TypeLibFuncFlags FDefaultBind;
    public static TypeLibFuncFlags FHidden;
    public static TypeLibFuncFlags FUsesGetLastError;
    public static TypeLibFuncFlags FDefaultCollelem;
    public static TypeLibFuncFlags FUiDefault;
    public static TypeLibFuncFlags FNonBrowsable;
    public static TypeLibFuncFlags FReplaceable;
    public static TypeLibFuncFlags FImmediateBind;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.TypeLibImportClassAttribute : Attribute {
    internal string _importClassName;
    public string Value { get; }
    public TypeLibImportClassAttribute(Type importClass);
    public string get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibImporterFlags : Enum {
    public int value__;
    public static TypeLibImporterFlags PrimaryInteropAssembly;
    public static TypeLibImporterFlags UnsafeInterfaces;
    public static TypeLibImporterFlags SafeArrayAsSystemArray;
    public static TypeLibImporterFlags TransformDispRetVals;
    public static TypeLibImporterFlags None;
    public static TypeLibImporterFlags PreventClassMembers;
    public static TypeLibImporterFlags ImportAsAgnostic;
    public static TypeLibImporterFlags ImportAsItanium;
    public static TypeLibImporterFlags ImportAsX64;
    public static TypeLibImporterFlags ImportAsX86;
    public static TypeLibImporterFlags ReflectionOnlyLoading;
    public static TypeLibImporterFlags SerializableValueClasses;
    public static TypeLibImporterFlags NoDefineVersionResource;
    public static TypeLibImporterFlags ImportAsArm;
}
[AttributeUsageAttribute("1052")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibTypeAttribute : Attribute {
    internal TypeLibTypeFlags _val;
    public TypeLibTypeFlags Value { get; }
    public TypeLibTypeAttribute(TypeLibTypeFlags flags);
    public TypeLibTypeAttribute(short flags);
    public TypeLibTypeFlags get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibTypeFlags : Enum {
    public int value__;
    public static TypeLibTypeFlags FAppObject;
    public static TypeLibTypeFlags FCanCreate;
    public static TypeLibTypeFlags FLicensed;
    public static TypeLibTypeFlags FPreDeclId;
    public static TypeLibTypeFlags FHidden;
    public static TypeLibTypeFlags FControl;
    public static TypeLibTypeFlags FDual;
    public static TypeLibTypeFlags FNonExtensible;
    public static TypeLibTypeFlags FOleAutomation;
    public static TypeLibTypeFlags FRestricted;
    public static TypeLibTypeFlags FAggregatable;
    public static TypeLibTypeFlags FReplaceable;
    public static TypeLibTypeFlags FDispatchable;
    public static TypeLibTypeFlags FReverseBind;
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibVarAttribute : Attribute {
    internal TypeLibVarFlags _val;
    public TypeLibVarFlags Value { get; }
    public TypeLibVarAttribute(TypeLibVarFlags flags);
    public TypeLibVarAttribute(short flags);
    public TypeLibVarFlags get_Value();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.TypeLibVarFlags : Enum {
    public int value__;
    public static TypeLibVarFlags FReadOnly;
    public static TypeLibVarFlags FSource;
    public static TypeLibVarFlags FBindable;
    public static TypeLibVarFlags FRequestEdit;
    public static TypeLibVarFlags FDisplayBind;
    public static TypeLibVarFlags FDefaultBind;
    public static TypeLibVarFlags FHidden;
    public static TypeLibVarFlags FRestricted;
    public static TypeLibVarFlags FDefaultCollelem;
    public static TypeLibVarFlags FUiDefault;
    public static TypeLibVarFlags FNonBrowsable;
    public static TypeLibVarFlags FReplaceable;
    public static TypeLibVarFlags FImmediateBind;
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Runtime.InteropServices.TypeLibVersionAttribute : Attribute {
    internal int _major;
    internal int _minor;
    public int MajorVersion { get; }
    public int MinorVersion { get; }
    public TypeLibVersionAttribute(int major, int minor);
    public int get_MajorVersion();
    public int get_MinorVersion();
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute]
[GuidAttribute("0000000e-0000-0000-c000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(UCOMIRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(UCOMIEnumString& ppenum);
    public abstract virtual void RevokeObjectParam(string pszKey);
}
[ObsoleteAttribute]
[GuidAttribute("b196b286-bab4-101a-b69c-00aa00341d07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(UCOMIConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(UCOMIEnumConnections& ppEnum);
}
[ObsoleteAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("b196b284-bab4-101a-b69c-00aa00341d07")]
public interface System.Runtime.InteropServices.UCOMIConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(UCOMIEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, UCOMIConnectionPoint& ppCP);
}
[GuidAttribute("b196b285-bab4-101a-b69c-00aa00341d07")]
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute]
public interface System.Runtime.InteropServices.UCOMIEnumConnectionPoints {
    public abstract virtual int Next(int celt, UCOMIConnectionPoint[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumConnectionPoints& ppenum);
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.IEnumConnections instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(UCOMIEnumConnections& ppenum);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute]
[GuidAttribute("00000102-0000-0000-c000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIEnumMoniker {
    public abstract virtual int Next(int celt, UCOMIMoniker[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumMoniker& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000101-0000-0000-c000-000000000046")]
[ObsoleteAttribute]
public interface System.Runtime.InteropServices.UCOMIEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, Int32& pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(UCOMIEnumString& ppenum);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute]
[GuidAttribute("00020404-0000-0000-c000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIEnumVARIANT {
    public abstract virtual int Next(int celt, int rgvar, int pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(int ppenum);
}
[ObsoleteAttribute]
[GuidAttribute("0000000f-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMIMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(UCOMIStream pStm);
    public abstract virtual void Save(UCOMIStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, UCOMIMoniker& ppmkToLeft, UCOMIMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, UCOMIMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, UCOMIEnumMoniker& ppenumMoniker);
    public abstract virtual void IsEqual(UCOMIMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(UCOMIMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, UCOMIMoniker& ppmkOut);
    public abstract virtual void IsSystemMoniker(Int32& pdwMksys);
}
[InterfaceTypeAttribute("1")]
[ObsoleteAttribute]
[GuidAttribute("0000010b-0000-0000-c000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000010-0000-0000-c000-000000000046")]
[ObsoleteAttribute]
public interface System.Runtime.InteropServices.UCOMIRunningObjectTable {
    public abstract virtual void Register(int grfFlags, object punkObject, UCOMIMoniker pmkObjectName, Int32& pdwRegister);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual void IsRunning(UCOMIMoniker pmkObjectName);
    public abstract virtual void GetObject(UCOMIMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(UCOMIEnumMoniker& ppenumMoniker);
}
[ObsoleteAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000c-0000-0000-c000-000000000046")]
public interface System.Runtime.InteropServices.UCOMIStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(UCOMIStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(UCOMIStream& ppstm);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020403-0000-0000-c000-000000000046")]
[ObsoleteAttribute]
public interface System.Runtime.InteropServices.UCOMITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, UCOMITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, UCOMITypeInfo& ppTInfo, UCOMITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.ITypeInfo instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.UCOMITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(UCOMITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, Int32& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, Object& pVarResult, EXCEPINFO& pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, String& pBstrDllName, String& pBstrName, Int16& pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, UCOMITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(UCOMITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020402-0000-0000-c000-000000000046")]
[ObsoleteAttribute]
public interface System.Runtime.InteropServices.UCOMITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, UCOMITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, UCOMITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(UCOMITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, UCOMITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
public class System.Runtime.InteropServices.UnknownWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    private CallingConvention m_callingConvention;
    public CharSet CharSet;
    public bool BestFitMapping;
    public bool ThrowOnUnmappableChar;
    public bool SetLastError;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    public CallingConvention get_CallingConvention();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    [ComVisibleAttribute("False")]
public static UnmanagedType IInspectable;
    [ComVisibleAttribute("False")]
public static UnmanagedType HString;
    [ComVisibleAttribute("False")]
public static UnmanagedType LPUTF8Str;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.VARDESC instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public class System.Runtime.InteropServices.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VarEnum varkind;
}
[ComVisibleAttribute("True")]
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
[ObsoleteAttribute("Use System.Runtime.InteropServices.ComTypes.VARFLAGS instead. http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public class System.Runtime.InteropServices.VariantWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
    private Type m_defaultInterface;
    public Type DefaultInterface { get; }
    public DefaultInterfaceAttribute(Type defaultInterface);
    public Type get_DefaultInterface();
}
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <ResolvedAssemblyFiles>k__BackingField;
    public string NamespaceName { get; private set; }
    public Collection`1<string> ResolvedAssemblyFiles { get; private set; }
    public DesignerNamespaceResolveEventArgs(string namespaceName);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
private void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_ResolvedAssemblyFiles();
    [CompilerGeneratedAttribute]
private void set_ResolvedAssemblyFiles(Collection`1<string> value);
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
    internal ulong m_value;
    internal ulong Value { get; }
    internal EventRegistrationToken(ulong value);
    internal ulong get_Value();
    public static bool op_Equality(EventRegistrationToken left, EventRegistrationToken right);
    public static bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
    private Dictionary`2<EventRegistrationToken, T> m_tokens;
    private T modreq(System.Runtime.CompilerServices.IsVolatile) m_invokeList;
    public T InvocationList { get; public set; }
    public T get_InvocationList();
    public void set_InvocationList(T value);
    public EventRegistrationToken AddEventHandler(T handler);
    private EventRegistrationToken AddEventHandlerNoLock(T handler);
    [FriendAccessAllowedAttribute]
internal T ExtractHandler(EventRegistrationToken token);
    private static EventRegistrationToken GetPreferredToken(T handler);
    public void RemoveEventHandler(EventRegistrationToken token);
    public void RemoveEventHandler(T handler);
    private void RemoveEventHandlerNoLock(EventRegistrationToken token);
    public static EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable);
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
    public abstract virtual object ActivateInstance();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
    private Type m_interfaceType;
    private byte m_majorVersion;
    private byte m_minorVersion;
    private byte m_buildVersion;
    private byte m_revisionVersion;
    public Type InterfaceType { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public byte BuildVersion { get; }
    public byte RevisionVersion { get; }
    public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
    public Type get_InterfaceType();
    public byte get_MajorVersion();
    public byte get_MinorVersion();
    public byte get_BuildVersion();
    public byte get_RevisionVersion();
}
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo {
    public abstract virtual void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public abstract virtual void GetReference(String& reference);
}
[ComVisibleAttribute("False")]
public class System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Assembly> <ResolvedAssemblies>k__BackingField;
    public string NamespaceName { get; private set; }
    public Assembly RequestingAssembly { get; private set; }
    public Collection`1<Assembly> ResolvedAssemblies { get; private set; }
    public NamespaceResolveEventArgs(string namespaceName, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
private void set_NamespaceName(string value);
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
    [CompilerGeneratedAttribute]
private void set_RequestingAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public Collection`1<Assembly> get_ResolvedAssemblies();
    [CompilerGeneratedAttribute]
private void set_ResolvedAssemblies(Collection`1<Assembly> value);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[AttributeUsageAttribute("12288")]
public class System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
    private string m_Name;
    public string Name { get; }
    public ReturnValueNameAttribute(string name);
    public string get_Name();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods : object {
    public static int WindowsCreateString(string sourceString, int length, IntPtr* hstring);
    public static int WindowsDeleteString(IntPtr hstring);
    public static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
    public static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    public static void RoReportUnhandledError(IRestrictedErrorInfo error);
    public static IRestrictedErrorInfo GetRestrictedErrorInfo();
}
[FriendAccessAllowedAttribute]
[AttributeUsageAttribute("5148")]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeImportAttribute : Attribute {
}
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
    private static bool s_haveBlueErrorApis;
    private static Guid s_iidIErrorInfo;
    private static WindowsRuntimeMarshal();
    [SecurityCriticalAttribute]
public static void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler);
    [SecurityCriticalAttribute]
public static void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler);
    [SecurityCriticalAttribute]
public static void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod);
    internal static int GetRegistrationTokenCacheSize();
    internal static void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove);
    [SecurityCriticalAttribute]
internal static string HStringToString(IntPtr hstring);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException, string messageResource);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException);
    [SecurityCriticalAttribute]
private static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    [SecurityCriticalAttribute]
private static void RoReportUnhandledError(IRestrictedErrorInfo error);
    [FriendAccessAllowedAttribute]
[SecuritySafeCriticalAttribute]
internal static bool ReportUnhandledError(Exception e);
    [SecurityCriticalAttribute]
public static IActivationFactory GetActivationFactory(Type type);
    [SecurityCriticalAttribute]
public static IntPtr StringToHString(string s);
    [SecurityCriticalAttribute]
public static string PtrToStringHString(IntPtr ptr);
    [SecurityCriticalAttribute]
public static void FreeHString(IntPtr ptr);
}
[MonoTODOAttribute]
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMetadata : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve;
    [CompilerGeneratedAttribute]
private static EventHandler`1<NamespaceResolveEventArgs> ReflectionOnlyNamespaceResolve;
    public static IEnumerable`1<string> ResolveNamespace(string namespaceName, IEnumerable`1<string> packageGraphFilePaths);
    public static IEnumerable`1<string> ResolveNamespace(string namespaceName, string windowsSdkFilePath, IEnumerable`1<string> packageGraphFilePaths);
    [CompilerGeneratedAttribute]
public static void add_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_DesignerNamespaceResolve(EventHandler`1<DesignerNamespaceResolveEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReflectionOnlyNamespaceResolve(EventHandler`1<NamespaceResolveEventArgs> value);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    [MonoTODOAttribute]
public MemoryFailPoint(int sizeInMegabytes);
    protected virtual override void Finalize();
    [MonoTODOAttribute]
[SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
}
public static class System.Runtime.ProfileOptimization : object {
    internal static void InternalSetProfileRoot(string directoryPath);
    internal static void InternalStartProfile(string profile, IntPtr ptrNativeAssemblyLoadContext);
    [SecurityCriticalAttribute]
public static void SetProfileRoot(string directoryPath);
    [SecurityCriticalAttribute]
public static void StartProfile(string profile);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ActivatedClientTypeEntry : TypeEntry {
    private string applicationUrl;
    private Type obj_type;
    public string ApplicationUrl { get; }
    public IContextAttribute[] ContextAttributes { get; public set; }
    public Type ObjectType { get; }
    public ActivatedClientTypeEntry(Type type, string appUrl);
    public ActivatedClientTypeEntry(string typeName, string assemblyName, string appUrl);
    public string get_ApplicationUrl();
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public Type get_ObjectType();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ActivatedServiceTypeEntry : TypeEntry {
    private Type obj_type;
    public IContextAttribute[] ContextAttributes { get; public set; }
    public Type ObjectType { get; }
    public ActivatedServiceTypeEntry(Type type);
    public ActivatedServiceTypeEntry(string typeName, string assemblyName);
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public Type get_ObjectType();
    public virtual string ToString();
}
internal class System.Runtime.Remoting.Activation.ActivationServices : object {
    private static IActivator _constructionActivator;
    private static IActivator ConstructionActivator { get; }
    private static IActivator get_ConstructionActivator();
    public static IMessage Activate(RemotingProxy proxy, ConstructionCall ctorCall);
    public static IMessage RemoteActivate(IConstructionCallMessage ctorCall);
    public static object CreateProxyFromAttributes(Type type, Object[] activationAttributes);
    public static ConstructionCall CreateConstructionCall(Type type, string activationUrl, Object[] activationAttributes);
    public static IMessage CreateInstanceFromMessage(IConstructionCallMessage ctorCall);
    public static object CreateProxyForType(Type type);
    internal static void PushActivationAttributes(Type serverType, Object[] attributes);
    internal static void PopActivationAttributes(Type serverType);
    public static object AllocateUninitializedClassInstance(Type type);
    public static void EnableProxyActivation(Type type, bool enable);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Activation.ActivatorLevel : Enum {
    public int value__;
    public static ActivatorLevel Construction;
    public static ActivatorLevel Context;
    public static ActivatorLevel AppDomain;
    public static ActivatorLevel Process;
    public static ActivatorLevel Machine;
}
internal class System.Runtime.Remoting.Activation.AppDomainLevelActivator : object {
    private string _activationUrl;
    private IActivator _next;
    public ActivatorLevel Level { get; }
    public IActivator NextActivator { get; public set; }
    public AppDomainLevelActivator(string activationUrl, IActivator next);
    public sealed virtual ActivatorLevel get_Level();
    public sealed virtual IActivator get_NextActivator();
    public sealed virtual void set_NextActivator(IActivator value);
    public sealed virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall);
}
internal class System.Runtime.Remoting.Activation.ConstructionLevelActivator : object {
    public ActivatorLevel Level { get; }
    public IActivator NextActivator { get; public set; }
    public sealed virtual ActivatorLevel get_Level();
    public sealed virtual IActivator get_NextActivator();
    public sealed virtual void set_NextActivator(IActivator value);
    public sealed virtual IConstructionReturnMessage Activate(IConstructionCallMessage msg);
}
internal class System.Runtime.Remoting.Activation.ContextLevelActivator : object {
    private IActivator m_NextActivator;
    public ActivatorLevel Level { get; }
    public IActivator NextActivator { get; public set; }
    public ContextLevelActivator(IActivator next);
    public sealed virtual ActivatorLevel get_Level();
    public sealed virtual IActivator get_NextActivator();
    public sealed virtual void set_NextActivator(IActivator value);
    public sealed virtual IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IActivator {
    public ActivatorLevel Level { get; }
    public IActivator NextActivator { get; public set; }
    public abstract virtual ActivatorLevel get_Level();
    public abstract virtual IActivator get_NextActivator();
    public abstract virtual void set_NextActivator(IActivator value);
    public abstract virtual IConstructionReturnMessage Activate(IConstructionCallMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IConstructionCallMessage {
    public Type ActivationType { get; }
    public string ActivationTypeName { get; }
    public IActivator Activator { get; public set; }
    public Object[] CallSiteActivationAttributes { get; }
    public IList ContextProperties { get; }
    public abstract virtual Type get_ActivationType();
    public abstract virtual string get_ActivationTypeName();
    public abstract virtual IActivator get_Activator();
    public abstract virtual void set_Activator(IActivator value);
    public abstract virtual Object[] get_CallSiteActivationAttributes();
    public abstract virtual IList get_ContextProperties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Activation.IConstructionReturnMessage {
}
internal class System.Runtime.Remoting.Activation.RemoteActivationAttribute : Attribute {
    private IList _contextProperties;
    public RemoteActivationAttribute(IList contextProperties);
    public sealed virtual bool IsContextOK(Context ctx, IConstructionCallMessage ctor);
    public sealed virtual void GetPropertiesForNewContext(IConstructionCallMessage ctor);
}
internal class System.Runtime.Remoting.Activation.RemoteActivator : MarshalByRefObject {
    public ActivatorLevel Level { get; }
    public IActivator NextActivator { get; public set; }
    public sealed virtual IConstructionReturnMessage Activate(IConstructionCallMessage msg);
    public virtual object InitializeLifetimeService();
    public sealed virtual ActivatorLevel get_Level();
    public sealed virtual IActivator get_NextActivator();
    public sealed virtual void set_NextActivator(IActivator value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Activation.UrlAttribute : ContextAttribute {
    private string url;
    public string UrlValue { get; }
    public UrlAttribute(string callsiteURL);
    public string get_UrlValue();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
}
internal class System.Runtime.Remoting.ChannelData : object {
    internal string Ref;
    internal string Type;
    internal string Id;
    internal string DelayLoadAsClientChannel;
    private ArrayList _serverProviders;
    private ArrayList _clientProviders;
    private Hashtable _customProperties;
    internal ArrayList ServerProviders { get; }
    public ArrayList ClientProviders { get; }
    public Hashtable CustomProperties { get; }
    internal ArrayList get_ServerProviders();
    public ArrayList get_ClientProviders();
    public Hashtable get_CustomProperties();
    public void CopyFrom(ChannelData other);
}
internal class System.Runtime.Remoting.ChannelInfo : object {
    private Object[] channelData;
    public Object[] ChannelData { get; public set; }
    public ChannelInfo(object remoteChannelData);
    public sealed virtual Object[] get_ChannelData();
    public sealed virtual void set_ChannelData(Object[] value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
internal class System.Runtime.Remoting.Channels.AggregateDictionary : object {
    private IDictionary[] dictionaries;
    private ArrayList _values;
    private ArrayList _keys;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AggregateDictionary(IDictionary[] dics);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object ob);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object ob);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
internal class System.Runtime.Remoting.Channels.AggregateEnumerator : object {
    private IDictionary[] dictionaries;
    private int pos;
    private IDictionaryEnumerator currente;
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public object Current { get; }
    public AggregateEnumerator(IDictionary[] dics);
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Runtime.Remoting.Channels.AsyncRequest : object {
    internal IMessageSink ReplySink;
    internal IMessage MsgRequest;
    public AsyncRequest(IMessage msgRequest, IMessageSink replySink);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties : object {
    private Hashtable table;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public IDictionary Properties { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    [SecuritySafeCriticalAttribute]
public virtual int get_Count();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsFixedSize();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsReadOnly();
    [SecuritySafeCriticalAttribute]
public virtual bool get_IsSynchronized();
    [SecuritySafeCriticalAttribute]
public virtual object get_Item(object key);
    [SecuritySafeCriticalAttribute]
public virtual void set_Item(object key, object value);
    [SecuritySafeCriticalAttribute]
public virtual ICollection get_Keys();
    public virtual IDictionary get_Properties();
    [SecuritySafeCriticalAttribute]
public virtual object get_SyncRoot();
    [SecuritySafeCriticalAttribute]
public virtual ICollection get_Values();
    [SecuritySafeCriticalAttribute]
public virtual void Add(object key, object value);
    [SecuritySafeCriticalAttribute]
public virtual void Clear();
    [SecuritySafeCriticalAttribute]
public virtual bool Contains(object key);
    [SecuritySafeCriticalAttribute]
public virtual void CopyTo(Array array, int index);
    [SecuritySafeCriticalAttribute]
public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecuritySafeCriticalAttribute]
public virtual void Remove(object key);
}
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Channels.BaseChannelSinkWithProperties : BaseChannelObjectWithProperties {
}
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Channels.BaseChannelWithProperties : BaseChannelObjectWithProperties {
    protected IChannelSinkBase SinksWithProperties;
    public IDictionary Properties { get; }
    public virtual IDictionary get_Properties();
}
internal class System.Runtime.Remoting.Channels.CADSerializer : object {
    internal static IMessage DeserializeMessage(MemoryStream mem, IMethodCallMessage msg);
    internal static MemoryStream SerializeMessage(IMessage msg);
    internal static object DeserializeObjectSafe(Byte[] mem);
    internal static MemoryStream SerializeObject(object obj);
    internal static object DeserializeObject(MemoryStream mem);
}
internal class System.Runtime.Remoting.Channels.ChanelSinkStackEntry : object {
    public IChannelSinkBase Sink;
    public object State;
    public ChanelSinkStackEntry Next;
    public ChanelSinkStackEntry(IChannelSinkBase sink, object state, ChanelSinkStackEntry next);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ChannelDataStore : object {
    private String[] _channelURIs;
    private DictionaryEntry[] _extraData;
    public String[] ChannelUris { get; public set; }
    public object Item { get; public set; }
    public ChannelDataStore(String[] channelURIs);
    [SecurityCriticalAttribute]
public sealed virtual String[] get_ChannelUris();
    public void set_ChannelUris(String[] value);
    [SecurityCriticalAttribute]
public sealed virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public sealed virtual void set_Item(object key, object value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ChannelServices : object {
    private static ArrayList registeredChannels;
    private static ArrayList delayedClientChannels;
    private static CrossContextChannel _crossContextSink;
    internal static string CrossContextUrl;
    private static IList oldStartModeTypes;
    internal static CrossContextChannel CrossContextChannel { get; }
    public static IChannel[] RegisteredChannels { get; }
    private static ChannelServices();
    internal static CrossContextChannel get_CrossContextChannel();
    internal static IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, String& objectUri);
    internal static IMessageSink CreateClientChannelSinkChain(IChannelSender sender, string url, Object[] channelDataArray, String& objectUri);
    public static IChannel[] get_RegisteredChannels();
    public static IServerChannelSink CreateServerChannelSinkChain(IServerChannelSinkProvider provider, IChannelReceiver channel);
    public static ServerProcessing DispatchMessage(IServerChannelSinkStack sinkStack, IMessage msg, IMessage& replyMsg);
    public static IChannel GetChannel(string name);
    public static IDictionary GetChannelSinkProperties(object obj);
    public static String[] GetUrlsForObject(MarshalByRefObject obj);
    [ObsoleteAttribute("Use RegisterChannel(IChannel,Boolean)")]
public static void RegisterChannel(IChannel chnl);
    public static void RegisterChannel(IChannel chnl, bool ensureSecurity);
    internal static void RegisterChannelConfig(ChannelData channel);
    private static object CreateProvider(ProviderData prov);
    public static IMessage SyncDispatchMessage(IMessage msg);
    public static IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink);
    private static ReturnMessage CheckIncomingMessage(IMessage msg);
    internal static IMessage CheckReturnMessage(IMessage callMsg, IMessage retMsg);
    private static bool IsLocalCall(IMessage callMsg);
    public static void UnregisterChannel(IChannel chnl);
    internal static Object[] GetCurrentChannelInfo();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ClientChannelSinkStack : object {
    private IMessageSink _replySink;
    private ChanelSinkStackEntry _sinkStack;
    public ClientChannelSinkStack(IMessageSink replySink);
    [SecurityCriticalAttribute]
public sealed virtual void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
    [SecurityCriticalAttribute]
public sealed virtual void DispatchException(Exception e);
    [SecurityCriticalAttribute]
public sealed virtual void DispatchReplyMessage(IMessage msg);
    [SecurityCriticalAttribute]
public sealed virtual object Pop(IClientChannelSink sink);
    [SecurityCriticalAttribute]
public sealed virtual void Push(IClientChannelSink sink, object state);
}
internal class System.Runtime.Remoting.Channels.CrossAppDomainChannel : object {
    private static string _strName;
    private static object s_lock;
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public object ChannelData { get; }
    private static CrossAppDomainChannel();
    internal static void RegisterCrossAppDomainChannel();
    public virtual string get_ChannelName();
    public virtual int get_ChannelPriority();
    public sealed virtual string Parse(string url, String& objectURI);
    public virtual object get_ChannelData();
    public virtual String[] GetUrlsForUri(string objectURI);
    public virtual void StartListening(object data);
    public virtual void StopListening(object data);
    public virtual IMessageSink CreateMessageSink(string url, object data, String& uri);
}
internal class System.Runtime.Remoting.Channels.CrossAppDomainData : object {
    private object _ContextID;
    private int _DomainID;
    private string _processGuid;
    internal int DomainID { get; }
    internal string ProcessID { get; }
    internal CrossAppDomainData(int domainId);
    internal int get_DomainID();
    internal string get_ProcessID();
}
[MonoTODOAttribute("Handle domain unloading?")]
internal class System.Runtime.Remoting.Channels.CrossAppDomainSink : object {
    private static Hashtable s_sinks;
    private static MethodInfo processMessageMethod;
    private int _domainID;
    internal int TargetDomainId { get; }
    public IMessageSink NextSink { get; }
    internal CrossAppDomainSink(int domainID);
    private static CrossAppDomainSink();
    internal static CrossAppDomainSink GetSink(int domainID);
    internal int get_TargetDomainId();
    private static ProcessMessageRes ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg);
    public virtual IMessage SyncProcessMessage(IMessage msgRequest);
    public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
    public void SendAsyncMessage(object data);
    public sealed virtual IMessageSink get_NextSink();
    [CompilerGeneratedAttribute]
private void <AsyncProcessMessage>b__10_0(object data);
}
internal class System.Runtime.Remoting.Channels.ExceptionFilterSink : object {
    private IMessageSink _next;
    private IMessage _call;
    public IMessageSink NextSink { get; }
    public ExceptionFilterSink(IMessage call, IMessageSink next);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannel {
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public abstract virtual string get_ChannelName();
    public abstract virtual int get_ChannelPriority();
    public abstract virtual string Parse(string url, String& objectURI);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelDataStore {
    public String[] ChannelUris { get; }
    public object Item { get; public set; }
    public abstract virtual String[] get_ChannelUris();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelReceiver {
    public object ChannelData { get; }
    public abstract virtual object get_ChannelData();
    public abstract virtual String[] GetUrlsForUri(string objectURI);
    public abstract virtual void StartListening(object data);
    public abstract virtual void StopListening(object data);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelReceiverHook {
    public string ChannelScheme { get; }
    public IServerChannelSink ChannelSinkChain { get; }
    public bool WantsToListen { get; }
    public abstract virtual string get_ChannelScheme();
    public abstract virtual IServerChannelSink get_ChannelSinkChain();
    public abstract virtual bool get_WantsToListen();
    public abstract virtual void AddHookChannelUri(string channelUri);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelSender {
    public abstract virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IChannelSinkBase {
    public IDictionary Properties { get; }
    public abstract virtual IDictionary get_Properties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSink {
    public IClientChannelSink NextChannelSink { get; }
    public abstract virtual IClientChannelSink get_NextChannelSink();
    public abstract virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
    public abstract virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public abstract virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public abstract virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSinkProvider {
    public IClientChannelSinkProvider Next { get; public set; }
    public abstract virtual IClientChannelSinkProvider get_Next();
    public abstract virtual void set_Next(IClientChannelSinkProvider value);
    public abstract virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientChannelSinkStack {
    public abstract virtual object Pop(IClientChannelSink sink);
    public abstract virtual void Push(IClientChannelSink sink, object state);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientFormatterSink {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientFormatterSinkProvider {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack {
    public abstract virtual void AsyncProcessResponse(ITransportHeaders headers, Stream stream);
    public abstract virtual void DispatchException(Exception e);
    public abstract virtual void DispatchReplyMessage(IMessage msg);
}
public interface System.Runtime.Remoting.Channels.ISecurableChannel {
    public bool IsSecured { get; public set; }
    public abstract virtual bool get_IsSecured();
    public abstract virtual void set_IsSecured(bool value);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSink {
    public IServerChannelSink NextChannelSink { get; }
    public abstract virtual IServerChannelSink get_NextChannelSink();
    public abstract virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
    public abstract virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public abstract virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSinkProvider {
    public IServerChannelSinkProvider Next { get; public set; }
    public abstract virtual IServerChannelSinkProvider get_Next();
    public abstract virtual void set_Next(IServerChannelSinkProvider value);
    public abstract virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    public abstract virtual void GetChannelData(IChannelDataStore channelData);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerChannelSinkStack {
    public abstract virtual object Pop(IServerChannelSink sink);
    public abstract virtual void Push(IServerChannelSink sink, object state);
    public abstract virtual void ServerCallback(IAsyncResult ar);
    public abstract virtual void Store(IServerChannelSink sink, object state);
    public abstract virtual void StoreAndDispatch(IServerChannelSink sink, object state);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerFormatterSinkProvider {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack {
    public abstract virtual void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
    public abstract virtual Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public interface System.Runtime.Remoting.Channels.ITransportHeaders {
    public object Item { get; public set; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.ServerChannelSinkStack : object {
    private ChanelSinkStackEntry _sinkStack;
    [SecurityCriticalAttribute]
public sealed virtual Stream GetResponseStream(IMessage msg, ITransportHeaders headers);
    [SecurityCriticalAttribute]
public sealed virtual object Pop(IServerChannelSink sink);
    [SecurityCriticalAttribute]
public sealed virtual void Push(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
[MonoTODOAttribute]
public sealed virtual void ServerCallback(IAsyncResult ar);
    [SecurityCriticalAttribute]
[MonoTODOAttribute]
public sealed virtual void Store(IServerChannelSink sink, object state);
    [MonoTODOAttribute]
[SecurityCriticalAttribute]
public sealed virtual void StoreAndDispatch(IServerChannelSink sink, object state);
    [SecurityCriticalAttribute]
public sealed virtual void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream);
}
internal class System.Runtime.Remoting.Channels.ServerDispatchSink : object {
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    public sealed virtual IServerChannelSink get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
}
internal class System.Runtime.Remoting.Channels.ServerDispatchSinkProvider : object {
    public IServerChannelSinkProvider Next { get; public set; }
    public ServerDispatchSinkProvider(IDictionary properties, ICollection providerData);
    public sealed virtual IServerChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IServerChannelSinkProvider value);
    public sealed virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    public sealed virtual void GetChannelData(IChannelDataStore channelData);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Channels.ServerProcessing : Enum {
    public int value__;
    public static ServerProcessing Complete;
    public static ServerProcessing OneWay;
    public static ServerProcessing Async;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.SinkProviderData : object {
    private string sinkName;
    private ArrayList children;
    private Hashtable properties;
    public IList Children { get; }
    public string Name { get; }
    public IDictionary Properties { get; }
    public SinkProviderData(string name);
    public IList get_Children();
    public string get_Name();
    public IDictionary get_Properties();
}
[DefaultMemberAttribute("Item")]
[MonoTODOAttribute("Serialization format not compatible with .NET")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Channels.TransportHeaders : object {
    private Hashtable hash_table;
    public object Item { get; public set; }
    [SecurityCriticalAttribute]
public sealed virtual object get_Item(object key);
    [SecurityCriticalAttribute]
public sealed virtual void set_Item(object key, object value);
    [SecurityCriticalAttribute]
public sealed virtual IEnumerator GetEnumerator();
}
internal class System.Runtime.Remoting.ClientActivatedIdentity : ServerIdentity {
    private MarshalByRefObject _targetThis;
    public ClientActivatedIdentity(string objectUri, Type objectType);
    public MarshalByRefObject GetServerObject();
    public MarshalByRefObject GetClientProxy();
    public void SetClientProxy(MarshalByRefObject obj);
    public virtual void OnLifetimeExpired();
    public virtual IMessage SyncObjectProcessMessage(IMessage msg);
    public virtual IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);
}
internal class System.Runtime.Remoting.ClientIdentity : Identity {
    private WeakReference _proxyReference;
    public MarshalByRefObject ClientProxy { get; public set; }
    public string TargetUri { get; }
    public ClientIdentity(string objectUri, ObjRef objRef);
    public MarshalByRefObject get_ClientProxy();
    public void set_ClientProxy(MarshalByRefObject value);
    public virtual ObjRef CreateObjRef(Type requestedType);
    public string get_TargetUri();
}
internal class System.Runtime.Remoting.ConfigHandler : object {
    private ArrayList typeEntries;
    private ArrayList channelInstances;
    private ChannelData currentChannel;
    private Stack currentProviderData;
    private string currentClientUrl;
    private string appName;
    private string currentXmlPath;
    private bool onlyDelayedChannels;
    public ConfigHandler(bool onlyDelayedChannels);
    private void ValidatePath(string element, String[] paths);
    private bool CheckPath(string path);
    public sealed virtual void OnStartParsing(SmallXmlParser parser);
    public sealed virtual void OnProcessingInstruction(string name, string text);
    public sealed virtual void OnIgnorableWhitespace(string s);
    public sealed virtual void OnStartElement(string name, IAttrList attrs);
    public void ParseElement(string name, IAttrList attrs);
    public sealed virtual void OnEndElement(string name);
    private void ReadCustomProviderData(string name, IAttrList attrs);
    private void ReadLifetine(IAttrList attrs);
    private TimeSpan ParseTime(string s);
    private void ReadChannel(IAttrList attrs, bool isTemplate);
    private ProviderData ReadProvider(string name, IAttrList attrs, bool isTemplate);
    private void ReadClientActivated(IAttrList attrs);
    private void ReadServiceActivated(IAttrList attrs);
    private void ReadClientWellKnown(IAttrList attrs);
    private void ReadServiceWellKnown(IAttrList attrs);
    private void ReadInteropXml(IAttrList attrs, bool isElement);
    private void ReadPreload(IAttrList attrs);
    private string GetNotNull(IAttrList attrs, string name);
    private string ExtractAssembly(String& type);
    public sealed virtual void OnChars(string ch);
    public sealed virtual void OnEndParsing(SmallXmlParser parser);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.Context : object {
    private int domain_id;
    private int context_id;
    private UIntPtr static_data;
    private UIntPtr data;
    [ContextStaticAttribute]
private static Object[] local_slots;
    private static IMessageSink default_server_context_sink;
    private IMessageSink server_context_sink_chain;
    private IMessageSink client_context_sink_chain;
    private List`1<IContextProperty> context_properties;
    private static int global_count;
    private LocalDataStoreHolder modreq(System.Runtime.CompilerServices.IsVolatile) _localDataStore;
    private static LocalDataStoreMgr _localDataStoreMgr;
    private static DynamicPropertyCollection global_dynamic_properties;
    private DynamicPropertyCollection context_dynamic_properties;
    private ContextCallbackObject callback_object;
    public static Context DefaultContext { get; }
    public int ContextID { get; }
    public IContextProperty[] ContextProperties { get; }
    internal bool IsDefaultContext { get; }
    internal bool NeedsContextSink { get; }
    internal static bool HasGlobalDynamicSinks { get; }
    internal bool HasDynamicSinks { get; }
    internal bool HasExitSinks { get; }
    private LocalDataStore MyLocalStore { get; }
    private static Context();
    private static void RegisterContext(Context ctx);
    private static void ReleaseContext(Context ctx);
    protected virtual override void Finalize();
    public static Context get_DefaultContext();
    public virtual int get_ContextID();
    public virtual IContextProperty[] get_ContextProperties();
    internal bool get_IsDefaultContext();
    internal bool get_NeedsContextSink();
    public static bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx);
    public static bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx);
    private static DynamicPropertyCollection GetDynamicPropertyCollection(ContextBoundObject obj, Context ctx);
    internal static void NotifyGlobalDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
    internal static bool get_HasGlobalDynamicSinks();
    internal void NotifyDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
    internal bool get_HasDynamicSinks();
    internal bool get_HasExitSinks();
    public virtual IContextProperty GetProperty(string name);
    public virtual void SetProperty(IContextProperty prop);
    public virtual void Freeze();
    public virtual string ToString();
    internal IMessageSink GetServerContextSinkChain();
    internal IMessageSink GetClientContextSinkChain();
    internal IMessageSink CreateServerObjectSinkChain(MarshalByRefObject obj, bool forceInternalExecute);
    internal IMessageSink CreateEnvoySink(MarshalByRefObject serverObject);
    internal static Context SwitchToContext(Context newContext);
    internal static Context CreateNewContext(IConstructionCallMessage msg);
    public void DoCallBack(CrossContextDelegate deleg);
    private LocalDataStore get_MyLocalStore();
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static void FreeNamedDataSlot(string name);
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public static object GetData(LocalDataStoreSlot slot);
    public static void SetData(LocalDataStoreSlot slot, object data);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.Runtime.Remoting.Contexts.ContextAttribute : Attribute {
    protected string AttributeName;
    public string Name { get; }
    public ContextAttribute(string name);
    [SecurityCriticalAttribute]
public virtual string get_Name();
    public virtual bool Equals(object o);
    [SecurityCriticalAttribute]
public virtual void Freeze(Context newContext);
    public virtual int GetHashCode();
    [SecurityCriticalAttribute]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual bool IsNewContextOK(Context newCtx);
}
internal class System.Runtime.Remoting.Contexts.ContextCallbackObject : ContextBoundObject {
    public void DoCallBack(CrossContextDelegate deleg);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.ContextProperty : object {
    private string name;
    private object prop;
    public string Name { get; }
    public object Property { get; }
    private ContextProperty(string name, object prop);
    public virtual string get_Name();
    public virtual object get_Property();
}
internal class System.Runtime.Remoting.Contexts.CrossContextChannel : object {
    public IMessageSink NextSink { get; }
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.CrossContextDelegate : MulticastDelegate {
    public CrossContextDelegate(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Remoting.Contexts.DynamicPropertyCollection : object {
    private ArrayList _properties;
    public bool HasProperties { get; }
    public bool get_HasProperties();
    public bool RegisterDynamicProperty(IDynamicProperty prop);
    public bool UnregisterDynamicProperty(string name);
    public void NotifyMessage(bool start, IMessage msg, bool client_site, bool async);
    private int FindProperty(string name);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextAttribute {
    public abstract virtual void GetPropertiesForNewContext(IConstructionCallMessage msg);
    public abstract virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextProperty {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Freeze(Context newContext);
    public abstract virtual bool IsNewContextOK(Context newCtx);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContextPropertyActivator {
    public abstract virtual void CollectFromClientContext(IConstructionCallMessage msg);
    public abstract virtual void CollectFromServerContext(IConstructionReturnMessage msg);
    public abstract virtual bool DeliverClientContextToServerContext(IConstructionCallMessage msg);
    public abstract virtual bool DeliverServerContextToClientContext(IConstructionReturnMessage msg);
    public abstract virtual bool IsOKToActivate(IConstructionCallMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeClientContextSink {
    public abstract virtual IMessageSink GetClientContextSink(IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeDynamicSink {
    public abstract virtual IDynamicMessageSink GetDynamicSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeEnvoySink {
    public abstract virtual IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeObjectSink {
    public abstract virtual IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IContributeServerContextSink {
    public abstract virtual IMessageSink GetServerContextSink(IMessageSink nextSink);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IDynamicMessageSink {
    public abstract virtual void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync);
    public abstract virtual void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Contexts.IDynamicProperty {
    public string Name { get; }
    public abstract virtual string get_Name();
}
[AttributeUsageAttribute("4")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Contexts.SynchronizationAttribute : ContextAttribute {
    public static int NOT_SUPPORTED;
    public static int SUPPORTED;
    public static int REQUIRED;
    public static int REQUIRES_NEW;
    private bool _bReEntrant;
    private int _flavor;
    private int _lockCount;
    private Mutex _mutex;
    private Thread _ownerThread;
    public bool IsReEntrant { get; }
    public bool Locked { get; public set; }
    public SynchronizationAttribute(bool reEntrant);
    public SynchronizationAttribute(int flag);
    public SynchronizationAttribute(int flag, bool reEntrant);
    public virtual bool get_IsReEntrant();
    public virtual bool get_Locked();
    public virtual void set_Locked(bool value);
    internal void AcquireLock();
    internal void ReleaseLock();
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg);
    [SecurityCriticalAttribute]
public virtual IMessageSink GetClientContextSink(IMessageSink nextSink);
    [SecurityCriticalAttribute]
public virtual IMessageSink GetServerContextSink(IMessageSink nextSink);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
    internal static void ExitContext();
    internal static void EnterContext();
}
internal class System.Runtime.Remoting.Contexts.SynchronizedClientContextSink : object {
    private IMessageSink _next;
    private SynchronizationAttribute _att;
    public IMessageSink NextSink { get; }
    public SynchronizedClientContextSink(IMessageSink next, SynchronizationAttribute att);
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
}
internal class System.Runtime.Remoting.Contexts.SynchronizedContextReplySink : object {
    private IMessageSink _next;
    private bool _newLock;
    private SynchronizationAttribute _att;
    public IMessageSink NextSink { get; }
    public SynchronizedContextReplySink(IMessageSink next, SynchronizationAttribute att, bool newLock);
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
}
internal class System.Runtime.Remoting.Contexts.SynchronizedServerContextSink : object {
    private IMessageSink _next;
    private SynchronizationAttribute _att;
    public IMessageSink NextSink { get; }
    public SynchronizedServerContextSink(IMessageSink next, SynchronizationAttribute att);
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.CustomErrorsModes : Enum {
    public int value__;
    public static CustomErrorsModes On;
    public static CustomErrorsModes Off;
    public static CustomErrorsModes RemoteOnly;
}
internal class System.Runtime.Remoting.DisposerReplySink : object {
    private IMessageSink _next;
    private IDisposable _disposable;
    public IMessageSink NextSink { get; }
    public DisposerReplySink(IMessageSink next, IDisposable disposable);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.EnvoyInfo : object {
    private IMessageSink envoySinks;
    public IMessageSink EnvoySinks { get; public set; }
    public EnvoyInfo(IMessageSink sinks);
    public sealed virtual IMessageSink get_EnvoySinks();
    public sealed virtual void set_EnvoySinks(IMessageSink value);
}
internal class System.Runtime.Remoting.FormatterData : ProviderData {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IChannelInfo {
    public Object[] ChannelData { get; public set; }
    public abstract virtual Object[] get_ChannelData();
    public abstract virtual void set_ChannelData(Object[] value);
}
internal abstract class System.Runtime.Remoting.Identity : object {
    protected string _objectUri;
    protected IMessageSink _channelSink;
    protected IMessageSink _envoySink;
    private DynamicPropertyCollection _clientDynamicProperties;
    private DynamicPropertyCollection _serverDynamicProperties;
    protected ObjRef _objRef;
    private bool _disposed;
    public bool IsFromThisAppDomain { get; }
    public IMessageSink ChannelSink { get; public set; }
    public IMessageSink EnvoySink { get; }
    public string ObjectUri { get; public set; }
    public bool IsConnected { get; }
    public bool Disposed { get; public set; }
    public DynamicPropertyCollection ClientDynamicProperties { get; }
    public DynamicPropertyCollection ServerDynamicProperties { get; }
    public bool HasClientDynamicSinks { get; }
    public bool HasServerDynamicSinks { get; }
    public Identity(string objectUri);
    public abstract virtual ObjRef CreateObjRef(Type requestedType);
    public bool get_IsFromThisAppDomain();
    public IMessageSink get_ChannelSink();
    public void set_ChannelSink(IMessageSink value);
    public IMessageSink get_EnvoySink();
    public string get_ObjectUri();
    public void set_ObjectUri(string value);
    public bool get_IsConnected();
    public bool get_Disposed();
    public void set_Disposed(bool value);
    public DynamicPropertyCollection get_ClientDynamicProperties();
    public DynamicPropertyCollection get_ServerDynamicProperties();
    public bool get_HasClientDynamicSinks();
    public bool get_HasServerDynamicSinks();
    public void NotifyClientDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
    public void NotifyServerDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IEnvoyInfo {
    public IMessageSink EnvoySinks { get; public set; }
    public abstract virtual IMessageSink get_EnvoySinks();
    public abstract virtual void set_EnvoySinks(IMessageSink value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.InternalRemotingServices : object {
    private static Hashtable _soapAttributes;
    private static InternalRemotingServices();
    [ConditionalAttribute("_LOGGING")]
public static void DebugOutChnl(string s);
    public static SoapAttribute GetCachedSoapAttribute(object reflectionObject);
    [ConditionalAttribute("_DEBUG")]
public static void RemotingAssert(bool condition, string message);
    [ConditionalAttribute("_LOGGING")]
public static void RemotingTrace(Object[] messages);
    [CLSCompliantAttribute("False")]
public static void SetServerIdentity(MethodCall m, object srvID);
}
[GuidAttribute("C460E2B4-E199-412a-8456-84DC3E4838C3")]
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IObjectHandle {
    public abstract virtual object Unwrap();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.IRemotingTypeInfo {
    public string TypeName { get; public set; }
    public abstract virtual string get_TypeName();
    public abstract virtual void set_TypeName(string value);
    public abstract virtual bool CanCastTo(Type fromType, object o);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Lifetime.ClientSponsor : MarshalByRefObject {
    private TimeSpan renewal_time;
    private Hashtable registered_objects;
    public TimeSpan RenewalTime { get; public set; }
    public ClientSponsor(TimeSpan renewalTime);
    public TimeSpan get_RenewalTime();
    public void set_RenewalTime(TimeSpan value);
    public void Close();
    protected virtual override void Finalize();
    public virtual object InitializeLifetimeService();
    public bool Register(MarshalByRefObject obj);
    [SecurityCriticalAttribute]
public sealed virtual TimeSpan Renewal(ILease lease);
    public void Unregister(MarshalByRefObject obj);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Lifetime.ILease {
    public TimeSpan CurrentLeaseTime { get; }
    public LeaseState CurrentState { get; }
    public TimeSpan InitialLeaseTime { get; public set; }
    public TimeSpan RenewOnCallTime { get; public set; }
    public TimeSpan SponsorshipTimeout { get; public set; }
    public abstract virtual TimeSpan get_CurrentLeaseTime();
    public abstract virtual LeaseState get_CurrentState();
    public abstract virtual TimeSpan get_InitialLeaseTime();
    public abstract virtual void set_InitialLeaseTime(TimeSpan value);
    public abstract virtual TimeSpan get_RenewOnCallTime();
    public abstract virtual void set_RenewOnCallTime(TimeSpan value);
    public abstract virtual TimeSpan get_SponsorshipTimeout();
    public abstract virtual void set_SponsorshipTimeout(TimeSpan value);
    public abstract virtual void Register(ISponsor obj);
    public abstract virtual void Register(ISponsor obj, TimeSpan renewalTime);
    public abstract virtual TimeSpan Renew(TimeSpan renewalTime);
    public abstract virtual void Unregister(ISponsor obj);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Lifetime.ISponsor {
    public abstract virtual TimeSpan Renewal(ILease lease);
}
internal class System.Runtime.Remoting.Lifetime.Lease : MarshalByRefObject {
    private DateTime _leaseExpireTime;
    private LeaseState _currentState;
    private TimeSpan _initialLeaseTime;
    private TimeSpan _renewOnCallTime;
    private TimeSpan _sponsorshipTimeout;
    private ArrayList _sponsors;
    private Queue _renewingSponsors;
    private RenewalDelegate _renewalDelegate;
    public TimeSpan CurrentLeaseTime { get; }
    public LeaseState CurrentState { get; }
    public TimeSpan InitialLeaseTime { get; public set; }
    public TimeSpan RenewOnCallTime { get; public set; }
    public TimeSpan SponsorshipTimeout { get; public set; }
    public sealed virtual TimeSpan get_CurrentLeaseTime();
    public sealed virtual LeaseState get_CurrentState();
    public void Activate();
    public sealed virtual TimeSpan get_InitialLeaseTime();
    public sealed virtual void set_InitialLeaseTime(TimeSpan value);
    public sealed virtual TimeSpan get_RenewOnCallTime();
    public sealed virtual void set_RenewOnCallTime(TimeSpan value);
    public sealed virtual TimeSpan get_SponsorshipTimeout();
    public sealed virtual void set_SponsorshipTimeout(TimeSpan value);
    public sealed virtual void Register(ISponsor obj);
    public sealed virtual void Register(ISponsor obj, TimeSpan renewalTime);
    public sealed virtual TimeSpan Renew(TimeSpan renewalTime);
    public sealed virtual void Unregister(ISponsor obj);
    internal void UpdateState();
    private void CheckNextSponsor();
    private void ProcessSponsorResponse(object state, bool timedOut);
}
internal class System.Runtime.Remoting.Lifetime.LeaseManager : object {
    private ArrayList _objects;
    private Timer _timer;
    public void SetPollTime(TimeSpan timeSpan);
    public void TrackLifetime(ServerIdentity identity);
    public void StopTrackingLifetime(ServerIdentity identity);
    public void StartManager();
    public void StopManager();
    public void ManageLeases(object state);
}
internal class System.Runtime.Remoting.Lifetime.LeaseSink : object {
    private IMessageSink _nextSink;
    public IMessageSink NextSink { get; }
    public LeaseSink(IMessageSink nextSink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    private void RenewLease(IMessage msg);
    public sealed virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Lifetime.LeaseState : Enum {
    public int value__;
    public static LeaseState Null;
    public static LeaseState Initial;
    public static LeaseState Active;
    public static LeaseState Renewing;
    public static LeaseState Expired;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Lifetime.LifetimeServices : object {
    private static TimeSpan _leaseManagerPollTime;
    private static TimeSpan _leaseTime;
    private static TimeSpan _renewOnCallTime;
    private static TimeSpan _sponsorshipTimeout;
    private static LeaseManager _leaseManager;
    public static TimeSpan LeaseManagerPollTime { get; public set; }
    public static TimeSpan LeaseTime { get; public set; }
    public static TimeSpan RenewOnCallTime { get; public set; }
    public static TimeSpan SponsorshipTimeout { get; public set; }
    private static LifetimeServices();
    public static TimeSpan get_LeaseManagerPollTime();
    public static void set_LeaseManagerPollTime(TimeSpan value);
    public static TimeSpan get_LeaseTime();
    public static void set_LeaseTime(TimeSpan value);
    public static TimeSpan get_RenewOnCallTime();
    public static void set_RenewOnCallTime(TimeSpan value);
    public static TimeSpan get_SponsorshipTimeout();
    public static void set_SponsorshipTimeout(TimeSpan value);
    internal static void TrackLifetime(ServerIdentity identity);
    internal static void StopTrackingLifetime(ServerIdentity identity);
}
internal class System.Runtime.Remoting.Messaging.ArgInfo : object {
    private Int32[] _paramMap;
    private int _inoutArgCount;
    private MethodBase _method;
    public ArgInfo(MethodBase method, ArgInfoType type);
    public int GetInOutArgIndex(int inoutArgNum);
    public virtual string GetInOutArgName(int index);
    public int GetInOutArgCount();
    public Object[] GetInOutArgs(Object[] args);
}
internal enum System.Runtime.Remoting.Messaging.ArgInfoType : Enum {
    public byte value__;
    public static ArgInfoType In;
    public static ArgInfoType Out;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.AsyncResult : object {
    private object async_state;
    private WaitHandle handle;
    private object async_delegate;
    private IntPtr data;
    private object object_data;
    private bool sync_completed;
    private bool completed;
    private bool endinvoke_called;
    private object async_callback;
    private ExecutionContext current;
    private ExecutionContext original;
    private long add_time;
    private MonoMethodMessage call_message;
    private IMessageCtrl message_ctrl;
    private IMessage reply_message;
    private WaitCallback orig_cb;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public bool EndInvokeCalled { get; public set; }
    public object AsyncDelegate { get; }
    public IMessageSink NextSink { get; }
    internal MonoMethodMessage CallMessage { get; internal set; }
    public virtual object get_AsyncState();
    public virtual WaitHandle get_AsyncWaitHandle();
    public virtual bool get_CompletedSynchronously();
    public virtual bool get_IsCompleted();
    public bool get_EndInvokeCalled();
    public void set_EndInvokeCalled(bool value);
    public virtual object get_AsyncDelegate();
    [SecurityCriticalAttribute]
public sealed virtual IMessageSink get_NextSink();
    [SecurityCriticalAttribute]
public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public virtual IMessage GetReplyMessage();
    public virtual void SetMessageCtrl(IMessageCtrl mc);
    internal void SetCompletedSynchronously(bool completed);
    internal IMessage EndInvoke();
    [SecurityCriticalAttribute]
public virtual IMessage SyncProcessMessage(IMessage msg);
    internal MonoMethodMessage get_CallMessage();
    internal void set_CallMessage(MonoMethodMessage value);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    internal object Invoke();
}
internal class System.Runtime.Remoting.Messaging.CADArgHolder : object {
    public int index;
    public CADArgHolder(int i);
}
internal class System.Runtime.Remoting.Messaging.CADMessageBase : object {
    protected Object[] _args;
    protected Byte[] _serializedArgs;
    protected int _propertyCount;
    protected CADArgHolder _callContext;
    internal Byte[] serializedMethod;
    public CADMessageBase(IMethodMessage msg);
    internal MethodBase GetMethod();
    protected static Type[] GetSignature(MethodBase methodBase, bool load);
    internal static int MarshalProperties(IDictionary dict, ArrayList& args);
    internal static void UnmarshalProperties(IDictionary dict, int count, ArrayList args);
    private static bool IsPossibleToIgnoreMarshal(object obj);
    protected object MarshalArgument(object arg, ArrayList& args);
    protected object UnmarshalArgument(object arg, ArrayList args);
    internal Object[] MarshalArguments(Object[] arguments, ArrayList& args);
    internal Object[] UnmarshalArguments(Object[] arguments, ArrayList args);
    protected void SaveLogicalCallContext(IMethodMessage msg, ArrayList& serializeList);
    internal LogicalCallContext GetLogicalCallContext(ArrayList args);
}
internal class System.Runtime.Remoting.Messaging.CADMethodCallMessage : CADMessageBase {
    private string _uri;
    internal string Uri { get; }
    internal int PropertiesCount { get; }
    internal CADMethodCallMessage(IMethodCallMessage callMsg);
    internal string get_Uri();
    internal static CADMethodCallMessage Create(IMessage callMsg);
    internal ArrayList GetArguments();
    internal Object[] GetArgs(ArrayList args);
    internal int get_PropertiesCount();
}
internal class System.Runtime.Remoting.Messaging.CADMethodRef : object {
    private bool ctor;
    private string typeName;
    private string methodName;
    private String[] param_names;
    private String[] generic_arg_names;
    public CADMethodRef(IMethodMessage msg);
    private Type[] GetTypes(String[] typeArray);
    public MethodBase Resolve();
}
internal class System.Runtime.Remoting.Messaging.CADMethodReturnMessage : CADMessageBase {
    private object _returnValue;
    private CADArgHolder _exception;
    private Type[] _sig;
    internal int PropertiesCount { get; }
    internal CADMethodReturnMessage(IMethodReturnMessage retMsg);
    internal static CADMethodReturnMessage Create(IMessage callMsg);
    internal ArrayList GetArguments();
    internal Object[] GetArgs(ArrayList args);
    internal object GetReturnValue(ArrayList args);
    internal Exception GetException(ArrayList args);
    internal int get_PropertiesCount();
}
internal class System.Runtime.Remoting.Messaging.CADObjRef : object {
    internal ObjRef objref;
    internal int SourceDomain;
    internal Byte[] TypeInfo;
    public string TypeName { get; }
    public string URI { get; }
    public CADObjRef(ObjRef o, int sourceDomain);
    public string get_TypeName();
    public string get_URI();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.CallContext : object {
    internal static IPrincipal Principal { get; internal set; }
    public static object HostContext { get; public set; }
    internal static object SetCurrentCallContext(LogicalCallContext ctx);
    internal static LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx);
    [SecurityCriticalAttribute]
public static void FreeNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public static object LogicalGetData(string name);
    private static object IllogicalGetData(string name);
    [SecurityCriticalAttribute]
internal static IPrincipal get_Principal();
    [SecurityCriticalAttribute]
internal static void set_Principal(IPrincipal value);
    [SecurityCriticalAttribute]
public static object get_HostContext();
    [SecurityCriticalAttribute]
public static void set_HostContext(object value);
    [SecurityCriticalAttribute]
public static object GetData(string name);
    [SecurityCriticalAttribute]
public static void SetData(string name, object data);
    [SecurityCriticalAttribute]
public static void LogicalSetData(string name, object data);
    [SecurityCriticalAttribute]
public static Header[] GetHeaders();
    [SecurityCriticalAttribute]
public static void SetHeaders(Header[] headers);
}
internal class System.Runtime.Remoting.Messaging.CallContextRemotingData : object {
    private string _logicalCallID;
    internal string LogicalCallID { get; internal set; }
    internal bool HasInfo { get; }
    internal string get_LogicalCallID();
    internal void set_LogicalCallID(string value);
    internal bool get_HasInfo();
    public sealed virtual object Clone();
}
internal class System.Runtime.Remoting.Messaging.CallContextSecurityData : object {
    private IPrincipal _principal;
    internal IPrincipal Principal { get; internal set; }
    internal bool HasInfo { get; }
    internal IPrincipal get_Principal();
    internal void set_Principal(IPrincipal value);
    internal bool get_HasInfo();
    public sealed virtual object Clone();
}
internal enum System.Runtime.Remoting.Messaging.CallType : Enum {
    public int value__;
    public static CallType Sync;
    public static CallType BeginInvoke;
    public static CallType EndInvoke;
    public static CallType OneWay;
}
internal class System.Runtime.Remoting.Messaging.ClientContextReplySink : object {
    private IMessageSink _replySink;
    private Context _context;
    public IMessageSink NextSink { get; }
    public ClientContextReplySink(Context ctx, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ClientContextTerminatorSink : object {
    private Context _context;
    public IMessageSink NextSink { get; }
    public ClientContextTerminatorSink(Context ctx);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.ConstructionCall : MethodCall {
    private IActivator _activator;
    private Object[] _activationAttributes;
    private IList _contextProperties;
    private Type _activationType;
    private string _activationTypeName;
    private bool _isContextOk;
    private RemotingProxy _sourceProxy;
    internal bool IsContextOk { get; internal set; }
    public Type ActivationType { get; }
    public string ActivationTypeName { get; }
    public IActivator Activator { get; public set; }
    public Object[] CallSiteActivationAttributes { get; }
    public IList ContextProperties { get; }
    public IDictionary Properties { get; }
    internal RemotingProxy SourceProxy { get; internal set; }
    public ConstructionCall(IMessage m);
    internal ConstructionCall(Type type);
    public ConstructionCall(Header[] headers);
    internal ConstructionCall(SerializationInfo info, StreamingContext context);
    internal virtual void InitDictionary();
    internal bool get_IsContextOk();
    internal void set_IsContextOk(bool value);
    [SecurityCriticalAttribute]
public sealed virtual Type get_ActivationType();
    [SecurityCriticalAttribute]
public sealed virtual string get_ActivationTypeName();
    [SecurityCriticalAttribute]
public sealed virtual IActivator get_Activator();
    [SecurityCriticalAttribute]
public sealed virtual void set_Activator(IActivator value);
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_CallSiteActivationAttributes();
    internal void SetActivationAttributes(Object[] attributes);
    [SecurityCriticalAttribute]
public sealed virtual IList get_ContextProperties();
    internal virtual void InitMethodProperty(string key, object value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    internal RemotingProxy get_SourceProxy();
    internal void set_SourceProxy(RemotingProxy value);
}
internal class System.Runtime.Remoting.Messaging.ConstructionCallDictionary : MessageDictionary {
    public static String[] InternalKeys;
    public ConstructionCallDictionary(IConstructionCallMessage message);
    private static ConstructionCallDictionary();
    protected virtual object GetMethodProperty(string key);
    protected virtual void SetMethodProperty(string key, object value);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.Runtime.Remoting.Messaging.ConstructionResponse : MethodResponse {
    public IDictionary Properties { get; }
    public ConstructionResponse(Header[] h, IMethodCallMessage mcm);
    internal ConstructionResponse(object resultObject, LogicalCallContext callCtx, IMethodCallMessage msg);
    internal ConstructionResponse(Exception e, IMethodCallMessage msg);
    internal ConstructionResponse(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
}
internal class System.Runtime.Remoting.Messaging.EnvoyTerminatorSink : object {
    public static EnvoyTerminatorSink Instance;
    public IMessageSink NextSink { get; }
    private static EnvoyTerminatorSink();
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ErrorMessage : object {
    private string _uri;
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public IDictionary Properties { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public sealed virtual int get_ArgCount();
    public sealed virtual Object[] get_Args();
    public sealed virtual bool get_HasVarArgs();
    public sealed virtual MethodBase get_MethodBase();
    public sealed virtual string get_MethodName();
    public sealed virtual object get_MethodSignature();
    public virtual IDictionary get_Properties();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Uri();
    public void set_Uri(string value);
    public sealed virtual object GetArg(int arg_num);
    public sealed virtual string GetArgName(int arg_num);
    public sealed virtual int get_InArgCount();
    public sealed virtual string GetInArgName(int index);
    public sealed virtual object GetInArg(int argNum);
    public sealed virtual Object[] get_InArgs();
    public sealed virtual LogicalCallContext get_LogicalCallContext();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.Header : object {
    public string HeaderNamespace;
    public bool MustUnderstand;
    public string Name;
    public object Value;
    public Header(string _Name, object _Value);
    public Header(string _Name, object _Value, bool _MustUnderstand);
    public Header(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.HeaderHandler : MulticastDelegate {
    public HeaderHandler(object object, IntPtr method);
    public virtual object Invoke(Header[] headers);
    public virtual IAsyncResult BeginInvoke(Header[] headers, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal interface System.Runtime.Remoting.Messaging.IInternalMessage {
    public Identity TargetIdentity { get; public set; }
    public string Uri { get; public set; }
    public abstract virtual Identity get_TargetIdentity();
    public abstract virtual void set_TargetIdentity(Identity value);
    public abstract virtual string get_Uri();
    public abstract virtual void set_Uri(string value);
    public abstract virtual bool HasProperties();
}
internal class System.Runtime.Remoting.Messaging.IllogicalCallContext : object {
    private Hashtable m_Datastore;
    private object m_HostContext;
    private Hashtable Datastore { get; }
    internal object HostContext { get; internal set; }
    internal bool HasUserData { get; }
    private Hashtable get_Datastore();
    internal object get_HostContext();
    internal void set_HostContext(object value);
    internal bool get_HasUserData();
    public void FreeNamedDataSlot(string name);
    public object GetData(string name);
    public void SetData(string name, object data);
    public IllogicalCallContext CreateCopy();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.ILogicalThreadAffinative {
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessage {
    public IDictionary Properties { get; }
    public abstract virtual IDictionary get_Properties();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessageCtrl {
    public abstract virtual void Cancel(int msToCancel);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMessageSink {
    public IMessageSink NextSink { get; }
    public abstract virtual IMessage SyncProcessMessage(IMessage msg);
    public abstract virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public abstract virtual IMessageSink get_NextSink();
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodCallMessage {
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public abstract virtual int get_InArgCount();
    public abstract virtual Object[] get_InArgs();
    public abstract virtual object GetInArg(int argNum);
    public abstract virtual string GetInArgName(int index);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodMessage {
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public string TypeName { get; }
    public string Uri { get; }
    public abstract virtual int get_ArgCount();
    public abstract virtual Object[] get_Args();
    public abstract virtual bool get_HasVarArgs();
    public abstract virtual LogicalCallContext get_LogicalCallContext();
    public abstract virtual MethodBase get_MethodBase();
    public abstract virtual string get_MethodName();
    public abstract virtual object get_MethodSignature();
    public abstract virtual string get_TypeName();
    public abstract virtual string get_Uri();
    public abstract virtual object GetArg(int argNum);
    public abstract virtual string GetArgName(int index);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IMethodReturnMessage {
    public Exception Exception { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public object ReturnValue { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual int get_OutArgCount();
    public abstract virtual Object[] get_OutArgs();
    public abstract virtual object get_ReturnValue();
    public abstract virtual object GetOutArg(int argNum);
    public abstract virtual string GetOutArgName(int index);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.InternalMessageWrapper : object {
    protected IMessage WrappedMessage;
    public InternalMessageWrapper(IMessage msg);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Messaging.IRemotingFormatter {
    public abstract virtual object Deserialize(Stream serializationStream, HeaderHandler handler);
    public abstract virtual void Serialize(Stream serializationStream, object graph, Header[] headers);
}
internal interface System.Runtime.Remoting.Messaging.ISerializationRootObject {
    public abstract virtual void RootSetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Remoting.Messaging.LogicalCallContext : object {
    private static Type s_callContextType;
    private static string s_CorrelationMgrSlotName;
    private Hashtable m_Datastore;
    private CallContextRemotingData m_RemotingData;
    private CallContextSecurityData m_SecurityData;
    private object m_HostContext;
    private bool m_IsCorrelationMgr;
    private Header[] _sendHeaders;
    private Header[] _recvHeaders;
    public bool HasInfo { get; }
    private bool HasUserData { get; }
    internal CallContextRemotingData RemotingData { get; }
    internal CallContextSecurityData SecurityData { get; }
    internal object HostContext { get; internal set; }
    private Hashtable Datastore { get; }
    internal IPrincipal Principal { get; internal set; }
    [SecurityCriticalAttribute]
internal LogicalCallContext(SerializationInfo info, StreamingContext context);
    private static LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public sealed virtual object Clone();
    [SecurityCriticalAttribute]
internal void Merge(LogicalCallContext lc);
    [SecurityCriticalAttribute]
public bool get_HasInfo();
    private bool get_HasUserData();
    internal CallContextRemotingData get_RemotingData();
    internal CallContextSecurityData get_SecurityData();
    internal object get_HostContext();
    internal void set_HostContext(object value);
    private Hashtable get_Datastore();
    internal IPrincipal get_Principal();
    [SecurityCriticalAttribute]
internal void set_Principal(IPrincipal value);
    [SecurityCriticalAttribute]
public void FreeNamedDataSlot(string name);
    [SecurityCriticalAttribute]
public object GetData(string name);
    [SecurityCriticalAttribute]
public void SetData(string name, object data);
    private Header[] InternalGetOutgoingHeaders();
    internal void InternalSetHeaders(Header[] headers);
    internal Header[] InternalGetHeaders();
    [SecurityCriticalAttribute]
internal IPrincipal RemovePrincipalIfNotSerializable();
    [SecurityCriticalAttribute]
internal void PropagateOutgoingHeadersToMessage(IMessage msg);
    internal static string GetPropertyKeyForHeader(Header header);
    [SecurityCriticalAttribute]
internal void PropagateIncomingHeadersToCallContext(IMessage msg);
}
internal class System.Runtime.Remoting.Messaging.MCMDictionary : MessageDictionary {
    public static String[] InternalKeys;
    public MCMDictionary(IMethodMessage message);
    private static MCMDictionary();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Remoting.Messaging.MessageDictionary : object {
    private IDictionary _internalProperties;
    protected IMethodMessage _message;
    private String[] _methodKeys;
    private bool _ownProperties;
    internal IDictionary InternalDictionary { get; }
    public String[] MethodKeys { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public MessageDictionary(IMethodMessage message);
    public MessageDictionary(String[] keys);
    internal bool HasUserData();
    internal IDictionary get_InternalDictionary();
    public String[] get_MethodKeys();
    public void set_MethodKeys(String[] value);
    protected virtual IDictionary AllocInternalProperties();
    public IDictionary GetInternalProperties();
    private bool IsOverridenKey(string key);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    protected virtual object GetMethodProperty(string key);
    protected virtual void SetMethodProperty(string key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Remove(object key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MessageSurrogateFilter : MulticastDelegate {
    public MessageSurrogateFilter(object object, IntPtr method);
    public virtual bool Invoke(string key, object value);
    public virtual IAsyncResult BeginInvoke(string key, object value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.Runtime.Remoting.Messaging.MethodCall : object {
    private string _uri;
    private string _typeName;
    private string _methodName;
    private Object[] _args;
    private Type[] _methodSignature;
    private MethodBase _methodBase;
    private LogicalCallContext _callContext;
    private ArgInfo _inArgInfo;
    private Identity _targetIdentity;
    private Type[] _genericArguments;
    protected IDictionary ExternalProperties;
    protected IDictionary InternalProperties;
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public IDictionary Properties { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; private set; }
    private Type[] GenericArguments { get; }
    public MethodCall(Header[] h1);
    internal MethodCall(SerializationInfo info, StreamingContext context);
    internal MethodCall(CADMethodCallMessage msg);
    public MethodCall(IMessage msg);
    internal MethodCall(string uri, string typeName, string methodName, Object[] args);
    internal MethodCall(object handlerObject, BinaryMethodCallMessage smuggledMsg);
    internal void CopyFrom(IMethodMessage call);
    internal virtual void InitMethodProperty(string key, object value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    internal virtual void InitDictionary();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    private sealed virtual override string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetInArgName(int index);
    [MonoTODOAttribute]
public virtual object HeaderHandler(Header[] h);
    public virtual void Init();
    public void ResolveMethod();
    private Type CastTo(string clientType, Type serverType);
    private static string GetTypeNameFromAssemblyQualifiedName(string aqname);
    [MonoTODOAttribute]
public sealed virtual void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
    private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
    private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    private Type[] get_GenericArguments();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MethodCallMessageWrapper : InternalMessageWrapper {
    private Object[] _args;
    private ArgInfo _inArgInfo;
    private DictionaryWrapper _properties;
    public int ArgCount { get; }
    public Object[] Args { get; public set; }
    public bool HasVarArgs { get; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public IDictionary Properties { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    public MethodCallMessageWrapper(IMethodCallMessage msg);
    [SecurityCriticalAttribute]
public virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public virtual Object[] get_Args();
    public virtual void set_Args(Object[] value);
    [SecurityCriticalAttribute]
public virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public virtual int get_InArgCount();
    [SecurityCriticalAttribute]
public virtual Object[] get_InArgs();
    [SecurityCriticalAttribute]
public virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public virtual string get_MethodName();
    [SecurityCriticalAttribute]
public virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public virtual string get_TypeName();
    [SecurityCriticalAttribute]
public virtual string get_Uri();
    public virtual void set_Uri(string value);
    [SecurityCriticalAttribute]
public virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public virtual object GetInArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetInArgName(int index);
}
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.Runtime.Remoting.Messaging.MethodResponse : object {
    private string _methodName;
    private string _uri;
    private string _typeName;
    private MethodBase _methodBase;
    private object _returnValue;
    private Exception _exception;
    private Type[] _methodSignature;
    private ArgInfo _inArgInfo;
    private Object[] _args;
    private Object[] _outArgs;
    private IMethodCallMessage _callMsg;
    private LogicalCallContext _callContext;
    private Identity _targetIdentity;
    protected IDictionary ExternalProperties;
    protected IDictionary InternalProperties;
    public int ArgCount { get; }
    public Object[] Args { get; }
    public Exception Exception { get; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public IDictionary Properties { get; }
    public object ReturnValue { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; private set; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; private set; }
    public MethodResponse(Header[] h1, IMethodCallMessage mcm);
    internal MethodResponse(Exception e, IMethodCallMessage msg);
    internal MethodResponse(object returnValue, Object[] outArgs, LogicalCallContext callCtx, IMethodCallMessage msg);
    internal MethodResponse(IMethodCallMessage msg, CADMethodReturnMessage retmsg);
    internal MethodResponse(IMethodCallMessage msg, object handlerObject, BinaryMethodReturnMessage smuggledMrm);
    internal MethodResponse(SerializationInfo info, StreamingContext context);
    internal void InitMethodProperty(string key, object value);
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public sealed virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    private sealed virtual override string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetOutArgName(int index);
    [MonoTODOAttribute]
public virtual object HeaderHandler(Header[] h);
    [MonoTODOAttribute]
public sealed virtual void RootSetObjectData(SerializationInfo info, StreamingContext ctx);
    private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
    private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
}
internal class System.Runtime.Remoting.Messaging.MethodReturnDictionary : MessageDictionary {
    public static String[] InternalReturnKeys;
    public static String[] InternalExceptionKeys;
    public MethodReturnDictionary(IMethodReturnMessage message);
    private static MethodReturnDictionary();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.MethodReturnMessageWrapper : InternalMessageWrapper {
    private Object[] _args;
    private ArgInfo _outArgInfo;
    private DictionaryWrapper _properties;
    private Exception _exception;
    private object _return;
    public int ArgCount { get; }
    public Object[] Args { get; public set; }
    public Exception Exception { get; public set; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public IDictionary Properties { get; }
    public object ReturnValue { get; public set; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    public MethodReturnMessageWrapper(IMethodReturnMessage msg);
    [SecurityCriticalAttribute]
public virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public virtual Object[] get_Args();
    public virtual void set_Args(Object[] value);
    [SecurityCriticalAttribute]
public virtual Exception get_Exception();
    public virtual void set_Exception(Exception value);
    [SecurityCriticalAttribute]
public virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public virtual string get_MethodName();
    [SecurityCriticalAttribute]
public virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public virtual object get_ReturnValue();
    public virtual void set_ReturnValue(object value);
    [SecurityCriticalAttribute]
public virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    [SecurityCriticalAttribute]
public virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public virtual string GetOutArgName(int index);
}
internal class System.Runtime.Remoting.Messaging.MonoMethodMessage : object {
    private RuntimeMethodInfo method;
    private Object[] args;
    private String[] names;
    private Byte[] arg_types;
    public LogicalCallContext ctx;
    public object rval;
    public Exception exc;
    private AsyncResult asyncResult;
    private CallType call_type;
    private string uri;
    private MCMDictionary properties;
    private Identity identity;
    private Type[] methodSignature;
    public IDictionary Properties { get; }
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; public set; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    public int InArgCount { get; }
    public Object[] InArgs { get; }
    public Exception Exception { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public object ReturnValue { get; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; private set; }
    public bool IsAsync { get; }
    public AsyncResult AsyncResult { get; }
    internal CallType CallType { get; }
    public MonoMethodMessage(MethodBase method, Object[] out_args);
    internal MonoMethodMessage(MethodInfo minfo, Object[] in_args, Object[] out_args);
    public MonoMethodMessage(Type type, string methodName, Object[] in_args);
    internal void InitMessage(RuntimeMethodInfo method, Object[] out_args);
    private static MethodInfo GetMethodInfo(Type type, string methodName);
    public sealed virtual IDictionary get_Properties();
    public sealed virtual int get_ArgCount();
    public sealed virtual Object[] get_Args();
    public sealed virtual bool get_HasVarArgs();
    public sealed virtual LogicalCallContext get_LogicalCallContext();
    public void set_LogicalCallContext(LogicalCallContext value);
    public sealed virtual MethodBase get_MethodBase();
    public sealed virtual string get_MethodName();
    public sealed virtual object get_MethodSignature();
    public sealed virtual string get_TypeName();
    public sealed virtual string get_Uri();
    public sealed virtual void set_Uri(string value);
    public sealed virtual object GetArg(int arg_num);
    public sealed virtual string GetArgName(int arg_num);
    public sealed virtual int get_InArgCount();
    public sealed virtual Object[] get_InArgs();
    public sealed virtual object GetInArg(int arg_num);
    public sealed virtual string GetInArgName(int arg_num);
    public sealed virtual Exception get_Exception();
    public sealed virtual int get_OutArgCount();
    public sealed virtual Object[] get_OutArgs();
    public sealed virtual object get_ReturnValue();
    public sealed virtual object GetOutArg(int arg_num);
    public sealed virtual string GetOutArgName(int arg_num);
    private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
    private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    public bool get_IsAsync();
    public AsyncResult get_AsyncResult();
    internal CallType get_CallType();
    public bool NeedsOutProcessing(Int32& outCount);
}
internal class System.Runtime.Remoting.Messaging.ObjRefSurrogate : object {
    public virtual void GetObjectData(object obj, SerializationInfo si, StreamingContext sc);
    public virtual object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Remoting.Messaging.OneWayAttribute : Attribute {
}
internal class System.Runtime.Remoting.Messaging.RemotingSurrogate : object {
    public virtual void GetObjectData(object obj, SerializationInfo si, StreamingContext sc);
    public virtual object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.RemotingSurrogateSelector : object {
    private static Type s_cachedTypeObjRef;
    private static ObjRefSurrogate _objRefSurrogate;
    private static RemotingSurrogate _objRemotingSurrogate;
    private object _rootObj;
    private MessageSurrogateFilter _filter;
    private ISurrogateSelector _next;
    public MessageSurrogateFilter Filter { get; public set; }
    private static RemotingSurrogateSelector();
    public MessageSurrogateFilter get_Filter();
    public void set_Filter(MessageSurrogateFilter value);
    [SecurityCriticalAttribute]
public virtual void ChainSelector(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public virtual ISurrogateSelector GetNextSelector();
    public object GetRootObject();
    [SecurityCriticalAttribute]
public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& ssout);
    public void SetRootObject(object obj);
    [MonoTODOAttribute]
public virtual void UseSoapFormat();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Messaging.ReturnMessage : object {
    private Object[] _outArgs;
    private Object[] _args;
    private LogicalCallContext _callCtx;
    private object _returnValue;
    private string _uri;
    private Exception _exception;
    private MethodBase _methodBase;
    private string _methodName;
    private Type[] _methodSignature;
    private string _typeName;
    private MethodReturnDictionary _properties;
    private Identity _targetIdentity;
    private ArgInfo _inArgInfo;
    public int ArgCount { get; }
    public Object[] Args { get; }
    public bool HasVarArgs { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public MethodBase MethodBase { get; }
    public string MethodName { get; }
    public object MethodSignature { get; }
    public IDictionary Properties { get; }
    public string TypeName { get; }
    public string Uri { get; public set; }
    private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; private set; }
    public Exception Exception { get; }
    public int OutArgCount { get; }
    public Object[] OutArgs { get; }
    public object ReturnValue { get; }
    private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; private set; }
    public ReturnMessage(object ret, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm);
    public ReturnMessage(Exception e, IMethodCallMessage mcm);
    [SecurityCriticalAttribute]
public sealed virtual int get_ArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_Args();
    [SecurityCriticalAttribute]
public sealed virtual bool get_HasVarArgs();
    [SecurityCriticalAttribute]
public sealed virtual LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecurityCriticalAttribute]
public sealed virtual string get_MethodName();
    [SecurityCriticalAttribute]
public sealed virtual object get_MethodSignature();
    [SecurityCriticalAttribute]
public virtual IDictionary get_Properties();
    [SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [SecurityCriticalAttribute]
public sealed virtual string get_Uri();
    public void set_Uri(string value);
    private sealed virtual override string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
    [SecurityCriticalAttribute]
public sealed virtual object GetArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetArgName(int index);
    [SecurityCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecurityCriticalAttribute]
public sealed virtual int get_OutArgCount();
    [SecurityCriticalAttribute]
public sealed virtual Object[] get_OutArgs();
    [SecurityCriticalAttribute]
public virtual object get_ReturnValue();
    [SecurityCriticalAttribute]
public sealed virtual object GetOutArg(int argNum);
    [SecurityCriticalAttribute]
public sealed virtual string GetOutArgName(int index);
    private sealed virtual override Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
    private sealed virtual override void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
    private sealed virtual override bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
    internal bool HasProperties();
}
internal class System.Runtime.Remoting.Messaging.ServerContextTerminatorSink : object {
    public IMessageSink NextSink { get; }
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ServerObjectReplySink : object {
    private IMessageSink _replySink;
    private ServerIdentity _identity;
    public IMessageSink NextSink { get; }
    public ServerObjectReplySink(ServerIdentity identity, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.ServerObjectTerminatorSink : object {
    private IMessageSink _nextSink;
    public IMessageSink NextSink { get; }
    public ServerObjectTerminatorSink(IMessageSink nextSink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessageSink get_NextSink();
}
internal class System.Runtime.Remoting.Messaging.StackBuilderSink : object {
    private MarshalByRefObject _target;
    private RealProxy _rp;
    public IMessageSink NextSink { get; }
    public StackBuilderSink(MarshalByRefObject obj, bool forceInternalExecute);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    private void ExecuteAsyncMessage(object ob);
    public sealed virtual IMessageSink get_NextSink();
    private void CheckParameters(IMessage msg);
    [CompilerGeneratedAttribute]
private void <AsyncProcessMessage>b__4_0(object data);
}
internal class System.Runtime.Remoting.Metadata.RemotingCachedData : object {
}
internal class System.Runtime.Remoting.Metadata.RemotingFieldCachedData : object {
    internal RemotingFieldCachedData(RuntimeFieldInfo ri);
    internal RemotingFieldCachedData(SerializationFieldInfo ri);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapAttribute : Attribute {
    private bool _nested;
    private bool _useAttribute;
    protected string ProtXmlNamespace;
    protected object ReflectInfo;
    public bool Embedded { get; public set; }
    public bool UseAttribute { get; public set; }
    public string XmlNamespace { get; public set; }
    public virtual bool get_Embedded();
    public virtual void set_Embedded(bool value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
    public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    internal virtual void SetReflectionObject(object reflectionObject);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("256")]
public class System.Runtime.Remoting.Metadata.SoapFieldAttribute : SoapAttribute {
    private int _order;
    private string _elementName;
    private bool _isElement;
    public int Order { get; public set; }
    public string XmlElementName { get; public set; }
    public int get_Order();
    public void set_Order(int value);
    public string get_XmlElementName();
    public void set_XmlElementName(string value);
    public bool IsInteropXmlElement();
    internal virtual void SetReflectionObject(object reflectionObject);
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapMethodAttribute : SoapAttribute {
    private string _responseElement;
    private string _responseNamespace;
    private string _returnElement;
    private string _soapAction;
    private bool _useAttribute;
    private string _namespace;
    public string ResponseXmlElementName { get; public set; }
    public string ResponseXmlNamespace { get; public set; }
    public string ReturnXmlElementName { get; public set; }
    public string SoapAction { get; public set; }
    public bool UseAttribute { get; public set; }
    public string XmlNamespace { get; public set; }
    public string get_ResponseXmlElementName();
    public void set_ResponseXmlElementName(string value);
    public string get_ResponseXmlNamespace();
    public void set_ResponseXmlNamespace(string value);
    public string get_ReturnXmlElementName();
    public void set_ReturnXmlElementName(string value);
    public string get_SoapAction();
    public void set_SoapAction(string value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
    public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    internal virtual void SetReflectionObject(object reflectionObject);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Metadata.SoapOption : Enum {
    public int value__;
    public static SoapOption None;
    public static SoapOption AlwaysIncludeTypes;
    public static SoapOption XsdString;
    public static SoapOption EmbedAll;
    public static SoapOption Option1;
    public static SoapOption Option2;
}
[AttributeUsageAttribute("2048")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapParameterAttribute : SoapAttribute {
}
[AttributeUsageAttribute("1052")]
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.SoapTypeAttribute : SoapAttribute {
    private SoapOption _soapOption;
    private bool _useAttribute;
    private string _xmlElementName;
    private XmlFieldOrderOption _xmlFieldOrder;
    private string _xmlNamespace;
    private string _xmlTypeName;
    private string _xmlTypeNamespace;
    private bool _isType;
    private bool _isElement;
    public SoapOption SoapOptions { get; public set; }
    public bool UseAttribute { get; public set; }
    public string XmlElementName { get; public set; }
    public XmlFieldOrderOption XmlFieldOrder { get; public set; }
    public string XmlNamespace { get; public set; }
    public string XmlTypeName { get; public set; }
    public string XmlTypeNamespace { get; public set; }
    internal bool IsInteropXmlElement { get; }
    internal bool IsInteropXmlType { get; }
    public SoapOption get_SoapOptions();
    public void set_SoapOptions(SoapOption value);
    public virtual bool get_UseAttribute();
    public virtual void set_UseAttribute(bool value);
    public string get_XmlElementName();
    public void set_XmlElementName(string value);
    public XmlFieldOrderOption get_XmlFieldOrder();
    public void set_XmlFieldOrder(XmlFieldOrderOption value);
    public virtual string get_XmlNamespace();
    public virtual void set_XmlNamespace(string value);
    public string get_XmlTypeName();
    public void set_XmlTypeName(string value);
    public string get_XmlTypeNamespace();
    public void set_XmlTypeNamespace(string value);
    internal bool get_IsInteropXmlElement();
    internal bool get_IsInteropXmlType();
    internal virtual void SetReflectionObject(object reflectionObject);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd {
    public abstract virtual string GetXsdType();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapAnyUri(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapAnyUri Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary : object {
    private Byte[] _value;
    public Byte[] Value { get; public set; }
    public static string XsdType { get; }
    public SoapBase64Binary(Byte[] value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapBase64Binary Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate : object {
    private static String[] _datetimeFormats;
    private int _sign;
    private DateTime _value;
    public int Sign { get; public set; }
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapDate(DateTime value);
    public SoapDate(DateTime value, int sign);
    private static SoapDate();
    public int get_Sign();
    public void set_Sign(int value);
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapDate Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDateTime : object {
    private static String[] _datetimeFormats;
    public static string XsdType { get; }
    private static SoapDateTime();
    public static string get_XsdType();
    public static DateTime Parse(string value);
    public static string ToString(DateTime value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay : object {
    private static String[] _datetimeFormats;
    private DateTime _value;
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapDay(DateTime value);
    private static SoapDay();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapDay Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDuration : object {
    public static string XsdType { get; }
    public static string get_XsdType();
    public static TimeSpan Parse(string value);
    public static string ToString(TimeSpan timeSpan);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapEntities(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapEntities Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapEntity(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapEntity Parse(string value);
    public virtual string ToString();
}
internal class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHelper : object {
    public static Exception GetException(ISoapXsd type, string msg);
    public static string Normalize(string s);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary : object {
    private Byte[] _value;
    private StringBuilder sb;
    public Byte[] Value { get; public set; }
    public static string XsdType { get; }
    public SoapHexBinary(Byte[] value);
    public Byte[] get_Value();
    public void set_Value(Byte[] value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapHexBinary Parse(string value);
    internal static Byte[] FromBinHexString(string value);
    private static byte FromHex(char hexDigit, string value);
    private static Exception CreateInvalidValueException(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapId(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapId Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapIdref(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapIdref Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapIdrefs(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapIdrefs Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger : object {
    private decimal _value;
    public decimal Value { get; public set; }
    public static string XsdType { get; }
    public SoapInteger(decimal value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapInteger Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapLanguage(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapLanguage Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth : object {
    private static String[] _datetimeFormats;
    private DateTime _value;
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapMonth(DateTime value);
    private static SoapMonth();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapMonth Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay : object {
    private static String[] _datetimeFormats;
    private DateTime _value;
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapMonthDay(DateTime value);
    private static SoapMonthDay();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapMonthDay Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapName(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapName Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapNcName(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNcName Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger : object {
    private decimal _value;
    public decimal Value { get; public set; }
    public static string XsdType { get; }
    public SoapNegativeInteger(decimal value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNegativeInteger Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapNmtoken(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNmtoken Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapNmtokens(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNmtokens Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger : object {
    private decimal _value;
    public decimal Value { get; public set; }
    public static string XsdType { get; }
    public SoapNonNegativeInteger(decimal value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNonNegativeInteger Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger : object {
    private decimal _value;
    public decimal Value { get; public set; }
    public static string XsdType { get; }
    public SoapNonPositiveInteger(decimal value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNonPositiveInteger Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapNormalizedString(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNormalizedString Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapNotation(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapNotation Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger : object {
    private decimal _value;
    public decimal Value { get; public set; }
    public static string XsdType { get; }
    public SoapPositiveInteger(decimal value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapPositiveInteger Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName : object {
    private string _name;
    private string _key;
    private string _namespace;
    public string Key { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public static string XsdType { get; }
    public SoapQName(string value);
    public SoapQName(string key, string name);
    public SoapQName(string key, string name, string namespaceValue);
    public string get_Key();
    public void set_Key(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapQName Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime : object {
    private static String[] _datetimeFormats;
    private DateTime _value;
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapTime(DateTime value);
    private static SoapTime();
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapTime Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken : object {
    private string _value;
    public string Value { get; public set; }
    public static string XsdType { get; }
    public SoapToken(string value);
    public string get_Value();
    public void set_Value(string value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapToken Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear : object {
    private static String[] _datetimeFormats;
    private int _sign;
    private DateTime _value;
    public int Sign { get; public set; }
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapYear(DateTime value);
    public SoapYear(DateTime value, int sign);
    private static SoapYear();
    public int get_Sign();
    public void set_Sign(int value);
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapYear Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth : object {
    private static String[] _datetimeFormats;
    private int _sign;
    private DateTime _value;
    public int Sign { get; public set; }
    public DateTime Value { get; public set; }
    public static string XsdType { get; }
    public SoapYearMonth(DateTime value);
    public SoapYearMonth(DateTime value, int sign);
    private static SoapYearMonth();
    public int get_Sign();
    public void set_Sign(int value);
    public DateTime get_Value();
    public void set_Value(DateTime value);
    public static string get_XsdType();
    public sealed virtual string GetXsdType();
    public static SoapYearMonth Parse(string value);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.Metadata.XmlFieldOrderOption : Enum {
    public int value__;
    public static XmlFieldOrderOption All;
    public static XmlFieldOrderOption Sequence;
    public static XmlFieldOrderOption Choice;
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    private object _wrapped;
    public ObjectHandle(object o);
    public virtual object InitializeLifetimeService();
    public sealed virtual object Unwrap();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ObjRef : object {
    private IChannelInfo channel_info;
    private string uri;
    private IRemotingTypeInfo typeInfo;
    private IEnvoyInfo envoyInfo;
    private int flags;
    private Type _serverType;
    private static int MarshalledObjectRef;
    private static int WellKnowObjectRef;
    internal bool IsReferenceToWellKnow { get; }
    public IChannelInfo ChannelInfo { get; public set; }
    public IEnvoyInfo EnvoyInfo { get; public set; }
    public IRemotingTypeInfo TypeInfo { get; public set; }
    public string URI { get; public set; }
    internal Type ServerType { get; }
    internal ObjRef(string uri, IChannelInfo cinfo);
    internal ObjRef(ObjRef o, bool unmarshalAsProxy);
    public ObjRef(MarshalByRefObject o, Type requestedType);
    internal ObjRef(Type type, string url, object remoteChannelData);
    protected ObjRef(SerializationInfo info, StreamingContext context);
    private static ObjRef();
    internal ObjRef DeserializeInTheCurrentDomain(int domainId, Byte[] tInfo);
    internal Byte[] SerializeType();
    internal bool IsPossibleToCAD();
    internal bool get_IsReferenceToWellKnow();
    [ReliabilityContractAttribute("3", "2")]
public virtual IChannelInfo get_ChannelInfo();
    public virtual void set_ChannelInfo(IChannelInfo value);
    public virtual IEnvoyInfo get_EnvoyInfo();
    public virtual void set_EnvoyInfo(IEnvoyInfo value);
    public virtual IRemotingTypeInfo get_TypeInfo();
    public virtual void set_TypeInfo(IRemotingTypeInfo value);
    public virtual string get_URI();
    public virtual void set_URI(string value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
    public bool IsFromThisAppDomain();
    [ReliabilityContractAttribute("3", "2")]
public bool IsFromThisProcess();
    internal void UpdateChannelInfo();
    internal Type get_ServerType();
    internal void SetDomainID(int id);
}
internal class System.Runtime.Remoting.ProviderData : object {
    internal string Ref;
    internal string Type;
    internal string Id;
    internal Hashtable CustomProperties;
    internal IList CustomData;
    public void CopyFrom(ProviderData other);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4")]
public class System.Runtime.Remoting.Proxies.ProxyAttribute : Attribute {
    public virtual MarshalByRefObject CreateInstance(Type serverType);
    public virtual RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public sealed virtual void GetPropertiesForNewContext(IConstructionCallMessage msg);
    [ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public sealed virtual bool IsContextOK(Context ctx, IConstructionCallMessage msg);
}
[ComVisibleAttribute("True")]
public abstract class System.Runtime.Remoting.Proxies.RealProxy : object {
    private Type class_to_proxy;
    internal Context _targetContext;
    internal MarshalByRefObject _server;
    private int _targetDomainId;
    internal string _targetUri;
    internal Identity _objectIdentity;
    private object _objTP;
    private object _stubData;
    internal Identity ObjectIdentity { get; internal set; }
    protected RealProxy(Type classToProxy);
    internal RealProxy(Type classToProxy, ClientIdentity identity);
    protected RealProxy(Type classToProxy, IntPtr stub, object stubData);
    private static Type InternalGetProxyType(object transparentProxy);
    public Type GetProxiedType();
    public virtual ObjRef CreateObjRef(Type requestedType);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Identity get_ObjectIdentity();
    internal void set_ObjectIdentity(Identity value);
    [MonoTODOAttribute]
public virtual IntPtr GetCOMIUnknown(bool fIsMarshalled);
    [MonoTODOAttribute]
public virtual void SetCOMIUnknown(IntPtr i);
    [MonoTODOAttribute]
public virtual IntPtr SupportsInterface(Guid& iid);
    public static object GetStubData(RealProxy rp);
    public static void SetStubData(RealProxy rp, object stubData);
    public abstract virtual IMessage Invoke(IMessage msg);
    internal static object PrivateInvoke(RealProxy rp, IMessage msg, Exception& exc, Object[]& out_args);
    internal virtual object InternalGetTransparentProxy(string className);
    public virtual object GetTransparentProxy();
    [MonoTODOAttribute]
[ComVisibleAttribute("True")]
public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg);
    protected void AttachServer(MarshalByRefObject s);
    protected MarshalByRefObject DetachServer();
    protected MarshalByRefObject GetUnwrappedServer();
    internal void SetTargetDomain(int domainId);
    internal object GetAppDomainTarget();
    private static Object[] ProcessResponse(IMethodReturnMessage mrm, MonoMethodMessage call);
}
internal class System.Runtime.Remoting.Proxies.RemotingProxy : RealProxy {
    private static MethodInfo _cache_GetTypeMethod;
    private static MethodInfo _cache_GetHashCodeMethod;
    private IMessageSink _sink;
    private bool _hasEnvoySink;
    private ConstructionCall _ctorCall;
    public string TypeName { get; public set; }
    internal RemotingProxy(Type type, ClientIdentity identity);
    internal RemotingProxy(Type type, string activationUrl, Object[] activationAttributes);
    private static RemotingProxy();
    public virtual IMessage Invoke(IMessage request);
    internal void AttachIdentity(Identity identity);
    internal IMessage ActivateRemoteObject(IMethodMessage request);
    public sealed virtual string get_TypeName();
    public sealed virtual void set_TypeName(string value);
    public sealed virtual bool CanCastTo(Type fromType, object o);
    protected virtual override void Finalize();
}
internal class System.Runtime.Remoting.Proxies.TransparentProxy : object {
    public RealProxy _rp;
    private RuntimeRemoteClassHandle _class;
    private bool _custom_type_info;
    private bool IsContextBoundObject { get; }
    private Context TargetContext { get; }
    internal RuntimeType GetProxyType();
    private bool get_IsContextBoundObject();
    private Context get_TargetContext();
    private bool InCurrentContext();
    internal object LoadRemoteFieldNew(IntPtr classPtr, IntPtr fieldPtr);
    internal void StoreRemoteField(IntPtr classPtr, IntPtr fieldPtr, object arg);
}
[ComVisibleAttribute("True")]
public static class System.Runtime.Remoting.RemotingConfiguration : object {
    private static string applicationID;
    private static string applicationName;
    private static string processGuid;
    private static bool defaultConfigRead;
    private static bool defaultDelayedConfigRead;
    private static CustomErrorsModes _errorMode;
    private static Hashtable wellKnownClientEntries;
    private static Hashtable activatedClientEntries;
    private static Hashtable wellKnownServiceEntries;
    private static Hashtable activatedServiceEntries;
    private static Hashtable channelTemplates;
    private static Hashtable clientProviderTemplates;
    private static Hashtable serverProviderTemplates;
    public static string ApplicationId { get; }
    public static string ApplicationName { get; public set; }
    public static CustomErrorsModes CustomErrorsMode { get; public set; }
    public static string ProcessId { get; }
    private static RemotingConfiguration();
    public static string get_ApplicationId();
    public static string get_ApplicationName();
    public static void set_ApplicationName(string value);
    public static CustomErrorsModes get_CustomErrorsMode();
    public static void set_CustomErrorsMode(CustomErrorsModes value);
    public static string get_ProcessId();
    [MonoTODOAttribute("ensureSecurity support has not been implemented")]
public static void Configure(string filename, bool ensureSecurity);
    [ObsoleteAttribute("Use Configure(String,Boolean)")]
public static void Configure(string filename);
    private static void ReadConfigString(string filename);
    private static void ReadConfigFile(string filename);
    internal static void LoadDefaultDelayedChannels();
    public static ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes();
    public static ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes();
    public static WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes();
    public static WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes();
    public static bool IsActivationAllowed(Type svrType);
    public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType);
    public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName);
    public static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType);
    public static WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName);
    public static void RegisterActivatedClientType(ActivatedClientTypeEntry entry);
    public static void RegisterActivatedClientType(Type type, string appUrl);
    public static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry);
    public static void RegisterActivatedServiceType(Type type);
    public static void RegisterWellKnownClientType(Type type, string objectUrl);
    public static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry);
    public static void RegisterWellKnownServiceType(Type type, string objectUri, WellKnownObjectMode mode);
    public static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry);
    internal static void RegisterChannelTemplate(ChannelData channel);
    internal static void RegisterClientProviderTemplate(ProviderData prov);
    internal static void RegisterServerProviderTemplate(ProviderData prov);
    internal static void RegisterChannels(ArrayList channels, bool onlyDelayed);
    internal static void RegisterTypes(ArrayList types);
    public static bool CustomErrorsEnabled(bool isLocalRequest);
    internal static void SetCustomErrorsMode(string mode);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.RemotingException : SystemException {
    public RemotingException(string message);
    protected RemotingException(SerializationInfo info, StreamingContext context);
    public RemotingException(string message, Exception InnerException);
}
[ComVisibleAttribute("True")]
public static class System.Runtime.Remoting.RemotingServices : object {
    private static Hashtable uri_hash;
    private static BinaryFormatter _serializationFormatter;
    private static BinaryFormatter _deserializationFormatter;
    private static string app_id;
    private static object app_id_lock;
    private static int next_id;
    private static BindingFlags methodBindings;
    private static MethodInfo FieldSetterMethod;
    private static MethodInfo FieldGetterMethod;
    private static RemotingServices();
    internal static object InternalExecute(MethodBase method, object obj, Object[] parameters, Object[]& out_args);
    internal static MethodBase GetVirtualMethod(Type type, MethodBase method);
    [ReliabilityContractAttribute("3", "2")]
public static bool IsTransparentProxy(object proxy);
    internal static bool ProxyCheckCast(RealProxy rp, RuntimeType castType);
    internal static IMethodReturnMessage InternalExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg);
    public static IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg);
    [ComVisibleAttribute("True")]
public static object Connect(Type classToProxy, string url);
    [ComVisibleAttribute("True")]
public static object Connect(Type classToProxy, string url, object data);
    public static bool Disconnect(MarshalByRefObject obj);
    public static Type GetServerTypeForUri(string URI);
    public static string GetObjectUri(MarshalByRefObject obj);
    public static object Unmarshal(ObjRef objectRef);
    public static object Unmarshal(ObjRef objectRef, bool fRefine);
    public static ObjRef Marshal(MarshalByRefObject Obj);
    public static ObjRef Marshal(MarshalByRefObject Obj, string URI);
    public static ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    private static string NewUri();
    [ReliabilityContractAttribute("3", "2")]
public static RealProxy GetRealProxy(object proxy);
    public static MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg);
    internal static MethodBase GetMethodBaseFromName(Type type, string methodName, Type[] signature);
    private static MethodBase FindInterfaceMethod(Type type, string methodName, Type[] signature);
    public static void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    public static ObjRef GetObjRefForProxy(MarshalByRefObject obj);
    public static object GetLifetimeService(MarshalByRefObject obj);
    public static IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj);
    [ObsoleteAttribute("It existed for only internal use in .NET and unimplemented in mono")]
[ConditionalAttribute("REMOTING_PERF")]
[MonoTODOAttribute]
public static void LogRemotingStage(int stage);
    public static string GetSessionIdForMethodMessage(IMethodMessage msg);
    public static bool IsMethodOverloaded(IMethodMessage msg);
    public static bool IsObjectOutOfAppDomain(object tp);
    public static bool IsObjectOutOfContext(object tp);
    public static bool IsOneWay(MethodBase method);
    internal static bool IsAsyncMessage(IMessage msg);
    public static void SetObjectUriForMarshal(MarshalByRefObject obj, string uri);
    internal static object CreateClientProxy(ActivatedClientTypeEntry entry, Object[] activationAttributes);
    internal static object CreateClientProxy(Type objectType, string url, Object[] activationAttributes);
    internal static object CreateClientProxy(WellKnownClientTypeEntry entry);
    internal static object CreateClientProxyForContextBound(Type type, Object[] activationAttributes);
    internal static object CreateClientProxyForComInterop(Type type);
    internal static Identity GetIdentityForUri(string uri);
    private static string RemoveAppNameFromUri(string uri);
    internal static Identity GetObjectIdentity(MarshalByRefObject obj);
    internal static ClientIdentity GetOrCreateClientIdentity(ObjRef objRef, Type proxyType, Object& clientProxy);
    private static IMessageSink GetClientChannelSinkChain(string url, object channelData, String& objectUri);
    internal static ClientActivatedIdentity CreateContextBoundObjectIdentity(Type objectType);
    internal static ClientActivatedIdentity CreateClientActivatedServerIdentity(MarshalByRefObject realObject, Type objectType, string objectUri);
    internal static ServerIdentity CreateWellKnownServerIdentity(Type objectType, string objectUri, WellKnownObjectMode mode);
    private static void RegisterServerIdentity(ServerIdentity identity);
    internal static object GetProxyForRemoteObject(ObjRef objref, Type classToProxy);
    internal static object GetRemoteObject(ObjRef objRef, Type proxyType);
    internal static object GetServerObject(string uri);
    internal static Byte[] SerializeCallData(object obj);
    internal static object DeserializeCallData(Byte[] array);
    internal static Byte[] SerializeExceptionData(Exception ex);
    internal static object GetDomainProxy(AppDomain domain);
    private static void RegisterInternalChannels();
    internal static void DisposeIdentity(Identity ident);
    internal static Identity GetMessageTargetIdentity(IMessage msg);
    internal static void SetMessageTargetIdentity(IMessage msg, Identity ident);
    internal static bool UpdateOutArgObject(ParameterInfo pi, object local, object remote);
    private static string GetNormalizedUri(string uri);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.RemotingTimeoutException : RemotingException {
    public RemotingTimeoutException(string message);
    public RemotingTimeoutException(string message, Exception InnerException);
    internal RemotingTimeoutException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.ServerException : SystemException {
    public ServerException(string message);
    public ServerException(string message, Exception InnerException);
    internal ServerException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.Runtime.Remoting.ServerIdentity : Identity {
    protected Type _objectType;
    protected MarshalByRefObject _serverObject;
    protected IMessageSink _serverSink;
    protected Context _context;
    protected Lease _lease;
    public Type ObjectType { get; }
    public Lease Lease { get; }
    public Context Context { get; public set; }
    public ServerIdentity(string objectUri, Context context, Type objectType);
    public Type get_ObjectType();
    public void StartTrackingLifetime(ILease lease);
    public virtual void OnLifetimeExpired();
    public virtual ObjRef CreateObjRef(Type requestedType);
    public void AttachServerObject(MarshalByRefObject serverObject, Context context);
    public Lease get_Lease();
    public Context get_Context();
    public void set_Context(Context value);
    public abstract virtual IMessage SyncObjectProcessMessage(IMessage msg);
    public abstract virtual IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);
    protected void DisposeServerObject();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Services.EnterpriseServicesHelper : object {
    [ComVisibleAttribute("True")]
public static IConstructionReturnMessage CreateConstructionReturnMessage(IConstructionCallMessage ctorMsg, MarshalByRefObject retObj);
    [MonoTODOAttribute]
public static void SwitchWrappers(RealProxy oldcp, RealProxy newcp);
    [MonoTODOAttribute]
public static object WrapIUnknownWithComObject(IntPtr punk);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Remoting.Services.ITrackingHandler {
    public abstract virtual void DisconnectedObject(object obj);
    public abstract virtual void MarshaledObject(object obj, ObjRef or);
    public abstract virtual void UnmarshaledObject(object obj, ObjRef or);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.Services.TrackingServices : object {
    private static ArrayList _handlers;
    public static ITrackingHandler[] RegisteredHandlers { get; }
    private static TrackingServices();
    public static void RegisterTrackingHandler(ITrackingHandler handler);
    public static void UnregisterTrackingHandler(ITrackingHandler handler);
    public static ITrackingHandler[] get_RegisteredHandlers();
    internal static void NotifyMarshaledObject(object obj, ObjRef or);
    internal static void NotifyUnmarshaledObject(object obj, ObjRef or);
    internal static void NotifyDisconnectedObject(object obj);
}
internal class System.Runtime.Remoting.SingleCallIdentity : ServerIdentity {
    public SingleCallIdentity(string objectUri, Context context, Type objectType);
    public virtual IMessage SyncObjectProcessMessage(IMessage msg);
    public virtual IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);
}
internal class System.Runtime.Remoting.SingletonIdentity : ServerIdentity {
    public SingletonIdentity(string objectUri, Context context, Type objectType);
    public MarshalByRefObject GetServerObject();
    public virtual IMessage SyncObjectProcessMessage(IMessage msg);
    public virtual IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.SoapServices : object {
    private static Hashtable _xmlTypes;
    private static Hashtable _xmlElements;
    private static Hashtable _soapActions;
    private static Hashtable _soapActionsMethods;
    private static Hashtable _typeInfos;
    public static string XmlNsForClrType { get; }
    public static string XmlNsForClrTypeWithAssembly { get; }
    public static string XmlNsForClrTypeWithNs { get; }
    public static string XmlNsForClrTypeWithNsAndAssembly { get; }
    private static SoapServices();
    public static string get_XmlNsForClrType();
    public static string get_XmlNsForClrTypeWithAssembly();
    public static string get_XmlNsForClrTypeWithNs();
    public static string get_XmlNsForClrTypeWithNsAndAssembly();
    public static string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
    public static bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, String& typeNamespace, String& assemblyName);
    public static void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType, string xmlAttribute, string xmlNamespace, Type& type, String& name);
    public static void GetInteropFieldTypeAndNameFromXmlElement(Type containingType, string xmlElement, string xmlNamespace, Type& type, String& name);
    private static void GetInteropFieldInfo(Hashtable fields, string xmlName, string xmlNamespace, Type& type, String& name);
    private static string GetNameKey(string name, string namspace);
    public static Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace);
    public static Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace);
    private static string GetAssemblyName(MethodBase mb);
    public static string GetSoapActionFromMethodBase(MethodBase mb);
    public static bool GetTypeAndMethodNameFromSoapAction(string soapAction, String& typeName, String& methodName);
    public static bool GetXmlElementForInteropType(Type type, String& xmlElement, String& xmlNamespace);
    public static string GetXmlNamespaceForMethodCall(MethodBase mb);
    public static string GetXmlNamespaceForMethodResponse(MethodBase mb);
    public static bool GetXmlTypeForInteropType(Type type, String& xmlType, String& xmlTypeNamespace);
    public static bool IsClrTypeNamespace(string namespaceString);
    public static bool IsSoapActionValidForMethodBase(string soapAction, MethodBase mb);
    public static void PreLoad(Assembly assembly);
    public static void PreLoad(Type type);
    public static void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type);
    public static void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type);
    public static void RegisterSoapActionForMethodBase(MethodBase mb);
    private static string InternalGetSoapAction(MethodBase mb);
    public static void RegisterSoapActionForMethodBase(MethodBase mb, string soapAction);
    private static string EncodeNs(string ns);
    private static string DecodeNs(string ns);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.TypeEntry : object {
    private string assembly_name;
    private string type_name;
    public string AssemblyName { get; public set; }
    public string TypeName { get; public set; }
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
}
internal class System.Runtime.Remoting.TypeInfo : object {
    private string serverType;
    private String[] serverHierarchy;
    private String[] interfacesImplemented;
    public string TypeName { get; public set; }
    public TypeInfo(Type type);
    public sealed virtual string get_TypeName();
    public sealed virtual void set_TypeName(string value);
    public sealed virtual bool CanCastTo(Type fromType, object o);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.WellKnownClientTypeEntry : TypeEntry {
    private Type obj_type;
    private string obj_url;
    private string app_url;
    public string ApplicationUrl { get; public set; }
    public Type ObjectType { get; }
    public string ObjectUrl { get; }
    public WellKnownClientTypeEntry(Type type, string objectUrl);
    public WellKnownClientTypeEntry(string typeName, string assemblyName, string objectUrl);
    public string get_ApplicationUrl();
    public void set_ApplicationUrl(string value);
    public Type get_ObjectType();
    public string get_ObjectUrl();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public enum System.Runtime.Remoting.WellKnownObjectMode : Enum {
    public int value__;
    public static WellKnownObjectMode Singleton;
    public static WellKnownObjectMode SingleCall;
}
[ComVisibleAttribute("True")]
public class System.Runtime.Remoting.WellKnownServiceTypeEntry : TypeEntry {
    private Type obj_type;
    private string obj_uri;
    private WellKnownObjectMode obj_mode;
    public IContextAttribute[] ContextAttributes { get; public set; }
    public WellKnownObjectMode Mode { get; }
    public Type ObjectType { get; }
    public string ObjectUri { get; }
    public WellKnownServiceTypeEntry(Type type, string objectUri, WellKnownObjectMode mode);
    public WellKnownServiceTypeEntry(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode);
    public IContextAttribute[] get_ContextAttributes();
    public void set_ContextAttributes(IContextAttribute[] value);
    public WellKnownObjectMode get_Mode();
    public Type get_ObjectType();
    public string get_ObjectUri();
    public virtual string ToString();
}
public static class System.Runtime.RuntimeImports : object {
    internal static void RhZeroMemory(Byte& b, ulong byteLength);
    internal static void RhZeroMemory(IntPtr p, UIntPtr byteLength);
    private static void ZeroMemory(Void* p, UInt32 byteLength);
    internal static void Memmove(Byte* dest, Byte* src, UInt32 len);
    internal static void Memmove_wbarrier(Byte* dest, Byte* src, UInt32 len, IntPtr type_handle);
    internal static void _ecvt_s(Byte* buffer, int sizeInBytes, double value, int count, Int32* dec, Int32* sign);
}
internal class System.Runtime.Serialization.DeserializationEventHandler : MulticastDelegate {
    public DeserializationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.FixupHolder : object {
    internal static int ArrayFixup;
    internal static int MemberFixup;
    internal static int DelayedFixup;
    internal long m_id;
    internal object m_fixupInfo;
    internal int m_fixupType;
    internal FixupHolder(long id, object fixupInfo, int fixupType);
}
internal class System.Runtime.Serialization.FixupHolderList : object {
    internal static int InitialSize;
    internal FixupHolder[] m_values;
    internal int m_count;
    internal FixupHolderList(int startingSize);
    internal virtual void Add(long id, object fixupInfo);
    internal virtual void Add(FixupHolder fixup);
    private void EnlargeArray();
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Serialization.Formatter : object {
    protected ObjectIDGenerator m_idGenerator;
    protected Queue m_objectQueue;
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public abstract virtual object Deserialize(Stream serializationStream);
    protected virtual object GetNext(Int64& objID);
    protected virtual long Schedule(object obj);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
    protected abstract virtual void WriteArray(object obj, string name, Type memberType);
    protected abstract virtual void WriteBoolean(bool val, string name);
    protected abstract virtual void WriteByte(byte val, string name);
    protected abstract virtual void WriteChar(char val, string name);
    protected abstract virtual void WriteDateTime(DateTime val, string name);
    protected abstract virtual void WriteDecimal(decimal val, string name);
    protected abstract virtual void WriteDouble(double val, string name);
    protected abstract virtual void WriteInt16(short val, string name);
    protected abstract virtual void WriteInt32(int val, string name);
    protected abstract virtual void WriteInt64(long val, string name);
    protected abstract virtual void WriteObjectRef(object obj, string name, Type memberType);
    protected virtual void WriteMember(string memberName, object data);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteSByte(sbyte val, string name);
    protected abstract virtual void WriteSingle(float val, string name);
    protected abstract virtual void WriteTimeSpan(TimeSpan val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt16(ushort val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt32(UInt32 val, string name);
    [CLSCompliantAttribute("False")]
protected abstract virtual void WriteUInt64(ulong val, string name);
    protected abstract virtual void WriteValueType(object obj, string name, Type memberType);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
}
public class System.Runtime.Serialization.FormatterConverter : object {
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual char ToChar(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual sbyte ToSByte(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual short ToInt16(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ushort ToUInt16(object value);
    public sealed virtual int ToInt32(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual long ToInt64(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ulong ToUInt64(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual string ToString(object value);
    private static void ThrowValueNullException();
}
internal class System.Runtime.Serialization.Formatters.Binary.__BinaryParser : object {
    internal ObjectReader objectReader;
    internal Stream input;
    internal long topId;
    internal long headerId;
    internal SizedArray objectMapIdTable;
    internal SizedArray assemIdToAssemblyTable;
    internal SerStack stack;
    internal BinaryTypeEnum expectedType;
    internal object expectedTypeInformation;
    internal ParseRecord PRS;
    private BinaryAssemblyInfo systemAssemblyInfo;
    private BinaryReader dataReader;
    private static Encoding encoding;
    private SerStack opPool;
    private BinaryObject binaryObject;
    private BinaryObjectWithMap bowm;
    private BinaryObjectWithMapTyped bowmt;
    internal BinaryObjectString objectString;
    internal BinaryCrossAppDomainString crossAppDomainString;
    internal MemberPrimitiveTyped memberPrimitiveTyped;
    private Byte[] byteBuffer;
    private static int chunkSize;
    internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
    internal MemberReference memberReference;
    internal ObjectNull objectNull;
    internal static MessageEnd modreq(System.Runtime.CompilerServices.IsVolatile) messageEnd;
    internal BinaryAssemblyInfo SystemAssemblyInfo { get; }
    internal SizedArray ObjectMapIdTable { get; }
    internal SizedArray AssemIdToAssemblyTable { get; }
    internal ParseRecord prs { get; }
    internal __BinaryParser(Stream stream, ObjectReader objectReader);
    private static __BinaryParser();
    internal BinaryAssemblyInfo get_SystemAssemblyInfo();
    internal SizedArray get_ObjectMapIdTable();
    internal SizedArray get_AssemIdToAssemblyTable();
    internal ParseRecord get_prs();
    [SecurityCriticalAttribute]
internal void Run();
    internal void ReadBegin();
    internal void ReadEnd();
    internal bool ReadBoolean();
    internal byte ReadByte();
    internal Byte[] ReadBytes(int length);
    internal void ReadBytes(Byte[] byteA, int offset, int size);
    internal char ReadChar();
    internal Char[] ReadChars(int length);
    internal decimal ReadDecimal();
    internal float ReadSingle();
    internal double ReadDouble();
    internal short ReadInt16();
    internal int ReadInt32();
    internal long ReadInt64();
    internal sbyte ReadSByte();
    internal string ReadString();
    internal TimeSpan ReadTimeSpan();
    internal DateTime ReadDateTime();
    internal ushort ReadUInt16();
    internal UInt32 ReadUInt32();
    internal ulong ReadUInt64();
    [SecurityCriticalAttribute]
internal void ReadSerializationHeaderRecord();
    [SecurityCriticalAttribute]
internal void ReadAssembly(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
internal void ReadMethodObject(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadObject();
    [SecurityCriticalAttribute]
internal void ReadCrossAppDomainMap();
    [SecurityCriticalAttribute]
internal void ReadObjectWithMap(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadObjectWithMap(BinaryObjectWithMap record);
    [SecurityCriticalAttribute]
internal void ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadObjectWithMapTyped(BinaryObjectWithMapTyped record);
    [SecurityCriticalAttribute]
private void ReadObjectString(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadMemberPrimitiveTyped();
    [SecurityCriticalAttribute]
private void ReadArray(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadArrayAsBytes(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ReadMemberPrimitiveUnTyped();
    [SecurityCriticalAttribute]
private void ReadMemberReference();
    [SecurityCriticalAttribute]
private void ReadObjectNull(BinaryHeaderEnum binaryHeaderEnum);
    [SecurityCriticalAttribute]
private void ReadMessageEnd();
    internal object ReadValue(InternalPrimitiveTypeE code);
    private ObjectProgress GetOp();
    private void PutOp(ObjectProgress op);
}
internal class System.Runtime.Serialization.Formatters.Binary.__BinaryWriter : object {
    internal Stream sout;
    internal FormatterTypeStyle formatterTypeStyle;
    internal Hashtable objectMapTable;
    internal ObjectWriter objectWriter;
    internal BinaryWriter dataWriter;
    internal int m_nestedObjectCount;
    private int nullCount;
    internal BinaryMethodCall binaryMethodCall;
    internal BinaryMethodReturn binaryMethodReturn;
    internal BinaryObject binaryObject;
    internal BinaryObjectWithMap binaryObjectWithMap;
    internal BinaryObjectWithMapTyped binaryObjectWithMapTyped;
    internal BinaryObjectString binaryObjectString;
    internal BinaryArray binaryArray;
    private Byte[] byteBuffer;
    private int chunkSize;
    internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
    internal MemberPrimitiveTyped memberPrimitiveTyped;
    internal ObjectNull objectNull;
    internal MemberReference memberReference;
    internal BinaryAssembly binaryAssembly;
    internal __BinaryWriter(Stream sout, ObjectWriter objectWriter, FormatterTypeStyle formatterTypeStyle);
    internal void WriteBegin();
    internal void WriteEnd();
    internal void WriteBoolean(bool value);
    internal void WriteByte(byte value);
    private void WriteBytes(Byte[] value);
    private void WriteBytes(Byte[] byteA, int offset, int size);
    internal void WriteChar(char value);
    internal void WriteChars(Char[] value);
    internal void WriteDecimal(decimal value);
    internal void WriteSingle(float value);
    internal void WriteDouble(double value);
    internal void WriteInt16(short value);
    internal void WriteInt32(int value);
    internal void WriteInt64(long value);
    internal void WriteSByte(sbyte value);
    internal void WriteString(string value);
    internal void WriteTimeSpan(TimeSpan value);
    internal void WriteDateTime(DateTime value);
    internal void WriteUInt16(ushort value);
    internal void WriteUInt32(UInt32 value);
    internal void WriteUInt64(ulong value);
    internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo);
    internal void WriteSerializationHeaderEnd();
    internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion);
    internal void WriteMethodCall();
    internal Object[] WriteCallArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties);
    internal void WriteMethodReturn();
    internal Object[] WriteReturnArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties);
    internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, String[] memberNames, Type[] memberTypes, WriteObjectInfo[] memberObjectInfos);
    internal void WriteObjectString(int objectId, string value);
    [SecurityCriticalAttribute]
internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array);
    [SecurityCriticalAttribute]
private void WriteArrayAsBytes(Array array, int typeLength);
    internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound);
    internal void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, Int32[] lengthA, Int32[] lowerBoundA);
    [SecurityCriticalAttribute]
internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Byte[] byteA);
    internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, object value);
    internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo);
    internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef);
    internal void WriteMemberNested(NameInfo memberNameInfo);
    internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, string value);
    internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, object value);
    internal void WriteNullItem(NameInfo itemNameInfo, NameInfo typeNameInfo);
    internal void WriteDelayedNullItem();
    internal void WriteItemEnd();
    private void InternalWriteItemNull();
    internal void WriteItemObjectRef(NameInfo nameInfo, int idRef);
    internal void WriteAssembly(Type type, string assemblyString, int assemId, bool isNew);
    internal void WriteValue(InternalPrimitiveTypeE code, object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryArray : object {
    internal int objectId;
    internal int rank;
    internal Int32[] lengthA;
    internal Int32[] lowerBoundA;
    internal BinaryTypeEnum binaryTypeEnum;
    internal object typeInformation;
    internal int assemId;
    private BinaryHeaderEnum binaryHeaderEnum;
    internal BinaryArrayTypeEnum binaryArrayTypeEnum;
    internal BinaryArray(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, int rank, Int32[] lengthA, Int32[] lowerBoundA, BinaryTypeEnum binaryTypeEnum, object typeInformation, BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum : Enum {
    public int value__;
    public static BinaryArrayTypeEnum Single;
    public static BinaryArrayTypeEnum Jagged;
    public static BinaryArrayTypeEnum Rectangular;
    public static BinaryArrayTypeEnum SingleOffset;
    public static BinaryArrayTypeEnum JaggedOffset;
    public static BinaryArrayTypeEnum RectangularOffset;
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryAssembly : object {
    internal int assemId;
    internal string assemblyString;
    internal void Set(int assemId, string assemblyString);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo : object {
    internal string assemblyString;
    private Assembly assembly;
    internal BinaryAssemblyInfo(string assemblyString);
    internal BinaryAssemblyInfo(string assemblyString, Assembly assembly);
    internal Assembly GetAssembly();
}
internal static class System.Runtime.Serialization.Formatters.Binary.BinaryConverter : object {
    internal static BinaryTypeEnum GetBinaryTypeInfo(Type type, WriteObjectInfo objectInfo, string typeName, ObjectWriter objectWriter, Object& typeInformation, Int32& assemId);
    internal static BinaryTypeEnum GetParserBinaryTypeInfo(Type type, Object& typeInformation);
    internal static void WriteTypeInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, __BinaryWriter sout);
    internal static object ReadTypeInfo(BinaryTypeEnum binaryTypeEnum, __BinaryParser input, Int32& assemId);
    [SecurityCriticalAttribute]
internal static void TypeFromInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, ObjectReader objectReader, BinaryAssemblyInfo assemblyInfo, InternalPrimitiveTypeE& primitiveTypeEnum, String& typeString, Type& type, Boolean& isVariant);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainAssembly : object {
    internal int assemId;
    internal int assemblyIndex;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainMap : object {
    internal int crossAppDomainArrayIndex;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainString : object {
    internal int objectId;
    internal int value;
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.Binary.BinaryFormatter : object {
    internal ISurrogateSelector m_surrogates;
    internal StreamingContext m_context;
    internal SerializationBinder m_binder;
    internal FormatterTypeStyle m_typeFormat;
    internal FormatterAssemblyStyle m_assemblyFormat;
    internal TypeFilterLevel m_securityLevel;
    internal Object[] m_crossAppDomainArray;
    private static Dictionary`2<Type, TypeInformation> typeNameCache;
    public FormatterTypeStyle TypeFormat { get; public set; }
    public FormatterAssemblyStyle AssemblyFormat { get; public set; }
    public TypeFilterLevel FilterLevel { get; public set; }
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public BinaryFormatter(ISurrogateSelector selector, StreamingContext context);
    private static BinaryFormatter();
    public FormatterTypeStyle get_TypeFormat();
    public void set_TypeFormat(FormatterTypeStyle value);
    public FormatterAssemblyStyle get_AssemblyFormat();
    public void set_AssemblyFormat(FormatterAssemblyStyle value);
    public TypeFilterLevel get_FilterLevel();
    public void set_FilterLevel(TypeFilterLevel value);
    public sealed virtual ISurrogateSelector get_SurrogateSelector();
    public sealed virtual void set_SurrogateSelector(ISurrogateSelector value);
    public sealed virtual SerializationBinder get_Binder();
    public sealed virtual void set_Binder(SerializationBinder value);
    public sealed virtual StreamingContext get_Context();
    public sealed virtual void set_Context(StreamingContext value);
    public sealed virtual object Deserialize(Stream serializationStream);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck);
    [SecuritySafeCriticalAttribute]
public sealed virtual object Deserialize(Stream serializationStream, HeaderHandler handler);
    [SecuritySafeCriticalAttribute]
public object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler);
    [SecurityCriticalAttribute]
[ComVisibleAttribute("False")]
public object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage);
    public sealed virtual void Serialize(Stream serializationStream, object graph);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Serialize(Stream serializationStream, object graph, Header[] headers);
    [SecurityCriticalAttribute]
internal void Serialize(Stream serializationStream, object graph, Header[] headers, bool fCheck);
    internal static TypeInformation GetTypeInformation(Type type);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum : Enum {
    public int value__;
    public static BinaryHeaderEnum SerializedStreamHeader;
    public static BinaryHeaderEnum Object;
    public static BinaryHeaderEnum ObjectWithMap;
    public static BinaryHeaderEnum ObjectWithMapAssemId;
    public static BinaryHeaderEnum ObjectWithMapTyped;
    public static BinaryHeaderEnum ObjectWithMapTypedAssemId;
    public static BinaryHeaderEnum ObjectString;
    public static BinaryHeaderEnum Array;
    public static BinaryHeaderEnum MemberPrimitiveTyped;
    public static BinaryHeaderEnum MemberReference;
    public static BinaryHeaderEnum ObjectNull;
    public static BinaryHeaderEnum MessageEnd;
    public static BinaryHeaderEnum Assembly;
    public static BinaryHeaderEnum ObjectNullMultiple256;
    public static BinaryHeaderEnum ObjectNullMultiple;
    public static BinaryHeaderEnum ArraySinglePrimitive;
    public static BinaryHeaderEnum ArraySingleObject;
    public static BinaryHeaderEnum ArraySingleString;
    public static BinaryHeaderEnum CrossAppDomainMap;
    public static BinaryHeaderEnum CrossAppDomainString;
    public static BinaryHeaderEnum CrossAppDomainAssembly;
    public static BinaryHeaderEnum MethodCall;
    public static BinaryHeaderEnum MethodReturn;
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodCall : object {
    private string uri;
    private string methodName;
    private string typeName;
    private Type[] instArgs;
    private Object[] args;
    private object methodSignature;
    private object callContext;
    private string scallContext;
    private object properties;
    private Type[] argTypes;
    private bool bArgsPrimitive;
    private MessageEnum messageEnum;
    private Object[] callA;
    internal Object[] WriteArray(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, object callContext, Object[] properties);
    internal void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
internal void Read(__BinaryParser input);
    [SecurityCriticalAttribute]
internal IMethodCallMessage ReadArray(Object[] callA, object handlerObject);
    internal void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodCallMessage : object {
    private Object[] _inargs;
    private string _methodName;
    private string _typeName;
    private object _methodSignature;
    private Type[] _instArgs;
    private Object[] _args;
    [SecurityCriticalAttribute]
private LogicalCallContext _logicalCallContext;
    private Object[] _properties;
    public string MethodName { get; }
    public string TypeName { get; }
    public Type[] InstantiationArgs { get; }
    public object MethodSignature { get; }
    public Object[] Args { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public bool HasProperties { get; }
    [SecurityCriticalAttribute]
internal BinaryMethodCallMessage(string uri, string methodName, string typeName, Type[] instArgs, Object[] args, object methodSignature, LogicalCallContext callContext, Object[] properties);
    public string get_MethodName();
    public string get_TypeName();
    public Type[] get_InstantiationArgs();
    public object get_MethodSignature();
    public Object[] get_Args();
    [SecurityCriticalAttribute]
public LogicalCallContext get_LogicalCallContext();
    public bool get_HasProperties();
    internal void PopulateMessageProperties(IDictionary dict);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturn : object {
    private object returnValue;
    private Object[] args;
    private Exception exception;
    private object callContext;
    private string scallContext;
    private object properties;
    private Type[] argTypes;
    private bool bArgsPrimitive;
    private MessageEnum messageEnum;
    private Object[] callA;
    private Type returnType;
    private static object instanceOfVoid;
    [SecuritySafeCriticalAttribute]
private static BinaryMethodReturn();
    internal Object[] WriteArray(object returnValue, Object[] args, Exception exception, object callContext, Object[] properties);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    [SecurityCriticalAttribute]
internal IMethodReturnMessage ReadArray(Object[] returnA, IMethodCallMessage methodCallMessage, object handlerObject);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturnMessage : object {
    private Object[] _outargs;
    private Exception _exception;
    private object _returnValue;
    private Object[] _args;
    [SecurityCriticalAttribute]
private LogicalCallContext _logicalCallContext;
    private Object[] _properties;
    public Exception Exception { get; }
    public object ReturnValue { get; }
    public Object[] Args { get; }
    public LogicalCallContext LogicalCallContext { get; }
    public bool HasProperties { get; }
    [SecurityCriticalAttribute]
internal BinaryMethodReturnMessage(object returnValue, Object[] args, Exception e, LogicalCallContext callContext, Object[] properties);
    public Exception get_Exception();
    public object get_ReturnValue();
    public Object[] get_Args();
    [SecurityCriticalAttribute]
public LogicalCallContext get_LogicalCallContext();
    public bool get_HasProperties();
    internal void PopulateMessageProperties(IDictionary dict);
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObject : object {
    internal int objectId;
    internal int mapId;
    internal void Set(int objectId, int mapId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectString : object {
    internal int objectId;
    internal string value;
    internal void Set(int objectId, string value);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap : object {
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int objectId;
    internal string name;
    internal int numMembers;
    internal String[] memberNames;
    internal int assemId;
    internal BinaryObjectWithMap(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, string name, int numMembers, String[] memberNames, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped : object {
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int objectId;
    internal string name;
    internal int numMembers;
    internal String[] memberNames;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal Int32[] memberAssemIds;
    internal int assemId;
    internal BinaryObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum);
    internal void Set(int objectId, string name, int numMembers, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, int assemId);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
}
internal enum System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum : Enum {
    public int value__;
    public static BinaryTypeEnum Primitive;
    public static BinaryTypeEnum String;
    public static BinaryTypeEnum Object;
    public static BinaryTypeEnum ObjectUrt;
    public static BinaryTypeEnum ObjectUser;
    public static BinaryTypeEnum ObjectArray;
    public static BinaryTypeEnum StringArray;
    public static BinaryTypeEnum PrimitiveArray;
}
internal static class System.Runtime.Serialization.Formatters.Binary.BinaryUtil : object {
    [ConditionalAttribute("_LOGGING")]
public static void NVTraceI(string name, string value);
    [ConditionalAttribute("_LOGGING")]
public static void NVTraceI(string name, object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.Converter : object {
    private static int primitiveTypeEnumLength;
    private static Type[] modreq(System.Runtime.CompilerServices.IsVolatile) typeA;
    private static Type[] modreq(System.Runtime.CompilerServices.IsVolatile) arrayTypeA;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) valueA;
    private static TypeCode[] modreq(System.Runtime.CompilerServices.IsVolatile) typeCodeA;
    private static InternalPrimitiveTypeE[] modreq(System.Runtime.CompilerServices.IsVolatile) codeA;
    internal static Type typeofISerializable;
    internal static Type typeofString;
    internal static Type typeofConverter;
    internal static Type typeofBoolean;
    internal static Type typeofByte;
    internal static Type typeofChar;
    internal static Type typeofDecimal;
    internal static Type typeofDouble;
    internal static Type typeofInt16;
    internal static Type typeofInt32;
    internal static Type typeofInt64;
    internal static Type typeofSByte;
    internal static Type typeofSingle;
    internal static Type typeofTimeSpan;
    internal static Type typeofDateTime;
    internal static Type typeofUInt16;
    internal static Type typeofUInt32;
    internal static Type typeofUInt64;
    internal static Type typeofObject;
    internal static Type typeofSystemVoid;
    internal static Assembly urtAssembly;
    internal static string urtAssemblyString;
    internal static Type typeofTypeArray;
    internal static Type typeofObjectArray;
    internal static Type typeofStringArray;
    internal static Type typeofBooleanArray;
    internal static Type typeofByteArray;
    internal static Type typeofCharArray;
    internal static Type typeofDecimalArray;
    internal static Type typeofDoubleArray;
    internal static Type typeofInt16Array;
    internal static Type typeofInt32Array;
    internal static Type typeofInt64Array;
    internal static Type typeofSByteArray;
    internal static Type typeofSingleArray;
    internal static Type typeofTimeSpanArray;
    internal static Type typeofDateTimeArray;
    internal static Type typeofUInt16Array;
    internal static Type typeofUInt32Array;
    internal static Type typeofUInt64Array;
    internal static Type typeofMarshalByRefObject;
    private static Converter();
    internal static InternalPrimitiveTypeE ToCode(Type type);
    internal static bool IsWriteAsByteArray(InternalPrimitiveTypeE code);
    internal static int TypeLength(InternalPrimitiveTypeE code);
    internal static InternalNameSpaceE GetNameSpaceEnum(InternalPrimitiveTypeE code, Type type, WriteObjectInfo objectInfo, String& typeName);
    internal static Type ToArrayType(InternalPrimitiveTypeE code);
    private static void InitTypeA();
    private static void InitArrayTypeA();
    internal static Type ToType(InternalPrimitiveTypeE code);
    internal static Array CreatePrimitiveArray(InternalPrimitiveTypeE code, int length);
    internal static bool IsPrimitiveArray(Type type, Object& typeInformation);
    private static void InitValueA();
    internal static string ToComType(InternalPrimitiveTypeE code);
    private static void InitTypeCodeA();
    internal static TypeCode ToTypeCode(InternalPrimitiveTypeE code);
    private static void InitCodeA();
    internal static InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode);
    internal static object FromString(string value, InternalPrimitiveTypeE code);
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE : Enum {
    public int value__;
    public static InternalArrayTypeE Empty;
    public static InternalArrayTypeE Single;
    public static InternalArrayTypeE Jagged;
    public static InternalArrayTypeE Rectangular;
    public static InternalArrayTypeE Base64;
}
internal class System.Runtime.Serialization.Formatters.Binary.InternalFE : object {
    internal FormatterTypeStyle FEtypeFormat;
    internal FormatterAssemblyStyle FEassemblyFormat;
    internal TypeFilterLevel FEsecurityLevel;
    internal InternalSerializerTypeE FEserializerTypeEnum;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE : Enum {
    public int value__;
    public static InternalMemberTypeE Empty;
    public static InternalMemberTypeE Header;
    public static InternalMemberTypeE Field;
    public static InternalMemberTypeE Item;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE : Enum {
    public int value__;
    public static InternalMemberValueE Empty;
    public static InternalMemberValueE InlineValue;
    public static InternalMemberValueE Nested;
    public static InternalMemberValueE Reference;
    public static InternalMemberValueE Null;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalNameSpaceE : Enum {
    public int value__;
    public static InternalNameSpaceE None;
    public static InternalNameSpaceE Soap;
    public static InternalNameSpaceE XdrPrimitive;
    public static InternalNameSpaceE XdrString;
    public static InternalNameSpaceE UrtSystem;
    public static InternalNameSpaceE UrtUser;
    public static InternalNameSpaceE UserNameSpace;
    public static InternalNameSpaceE MemberName;
    public static InternalNameSpaceE Interop;
    public static InternalNameSpaceE CallElement;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalObjectPositionE : Enum {
    public int value__;
    public static InternalObjectPositionE Empty;
    public static InternalObjectPositionE Top;
    public static InternalObjectPositionE Child;
    public static InternalObjectPositionE Headers;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE : Enum {
    public int value__;
    public static InternalObjectTypeE Empty;
    public static InternalObjectTypeE Object;
    public static InternalObjectTypeE Array;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalParseTypeE : Enum {
    public int value__;
    public static InternalParseTypeE Empty;
    public static InternalParseTypeE SerializedStreamHeader;
    public static InternalParseTypeE Object;
    public static InternalParseTypeE Member;
    public static InternalParseTypeE ObjectEnd;
    public static InternalParseTypeE MemberEnd;
    public static InternalParseTypeE Headers;
    public static InternalParseTypeE HeadersEnd;
    public static InternalParseTypeE SerializedStreamHeaderEnd;
    public static InternalParseTypeE Envelope;
    public static InternalParseTypeE EnvelopeEnd;
    public static InternalParseTypeE Body;
    public static InternalParseTypeE BodyEnd;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE : Enum {
    public int value__;
    public static InternalPrimitiveTypeE Invalid;
    public static InternalPrimitiveTypeE Boolean;
    public static InternalPrimitiveTypeE Byte;
    public static InternalPrimitiveTypeE Char;
    public static InternalPrimitiveTypeE Currency;
    public static InternalPrimitiveTypeE Decimal;
    public static InternalPrimitiveTypeE Double;
    public static InternalPrimitiveTypeE Int16;
    public static InternalPrimitiveTypeE Int32;
    public static InternalPrimitiveTypeE Int64;
    public static InternalPrimitiveTypeE SByte;
    public static InternalPrimitiveTypeE Single;
    public static InternalPrimitiveTypeE TimeSpan;
    public static InternalPrimitiveTypeE DateTime;
    public static InternalPrimitiveTypeE UInt16;
    public static InternalPrimitiveTypeE UInt32;
    public static InternalPrimitiveTypeE UInt64;
    public static InternalPrimitiveTypeE Null;
    public static InternalPrimitiveTypeE String;
}
internal enum System.Runtime.Serialization.Formatters.Binary.InternalSerializerTypeE : Enum {
    public int value__;
    public static InternalSerializerTypeE Soap;
    public static InternalSerializerTypeE Binary;
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.Formatters.Binary.IntSizedArray : object {
    internal Int32[] objects;
    internal Int32[] negObjects;
    internal int Item { get; internal set; }
    private IntSizedArray(IntSizedArray sizedArray);
    public sealed virtual object Clone();
    internal int get_Item(int index);
    internal void set_Item(int index, int value);
    internal void IncreaseCapacity(int index);
}
internal static class System.Runtime.Serialization.Formatters.Binary.IOUtil : object {
    internal static bool FlagTest(MessageEnum flag, MessageEnum target);
    internal static void WriteStringWithCode(string value, __BinaryWriter sout);
    internal static void WriteWithCode(Type type, object value, __BinaryWriter sout);
    internal static object ReadWithCode(__BinaryParser input);
    internal static Object[] ReadArgs(__BinaryParser input);
}
internal interface System.Runtime.Serialization.Formatters.Binary.IStreamable {
    [SecurityCriticalAttribute]
public abstract virtual void Read(__BinaryParser input);
    public abstract virtual void Write(__BinaryWriter sout);
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped : object {
    internal InternalPrimitiveTypeE primitiveTypeEnum;
    internal object value;
    internal void Set(InternalPrimitiveTypeE primitiveTypeEnum, object value);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped : object {
    internal InternalPrimitiveTypeE typeInformation;
    internal object value;
    internal void Set(InternalPrimitiveTypeE typeInformation, object value);
    internal void Set(InternalPrimitiveTypeE typeInformation);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.MemberReference : object {
    internal int idRef;
    internal void Set(int idRef);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.MessageEnd : object {
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    public void Dump(Stream sout);
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal(Stream sout);
}
[FlagsAttribute]
internal enum System.Runtime.Serialization.Formatters.Binary.MessageEnum : Enum {
    public int value__;
    public static MessageEnum NoArgs;
    public static MessageEnum ArgsInline;
    public static MessageEnum ArgsIsArray;
    public static MessageEnum ArgsInArray;
    public static MessageEnum NoContext;
    public static MessageEnum ContextInline;
    public static MessageEnum ContextInArray;
    public static MessageEnum MethodSignatureInArray;
    public static MessageEnum PropertyInArray;
    public static MessageEnum NoReturnValue;
    public static MessageEnum ReturnValueVoid;
    public static MessageEnum ReturnValueInline;
    public static MessageEnum ReturnValueInArray;
    public static MessageEnum ExceptionInArray;
    public static MessageEnum GenericMethod;
}
internal class System.Runtime.Serialization.Formatters.Binary.NameCache : object {
    private static ConcurrentDictionary`2<string, object> ht;
    private string name;
    private static NameCache();
    internal object GetCachedValue(string name);
    internal void SetCachedValue(object value);
}
internal class System.Runtime.Serialization.Formatters.Binary.NameInfo : object {
    internal string NIFullName;
    internal long NIobjectId;
    internal long NIassemId;
    internal InternalPrimitiveTypeE NIprimitiveTypeEnum;
    internal Type NItype;
    internal bool NIisSealed;
    internal bool NIisArray;
    internal bool NIisArrayItem;
    internal bool NItransmitTypeOnObject;
    internal bool NItransmitTypeOnMember;
    internal bool NIisParentTypeOnObject;
    internal InternalArrayTypeE NIarrayEnum;
    private bool NIsealedStatusChecked;
    public bool IsSealed { get; }
    public string NIname { get; public set; }
    internal void Init();
    public bool get_IsSealed();
    public string get_NIname();
    public void set_NIname(string value);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectMap : object {
    internal string objectName;
    internal Type objectType;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal Type[] memberTypes;
    internal String[] memberNames;
    internal ReadObjectInfo objectInfo;
    internal bool isInitObjectInfo;
    internal ObjectReader objectReader;
    internal int objectId;
    internal BinaryAssemblyInfo assemblyInfo;
    [SecurityCriticalAttribute]
internal ObjectMap(string objectName, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
    [SecurityCriticalAttribute]
internal ObjectMap(string objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);
    internal ReadObjectInfo CreateObjectInfo(SerializationInfo& si, Object[]& memberData);
    [SecurityCriticalAttribute]
internal static ObjectMap Create(string name, Type objectType, String[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
    [SecurityCriticalAttribute]
internal static ObjectMap Create(string name, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectMapInfo : object {
    internal int objectId;
    private int numMembers;
    private String[] memberNames;
    private Type[] memberTypes;
    internal ObjectMapInfo(int objectId, int numMembers, String[] memberNames, Type[] memberTypes);
    internal bool isCompatible(int numMembers, String[] memberNames, Type[] memberTypes);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectNull : object {
    internal int nullCount;
    internal void SetNullCount(int nullCount);
    public sealed virtual void Write(__BinaryWriter sout);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Read(__BinaryParser input, BinaryHeaderEnum binaryHeaderEnum);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectProgress : object {
    internal static int opRecordIdCount;
    internal int opRecordId;
    internal bool isInitial;
    internal int count;
    internal BinaryTypeEnum expectedType;
    internal object expectedTypeInformation;
    internal string name;
    internal InternalObjectTypeE objectTypeEnum;
    internal InternalMemberTypeE memberTypeEnum;
    internal InternalMemberValueE memberValueEnum;
    internal Type dtType;
    internal int numItems;
    internal BinaryTypeEnum binaryTypeEnum;
    internal object typeInformation;
    internal int nullCount;
    internal int memberLength;
    internal BinaryTypeEnum[] binaryTypeEnumA;
    internal Object[] typeInformationA;
    internal String[] memberNames;
    internal Type[] memberTypes;
    internal ParseRecord pr;
    private static ObjectProgress();
    [ConditionalAttribute("SER_LOGGING")]
private void Counter();
    internal void Init();
    internal void ArrayCountIncrement(int value);
    internal bool GetNext(BinaryTypeEnum& outBinaryTypeEnum, Object& outTypeInformation);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectReader : object {
    internal Stream m_stream;
    internal ISurrogateSelector m_surrogates;
    internal StreamingContext m_context;
    internal ObjectManager m_objectManager;
    internal InternalFE formatterEnums;
    internal SerializationBinder m_binder;
    internal long topId;
    internal bool bSimpleAssembly;
    internal object handlerObject;
    internal object m_topObject;
    internal Header[] headers;
    internal HeaderHandler handler;
    internal SerObjectInfoInit serObjectInfoInit;
    internal IFormatterConverter m_formatterConverter;
    internal SerStack stack;
    private SerStack valueFixupStack;
    internal Object[] crossAppDomainArray;
    private bool bFullDeserialization;
    private bool bMethodCall;
    private bool bMethodReturn;
    private BinaryMethodCall binaryMethodCall;
    private BinaryMethodReturn binaryMethodReturn;
    private bool bIsCrossAppDomain;
    private static int THRESHOLD_FOR_VALUETYPE_IDS;
    private bool bOldFormatDetected;
    private IntSizedArray valTypeObjectIdTable;
    private NameCache typeCache;
    private string previousAssemblyString;
    private string previousName;
    private Type previousType;
    private SerStack ValueFixupStack { get; }
    internal object TopObject { get; internal set; }
    private bool IsRemoting { get; }
    internal ObjectReader(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
    private SerStack get_ValueFixupStack();
    internal object get_TopObject();
    internal void set_TopObject(object value);
    internal void SetMethodCall(BinaryMethodCall binaryMethodCall);
    internal void SetMethodReturn(BinaryMethodReturn binaryMethodReturn);
    [SecurityCriticalAttribute]
internal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck, bool isCrossAppDomain, IMethodCallMessage methodCallMessage);
    [SecurityCriticalAttribute]
private bool HasSurrogate(Type t);
    [SecurityCriticalAttribute]
private void CheckSerializable(Type t);
    [SecurityCriticalAttribute]
private void InitFullDeserialization();
    internal object CrossAppDomainArray(int index);
    [SecurityCriticalAttribute]
internal ReadObjectInfo CreateReadObjectInfo(Type objectType);
    [SecurityCriticalAttribute]
internal ReadObjectInfo CreateReadObjectInfo(Type objectType, String[] memberNames, Type[] memberTypes);
    [SecurityCriticalAttribute]
internal void Parse(ParseRecord pr);
    private void ParseError(ParseRecord processing, ParseRecord onStack);
    private void ParseSerializedStreamHeader(ParseRecord pr);
    private void ParseSerializedStreamHeaderEnd(ParseRecord pr);
    private bool get_IsRemoting();
    [SecurityCriticalAttribute]
internal void CheckSecurity(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseObject(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseObjectEnd(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseArray(ParseRecord pr);
    private void NextRectangleMap(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseArrayMember(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseArrayMemberEnd(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseMember(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseMemberEnd(ParseRecord pr);
    [SecurityCriticalAttribute]
private void ParseString(ParseRecord pr, ParseRecord parentPr);
    [SecurityCriticalAttribute]
private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr);
    [SecurityCriticalAttribute]
private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr, bool bIsString);
    [SecurityCriticalAttribute]
internal long GetId(long objectId);
    [ConditionalAttribute("SER_LOGGING")]
private void IndexTraceMessage(string message, Int32[] index);
    [SecurityCriticalAttribute]
internal Type Bind(string assemblyString, string typeString);
    [SecurityCriticalAttribute]
internal Type FastBindToType(string assemblyName, string typeName);
    [SecurityCriticalAttribute]
private static Assembly ResolveSimpleAssemblyName(AssemblyName assemblyName);
    [SecurityCriticalAttribute]
private static void GetSimplyNamedTypeFromAssembly(Assembly assm, string typeName, Type& type);
    [SecurityCriticalAttribute]
internal Type GetType(BinaryAssemblyInfo assemblyInfo, string name);
    [SecuritySafeCriticalAttribute]
private static void CheckTypeForwardedTo(Assembly sourceAssembly, Assembly destAssembly, Type resolvedType);
}
internal class System.Runtime.Serialization.Formatters.Binary.ObjectWriter : object {
    private Queue m_objectQueue;
    private ObjectIDGenerator m_idGenerator;
    private int m_currentId;
    private ISurrogateSelector m_surrogates;
    private StreamingContext m_context;
    private __BinaryWriter serWriter;
    private SerializationObjectManager m_objectManager;
    private long topId;
    private string topName;
    private Header[] headers;
    private InternalFE formatterEnums;
    private SerializationBinder m_binder;
    private SerObjectInfoInit serObjectInfoInit;
    private IFormatterConverter m_formatterConverter;
    internal Object[] crossAppDomainArray;
    internal ArrayList internalCrossAppDomainArray;
    private object previousObj;
    private long previousId;
    private Type previousType;
    private InternalPrimitiveTypeE previousCode;
    private Hashtable assemblyToIdTable;
    private SerStack niPool;
    internal SerializationObjectManager ObjectManager { get; }
    internal ObjectWriter(ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void Serialize(object graph, Header[] inHeaders, __BinaryWriter serWriter, bool fCheck);
    [SecurityCriticalAttribute]
private Object[] WriteMethodCall(IMethodCallMessage mcm);
    [SecurityCriticalAttribute]
private Object[] WriteMethodReturn(IMethodReturnMessage mrm);
    [SecurityCriticalAttribute]
private static Object[] StoreUserPropertiesForMethodMessage(IMethodMessage msg);
    internal SerializationObjectManager get_ObjectManager();
    [SecurityCriticalAttribute]
private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo);
    [SecurityCriticalAttribute]
private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, String[] memberNames, Type[] memberTypes, Object[] memberData, WriteObjectInfo[] memberObjectInfos);
    [SecurityCriticalAttribute]
private void WriteMemberSetup(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, string memberName, Type memberType, object memberData, WriteObjectInfo memberObjectInfo);
    [SecurityCriticalAttribute]
private void WriteMembers(NameInfo memberNameInfo, NameInfo memberTypeNameInfo, object memberData, WriteObjectInfo objectInfo, NameInfo typeNameInfo, WriteObjectInfo memberObjectInfo);
    [SecurityCriticalAttribute]
private void WriteArray(WriteObjectInfo objectInfo, NameInfo memberNameInfo, WriteObjectInfo memberObjectInfo);
    [SecurityCriticalAttribute]
private void WriteArrayMember(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, object data);
    [SecurityCriticalAttribute]
private void WriteRectangle(WriteObjectInfo objectInfo, int rank, Int32[] maxA, Array array, NameInfo arrayElemNameTypeInfo, Int32[] lowerBoundA);
    [ConditionalAttribute("SER_LOGGING")]
private void IndexTraceMessage(string message, Int32[] index);
    private object GetNext(Int64& objID);
    private long InternalGetId(object obj, bool assignUniqueIdToValueType, Type type, Boolean& isNew);
    private long Schedule(object obj, bool assignUniqueIdToValueType, Type type);
    private long Schedule(object obj, bool assignUniqueIdToValueType, Type type, WriteObjectInfo objectInfo);
    private bool WriteKnownValueClass(NameInfo memberNameInfo, NameInfo typeNameInfo, object data);
    private void WriteObjectRef(NameInfo nameInfo, long objectId);
    private void WriteString(NameInfo memberNameInfo, NameInfo typeNameInfo, object stringObject);
    private bool CheckForNull(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, object data);
    private void WriteSerializedStreamHeader(long topId, long headerId);
    private NameInfo TypeToNameInfo(Type type, WriteObjectInfo objectInfo, InternalPrimitiveTypeE code, NameInfo nameInfo);
    private NameInfo TypeToNameInfo(Type type);
    private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo);
    private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, NameInfo nameInfo);
    private void TypeToNameInfo(Type type, NameInfo nameInfo);
    private NameInfo MemberToNameInfo(string name);
    internal InternalPrimitiveTypeE ToCode(Type type);
    private long GetAssemblyId(WriteObjectInfo objectInfo);
    [SecurityCriticalAttribute]
private Type GetType(object obj);
    private NameInfo GetNameInfo();
    private bool CheckTypeFormat(FormatterTypeStyle test, FormatterTypeStyle want);
    private void PutNameInfo(NameInfo nameInfo);
}
internal class System.Runtime.Serialization.Formatters.Binary.ParseRecord : object {
    internal static int parseRecordIdCount;
    internal int PRparseRecordId;
    internal InternalParseTypeE PRparseTypeEnum;
    internal InternalObjectTypeE PRobjectTypeEnum;
    internal InternalArrayTypeE PRarrayTypeEnum;
    internal InternalMemberTypeE PRmemberTypeEnum;
    internal InternalMemberValueE PRmemberValueEnum;
    internal InternalObjectPositionE PRobjectPositionEnum;
    internal string PRname;
    internal string PRvalue;
    internal object PRvarValue;
    internal string PRkeyDt;
    internal Type PRdtType;
    internal InternalPrimitiveTypeE PRdtTypeCode;
    internal bool PRisVariant;
    internal bool PRisEnum;
    internal long PRobjectId;
    internal long PRidRef;
    internal string PRarrayElementTypeString;
    internal Type PRarrayElementType;
    internal bool PRisArrayVariant;
    internal InternalPrimitiveTypeE PRarrayElementTypeCode;
    internal int PRrank;
    internal Int32[] PRlengthA;
    internal Int32[] PRpositionA;
    internal Int32[] PRlowerBoundA;
    internal Int32[] PRupperBoundA;
    internal Int32[] PRindexMap;
    internal int PRmemberIndex;
    internal int PRlinearlength;
    internal Int32[] PRrectangularMap;
    internal bool PRisLowerBound;
    internal long PRtopId;
    internal long PRheaderId;
    internal ReadObjectInfo PRobjectInfo;
    internal bool PRisValueTypeFixup;
    internal object PRnewObj;
    internal Object[] PRobjectA;
    internal PrimitiveArray PRprimitiveArray;
    internal bool PRisRegistered;
    internal Object[] PRmemberData;
    internal SerializationInfo PRsi;
    internal int PRnullCount;
    private static ParseRecord();
    internal void Init();
}
internal class System.Runtime.Serialization.Formatters.Binary.PrimitiveArray : object {
    private InternalPrimitiveTypeE code;
    private Boolean[] booleanA;
    private Char[] charA;
    private Double[] doubleA;
    private Int16[] int16A;
    private Int32[] int32A;
    private Int64[] int64A;
    private SByte[] sbyteA;
    private Single[] singleA;
    private UInt16[] uint16A;
    private UInt32[] uint32A;
    private UInt64[] uint64A;
    internal PrimitiveArray(InternalPrimitiveTypeE code, Array array);
    internal void Init(InternalPrimitiveTypeE code, Array array);
    internal void SetValue(string value, int index);
}
internal class System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo : object {
    internal int objectInfoId;
    internal static int readObjectInfoCounter;
    internal Type objectType;
    internal ObjectManager objectManager;
    internal int count;
    internal bool isSi;
    internal bool isNamed;
    internal bool isTyped;
    internal bool bSimpleAssembly;
    internal SerObjectInfoCache cache;
    internal String[] wireMemberNames;
    internal Type[] wireMemberTypes;
    private int lastPosition;
    internal ISurrogateSelector surrogateSelector;
    internal ISerializationSurrogate serializationSurrogate;
    internal StreamingContext context;
    internal List`1<Type> memberTypesList;
    internal SerObjectInfoInit serObjectInfoInit;
    internal IFormatterConverter formatterConverter;
    internal void ObjectEnd();
    internal void PrepareForReuse();
    [SecurityCriticalAttribute]
internal static ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal static ReadObjectInfo Create(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
internal void Init(Type objectType, String[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
    [SecurityCriticalAttribute]
private void InitReadConstructor(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context);
    private void InitSiRead();
    private void InitNoMembers();
    [SecurityCriticalAttribute]
private void InitMemberInfo();
    internal MemberInfo GetMemberInfo(string name);
    internal Type GetType(string name);
    internal void AddValue(string name, object value, SerializationInfo& si, Object[]& memberData);
    internal void InitDataStore(SerializationInfo& si, Object[]& memberData);
    internal void RecordFixup(long objectId, string name, long idRef);
    [SecurityCriticalAttribute]
internal void PopulateObjectMembers(object obj, Object[] memberData);
    [ConditionalAttribute("SER_LOGGING")]
private void DumpPopulate(MemberInfo[] memberInfos, Object[] memberData);
    [ConditionalAttribute("SER_LOGGING")]
private void DumpPopulateSi();
    private int Position(string name);
    internal Type[] GetMemberTypes(String[] inMemberNames, Type objectType);
    internal Type GetMemberType(MemberInfo objMember);
    private static ReadObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit);
}
internal class System.Runtime.Serialization.Formatters.Binary.SerializationHeaderRecord : object {
    internal int binaryFormatterMajorVersion;
    internal int binaryFormatterMinorVersion;
    internal BinaryHeaderEnum binaryHeaderEnum;
    internal int topId;
    internal int headerId;
    internal int majorVersion;
    internal int minorVersion;
    internal SerializationHeaderRecord(BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion);
    public sealed virtual void Write(__BinaryWriter sout);
    private static int GetInt32(Byte[] buffer, int index);
    [SecurityCriticalAttribute]
public sealed virtual void Read(__BinaryParser input);
    public void Dump();
    [ConditionalAttribute("_LOGGING")]
private void DumpInternal();
}
internal class System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache : object {
    internal string fullTypeName;
    internal string assemblyString;
    internal bool hasTypeForwardedFrom;
    internal MemberInfo[] memberInfos;
    internal String[] memberNames;
    internal Type[] memberTypes;
    internal SerObjectInfoCache(string typeName, string assemblyName, bool hasTypeForwardedFrom);
    internal SerObjectInfoCache(Type type);
}
internal class System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit : object {
    internal Hashtable seenBeforeTable;
    internal int objectInfoIdCount;
    internal SerStack oiPool;
}
internal class System.Runtime.Serialization.Formatters.Binary.SerStack : object {
    internal Object[] objects;
    internal string stackId;
    internal int top;
    internal int next;
    internal SerStack(string stackId);
    internal void Push(object obj);
    internal object Pop();
    internal void IncreaseCapacity();
    internal object Peek();
    internal object PeekPeek();
    internal int Count();
    internal bool IsEmpty();
    [ConditionalAttribute("SER_LOGGING")]
internal void Dump();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.Serialization.Formatters.Binary.SizedArray : object {
    internal Object[] objects;
    internal Object[] negObjects;
    internal object Item { get; internal set; }
    internal SizedArray(int length);
    private SizedArray(SizedArray sizedArray);
    public sealed virtual object Clone();
    internal object get_Item(int index);
    internal void set_Item(int index, object value);
    internal void IncreaseCapacity(int index);
}
internal enum System.Runtime.Serialization.Formatters.Binary.SoapAttributeType : Enum {
    public int value__;
    public static SoapAttributeType None;
    public static SoapAttributeType SchemaType;
    public static SoapAttributeType Embedded;
    public static SoapAttributeType XmlElement;
    public static SoapAttributeType XmlAttribute;
}
internal class System.Runtime.Serialization.Formatters.Binary.TypeInformation : object {
    private string fullTypeName;
    private string assemblyString;
    private bool hasTypeForwardedFrom;
    internal string FullTypeName { get; }
    internal string AssemblyString { get; }
    internal bool HasTypeForwardedFrom { get; }
    internal TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
    internal string get_FullTypeName();
    internal string get_AssemblyString();
    internal bool get_HasTypeForwardedFrom();
}
internal class System.Runtime.Serialization.Formatters.Binary.ValueFixup : object {
    internal ValueFixupEnum valueFixupEnum;
    internal Array arrayObj;
    internal Int32[] indexMap;
    internal object header;
    internal object memberObject;
    internal static MemberInfo modreq(System.Runtime.CompilerServices.IsVolatile) valueInfo;
    internal ReadObjectInfo objectInfo;
    internal string memberName;
    internal ValueFixup(Array arrayObj, Int32[] indexMap);
    internal ValueFixup(object memberObject, string memberName, ReadObjectInfo objectInfo);
    [SecurityCriticalAttribute]
internal void Fixup(ParseRecord record, ParseRecord parent);
}
internal enum System.Runtime.Serialization.Formatters.Binary.ValueFixupEnum : Enum {
    public int value__;
    public static ValueFixupEnum Empty;
    public static ValueFixupEnum Array;
    public static ValueFixupEnum Header;
    public static ValueFixupEnum Member;
}
internal class System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo : object {
    internal int objectInfoId;
    internal object obj;
    internal Type objectType;
    internal bool isSi;
    internal bool isNamed;
    internal bool isTyped;
    internal bool isArray;
    internal SerializationInfo si;
    internal SerObjectInfoCache cache;
    internal Object[] memberData;
    internal ISerializationSurrogate serializationSurrogate;
    internal StreamingContext context;
    internal SerObjectInfoInit serObjectInfoInit;
    internal long objectId;
    internal long assemId;
    private string binderTypeName;
    private string binderAssemblyString;
    internal void ObjectEnd();
    private void InternalInit();
    [SecurityCriticalAttribute]
internal static WriteObjectInfo Serialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void InitSerialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
    [ConditionalAttribute("SER_LOGGING")]
private void DumpMemberInfo();
    [SecurityCriticalAttribute]
internal static WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
    [SecurityCriticalAttribute]
internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
    private void InitSiWrite();
    private static void CheckTypeForwardedFrom(SerObjectInfoCache cache, Type objectType, string binderAssemblyString);
    private void InitNoMembers();
    [SecurityCriticalAttribute]
private void InitMemberInfo();
    internal string GetTypeFullName();
    internal string GetAssemblyString();
    private void InvokeSerializationBinder(SerializationBinder binder);
    internal Type GetMemberType(MemberInfo objMember);
    internal void GetMemberInfo(String[]& outMemberNames, Type[]& outMemberTypes, Object[]& outMemberData);
    private static WriteObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit);
    private static void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, WriteObjectInfo objectInfo);
}
public enum System.Runtime.Serialization.Formatters.FormatterAssemblyStyle : Enum {
    public int value__;
    public static FormatterAssemblyStyle Simple;
    public static FormatterAssemblyStyle Full;
}
public enum System.Runtime.Serialization.Formatters.FormatterTypeStyle : Enum {
    public int value__;
    public static FormatterTypeStyle TypesWhenNeeded;
    public static FormatterTypeStyle TypesAlways;
    public static FormatterTypeStyle XsdString;
}
public interface System.Runtime.Serialization.Formatters.IFieldInfo {
    public String[] FieldNames { get; public set; }
    public Type[] FieldTypes { get; public set; }
    public abstract virtual String[] get_FieldNames();
    public abstract virtual void set_FieldNames(String[] value);
    public abstract virtual Type[] get_FieldTypes();
    public abstract virtual void set_FieldTypes(Type[] value);
}
[SecurityCriticalAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.InternalRM : object {
    [ConditionalAttribute("_LOGGING")]
public static void InfoSoap(Object[] messages);
    public static bool SoapCheckEnabled();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
public class System.Runtime.Serialization.Formatters.InternalST : object {
    [ConditionalAttribute("_LOGGING")]
public static void InfoSoap(Object[] messages);
    public static bool SoapCheckEnabled();
    [ConditionalAttribute("SER_LOGGING")]
public static void Soap(Object[] messages);
    [ConditionalAttribute("_DEBUG")]
public static void SoapAssert(bool condition, string message);
    public static void SerializationSetValue(FieldInfo fi, object target, object value);
    public static Assembly LoadAssemblyFromString(string assemblyString);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.Formatters.ISoapMessage {
    public String[] ParamNames { get; public set; }
    public Object[] ParamValues { get; public set; }
    public Type[] ParamTypes { get; public set; }
    public string MethodName { get; public set; }
    public string XmlNameSpace { get; public set; }
    public Header[] Headers { get; public set; }
    public abstract virtual String[] get_ParamNames();
    public abstract virtual void set_ParamNames(String[] value);
    public abstract virtual Object[] get_ParamValues();
    public abstract virtual void set_ParamValues(Object[] value);
    public abstract virtual Type[] get_ParamTypes();
    public abstract virtual void set_ParamTypes(Type[] value);
    public abstract virtual string get_MethodName();
    public abstract virtual void set_MethodName(string value);
    public abstract virtual string get_XmlNameSpace();
    public abstract virtual void set_XmlNameSpace(string value);
    public abstract virtual Header[] get_Headers();
    public abstract virtual void set_Headers(Header[] value);
}
internal static class System.Runtime.Serialization.Formatters.SerTrace : object {
    [ConditionalAttribute("_LOGGING")]
internal static void InfoLog(Object[] messages);
    [ConditionalAttribute("SER_LOGGING")]
internal static void Log(Object[] messages);
}
[SoapTypeAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.ServerFault : object {
    private string exceptionType;
    private string message;
    private string stackTrace;
    private Exception exception;
    public string ExceptionType { get; public set; }
    public string ExceptionMessage { get; public set; }
    public string StackTrace { get; public set; }
    internal Exception Exception { get; }
    internal ServerFault(Exception exception);
    public ServerFault(string exceptionType, string message, string stackTrace);
    public string get_ExceptionType();
    public void set_ExceptionType(string value);
    public string get_ExceptionMessage();
    public void set_ExceptionMessage(string value);
    public string get_StackTrace();
    public void set_StackTrace(string value);
    internal Exception get_Exception();
}
[SoapTypeAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.SoapFault : object {
    private string faultCode;
    private string faultString;
    private string faultActor;
    [SoapFieldAttribute]
private object detail;
    public string FaultCode { get; public set; }
    public string FaultString { get; public set; }
    public string FaultActor { get; public set; }
    public object Detail { get; public set; }
    public SoapFault(string faultCode, string faultString, string faultActor, ServerFault serverFault);
    internal SoapFault(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_FaultCode();
    public void set_FaultCode(string value);
    public string get_FaultString();
    public void set_FaultString(string value);
    public string get_FaultActor();
    public void set_FaultActor(string value);
    public object get_Detail();
    public void set_Detail(object value);
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.Formatters.SoapMessage : object {
    internal String[] paramNames;
    internal Object[] paramValues;
    internal Type[] paramTypes;
    internal string methodName;
    internal string xmlNameSpace;
    internal Header[] headers;
    public String[] ParamNames { get; public set; }
    public Object[] ParamValues { get; public set; }
    public Type[] ParamTypes { get; public set; }
    public string MethodName { get; public set; }
    public string XmlNameSpace { get; public set; }
    public Header[] Headers { get; public set; }
    public sealed virtual String[] get_ParamNames();
    public sealed virtual void set_ParamNames(String[] value);
    public sealed virtual Object[] get_ParamValues();
    public sealed virtual void set_ParamValues(Object[] value);
    public sealed virtual Type[] get_ParamTypes();
    public sealed virtual void set_ParamTypes(Type[] value);
    public sealed virtual string get_MethodName();
    public sealed virtual void set_MethodName(string value);
    public sealed virtual string get_XmlNameSpace();
    public sealed virtual void set_XmlNameSpace(string value);
    public sealed virtual Header[] get_Headers();
    public sealed virtual void set_Headers(Header[] value);
}
public enum System.Runtime.Serialization.Formatters.TypeFilterLevel : Enum {
    public int value__;
    public static TypeFilterLevel Low;
    public static TypeFilterLevel Full;
}
[ComVisibleAttribute("True")]
public static class System.Runtime.Serialization.FormatterServices : object {
    internal static ConcurrentDictionary`2<MemberHolder, MemberInfo[]> m_MemberInfoTable;
    [SecurityCriticalAttribute]
private static bool unsafeTypeForwardersIsEnabled;
    [SecurityCriticalAttribute]
private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) unsafeTypeForwardersIsEnabledInitialized;
    private static Type[] advancedTypes;
    private static Binder s_binder;
    [SecuritySafeCriticalAttribute]
private static FormatterServices();
    private static MemberInfo[] GetSerializableMembers(RuntimeType type);
    private static bool CheckSerializable(RuntimeType type);
    private static MemberInfo[] InternalGetSerializableMembers(RuntimeType type);
    private static bool GetParentTypes(RuntimeType parentType, RuntimeType[]& parentTypes, Int32& parentTypeCount);
    [SecurityCriticalAttribute]
public static MemberInfo[] GetSerializableMembers(Type type);
    [SecurityCriticalAttribute]
public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);
    public static void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel);
    [SecurityCriticalAttribute]
public static object GetUninitializedObject(Type type);
    [SecurityCriticalAttribute]
public static object GetSafeUninitializedObject(Type type);
    private static object nativeGetUninitializedObject(RuntimeType type);
    private static object nativeGetSafeUninitializedObject(RuntimeType type);
    private static bool GetEnableUnsafeTypeForwarders();
    [SecuritySafeCriticalAttribute]
internal static bool UnsafeTypeForwardersIsEnabled();
    [SecurityCriticalAttribute]
internal static void SerializationSetValue(MemberInfo fi, object target, object value);
    [SecurityCriticalAttribute]
public static object PopulateObjectMembers(object obj, MemberInfo[] members, Object[] data);
    [SecurityCriticalAttribute]
public static Object[] GetObjectData(object obj, MemberInfo[] members);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
public static ISerializationSurrogate GetSurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
    [SecurityCriticalAttribute]
public static Type GetTypeFromAssembly(Assembly assem, string name);
    internal static Assembly LoadAssemblyFromString(string assemblyName);
    internal static Assembly LoadAssemblyFromStringNoThrow(string assemblyName);
    internal static string GetClrAssemblyName(Type type, Boolean& hasTypeForwardedFrom);
    internal static string GetClrTypeFullName(Type type);
    private static string GetClrTypeFullNameForArray(Type type);
    private static string GetClrTypeFullNameForNonArrayTypes(Type type);
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[ComVisibleAttribute("True")]
public interface System.Runtime.Serialization.IFormatter {
    public ISurrogateSelector SurrogateSelector { get; public set; }
    public SerializationBinder Binder { get; public set; }
    public StreamingContext Context { get; public set; }
    public abstract virtual object Deserialize(Stream serializationStream);
    public abstract virtual void Serialize(Stream serializationStream, object graph);
    public abstract virtual ISurrogateSelector get_SurrogateSelector();
    public abstract virtual void set_SurrogateSelector(ISurrogateSelector value);
    public abstract virtual SerializationBinder get_Binder();
    public abstract virtual void set_Binder(SerializationBinder value);
    public abstract virtual StreamingContext get_Context();
    public abstract virtual void set_Context(StreamingContext value);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface System.Runtime.Serialization.ISerializationSurrogate {
    public abstract virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    public abstract virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
public interface System.Runtime.Serialization.ISurrogateSelector {
    public abstract virtual void ChainSelector(ISurrogateSelector selector);
    public abstract virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    public abstract virtual ISurrogateSelector GetNextSelector();
}
internal class System.Runtime.Serialization.LongList : object {
    private static int InitialSize;
    private Int64[] m_values;
    private int m_count;
    private int m_totalItems;
    private int m_currentItem;
    internal int Count { get; }
    internal long Current { get; }
    internal LongList(int startingSize);
    internal void Add(long value);
    internal int get_Count();
    internal void StartEnumeration();
    internal bool MoveNext();
    internal long get_Current();
    internal bool RemoveElement(long value);
    private void EnlargeArray();
}
internal class System.Runtime.Serialization.MemberHolder : object {
    internal MemberInfo[] _members;
    internal Type _memberType;
    internal StreamingContext _context;
    internal MemberHolder(Type type, StreamingContext ctx);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal static class System.Runtime.Serialization.ObjectCloneHelper : object {
    private static IFormatterConverter s_converter;
    private static StreamingContext s_cloneContext;
    private static ISerializationSurrogate s_RemotingSurrogate;
    private static ISerializationSurrogate s_ObjRefRemotingSurrogate;
    private static ObjectCloneHelper();
    [SecurityCriticalAttribute]
internal static object GetObjectData(object serObj, String& typeName, String& assemName, String[]& fieldNames, Object[]& fieldValues);
    [SecurityCriticalAttribute]
internal static SerializationInfo PrepareConstructorArgs(object serObj, String[] fieldNames, Object[] fieldValues, StreamingContext& context);
}
internal class System.Runtime.Serialization.ObjectHolder : object {
    internal static int INCOMPLETE_OBJECT_REFERENCE;
    internal static int HAS_ISERIALIZABLE;
    internal static int HAS_SURROGATE;
    internal static int REQUIRES_VALUETYPE_FIXUP;
    internal static int REQUIRES_DELAYED_FIXUP;
    internal static int SER_INFO_FIXED;
    internal static int VALUETYPE_FIXUP_PERFORMED;
    private object m_object;
    internal long m_id;
    private int m_missingElementsRemaining;
    private int m_missingDecendents;
    internal SerializationInfo m_serInfo;
    internal ISerializationSurrogate m_surrogate;
    internal FixupHolderList m_missingElements;
    internal LongList m_dependentObjects;
    internal ObjectHolder m_next;
    internal int m_flags;
    private bool m_markForFixupWhenAvailable;
    private ValueTypeFixupInfo m_valueFixup;
    private TypeLoadExceptionHolder m_typeLoad;
    private bool m_reachable;
    internal bool IsIncompleteObjectReference { get; internal set; }
    internal bool RequiresDelayedFixup { get; }
    internal bool RequiresValueTypeFixup { get; }
    internal bool ValueTypeFixupPerformed { get; internal set; }
    internal bool HasISerializable { get; }
    internal bool HasSurrogate { get; }
    internal bool CanSurrogatedObjectValueChange { get; }
    internal bool CanObjectValueChange { get; }
    internal int DirectlyDependentObjects { get; }
    internal int TotalDependentObjects { get; }
    internal bool Reachable { get; internal set; }
    internal bool TypeLoadExceptionReachable { get; }
    internal TypeLoadExceptionHolder TypeLoadException { get; internal set; }
    internal object ObjectValue { get; }
    internal SerializationInfo SerializationInfo { get; internal set; }
    internal ISerializationSurrogate Surrogate { get; }
    internal LongList DependentObjects { get; internal set; }
    internal bool RequiresSerInfoFixup { get; internal set; }
    internal ValueTypeFixupInfo ValueFixup { get; }
    internal bool CompletelyFixed { get; }
    internal long ContainerID { get; }
    internal ObjectHolder(long objID);
    internal ObjectHolder(object obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex);
    internal ObjectHolder(string obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, Int32[] arrayIndex);
    private void IncrementDescendentFixups(int amount);
    internal void DecrementFixupsRemaining(ObjectManager manager);
    internal void RemoveDependency(long id);
    internal void AddFixup(FixupHolder fixup, ObjectManager manager);
    private void UpdateDescendentDependencyChain(int amount, ObjectManager manager);
    internal void AddDependency(long dependentObject);
    [SecurityCriticalAttribute]
internal void UpdateData(object obj, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainer, FieldInfo field, Int32[] arrayIndex, ObjectManager manager);
    internal void MarkForCompletionWhenAvailable();
    internal void SetFlags();
    internal bool get_IsIncompleteObjectReference();
    internal void set_IsIncompleteObjectReference(bool value);
    internal bool get_RequiresDelayedFixup();
    internal bool get_RequiresValueTypeFixup();
    internal bool get_ValueTypeFixupPerformed();
    internal void set_ValueTypeFixupPerformed(bool value);
    internal bool get_HasISerializable();
    internal bool get_HasSurrogate();
    internal bool get_CanSurrogatedObjectValueChange();
    internal bool get_CanObjectValueChange();
    internal int get_DirectlyDependentObjects();
    internal int get_TotalDependentObjects();
    internal bool get_Reachable();
    internal void set_Reachable(bool value);
    internal bool get_TypeLoadExceptionReachable();
    internal TypeLoadExceptionHolder get_TypeLoadException();
    internal void set_TypeLoadException(TypeLoadExceptionHolder value);
    internal object get_ObjectValue();
    [SecurityCriticalAttribute]
internal void SetObjectValue(object obj, ObjectManager manager);
    internal SerializationInfo get_SerializationInfo();
    internal void set_SerializationInfo(SerializationInfo value);
    internal ISerializationSurrogate get_Surrogate();
    internal LongList get_DependentObjects();
    internal void set_DependentObjects(LongList value);
    internal bool get_RequiresSerInfoFixup();
    internal void set_RequiresSerInfoFixup(bool value);
    internal ValueTypeFixupInfo get_ValueFixup();
    internal bool get_CompletelyFixed();
    internal long get_ContainerID();
}
internal class System.Runtime.Serialization.ObjectHolderList : object {
    internal static int DefaultInitialSize;
    internal ObjectHolder[] m_values;
    internal int m_count;
    internal int Version { get; }
    internal int Count { get; }
    internal ObjectHolderList(int startingSize);
    internal virtual void Add(ObjectHolder value);
    internal ObjectHolderListEnumerator GetFixupEnumerator();
    private void EnlargeArray();
    internal int get_Version();
    internal int get_Count();
}
internal class System.Runtime.Serialization.ObjectHolderListEnumerator : object {
    private bool m_isFixupEnumerator;
    private ObjectHolderList m_list;
    private int m_startingVersion;
    private int m_currPos;
    internal ObjectHolder Current { get; }
    internal ObjectHolderListEnumerator(ObjectHolderList list, bool isFixupEnumerator);
    internal bool MoveNext();
    internal ObjectHolder get_Current();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.ObjectIDGenerator : object {
    private static int numbins;
    internal int m_currentCount;
    internal int m_currentSize;
    internal Int64[] m_ids;
    internal Object[] m_objs;
    private static Int32[] sizes;
    private static ObjectIDGenerator();
    private int FindElement(object obj, Boolean& found);
    public virtual long GetId(object obj, Boolean& firstTime);
    public virtual long HasId(object obj, Boolean& firstTime);
    private void Rehash();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.ObjectManager : object {
    private static int DefaultInitialSize;
    private static int MaxArraySize;
    private static int ArrayMask;
    private static int MaxReferenceDepth;
    private DeserializationEventHandler m_onDeserializationHandler;
    private SerializationEventHandler m_onDeserializedHandler;
    internal ObjectHolder[] m_objects;
    internal object m_topObject;
    internal ObjectHolderList m_specialFixupObjects;
    internal long m_fixupCount;
    internal ISurrogateSelector m_selector;
    internal StreamingContext m_context;
    internal object TopObject { get; internal set; }
    internal ObjectHolderList SpecialFixupObjects { get; }
    [SecuritySafeCriticalAttribute]
public ObjectManager(ISurrogateSelector selector, StreamingContext context);
    [SecurityCriticalAttribute]
internal ObjectManager(ISurrogateSelector selector, StreamingContext context, bool checkSecurity, bool isCrossAppDomain);
    private static ObjectManager();
    [SecurityCriticalAttribute]
private bool CanCallGetType(object obj);
    internal void set_TopObject(object value);
    internal object get_TopObject();
    internal ObjectHolderList get_SpecialFixupObjects();
    internal ObjectHolder FindObjectHolder(long objectID);
    internal ObjectHolder FindOrCreateObjectHolder(long objectID);
    private void AddObjectHolder(ObjectHolder holder);
    private bool GetCompletionInfo(FixupHolder fixup, ObjectHolder& holder, Object& member, bool bThrowIfMissing);
    [SecurityCriticalAttribute]
private void FixupSpecialObject(ObjectHolder holder);
    [SecurityCriticalAttribute]
private bool ResolveObjectReference(ObjectHolder holder);
    [SecurityCriticalAttribute]
private bool DoValueTypeFixup(FieldInfo memberToFix, ObjectHolder holder, object value);
    [ConditionalAttribute("SER_LOGGING")]
private void DumpValueTypeFixup(object obj, FieldInfo[] intermediateFields, FieldInfo memberToFix, object value);
    [SecurityCriticalAttribute]
internal void CompleteObject(ObjectHolder holder, bool bObjectFullyComplete);
    [SecurityCriticalAttribute]
private void DoNewlyRegisteredObjectFixups(ObjectHolder holder);
    public virtual object GetObject(long objectID);
    [SecurityCriticalAttribute]
public virtual void RegisterObject(object obj, long objectID);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
    internal void RegisterString(string obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
    [SecurityCriticalAttribute]
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, Int32[] arrayIndex);
    [SecurityCriticalAttribute]
internal void CompleteISerializableObject(object obj, SerializationInfo info, StreamingContext context);
    internal static RuntimeConstructorInfo GetConstructor(RuntimeType t);
    [SecuritySafeCriticalAttribute]
public virtual void DoFixups();
    private void RegisterFixup(FixupHolder fixup, long objectToBeFixed, long objectRequired);
    public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired);
    public virtual void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired);
    public virtual void RecordArrayElementFixup(long arrayToBeFixed, Int32[] indices, long objectRequired);
    public virtual void RaiseDeserializationEvent();
    internal virtual void AddOnDeserialization(DeserializationEventHandler handler);
    internal virtual void RemoveOnDeserialization(DeserializationEventHandler handler);
    [SecuritySafeCriticalAttribute]
internal virtual void AddOnDeserialized(object obj);
    internal virtual void RaiseOnDeserializedEvent(object obj);
    public void RaiseOnDeserializingEvent(object obj);
}
[AttributeUsageAttribute("64")]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    private StreamingContext m_streamingContext;
    private List`1<object> m_serializedStates;
    internal IList`1<object> SerializedStates { get; }
    public StreamingContext StreamingContext { get; }
    internal SafeSerializationEventArgs(StreamingContext streamingContext);
    public void AddSerializedState(ISafeSerializationData serializedState);
    internal IList`1<object> get_SerializedStates();
    public StreamingContext get_StreamingContext();
}
internal class System.Runtime.Serialization.SafeSerializationManager : object {
    private IList`1<object> m_serializedStates;
    private SerializationInfo m_savedSerializationInfo;
    private object m_realObject;
    private RuntimeType m_realType;
    [CompilerGeneratedAttribute]
private EventHandler`1<SafeSerializationEventArgs> SerializeObjectState;
    private static string RealTypeSerializationName;
    internal bool IsActive { get; }
    [SecurityCriticalAttribute]
private SafeSerializationManager(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    internal bool get_IsActive();
    [SecurityCriticalAttribute]
internal void CompleteSerialization(object serializedObject, SerializationInfo info, StreamingContext context);
    internal void CompleteDeserialization(object deserializedObject);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private sealed virtual override object System.Runtime.Serialization.IObjectReference.GetRealObject(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
public abstract class System.Runtime.Serialization.SerializationBinder : object {
    public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
    public abstract virtual Type BindToType(string assemblyName, string typeName);
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
public class System.Runtime.Serialization.SerializationEventHandler : MulticastDelegate {
    public SerializationEventHandler(object object, IntPtr method);
    public virtual void Invoke(StreamingContext context);
    public virtual IAsyncResult BeginInvoke(StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Runtime.Serialization.SerializationEvents : object {
    private List`1<MethodInfo> _onSerializingMethods;
    private List`1<MethodInfo> _onSerializedMethods;
    private List`1<MethodInfo> _onDeserializingMethods;
    private List`1<MethodInfo> _onDeserializedMethods;
    internal bool HasOnSerializingEvents { get; }
    internal SerializationEvents(Type t);
    private List`1<MethodInfo> GetMethodsWithAttribute(Type attribute, Type t);
    internal bool get_HasOnSerializingEvents();
    internal void InvokeOnSerializing(object obj, StreamingContext context);
    internal void InvokeOnDeserializing(object obj, StreamingContext context);
    internal void InvokeOnDeserialized(object obj, StreamingContext context);
    internal SerializationEventHandler AddOnSerialized(object obj, SerializationEventHandler handler);
    internal SerializationEventHandler AddOnDeserialized(object obj, SerializationEventHandler handler);
    private static void InvokeOnDelegate(object obj, StreamingContext context, List`1<MethodInfo> methods);
    private static SerializationEventHandler AddOnDelegate(object obj, SerializationEventHandler handler, List`1<MethodInfo> methods);
}
internal static class System.Runtime.Serialization.SerializationEventsCache : object {
    private static ConcurrentDictionary`2<Type, SerializationEvents> s_cache;
    private static SerializationEventsCache();
    internal static SerializationEvents GetSerializationEventsForType(Type t);
}
public class System.Runtime.Serialization.SerializationException : SystemException {
    private static string s_nullMessage;
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    private static SerializationException();
}
internal class System.Runtime.Serialization.SerializationFieldInfo : FieldInfo {
    internal static string FakeNameSeparatorString;
    private RuntimeFieldInfo m_field;
    private string m_serializationName;
    private RemotingFieldCachedData m_cachedData;
    public Module Module { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    internal RuntimeFieldInfo FieldInfo { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    internal RemotingFieldCachedData RemotingCache { get; }
    internal SerializationFieldInfo(RuntimeFieldInfo field, string namePrefix);
    public virtual Module get_Module();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    [SecurityCriticalAttribute]
internal object InternalGetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [SecurityCriticalAttribute]
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    internal RuntimeFieldInfo get_FieldInfo();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    internal RemotingFieldCachedData get_RemotingCache();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SerializationInfo : object {
    private static int defaultSize;
    private static string s_mscorlibAssemblySimpleName;
    private static string s_mscorlibFileName;
    internal String[] m_members;
    internal Object[] m_data;
    internal Type[] m_types;
    private Dictionary`2<string, int> m_nameToIndex;
    internal int m_currMember;
    internal IFormatterConverter m_converter;
    private string m_fullTypeName;
    private string m_assemName;
    private Type objectType;
    private bool isFullTypeNameSetExplicit;
    private bool isAssemblyNameSetExplicit;
    private bool requireSameTokenInPartialTrust;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public bool IsAssemblyNameSetExplicit { get; }
    internal String[] MemberNames { get; }
    internal Object[] MemberValues { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    [SecuritySafeCriticalAttribute]
public void set_AssemblyName(string value);
    [SecuritySafeCriticalAttribute]
public void SetType(Type type);
    private static bool Compare(Byte[] a, Byte[] b);
    [SecuritySafeCriticalAttribute]
internal static void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
    internal static bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName);
    public int get_MemberCount();
    public Type get_ObjectType();
    public bool get_IsFullTypeNameSetExplicit();
    public bool get_IsAssemblyNameSetExplicit();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    internal void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    [ComVisibleAttribute("True")]
private object GetElementNoThrow(string name, Type& foundType);
    [SecuritySafeCriticalAttribute]
public object GetValue(string name, Type type);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("True")]
internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
    internal String[] get_MemberNames();
    internal Object[] get_MemberValues();
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    public object get_Value();
    public Type get_ObjectType();
}
public class System.Runtime.Serialization.SerializationObjectManager : object {
    private Dictionary`2<object, object> _objectSeenTable;
    private StreamingContext _context;
    private SerializationEventHandler _onSerializedHandler;
    public SerializationObjectManager(StreamingContext context);
    public void RegisterObject(object obj);
    public void RaiseOnSerializedEvent();
    private void AddOnSerialized(object obj);
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    internal object m_additionalContext;
    internal StreamingContextStates m_state;
    public object Context { get; }
    public StreamingContextStates State { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public object get_Context();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
internal class System.Runtime.Serialization.SurrogateForCyclicalReference : object {
    private ISerializationSurrogate innerSurrogate;
    internal SurrogateForCyclicalReference(ISerializationSurrogate innerSurrogate);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);
}
internal class System.Runtime.Serialization.SurrogateHashtable : Hashtable {
    internal SurrogateHashtable(int size);
    protected virtual bool KeyEquals(object key, object item);
}
internal class System.Runtime.Serialization.SurrogateKey : object {
    internal Type m_type;
    internal StreamingContext m_context;
    internal SurrogateKey(Type type, StreamingContext context);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("True")]
public class System.Runtime.Serialization.SurrogateSelector : object {
    internal SurrogateHashtable m_surrogates;
    internal ISurrogateSelector m_nextSelector;
    public virtual void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate);
    [SecurityCriticalAttribute]
private static bool HasCycle(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public virtual void ChainSelector(ISurrogateSelector selector);
    [SecurityCriticalAttribute]
public virtual ISurrogateSelector GetNextSelector();
    [SecurityCriticalAttribute]
public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector);
    public virtual void RemoveSurrogate(Type type, StreamingContext context);
}
internal class System.Runtime.Serialization.TypeLoadExceptionHolder : object {
    private string m_typeName;
    internal string TypeName { get; }
    internal TypeLoadExceptionHolder(string typeName);
    internal string get_TypeName();
}
internal class System.Runtime.Serialization.ValueTypeFixupInfo : object {
    private long _containerID;
    private FieldInfo _parentField;
    private Int32[] _parentIndex;
    public long ContainerID { get; }
    public FieldInfo ParentField { get; }
    public Int32[] ParentIndex { get; }
    public ValueTypeFixupInfo(long containerID, FieldInfo member, Int32[] parentIndex);
    public long get_ContainerID();
    public FieldInfo get_ParentField();
    public Int32[] get_ParentIndex();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
internal static class System.Runtime.Versioning.BinaryCompatibility : object {
    public static bool TargetsAtLeast_Desktop_V4_5;
    public static bool TargetsAtLeast_Desktop_V4_5_1;
    public static bool TargetsAtLeast_Desktop_V4_5_2 { get; }
    private static BinaryCompatibility();
    public static bool get_TargetsAtLeast_Desktop_V4_5_2();
}
public static class System.Runtime.Versioning.CompatibilitySwitch : object {
    public static bool IsEnabled(string compatibilitySwitchName);
    public static string GetValue(string compatibilitySwitchName);
    internal static string GetValueInternal(string compatibilitySwitchName);
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComponentGuaranteesOptions <Guarantees>k__BackingField;
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    [CompilerGeneratedAttribute]
public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
internal static class System.Runtime.Versioning.MultitargetingHelpers : object {
    internal static string GetAssemblyQualifiedName(Type type, Func`2<Type, string> converter);
    private static bool IsCriticalException(Exception ex);
    private static bool IsSecurityOrCriticalException(Exception ex);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    private ResourceScope _consumptionScope;
    private ResourceScope _resourceScope;
    public ResourceScope ResourceScope { get; }
    public ResourceScope ConsumptionScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    public ResourceScope get_ResourceScope();
    public ResourceScope get_ConsumptionScope();
}
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
[AttributeUsageAttribute("480")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    private ResourceScope _resourceExposureLevel;
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[FlagsAttribute]
internal enum System.Runtime.Versioning.SxSRequirements : Enum {
    public int value__;
    public static SxSRequirements None;
    public static SxSRequirements AppDomainID;
    public static SxSRequirements ProcessID;
    public static SxSRequirements CLRInstanceID;
    public static SxSRequirements AssemblyName;
    public static SxSRequirements TypeName;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
}
[FriendAccessAllowedAttribute]
internal enum System.Runtime.Versioning.TargetFrameworkId : Enum {
    public int value__;
    public static TargetFrameworkId NotYetChecked;
    public static TargetFrameworkId Unrecognized;
    public static TargetFrameworkId Unspecified;
    public static TargetFrameworkId NetFramework;
    public static TargetFrameworkId Portable;
    public static TargetFrameworkId NetCore;
    public static TargetFrameworkId Silverlight;
    public static TargetFrameworkId Phone;
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    private static ResourceScope ResTypeMask;
    private static ResourceScope VisibilityMask;
    [SecuritySafeCriticalAttribute]
private static int GetRuntimeId();
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    [SecuritySafeCriticalAttribute]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
    private static string GetCLRInstanceString();
    private static SxSRequirements GetRequirements(ResourceScope consumeAsScope, ResourceScope calleeScope);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    internal IntPtr args;
}
[ComVisibleAttribute("True")]
public class System.RuntimeFieldHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IntPtr v);
    private RuntimeFieldHandle(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    internal bool IsNullHandle();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeFieldHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    private static void SetValueInternal(FieldInfo fi, object obj, object value);
    internal static void SetValue(RuntimeFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized);
    internal static object GetValueDirect(RuntimeFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    internal static void SetValueDirect(RuntimeFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
}
[ComVisibleAttribute("True")]
public class System.RuntimeMethodHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IntPtr v);
    private RuntimeMethodHandle(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static IntPtr GetFunctionPointer(IntPtr m);
    public IntPtr GetFunctionPointer();
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeMethodHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    internal static string ConstructInstantiation(RuntimeMethodInfo method, TypeNameFormatFlags format);
    internal bool IsNullHandle();
}
internal class System.RuntimeMethodHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal static RuntimeMethodHandleInternal EmptyHandle { get; }
    internal IntPtr Value { get; }
    internal RuntimeMethodHandleInternal(IntPtr value);
    internal static RuntimeMethodHandleInternal get_EmptyHandle();
    internal bool IsNullHandle();
    internal IntPtr get_Value();
}
internal class System.RuntimeType : TypeInfo {
    internal static RuntimeType ValueType;
    internal static RuntimeType EnumType;
    private static RuntimeType ObjectType;
    private static RuntimeType StringType;
    private static RuntimeType DelegateType;
    private static Type[] s_SICtorParamTypes;
    internal static Func`3<Type, Type[], Type> MakeTypeBuilderInstantiation;
    private static BindingFlags MemberBindingMask;
    private static BindingFlags InvocationMask;
    private static BindingFlags BinderNonCreateInstance;
    private static BindingFlags BinderGetSetProperty;
    private static BindingFlags BinderSetInvokeProperty;
    private static BindingFlags BinderGetSetField;
    private static BindingFlags BinderSetInvokeField;
    private static BindingFlags BinderNonFieldGetSet;
    private static BindingFlags ClassicBindingMask;
    private static RuntimeType s_typedRef;
    private MonoTypeInfo type_info;
    internal object GenericCache;
    private RuntimeConstructorInfo m_serializationCtor;
    private static Dictionary`2<Guid, Type> clsid_types;
    private static AssemblyBuilder clsid_assemblybuilder;
    private static int GenericParameterCountAny;
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsEnum { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    internal bool IsSzArray { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public bool ContainsGenericParameters { get; }
    public Guid GUID { get; }
    public MethodBase DeclaringMethod { get; }
    public string AssemblyQualifiedName { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public string FullName { get; }
    public bool IsSZArray { get; }
    internal bool IsUserType { get; }
    public bool IsByRefLike { get; }
    public bool IsTypeDefinition { get; }
    internal RuntimeType(object obj);
    private static RuntimeType();
    internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark);
    private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
    private static void SplitName(string fullname, String& name, String& ns);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType);
    private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
    private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
    private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
    private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    internal bool IsSpecialSerializableType();
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, int genericParamCount, bool allowPrefixLookup);
    private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [ComVisibleAttribute("True")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetInterface(string fullname, bool ignoreCase);
    public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [ReliabilityContractAttribute("3", "2")]
internal sealed virtual RuntimeTypeHandle GetTypeHandleInternal();
    [SecuritySafeCriticalAttribute]
public virtual bool IsInstanceOfType(object o);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type get_BaseType();
    private RuntimeType GetBaseType();
    public virtual Type get_UnderlyingSystemType();
    [SecuritySafeCriticalAttribute]
protected virtual TypeAttributes GetAttributeFlagsImpl();
    [SecuritySafeCriticalAttribute]
protected virtual bool IsContextfulImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    [SecuritySafeCriticalAttribute]
protected virtual bool IsCOMObjectImpl();
    [SecuritySafeCriticalAttribute]
internal virtual bool IsWindowsRuntimeObjectImpl();
    [SecuritySafeCriticalAttribute]
internal virtual bool IsExportedToWindowsRuntimeImpl();
    [SecurityCriticalAttribute]
private static bool IsWindowsRuntimeObjectType(RuntimeType type);
    [SecurityCriticalAttribute]
private static bool IsTypeExportedToWindowsRuntime(RuntimeType type);
    [SecuritySafeCriticalAttribute]
internal virtual bool HasProxyAttributeImpl();
    internal bool IsDelegate();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsEnum();
    protected virtual bool HasElementTypeImpl();
    [SecuritySafeCriticalAttribute]
public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal virtual bool get_IsSzArray();
    protected virtual bool IsArrayImpl();
    [SecuritySafeCriticalAttribute]
public virtual int GetArrayRank();
    public virtual Type GetElementType();
    public virtual String[] GetEnumNames();
    [SecuritySafeCriticalAttribute]
public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    [SecuritySafeCriticalAttribute]
public virtual Type MakeGenericType(Type[] instantiation);
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual MemberInfo[] GetDefaultMembers();
    [DebuggerStepThroughAttribute]
[SecuritySafeCriticalAttribute]
[DebuggerHiddenAttribute]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RuntimeType left, RuntimeType right);
    public static bool op_Inequality(RuntimeType left, RuntimeType right);
    public sealed virtual object Clone();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [SecuritySafeCriticalAttribute]
public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal virtual string FormatTypeName(bool serialization);
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    [SecuritySafeCriticalAttribute]
public virtual int get_MetadataToken();
    private void CreateInstanceCheckThis();
    [SecurityCriticalAttribute]
internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark);
    private object ActivationCreateInstance(MethodBase invokeMethod, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [SecuritySafeCriticalAttribute]
[DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, bool wrapExceptions, StackCrawlMark& stackMark);
    internal RuntimeConstructorInfo GetDefaultConstructor();
    private MethodInfo GetCorrespondingInflatedMethod(MethodInfo generic);
    private ConstructorInfo GetCorrespondingInflatedConstructor(ConstructorInfo generic);
    internal virtual MethodInfo GetMethod(MethodInfo fromNoninstanciated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    private string GetDefaultMemberName();
    internal RuntimeConstructorInfo GetSerializationCtor();
    internal object CreateInstanceSlow(bool publicOnly, bool wrapExceptions, bool skipCheckThis, bool fillCache);
    private object CreateInstanceMono(bool nonPublic, bool wrapExceptions);
    internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private object TryConvertToType(object value, Boolean& failed);
    private static object IsConvertibleToPrimitiveType(object value, Type targetType);
    private string GetCachedName(TypeNameKind kind);
    private Type make_array_type(int rank);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    private Type make_byref_type();
    public virtual Type MakeByRefType();
    private static Type MakePointerType(Type type);
    public virtual Type MakePointerType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    internal static object CreateInstanceForAnotherGenericParameter(Type genericType, RuntimeType genericArgument);
    private static Type MakeGenericType(Type gt, Type[] types);
    internal IntPtr GetMethodsByName_native(IntPtr namePtr, BindingFlags bindingAttr, MemberListType listType);
    internal RuntimeMethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    private IntPtr GetPropertiesByName_native(IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private IntPtr GetConstructors_native(BindingFlags bindingAttr);
    private RuntimeConstructorInfo[] GetConstructors_internal(BindingFlags bindingAttr, RuntimeType reflectedType);
    private RuntimePropertyInfo[] GetPropertiesByName(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    public virtual InterfaceMapping GetInterfaceMap(Type ifaceType);
    private static void GetInterfaceMapData(Type t, Type iface, MethodInfo[]& targets, MethodInfo[]& methods);
    private static void GetGUID(Type type, Byte[] guid);
    public virtual Guid get_GUID();
    internal void GetPacking(Int32& packing, Int32& size);
    internal static Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError);
    protected virtual TypeCode GetTypeCodeImpl();
    private static TypeCode GetTypeCodeImplInternal(Type type);
    internal static Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
    public virtual string ToString();
    private bool IsGenericCOMObjectImpl();
    private static object CreateInstanceInternal(Type type);
    public virtual MethodBase get_DeclaringMethod();
    internal string getFullName(bool full_name, bool assembly_qualified);
    private Type[] GetGenericArgumentsInternal(bool runtimeArray);
    private GenericParameterAttributes GetGenericParameterAttributes();
    private int GetGenericParameterPosition();
    private IntPtr GetEvents_native(IntPtr name, MemberListType listType);
    private IntPtr GetFields_native(IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private RuntimeFieldInfo[] GetFields_internal(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    private RuntimeEventInfo[] GetEvents_internal(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    public virtual Type[] GetInterfaces();
    private IntPtr GetNestedTypes_native(IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private RuntimeType[] GetNestedTypes_internal(string displayName, BindingFlags bindingAttr, MemberListType listType);
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public int get_core_clr_security_level();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual int GetHashCode();
    public virtual string get_FullName();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual bool get_IsSZArray();
    internal virtual bool get_IsUserType();
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type type);
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsTypeDefinition();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    private MethodInfo GetMethodImplCommon(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, int genericParameterCount, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
}
[ComVisibleAttribute("True")]
public class System.RuntimeTypeHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(IntPtr val);
    internal RuntimeTypeHandle(RuntimeType type);
    private RuntimeTypeHandle(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [ReliabilityContractAttribute("3", "2")]
public virtual bool Equals(object obj);
    [ReliabilityContractAttribute("3", "2")]
public bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    internal static TypeAttributes GetAttributes(RuntimeType type);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
public ModuleHandle GetModuleHandle();
    private static int GetMetadataToken(RuntimeType type);
    internal static int GetToken(RuntimeType type);
    private static Type GetGenericTypeDefinition_impl(RuntimeType type);
    internal static Type GetGenericTypeDefinition(RuntimeType type);
    internal static bool HasProxyAttribute(RuntimeType type);
    internal static bool IsPrimitive(RuntimeType type);
    internal static bool IsByRef(RuntimeType type);
    internal static bool IsPointer(RuntimeType type);
    internal static bool IsArray(RuntimeType type);
    internal static bool IsSzArray(RuntimeType type);
    internal static bool HasElementType(RuntimeType type);
    internal static CorElementType GetCorElementType(RuntimeType type);
    internal static bool HasInstantiation(RuntimeType type);
    internal static bool IsComObject(RuntimeType type);
    internal static bool IsInstanceOfType(RuntimeType type, object o);
    internal static bool HasReferences(RuntimeType type);
    internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    internal static bool IsContextful(RuntimeType type);
    internal static bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2);
    internal static bool IsInterface(RuntimeType type);
    internal static int GetArrayRank(RuntimeType type);
    internal static RuntimeAssembly GetAssembly(RuntimeType type);
    internal static RuntimeType GetElementType(RuntimeType type);
    internal static RuntimeModule GetModule(RuntimeType type);
    internal static bool IsGenericVariable(RuntimeType type);
    internal static RuntimeType GetBaseType(RuntimeType type);
    internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    private static bool type_is_assignable_from(Type a, Type b);
    internal static bool IsGenericTypeDefinition(RuntimeType type);
    internal static IntPtr GetGenericParameterInfo(RuntimeType type);
    internal static bool IsSubclassOf(RuntimeType childType, RuntimeType baseType);
    internal static bool is_subclass_of(IntPtr childType, IntPtr baseType);
    [PreserveDependencyAttribute(".ctor()", "System.Runtime.CompilerServices.IsByRefLikeAttribute")]
internal static bool IsByRefLike(RuntimeType type);
    internal static bool IsTypeDefinition(RuntimeType type);
    private static RuntimeType internal_from_name(string name, StackCrawlMark& stackMark, Assembly callerAssembly, bool throwOnError, bool ignoreCase, bool reflectionOnly);
    internal static RuntimeType GetTypeByName(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, bool loadTypeFromPartialName);
    internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
}
[CLSCompliantAttribute("False")]
[IsReadOnlyAttribute]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static sbyte Parse(string s, NumberStyles style, NumberFormatInfo info);
    private static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlActions : Enum {
    public int value__;
    public static AccessControlActions None;
    public static AccessControlActions View;
    public static AccessControlActions Change;
}
public enum System.Security.AccessControl.AccessControlModification : Enum {
    public int value__;
    public static AccessControlModification Add;
    public static AccessControlModification Set;
    public static AccessControlModification Reset;
    public static AccessControlModification Remove;
    public static AccessControlModification RemoveAll;
    public static AccessControlModification RemoveSpecific;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlSections : Enum {
    public int value__;
    public static AccessControlSections None;
    public static AccessControlSections Audit;
    public static AccessControlSections Access;
    public static AccessControlSections Owner;
    public static AccessControlSections Group;
    public static AccessControlSections All;
}
public enum System.Security.AccessControl.AccessControlType : Enum {
    public int value__;
    public static AccessControlType Allow;
    public static AccessControlType Deny;
}
public abstract class System.Security.AccessControl.AccessRule : AuthorizationRule {
    private AccessControlType type;
    public AccessControlType AccessControlType { get; }
    protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessControlType get_AccessControlType();
}
public class System.Security.AccessControl.AccessRule`1 : AccessRule {
    public T Rights { get; }
    public AccessRule`1(string identity, T rights, AccessControlType type);
    public AccessRule`1(IdentityReference identity, T rights, AccessControlType type);
    public AccessRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal AccessRule`1(IdentityReference identity, int rights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public T get_Rights();
}
public class System.Security.AccessControl.AceEnumerator : object {
    private GenericAcl owner;
    private int current;
    public GenericAce Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AceEnumerator(GenericAcl owner);
    public GenericAce get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[FlagsAttribute]
public enum System.Security.AccessControl.AceFlags : Enum {
    public byte value__;
    public static AceFlags None;
    public static AceFlags ObjectInherit;
    public static AceFlags ContainerInherit;
    public static AceFlags NoPropagateInherit;
    public static AceFlags InheritOnly;
    public static AceFlags InheritanceFlags;
    public static AceFlags Inherited;
    public static AceFlags SuccessfulAccess;
    public static AceFlags FailedAccess;
    public static AceFlags AuditFlags;
}
public enum System.Security.AccessControl.AceQualifier : Enum {
    public int value__;
    public static AceQualifier AccessAllowed;
    public static AceQualifier AccessDenied;
    public static AceQualifier SystemAudit;
    public static AceQualifier SystemAlarm;
}
public enum System.Security.AccessControl.AceType : Enum {
    public byte value__;
    public static AceType AccessAllowed;
    public static AceType AccessDenied;
    public static AceType SystemAudit;
    public static AceType SystemAlarm;
    public static AceType AccessAllowedCompound;
    public static AceType AccessAllowedObject;
    public static AceType AccessDeniedObject;
    public static AceType SystemAuditObject;
    public static AceType SystemAlarmObject;
    public static AceType AccessAllowedCallback;
    public static AceType AccessDeniedCallback;
    public static AceType AccessAllowedCallbackObject;
    public static AceType AccessDeniedCallbackObject;
    public static AceType SystemAuditCallback;
    public static AceType SystemAlarmCallback;
    public static AceType SystemAuditCallbackObject;
    public static AceType SystemAlarmCallbackObject;
    public static AceType MaxDefinedAceType;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AuditFlags : Enum {
    public int value__;
    public static AuditFlags None;
    public static AuditFlags Success;
    public static AuditFlags Failure;
}
public abstract class System.Security.AccessControl.AuditRule : AuthorizationRule {
    private AuditFlags auditFlags;
    public AuditFlags AuditFlags { get; }
    protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    public AuditFlags get_AuditFlags();
}
public class System.Security.AccessControl.AuditRule`1 : AuditRule {
    public T Rights { get; }
    public AuditRule`1(string identity, T rights, AuditFlags flags);
    public AuditRule`1(IdentityReference identity, T rights, AuditFlags flags);
    public AuditRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public AuditRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AuditRule`1(IdentityReference identity, int rights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public T get_Rights();
}
public abstract class System.Security.AccessControl.AuthorizationRule : object {
    private IdentityReference identity;
    private int accessMask;
    private bool isInherited;
    private InheritanceFlags inheritanceFlags;
    private PropagationFlags propagationFlags;
    public IdentityReference IdentityReference { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public bool IsInherited { get; }
    public PropagationFlags PropagationFlags { get; }
    protected internal int AccessMask { get; }
    protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public IdentityReference get_IdentityReference();
    public InheritanceFlags get_InheritanceFlags();
    public bool get_IsInherited();
    public PropagationFlags get_PropagationFlags();
    protected internal int get_AccessMask();
}
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.AuthorizationRuleCollection : ReadOnlyCollectionBase {
    public AuthorizationRule Item { get; }
    internal AuthorizationRuleCollection(AuthorizationRule[] rules);
    public void AddRule(AuthorizationRule rule);
    public AuthorizationRule get_Item(int index);
    public void CopyTo(AuthorizationRule[] rules, int index);
}
public class System.Security.AccessControl.CommonAce : QualifiedAce {
    public int BinaryLength { get; }
    public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, Byte[] opaque);
    internal CommonAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, Byte[] opaque);
    internal CommonAce(Byte[] binaryForm, int offset);
    public virtual int get_BinaryLength();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual string GetSddlForm();
    private static AceType ConvertType(AceQualifier qualifier, bool isCallback);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.CommonAcl : GenericAcl {
    private static int default_capacity;
    private bool is_aefa;
    private bool is_canonical;
    private bool is_container;
    private bool is_ds;
    internal RawAcl raw_acl;
    public int BinaryLength { get; }
    public int Count { get; }
    public bool IsCanonical { get; }
    public bool IsContainer { get; }
    public bool IsDS { get; }
    internal bool IsAefa { get; internal set; }
    public byte Revision { get; }
    public GenericAce Item { get; public set; }
    internal CommonAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    internal CommonAcl(bool isContainer, bool isDS, byte revision, int capacity);
    internal CommonAcl(bool isContainer, bool isDS, int capacity);
    private void Init(bool isContainer, bool isDS, RawAcl rawAcl);
    public sealed virtual int get_BinaryLength();
    public sealed virtual int get_Count();
    public bool get_IsCanonical();
    public bool get_IsContainer();
    public bool get_IsDS();
    internal bool get_IsAefa();
    internal void set_IsAefa(bool value);
    public sealed virtual byte get_Revision();
    public sealed virtual GenericAce get_Item(int index);
    public sealed virtual void set_Item(int index, GenericAce value);
    public sealed virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public void Purge(SecurityIdentifier sid);
    public void RemoveInheritedAces();
    internal void RequireCanonicity();
    internal void CanonicalizeAndClearAefa();
    internal virtual bool IsAceMeaningless(GenericAce ace);
    private bool TestCanonicity();
    internal int GetCanonicalExplicitDenyAceCount();
    internal int GetCanonicalExplicitAceCount();
    private void MergeExplicitAces();
    private GenericAce MergeExplicitAcePair(GenericAce ace1, GenericAce ace2);
    private static void GetObjectAceTypeGuids(ObjectAce ace, Guid& type, Guid& inheritedType);
    internal abstract virtual void ApplyCanonicalSortToExplicitAces();
    internal void ApplyCanonicalSortToExplicitAces(int start, int count);
    internal virtual string GetSddlForm(ControlFlags sdFlags, bool isDacl);
    internal void RemoveAces(RemoveAcesCallback`1<T> callback);
    internal void AddAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    internal void AddAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    private QualifiedAce AddAceGetQualifiedAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    private QualifiedAce AddAceGetQualifiedAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    private void AddAce(QualifiedAce newAce);
    private static GenericAce CopyAce(GenericAce ace);
    internal abstract virtual int GetAceInsertPosition(AceQualifier aceQualifier);
    private AceFlags GetAceFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    internal void RemoveAceSpecific(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    internal void RemoveAceSpecific(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal void SetAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    internal void SetAce(AceQualifier aceQualifier, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    private void SetAce(QualifiedAce newAce);
}
public abstract class System.Security.AccessControl.CommonObjectSecurity : ObjectSecurity {
    protected CommonObjectSecurity(bool isContainer);
    internal CommonObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
    protected void AddAccessRule(AccessRule rule);
    protected bool RemoveAccessRule(AccessRule rule);
    protected void RemoveAccessRuleAll(AccessRule rule);
    protected void RemoveAccessRuleSpecific(AccessRule rule);
    protected void ResetAccessRule(AccessRule rule);
    protected void SetAccessRule(AccessRule rule);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected void AddAuditRule(AuditRule rule);
    protected bool RemoveAuditRule(AuditRule rule);
    protected void RemoveAuditRuleAll(AuditRule rule);
    protected void RemoveAuditRuleSpecific(AuditRule rule);
    protected void SetAuditRule(AuditRule rule);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
}
public class System.Security.AccessControl.CommonSecurityDescriptor : GenericSecurityDescriptor {
    private bool is_container;
    private bool is_ds;
    private ControlFlags flags;
    private SecurityIdentifier owner;
    private SecurityIdentifier group;
    private SystemAcl system_acl;
    private DiscretionaryAcl discretionary_acl;
    public ControlFlags ControlFlags { get; }
    public DiscretionaryAcl DiscretionaryAcl { get; public set; }
    internal GenericAcl InternalDacl { get; }
    public SecurityIdentifier Group { get; public set; }
    public bool IsContainer { get; }
    public bool IsDiscretionaryAclCanonical { get; }
    public bool IsDS { get; }
    public bool IsSystemAclCanonical { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SystemAcl SystemAcl { get; public set; }
    internal GenericAcl InternalSacl { get; }
    internal bool DaclIsUnmodifiedAefa { get; }
    public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, Byte[] binaryForm, int offset);
    public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
    private void Init(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
    private void Init(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
    public virtual ControlFlags get_ControlFlags();
    public DiscretionaryAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(DiscretionaryAcl value);
    internal virtual GenericAcl get_InternalDacl();
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public bool get_IsContainer();
    public bool get_IsDiscretionaryAclCanonical();
    public bool get_IsDS();
    public bool get_IsSystemAclCanonical();
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public SystemAcl get_SystemAcl();
    public void set_SystemAcl(SystemAcl value);
    internal virtual GenericAcl get_InternalSacl();
    public void PurgeAccessControl(SecurityIdentifier sid);
    public void PurgeAudit(SecurityIdentifier sid);
    public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
    public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
    public void AddDiscretionaryAcl(byte revision, int trusted);
    public void AddSystemAcl(byte revision, int trusted);
    private void CheckAclConsistency(CommonAcl acl);
    internal virtual bool get_DaclIsUnmodifiedAefa();
}
public class System.Security.AccessControl.CompoundAce : KnownAce {
    private CompoundAceType compound_ace_type;
    [MonoTODOAttribute]
public int BinaryLength { get; }
    public CompoundAceType CompoundAceType { get; public set; }
    public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
    public virtual int get_BinaryLength();
    public CompoundAceType get_CompoundAceType();
    public void set_CompoundAceType(CompoundAceType value);
    [MonoTODOAttribute]
public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    internal virtual string GetSddlForm();
}
public enum System.Security.AccessControl.CompoundAceType : Enum {
    public int value__;
    public static CompoundAceType Impersonation;
}
[FlagsAttribute]
public enum System.Security.AccessControl.ControlFlags : Enum {
    public int value__;
    public static ControlFlags None;
    public static ControlFlags OwnerDefaulted;
    public static ControlFlags GroupDefaulted;
    public static ControlFlags DiscretionaryAclPresent;
    public static ControlFlags DiscretionaryAclDefaulted;
    public static ControlFlags SystemAclPresent;
    public static ControlFlags SystemAclDefaulted;
    public static ControlFlags DiscretionaryAclUntrusted;
    public static ControlFlags ServerSecurity;
    public static ControlFlags DiscretionaryAclAutoInheritRequired;
    public static ControlFlags SystemAclAutoInheritRequired;
    public static ControlFlags DiscretionaryAclAutoInherited;
    public static ControlFlags SystemAclAutoInherited;
    public static ControlFlags DiscretionaryAclProtected;
    public static ControlFlags SystemAclProtected;
    public static ControlFlags RMControlValid;
    public static ControlFlags SelfRelative;
}
public class System.Security.AccessControl.CryptoKeyAccessRule : AccessRule {
    public CryptoKeyRights CryptoKeyRights { get; }
    public CryptoKeyAccessRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
    public CryptoKeyAccessRule(string identity, CryptoKeyRights cryptoKeyRights, AccessControlType type);
    public CryptoKeyRights get_CryptoKeyRights();
}
public class System.Security.AccessControl.CryptoKeyAuditRule : AuditRule {
    public CryptoKeyRights CryptoKeyRights { get; }
    public CryptoKeyAuditRule(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
    public CryptoKeyAuditRule(string identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags);
    public CryptoKeyRights get_CryptoKeyRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.CryptoKeyRights : Enum {
    public int value__;
    public static CryptoKeyRights ReadData;
    public static CryptoKeyRights WriteData;
    public static CryptoKeyRights ReadExtendedAttributes;
    public static CryptoKeyRights WriteExtendedAttributes;
    public static CryptoKeyRights ReadAttributes;
    public static CryptoKeyRights WriteAttributes;
    public static CryptoKeyRights Delete;
    public static CryptoKeyRights ReadPermissions;
    public static CryptoKeyRights ChangePermissions;
    public static CryptoKeyRights TakeOwnership;
    public static CryptoKeyRights Synchronize;
    public static CryptoKeyRights FullControl;
    public static CryptoKeyRights GenericAll;
    public static CryptoKeyRights GenericExecute;
    public static CryptoKeyRights GenericWrite;
    public static CryptoKeyRights GenericRead;
}
public class System.Security.AccessControl.CryptoKeySecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public CryptoKeySecurity(CommonSecurityDescriptor securityDescriptor);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public sealed virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(CryptoKeyAccessRule rule);
    public bool RemoveAccessRule(CryptoKeyAccessRule rule);
    public void RemoveAccessRuleAll(CryptoKeyAccessRule rule);
    public void RemoveAccessRuleSpecific(CryptoKeyAccessRule rule);
    public void ResetAccessRule(CryptoKeyAccessRule rule);
    public void SetAccessRule(CryptoKeyAccessRule rule);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAuditRule(CryptoKeyAuditRule rule);
    public bool RemoveAuditRule(CryptoKeyAuditRule rule);
    public void RemoveAuditRuleAll(CryptoKeyAuditRule rule);
    public void RemoveAuditRuleSpecific(CryptoKeyAuditRule rule);
    public void SetAuditRule(CryptoKeyAuditRule rule);
}
public class System.Security.AccessControl.CustomAce : GenericAce {
    private Byte[] opaque;
    [MonoTODOAttribute]
public static int MaxOpaqueLength;
    [MonoTODOAttribute]
public int BinaryLength { get; }
    public int OpaqueLength { get; }
    public CustomAce(AceType type, AceFlags flags, Byte[] opaque);
    public virtual int get_BinaryLength();
    public int get_OpaqueLength();
    [MonoTODOAttribute]
public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
    internal virtual string GetSddlForm();
}
public abstract class System.Security.AccessControl.DirectoryObjectSecurity : ObjectSecurity {
    protected DirectoryObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    private Exception GetNotImplementedException();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType);
    internal virtual AccessRule InternalAccessRuleFactory(QualifiedAce ace, Type targetType, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType);
    internal virtual AuditRule InternalAuditRuleFactory(QualifiedAce ace, Type targetType);
    public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
    protected void AddAccessRule(ObjectAccessRule rule);
    protected bool RemoveAccessRule(ObjectAccessRule rule);
    protected void RemoveAccessRuleAll(ObjectAccessRule rule);
    protected void RemoveAccessRuleSpecific(ObjectAccessRule rule);
    protected void ResetAccessRule(ObjectAccessRule rule);
    protected void SetAccessRule(ObjectAccessRule rule);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected void AddAuditRule(ObjectAuditRule rule);
    protected bool RemoveAuditRule(ObjectAuditRule rule);
    protected void RemoveAuditRuleAll(ObjectAuditRule rule);
    protected void RemoveAuditRuleSpecific(ObjectAuditRule rule);
    protected void SetAuditRule(ObjectAuditRule rule);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
}
public class System.Security.AccessControl.DirectorySecurity : FileSystemSecurity {
    public DirectorySecurity(string name, AccessControlSections includeSections);
}
public class System.Security.AccessControl.DiscretionaryAcl : CommonAcl {
    public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
    public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    [MonoTODOAttribute]
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    [MonoTODOAttribute]
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    internal virtual void ApplyCanonicalSortToExplicitAces();
    internal virtual int GetAceInsertPosition(AceQualifier aceQualifier);
    private static AceQualifier GetAceQualifier(AccessControlType accessType);
    internal virtual bool IsAceMeaningless(GenericAce ace);
}
public class System.Security.AccessControl.EventWaitHandleAccessRule : AccessRule {
    public EventWaitHandleRights EventWaitHandleRights { get; }
    public EventWaitHandleAccessRule(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type);
    public EventWaitHandleAccessRule(string identity, EventWaitHandleRights eventRights, AccessControlType type);
    public EventWaitHandleRights get_EventWaitHandleRights();
}
public class System.Security.AccessControl.EventWaitHandleAuditRule : AuditRule {
    public EventWaitHandleRights EventWaitHandleRights { get; }
    public EventWaitHandleAuditRule(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags);
    public EventWaitHandleRights get_EventWaitHandleRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.EventWaitHandleRights : Enum {
    public int value__;
    public static EventWaitHandleRights Modify;
    public static EventWaitHandleRights Delete;
    public static EventWaitHandleRights ReadPermissions;
    public static EventWaitHandleRights ChangePermissions;
    public static EventWaitHandleRights TakeOwnership;
    public static EventWaitHandleRights Synchronize;
    public static EventWaitHandleRights FullControl;
}
public class System.Security.AccessControl.EventWaitHandleSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    internal EventWaitHandleSecurity(SafeHandle handle, AccessControlSections includeSections);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(EventWaitHandleAccessRule rule);
    public bool RemoveAccessRule(EventWaitHandleAccessRule rule);
    public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule);
    public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule);
    public void ResetAccessRule(EventWaitHandleAccessRule rule);
    public void SetAccessRule(EventWaitHandleAccessRule rule);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAuditRule(EventWaitHandleAuditRule rule);
    public bool RemoveAuditRule(EventWaitHandleAuditRule rule);
    public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule);
    public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule);
    public void SetAuditRule(EventWaitHandleAuditRule rule);
    internal void Persist(SafeHandle handle);
}
public class System.Security.AccessControl.FileSecurity : FileSystemSecurity {
    public FileSecurity(string fileName, AccessControlSections includeSections);
    internal FileSecurity(SafeHandle handle, AccessControlSections includeSections);
}
public class System.Security.AccessControl.FileSystemAccessRule : AccessRule {
    public FileSystemRights FileSystemRights { get; }
    public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type);
    public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, AccessControlType type);
    public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public FileSystemRights get_FileSystemRights();
}
public class System.Security.AccessControl.FileSystemAuditRule : AuditRule {
    public FileSystemRights FileSystemRights { get; }
    public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags);
    public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, AuditFlags flags);
    public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public FileSystemRights get_FileSystemRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.FileSystemRights : Enum {
    public int value__;
    public static FileSystemRights ListDirectory;
    public static FileSystemRights ReadData;
    public static FileSystemRights CreateFiles;
    public static FileSystemRights WriteData;
    public static FileSystemRights AppendData;
    public static FileSystemRights CreateDirectories;
    public static FileSystemRights ReadExtendedAttributes;
    public static FileSystemRights WriteExtendedAttributes;
    public static FileSystemRights ExecuteFile;
    public static FileSystemRights Traverse;
    public static FileSystemRights DeleteSubdirectoriesAndFiles;
    public static FileSystemRights ReadAttributes;
    public static FileSystemRights WriteAttributes;
    public static FileSystemRights Write;
    public static FileSystemRights Delete;
    public static FileSystemRights ReadPermissions;
    public static FileSystemRights Read;
    public static FileSystemRights ReadAndExecute;
    public static FileSystemRights Modify;
    public static FileSystemRights ChangePermissions;
    public static FileSystemRights TakeOwnership;
    public static FileSystemRights Synchronize;
    public static FileSystemRights FullControl;
}
public abstract class System.Security.AccessControl.FileSystemSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    internal FileSystemSecurity(bool isContainer);
    internal FileSystemSecurity(bool isContainer, string name, AccessControlSections includeSections);
    internal FileSystemSecurity(bool isContainer, SafeHandle handle, AccessControlSections includeSections);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public sealed virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(FileSystemAccessRule rule);
    public bool RemoveAccessRule(FileSystemAccessRule rule);
    public void RemoveAccessRuleAll(FileSystemAccessRule rule);
    public void RemoveAccessRuleSpecific(FileSystemAccessRule rule);
    public void ResetAccessRule(FileSystemAccessRule rule);
    public void SetAccessRule(FileSystemAccessRule rule);
    public sealed virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAuditRule(FileSystemAuditRule rule);
    public bool RemoveAuditRule(FileSystemAuditRule rule);
    public void RemoveAuditRuleAll(FileSystemAuditRule rule);
    public void RemoveAuditRuleSpecific(FileSystemAuditRule rule);
    public void SetAuditRule(FileSystemAuditRule rule);
}
public abstract class System.Security.AccessControl.GenericAce : object {
    private AceFlags ace_flags;
    private AceType ace_type;
    public AceFlags AceFlags { get; public set; }
    public AceType AceType { get; }
    public AuditFlags AuditFlags { get; }
    public int BinaryLength { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public bool IsInherited { get; }
    public PropagationFlags PropagationFlags { get; }
    internal GenericAce(AceType type, AceFlags flags);
    internal GenericAce(Byte[] binaryForm, int offset);
    public AceFlags get_AceFlags();
    public void set_AceFlags(AceFlags value);
    public AceType get_AceType();
    public AuditFlags get_AuditFlags();
    public abstract virtual int get_BinaryLength();
    public InheritanceFlags get_InheritanceFlags();
    public bool get_IsInherited();
    public PropagationFlags get_PropagationFlags();
    public GenericAce Copy();
    public static GenericAce CreateFromBinaryForm(Byte[] binaryForm, int offset);
    public sealed virtual bool Equals(object o);
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public sealed virtual int GetHashCode();
    public static bool op_Equality(GenericAce left, GenericAce right);
    public static bool op_Inequality(GenericAce left, GenericAce right);
    internal abstract virtual string GetSddlForm();
    internal static GenericAce CreateFromSddlForm(string sddlForm, Int32& pos);
    private static bool IsObjectType(AceType type);
    internal static string GetSddlAceType(AceType type);
    private static AceType ParseSddlAceType(string type);
    internal static string GetSddlAceFlags(AceFlags flags);
    private static AceFlags ParseSddlAceFlags(string flags);
    private static int ParseSddlAccessRights(string accessMask);
    private static int ParseSddlAliasRights(string accessMask);
    internal static ushort ReadUShort(Byte[] buffer, int offset);
    internal static int ReadInt(Byte[] buffer, int offset);
    internal static void WriteInt(int val, Byte[] buffer, int offset);
    internal static void WriteUShort(ushort val, Byte[] buffer, int offset);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.GenericAcl : object {
    public static byte AclRevision;
    public static byte AclRevisionDS;
    public static int MaxBinaryLength;
    public int BinaryLength { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public GenericAce Item { get; public set; }
    public byte Revision { get; }
    public object SyncRoot { get; }
    private static GenericAcl();
    public abstract virtual int get_BinaryLength();
    public abstract virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public abstract virtual GenericAce get_Item(int index);
    public abstract virtual void set_Item(int index, GenericAce value);
    public abstract virtual byte get_Revision();
    public virtual object get_SyncRoot();
    public void CopyTo(GenericAce[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public AceEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal abstract virtual string GetSddlForm(ControlFlags sdFlags, bool isDacl);
}
public abstract class System.Security.AccessControl.GenericSecurityDescriptor : object {
    public int BinaryLength { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Group { get; public set; }
    public SecurityIdentifier Owner { get; public set; }
    public static byte Revision { get; }
    internal GenericAcl InternalDacl { get; }
    internal GenericAcl InternalSacl { get; }
    internal byte InternalReservedField { get; }
    internal bool DaclIsUnmodifiedAefa { get; }
    private bool DaclPresent { get; }
    private bool SaclPresent { get; }
    public int get_BinaryLength();
    public abstract virtual ControlFlags get_ControlFlags();
    public abstract virtual SecurityIdentifier get_Group();
    public abstract virtual void set_Group(SecurityIdentifier value);
    public abstract virtual SecurityIdentifier get_Owner();
    public abstract virtual void set_Owner(SecurityIdentifier value);
    public static byte get_Revision();
    internal virtual GenericAcl get_InternalDacl();
    internal virtual GenericAcl get_InternalSacl();
    internal virtual byte get_InternalReservedField();
    public void GetBinaryForm(Byte[] binaryForm, int offset);
    public string GetSddlForm(AccessControlSections includeSections);
    public static bool IsSddlConversionSupported();
    internal virtual bool get_DaclIsUnmodifiedAefa();
    private bool get_DaclPresent();
    private bool get_SaclPresent();
    private void WriteUShort(ushort val, Byte[] buffer, int offset);
    private void WriteInt(int val, Byte[] buffer, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.InheritanceFlags : Enum {
    public int value__;
    public static InheritanceFlags None;
    public static InheritanceFlags ContainerInherit;
    public static InheritanceFlags ObjectInherit;
}
public abstract class System.Security.AccessControl.KnownAce : GenericAce {
    private int access_mask;
    private SecurityIdentifier identifier;
    public int AccessMask { get; public set; }
    public SecurityIdentifier SecurityIdentifier { get; public set; }
    internal KnownAce(AceType type, AceFlags flags);
    internal KnownAce(Byte[] binaryForm, int offset);
    public int get_AccessMask();
    public void set_AccessMask(int value);
    public SecurityIdentifier get_SecurityIdentifier();
    public void set_SecurityIdentifier(SecurityIdentifier value);
    internal static string GetSddlAccessRights(int accessMask);
    private static string GetSddlAliasRights(int accessMask);
}
public class System.Security.AccessControl.MutexAccessRule : AccessRule {
    public MutexRights MutexRights { get; }
    public MutexAccessRule(IdentityReference identity, MutexRights eventRights, AccessControlType type);
    public MutexAccessRule(string identity, MutexRights eventRights, AccessControlType type);
    public MutexRights get_MutexRights();
}
public class System.Security.AccessControl.MutexAuditRule : AuditRule {
    public MutexRights MutexRights { get; }
    public MutexAuditRule(IdentityReference identity, MutexRights eventRights, AuditFlags flags);
    public MutexRights get_MutexRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.MutexRights : Enum {
    public int value__;
    public static MutexRights Modify;
    public static MutexRights Delete;
    public static MutexRights ReadPermissions;
    public static MutexRights ChangePermissions;
    public static MutexRights TakeOwnership;
    public static MutexRights Synchronize;
    public static MutexRights FullControl;
}
public class System.Security.AccessControl.MutexSecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public MutexSecurity(string name, AccessControlSections includeSections);
    internal MutexSecurity(SafeHandle handle, AccessControlSections includeSections);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public void AddAccessRule(MutexAccessRule rule);
    public bool RemoveAccessRule(MutexAccessRule rule);
    public void RemoveAccessRuleAll(MutexAccessRule rule);
    public void RemoveAccessRuleSpecific(MutexAccessRule rule);
    public void ResetAccessRule(MutexAccessRule rule);
    public void SetAccessRule(MutexAccessRule rule);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public void AddAuditRule(MutexAuditRule rule);
    public bool RemoveAuditRule(MutexAuditRule rule);
    public void RemoveAuditRuleAll(MutexAuditRule rule);
    public void RemoveAuditRuleSpecific(MutexAuditRule rule);
    public void SetAuditRule(MutexAuditRule rule);
    private static Exception MutexExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context);
}
public abstract class System.Security.AccessControl.NativeObjectSecurity : CommonObjectSecurity {
    private ExceptionFromErrorCode exception_from_error_code;
    private ResourceType resource_type;
    internal ResourceType ResourceType { get; }
    internal NativeObjectSecurity(CommonSecurityDescriptor securityDescriptor, ResourceType resourceType);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    private void ClearAccessControlSectionsModified();
    protected sealed virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    protected sealed virtual void Persist(string name, AccessControlSections includeSections);
    internal void PersistModifications(SafeHandle handle);
    protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
    internal void PersistModifications(string name);
    protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
    internal static Exception DefaultExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context);
    private void RaiseExceptionOnFailure(int errorCode, string name, SafeHandle handle, object context);
    internal virtual int InternalGet(SafeHandle handle, AccessControlSections includeSections);
    internal virtual int InternalGet(string name, AccessControlSections includeSections);
    internal virtual int InternalSet(SafeHandle handle, AccessControlSections includeSections);
    internal virtual int InternalSet(string name, AccessControlSections includeSections);
    internal ResourceType get_ResourceType();
    private int Win32GetHelper(GetSecurityInfoNativeCall nativeCall, AccessControlSections includeSections);
    private int Win32SetHelper(SetSecurityInfoNativeCall nativeCall, AccessControlSections includeSections);
    private string Win32FixName(string name);
    private static int GetSecurityInfo(SafeHandle handle, ResourceType resourceType, SecurityInfos securityInfos, IntPtr& owner, IntPtr& group, IntPtr& dacl, IntPtr& sacl, IntPtr& descriptor);
    private static int GetNamedSecurityInfo(string name, ResourceType resourceType, SecurityInfos securityInfos, IntPtr& owner, IntPtr& group, IntPtr& dacl, IntPtr& sacl, IntPtr& descriptor);
    private static IntPtr LocalFree(IntPtr handle);
    private static int SetSecurityInfo(SafeHandle handle, ResourceType resourceType, SecurityInfos securityInfos, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl);
    private static int SetNamedSecurityInfo(string name, ResourceType resourceType, SecurityInfos securityInfos, Byte[] owner, Byte[] group, Byte[] dacl, Byte[] sacl);
    private static int GetSecurityDescriptorLength(IntPtr descriptor);
    private static bool IsValidSecurityDescriptor(IntPtr descriptor);
}
public abstract class System.Security.AccessControl.ObjectAccessRule : AccessRule {
    private Guid object_type;
    private Guid inherited_object_type;
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    public Guid ObjectType { get; }
    protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
    public Guid get_ObjectType();
}
public class System.Security.AccessControl.ObjectAce : QualifiedAce {
    private Guid object_ace_type;
    private Guid inherited_object_type;
    private ObjectAceFlags object_ace_flags;
    public int BinaryLength { get; }
    public Guid InheritedObjectAceType { get; public set; }
    private bool InheritedObjectAceTypePresent { get; }
    public ObjectAceFlags ObjectAceFlags { get; public set; }
    public Guid ObjectAceType { get; public set; }
    private bool ObjectAceTypePresent { get; }
    public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, Byte[] opaque);
    internal ObjectAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, ObjectAceFlags objFlags, Guid objType, Guid inheritedType, Byte[] opaque);
    internal ObjectAce(Byte[] binaryForm, int offset);
    public virtual int get_BinaryLength();
    public Guid get_InheritedObjectAceType();
    public void set_InheritedObjectAceType(Guid value);
    private bool get_InheritedObjectAceTypePresent();
    public ObjectAceFlags get_ObjectAceFlags();
    public void set_ObjectAceFlags(ObjectAceFlags value);
    public Guid get_ObjectAceType();
    public void set_ObjectAceType(Guid value);
    private bool get_ObjectAceTypePresent();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual string GetSddlForm();
    private static AceType ConvertType(AceQualifier qualifier, bool isCallback);
    private void WriteGuid(Guid val, Byte[] buffer, int offset);
    private Guid ReadGuid(Byte[] buffer, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.ObjectAceFlags : Enum {
    public int value__;
    public static ObjectAceFlags None;
    public static ObjectAceFlags ObjectAceTypePresent;
    public static ObjectAceFlags InheritedObjectAceTypePresent;
}
public abstract class System.Security.AccessControl.ObjectAuditRule : AuditRule {
    private Guid inherited_object_type;
    private Guid object_type;
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    public Guid ObjectType { get; }
    protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
    public Guid get_ObjectType();
}
public abstract class System.Security.AccessControl.ObjectSecurity : object {
    internal CommonSecurityDescriptor descriptor;
    private AccessControlSections sections_modified;
    private ReaderWriterLock rw_lock;
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public bool AreAccessRulesCanonical { get; }
    public bool AreAccessRulesProtected { get; }
    public bool AreAuditRulesCanonical { get; }
    public bool AreAuditRulesProtected { get; }
    internal AccessControlSections AccessControlSectionsModified { get; internal set; }
    protected bool AccessRulesModified { get; protected set; }
    protected bool AuditRulesModified { get; protected set; }
    protected bool GroupModified { get; protected set; }
    protected bool IsContainer { get; }
    protected bool IsDS { get; }
    protected bool OwnerModified { get; protected set; }
    protected ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    protected ObjectSecurity(bool isContainer, bool isDS);
    public abstract virtual Type get_AccessRightType();
    public abstract virtual Type get_AccessRuleType();
    public abstract virtual Type get_AuditRuleType();
    public bool get_AreAccessRulesCanonical();
    public bool get_AreAccessRulesProtected();
    public bool get_AreAuditRulesCanonical();
    public bool get_AreAuditRulesProtected();
    internal AccessControlSections get_AccessControlSectionsModified();
    internal void set_AccessControlSectionsModified(AccessControlSections value);
    protected bool get_AccessRulesModified();
    protected void set_AccessRulesModified(bool value);
    protected bool get_AuditRulesModified();
    protected void set_AuditRulesModified(bool value);
    protected bool get_GroupModified();
    protected void set_GroupModified(bool value);
    protected bool get_IsContainer();
    protected bool get_IsDS();
    protected bool get_OwnerModified();
    protected void set_OwnerModified(bool value);
    public abstract virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public abstract virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public IdentityReference GetGroup(Type targetType);
    public IdentityReference GetOwner(Type targetType);
    public Byte[] GetSecurityDescriptorBinaryForm();
    public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
    public static bool IsSddlConversionSupported();
    public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, Boolean& modified);
    public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, Boolean& modified);
    public virtual void PurgeAccessRules(IdentityReference identity);
    public virtual void PurgeAuditRules(IdentityReference identity);
    public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
    public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
    public void SetGroup(IdentityReference identity);
    public void SetOwner(IdentityReference identity);
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm);
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm, AccessControlSections includeSections);
    public void SetSecurityDescriptorSddlForm(string sddlForm);
    public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
    private void CopySddlForm(CommonSecurityDescriptor sourceDescriptor, AccessControlSections includeSections);
    protected abstract virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected abstract virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    private Exception GetNotImplementedException();
    protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    protected virtual void Persist(string name, AccessControlSections includeSections);
    [MonoTODOAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
    private void Reading();
    protected void ReadLock();
    protected void ReadUnlock();
    private void Writing();
    protected void WriteLock();
    protected void WriteUnlock();
    internal AuthorizationRuleCollection InternalGetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    internal virtual AccessRule InternalAccessRuleFactory(QualifiedAce ace, Type targetType, AccessControlType type);
    internal AuthorizationRuleCollection InternalGetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
    internal virtual AuditRule InternalAuditRuleFactory(QualifiedAce ace, Type targetType);
    internal static SecurityIdentifier SidFromIR(IdentityReference identity);
    private bool AreAccessControlSectionsModified(AccessControlSections mask);
    private void SetAccessControlSectionsModified(AccessControlSections mask, bool modified);
}
public abstract class System.Security.AccessControl.ObjectSecurity`1 : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual void AddAccessRule(AccessRule`1<T> rule);
    public virtual bool RemoveAccessRule(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleAll(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleSpecific(AccessRule`1<T> rule);
    public virtual void ResetAccessRule(AccessRule`1<T> rule);
    public virtual void SetAccessRule(AccessRule`1<T> rule);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public virtual void AddAuditRule(AuditRule`1<T> rule);
    public virtual bool RemoveAuditRule(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleAll(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleSpecific(AuditRule`1<T> rule);
    public virtual void SetAuditRule(AuditRule`1<T> rule);
    protected void Persist(SafeHandle handle);
    protected void Persist(string name);
}
public class System.Security.AccessControl.PrivilegeNotHeldException : UnauthorizedAccessException {
    private string _privilegeName;
    public string PrivilegeName { get; }
    public PrivilegeNotHeldException(string privilege);
    public PrivilegeNotHeldException(string privilege, Exception inner);
    private PrivilegeNotHeldException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_PrivilegeName();
}
[FlagsAttribute]
public enum System.Security.AccessControl.PropagationFlags : Enum {
    public int value__;
    public static PropagationFlags None;
    public static PropagationFlags NoPropagateInherit;
    public static PropagationFlags InheritOnly;
}
public abstract class System.Security.AccessControl.QualifiedAce : KnownAce {
    private Byte[] opaque;
    public AceQualifier AceQualifier { get; }
    public bool IsCallback { get; }
    public int OpaqueLength { get; }
    internal QualifiedAce(AceType type, AceFlags flags, Byte[] opaque);
    internal QualifiedAce(Byte[] binaryForm, int offset);
    public AceQualifier get_AceQualifier();
    public bool get_IsCallback();
    public int get_OpaqueLength();
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
}
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.RawAcl : GenericAcl {
    private byte revision;
    private List`1<GenericAce> list;
    public int BinaryLength { get; }
    public int Count { get; }
    public GenericAce Item { get; public set; }
    public byte Revision { get; }
    public RawAcl(byte revision, int capacity);
    public RawAcl(Byte[] binaryForm, int offset);
    internal RawAcl(byte revision, List`1<GenericAce> aces);
    public virtual int get_BinaryLength();
    public virtual int get_Count();
    public virtual GenericAce get_Item(int index);
    public virtual void set_Item(int index, GenericAce value);
    public virtual byte get_Revision();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public void InsertAce(int index, GenericAce ace);
    public void RemoveAce(int index);
    internal virtual string GetSddlForm(ControlFlags sdFlags, bool isDacl);
    internal static RawAcl ParseSddlForm(string sddlForm, bool isDacl, ControlFlags& sdFlags, Int32& pos);
    private static void ParseFlags(string sddlForm, bool isDacl, ControlFlags& sdFlags, Int32& pos);
    private void WriteUShort(ushort val, Byte[] buffer, int offset);
    private ushort ReadUShort(Byte[] buffer, int offset);
}
public class System.Security.AccessControl.RawSecurityDescriptor : GenericSecurityDescriptor {
    private ControlFlags control_flags;
    private SecurityIdentifier owner_sid;
    private SecurityIdentifier group_sid;
    private RawAcl system_acl;
    private RawAcl discretionary_acl;
    private byte resourcemgr_control;
    public ControlFlags ControlFlags { get; }
    public RawAcl DiscretionaryAcl { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public SecurityIdentifier Owner { get; public set; }
    public byte ResourceManagerControl { get; public set; }
    public RawAcl SystemAcl { get; public set; }
    internal GenericAcl InternalDacl { get; }
    internal GenericAcl InternalSacl { get; }
    internal byte InternalReservedField { get; }
    public RawSecurityDescriptor(string sddlForm);
    public RawSecurityDescriptor(Byte[] binaryForm, int offset);
    public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
    public virtual ControlFlags get_ControlFlags();
    public RawAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(RawAcl value);
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public byte get_ResourceManagerControl();
    public void set_ResourceManagerControl(byte value);
    public RawAcl get_SystemAcl();
    public void set_SystemAcl(RawAcl value);
    public void SetFlags(ControlFlags flags);
    internal virtual GenericAcl get_InternalDacl();
    internal virtual GenericAcl get_InternalSacl();
    internal virtual byte get_InternalReservedField();
    private void ParseSddl(string sddlForm);
    private ushort ReadUShort(Byte[] buffer, int offset);
    private int ReadInt(Byte[] buffer, int offset);
}
public class System.Security.AccessControl.RegistryAccessRule : AccessRule {
    public RegistryRights RegistryRights { get; }
    public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, AccessControlType type);
    public RegistryAccessRule(string identity, RegistryRights registryRights, AccessControlType type);
    public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public RegistryAccessRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal RegistryAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public RegistryRights get_RegistryRights();
}
public class System.Security.AccessControl.RegistryAuditRule : AuditRule {
    public RegistryRights RegistryRights { get; }
    public RegistryAuditRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public RegistryAuditRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal RegistryAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public RegistryRights get_RegistryRights();
}
[FlagsAttribute]
public enum System.Security.AccessControl.RegistryRights : Enum {
    public int value__;
    public static RegistryRights QueryValues;
    public static RegistryRights SetValue;
    public static RegistryRights CreateSubKey;
    public static RegistryRights EnumerateSubKeys;
    public static RegistryRights Notify;
    public static RegistryRights CreateLink;
    public static RegistryRights Delete;
    public static RegistryRights ReadPermissions;
    public static RegistryRights WriteKey;
    public static RegistryRights ReadKey;
    public static RegistryRights ExecuteKey;
    public static RegistryRights ChangePermissions;
    public static RegistryRights TakeOwnership;
    public static RegistryRights FullControl;
}
public class System.Security.AccessControl.RegistrySecurity : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    internal RegistrySecurity(SafeRegistryHandle hKey, string name, AccessControlSections includeSections);
    private static Exception _HandleErrorCodeCore(int errorCode, string name, SafeHandle handle, object context);
    private static Exception _HandleErrorCode(int errorCode, string name, SafeHandle handle, object context);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AccessControlSections GetAccessControlSectionsFromChanges();
    internal void Persist(SafeRegistryHandle hKey, string keyName);
    public void AddAccessRule(RegistryAccessRule rule);
    public void SetAccessRule(RegistryAccessRule rule);
    public void ResetAccessRule(RegistryAccessRule rule);
    public bool RemoveAccessRule(RegistryAccessRule rule);
    public void RemoveAccessRuleAll(RegistryAccessRule rule);
    public void RemoveAccessRuleSpecific(RegistryAccessRule rule);
    public void AddAuditRule(RegistryAuditRule rule);
    public void SetAuditRule(RegistryAuditRule rule);
    public bool RemoveAuditRule(RegistryAuditRule rule);
    public void RemoveAuditRuleAll(RegistryAuditRule rule);
    public void RemoveAuditRuleSpecific(RegistryAuditRule rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
public enum System.Security.AccessControl.ResourceType : Enum {
    public int value__;
    public static ResourceType Unknown;
    public static ResourceType FileObject;
    public static ResourceType Service;
    public static ResourceType Printer;
    public static ResourceType RegistryKey;
    public static ResourceType LMShare;
    public static ResourceType KernelObject;
    public static ResourceType WindowObject;
    public static ResourceType DSObject;
    public static ResourceType DSObjectAll;
    public static ResourceType ProviderDefined;
    public static ResourceType WmiGuidObject;
    public static ResourceType RegistryWow6432Key;
}
internal class System.Security.AccessControl.SddlAccessRight : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ObjectType>k__BackingField;
    private static SddlAccessRight[] rights;
    public string Name { get; public set; }
    public int Value { get; public set; }
    public int ObjectType { get; public set; }
    private static SddlAccessRight();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    [CompilerGeneratedAttribute]
public int get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(int value);
    public static SddlAccessRight LookupByName(string s);
    public static SddlAccessRight[] Decompose(int mask);
}
[FlagsAttribute]
public enum System.Security.AccessControl.SecurityInfos : Enum {
    public int value__;
    public static SecurityInfos Owner;
    public static SecurityInfos Group;
    public static SecurityInfos DiscretionaryAcl;
    public static SecurityInfos SystemAcl;
}
public class System.Security.AccessControl.SystemAcl : CommonAcl {
    public SystemAcl(bool isContainer, bool isDS, int capacity);
    public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    [MonoTODOAttribute]
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    [MonoTODOAttribute]
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    internal virtual void ApplyCanonicalSortToExplicitAces();
    internal virtual int GetAceInsertPosition(AceQualifier aceQualifier);
    internal virtual bool IsAceMeaningless(GenericAce ace);
    private static bool IsValidAuditFlags(AuditFlags auditFlags);
}
[AttributeUsageAttribute("1")]
[ComVisibleAttribute("True")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    private PartialTrustVisibilityLevel _visibilityLevel;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
public class System.Security.Claims.Claim : object {
    private string m_issuer;
    private string m_originalIssuer;
    private string m_type;
    private string m_value;
    private string m_valueType;
    private Byte[] m_userSerializationData;
    private Dictionary`2<string, string> m_properties;
    private object m_propertyLock;
    private ClaimsIdentity m_subject;
    protected Byte[] CustomSerializationData { get; }
    public string Issuer { get; }
    public string OriginalIssuer { get; }
    public IDictionary`2<string, string> Properties { get; }
    public ClaimsIdentity Subject { get; internal set; }
    public string Type { get; }
    public string Value { get; }
    public string ValueType { get; }
    public Claim(BinaryReader reader);
    public Claim(BinaryReader reader, ClaimsIdentity subject);
    public Claim(string type, string value);
    public Claim(string type, string value, string valueType);
    public Claim(string type, string value, string valueType, string issuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
    public Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject);
    internal Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject, string propertyKey, string propertyValue);
    protected Claim(Claim other);
    protected Claim(Claim other, ClaimsIdentity subject);
    protected virtual Byte[] get_CustomSerializationData();
    public string get_Issuer();
    [OnDeserializedAttribute]
private void OnDeserializedMethod(StreamingContext context);
    public string get_OriginalIssuer();
    public IDictionary`2<string, string> get_Properties();
    public ClaimsIdentity get_Subject();
    internal void set_Subject(ClaimsIdentity value);
    public string get_Type();
    public string get_Value();
    public string get_ValueType();
    public virtual Claim Clone();
    public virtual Claim Clone(ClaimsIdentity identity);
    private void Initialize(BinaryReader reader, ClaimsIdentity subject);
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Claims.ClaimsIdentity : object {
    private Byte[] m_userSerializationData;
    private static string PreFix;
    private static string ActorKey;
    private static string AuthenticationTypeKey;
    private static string BootstrapContextKey;
    private static string ClaimsKey;
    private static string LabelKey;
    private static string NameClaimTypeKey;
    private static string RoleClaimTypeKey;
    private static string VersionKey;
    public static string DefaultIssuer;
    public static string DefaultNameClaimType;
    public static string DefaultRoleClaimType;
    private List`1<Claim> m_instanceClaims;
    private Collection`1<IEnumerable`1<Claim>> m_externalClaims;
    private string m_nameType;
    private string m_roleType;
    [OptionalFieldAttribute]
private string m_version;
    [OptionalFieldAttribute]
private ClaimsIdentity m_actor;
    [OptionalFieldAttribute]
private string m_authenticationType;
    [OptionalFieldAttribute]
private object m_bootstrapContext;
    [OptionalFieldAttribute]
private string m_label;
    [OptionalFieldAttribute]
private string m_serializedNameType;
    [OptionalFieldAttribute]
private string m_serializedRoleType;
    [OptionalFieldAttribute]
private string m_serializedClaims;
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public ClaimsIdentity Actor { get; public set; }
    public object BootstrapContext { get; public set; }
    public IEnumerable`1<Claim> Claims { get; }
    protected Byte[] CustomSerializationData { get; }
    internal Collection`1<IEnumerable`1<Claim>> ExternalClaims { get; }
    public string Label { get; public set; }
    public string Name { get; }
    public string NameClaimType { get; }
    public string RoleClaimType { get; }
    public ClaimsIdentity(IIdentity identity);
    public ClaimsIdentity(IEnumerable`1<Claim> claims);
    public ClaimsIdentity(string authenticationType);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims);
    public ClaimsIdentity(string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    public ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    internal ClaimsIdentity(IIdentity identity, IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType, bool checkAuthType);
    public ClaimsIdentity(BinaryReader reader);
    protected ClaimsIdentity(ClaimsIdentity other);
    [SecurityCriticalAttribute]
protected ClaimsIdentity(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
protected ClaimsIdentity(SerializationInfo info);
    public virtual string get_AuthenticationType();
    public virtual bool get_IsAuthenticated();
    public ClaimsIdentity get_Actor();
    public void set_Actor(ClaimsIdentity value);
    public object get_BootstrapContext();
    [SecurityCriticalAttribute]
public void set_BootstrapContext(object value);
    [IteratorStateMachineAttribute("System.Security.Claims.ClaimsIdentity/<get_Claims>d__51")]
public virtual IEnumerable`1<Claim> get_Claims();
    protected virtual Byte[] get_CustomSerializationData();
    [FriendAccessAllowedAttribute]
internal Collection`1<IEnumerable`1<Claim>> get_ExternalClaims();
    public string get_Label();
    public void set_Label(string value);
    public virtual string get_Name();
    public string get_NameClaimType();
    public string get_RoleClaimType();
    public virtual ClaimsIdentity Clone();
    [SecurityCriticalAttribute]
public virtual void AddClaim(Claim claim);
    [SecurityCriticalAttribute]
public virtual void AddClaims(IEnumerable`1<Claim> claims);
    [SecurityCriticalAttribute]
public virtual bool TryRemoveClaim(Claim claim);
    [SecurityCriticalAttribute]
public virtual void RemoveClaim(Claim claim);
    [SecuritySafeCriticalAttribute]
private void SafeAddClaims(IEnumerable`1<Claim> claims);
    [SecuritySafeCriticalAttribute]
private void SafeAddClaim(Claim claim);
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    [OnSerializingAttribute]
[SecurityCriticalAttribute]
private void OnSerializingMethod(StreamingContext context);
    [OnDeserializedAttribute]
[SecurityCriticalAttribute]
private void OnDeserializedMethod(StreamingContext context);
    [OnDeserializingAttribute]
private void OnDeserializingMethod(StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private void DeserializeClaims(string serializedClaims);
    [SecurityCriticalAttribute]
private string SerializeClaims();
    private bool IsCircular(ClaimsIdentity subject);
    private void Initialize(BinaryReader reader);
    protected virtual Claim CreateClaim(BinaryReader reader);
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
    [SecurityCriticalAttribute]
private void Deserialize(SerializationInfo info, StreamingContext context, bool useContext);
}
[ComVisibleAttribute("True")]
public class System.Security.Claims.ClaimsPrincipal : object {
    private Byte[] m_userSerializationData;
    private static string PreFix;
    private static string IdentitiesKey;
    private static string VersionKey;
    [OptionalFieldAttribute]
private string m_version;
    [OptionalFieldAttribute]
private string m_serializedClaimsIdentities;
    private List`1<ClaimsIdentity> m_identities;
    private static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> s_identitySelector;
    private static Func`1<ClaimsPrincipal> s_principalSelector;
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector { get; public set; }
    public static Func`1<ClaimsPrincipal> ClaimsPrincipalSelector { get; public set; }
    protected Byte[] CustomSerializationData { get; }
    public IEnumerable`1<Claim> Claims { get; }
    public static ClaimsPrincipal Current { get; }
    public IEnumerable`1<ClaimsIdentity> Identities { get; }
    public IIdentity Identity { get; }
    public ClaimsPrincipal(IEnumerable`1<ClaimsIdentity> identities);
    public ClaimsPrincipal(IIdentity identity);
    public ClaimsPrincipal(IPrincipal principal);
    public ClaimsPrincipal(BinaryReader reader);
    [SecurityCriticalAttribute]
protected ClaimsPrincipal(SerializationInfo info, StreamingContext context);
    private static ClaimsPrincipal();
    private static ClaimsIdentity SelectPrimaryIdentity(IEnumerable`1<ClaimsIdentity> identities);
    private static ClaimsPrincipal SelectClaimsPrincipal();
    public static Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> get_PrimaryIdentitySelector();
    [SecurityCriticalAttribute]
public static void set_PrimaryIdentitySelector(Func`2<IEnumerable`1<ClaimsIdentity>, ClaimsIdentity> value);
    public static Func`1<ClaimsPrincipal> get_ClaimsPrincipalSelector();
    [SecurityCriticalAttribute]
public static void set_ClaimsPrincipalSelector(Func`1<ClaimsPrincipal> value);
    protected virtual Byte[] get_CustomSerializationData();
    public virtual ClaimsPrincipal Clone();
    protected virtual ClaimsIdentity CreateClaimsIdentity(BinaryReader reader);
    [SecurityCriticalAttribute]
[OnSerializingAttribute]
private void OnSerializingMethod(StreamingContext context);
    [OnDeserializedAttribute]
[SecurityCriticalAttribute]
private void OnDeserializedMethod(StreamingContext context);
    [SecurityCriticalAttribute]
protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private void Deserialize(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
private void DeserializeIdentities(string identities);
    [SecurityCriticalAttribute]
private string SerializeIdentities();
    [SecurityCriticalAttribute]
public virtual void AddIdentity(ClaimsIdentity identity);
    [SecurityCriticalAttribute]
public virtual void AddIdentities(IEnumerable`1<ClaimsIdentity> identities);
    [IteratorStateMachineAttribute("System.Security.Claims.ClaimsPrincipal/<get_Claims>d__37")]
public virtual IEnumerable`1<Claim> get_Claims();
    public static ClaimsPrincipal get_Current();
    public virtual IEnumerable`1<Claim> FindAll(Predicate`1<Claim> match);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual Claim FindFirst(Predicate`1<Claim> match);
    public virtual Claim FindFirst(string type);
    public virtual bool HasClaim(Predicate`1<Claim> match);
    public virtual bool HasClaim(string type, string value);
    public virtual IEnumerable`1<ClaimsIdentity> get_Identities();
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(string role);
    private void Initialize(BinaryReader reader);
    public virtual void WriteTo(BinaryWriter writer);
    protected virtual void WriteTo(BinaryWriter writer, Byte[] userData);
}
public static class System.Security.Claims.ClaimTypes : object {
    internal static string ClaimTypeNamespace;
    public static string AuthenticationInstant;
    public static string AuthenticationMethod;
    public static string CookiePath;
    public static string DenyOnlyPrimarySid;
    public static string DenyOnlyPrimaryGroupSid;
    public static string DenyOnlyWindowsDeviceGroup;
    public static string Dsa;
    public static string Expiration;
    public static string Expired;
    public static string GroupSid;
    public static string IsPersistent;
    public static string PrimaryGroupSid;
    public static string PrimarySid;
    public static string Role;
    public static string SerialNumber;
    public static string UserData;
    public static string Version;
    public static string WindowsAccountName;
    public static string WindowsDeviceClaim;
    public static string WindowsDeviceGroup;
    public static string WindowsUserClaim;
    public static string WindowsFqbnVersion;
    public static string WindowsSubAuthority;
    internal static string ClaimType2005Namespace;
    public static string Anonymous;
    public static string Authentication;
    public static string AuthorizationDecision;
    public static string Country;
    public static string DateOfBirth;
    public static string Dns;
    public static string DenyOnlySid;
    public static string Email;
    public static string Gender;
    public static string GivenName;
    public static string Hash;
    public static string HomePhone;
    public static string Locality;
    public static string MobilePhone;
    public static string Name;
    public static string NameIdentifier;
    public static string OtherPhone;
    public static string PostalCode;
    public static string Rsa;
    public static string Sid;
    public static string Spn;
    public static string StateOrProvince;
    public static string StreetAddress;
    public static string Surname;
    public static string System;
    public static string Thumbprint;
    public static string Upn;
    public static string Uri;
    public static string Webpage;
    public static string X500DistinguishedName;
    internal static string ClaimType2009Namespace;
    public static string Actor;
}
[ComVisibleAttribute("False")]
public static class System.Security.Claims.ClaimValueTypes : object {
    private static string XmlSchemaNamespace;
    public static string Base64Binary;
    public static string Base64Octet;
    public static string Boolean;
    public static string Date;
    public static string DateTime;
    public static string Double;
    public static string Fqbn;
    public static string HexBinary;
    public static string Integer;
    public static string Integer32;
    public static string Integer64;
    public static string Sid;
    public static string String;
    public static string Time;
    public static string UInteger32;
    public static string UInteger64;
    private static string SoapSchemaNamespace;
    public static string DnsName;
    public static string Email;
    public static string Rsa;
    public static string UpnName;
    private static string XmlSignatureConstantsNamespace;
    public static string DsaKeyValue;
    public static string KeyInfo;
    public static string RsaKeyValue;
    private static string XQueryOperatorsNameSpace;
    public static string DaytimeDuration;
    public static string YearMonthDuration;
    private static string Xacml10Namespace;
    public static string Rfc822Name;
    public static string X500Name;
}
[ComVisibleAttribute("False")]
internal class System.Security.Claims.RoleClaimProvider : object {
    private string m_issuer;
    private String[] m_roles;
    private ClaimsIdentity m_subject;
    public IEnumerable`1<Claim> Claims { get; }
    public RoleClaimProvider(string issuer, String[] roles, ClaimsIdentity subject);
    [IteratorStateMachineAttribute("System.Security.Claims.RoleClaimProvider/<get_Claims>d__5")]
public IEnumerable`1<Claim> get_Claims();
}
[MonoTODOAttribute("CAS support is experimental (and unsupported).")]
[ComVisibleAttribute("True")]
public abstract class System.Security.CodeAccessPermission : object {
    [SecuritySafeCriticalAttribute]
[MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public sealed virtual void Assert();
    public abstract virtual IPermission Copy();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
[SecuritySafeCriticalAttribute]
public sealed virtual void Deny();
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    public abstract virtual void FromXml(SecurityElement elem);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public virtual string ToString();
    public abstract virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
    [SecuritySafeCriticalAttribute]
[MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public sealed virtual void PermitOnly();
    [MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public static void RevertAll();
    [MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public static void RevertAssert();
    [MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public static void RevertDeny();
    [MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public static void RevertPermitOnly();
    internal SecurityElement Element(int version);
    internal static PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted);
    internal static int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
    internal static bool IsUnrestricted(SecurityElement se);
    internal static void ThrowInvalidPermission(IPermission target, Type expected);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Aes();
    public static Aes Create();
    public static Aes Create(string algorithmName);
}
public class System.Security.Cryptography.AesCcm : object {
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesCcm(Byte[] key);
    public AesCcm(ReadOnlySpan`1<byte> key);
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
public class System.Security.Cryptography.AesGcm : object {
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesGcm(Byte[] key);
    public AesGcm(ReadOnlySpan`1<byte> key);
    public static KeySizes get_NonceByteSizes();
    public static KeySizes get_TagByteSizes();
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    protected KeySizes[] LegalKeySizesValue;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    public string KeyExchangeAlgorithm { get; }
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public virtual string get_KeyExchangeAlgorithm();
    public static AsymmetricAlgorithm Create();
    public static AsymmetricAlgorithm Create(string algName);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportPkcs8PrivateKey();
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    public string Parameters { get; }
    public abstract virtual string get_Parameters();
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    public static CipherMode ECB;
    public static CipherMode OFB;
    public static CipherMode CFB;
    public static CipherMode CTS;
}
internal static class System.Security.Cryptography.Constants : object {
    internal static int S_OK;
    internal static int NTE_FILENOTFOUND;
    internal static int NTE_NO_KEY;
    internal static int NTE_BAD_KEYSET;
    internal static int NTE_KEYSET_NOT_DEF;
    internal static int KP_IV;
    internal static int KP_MODE;
    internal static int KP_MODE_BITS;
    internal static int KP_EFFECTIVE_KEYLEN;
    internal static int ALG_CLASS_SIGNATURE;
    internal static int ALG_CLASS_DATA_ENCRYPT;
    internal static int ALG_CLASS_HASH;
    internal static int ALG_CLASS_KEY_EXCHANGE;
    internal static int ALG_TYPE_DSS;
    internal static int ALG_TYPE_RSA;
    internal static int ALG_TYPE_BLOCK;
    internal static int ALG_TYPE_STREAM;
    internal static int ALG_TYPE_ANY;
    internal static int CALG_MD5;
    internal static int CALG_SHA1;
    internal static int CALG_SHA_256;
    internal static int CALG_SHA_384;
    internal static int CALG_SHA_512;
    internal static int CALG_RSA_KEYX;
    internal static int CALG_RSA_SIGN;
    internal static int CALG_DSS_SIGN;
    internal static int CALG_DES;
    internal static int CALG_RC2;
    internal static int CALG_3DES;
    internal static int CALG_3DES_112;
    internal static int CALG_AES_128;
    internal static int CALG_AES_192;
    internal static int CALG_AES_256;
    internal static int CALG_RC4;
    internal static int PROV_RSA_FULL;
    internal static int PROV_DSS_DH;
    internal static int PROV_RSA_AES;
    internal static int AT_KEYEXCHANGE;
    internal static int AT_SIGNATURE;
    internal static int PUBLICKEYBLOB;
    internal static int PRIVATEKEYBLOB;
    internal static int CRYPT_OAEP;
    internal static UInt32 CRYPT_VERIFYCONTEXT;
    internal static UInt32 CRYPT_NEWKEYSET;
    internal static UInt32 CRYPT_DELETEKEYSET;
    internal static UInt32 CRYPT_MACHINE_KEYSET;
    internal static UInt32 CRYPT_SILENT;
    internal static UInt32 CRYPT_EXPORTABLE;
    internal static UInt32 CLR_KEYLEN;
    internal static UInt32 CLR_PUBLICKEYONLY;
    internal static UInt32 CLR_EXPORTABLE;
    internal static UInt32 CLR_REMOVABLE;
    internal static UInt32 CLR_HARDWARE;
    internal static UInt32 CLR_ACCESSIBLE;
    internal static UInt32 CLR_PROTECTED;
    internal static UInt32 CLR_UNIQUE_CONTAINER;
    internal static UInt32 CLR_ALGID;
    internal static UInt32 CLR_PP_CLIENT_HWND;
    internal static UInt32 CLR_PP_PIN;
    internal static string OID_RSA_SMIMEalgCMS3DESwrap;
    internal static string OID_RSA_MD5;
    internal static string OID_RSA_RC2CBC;
    internal static string OID_RSA_DES_EDE3_CBC;
    internal static string OID_OIWSEC_desCBC;
    internal static string OID_OIWSEC_SHA1;
    internal static string OID_OIWSEC_SHA256;
    internal static string OID_OIWSEC_SHA384;
    internal static string OID_OIWSEC_SHA512;
    internal static string OID_OIWSEC_RIPEMD160;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptoAPITransform : object {
    private bool m_disposed;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public IntPtr KeyHandle { get; }
    public int OutputBlockSize { get; }
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public IntPtr get_KeyHandle();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public void Clear();
    private void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [SecuritySafeCriticalAttribute]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [ComVisibleAttribute("False")]
public void Reset();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptoConfig : object {
    private static object lockObject;
    private static Dictionary`2<string, Type> algorithms;
    [MonoLimitationAttribute("nothing is FIPS certified so it never make sense to restrict to this (empty) subset")]
public static bool AllowOnlyFipsAlgorithms { get; }
    private static CryptoConfig();
    public static void AddOID(string oid, String[] names);
    public static object CreateFromName(string name);
    [PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension", "System")]
[PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension", "System")]
[PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension", "System")]
[PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.X509Certificates.X509KeyUsageExtension", "System")]
[PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.X509Certificates.X509Chain", "System")]
[PreserveDependencyAttribute(".ctor()", "System.Security.Cryptography.AesCryptoServiceProvider", "System.Core")]
public static object CreateFromName(string name, Object[] args);
    internal static string MapNameToOID(string name, object arg);
    public static string MapNameToOID(string name);
    private static void Initialize();
    public static void AddAlgorithm(Type algorithm, String[] names);
    public static Byte[] EncodeOID(string str);
    private static Byte[] EncodeLongNumber(long x);
    public static bool get_AllowOnlyFipsAlgorithms();
}
internal static class System.Security.Cryptography.CryptoConfigForwarder : object {
    internal static object CreateFromName(string name);
    internal static HashAlgorithm CreateDefaultHashAlgorithm();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    public CryptographicException(string message);
    public CryptographicException(string format, string insert);
    public CryptographicException(string message, Exception inner);
    [SecuritySafeCriticalAttribute]
public CryptographicException(int hr);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
    private static void ThrowCryptographicException(int hr);
}
public static class System.Security.Cryptography.CryptographicOperations : object {
    public static bool FixedTimeEquals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static void ZeroMemory(Span`1<byte> buffer);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    public CryptographicUnexpectedOperationException(string message);
    public CryptographicUnexpectedOperationException(string format, string insert);
    public CryptographicUnexpectedOperationException(string message, Exception inner);
    protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
}
public class System.Security.Cryptography.CryptoStream : Stream {
    private Stream _stream;
    private ICryptoTransform _transform;
    private CryptoStreamMode _transformMode;
    private Byte[] _inputBuffer;
    private int _inputBufferIndex;
    private int _inputBlockSize;
    private Byte[] _outputBuffer;
    private int _outputBufferIndex;
    private int _outputBlockSize;
    private bool _canRead;
    private bool _canWrite;
    private bool _finalBlockTransformed;
    private SemaphoreSlim _lazyAsyncActiveSemaphore;
    private bool _leaveOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool HasFlushedFinalBlock { get; }
    private SemaphoreSlim AsyncActiveSemaphore { get; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public bool get_HasFlushedFinalBlock();
    public void FlushFinalBlock();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncInternal>d__37")]
private Task`1<int> ReadAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CheckReadArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncCore>d__42")]
private Task`1<int> ReadAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, bool useAsync);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncInternal>d__46")]
private Task WriteAsyncInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void CheckWriteArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncCore>d__49")]
private Task WriteAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, bool useAsync);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    private void InitializeBuffer();
    private SemaphoreSlim get_AsyncActiveSemaphore();
}
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
internal enum System.Security.Cryptography.CspAlgorithmType : Enum {
    public int value__;
    public static CspAlgorithmType Rsa;
    public static CspAlgorithmType Dss;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    private CspParameters _params;
    internal bool _random;
    public bool Accessible { get; }
    public CryptoKeySecurity CryptoKeySecurity { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    public string UniqueKeyContainerName { get; }
    public CspKeyContainerInfo(CspParameters parameters);
    public bool get_Accessible();
    public CryptoKeySecurity get_CryptoKeySecurity();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    public string get_UniqueKeyContainerName();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.CspParameters : object {
    public int ProviderType;
    public string ProviderName;
    public string KeyContainerName;
    public int KeyNumber;
    private int m_flags;
    private CryptoKeySecurity m_cryptoKeySecurity;
    private SecureString m_keyPassword;
    private IntPtr m_parentWindowHandle;
    public CspProviderFlags Flags { get; public set; }
    public CryptoKeySecurity CryptoKeySecurity { get; public set; }
    public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, SecureString keyPassword);
    public CspParameters(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, IntPtr parentWindowHandle);
    internal CspParameters(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);
    internal CspParameters(CspParameters parameters);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    public CryptoKeySecurity get_CryptoKeySecurity();
    public void set_CryptoKeySecurity(CryptoKeySecurity value);
    public SecureString get_KeyPassword();
    public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DeriveBytes : object {
    public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static DES();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static DES Create();
    public static DES Create(string algName);
    public static bool IsWeakKey(Byte[] rgbKey);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    private static bool IsLegalKeySize(Byte[] rgbKey);
    private static ulong QuadWordFromBigEndian(Byte[] block);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
internal class System.Security.Cryptography.DESTransform : SymmetricTransform {
    internal static int KEY_BIT_SIZE;
    internal static int KEY_BYTE_SIZE;
    internal static int BLOCK_BIT_SIZE;
    internal static int BLOCK_BYTE_SIZE;
    private Byte[] keySchedule;
    private Byte[] byteBuff;
    private UInt32[] dwordBuff;
    private static UInt32[] spBoxes;
    private static Byte[] PC1;
    private static Byte[] leftRotTotal;
    private static Byte[] PC2;
    internal static UInt32[] ipTab;
    internal static UInt32[] fpTab;
    internal DESTransform(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] key, Byte[] iv);
    private static DESTransform();
    private UInt32 CipherFunct(UInt32 r, int n);
    internal static void Permutation(Byte[] input, Byte[] output, UInt32[] permTab, bool preSwap);
    private static void BSwap(Byte[] byteBuff);
    internal void SetKey(Byte[] key);
    public void ProcessBlock(Byte[] input, Byte[] output);
    protected virtual void ECB(Byte[] input, Byte[] output);
    internal static Byte[] GetStrongKey();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public static DSA Create();
    public static DSA Create(string algName);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    private static Exception DerivedClassMustOverride();
    internal static Exception HashAlgorithmNameNullOrEmpty();
    public static DSA Create(int keySizeInBits);
    public static DSA Create(DSAParameters parameters);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    private static int PROV_DSS_DH;
    private KeyPairPersistence store;
    private bool persistKey;
    private bool persisted;
    private bool privateKeyExportable;
    private bool m_disposed;
    private DSAManaged dsa;
    private static bool useMachineKeyStore;
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public bool PersistKeyInCsp { get; public set; }
    [ComVisibleAttribute("False")]
public bool PublicOnly { get; }
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [MonoTODOAttribute("call into KeyPairPersistence to get details")]
[ComVisibleAttribute("False")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public DSACryptoServiceProvider(CspParameters parameters);
    public DSACryptoServiceProvider(int dwKeySize);
    public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    private void Common(int dwKeySize, bool parameters);
    private void Common(CspParameters parameters);
    protected virtual override void Finalize();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    protected virtual void Dispose(bool disposing);
    private void OnKeyGenerated(object sender, EventArgs e);
    [SecuritySafeCriticalAttribute]
public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public sealed virtual void ImportCspBlob(Byte[] keyBlob);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSAParameters : ValueType {
    public Byte[] P;
    public Byte[] Q;
    public Byte[] G;
    public Byte[] Y;
    public Byte[] J;
    public Byte[] X;
    public Byte[] Seed;
    public int Counter;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    private DSA _dsaKey;
    private string _oid;
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
internal class System.Security.Cryptography.DSASignatureDescription : SignatureDescription {
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    private DSA _dsaKey;
    private string _oid;
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.FromBase64Transform : object {
    private Byte[] _inputBuffer;
    private int _inputIndex;
    private FromBase64TransformMode _whitespaces;
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] DiscardWhiteSpaces(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    private void Reset();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    private bool _disposed;
    protected int HashSizeValue;
    protected internal Byte[] HashValue;
    protected int State;
    public int HashSize { get; }
    public Byte[] Hash { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public static HashAlgorithm Create();
    public static HashAlgorithm Create(string hashName);
    public virtual int get_HashSize();
    public virtual Byte[] get_Hash();
    public Byte[] ComputeHash(Byte[] buffer);
    public bool TryComputeHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public Byte[] ComputeHash(Stream inputStream);
    private Byte[] CaptureHashCodeAndReinitialize();
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected abstract virtual Byte[] HashFinal();
    public abstract virtual void Initialize();
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[IsReadOnlyAttribute]
public class System.Security.Cryptography.HashAlgorithmName : ValueType {
    private string _name;
    public static HashAlgorithmName MD5 { get; }
    public static HashAlgorithmName SHA1 { get; }
    public static HashAlgorithmName SHA256 { get; }
    public static HashAlgorithmName SHA384 { get; }
    public static HashAlgorithmName SHA512 { get; }
    public string Name { get; }
    public HashAlgorithmName(string name);
    public static HashAlgorithmName get_MD5();
    public static HashAlgorithmName get_SHA1();
    public static HashAlgorithmName get_SHA256();
    public static HashAlgorithmName get_SHA384();
    public static HashAlgorithmName get_SHA512();
    public string get_Name();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashAlgorithmName other);
    public virtual int GetHashCode();
    public static bool op_Equality(HashAlgorithmName left, HashAlgorithmName right);
    public static bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    private int blockSizeValue;
    internal string m_hashName;
    internal HashAlgorithm m_hash1;
    internal HashAlgorithm m_hash2;
    private Byte[] m_inner;
    private Byte[] m_outer;
    private bool m_hashing;
    protected int BlockSizeValue { get; protected set; }
    public Byte[] Key { get; public set; }
    public string HashName { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    private void UpdateIOPadBuffers();
    internal void InitializeKey(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public string get_HashName();
    public void set_HashName(string value);
    public static HMAC Create();
    public static HMAC Create(string algorithmName);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual Byte[] HashFinal();
    protected virtual void Dispose(bool disposing);
    internal static HashAlgorithm GetHashAlgorithmWithFipsFallback(Func`1<HashAlgorithm> createStandardHashAlgorithmCallback, Func`1<HashAlgorithm> createFipsHashAlgorithmCallback);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public HMACMD5(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACRIPEMD160 : HMAC {
    public HMACRIPEMD160(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public HMACSHA1(Byte[] key);
    public HMACSHA1(Byte[] key, bool useManagedSha1);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public HMACSHA256(Byte[] key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    private bool m_useLegacyBlockSize;
    private int BlockSize { get; }
    public bool ProduceLegacyHmacValues { get; public set; }
    [SecuritySafeCriticalAttribute]
public HMACSHA384(Byte[] key);
    private int get_BlockSize();
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    private bool m_useLegacyBlockSize;
    private int BlockSize { get; }
    public bool ProduceLegacyHmacValues { get; public set; }
    [SecuritySafeCriticalAttribute]
public HMACSHA512(Byte[] key);
    private int get_BlockSize();
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
}
[ComVisibleAttribute("True")]
public interface System.Security.Cryptography.ICryptoTransform {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static KeyedHashAlgorithm Create();
    public static KeyedHashAlgorithm Create(string algName);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.KeySizes : object {
    private int m_minSize;
    private int m_maxSize;
    private int m_skipSize;
    public int MinSize { get; }
    public int MaxSize { get; }
    public int SkipSize { get; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    public int get_MinSize();
    public int get_MaxSize();
    public int get_SkipSize();
    internal bool IsLegal(int keySize);
    internal static bool IsLegalKeySize(KeySizes[] legalKeys, int size);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.MACTripleDES : KeyedHashAlgorithm {
    private ICryptoTransform m_encryptor;
    private CryptoStream _cs;
    private TailStream _ts;
    private static int m_bitsPerByte;
    private int m_bytesPerBlock;
    private TripleDES des;
    [ComVisibleAttribute("False")]
public PaddingMode Padding { get; public set; }
    public MACTripleDES(Byte[] rgbKey);
    public MACTripleDES(string strTripleDES, Byte[] rgbKey);
    public virtual void Initialize();
    public PaddingMode get_Padding();
    public void set_Padding(PaddingMode value);
    protected virtual void HashCore(Byte[] rgbData, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    [ComVisibleAttribute("True")]
public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static MD5 Create();
    public static MD5 Create(string algName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private UInt32[] buff;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private static UInt32[] K;
    private static MD5CryptoServiceProvider();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, int inputOffset);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
[ComVisibleAttribute("True")]
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    private int _extraCount;
    private int _prefix;
    private int _iterations;
    private Byte[] _baseValue;
    private Byte[] _extra;
    private Byte[] _salt;
    private string _hashName;
    private Byte[] _password;
    private HashAlgorithm _hash;
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    [SecuritySafeCriticalAttribute]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    private Byte[] ComputeBaseValue();
    [SecurityCriticalAttribute]
private Byte[] ComputeBytes(int cb);
    private void HashPrefix(CryptoStream cs);
}
public enum System.Security.Cryptography.PbeEncryptionAlgorithm : Enum {
    public int value__;
    public static PbeEncryptionAlgorithm Unknown;
    public static PbeEncryptionAlgorithm Aes128Cbc;
    public static PbeEncryptionAlgorithm Aes192Cbc;
    public static PbeEncryptionAlgorithm Aes256Cbc;
    public static PbeEncryptionAlgorithm TripleDes3KeyPkcs12;
}
public class System.Security.Cryptography.PbeParameters : object {
    [CompilerGeneratedAttribute]
private PbeEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationCount>k__BackingField;
    public PbeEncryptionAlgorithm EncryptionAlgorithm { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; }
    public PbeParameters(PbeEncryptionAlgorithm encryptionAlgorithm, HashAlgorithmName hashAlgorithm, int iterationCount);
    [CompilerGeneratedAttribute]
public PbeEncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public int get_IterationCount();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    private string HashNameValue;
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetNonZeroBytes(Byte[] data);
    public static void Fill(Span`1<byte> data);
    internal static void FillSpan(Span`1<byte> data);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public static int GetInt32(int toExclusive);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public int EffectiveKeySize { get; public set; }
    public int KeySize { get; public set; }
    private static RC2();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public static RC2 Create();
    public static RC2 Create(string AlgName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    private bool m_use40bitSalt;
    private static KeySizes[] s_legalKeySizes;
    public int EffectiveKeySize { get; public set; }
    [ComVisibleAttribute("False")]
public bool UseSalt { get; public set; }
    private static RC2CryptoServiceProvider();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    public void set_UseSalt(bool value);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
internal class System.Security.Cryptography.RC2Transform : SymmetricTransform {
    private ushort R0;
    private ushort R1;
    private ushort R2;
    private ushort R3;
    private UInt16[] K;
    private int j;
    private static Byte[] pitable;
    public RC2Transform(RC2 rc2Algo, bool encryption, Byte[] key, Byte[] iv);
    private static RC2Transform();
    protected virtual void ECB(Byte[] input, Byte[] output);
}
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    private static int MinimumSaltSize;
    private Byte[] _password;
    private Byte[] _salt;
    private UInt32 _iterations;
    private HMAC _hmac;
    private int _blockSize;
    private Byte[] _buffer;
    private UInt32 _block;
    private int _startIndex;
    private int _endIndex;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, Byte[] salt);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, int saltSize);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    public virtual void Reset();
    private HMAC OpenHmac();
    private void Initialize();
    private Byte[] Func();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Rijndael();
    public static Rijndael Create();
    public static Rijndael Create(string algName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    private ICryptoTransform NewEncryptor(Byte[] rgbKey, CipherMode mode, Byte[] rgbIV, int feedbackSize, RijndaelManagedTransformMode encryptMode);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RijndaelManagedTransform : object {
    private CipherMode m_cipherMode;
    private PaddingMode m_paddingValue;
    private RijndaelManagedTransformMode m_transformMode;
    private int m_blockSizeBits;
    private int m_blockSizeBytes;
    private int m_inputBlockSize;
    private int m_outputBlockSize;
    private Int32[] m_encryptKeyExpansion;
    private Int32[] m_decryptKeyExpansion;
    private int m_Nr;
    private int m_Nb;
    private int m_Nk;
    private Int32[] m_encryptindex;
    private Int32[] m_decryptindex;
    private Int32[] m_IV;
    private Int32[] m_lastBlockBuffer;
    private Byte[] m_depadBuffer;
    private Byte[] m_shiftRegister;
    private static Byte[] s_Sbox;
    private static Int32[] s_Rcon;
    private static Int32[] s_T;
    private static Int32[] s_TF;
    private static Int32[] s_iT;
    private static Int32[] s_iTF;
    public int BlockSizeValue { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    internal RijndaelManagedTransform(Byte[] rgbKey, CipherMode mode, Byte[] rgbIV, int blockSize, int feedbackSize, PaddingMode PaddingValue, RijndaelManagedTransformMode transformMode);
    private static RijndaelManagedTransform();
    public sealed virtual void Dispose();
    public void Clear();
    private void Dispose(bool disposing);
    public int get_BlockSizeValue();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public void Reset();
    [SecuritySafeCriticalAttribute]
private int EncryptData(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[]& outputBuffer, int outputOffset, PaddingMode paddingMode, bool fLast);
    [SecuritySafeCriticalAttribute]
private int DecryptData(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[]& outputBuffer, int outputOffset, PaddingMode paddingMode, bool fLast);
    [SecurityCriticalAttribute]
private void Enc(Int32* encryptindex, Int32* encryptKeyExpansion, Int32* T, Int32* TF, Int32* work, Int32* temp);
    [SecurityCriticalAttribute]
private void Dec(Int32* decryptindex, Int32* decryptKeyExpansion, Int32* iT, Int32* iTF, Int32* work, Int32* temp);
    private void GenerateKeyExpansion(Byte[] rgbKey);
    private static int rot1(int val);
    private static int rot2(int val);
    private static int rot3(int val);
    private static int SubWord(int a);
    private static int MulX(int x);
}
internal enum System.Security.Cryptography.RijndaelManagedTransformMode : Enum {
    public int value__;
    public static RijndaelManagedTransformMode Encrypt;
    public static RijndaelManagedTransformMode Decrypt;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RIPEMD160 : HashAlgorithm {
    public static RIPEMD160 Create();
    public static RIPEMD160 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RIPEMD160Managed : RIPEMD160 {
    private Byte[] _buffer;
    private long _count;
    private UInt32[] _stateMD160;
    private UInt32[] _blockDWords;
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
    private void InitializeState();
    [SecurityCriticalAttribute]
private void _HashData(Byte[] partIn, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
private Byte[] _EndHash();
    [SecurityCriticalAttribute]
private static void MDTransform(UInt32* blockDWords, UInt32* state, Byte* block);
    private static UInt32 F(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 G(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 H(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 I(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 J(UInt32 x, UInt32 y, UInt32 z);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    private static object _lock;
    private IntPtr _handle;
    private static RNGCryptoServiceProvider();
    public RNGCryptoServiceProvider(Byte[] rgb);
    public RNGCryptoServiceProvider(CspParameters cspParams);
    public RNGCryptoServiceProvider(string str);
    private void Check();
    private static bool RngOpen();
    private static IntPtr RngInitialize(Byte* seed, IntPtr seed_length);
    private static IntPtr RngGetBytes(IntPtr handle, Byte* data, IntPtr data_length);
    private static void RngClose(IntPtr handle);
    public virtual void GetBytes(Byte[] data);
    internal void GetBytes(Byte* data, IntPtr data_length);
    public virtual void GetNonZeroBytes(Byte[] data);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public static RSA Create();
    public static RSA Create(string algName);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    private static Exception DerivedClassMustOverride();
    internal static Exception HashAlgorithmNameNullOrEmpty();
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public static RSA Create(int keySizeInBits);
    public static RSA Create(RSAParameters parameters);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] ExportRSAPrivateKey();
    public virtual Byte[] ExportRSAPublicKey();
    public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    private static CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_UseMachineKeyStore;
    private static int PROV_RSA_FULL;
    private static int AT_KEYEXCHANGE;
    private static int AT_SIGNATURE;
    private KeyPairPersistence store;
    private bool persistKey;
    private bool persisted;
    private bool privateKeyExportable;
    private bool m_disposed;
    private RSAManaged rsa;
    public string SignatureAlgorithm { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; }
    public bool PersistKeyInCsp { get; public set; }
    [ComVisibleAttribute("False")]
public bool PublicOnly { get; }
    [ComVisibleAttribute("False")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public RSACryptoServiceProvider(CspParameters parameters);
    public RSACryptoServiceProvider(int dwKeySize);
    public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    public virtual string get_SignatureAlgorithm();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    private static int GetAlgorithmId(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    private static Exception PaddingModeNotSupported();
    private void Common(int dwKeySize, bool parameters);
    private void Common(CspParameters p);
    protected virtual override void Finalize();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual int get_KeySize();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    private HashAlgorithm GetHash(object halg);
    private HashAlgorithm GetHashFromString(string name);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    private string GetHashNameFromOID(string oid);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    private Byte[] SignHash(Byte[] rgbHash, int calgHash);
    private static HashAlgorithm InternalHashToHashAlgorithm(int calgHash);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    private bool VerifyHash(Byte[] rgbHash, int calgHash, Byte[] rgbSignature);
    protected virtual void Dispose(bool disposing);
    private void OnKeyGenerated(object sender, EventArgs e);
    [SecuritySafeCriticalAttribute]
public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    [SecuritySafeCriticalAttribute]
[ComVisibleAttribute("False")]
public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    [ComVisibleAttribute("False")]
[SecuritySafeCriticalAttribute]
public sealed virtual void ImportCspBlob(Byte[] keyBlob);
}
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    private static RSAEncryptionPadding s_pkcs1;
    private static RSAEncryptionPadding s_oaepSHA1;
    private static RSAEncryptionPadding s_oaepSHA256;
    private static RSAEncryptionPadding s_oaepSHA384;
    private static RSAEncryptionPadding s_oaepSHA512;
    private RSAEncryptionPaddingMode _mode;
    private HashAlgorithmName _oaepHashAlgorithm;
    public static RSAEncryptionPadding Pkcs1 { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    private RSAEncryptionPadding(RSAEncryptionPaddingMode mode, HashAlgorithmName oaepHashAlgorithm);
    private static RSAEncryptionPadding();
    public static RSAEncryptionPadding get_Pkcs1();
    public static RSAEncryptionPadding get_OaepSHA1();
    public static RSAEncryptionPadding get_OaepSHA256();
    public static RSAEncryptionPadding get_OaepSHA384();
    public static RSAEncryptionPadding get_OaepSHA512();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public virtual int GetHashCode();
    private static int CombineHashCodes(int h1, int h2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSAEncryptionPadding other);
    public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Pkcs1;
    public static RSAEncryptionPaddingMode Oaep;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    private Nullable`1<bool> _rsaOverridesDecrypt;
    public string Parameters { get; public set; }
    private bool OverridesDecrypt { get; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
    private bool get_OverridesDecrypt();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private Byte[] ParameterValue;
    private RSA _rsaKey;
    private Nullable`1<bool> _rsaOverridesEncrypt;
    private RandomNumberGenerator RngValue;
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    private bool OverridesEncrypt { get; }
    public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    [SecuritySafeCriticalAttribute]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    private bool get_OverridesEncrypt();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] Exponent;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] InverseQ;
    public Byte[] D;
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    private Nullable`1<bool> _rsaOverridesDecrypt;
    private RandomNumberGenerator RngValue;
    public RandomNumberGenerator RNG { get; public set; }
    public string Parameters { get; public set; }
    private bool OverridesDecrypt { get; }
    public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    public virtual void SetKey(AsymmetricAlgorithm key);
    private bool get_OverridesDecrypt();
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RandomNumberGenerator RngValue;
    private RSA _rsaKey;
    private Nullable`1<bool> _rsaOverridesEncrypt;
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    private bool OverridesEncrypt { get; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    private bool get_OverridesEncrypt();
}
internal class System.Security.Cryptography.RSAPKCS1SHA1SignatureDescription : RSAPKCS1SignatureDescription {
}
internal class System.Security.Cryptography.RSAPKCS1SHA256SignatureDescription : RSAPKCS1SignatureDescription {
}
internal class System.Security.Cryptography.RSAPKCS1SHA384SignatureDescription : RSAPKCS1SignatureDescription {
}
internal class System.Security.Cryptography.RSAPKCS1SHA512SignatureDescription : RSAPKCS1SignatureDescription {
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    private RSA rsa;
    private string hashName;
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
internal abstract class System.Security.Cryptography.RSAPKCS1SignatureDescription : SignatureDescription {
    private string _hashAlgorithm;
    protected RSAPKCS1SignatureDescription(string hashAlgorithm, string digestAlgorithm);
    public sealed virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public sealed virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    private RSA rsa;
    private string hash;
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual void SetHashAlgorithm(string strName);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSASignaturePadding : object {
    private static RSASignaturePadding s_pkcs1;
    private static RSASignaturePadding s_pss;
    private RSASignaturePaddingMode _mode;
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode Mode { get; }
    private RSASignaturePadding(RSASignaturePaddingMode mode);
    private static RSASignaturePadding();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    public RSASignaturePaddingMode get_Mode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSASignaturePadding other);
    public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static SHA1 Create();
    public static SHA1 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    private SHA1Internal sha;
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual void Initialize();
}
internal class System.Security.Cryptography.SHA1Internal : object {
    private static int BLOCK_SIZE_BYTES;
    private UInt32[] _H;
    private ulong count;
    private Byte[] _ProcessingBuffer;
    private int _ProcessingBufferCount;
    private UInt32[] buff;
    public void HashCore(Byte[] rgb, int ibStart, int cbSize);
    public Byte[] HashFinal();
    public void Initialize();
    private void ProcessBlock(Byte[] inputBuffer, UInt32 inputOffset);
    private static void InitialiseBuff(UInt32[] buff, Byte[] input, UInt32 inputOffset);
    private static void FillBuff(UInt32[] buff);
    private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void AddLength(ulong length, Byte[] buffer, int position);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    private Byte[] _buffer;
    private long _count;
    private UInt32[] _stateSHA1;
    private UInt32[] _expandedBuffer;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void InitializeState();
    [SecuritySafeCriticalAttribute]
private void _HashData(Byte[] partIn, int ibStart, int cbSize);
    private Byte[] _EndHash();
    [SecurityCriticalAttribute]
private static void SHATransform(UInt32* expandedBuffer, UInt32* state, Byte* block);
    [SecurityCriticalAttribute]
private static void SHAExpand(UInt32* x);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static SHA256 Create();
    public static SHA256 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    private Byte[] _buffer;
    private long _count;
    private UInt32[] _stateSHA256;
    private UInt32[] _W;
    private static UInt32[] _K;
    private static SHA256Managed();
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    private void InitializeState();
    [SecuritySafeCriticalAttribute]
private void _HashData(Byte[] partIn, int ibStart, int cbSize);
    private Byte[] _EndHash();
    [SecurityCriticalAttribute]
private static void SHATransform(UInt32* expandedBuffer, UInt32* state, Byte* block);
    private static UInt32 RotateRight(UInt32 x, int n);
    private static UInt32 Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 sigma_0(UInt32 x);
    private static UInt32 sigma_1(UInt32 x);
    private static UInt32 Sigma_0(UInt32 x);
    private static UInt32 Sigma_1(UInt32 x);
    [SecurityCriticalAttribute]
private static void SHA256Expand(UInt32* x);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static SHA384 Create();
    public static SHA384 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    private Byte[] _buffer;
    private ulong _count;
    private UInt64[] _stateSHA384;
    private UInt64[] _W;
    private static UInt64[] _K;
    private static SHA384Managed();
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
    private void InitializeState();
    [SecurityCriticalAttribute]
private void _HashData(Byte[] partIn, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
private Byte[] _EndHash();
    [SecurityCriticalAttribute]
private static void SHATransform(UInt64* expandedBuffer, UInt64* state, Byte* block);
    private static ulong RotateRight(ulong x, int n);
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sigma_0(ulong x);
    private static ulong Sigma_1(ulong x);
    private static ulong sigma_0(ulong x);
    private static ulong sigma_1(ulong x);
    [SecurityCriticalAttribute]
private static void SHA384Expand(UInt64* x);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static SHA512 Create();
    public static SHA512 Create(string hashName);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    private Byte[] _buffer;
    private ulong _count;
    private UInt64[] _stateSHA512;
    private UInt64[] _W;
    private static UInt64[] _K;
    private static SHA512Managed();
    public virtual void Initialize();
    [SecuritySafeCriticalAttribute]
protected virtual void HashCore(Byte[] rgb, int ibStart, int cbSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] HashFinal();
    private void InitializeState();
    [SecurityCriticalAttribute]
private void _HashData(Byte[] partIn, int ibStart, int cbSize);
    [SecurityCriticalAttribute]
private Byte[] _EndHash();
    [SecurityCriticalAttribute]
private static void SHATransform(UInt64* expandedBuffer, UInt64* state, Byte* block);
    private static ulong RotateRight(ulong x, int n);
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sigma_0(ulong x);
    private static ulong Sigma_1(ulong x);
    private static ulong sigma_0(ulong x);
    private static ulong sigma_1(ulong x);
    [SecurityCriticalAttribute]
private static void SHA512Expand(UInt64* x);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.SignatureDescription : object {
    private string _strKey;
    private string _strDigest;
    private string _strFormatter;
    private string _strDeformatter;
    public string KeyAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string DeformatterAlgorithm { get; public set; }
    public SignatureDescription(SecurityElement el);
    public string get_KeyAlgorithm();
    public void set_KeyAlgorithm(string value);
    public string get_DigestAlgorithm();
    public void set_DigestAlgorithm(string value);
    public string get_FormatterAlgorithm();
    public void set_FormatterAlgorithm(string value);
    public string get_DeformatterAlgorithm();
    public void set_DeformatterAlgorithm(string value);
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
    public virtual HashAlgorithm CreateDigest();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    protected Byte[] IVValue;
    protected Byte[] KeyValue;
    protected KeySizes[] LegalBlockSizesValue;
    protected KeySizes[] LegalKeySizesValue;
    protected int KeySizeValue;
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public bool ValidKeySize(int bitLength);
    public static SymmetricAlgorithm Create();
    public static SymmetricAlgorithm Create(string algName);
    public virtual ICryptoTransform CreateEncryptor();
    public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public abstract virtual void GenerateKey();
    public abstract virtual void GenerateIV();
}
internal class System.Security.Cryptography.TailStream : Stream {
    private Byte[] _Buffer;
    private int _BufferSize;
    private int _BufferIndex;
    private bool _BufferFull;
    public Byte[] Buffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TailStream(int bufferSize);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public Byte[] get_Buffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.ToBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static TripleDES();
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static TripleDES Create();
    public static TripleDES Create(string str);
    public static bool IsWeakKey(Byte[] rgbKey);
    private static bool EqualBytes(Byte[] rgbKey, int start1, int start2, int count);
    private static bool IsLegalKeySize(Byte[] rgbKey);
}
[ComVisibleAttribute("True")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    [SecuritySafeCriticalAttribute]
public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
}
internal class System.Security.Cryptography.TripleDESTransform : SymmetricTransform {
    private DESTransform E1;
    private DESTransform D2;
    private DESTransform E3;
    private DESTransform D1;
    private DESTransform E2;
    private DESTransform D3;
    public TripleDESTransform(TripleDES algo, bool encryption, Byte[] key, Byte[] iv);
    protected virtual void ECB(Byte[] input, Byte[] output);
    internal static Byte[] GetStrongKey();
}
internal static class System.Security.Cryptography.Utils : object {
    internal static int DefaultRsaProviderType;
    private static RNGCryptoServiceProvider modreq(System.Runtime.CompilerServices.IsVolatile) _rng;
    internal static RNGCryptoServiceProvider StaticRandomNumberGenerator { get; }
    private static Utils();
    internal static RNGCryptoServiceProvider get_StaticRandomNumberGenerator();
    internal static Byte[] GenerateRandom(int keySize);
    [SecurityCriticalAttribute]
internal static bool HasAlgorithm(int dwCalg, int dwKeySize);
    internal static string DiscardWhiteSpaces(string inputBuffer);
    internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
    internal static int ConvertByteArrayToInt(Byte[] input);
    internal static Byte[] ConvertIntToByteArray(int dwInput);
    internal static void ConvertIntToByteArray(UInt32 dwInput, Byte[]& counter);
    internal static Byte[] FixupKeyParity(Byte[] key);
    [SecurityCriticalAttribute]
internal static void DWORDFromLittleEndian(UInt32* x, int digits, Byte* block);
    internal static void DWORDToLittleEndian(Byte[] block, UInt32[] x, int digits);
    [SecurityCriticalAttribute]
internal static void DWORDFromBigEndian(UInt32* x, int digits, Byte* block);
    internal static void DWORDToBigEndian(Byte[] block, UInt32[] x, int digits);
    [SecurityCriticalAttribute]
internal static void QuadWordFromBigEndian(UInt64* x, int digits, Byte* block);
    internal static void QuadWordToBigEndian(Byte[] block, UInt64[] x, int digits);
    internal static Byte[] Int(UInt32 i);
    [SecurityCriticalAttribute]
internal static Byte[] RsaOaepEncrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, RandomNumberGenerator rng, Byte[] data);
    [SecurityCriticalAttribute]
internal static Byte[] RsaOaepDecrypt(RSA rsa, HashAlgorithm hash, PKCS1MaskGenerationMethod mgf, Byte[] encryptedData);
    [SecurityCriticalAttribute]
internal static Byte[] RsaPkcs1Padding(RSA rsa, Byte[] oid, Byte[] hash);
    internal static bool CompareBigIntArrays(Byte[] lhs, Byte[] rhs);
    internal static HashAlgorithmName OidToHashAlgorithmName(string oid);
    internal static bool DoesRsaKeyOverride(RSA rsaKey, string methodName, Type[] parameterTypes);
    private static bool DoesRsaKeyOverrideSlowPath(Type t, string methodName, Type[] parameterTypes);
    internal static bool _ProduceLegacyHmacValues();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    private X509CertificateImpl impl;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazyCertHash;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) lazySubject;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) lazyPublicKey;
    private DateTime lazyNotBefore;
    private DateTime lazyNotAfter;
    internal static X509KeyStorageFlags KeyStorageFlagsAll;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal X509CertificateImpl Impl { get; }
    internal bool IsValid { get; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    internal X509Certificate(X509CertificateImpl impl);
    public X509Certificate(string fileName);
    public X509Certificate(string fileName, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(X509Certificate cert);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public static X509Certificate CreateFromCertFile(string filename);
    public static X509Certificate CreateFromSignedFile(string filename);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    private Byte[] GetRawCertHash();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    private Byte[] GetRawSerialNumber();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Subject property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetName();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Issuer property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetIssuerName();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [ComVisibleAttribute("False")]
public virtual void Import(Byte[] rawData);
    [ComVisibleAttribute("False")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ComVisibleAttribute("False")]
public virtual void Import(string fileName);
    [ComVisibleAttribute("False")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    protected static string FormatDate(DateTime date);
    internal static void ValidateKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private void VerifyContentType(X509ContentType contentType);
    internal void ImportHandle(X509CertificateImpl impl);
    internal X509CertificateImpl get_Impl();
    internal bool get_IsValid();
    internal void ThrowIfInvalid();
}
internal abstract class System.Security.Cryptography.X509Certificates.X509CertificateImpl : object {
    public bool IsValid { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] RawData { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public bool HasPrivateKey { get; }
    public abstract virtual bool get_IsValid();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual IntPtr GetNativeAppleCertificate();
    protected void ThrowIfContextInvalid();
    public abstract virtual X509CertificateImpl Clone();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual string get_LegacyIssuer();
    public abstract virtual string get_LegacySubject();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_Thumbprint();
    public sealed virtual int GetHashCode();
    public abstract virtual bool Equals(X509CertificateImpl other, Boolean& result);
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual DSA GetDSAPrivateKey();
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    public abstract virtual X509CertificateImpl CopyWithPrivateKey(RSA privateKey);
    public abstract virtual X509Certificate CreateCertificate();
    public sealed virtual bool Equals(object obj);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
internal static class System.Security.Cryptography.X509Certificates.X509Helper : object {
    private static ISystemCertificateProvider CertificateProvider { get; }
    private static ISystemCertificateProvider get_CertificateProvider();
    public static X509CertificateImpl InitFromCertificate(X509Certificate cert);
    public static X509CertificateImpl InitFromCertificate(X509CertificateImpl impl);
    public static bool IsValid(X509CertificateImpl impl);
    internal static void ThrowIfContextInvalid(X509CertificateImpl impl);
    internal static Exception GetInvalidContextException();
    public static X509CertificateImpl Import(Byte[] rawData);
    public static X509CertificateImpl Import(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static Byte[] Export(X509CertificateImpl impl, X509ContentType contentType, SafePasswordHandle password);
    public static bool Equals(X509CertificateImpl first, X509CertificateImpl second);
    public static string ToHexString(Byte[] data);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
[AttributeUsageAttribute("64")]
internal class System.Security.DynamicSecurityMethodAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[MonoTODOAttribute("Not supported in the runtime")]
public class System.Security.HostProtectionException : SystemException {
    private HostProtectionResource _protected;
    private HostProtectionResource _demanded;
    public HostProtectionResource DemandedResources { get; }
    public HostProtectionResource ProtectedResources { get; }
    public HostProtectionException(string message);
    public HostProtectionException(string message, Exception e);
    public HostProtectionException(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources);
    protected HostProtectionException(SerializationInfo info, StreamingContext context);
    public HostProtectionResource get_DemandedResources();
    public HostProtectionResource get_ProtectedResources();
    [MonoTODOAttribute]
[SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [MonoTODOAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.HostSecurityManager : object {
    public PolicyLevel DomainPolicy { get; }
    public HostSecurityManagerOptions Flags { get; }
    public virtual PolicyLevel get_DomainPolicy();
    public virtual HostSecurityManagerOptions get_Flags();
    public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
    public virtual Evidence ProvideAppDomainEvidence(Evidence inputEvidence);
    public virtual Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence);
    public virtual PermissionSet ResolvePolicy(Evidence evidence);
    public virtual EvidenceBase GenerateAppDomainEvidence(Type evidenceType);
    public virtual EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly);
    public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes();
    public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.HostSecurityManagerOptions : Enum {
    public int value__;
    public static HostSecurityManagerOptions None;
    public static HostSecurityManagerOptions HostAppDomainEvidence;
    public static HostSecurityManagerOptions HostPolicyLevel;
    public static HostSecurityManagerOptions HostAssemblyEvidence;
    public static HostSecurityManagerOptions HostDetermineApplicationTrust;
    public static HostSecurityManagerOptions HostResolvePolicy;
    public static HostSecurityManagerOptions AllFlags;
}
public interface System.Security.IEvidenceFactory {
    public Evidence Evidence { get; }
    public abstract virtual Evidence get_Evidence();
}
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    public abstract virtual SecurityElement ToXml();
}
public interface System.Security.ISecurityPolicyEncodable {
    public abstract virtual void FromXml(SecurityElement e, PolicyLevel level);
    public abstract virtual SecurityElement ToXml(PolicyLevel level);
}
public interface System.Security.IStackWalk {
    public abstract virtual void Assert();
    public abstract virtual void Demand();
    public abstract virtual void Deny();
    public abstract virtual void PermitOnly();
}
[ComVisibleAttribute("True")]
public class System.Security.NamedPermissionSet : PermissionSet {
    private string name;
    private string description;
    public string Description { get; public set; }
    public string Name { get; public set; }
    public NamedPermissionSet(string name, PermissionSet permSet);
    public NamedPermissionSet(string name, PermissionState state);
    public NamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet(string name);
    public string get_Description();
    public void set_Description(string value);
    public string get_Name();
    public void set_Name(string value);
    public virtual PermissionSet Copy();
    public NamedPermissionSet Copy(string name);
    public virtual void FromXml(SecurityElement et);
    public virtual SecurityElement ToXml();
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
internal static class System.Security.PermissionBuilder : object {
    private static Object[] psNone;
    private static PermissionBuilder();
    public static IPermission Create(string fullname, PermissionState state);
    public static IPermission Create(SecurityElement se);
    public static IPermission Create(string fullname, SecurityElement se);
    public static IPermission Create(Type type);
    internal static IPermission CreatePermission(string fullname, SecurityElement se);
}
internal enum System.Security.Permissions.BuiltInToken : Enum {
    public int value__;
    public static BuiltInToken Environment;
    public static BuiltInToken FileDialog;
    public static BuiltInToken FileIO;
    public static BuiltInToken IsolatedStorageFile;
    public static BuiltInToken Reflection;
    public static BuiltInToken Registry;
    public static BuiltInToken Security;
    public static BuiltInToken UI;
    public static BuiltInToken Principal;
    public static BuiltInToken HostProtection;
    public static BuiltInToken PublisherIdentity;
    public static BuiltInToken SiteIdentity;
    public static BuiltInToken StrongNameIdentity;
    public static BuiltInToken UrlIdentity;
    public static BuiltInToken ZoneIdentity;
    public static BuiltInToken GacIdentity;
    public static BuiltInToken KeyContainer;
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.EnvironmentPermission : CodeAccessPermission {
    private static int version;
    private PermissionState _state;
    private ArrayList readList;
    private ArrayList writeList;
    public EnvironmentPermission(PermissionState state);
    public EnvironmentPermission(EnvironmentPermissionAccess flag, string pathList);
    public void AddPathList(EnvironmentPermissionAccess flag, string pathList);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public string GetPathList(EnvironmentPermissionAccess flag);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Intersect(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public void SetPathList(EnvironmentPermissionAccess flag, string pathList);
    public virtual SecurityElement ToXml();
    [SecuritySafeCriticalAttribute]
public virtual IPermission Union(IPermission other);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private EnvironmentPermission Cast(IPermission target);
    internal void ThrowInvalidFlag(EnvironmentPermissionAccess flag, bool context);
    private string GetPathList(ArrayList list);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.EnvironmentPermissionAccess : Enum {
    public int value__;
    public static EnvironmentPermissionAccess NoAccess;
    public static EnvironmentPermissionAccess Read;
    public static EnvironmentPermissionAccess Write;
    public static EnvironmentPermissionAccess AllAccess;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
    private string read;
    private string write;
    public string All { get; public set; }
    public string Read { get; public set; }
    public string Write { get; public set; }
    public EnvironmentPermissionAttribute(SecurityAction action);
    public string get_All();
    public void set_All(string value);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileDialogPermission : CodeAccessPermission {
    private static int version;
    private FileDialogPermissionAccess _access;
    public FileDialogPermissionAccess Access { get; public set; }
    public FileDialogPermission(PermissionState state);
    public FileDialogPermission(FileDialogPermissionAccess access);
    public FileDialogPermissionAccess get_Access();
    public void set_Access(FileDialogPermissionAccess value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private FileDialogPermission Cast(IPermission target);
}
[FlagsAttribute]
public enum System.Security.Permissions.FileDialogPermissionAccess : Enum {
    public int value__;
    public static FileDialogPermissionAccess None;
    public static FileDialogPermissionAccess Open;
    public static FileDialogPermissionAccess OpenSave;
    public static FileDialogPermissionAccess Save;
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
    private bool canOpen;
    private bool canSave;
    public bool Open { get; public set; }
    public bool Save { get; public set; }
    public FileDialogPermissionAttribute(SecurityAction action);
    public bool get_Open();
    public void set_Open(bool value);
    public bool get_Save();
    public void set_Save(bool value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.FileIOPermission : CodeAccessPermission {
    private static int version;
    private static Char[] BadPathNameCharacters;
    private static Char[] BadFileNameCharacters;
    private bool m_Unrestricted;
    private FileIOPermissionAccess m_AllFilesAccess;
    private FileIOPermissionAccess m_AllLocalFilesAccess;
    private ArrayList readList;
    private ArrayList writeList;
    private ArrayList appendList;
    private ArrayList pathList;
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    private static FileIOPermission();
    public FileIOPermission(PermissionState state);
    public FileIOPermission(FileIOPermissionAccess access, string path);
    public FileIOPermission(FileIOPermissionAccess access, String[] pathList);
    [MonoTODOAttribute("(2.0) Access Control isn't implemented")]
public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, string path);
    [MonoTODOAttribute("(2.0) Access Control isn't implemented")]
public FileIOPermission(FileIOPermissionAccess access, AccessControlActions control, String[] pathList);
    internal FileIOPermission(FileIOPermissionAccess access, String[] pathList, bool checkForDuplicates, bool needFullPath);
    internal void CreateLists();
    public FileIOPermissionAccess get_AllFiles();
    public void set_AllFiles(FileIOPermissionAccess value);
    public FileIOPermissionAccess get_AllLocalFiles();
    public void set_AllLocalFiles(FileIOPermissionAccess value);
    public void AddPathList(FileIOPermissionAccess access, string path);
    public void AddPathList(FileIOPermissionAccess access, String[] pathList);
    internal void AddPathInternal(FileIOPermissionAccess access, string path);
    public virtual IPermission Copy();
    [SecuritySafeCriticalAttribute]
public virtual void FromXml(SecurityElement esd);
    public String[] GetPathList(FileIOPermissionAccess access);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public void SetPathList(FileIOPermissionAccess access, string path);
    public void SetPathList(FileIOPermissionAccess access, String[] pathList);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
    [MonoTODOAttribute("(2.0)")]
[ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [MonoTODOAttribute("(2.0)")]
[ComVisibleAttribute("False")]
public virtual int GetHashCode();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private static FileIOPermission Cast(IPermission target);
    internal static void ThrowInvalidFlag(FileIOPermissionAccess access, bool context);
    internal static void ThrowIfInvalidPath(string path);
    internal static void ThrowIfInvalidPath(String[] paths);
    internal void Clear(FileIOPermissionAccess access);
    internal static bool KeyIsSubsetOf(IList local, IList target);
    internal static void UnionKeys(IList list, String[] paths);
    internal static void IntersectKeys(IList local, IList target, IList result);
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.FileIOPermissionAccess : Enum {
    public int value__;
    public static FileIOPermissionAccess NoAccess;
    public static FileIOPermissionAccess Read;
    public static FileIOPermissionAccess Write;
    public static FileIOPermissionAccess Append;
    public static FileIOPermissionAccess PathDiscovery;
    public static FileIOPermissionAccess AllAccess;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.FileIOPermissionAttribute : CodeAccessSecurityAttribute {
    private string append;
    private string path;
    private string read;
    private string write;
    private FileIOPermissionAccess allFiles;
    private FileIOPermissionAccess allLocalFiles;
    private string changeAccessControl;
    private string viewAccessControl;
    [ObsoleteAttribute("use newer properties")]
public string All { get; public set; }
    public string Append { get; public set; }
    public string PathDiscovery { get; public set; }
    public string Read { get; public set; }
    public string Write { get; public set; }
    public FileIOPermissionAccess AllFiles { get; public set; }
    public FileIOPermissionAccess AllLocalFiles { get; public set; }
    public string ChangeAccessControl { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ViewAndModify { get; public set; }
    public FileIOPermissionAttribute(SecurityAction action);
    public string get_All();
    public void set_All(string value);
    public string get_Append();
    public void set_Append(string value);
    public string get_PathDiscovery();
    public void set_PathDiscovery(string value);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public FileIOPermissionAccess get_AllFiles();
    public void set_AllFiles(FileIOPermissionAccess value);
    public FileIOPermissionAccess get_AllLocalFiles();
    public void set_AllLocalFiles(FileIOPermissionAccess value);
    public string get_ChangeAccessControl();
    public void set_ChangeAccessControl(string value);
    public string get_ViewAccessControl();
    public void set_ViewAccessControl(string value);
    public string get_ViewAndModify();
    public void set_ViewAndModify(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.GacIdentityPermission : CodeAccessPermission {
    private static int version;
    public GacIdentityPermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual void FromXml(SecurityElement securityElement);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private GacIdentityPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    public GacIdentityPermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("4205")]
public class System.Security.Permissions.HostProtectionAttribute : CodeAccessSecurityAttribute {
    private HostProtectionResource _resources;
    public bool ExternalProcessMgmt { get; public set; }
    public bool ExternalThreading { get; public set; }
    public bool MayLeakOnAbort { get; public set; }
    [ComVisibleAttribute("True")]
public bool SecurityInfrastructure { get; public set; }
    public bool SelfAffectingProcessMgmt { get; public set; }
    public bool SelfAffectingThreading { get; public set; }
    public bool SharedState { get; public set; }
    public bool Synchronization { get; public set; }
    public bool UI { get; public set; }
    public HostProtectionResource Resources { get; public set; }
    public HostProtectionAttribute(SecurityAction action);
    public bool get_ExternalProcessMgmt();
    public void set_ExternalProcessMgmt(bool value);
    public bool get_ExternalThreading();
    public void set_ExternalThreading(bool value);
    public bool get_MayLeakOnAbort();
    public void set_MayLeakOnAbort(bool value);
    public bool get_SecurityInfrastructure();
    public void set_SecurityInfrastructure(bool value);
    public bool get_SelfAffectingProcessMgmt();
    public void set_SelfAffectingProcessMgmt(bool value);
    public bool get_SelfAffectingThreading();
    public void set_SelfAffectingThreading(bool value);
    public bool get_SharedState();
    public void set_SharedState(bool value);
    public bool get_Synchronization();
    public void set_Synchronization(bool value);
    public bool get_UI();
    public void set_UI(bool value);
    public HostProtectionResource get_Resources();
    public void set_Resources(HostProtectionResource value);
    public virtual IPermission CreatePermission();
}
internal class System.Security.Permissions.HostProtectionPermission : CodeAccessPermission {
    private static int version;
    private HostProtectionResource _resources;
    public HostProtectionResource Resources { get; public set; }
    public HostProtectionPermission(PermissionState state);
    public HostProtectionPermission(HostProtectionResource resources);
    public HostProtectionResource get_Resources();
    public void set_Resources(HostProtectionResource value);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement e);
    public virtual SecurityElement ToXml();
    public sealed virtual bool IsUnrestricted();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private HostProtectionPermission Cast(IPermission target);
}
[FlagsAttribute]
public enum System.Security.Permissions.HostProtectionResource : Enum {
    public int value__;
    public static HostProtectionResource All;
    public static HostProtectionResource ExternalProcessMgmt;
    public static HostProtectionResource ExternalThreading;
    public static HostProtectionResource MayLeakOnAbort;
    public static HostProtectionResource None;
    public static HostProtectionResource SecurityInfrastructure;
    public static HostProtectionResource SelfAffectingProcessMgmt;
    public static HostProtectionResource SelfAffectingThreading;
    public static HostProtectionResource SharedState;
    public static HostProtectionResource Synchronization;
    public static HostProtectionResource UI;
}
internal interface System.Security.Permissions.IBuiltInPermission {
    public abstract virtual int GetTokenIndex();
}
public enum System.Security.Permissions.IsolatedStorageContainment : Enum {
    public int value__;
    public static IsolatedStorageContainment None;
    public static IsolatedStorageContainment DomainIsolationByUser;
    public static IsolatedStorageContainment ApplicationIsolationByUser;
    public static IsolatedStorageContainment AssemblyIsolationByUser;
    public static IsolatedStorageContainment DomainIsolationByMachine;
    public static IsolatedStorageContainment AssemblyIsolationByMachine;
    public static IsolatedStorageContainment ApplicationIsolationByMachine;
    public static IsolatedStorageContainment DomainIsolationByRoamingUser;
    public static IsolatedStorageContainment AssemblyIsolationByRoamingUser;
    public static IsolatedStorageContainment ApplicationIsolationByRoamingUser;
    public static IsolatedStorageContainment AdministerIsolatedStorageByUser;
    public static IsolatedStorageContainment UnrestrictedIsolatedStorage;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.IsolatedStorageFilePermission : IsolatedStoragePermission {
    public IsolatedStorageFilePermission(PermissionState state);
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    [MonoTODOAttribute("(2.0) new override - something must have been added ???")]
[ComVisibleAttribute("False")]
public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private IsolatedStorageFilePermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
    public IsolatedStorageFilePermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Permissions.IsolatedStoragePermission : CodeAccessPermission {
    private static int version;
    internal long m_userQuota;
    internal long m_machineQuota;
    internal long m_expirationDays;
    internal bool m_permanentData;
    internal IsolatedStorageContainment m_allowed;
    public long UserQuota { get; public set; }
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    protected IsolatedStoragePermission(PermissionState state);
    public long get_UserQuota();
    public void set_UserQuota(long value);
    public IsolatedStorageContainment get_UsageAllowed();
    public void set_UsageAllowed(IsolatedStorageContainment value);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual void FromXml(SecurityElement esd);
    internal bool IsEmpty();
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public abstract class System.Security.Permissions.IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
    private IsolatedStorageContainment usage_allowed;
    private long user_quota;
    public IsolatedStorageContainment UsageAllowed { get; public set; }
    public long UserQuota { get; public set; }
    protected IsolatedStoragePermissionAttribute(SecurityAction action);
    public IsolatedStorageContainment get_UsageAllowed();
    public void set_UsageAllowed(IsolatedStorageContainment value);
    public long get_UserQuota();
    public void set_UserQuota(long value);
}
public interface System.Security.Permissions.IUnrestrictedPermission {
    public abstract virtual bool IsUnrestricted();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermission : CodeAccessPermission {
    private KeyContainerPermissionAccessEntryCollection _accessEntries;
    private KeyContainerPermissionFlags _flags;
    private static int version;
    public KeyContainerPermissionAccessEntryCollection AccessEntries { get; }
    public KeyContainerPermissionFlags Flags { get; }
    public KeyContainerPermission(PermissionState state);
    public KeyContainerPermission(KeyContainerPermissionFlags flags);
    public KeyContainerPermission(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList);
    public KeyContainerPermissionAccessEntryCollection get_AccessEntries();
    public KeyContainerPermissionFlags get_Flags();
    public virtual IPermission Copy();
    [MonoTODOAttribute("(2.0) missing support for AccessEntries")]
public virtual void FromXml(SecurityElement securityElement);
    [MonoTODOAttribute("(2.0)")]
public virtual IPermission Intersect(IPermission target);
    [MonoTODOAttribute("(2.0)")]
public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    [MonoTODOAttribute("(2.0) missing support for AccessEntries")]
public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private void SetFlags(KeyContainerPermissionFlags flags);
    private KeyContainerPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntry : object {
    private KeyContainerPermissionFlags _flags;
    private string _containerName;
    private int _spec;
    private string _store;
    private string _providerName;
    private int _type;
    public KeyContainerPermissionFlags Flags { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public KeyContainerPermissionAccessEntry(CspParameters parameters, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(string keyContainerName, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags);
    public KeyContainerPermissionFlags get_Flags();
    public void set_Flags(KeyContainerPermissionFlags value);
    public string get_KeyContainerName();
    public void set_KeyContainerName(string value);
    public int get_KeySpec();
    public void set_KeySpec(int value);
    public string get_KeyStore();
    public void set_KeyStore(string value);
    public string get_ProviderName();
    public void set_ProviderName(string value);
    public int get_ProviderType();
    public void set_ProviderType(int value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntryCollection : object {
    private ArrayList _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public KeyContainerPermissionAccessEntry Item { get; }
    public object SyncRoot { get; }
    internal KeyContainerPermissionAccessEntryCollection(KeyContainerPermissionAccessEntry[] entries);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public KeyContainerPermissionAccessEntry get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public int Add(KeyContainerPermissionAccessEntry accessEntry);
    public void Clear();
    public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int IndexOf(KeyContainerPermissionAccessEntry accessEntry);
    public void Remove(KeyContainerPermissionAccessEntry accessEntry);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator : object {
    private IEnumerator e;
    public KeyContainerPermissionAccessEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal KeyContainerPermissionAccessEntryEnumerator(ArrayList list);
    public KeyContainerPermissionAccessEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
    private KeyContainerPermissionFlags _flags;
    private string _containerName;
    private int _spec;
    private string _store;
    private string _providerName;
    private int _type;
    public KeyContainerPermissionFlags Flags { get; public set; }
    public string KeyContainerName { get; public set; }
    public int KeySpec { get; public set; }
    public string KeyStore { get; public set; }
    public string ProviderName { get; public set; }
    public int ProviderType { get; public set; }
    public KeyContainerPermissionAttribute(SecurityAction action);
    public KeyContainerPermissionFlags get_Flags();
    public void set_Flags(KeyContainerPermissionFlags value);
    public string get_KeyContainerName();
    public void set_KeyContainerName(string value);
    public int get_KeySpec();
    public void set_KeySpec(int value);
    public string get_KeyStore();
    public void set_KeyStore(string value);
    public string get_ProviderName();
    public void set_ProviderName(string value);
    public int get_ProviderType();
    public void set_ProviderType(int value);
    public virtual IPermission CreatePermission();
    private bool EmptyEntry();
}
[ComVisibleAttribute("True")]
[FlagsAttribute]
public enum System.Security.Permissions.KeyContainerPermissionFlags : Enum {
    public int value__;
    public static KeyContainerPermissionFlags NoFlags;
    public static KeyContainerPermissionFlags Create;
    public static KeyContainerPermissionFlags Open;
    public static KeyContainerPermissionFlags Delete;
    public static KeyContainerPermissionFlags Import;
    public static KeyContainerPermissionFlags Export;
    public static KeyContainerPermissionFlags Sign;
    public static KeyContainerPermissionFlags Decrypt;
    public static KeyContainerPermissionFlags ViewAcl;
    public static KeyContainerPermissionFlags ChangeAcl;
    public static KeyContainerPermissionFlags AllFlags;
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PermissionSetAttribute : CodeAccessSecurityAttribute {
    private string file;
    private string name;
    private bool isUnicodeEncoded;
    private string xml;
    private string hex;
    public string File { get; public set; }
    public string Hex { get; public set; }
    public string Name { get; public set; }
    public bool UnicodeEncoded { get; public set; }
    public string XML { get; public set; }
    public PermissionSetAttribute(SecurityAction action);
    public string get_File();
    public void set_File(string value);
    public string get_Hex();
    public void set_Hex(string value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_UnicodeEncoded();
    public void set_UnicodeEncoded(bool value);
    public string get_XML();
    public void set_XML(string value);
    public virtual IPermission CreatePermission();
    private PermissionSet CreateFromXml(string xml);
    public PermissionSet CreatePermissionSet();
}
public enum System.Security.Permissions.PermissionState : Enum {
    public int value__;
    public static PermissionState None;
    public static PermissionState Unrestricted;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PrincipalPermission : object {
    private static int version;
    private ArrayList principals;
    public PrincipalPermission(PermissionState state);
    public PrincipalPermission(string name, string role);
    public PrincipalPermission(string name, string role, bool isAuthenticated);
    internal PrincipalPermission(ArrayList principals);
    public sealed virtual IPermission Copy();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    public sealed virtual void FromXml(SecurityElement elem);
    public sealed virtual IPermission Intersect(IPermission target);
    public sealed virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual IPermission Union(IPermission other);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private PrincipalPermission Cast(IPermission target);
    private bool IsEmpty();
    internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
}
[AttributeUsageAttribute("68")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
    private bool authenticated;
    private string name;
    private string role;
    public bool Authenticated { get; public set; }
    public string Name { get; public set; }
    public string Role { get; public set; }
    public PrincipalPermissionAttribute(SecurityAction action);
    public bool get_Authenticated();
    public void set_Authenticated(bool value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Role();
    public void set_Role(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.PublisherIdentityPermission : CodeAccessPermission {
    private static int version;
    private X509Certificate x509;
    public X509Certificate Certificate { get; public set; }
    public PublisherIdentityPermission(PermissionState state);
    public PublisherIdentityPermission(X509Certificate certificate);
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private PublisherIdentityPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    private string certFile;
    private string signedFile;
    private string x509data;
    public string CertFile { get; public set; }
    public string SignedFile { get; public set; }
    public string X509Certificate { get; public set; }
    public PublisherIdentityPermissionAttribute(SecurityAction action);
    public string get_CertFile();
    public void set_CertFile(string value);
    public string get_SignedFile();
    public void set_SignedFile(string value);
    public string get_X509Certificate();
    public void set_X509Certificate(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ReflectionPermission : CodeAccessPermission {
    private static int version;
    private ReflectionPermissionFlag flags;
    public ReflectionPermissionFlag Flags { get; public set; }
    public ReflectionPermission(PermissionState state);
    public ReflectionPermission(ReflectionPermissionFlag flag);
    public ReflectionPermissionFlag get_Flags();
    public void set_Flags(ReflectionPermissionFlag value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission other);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private ReflectionPermission Cast(IPermission target);
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
    private ReflectionPermissionFlag flags;
    private bool memberAccess;
    private bool reflectionEmit;
    private bool typeInfo;
    public ReflectionPermissionFlag Flags { get; public set; }
    public bool MemberAccess { get; public set; }
    [ObsoleteAttribute]
public bool ReflectionEmit { get; public set; }
    public bool RestrictedMemberAccess { get; public set; }
    [ObsoleteAttribute("not enforced in 2.0+")]
public bool TypeInformation { get; public set; }
    public ReflectionPermissionAttribute(SecurityAction action);
    public ReflectionPermissionFlag get_Flags();
    public void set_Flags(ReflectionPermissionFlag value);
    public bool get_MemberAccess();
    public void set_MemberAccess(bool value);
    public bool get_ReflectionEmit();
    public void set_ReflectionEmit(bool value);
    public bool get_RestrictedMemberAccess();
    public void set_RestrictedMemberAccess(bool value);
    public bool get_TypeInformation();
    public void set_TypeInformation(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.ReflectionPermissionFlag : Enum {
    public int value__;
    [ObsoleteAttribute("This permission has been deprecated. Use PermissionState.Unrestricted to get full access.")]
public static ReflectionPermissionFlag AllFlags;
    public static ReflectionPermissionFlag MemberAccess;
    public static ReflectionPermissionFlag NoFlags;
    [ObsoleteAttribute("This permission is no longer used by the CLR.")]
public static ReflectionPermissionFlag ReflectionEmit;
    public static ReflectionPermissionFlag RestrictedMemberAccess;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static ReflectionPermissionFlag TypeInformation;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.RegistryPermission : CodeAccessPermission {
    private static int version;
    private PermissionState _state;
    private ArrayList createList;
    private ArrayList readList;
    private ArrayList writeList;
    public RegistryPermission(PermissionState state);
    public RegistryPermission(RegistryPermissionAccess access, string pathList);
    public RegistryPermission(RegistryPermissionAccess access, AccessControlActions control, string pathList);
    public void AddPathList(RegistryPermissionAccess access, string pathList);
    [MonoTODOAttribute("(2.0) Access Control isn't implemented")]
public void AddPathList(RegistryPermissionAccess access, AccessControlActions control, string pathList);
    public string GetPathList(RegistryPermissionAccess access);
    public void SetPathList(RegistryPermissionAccess access, string pathList);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    [SecuritySafeCriticalAttribute]
public virtual IPermission Intersect(IPermission target);
    [SecuritySafeCriticalAttribute]
public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    [SecuritySafeCriticalAttribute]
public virtual SecurityElement ToXml();
    [SecuritySafeCriticalAttribute]
public virtual IPermission Union(IPermission other);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private RegistryPermission Cast(IPermission target);
    internal void ThrowInvalidFlag(RegistryPermissionAccess flag, bool context);
    private string GetPathList(ArrayList list);
    internal bool KeyIsSubsetOf(IList local, IList target);
    internal void AddWithUnionKey(IList list, string pathList);
    internal void IntersectKeys(IList local, IList target, IList result);
}
[FlagsAttribute]
public enum System.Security.Permissions.RegistryPermissionAccess : Enum {
    public int value__;
    public static RegistryPermissionAccess AllAccess;
    public static RegistryPermissionAccess Create;
    public static RegistryPermissionAccess NoAccess;
    public static RegistryPermissionAccess Read;
    public static RegistryPermissionAccess Write;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.RegistryPermissionAttribute : CodeAccessSecurityAttribute {
    private string create;
    private string read;
    private string write;
    private string changeAccessControl;
    private string viewAccessControl;
    [ObsoleteAttribute("use newer properties")]
public string All { get; public set; }
    public string Create { get; public set; }
    public string Read { get; public set; }
    public string Write { get; public set; }
    public string ChangeAccessControl { get; public set; }
    public string ViewAccessControl { get; public set; }
    public string ViewAndModify { get; public set; }
    public RegistryPermissionAttribute(SecurityAction action);
    public string get_All();
    public void set_All(string value);
    public string get_Create();
    public void set_Create(string value);
    public string get_Read();
    public void set_Read(string value);
    public string get_Write();
    public void set_Write(string value);
    public string get_ChangeAccessControl();
    public void set_ChangeAccessControl(string value);
    public string get_ViewAccessControl();
    public void set_ViewAccessControl(string value);
    public string get_ViewAndModify();
    public void set_ViewAndModify(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    [ObsoleteAttribute("This requests should not be used")]
public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    [ObsoleteAttribute("This requests should not be used")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("This requests should not be used")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("This requests should not be used")]
public static SecurityAction RequestRefuse;
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    private SecurityAction m_Action;
    private bool m_Unrestricted;
    public bool Unrestricted { get; public set; }
    public SecurityAction Action { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    public abstract virtual IPermission CreatePermission();
    public bool get_Unrestricted();
    public void set_Unrestricted(bool value);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SecurityPermission : CodeAccessPermission {
    private static int version;
    private SecurityPermissionFlag flags;
    public SecurityPermissionFlag Flags { get; public set; }
    public SecurityPermission(PermissionState state);
    public SecurityPermission(SecurityPermissionFlag flag);
    public SecurityPermissionFlag get_Flags();
    public void set_Flags(SecurityPermissionFlag value);
    public sealed virtual bool IsUnrestricted();
    public virtual IPermission Copy();
    public virtual IPermission Intersect(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual void FromXml(SecurityElement esd);
    public virtual SecurityElement ToXml();
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private SecurityPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    private SecurityPermissionFlag m_Flags;
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    [ComVisibleAttribute("True")]
public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    public bool get_Assertion();
    public void set_Assertion(bool value);
    public bool get_BindingRedirects();
    public void set_BindingRedirects(bool value);
    public bool get_ControlAppDomain();
    public void set_ControlAppDomain(bool value);
    public bool get_ControlDomainPolicy();
    public void set_ControlDomainPolicy(bool value);
    public bool get_ControlEvidence();
    public void set_ControlEvidence(bool value);
    public bool get_ControlPolicy();
    public void set_ControlPolicy(bool value);
    public bool get_ControlPrincipal();
    public void set_ControlPrincipal(bool value);
    public bool get_ControlThread();
    public void set_ControlThread(bool value);
    public bool get_Execution();
    public void set_Execution(bool value);
    public bool get_Infrastructure();
    public void set_Infrastructure(bool value);
    public bool get_RemotingConfiguration();
    public void set_RemotingConfiguration(bool value);
    public bool get_SerializationFormatter();
    public void set_SerializationFormatter(bool value);
    public bool get_SkipVerification();
    public void set_SkipVerification(bool value);
    public bool get_UnmanagedCode();
    public void set_UnmanagedCode(bool value);
    public virtual IPermission CreatePermission();
    public SecurityPermissionFlag get_Flags();
    public void set_Flags(SecurityPermissionFlag value);
}
[FlagsAttribute]
[ComVisibleAttribute("True")]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag UnmanagedCode;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag AllFlags;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SiteIdentityPermission : CodeAccessPermission {
    private static int version;
    private string _site;
    private static Boolean[] valid;
    public string Site { get; public set; }
    public SiteIdentityPermission(PermissionState state);
    public SiteIdentityPermission(string site);
    private static SiteIdentityPermission();
    public string get_Site();
    public void set_Site(string value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private SiteIdentityPermission Cast(IPermission target);
    private bool IsValid(string s);
    private bool Match(string target);
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    private string site;
    public string Site { get; public set; }
    public SiteIdentityPermissionAttribute(SecurityAction action);
    public string get_Site();
    public void set_Site(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.StrongNameIdentityPermission : CodeAccessPermission {
    private static int version;
    private static Version defaultVersion;
    private PermissionState _state;
    private ArrayList _list;
    public string Name { get; public set; }
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public Version Version { get; public set; }
    public StrongNameIdentityPermission(PermissionState state);
    public StrongNameIdentityPermission(StrongNamePublicKeyBlob blob, string name, Version version);
    internal StrongNameIdentityPermission(StrongNameIdentityPermission snip);
    private static StrongNameIdentityPermission();
    public string get_Name();
    public void set_Name(string value);
    public StrongNamePublicKeyBlob get_PublicKey();
    public void set_PublicKey(StrongNamePublicKeyBlob value);
    public Version get_Version();
    public void set_Version(Version value);
    internal void ResetToDefault();
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement e);
    private SNIP FromSecurityElement(SecurityElement se);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    private void ToSecurityElement(SecurityElement se, SNIP snip);
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsUnrestricted();
    private bool Contains(SNIP snip);
    private bool IsEmpty(SNIP snip);
    private bool IsEmpty();
    private StrongNameIdentityPermission Cast(IPermission target);
    private bool Match(string target);
}
[AttributeUsageAttribute("109")]
[ComVisibleAttribute("True")]
public class System.Security.Permissions.StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    private string name;
    private string key;
    private string version;
    public string Name { get; public set; }
    public string PublicKey { get; public set; }
    public string Version { get; public set; }
    public StrongNameIdentityPermissionAttribute(SecurityAction action);
    public string get_Name();
    public void set_Name(string value);
    public string get_PublicKey();
    public void set_PublicKey(string value);
    public string get_Version();
    public void set_Version(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.StrongNamePublicKeyBlob : object {
    internal Byte[] pubkey;
    public StrongNamePublicKeyBlob(Byte[] publicKey);
    internal static StrongNamePublicKeyBlob FromString(string s);
    private static byte CharToByte(char c);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UIPermission : CodeAccessPermission {
    private UIPermissionWindow _window;
    private UIPermissionClipboard _clipboard;
    private static int version;
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermissionWindow Window { get; public set; }
    public UIPermission(PermissionState state);
    public UIPermission(UIPermissionClipboard clipboardFlag);
    public UIPermission(UIPermissionWindow windowFlag);
    public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag);
    public UIPermissionClipboard get_Clipboard();
    public void set_Clipboard(UIPermissionClipboard value);
    public UIPermissionWindow get_Window();
    public void set_Window(UIPermissionWindow value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public sealed virtual bool IsUnrestricted();
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty(UIPermissionWindow w, UIPermissionClipboard c);
    private UIPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.UIPermissionAttribute : CodeAccessSecurityAttribute {
    private UIPermissionClipboard clipboard;
    private UIPermissionWindow window;
    public UIPermissionClipboard Clipboard { get; public set; }
    public UIPermissionWindow Window { get; public set; }
    public UIPermissionAttribute(SecurityAction action);
    public UIPermissionClipboard get_Clipboard();
    public void set_Clipboard(UIPermissionClipboard value);
    public UIPermissionWindow get_Window();
    public void set_Window(UIPermissionWindow value);
    public virtual IPermission CreatePermission();
}
public enum System.Security.Permissions.UIPermissionClipboard : Enum {
    public int value__;
    public static UIPermissionClipboard AllClipboard;
    public static UIPermissionClipboard NoClipboard;
    public static UIPermissionClipboard OwnClipboard;
}
public enum System.Security.Permissions.UIPermissionWindow : Enum {
    public int value__;
    public static UIPermissionWindow AllWindows;
    public static UIPermissionWindow NoWindows;
    public static UIPermissionWindow SafeSubWindows;
    public static UIPermissionWindow SafeTopLevelWindows;
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.UrlIdentityPermission : CodeAccessPermission {
    private static int version;
    private string url;
    public string Url { get; public set; }
    public UrlIdentityPermission(PermissionState state);
    public UrlIdentityPermission(string site);
    public string get_Url();
    public void set_Url(string value);
    public virtual IPermission Copy();
    public virtual void FromXml(SecurityElement esd);
    public virtual IPermission Intersect(IPermission target);
    public virtual bool IsSubsetOf(IPermission target);
    public virtual SecurityElement ToXml();
    public virtual IPermission Union(IPermission target);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private bool IsEmpty();
    private UrlIdentityPermission Cast(IPermission target);
    private bool Match(string target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    private string url;
    public string Url { get; public set; }
    public UrlIdentityPermissionAttribute(SecurityAction action);
    public string get_Url();
    public void set_Url(string value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
public class System.Security.Permissions.ZoneIdentityPermission : CodeAccessPermission {
    private static int version;
    private SecurityZone zone;
    public SecurityZone SecurityZone { get; public set; }
    public ZoneIdentityPermission(PermissionState state);
    public ZoneIdentityPermission(SecurityZone zone);
    public virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    public virtual IPermission Union(IPermission target);
    public virtual IPermission Intersect(IPermission target);
    public virtual void FromXml(SecurityElement esd);
    public virtual SecurityElement ToXml();
    public SecurityZone get_SecurityZone();
    public void set_SecurityZone(SecurityZone value);
    private sealed virtual override int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
    private ZoneIdentityPermission Cast(IPermission target);
}
[ComVisibleAttribute("True")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
    private SecurityZone zone;
    public SecurityZone Zone { get; public set; }
    public ZoneIdentityPermissionAttribute(SecurityAction action);
    public SecurityZone get_Zone();
    public void set_Zone(SecurityZone value);
    public virtual IPermission CreatePermission();
}
[ComVisibleAttribute("True")]
[MonoTODOAttribute("CAS support is experimental (and unsupported).")]
public class System.Security.PermissionSet : object {
    private static string tagName;
    private static int version;
    private static Object[] psUnrestricted;
    private PermissionState state;
    private ArrayList list;
    private PolicyLevel _policyLevel;
    private bool _declsec;
    private bool _readOnly;
    private Boolean[] _ignored;
    private static Object[] action;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    public object SyncRoot { get; }
    internal bool DeclarativeSecurity { get; internal set; }
    internal PolicyLevel Resolver { get; internal set; }
    public PermissionSet(PermissionState state);
    public PermissionSet(PermissionSet permSet);
    internal PermissionSet(string xml);
    internal PermissionSet(IPermission perm);
    private static PermissionSet();
    public IPermission AddPermission(IPermission perm);
    [SecuritySafeCriticalAttribute]
[MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public sealed virtual void Assert();
    internal void Clear();
    public virtual PermissionSet Copy();
    public virtual void CopyTo(Array array, int index);
    [SecuritySafeCriticalAttribute]
public sealed virtual void Demand();
    internal void CasOnlyDemand(int skip);
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
[MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
public sealed virtual void Deny();
    public virtual void FromXml(SecurityElement et);
    public sealed virtual IEnumerator GetEnumerator();
    public bool IsSubsetOf(PermissionSet target);
    [MonoTODOAttribute("CAS support is experimental (and unsupported). Imperative mode is not implemented.")]
[SecuritySafeCriticalAttribute]
public sealed virtual void PermitOnly();
    public bool ContainsNonCodeAccessPermissions();
    public static Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat);
    public IPermission GetPermission(Type permClass);
    public PermissionSet Intersect(PermissionSet other);
    internal void InternalIntersect(PermissionSet intersect, PermissionSet a, PermissionSet b, bool unrestricted);
    public bool IsEmpty();
    public bool IsUnrestricted();
    public IPermission RemovePermission(Type permClass);
    public IPermission SetPermission(IPermission perm);
    public virtual string ToString();
    public virtual SecurityElement ToXml();
    public PermissionSet Union(PermissionSet other);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsReadOnly();
    public virtual object get_SyncRoot();
    internal bool get_DeclarativeSecurity();
    internal void set_DeclarativeSecurity(bool value);
    [MonoTODOAttribute("may not be required")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    public static void RevertAssert();
    internal PolicyLevel get_Resolver();
    internal void set_Resolver(PolicyLevel value);
    internal void SetReadOnly(bool value);
    private bool AllIgnored();
    internal static PermissionSet CreateFromBinaryFormat(Byte[] data);
    internal static int ReadEncodedInt(Byte[] data, Int32& position);
    internal static IPermission ProcessAttribute(Byte[] data, Int32& position);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    protected virtual IEnumerator GetEnumeratorImpl();
    protected virtual IPermission GetPermissionImpl(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.AllMembershipCondition : object {
    private int version;
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationDirectory : EvidenceBase {
    private string directory;
    public string Directory { get; }
    public ApplicationDirectory(string name);
    public string get_Directory();
    public object Copy();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
    private void ThrowOnInvalid(string appdir);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationDirectoryMembershipCondition : object {
    private int version;
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationSecurityInfo : object {
    private Evidence _evidence;
    private ApplicationId _appid;
    private PermissionSet _defaultSet;
    private ApplicationId _deployid;
    public Evidence ApplicationEvidence { get; public set; }
    public ApplicationId ApplicationId { get; public set; }
    public PermissionSet DefaultRequestSet { get; public set; }
    public ApplicationId DeploymentId { get; public set; }
    public ApplicationSecurityInfo(ActivationContext activationContext);
    public Evidence get_ApplicationEvidence();
    public void set_ApplicationEvidence(Evidence value);
    public ApplicationId get_ApplicationId();
    public void set_ApplicationId(ApplicationId value);
    public PermissionSet get_DefaultRequestSet();
    public void set_DefaultRequestSet(PermissionSet value);
    public ApplicationId get_DeploymentId();
    public void set_DeploymentId(ApplicationId value);
}
[ComVisibleAttribute("True")]
public static class System.Security.Policy.ApplicationSecurityManager : object {
    private static IApplicationTrustManager _appTrustManager;
    private static ApplicationTrustCollection _userAppTrusts;
    public static IApplicationTrustManager ApplicationTrustManager { get; }
    public static ApplicationTrustCollection UserApplicationTrusts { get; }
    public static IApplicationTrustManager get_ApplicationTrustManager();
    public static ApplicationTrustCollection get_UserApplicationTrusts();
    [MonoTODOAttribute("Missing application manifest support")]
public static bool DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationTrust : EvidenceBase {
    private ApplicationIdentity _appid;
    private PolicyStatement _defaultPolicy;
    private object _xtranfo;
    private bool _trustrun;
    private bool _persist;
    private IList`1<StrongName> fullTrustAssemblies;
    public ApplicationIdentity ApplicationIdentity { get; public set; }
    public PolicyStatement DefaultGrantSet { get; public set; }
    public object ExtraInfo { get; public set; }
    public bool IsApplicationTrustedToRun { get; public set; }
    public bool Persist { get; public set; }
    public IList`1<StrongName> FullTrustAssemblies { get; }
    public ApplicationTrust(ApplicationIdentity applicationIdentity);
    public ApplicationTrust(PermissionSet defaultGrantSet, IEnumerable`1<StrongName> fullTrustAssemblies);
    public ApplicationIdentity get_ApplicationIdentity();
    public void set_ApplicationIdentity(ApplicationIdentity value);
    public PolicyStatement get_DefaultGrantSet();
    public void set_DefaultGrantSet(PolicyStatement value);
    public object get_ExtraInfo();
    public void set_ExtraInfo(object value);
    public bool get_IsApplicationTrustedToRun();
    public void set_IsApplicationTrustedToRun(bool value);
    public bool get_Persist();
    public void set_Persist(bool value);
    public sealed virtual void FromXml(SecurityElement element);
    public sealed virtual SecurityElement ToXml();
    public IList`1<StrongName> get_FullTrustAssemblies();
    private PolicyStatement GetDefaultGrantSet();
}
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
public class System.Security.Policy.ApplicationTrustCollection : object {
    private ArrayList _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ApplicationTrust Item { get; }
    public ApplicationTrust Item { get; }
    [SecuritySafeCriticalAttribute]
public sealed virtual int get_Count();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool get_IsSynchronized();
    [SecuritySafeCriticalAttribute]
public sealed virtual object get_SyncRoot();
    public ApplicationTrust get_Item(int index);
    public ApplicationTrust get_Item(string appFullName);
    public int Add(ApplicationTrust trust);
    public void AddRange(ApplicationTrust[] trusts);
    public void AddRange(ApplicationTrustCollection trusts);
    public void Clear();
    public void CopyTo(ApplicationTrust[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    public ApplicationTrustEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Remove(ApplicationTrust trust);
    public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
    public void RemoveRange(ApplicationTrust[] trusts);
    public void RemoveRange(ApplicationTrustCollection trusts);
    internal void RemoveAllInstances(ApplicationTrust trust);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ApplicationTrustEnumerator : object {
    private ApplicationTrustCollection trusts;
    private int current;
    public ApplicationTrust Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ApplicationTrustEnumerator(ApplicationTrustCollection atc);
    public ApplicationTrust get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    [SecuritySafeCriticalAttribute]
public sealed virtual bool MoveNext();
}
public enum System.Security.Policy.ApplicationVersionMatch : Enum {
    public int value__;
    public static ApplicationVersionMatch MatchAllVersions;
    public static ApplicationVersionMatch MatchExactVersion;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.CodeConnectAccess : object {
    public static string AnyScheme;
    public static int DefaultPort;
    public static int OriginPort;
    public static string OriginScheme;
    private string _scheme;
    private int _port;
    public int Port { get; }
    public string Scheme { get; }
    [MonoTODOAttribute("(2.0) validations incomplete")]
public CodeConnectAccess(string allowScheme, int allowPort);
    private static CodeConnectAccess();
    public int get_Port();
    public string get_Scheme();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static CodeConnectAccess CreateAnySchemeAccess(int allowPort);
    public static CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
}
[ComVisibleAttribute("True")]
public abstract class System.Security.Policy.CodeGroup : object {
    private PolicyStatement m_policy;
    private IMembershipCondition m_membershipCondition;
    private string m_description;
    private string m_name;
    private ArrayList m_children;
    public string MergeLogic { get; }
    public PolicyStatement PolicyStatement { get; public set; }
    public string Description { get; public set; }
    public IMembershipCondition MembershipCondition { get; public set; }
    public string Name { get; public set; }
    public IList Children { get; public set; }
    public string AttributeString { get; }
    public string PermissionSetName { get; }
    protected CodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    internal CodeGroup(SecurityElement e, PolicyLevel level);
    public abstract virtual CodeGroup Copy();
    public abstract virtual string get_MergeLogic();
    public abstract virtual PolicyStatement Resolve(Evidence evidence);
    public abstract virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public PolicyStatement get_PolicyStatement();
    public void set_PolicyStatement(PolicyStatement value);
    public string get_Description();
    public void set_Description(string value);
    public IMembershipCondition get_MembershipCondition();
    public void set_MembershipCondition(IMembershipCondition value);
    public string get_Name();
    public void set_Name(string value);
    public IList get_Children();
    public void set_Children(IList value);
    public virtual string get_AttributeString();
    public virtual string get_PermissionSetName();
    public void AddChild(CodeGroup group);
    public virtual bool Equals(object o);
    public bool Equals(CodeGroup cg, bool compareChildren);
    public void RemoveChild(CodeGroup group);
    public virtual int GetHashCode();
    public void FromXml(SecurityElement e);
    public void FromXml(SecurityElement e, PolicyLevel level);
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    public SecurityElement ToXml();
    public SecurityElement ToXml(PolicyLevel level);
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    internal static CodeGroup CreateFromXml(SecurityElement se, PolicyLevel level);
}
internal static class System.Security.Policy.DefaultPolicies : object {
    private static string DnsPermissionClass;
    private static string EventLogPermissionClass;
    private static string PrintingPermissionClass;
    private static string SocketPermissionClass;
    private static string WebPermissionClass;
    private static string PerformanceCounterPermissionClass;
    private static string DirectoryServicesPermissionClass;
    private static string MessageQueuePermissionClass;
    private static string ServiceControllerPermissionClass;
    private static string OleDbPermissionClass;
    private static string SqlClientPermissionClass;
    private static Version _fxVersion;
    private static Byte[] _ecmaKey;
    private static StrongNamePublicKeyBlob _ecma;
    private static Byte[] _msFinalKey;
    private static StrongNamePublicKeyBlob _msFinal;
    private static NamedPermissionSet _fullTrust;
    private static NamedPermissionSet _localIntranet;
    private static NamedPermissionSet _internet;
    private static NamedPermissionSet _skipVerification;
    private static NamedPermissionSet _execution;
    private static NamedPermissionSet _nothing;
    private static NamedPermissionSet _everything;
    public static PermissionSet FullTrust { get; }
    public static PermissionSet LocalIntranet { get; }
    public static PermissionSet Internet { get; }
    public static PermissionSet SkipVerification { get; }
    public static PermissionSet Execution { get; }
    public static PermissionSet Nothing { get; }
    public static PermissionSet Everything { get; }
    private static DefaultPolicies();
    public static PermissionSet GetSpecialPermissionSet(string name);
    public static PermissionSet get_FullTrust();
    public static PermissionSet get_LocalIntranet();
    public static PermissionSet get_Internet();
    public static PermissionSet get_SkipVerification();
    public static PermissionSet get_Execution();
    public static PermissionSet get_Nothing();
    public static PermissionSet get_Everything();
    public static StrongNameMembershipCondition FullTrustMembership(string name, Key key);
    private static NamedPermissionSet BuildFullTrust();
    private static NamedPermissionSet BuildLocalIntranet();
    private static NamedPermissionSet BuildInternet();
    private static NamedPermissionSet BuildSkipVerification();
    private static NamedPermissionSet BuildExecution();
    private static NamedPermissionSet BuildNothing();
    private static NamedPermissionSet BuildEverything();
    private static SecurityElement PrintingPermission(string level);
}
[MonoTODOAttribute("Serialization format not compatible with .NET")]
[ComVisibleAttribute("True")]
public class System.Security.Policy.Evidence : object {
    private bool _locked;
    private ArrayList hostEvidenceList;
    private ArrayList assemblyEvidenceList;
    [ObsoleteAttribute]
public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public bool Locked { get; public set; }
    public object SyncRoot { get; }
    internal ArrayList HostEvidenceList { get; }
    internal ArrayList AssemblyEvidenceList { get; }
    public Evidence(Evidence evidence);
    public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
    [ObsoleteAttribute]
public Evidence(Object[] hostEvidence, Object[] assemblyEvidence);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public bool get_Locked();
    public void set_Locked(bool value);
    public sealed virtual object get_SyncRoot();
    internal ArrayList get_HostEvidenceList();
    internal ArrayList get_AssemblyEvidenceList();
    [ObsoleteAttribute]
public void AddAssembly(object id);
    [ObsoleteAttribute]
public void AddHost(object id);
    [ComVisibleAttribute("False")]
public void Clear();
    [ComVisibleAttribute("False")]
public Evidence Clone();
    [ObsoleteAttribute]
public sealed virtual void CopyTo(Array array, int index);
    [ObsoleteAttribute]
public sealed virtual IEnumerator GetEnumerator();
    public IEnumerator GetAssemblyEnumerator();
    public IEnumerator GetHostEnumerator();
    public void Merge(Evidence evidence);
    [ComVisibleAttribute("False")]
public void RemoveType(Type t);
    private static bool IsAuthenticodePresent(Assembly a);
    internal static Evidence GetDefaultHostEvidence(Assembly a);
    [ComVisibleAttribute("False")]
public void AddAssemblyEvidence(T evidence);
    [ComVisibleAttribute("False")]
public void AddHostEvidence(T evidence);
    [ComVisibleAttribute("False")]
public T GetAssemblyEvidence();
    [ComVisibleAttribute("False")]
public T GetHostEvidence();
}
public abstract class System.Security.Policy.EvidenceBase : object {
    public virtual EvidenceBase Clone();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.FileCodeGroup : CodeGroup {
    private FileIOPermissionAccess m_access;
    public string MergeLogic { get; }
    public string AttributeString { get; }
    public string PermissionSetName { get; }
    public FileCodeGroup(IMembershipCondition membershipCondition, FileIOPermissionAccess access);
    internal FileCodeGroup(SecurityElement e, PolicyLevel level);
    public virtual CodeGroup Copy();
    public virtual string get_MergeLogic();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public virtual string get_AttributeString();
    public virtual string get_PermissionSetName();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
    protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.FirstMatchCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public FirstMatchCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    internal FirstMatchCodeGroup(SecurityElement e, PolicyLevel level);
    public virtual string get_MergeLogic();
    public virtual CodeGroup Copy();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    private FirstMatchCodeGroup CopyNoChildren();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.GacInstalled : EvidenceBase {
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.GacMembershipCondition : object {
    private int version;
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Hash : EvidenceBase {
    private Assembly assembly;
    private Byte[] data;
    internal Byte[] _md5;
    internal Byte[] _sha1;
    public Byte[] MD5 { get; }
    public Byte[] SHA1 { get; }
    public Byte[] SHA256 { get; }
    public Hash(Assembly assembly);
    internal Hash(SerializationInfo info, StreamingContext context);
    public Byte[] get_MD5();
    public Byte[] get_SHA1();
    public Byte[] GenerateHash(HashAlgorithm hashAlg);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    private Byte[] GetData();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
    public static Hash CreateMD5(Byte[] md5);
    public static Hash CreateSHA1(Byte[] sha1);
    public Byte[] get_SHA256();
    public static Hash CreateSHA256(Byte[] sha256);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.HashMembershipCondition : object {
    private int version;
    private HashAlgorithm hash_algorithm;
    private Byte[] hash_value;
    public HashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] HashValue { get; public set; }
    public HashMembershipCondition(HashAlgorithm hashAlg, Byte[] value);
    public HashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithm value);
    public Byte[] get_HashValue();
    public void set_HashValue(Byte[] value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    private bool Compare(Byte[] expected, Byte[] actual);
    [MonoTODOAttribute("fx 2.0")]
private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [MonoTODOAttribute("fx 2.0")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("True")]
public interface System.Security.Policy.IApplicationTrustManager {
    public abstract virtual ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
}
internal interface System.Security.Policy.IBuiltInEvidence {
    public abstract virtual int GetRequiredSize(bool verbose);
    public abstract virtual int InitFromBuffer(Char[] buffer, int position);
    public abstract virtual int OutputToBuffer(Char[] buffer, int position, bool verbose);
}
internal interface System.Security.Policy.IConstantMembershipCondition {
}
public interface System.Security.Policy.IIdentityPermissionFactory {
    public abstract virtual IPermission CreateIdentityPermission(Evidence evidence);
}
public interface System.Security.Policy.IMembershipCondition {
    public abstract virtual bool Check(Evidence evidence);
    public abstract virtual IMembershipCondition Copy();
    public abstract virtual bool Equals(object obj);
    public abstract virtual string ToString();
}
internal class System.Security.Policy.MembershipConditionHelper : object {
    private static string XmlTag;
    private static MembershipConditionHelper();
    internal static int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
    internal static SecurityElement Element(Type type, int version);
}
internal class System.Security.Policy.MonoTrustManager : object {
    private static string tag;
    public sealed virtual ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual SecurityElement ToXml();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.NetCodeGroup : CodeGroup {
    public static string AbsentOriginScheme;
    public static string AnyOtherOriginScheme;
    private Hashtable _rules;
    private int _hashcode;
    public string AttributeString { get; }
    public string MergeLogic { get; }
    public string PermissionSetName { get; }
    public NetCodeGroup(IMembershipCondition membershipCondition);
    internal NetCodeGroup(SecurityElement e, PolicyLevel level);
    private static NetCodeGroup();
    public virtual string get_AttributeString();
    public virtual string get_MergeLogic();
    public virtual string get_PermissionSetName();
    [MonoTODOAttribute("(2.0) missing validations")]
public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess);
    public virtual CodeGroup Copy();
    private bool Equals(CodeConnectAccess[] rules1, CodeConnectAccess[] rules2);
    public virtual bool Equals(object o);
    public DictionaryEntry[] GetConnectAccessRules();
    public virtual int GetHashCode();
    public virtual PolicyStatement Resolve(Evidence evidence);
    public void ResetConnectAccess();
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    [MonoTODOAttribute("(2.0) Add new stuff (CodeConnectAccess) into XML")]
protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
    [MonoTODOAttribute("(2.0) Parse new stuff (CodeConnectAccess) from XML")]
protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PermissionRequestEvidence : EvidenceBase {
    private PermissionSet requested;
    private PermissionSet optional;
    private PermissionSet denied;
    public PermissionSet DeniedPermissions { get; }
    public PermissionSet OptionalPermissions { get; }
    public PermissionSet RequestedPermissions { get; }
    public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied);
    public PermissionSet get_DeniedPermissions();
    public PermissionSet get_OptionalPermissions();
    public PermissionSet get_RequestedPermissions();
    public PermissionRequestEvidence Copy();
    public virtual string ToString();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyException : SystemException {
    public PolicyException(string message);
    protected PolicyException(SerializationInfo info, StreamingContext context);
    public PolicyException(string message, Exception exception);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyLevel : object {
    private string label;
    private CodeGroup root_code_group;
    private ArrayList full_trust_assemblies;
    private ArrayList named_permission_sets;
    private string _location;
    private PolicyLevelType _type;
    private Hashtable fullNames;
    private SecurityElement xml;
    [ObsoleteAttribute("All GACed assemblies are now fully trusted and all permissions now succeed on fully trusted code.")]
public IList FullTrustAssemblies { get; }
    public string Label { get; }
    public IList NamedPermissionSets { get; }
    public CodeGroup RootCodeGroup { get; public set; }
    public string StoreLocation { get; }
    [ComVisibleAttribute("False")]
public PolicyLevelType Type { get; }
    internal PolicyLevel(string label, PolicyLevelType type);
    internal void LoadFromFile(string filename);
    internal void LoadFromString(string xml);
    private SecurityElement FromString(string xml);
    public IList get_FullTrustAssemblies();
    public string get_Label();
    public IList get_NamedPermissionSets();
    public CodeGroup get_RootCodeGroup();
    public void set_RootCodeGroup(CodeGroup value);
    public string get_StoreLocation();
    public PolicyLevelType get_Type();
    [ObsoleteAttribute("All GACed assemblies are now fully trusted and all permissions now succeed on fully trusted code.")]
public void AddFullTrustAssembly(StrongName sn);
    [ObsoleteAttribute("All GACed assemblies are now fully trusted and all permissions now succeed on fully trusted code.")]
public void AddFullTrustAssembly(StrongNameMembershipCondition snMC);
    public void AddNamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet);
    public static PolicyLevel CreateAppDomainLevel();
    public void FromXml(SecurityElement e);
    public NamedPermissionSet GetNamedPermissionSet(string name);
    public void Recover();
    [ObsoleteAttribute("All GACed assemblies are now fully trusted and all permissions now succeed on fully trusted code.")]
public void RemoveFullTrustAssembly(StrongName sn);
    [ObsoleteAttribute("All GACed assemblies are now fully trusted and all permissions now succeed on fully trusted code.")]
public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC);
    public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet);
    public NamedPermissionSet RemoveNamedPermissionSet(string name);
    public void Reset();
    public PolicyStatement Resolve(Evidence evidence);
    public CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public SecurityElement ToXml();
    internal void Save();
    internal void CreateDefaultLevel(PolicyLevelType type);
    internal void CreateDefaultFullTrustAssemblies();
    internal void CreateDefaultNamedPermissionSets();
    internal string ResolveClassName(string className);
    internal bool IsFullTrustAssembly(Assembly a);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.PolicyStatement : object {
    private PermissionSet perms;
    private PolicyStatementAttribute attrs;
    public PermissionSet PermissionSet { get; public set; }
    public PolicyStatementAttribute Attributes { get; public set; }
    public string AttributeString { get; }
    public PolicyStatement(PermissionSet permSet);
    public PolicyStatement(PermissionSet permSet, PolicyStatementAttribute attributes);
    public PermissionSet get_PermissionSet();
    public void set_PermissionSet(PermissionSet value);
    public PolicyStatementAttribute get_Attributes();
    public void set_Attributes(PolicyStatementAttribute value);
    public string get_AttributeString();
    public PolicyStatement Copy();
    public sealed virtual void FromXml(SecurityElement et);
    [SecuritySafeCriticalAttribute]
public sealed virtual void FromXml(SecurityElement et, PolicyLevel level);
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    [ComVisibleAttribute("False")]
public virtual bool Equals(object obj);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    internal static PolicyStatement Empty();
}
[FlagsAttribute]
public enum System.Security.Policy.PolicyStatementAttribute : Enum {
    public int value__;
    public static PolicyStatementAttribute All;
    public static PolicyStatementAttribute Exclusive;
    public static PolicyStatementAttribute LevelFinal;
    public static PolicyStatementAttribute Nothing;
}
public class System.Security.Policy.Publisher : EvidenceBase {
    public X509Certificate Certificate { get; }
    public Publisher(X509Certificate cert);
    public X509Certificate get_Certificate();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Security.Policy.PublisherMembershipCondition : object {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    public X509Certificate Certificate { get; public set; }
    public PublisherMembershipCondition(X509Certificate certificate);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Site : EvidenceBase {
    internal string origin_site;
    public string Name { get; }
    public Site(string name);
    public static Site CreateFromUrl(string url);
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_Name();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
    internal static bool IsValid(string name);
    internal static string UrlToSite(string url);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.SiteMembershipCondition : object {
    private int version;
    private string _site;
    public string Site { get; public set; }
    public SiteMembershipCondition(string site);
    public string get_Site();
    public void set_Site(string value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.StrongName : EvidenceBase {
    private StrongNamePublicKeyBlob publickey;
    private string name;
    private Version version;
    public string Name { get; }
    public StrongNamePublicKeyBlob PublicKey { get; }
    public Version Version { get; }
    public StrongName(StrongNamePublicKeyBlob blob, string name, Version version);
    public string get_Name();
    public StrongNamePublicKeyBlob get_PublicKey();
    public Version get_Version();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.StrongNameMembershipCondition : object {
    private int version;
    private StrongNamePublicKeyBlob blob;
    private string name;
    private Version assemblyVersion;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public StrongNamePublicKeyBlob PublicKey { get; public set; }
    public StrongNameMembershipCondition(StrongNamePublicKeyBlob blob, string name, Version version);
    internal StrongNameMembershipCondition(SecurityElement e);
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public StrongNamePublicKeyBlob get_PublicKey();
    public void set_PublicKey(StrongNamePublicKeyBlob value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.TrustManagerContext : object {
    private bool _ignorePersistedDecision;
    private bool _noPrompt;
    private bool _keepAlive;
    private bool _persist;
    private ApplicationIdentity _previousId;
    private TrustManagerUIContext _ui;
    public bool IgnorePersistedDecision { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool NoPrompt { get; public set; }
    public bool Persist { get; public set; }
    public ApplicationIdentity PreviousApplicationIdentity { get; public set; }
    public TrustManagerUIContext UIContext { get; public set; }
    public TrustManagerContext(TrustManagerUIContext uiContext);
    public virtual bool get_IgnorePersistedDecision();
    public virtual void set_IgnorePersistedDecision(bool value);
    public virtual bool get_KeepAlive();
    public virtual void set_KeepAlive(bool value);
    public virtual bool get_NoPrompt();
    public virtual void set_NoPrompt(bool value);
    public virtual bool get_Persist();
    public virtual void set_Persist(bool value);
    public virtual ApplicationIdentity get_PreviousApplicationIdentity();
    public virtual void set_PreviousApplicationIdentity(ApplicationIdentity value);
    public virtual TrustManagerUIContext get_UIContext();
    public virtual void set_UIContext(TrustManagerUIContext value);
}
[ComVisibleAttribute("True")]
public enum System.Security.Policy.TrustManagerUIContext : Enum {
    public int value__;
    public static TrustManagerUIContext Install;
    public static TrustManagerUIContext Upgrade;
    public static TrustManagerUIContext Run;
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.UnionCodeGroup : CodeGroup {
    public string MergeLogic { get; }
    public UnionCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
    internal UnionCodeGroup(SecurityElement e, PolicyLevel level);
    public virtual CodeGroup Copy();
    internal CodeGroup Copy(bool childs);
    public virtual PolicyStatement Resolve(Evidence evidence);
    public virtual CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
    public virtual string get_MergeLogic();
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Url : EvidenceBase {
    private string origin_url;
    public string Value { get; }
    public Url(string name);
    internal Url(string name, bool validated);
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_Value();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    [MonoTODOAttribute("IBuiltInEvidence")]
private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
    private string Prepare(string url);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.UrlMembershipCondition : object {
    private int version;
    private Url url;
    private string userUrl;
    public string Url { get; public set; }
    public UrlMembershipCondition(string url);
    internal UrlMembershipCondition(Url url, string userUrl);
    public string get_Url();
    public void set_Url(string value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
    internal void CheckUrl(string url);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.Zone : EvidenceBase {
    private SecurityZone zone;
    public SecurityZone SecurityZone { get; }
    public Zone(SecurityZone zone);
    public SecurityZone get_SecurityZone();
    public object Copy();
    public sealed virtual IPermission CreateIdentityPermission(Evidence evidence);
    [MonoTODOAttribute("Not user configurable yet")]
public static Zone CreateFromUrl(string url);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position);
    private sealed virtual override int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose);
}
[ComVisibleAttribute("True")]
public class System.Security.Policy.ZoneMembershipCondition : object {
    private int version;
    private SecurityZone zone;
    public SecurityZone SecurityZone { get; public set; }
    public ZoneMembershipCondition(SecurityZone zone);
    public SecurityZone get_SecurityZone();
    public void set_SecurityZone(SecurityZone value);
    public sealed virtual bool Check(Evidence evidence);
    public sealed virtual IMembershipCondition Copy();
    public virtual bool Equals(object o);
    public sealed virtual void FromXml(SecurityElement e);
    public sealed virtual void FromXml(SecurityElement e, PolicyLevel level);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual SecurityElement ToXml();
    public sealed virtual SecurityElement ToXml(PolicyLevel level);
}
public enum System.Security.PolicyLevelType : Enum {
    public int value__;
    public static PolicyLevelType AppDomain;
    public static PolicyLevelType Enterprise;
    public static PolicyLevelType Machine;
    public static PolicyLevelType User;
}
public class System.Security.Principal.GenericIdentity : ClaimsIdentity {
    private string m_name;
    private string m_type;
    public IEnumerable`1<Claim> Claims { get; }
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public GenericIdentity(string name);
    public GenericIdentity(string name, string type);
    protected GenericIdentity(GenericIdentity identity);
    public virtual ClaimsIdentity Clone();
    public virtual IEnumerable`1<Claim> get_Claims();
    public virtual string get_Name();
    public virtual string get_AuthenticationType();
    public virtual bool get_IsAuthenticated();
    private void AddNameClaim();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.GenericPrincipal : ClaimsPrincipal {
    private IIdentity m_identity;
    private String[] m_roles;
    internal String[] Roles { get; }
    public IIdentity Identity { get; }
    public GenericPrincipal(IIdentity identity, String[] roles);
    internal String[] get_Roles();
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(string role);
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.IdentityNotMappedException : SystemException {
    private IdentityReferenceCollection _coll;
    public IdentityReferenceCollection UnmappedIdentities { get; }
    public IdentityNotMappedException(string message);
    public IdentityNotMappedException(string message, Exception inner);
    public IdentityReferenceCollection get_UnmappedIdentities();
    [SecurityCriticalAttribute]
[MonoTODOAttribute("not implemented")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[ComVisibleAttribute("False")]
public abstract class System.Security.Principal.IdentityReference : object {
    public string Value { get; }
    public abstract virtual string get_Value();
    public abstract virtual bool Equals(object o);
    public abstract virtual int GetHashCode();
    public abstract virtual bool IsValidTargetType(Type targetType);
    public abstract virtual string ToString();
    public abstract virtual IdentityReference Translate(Type targetType);
    public static bool op_Equality(IdentityReference left, IdentityReference right);
    public static bool op_Inequality(IdentityReference left, IdentityReference right);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class System.Security.Principal.IdentityReferenceCollection : object {
    private ArrayList _list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IdentityReference Item { get; public set; }
    public IdentityReferenceCollection(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public IdentityReference get_Item(int index);
    public void set_Item(int index, IdentityReference value);
    public sealed virtual void Add(IdentityReference identity);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IdentityReference identity);
    public sealed virtual void CopyTo(IdentityReference[] array, int offset);
    public sealed virtual IEnumerator`1<IdentityReference> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Remove(IdentityReference identity);
    public IdentityReferenceCollection Translate(Type targetType);
    public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess);
}
public interface System.Security.Principal.IIdentity {
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
}
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    public abstract virtual bool IsInRole(string role);
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.NTAccount : IdentityReference {
    private string _value;
    public string Value { get; }
    public NTAccount(string name);
    public NTAccount(string domainName, string accountName);
    public virtual string get_Value();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool IsValidTargetType(Type targetType);
    public virtual string ToString();
    public virtual IdentityReference Translate(Type targetType);
    public static bool op_Equality(NTAccount left, NTAccount right);
    public static bool op_Inequality(NTAccount left, NTAccount right);
}
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
[ComVisibleAttribute("False")]
public class System.Security.Principal.SecurityIdentifier : IdentityReference {
    private Byte[] buffer;
    public static int MaxBinaryLength;
    public static int MinBinaryLength;
    public SecurityIdentifier AccountDomainSid { get; }
    public int BinaryLength { get; }
    public string Value { get; }
    public SecurityIdentifier(string sddlForm);
    public SecurityIdentifier(Byte[] binaryForm, int offset);
    public SecurityIdentifier(IntPtr binaryForm);
    public SecurityIdentifier(WellKnownSidType sidType, SecurityIdentifier domainSid);
    private static SecurityIdentifier();
    private void CreateFromBinaryForm(IntPtr binaryForm, int length);
    public SecurityIdentifier get_AccountDomainSid();
    public int get_BinaryLength();
    public virtual string get_Value();
    private ulong GetSidAuthority();
    private byte GetSidSubAuthorityCount();
    private UInt32 GetSidSubAuthority(byte index);
    public sealed virtual int CompareTo(SecurityIdentifier sid);
    public virtual bool Equals(object o);
    public bool Equals(SecurityIdentifier sid);
    public void GetBinaryForm(Byte[] binaryForm, int offset);
    public virtual int GetHashCode();
    public bool IsAccountSid();
    public bool IsEqualDomainSid(SecurityIdentifier sid);
    public virtual bool IsValidTargetType(Type targetType);
    public bool IsWellKnown(WellKnownSidType type);
    public virtual string ToString();
    public virtual IdentityReference Translate(Type targetType);
    public static bool op_Equality(SecurityIdentifier left, SecurityIdentifier right);
    public static bool op_Inequality(SecurityIdentifier left, SecurityIdentifier right);
    internal string GetSddlForm();
    internal static SecurityIdentifier ParseSddlForm(string sddlForm, Int32& pos);
    private static Byte[] ParseSddlForm(string sddlForm);
    private static bool TryParseAuthority(string s, UInt64& result);
    private static bool TryParseSubAuthority(string s, UInt32& result);
}
[FlagsAttribute]
public enum System.Security.Principal.TokenAccessLevels : Enum {
    public int value__;
    public static TokenAccessLevels AssignPrimary;
    public static TokenAccessLevels Duplicate;
    public static TokenAccessLevels Impersonate;
    public static TokenAccessLevels Query;
    public static TokenAccessLevels QuerySource;
    public static TokenAccessLevels AdjustPrivileges;
    public static TokenAccessLevels AdjustGroups;
    public static TokenAccessLevels AdjustDefault;
    public static TokenAccessLevels AdjustSessionId;
    public static TokenAccessLevels Read;
    public static TokenAccessLevels Write;
    public static TokenAccessLevels AllAccess;
    public static TokenAccessLevels MaximumAllowed;
}
public enum System.Security.Principal.TokenImpersonationLevel : Enum {
    public int value__;
    public static TokenImpersonationLevel None;
    public static TokenImpersonationLevel Anonymous;
    public static TokenImpersonationLevel Identification;
    public static TokenImpersonationLevel Impersonation;
    public static TokenImpersonationLevel Delegation;
}
internal class System.Security.Principal.WellKnownAccount : object {
    [CompilerGeneratedAttribute]
private WellKnownSidType <WellKnownValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbsolute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Rid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SddlForm>k__BackingField;
    private static WellKnownAccount[] accounts;
    public WellKnownSidType WellKnownValue { get; public set; }
    public bool IsAbsolute { get; public set; }
    public string Sid { get; public set; }
    public string Rid { get; public set; }
    public string Name { get; public set; }
    public string SddlForm { get; public set; }
    private static WellKnownAccount();
    [CompilerGeneratedAttribute]
public WellKnownSidType get_WellKnownValue();
    [CompilerGeneratedAttribute]
public void set_WellKnownValue(WellKnownSidType value);
    [CompilerGeneratedAttribute]
public bool get_IsAbsolute();
    [CompilerGeneratedAttribute]
public void set_IsAbsolute(bool value);
    [CompilerGeneratedAttribute]
public string get_Sid();
    [CompilerGeneratedAttribute]
public void set_Sid(string value);
    [CompilerGeneratedAttribute]
public string get_Rid();
    [CompilerGeneratedAttribute]
public void set_Rid(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_SddlForm();
    [CompilerGeneratedAttribute]
public void set_SddlForm(string value);
    public static WellKnownAccount LookupByType(WellKnownSidType sidType);
    public static WellKnownAccount LookupBySid(string s);
    public static WellKnownAccount LookupByName(string s);
    public static WellKnownAccount LookupBySddlForm(string s);
}
[ComVisibleAttribute("False")]
public enum System.Security.Principal.WellKnownSidType : Enum {
    public int value__;
    public static WellKnownSidType NullSid;
    public static WellKnownSidType WorldSid;
    public static WellKnownSidType LocalSid;
    public static WellKnownSidType CreatorOwnerSid;
    public static WellKnownSidType CreatorGroupSid;
    public static WellKnownSidType CreatorOwnerServerSid;
    public static WellKnownSidType CreatorGroupServerSid;
    public static WellKnownSidType NTAuthoritySid;
    public static WellKnownSidType DialupSid;
    public static WellKnownSidType NetworkSid;
    public static WellKnownSidType BatchSid;
    public static WellKnownSidType InteractiveSid;
    public static WellKnownSidType ServiceSid;
    public static WellKnownSidType AnonymousSid;
    public static WellKnownSidType ProxySid;
    public static WellKnownSidType EnterpriseControllersSid;
    public static WellKnownSidType SelfSid;
    public static WellKnownSidType AuthenticatedUserSid;
    public static WellKnownSidType RestrictedCodeSid;
    public static WellKnownSidType TerminalServerSid;
    public static WellKnownSidType RemoteLogonIdSid;
    public static WellKnownSidType LogonIdsSid;
    public static WellKnownSidType LocalSystemSid;
    public static WellKnownSidType LocalServiceSid;
    public static WellKnownSidType NetworkServiceSid;
    public static WellKnownSidType BuiltinDomainSid;
    public static WellKnownSidType BuiltinAdministratorsSid;
    public static WellKnownSidType BuiltinUsersSid;
    public static WellKnownSidType BuiltinGuestsSid;
    public static WellKnownSidType BuiltinPowerUsersSid;
    public static WellKnownSidType BuiltinAccountOperatorsSid;
    public static WellKnownSidType BuiltinSystemOperatorsSid;
    public static WellKnownSidType BuiltinPrintOperatorsSid;
    public static WellKnownSidType BuiltinBackupOperatorsSid;
    public static WellKnownSidType BuiltinReplicatorSid;
    public static WellKnownSidType BuiltinPreWindows2000CompatibleAccessSid;
    public static WellKnownSidType BuiltinRemoteDesktopUsersSid;
    public static WellKnownSidType BuiltinNetworkConfigurationOperatorsSid;
    public static WellKnownSidType AccountAdministratorSid;
    public static WellKnownSidType AccountGuestSid;
    public static WellKnownSidType AccountKrbtgtSid;
    public static WellKnownSidType AccountDomainAdminsSid;
    public static WellKnownSidType AccountDomainUsersSid;
    public static WellKnownSidType AccountDomainGuestsSid;
    public static WellKnownSidType AccountComputersSid;
    public static WellKnownSidType AccountControllersSid;
    public static WellKnownSidType AccountCertAdminsSid;
    public static WellKnownSidType AccountSchemaAdminsSid;
    public static WellKnownSidType AccountEnterpriseAdminsSid;
    public static WellKnownSidType AccountPolicyAdminsSid;
    public static WellKnownSidType AccountRasAndIasServersSid;
    public static WellKnownSidType NtlmAuthenticationSid;
    public static WellKnownSidType DigestAuthenticationSid;
    public static WellKnownSidType SChannelAuthenticationSid;
    public static WellKnownSidType ThisOrganizationSid;
    public static WellKnownSidType OtherOrganizationSid;
    public static WellKnownSidType BuiltinIncomingForestTrustBuildersSid;
    public static WellKnownSidType BuiltinPerformanceMonitoringUsersSid;
    public static WellKnownSidType BuiltinPerformanceLoggingUsersSid;
    public static WellKnownSidType BuiltinAuthorizationAccessSid;
    public static WellKnownSidType WinBuiltinTerminalServerLicenseServersSid;
    public static WellKnownSidType MaxDefined;
    public static WellKnownSidType WinBuiltinDCOMUsersSid;
    public static WellKnownSidType WinBuiltinIUsersSid;
    public static WellKnownSidType WinIUserSid;
    public static WellKnownSidType WinBuiltinCryptoOperatorsSid;
    public static WellKnownSidType WinUntrustedLabelSid;
    public static WellKnownSidType WinLowLabelSid;
    public static WellKnownSidType WinMediumLabelSid;
    public static WellKnownSidType WinHighLabelSid;
    public static WellKnownSidType WinSystemLabelSid;
    public static WellKnownSidType WinWriteRestrictedCodeSid;
    public static WellKnownSidType WinCreatorOwnerRightsSid;
    public static WellKnownSidType WinCacheablePrincipalsGroupSid;
    public static WellKnownSidType WinNonCacheablePrincipalsGroupSid;
    public static WellKnownSidType WinEnterpriseReadonlyControllersSid;
    public static WellKnownSidType WinAccountReadonlyControllersSid;
    public static WellKnownSidType WinBuiltinEventLogReadersGroup;
    public static WellKnownSidType WinNewEnterpriseReadonlyControllersSid;
    public static WellKnownSidType WinBuiltinCertSvcDComAccessGroup;
    public static WellKnownSidType WinMediumPlusLabelSid;
    public static WellKnownSidType WinLocalLogonSid;
    public static WellKnownSidType WinConsoleLogonSid;
    public static WellKnownSidType WinThisOrganizationCertificateSid;
    public static WellKnownSidType WinApplicationPackageAuthoritySid;
    public static WellKnownSidType WinBuiltinAnyPackageSid;
    public static WellKnownSidType WinCapabilityInternetClientSid;
    public static WellKnownSidType WinCapabilityInternetClientServerSid;
    public static WellKnownSidType WinCapabilityPrivateNetworkClientServerSid;
    public static WellKnownSidType WinCapabilityPicturesLibrarySid;
    public static WellKnownSidType WinCapabilityVideosLibrarySid;
    public static WellKnownSidType WinCapabilityMusicLibrarySid;
    public static WellKnownSidType WinCapabilityDocumentsLibrarySid;
    public static WellKnownSidType WinCapabilitySharedUserCertificatesSid;
    public static WellKnownSidType WinCapabilityEnterpriseAuthenticationSid;
    public static WellKnownSidType WinCapabilityRemovableStorageSid;
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.WindowsAccountType : Enum {
    public int value__;
    public static WindowsAccountType Normal;
    public static WindowsAccountType Guest;
    public static WindowsAccountType System;
    public static WindowsAccountType Anonymous;
}
[ComVisibleAttribute("True")]
public enum System.Security.Principal.WindowsBuiltInRole : Enum {
    public int value__;
    public static WindowsBuiltInRole Administrator;
    public static WindowsBuiltInRole User;
    public static WindowsBuiltInRole Guest;
    public static WindowsBuiltInRole PowerUser;
    public static WindowsBuiltInRole AccountOperator;
    public static WindowsBuiltInRole SystemOperator;
    public static WindowsBuiltInRole PrintOperator;
    public static WindowsBuiltInRole BackupOperator;
    public static WindowsBuiltInRole Replicator;
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsIdentity : ClaimsIdentity {
    private IntPtr _token;
    private string _type;
    private WindowsAccountType _account;
    private bool _authenticated;
    private string _name;
    private SerializationInfo _info;
    private static IntPtr invalidWindows;
    public static string DefaultIssuer;
    public string AuthenticationType { get; }
    public bool IsAnonymous { get; }
    public bool IsAuthenticated { get; }
    public bool IsGuest { get; }
    public bool IsSystem { get; }
    public string Name { get; }
    public IntPtr Token { get; }
    [MonoTODOAttribute("not implemented")]
public IdentityReferenceCollection Groups { get; }
    [MonoTODOAttribute("not implemented")]
[ComVisibleAttribute("False")]
public TokenImpersonationLevel ImpersonationLevel { get; }
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("not implemented")]
public SecurityIdentifier Owner { get; }
    [ComVisibleAttribute("False")]
[MonoTODOAttribute("not implemented")]
public SecurityIdentifier User { get; }
    public SafeAccessTokenHandle AccessToken { get; }
    public IEnumerable`1<Claim> DeviceClaims { get; }
    public IEnumerable`1<Claim> UserClaims { get; }
    public WindowsIdentity(IntPtr userToken);
    public WindowsIdentity(IntPtr userToken, string type);
    public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType);
    public WindowsIdentity(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated);
    public WindowsIdentity(string sUserPrincipalName);
    public WindowsIdentity(string sUserPrincipalName, string type);
    public WindowsIdentity(SerializationInfo info, StreamingContext context);
    internal WindowsIdentity(ClaimsIdentity claimsIdentity, IntPtr userToken);
    private static WindowsIdentity();
    [SecuritySafeCriticalAttribute]
protected WindowsIdentity(WindowsIdentity identity);
    [ComVisibleAttribute("False")]
public sealed virtual void Dispose();
    [ComVisibleAttribute("False")]
protected virtual void Dispose(bool disposing);
    public static WindowsIdentity GetAnonymous();
    public static WindowsIdentity GetCurrent();
    [MonoTODOAttribute("need icall changes")]
public static WindowsIdentity GetCurrent(bool ifImpersonating);
    [MonoTODOAttribute("need icall changes")]
public static WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess);
    public virtual WindowsImpersonationContext Impersonate();
    public static WindowsImpersonationContext Impersonate(IntPtr userToken);
    [SecuritySafeCriticalAttribute]
public static void RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Action action);
    [SecuritySafeCriticalAttribute]
public static T RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Func`1<T> func);
    [SecuritySafeCriticalAttribute]
public sealed virtual string get_AuthenticationType();
    public virtual bool get_IsAnonymous();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsGuest();
    public virtual bool get_IsSystem();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    public virtual IntPtr get_Token();
    public IdentityReferenceCollection get_Groups();
    public TokenImpersonationLevel get_ImpersonationLevel();
    public SecurityIdentifier get_Owner();
    public SecurityIdentifier get_User();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal ClaimsIdentity CloneAsBase();
    internal IntPtr GetTokenInternal();
    private void SetToken(IntPtr token);
    public SafeAccessTokenHandle get_AccessToken();
    internal static String[] _GetRoles(IntPtr token);
    internal static IntPtr GetCurrentToken();
    private static string GetTokenName(IntPtr token);
    private static IntPtr GetUserToken(string username);
    public virtual IEnumerable`1<Claim> get_DeviceClaims();
    public virtual IEnumerable`1<Claim> get_UserClaims();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsImpersonationContext : object {
    private IntPtr _token;
    private bool undo;
    internal WindowsImpersonationContext(IntPtr token);
    [ComVisibleAttribute("False")]
public sealed virtual void Dispose();
    [ComVisibleAttribute("False")]
protected virtual void Dispose(bool disposing);
    public void Undo();
    private static bool CloseToken(IntPtr token);
    private static IntPtr DuplicateToken(IntPtr token);
    private static bool SetCurrentToken(IntPtr token);
    private static bool RevertToSelf();
}
[ComVisibleAttribute("True")]
public class System.Security.Principal.WindowsPrincipal : ClaimsPrincipal {
    private WindowsIdentity _identity;
    private String[] m_roles;
    public IIdentity Identity { get; }
    private IntPtr Token { get; }
    public IEnumerable`1<Claim> DeviceClaims { get; }
    public IEnumerable`1<Claim> UserClaims { get; }
    public WindowsPrincipal(WindowsIdentity ntIdentity);
    public virtual IIdentity get_Identity();
    public virtual bool IsInRole(int rid);
    [SecuritySafeCriticalAttribute]
public virtual bool IsInRole(string role);
    public virtual bool IsInRole(WindowsBuiltInRole role);
    [MonoTODOAttribute("not implemented")]
[ComVisibleAttribute("False")]
public virtual bool IsInRole(SecurityIdentifier sid);
    private IntPtr get_Token();
    private static bool IsMemberOfGroupId(IntPtr user, IntPtr group);
    private static bool IsMemberOfGroupName(IntPtr user, IntPtr group);
    public virtual IEnumerable`1<Claim> get_DeviceClaims();
    public virtual IEnumerable`1<Claim> get_UserClaims();
}
public class System.Security.ReadOnlyPermissionSet : PermissionSet {
    public ReadOnlyPermissionSet(SecurityElement permissionSetXml);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    protected virtual IEnumerator GetEnumeratorImpl();
    protected virtual IPermission GetPermissionImpl(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
}
internal class System.Security.RuntimeDeclSecurityActions : ValueType {
    public RuntimeDeclSecurityEntry cas;
    public RuntimeDeclSecurityEntry noncas;
    public RuntimeDeclSecurityEntry choice;
}
internal class System.Security.RuntimeDeclSecurityEntry : ValueType {
    public IntPtr blob;
    public int size;
    public int index;
}
[MonoTODOAttribute("work in progress - encryption is missing")]
public class System.Security.SecureString : object {
    private static int BlockSize;
    private static int MaxSize;
    private int length;
    private bool disposed;
    private bool read_only;
    private Byte[] data;
    public int Length { get; }
    private static SecureString();
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    public int get_Length();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void AppendChar(char c);
    public void Clear();
    public SecureString Copy();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    [HandleProcessCorruptedStateExceptionsAttribute]
public void RemoveAt(int index);
    [HandleProcessCorruptedStateExceptionsAttribute]
public void SetAt(int index, char c);
    private void Encrypt();
    private void Decrypt();
    private void Alloc(int length, bool realloc);
    internal Byte[] GetBuffer();
}
public class System.Security.SecurityContext : object {
    public SecurityContext CreateCopy();
    public static SecurityContext Capture();
    public sealed virtual void Dispose();
    public static bool IsFlowSuppressed();
    public static bool IsWindowsIdentityFlowSuppressed();
    public static void RestoreFlow();
    public static void Run(SecurityContext securityContext, ContextCallback callback, object state);
    public static AsyncFlowControl SuppressFlow();
    public static AsyncFlowControl SuppressFlowWindowsIdentity();
}
internal enum System.Security.SecurityContextDisableFlow : Enum {
    public int value__;
    public static SecurityContextDisableFlow Nothing;
    public static SecurityContextDisableFlow WI;
    public static SecurityContextDisableFlow All;
}
public enum System.Security.SecurityContextSource : Enum {
    public int value__;
    public static SecurityContextSource CurrentAppDomain;
    public static SecurityContextSource CurrentAssembly;
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    private SecurityCriticalScope _val;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
internal class System.Security.SecurityDocument : object {
    internal Byte[] m_data;
    internal static byte c_element;
    internal static byte c_attribute;
    internal static byte c_text;
    internal static byte c_children;
    internal static int c_growthSize;
    public SecurityDocument(int numData);
    public SecurityDocument(Byte[] data);
    public SecurityDocument(SecurityElement elRoot);
    public void GuaranteeSize(int size);
    public void AddString(string str, Int32& position);
    public void AppendString(string str, Int32& position);
    public static int EncodedStringSize(string str);
    public string GetString(Int32& position);
    public string GetString(Int32& position, bool bCreate);
    public void AddToken(byte b, Int32& position);
    public void ConvertElement(SecurityElement elCurrent, Int32& position);
    public SecurityElement GetRootElement();
    public SecurityElement GetElement(int position, bool bCreate);
    internal SecurityElement InternalGetElement(Int32& position, bool bCreate);
    public string GetTagForElement(int position);
    public ArrayList GetChildrenPositionForElement(int position);
    public string GetAttributeForElement(int position, string attributeName);
}
[ComVisibleAttribute("True")]
public class System.Security.SecurityElement : object {
    private string text;
    private string tag;
    private ArrayList attributes;
    private ArrayList children;
    private static Char[] invalid_tag_chars;
    private static Char[] invalid_text_chars;
    private static Char[] invalid_attr_name_chars;
    private static Char[] invalid_attr_value_chars;
    private static Char[] invalid_chars;
    public Hashtable Attributes { get; public set; }
    public ArrayList Children { get; public set; }
    public string Tag { get; public set; }
    public string Text { get; public set; }
    internal string m_strTag { get; }
    internal string m_strText { get; internal set; }
    internal ArrayList m_lAttributes { get; }
    internal ArrayList InternalChildren { get; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    internal SecurityElement(SecurityElement se);
    private static SecurityElement();
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    public string get_Tag();
    public void set_Tag(string value);
    public string get_Text();
    public void set_Text(string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    public string Attribute(string name);
    [ComVisibleAttribute("False")]
public SecurityElement Copy();
    public bool Equal(SecurityElement other);
    public static string Escape(string str);
    private static string Unescape(string str);
    public static SecurityElement FromString(string xml);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public SecurityElement SearchForChildByTag(string tag);
    public string SearchForTextOfTag(string tag);
    public virtual string ToString();
    private void ToXml(StringBuilder& s, int level);
    internal SecurityAttribute GetAttribute(string name);
    internal string get_m_strTag();
    internal string get_m_strText();
    internal void set_m_strText(string value);
    internal ArrayList get_m_lAttributes();
    internal ArrayList get_InternalChildren();
    internal string SearchForTextOfLocalName(string strLocalName);
}
internal enum System.Security.SecurityElementType : Enum {
    public int value__;
    public static SecurityElementType Regular;
    public static SecurityElementType Format;
    public static SecurityElementType Comment;
}
[ComVisibleAttribute("True")]
public class System.Security.SecurityException : SystemException {
    private string permissionState;
    private Type permissionType;
    private string _granted;
    private string _refused;
    private object _demanded;
    private IPermission _firstperm;
    private MethodInfo _method;
    private Evidence _evidence;
    private SecurityAction _action;
    private object _denyset;
    private object _permitset;
    private AssemblyName _assembly;
    private string _url;
    private SecurityZone _zone;
    [ComVisibleAttribute("False")]
public SecurityAction Action { get; public set; }
    [ComVisibleAttribute("False")]
public object DenySetInstance { get; public set; }
    [ComVisibleAttribute("False")]
public AssemblyName FailedAssemblyInfo { get; public set; }
    [ComVisibleAttribute("False")]
public MethodInfo Method { get; public set; }
    [ComVisibleAttribute("False")]
public object PermitOnlySetInstance { get; public set; }
    public string Url { get; public set; }
    public SecurityZone Zone { get; public set; }
    [ComVisibleAttribute("False")]
public object Demanded { get; public set; }
    public IPermission FirstPermissionThatFailed { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public string GrantedSet { get; public set; }
    public string RefusedSet { get; public set; }
    public SecurityException(string message);
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    internal SecurityException(string message, PermissionSet granted, PermissionSet refused);
    public SecurityException(string message, object deny, object permitOnly, MethodInfo method, object demanded, IPermission permThatFailed);
    public SecurityException(string message, AssemblyName assemblyName, PermissionSet grant, PermissionSet refused, MethodInfo method, SecurityAction action, object demanded, IPermission permThatFailed, Evidence evidence);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public object get_DenySetInstance();
    public void set_DenySetInstance(object value);
    public AssemblyName get_FailedAssemblyInfo();
    public void set_FailedAssemblyInfo(AssemblyName value);
    public MethodInfo get_Method();
    public void set_Method(MethodInfo value);
    public object get_PermitOnlySetInstance();
    public void set_PermitOnlySetInstance(object value);
    public string get_Url();
    public void set_Url(string value);
    public SecurityZone get_Zone();
    public void set_Zone(SecurityZone value);
    public object get_Demanded();
    public void set_Demanded(object value);
    public IPermission get_FirstPermissionThatFailed();
    public void set_FirstPermissionThatFailed(IPermission value);
    public string get_PermissionState();
    public void set_PermissionState(string value);
    public Type get_PermissionType();
    public void set_PermissionType(Type value);
    public string get_GrantedSet();
    public void set_GrantedSet(string value);
    public string get_RefusedSet();
    public void set_RefusedSet(string value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string ToString();
}
[ComVisibleAttribute("True")]
public static class System.Security.SecurityManager : object {
    private static object _lockObject;
    private static ArrayList _hierarchy;
    private static IPermission _unmanagedCode;
    private static Hashtable _declsecCache;
    private static PolicyLevel _level;
    private static SecurityPermission _execution;
    [ObsoleteAttribute]
public static bool CheckExecutionRights { get; public set; }
    [ObsoleteAttribute("The security manager cannot be turned off on MS runtime")]
public static bool SecurityEnabled { get; public set; }
    private static IEnumerator Hierarchy { get; }
    internal static PolicyLevel ResolvingPolicyLevel { get; internal set; }
    private static IPermission UnmanagedCode { get; }
    private static SecurityManager();
    public static bool get_CheckExecutionRights();
    public static void set_CheckExecutionRights(bool value);
    public static bool get_SecurityEnabled();
    public static void set_SecurityEnabled(bool value);
    internal static bool CheckElevatedPermissions();
    [ConditionalAttribute("ENABLE_SANDBOX")]
internal static void EnsureElevatedPermissions();
    [MonoTODOAttribute("CAS support is experimental (and unsupported). This method only works in FullTrust.")]
public static void GetZoneAndOrigin(ArrayList& zone, ArrayList& origin);
    [ObsoleteAttribute]
public static bool IsGranted(IPermission perm);
    internal static bool IsGranted(Assembly a, IPermission perm);
    [ObsoleteAttribute]
public static PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type);
    [ObsoleteAttribute]
public static PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type);
    [ObsoleteAttribute]
public static IEnumerator PolicyHierarchy();
    [ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence);
    [MonoTODOAttribute("(2.0) more tests are needed")]
[ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence[] evidences);
    [ObsoleteAttribute]
public static PermissionSet ResolveSystemPolicy(Evidence evidence);
    [ObsoleteAttribute]
public static PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, PermissionSet& denied);
    [ObsoleteAttribute]
public static IEnumerator ResolvePolicyGroups(Evidence evidence);
    [ObsoleteAttribute]
public static void SavePolicy();
    [ObsoleteAttribute]
public static void SavePolicyLevel(PolicyLevel level);
    private static IEnumerator get_Hierarchy();
    private static void InitializePolicyHierarchy();
    internal static bool ResolvePolicyLevel(PermissionSet& ps, PolicyLevel pl, Evidence evidence);
    internal static void ResolveIdentityPermissions(PermissionSet ps, Evidence evidence);
    internal static PolicyLevel get_ResolvingPolicyLevel();
    internal static void set_ResolvingPolicyLevel(PolicyLevel value);
    internal static PermissionSet Decode(IntPtr permissions, int length);
    internal static PermissionSet Decode(Byte[] encodedPermissions);
    private static IPermission get_UnmanagedCode();
    private static void ThrowException(Exception ex);
    public static PermissionSet GetStandardSandbox(Evidence evidence);
    public static bool CurrentThreadRequiresSecurityContextCapture();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    private SecurityRuleSet m_ruleSet;
    private bool m_skipVerificationInFullTrust;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    public bool get_SkipVerificationInFullTrust();
    public void set_SkipVerificationInFullTrust(bool value);
    public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
public abstract class System.Security.SecurityState : object {
    public abstract virtual void EnsureState();
    public bool IsStateAvailable();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
public enum System.Security.SecurityZone : Enum {
    public int value__;
    public static SecurityZone Internet;
    public static SecurityZone Intranet;
    public static SecurityZone MyComputer;
    public static SecurityZone NoZone;
    public static SecurityZone Trusted;
    public static SecurityZone Untrusted;
}
[AttributeUsageAttribute("5188")]
[ComVisibleAttribute("True")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
[ComVisibleAttribute("True")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
internal static class System.Security.Util.Hex : object {
    private static char HexDigit(int num);
    public static string EncodeHexString(Byte[] sArray);
    internal static string EncodeHexStringFromInt(Byte[] sArray);
    public static int ConvertHexDigit(char val);
    public static Byte[] DecodeHexString(string hexString);
}
internal class System.Security.Util.Parser : object {
    private SecurityDocument _doc;
    private Tokenizer _t;
    private static short c_flag;
    private static short c_elementtag;
    private static short c_attributetag;
    private static short c_texttag;
    private static short c_additionaltexttag;
    private static short c_childrentag;
    private static short c_wastedstringtag;
    private Parser(Tokenizer t);
    internal Parser(string input);
    internal Parser(string input, String[] searchStrings, String[] replaceStrings);
    internal Parser(Byte[] array, ByteTokenEncoding encoding);
    internal Parser(Byte[] array, ByteTokenEncoding encoding, int startIndex);
    internal Parser(StreamReader input);
    internal Parser(Char[] array);
    internal SecurityElement GetTopElement();
    private void GetRequiredSizes(TokenizerStream stream, Int32& index);
    private int DetermineFormat(TokenizerStream stream);
    private void ParseContents();
}
internal class System.Security.Util.Tokenizer : object {
    internal static byte bra;
    internal static byte ket;
    internal static byte slash;
    internal static byte cstr;
    internal static byte equals;
    internal static byte quest;
    internal static byte bang;
    internal static byte dash;
    internal static int intOpenBracket;
    internal static int intCloseBracket;
    internal static int intSlash;
    internal static int intEquals;
    internal static int intQuote;
    internal static int intQuest;
    internal static int intBang;
    internal static int intDash;
    internal static int intTab;
    internal static int intCR;
    internal static int intLF;
    internal static int intSpace;
    public int LineNo;
    private int _inProcessingTag;
    private Byte[] _inBytes;
    private Char[] _inChars;
    private string _inString;
    private int _inIndex;
    private int _inSize;
    private int _inSavedCharacter;
    private TokenSource _inTokenSource;
    private ITokenReader _inTokenReader;
    private StringMaker _maker;
    private String[] _searchStrings;
    private String[] _replaceStrings;
    private int _inNestedIndex;
    private int _inNestedSize;
    private string _inNestedString;
    internal Tokenizer(string input);
    internal Tokenizer(string input, String[] searchStrings, String[] replaceStrings);
    internal Tokenizer(Byte[] array, ByteTokenEncoding encoding, int startIndex);
    internal Tokenizer(Char[] array);
    internal Tokenizer(StreamReader input);
    internal void BasicInitialization();
    public void Recycle();
    internal void ChangeFormat(Encoding encoding);
    internal void GetTokens(TokenizerStream stream, int maxNum, bool endAfterKet);
    private string GetStringToken();
}
internal class System.Security.Util.TokenizerShortBlock : object {
    internal Int16[] m_block;
    internal TokenizerShortBlock m_next;
}
internal class System.Security.Util.TokenizerStream : object {
    private int m_countTokens;
    private TokenizerShortBlock m_headTokens;
    private TokenizerShortBlock m_lastTokens;
    private TokenizerShortBlock m_currentTokens;
    private int m_indexTokens;
    private TokenizerStringBlock m_headStrings;
    private TokenizerStringBlock m_currentStrings;
    private int m_indexStrings;
    internal void AddToken(short token);
    internal void AddString(string str);
    internal void Reset();
    internal short GetNextFullToken();
    internal short GetNextToken();
    internal string GetNextString();
    internal void ThrowAwayNextString();
    internal void TagLastToken(short tag);
    internal int GetTokenCount();
    internal void GoToPosition(int position);
}
internal class System.Security.Util.TokenizerStringBlock : object {
    internal String[] m_block;
    internal TokenizerStringBlock m_next;
}
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    protected VerificationException(SerializationInfo info, StreamingContext context);
}
public class System.Security.XmlSyntaxException : SystemException {
    public XmlSyntaxException(int lineNumber);
    public XmlSyntaxException(int lineNumber, string message);
    public XmlSyntaxException(string message);
    public XmlSyntaxException(string message, Exception inner);
    private XmlSyntaxException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.SequencePosition : ValueType {
    private object _object;
    private int _integer;
    public SequencePosition(object object, int integer);
    public object GetObject();
    public int GetInteger();
    public sealed virtual bool Equals(SequencePosition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
internal class System.SharedStatics : object {
    private static SharedStatics _sharedStatics;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _Remoting_Identity_IDGuid;
    private StringMaker _maker;
    private int _Remoting_Identity_IDSeqNum;
    private long _memFailPointReservedMemory;
    public static string Remoting_Identity_IDGuid { get; }
    internal static ulong MemoryFailPointReservedMemory { get; }
    private static SharedStatics();
    [SecuritySafeCriticalAttribute]
public static string get_Remoting_Identity_IDGuid();
    [SecuritySafeCriticalAttribute]
public static StringMaker GetSharedStringMaker();
    [SecuritySafeCriticalAttribute]
public static void ReleaseSharedStringMaker(StringMaker& maker);
    internal static int Remoting_Identity_GetNextSeqNum();
    [ReliabilityContractAttribute("3", "2")]
internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
}
[IsReadOnlyAttribute]
public class System.Single : ValueType {
    private float m_value;
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    internal static float NegativeZero;
    [NonVersionableAttribute]
public static bool IsFinite(float f);
    [NonVersionableAttribute]
public static bool IsInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNaN(float f);
    [NonVersionableAttribute]
public static bool IsNegative(float f);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNormal(float f);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static bool IsSubnormal(float f);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(float left, float right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.SmallRect : ValueType {
    public short Left;
    public short Top;
    public short Right;
    public short Bottom;
    public SmallRect(int left, int top, int right, int bottom);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[NonVersionableAttribute]
public class System.Span`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    public T& Item { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public static Span`1<T> Empty { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(T& ptr, int length);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public T& get_Item(int index);
    public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    private static ulong XorPowerOfTwoToHighChar;
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, ulong length);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
    public static int IndexOfCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static int IndexOfCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static int IndexOfOrdinalHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, bool ignoreCase);
    public static bool StartsWithCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool StartsWithCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool StartsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    public static bool EndsWithCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool EndsWithCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool EndsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    public static void ClearWithoutReferences(Byte& b, ulong byteLength);
    public static void ClearWithReferences(IntPtr& ip, ulong pointerSizeLength);
    public static void CopyTo(T& dst, int dstLength, T& src, int srcLength);
    [ExtensionAttribute]
public static IntPtr Add(IntPtr start, int index);
    public static bool IsReferenceOrContainsReferences();
    private static bool IsReferenceOrContainsReferencesCore(Type type);
    public static void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength);
    public static void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength);
    [ExtensionAttribute]
private static bool LessThanEqual(IntPtr index, UIntPtr length);
}
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    private static int StackallocIntBufferSizeLimit;
    private static int PROBABILISTICMAP_BLOCK_INDEX_MASK;
    private static int PROBABILISTICMAP_BLOCK_INDEX_SHIFT;
    private static int PROBABILISTICMAP_SIZE;
    private int _stringLength;
    private char _firstChar;
    public static string Empty;
    public int Length { get; }
    public char Chars { get; }
    [PreserveDependencyAttribute("CreateString(System.Char[])", "System.String")]
public String(Char[] value);
    [PreserveDependencyAttribute("CreateString(System.Char[], System.Int32, System.Int32)", "System.String")]
public String(Char[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
[PreserveDependencyAttribute("CreateString(System.Char*)", "System.String")]
public String(Char* value);
    [PreserveDependencyAttribute("CreateString(System.Char*, System.Int32, System.Int32)", "System.String")]
[CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    [PreserveDependencyAttribute("CreateString(System.SByte*)", "System.String")]
[CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
[PreserveDependencyAttribute("CreateString(System.SByte*, System.Int32, System.Int32)", "System.String")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
[PreserveDependencyAttribute("CreateString(System.SByte*, System.Int32, System.Int32, System.Text.Encoding)", "System.String")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    [PreserveDependencyAttribute("CreateString(System.Char, System.Int32)", "System.String")]
public String(char c, int count);
    [PreserveDependencyAttribute("CreateString(System.ReadOnlySpan`1<System.Char>)", "System.String")]
public String(ReadOnlySpan`1<char> value);
    private static int CompareOrdinalIgnoreCaseHelper(string strA, string strB);
    private static bool EqualsHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    private static bool EqualsIgnoreCaseAsciiHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, string strB);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, string strB);
    internal static int CompareOrdinal(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public bool Equals(string value, StringComparison comparisonType);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetLegacyNonRandomizedHashCode();
    public bool StartsWith(string value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    internal static void CheckStringComparison(StringComparison comparisonType);
    private static void FillStringChecked(string dest, int destPos, string src);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(Char* separator, int separatorLength, Object[] values);
    private static string JoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private static string JoinCore(Char* separator, int separatorLength, String[] value, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CultureInfo culture, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    private string ReplaceHelper(int oldValueLength, string newValue, ReadOnlySpan`1<int> indices);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(ReadOnlySpan`1<char> separators, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, int count, StringSplitOptions options);
    private String[] SplitKeepEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private String[] SplitOmitEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private void MakeSeparatorList(ReadOnlySpan`1<char> separators, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(string separator, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(String[] separators, ValueListBuilder`1& sepListBuilder, ValueListBuilder`1& lengthListBuilder);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, char value3, int startIndex, int count);
    private int IndexOfCharArray(Char[] anyOf, int startIndex, int count);
    private static void InitializeProbabilisticMap(UInt32* charMap, ReadOnlySpan`1<char> anyOf);
    private static bool ArrayContains(char searchChar, Char[] anyOf);
    private static bool IsCharBitSet(UInt32* charMap, byte value);
    private static void SetCharBit(UInt32* charMap, byte value);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    private int LastIndexOfCharArray(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    private static string Ctor(Char[] value);
    private static string Ctor(Char[] value, int startIndex, int length);
    private static string Ctor(Char* ptr);
    private static string Ctor(Char* ptr, int startIndex, int length);
    private static string Ctor(SByte* value);
    private static string Ctor(SByte* value, int startIndex, int length);
    private static string CreateStringForSByteConstructor(Byte* pb, int numBytes);
    private static string Ctor(SByte* value, int startIndex, int length, Encoding enc);
    private static string Ctor(char c, int count);
    private static string Ctor(ReadOnlySpan`1<char> value);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public static ReadOnlySpan`1<char> op_Implicit(string value);
    public sealed virtual object Clone();
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    [NonVersionableAttribute]
public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    internal Char& GetRawStringData();
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static int wcslen(Char* ptr);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    public int get_Length();
    internal int IndexOfUnchecked(string value, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public static string Concat(object arg0, object arg1, object arg2, object arg3);
    internal int IndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
    internal int LastIndexOfUnchecked(string value, int startIndex, int count);
    internal int LastIndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
    internal bool StartsWithOrdinalUnchecked(string value);
    internal static string FastAllocateString(int length);
    private static string InternalIsInterned(string str);
    private static string InternalIntern(string str);
    private static int FastCompareStringHelper(UInt32* strAChars, int countA, UInt32* strBChars, int countB);
    private static void memset(Byte* dest, int val, int len);
    private static void memcpy(Byte* dest, Byte* src, int size);
    internal static void bzero(Byte* dest, int len);
    internal static void bzero_aligned_1(Byte* dest, int len);
    internal static void bzero_aligned_2(Byte* dest, int len);
    internal static void bzero_aligned_4(Byte* dest, int len);
    internal static void bzero_aligned_8(Byte* dest, int len);
    internal static void memcpy_aligned_1(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_2(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_4(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_8(Byte* dest, Byte* src, int size);
    private string CreateString(SByte* value);
    private string CreateString(SByte* value, int startIndex, int length);
    private string CreateString(Char* value);
    private string CreateString(Char* value, int startIndex, int length);
    private string CreateString(Char[] val, int startIndex, int length);
    private string CreateString(Char[] val);
    private string CreateString(char c, int count);
    private string CreateString(SByte* value, int startIndex, int length, Encoding enc);
    private string CreateString(ReadOnlySpan`1<char> value);
    [IntrinsicAttribute]
public char get_Chars(int index);
    public static string Intern(string str);
    public static string IsInterned(string str);
    private int LegacyStringGetHashCode();
}
public abstract class System.StringComparer : object {
    private static CultureAwareComparer s_invariantCulture;
    private static CultureAwareComparer s_invariantCultureIgnoreCase;
    private static OrdinalCaseSensitiveComparer s_ordinal;
    private static OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
internal enum System.TermInfoBooleans : Enum {
    public int value__;
    public static TermInfoBooleans AutoLeftMargin;
    public static TermInfoBooleans AutoRightMargin;
    public static TermInfoBooleans NoEscCtlc;
    public static TermInfoBooleans CeolStandoutGlitch;
    public static TermInfoBooleans EatNewlineGlitch;
    public static TermInfoBooleans EraseOverstrike;
    public static TermInfoBooleans GenericType;
    public static TermInfoBooleans HardCopy;
    public static TermInfoBooleans HasMetaKey;
    public static TermInfoBooleans HasStatusLine;
    public static TermInfoBooleans InsertNullGlitch;
    public static TermInfoBooleans MemoryAbove;
    public static TermInfoBooleans MemoryBelow;
    public static TermInfoBooleans MoveInsertMode;
    public static TermInfoBooleans MoveStandoutMode;
    public static TermInfoBooleans OverStrike;
    public static TermInfoBooleans StatusLineEscOk;
    public static TermInfoBooleans DestTabsMagicSmso;
    public static TermInfoBooleans TildeGlitch;
    public static TermInfoBooleans TransparentUnderline;
    public static TermInfoBooleans XonXoff;
    public static TermInfoBooleans NeedsXonXoff;
    public static TermInfoBooleans PrtrSilent;
    public static TermInfoBooleans HardCursor;
    public static TermInfoBooleans NonRevRmcup;
    public static TermInfoBooleans NoPadChar;
    public static TermInfoBooleans NonDestScrollRegion;
    public static TermInfoBooleans CanChange;
    public static TermInfoBooleans BackColorErase;
    public static TermInfoBooleans HueLightnessSaturation;
    public static TermInfoBooleans ColAddrGlitch;
    public static TermInfoBooleans CrCancelsMicroMode;
    public static TermInfoBooleans HasPrintWheel;
    public static TermInfoBooleans RowAddrGlitch;
    public static TermInfoBooleans SemiAutoRightMargin;
    public static TermInfoBooleans CpiChangesRes;
    public static TermInfoBooleans LpiChangesRes;
    public static TermInfoBooleans Last;
}
internal class System.TermInfoDriver : object {
    private static Int32* native_terminal_size;
    private static int terminal_size;
    private static String[] locations;
    private TermInfoReader reader;
    private int cursorLeft;
    private int cursorTop;
    private string title;
    private string titleFormat;
    private bool cursorVisible;
    private string csrVisible;
    private string csrInvisible;
    private string clear;
    private string bell;
    private string term;
    private StreamReader stdin;
    private CStreamWriter stdout;
    private int windowWidth;
    private int windowHeight;
    private int bufferHeight;
    private int bufferWidth;
    private Char[] buffer;
    private int readpos;
    private int writepos;
    private string keypadXmit;
    private string keypadLocal;
    private bool controlCAsInput;
    private bool inited;
    private object initLock;
    private bool initKeys;
    private string origPair;
    private string origColors;
    private string cursorAddress;
    private ConsoleColor fgcolor;
    private ConsoleColor bgcolor;
    private string setfgcolor;
    private string setbgcolor;
    private int maxColors;
    private bool noGetPosition;
    private Hashtable keymap;
    private ByteMatcher rootmap;
    private int rl_startx;
    private int rl_starty;
    private Byte[] control_characters;
    private static Int32[] _consoleColorToAnsiCode;
    private Char[] echobuf;
    private int echon;
    public bool Initialized { get; }
    public ConsoleColor BackgroundColor { get; public set; }
    public ConsoleColor ForegroundColor { get; public set; }
    public int BufferHeight { get; public set; }
    public int BufferWidth { get; public set; }
    public bool CapsLock { get; }
    public int CursorLeft { get; public set; }
    public int CursorTop { get; public set; }
    public bool CursorVisible { get; public set; }
    [MonoTODOAttribute]
public int CursorSize { get; public set; }
    public bool KeyAvailable { get; }
    public int LargestWindowHeight { get; }
    public int LargestWindowWidth { get; }
    public bool NumberLock { get; }
    public string Title { get; public set; }
    public bool TreatControlCAsInput { get; public set; }
    public int WindowHeight { get; public set; }
    public int WindowLeft { get; public set; }
    public int WindowTop { get; public set; }
    public int WindowWidth { get; public set; }
    public TermInfoDriver(string term);
    private static TermInfoDriver();
    private static string TryTermInfoDir(string dir, string term);
    private static string SearchTerminfo(string term);
    private void WriteConsole(string str);
    public sealed virtual bool get_Initialized();
    public sealed virtual void Init();
    private void IncrementX();
    public void WriteSpecialKey(ConsoleKeyInfo key);
    public void WriteSpecialKey(char c);
    public bool IsSpecialKey(ConsoleKeyInfo key);
    public bool IsSpecialKey(char c);
    private void ChangeColor(string format, ConsoleColor color);
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual void set_BackgroundColor(ConsoleColor value);
    public sealed virtual ConsoleColor get_ForegroundColor();
    public sealed virtual void set_ForegroundColor(ConsoleColor value);
    private void GetCursorPosition();
    public sealed virtual int get_BufferHeight();
    public sealed virtual void set_BufferHeight(int value);
    public sealed virtual int get_BufferWidth();
    public sealed virtual void set_BufferWidth(int value);
    public sealed virtual bool get_CapsLock();
    public sealed virtual int get_CursorLeft();
    public sealed virtual void set_CursorLeft(int value);
    public sealed virtual int get_CursorTop();
    public sealed virtual void set_CursorTop(int value);
    public sealed virtual bool get_CursorVisible();
    public sealed virtual void set_CursorVisible(bool value);
    public sealed virtual int get_CursorSize();
    public sealed virtual void set_CursorSize(int value);
    public sealed virtual bool get_KeyAvailable();
    public sealed virtual int get_LargestWindowHeight();
    public sealed virtual int get_LargestWindowWidth();
    public sealed virtual bool get_NumberLock();
    public sealed virtual string get_Title();
    public sealed virtual void set_Title(string value);
    public sealed virtual bool get_TreatControlCAsInput();
    public sealed virtual void set_TreatControlCAsInput(bool value);
    private void CheckWindowDimensions();
    public sealed virtual int get_WindowHeight();
    public sealed virtual void set_WindowHeight(int value);
    public sealed virtual int get_WindowLeft();
    public sealed virtual void set_WindowLeft(int value);
    public sealed virtual int get_WindowTop();
    public sealed virtual void set_WindowTop(int value);
    public sealed virtual int get_WindowWidth();
    public sealed virtual void set_WindowWidth(int value);
    public sealed virtual void Clear();
    public sealed virtual void Beep(int frequency, int duration);
    public sealed virtual void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    private void AddToBuffer(int b);
    private void AdjustBuffer();
    private ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt);
    private object GetKeyFromBuffer(bool cooked);
    private ConsoleKeyInfo ReadKeyInternal(Boolean& fresh);
    private bool InputPending();
    private void QueueEcho(char c);
    private void Echo(ConsoleKeyInfo key);
    private void EchoFlush();
    public int Read(Char[] dest, int index, int count);
    public sealed virtual ConsoleKeyInfo ReadKey(bool intercept);
    public sealed virtual string ReadLine();
    public string ReadToEnd();
    private string ReadUntilConditionInternal(bool haltOnNewLine);
    public sealed virtual void ResetColor();
    public sealed virtual void SetBufferSize(int width, int height);
    public sealed virtual void SetCursorPosition(int left, int top);
    public sealed virtual void SetWindowPosition(int left, int top);
    public sealed virtual void SetWindowSize(int width, int height);
    private void CreateKeyMap();
    private void InitKeys();
    private void AddStringMapping(TermInfoStrings s);
}
internal enum System.TermInfoNumbers : Enum {
    public int value__;
    public static TermInfoNumbers Columns;
    public static TermInfoNumbers InitTabs;
    public static TermInfoNumbers Lines;
    public static TermInfoNumbers LinesOfMemory;
    public static TermInfoNumbers MagicCookieGlitch;
    public static TermInfoNumbers PaddingBaudRate;
    public static TermInfoNumbers VirtualTerminal;
    public static TermInfoNumbers WidthStatusLine;
    public static TermInfoNumbers NumLabels;
    public static TermInfoNumbers LabelHeight;
    public static TermInfoNumbers LabelWidth;
    public static TermInfoNumbers MaxAttributes;
    public static TermInfoNumbers MaximumWindows;
    public static TermInfoNumbers MaxColors;
    public static TermInfoNumbers MaxPairs;
    public static TermInfoNumbers NoColorVideo;
    public static TermInfoNumbers BufferCapacity;
    public static TermInfoNumbers DotVertSpacing;
    public static TermInfoNumbers DotHorzSpacing;
    public static TermInfoNumbers MaxMicroAddress;
    public static TermInfoNumbers MaxMicroJump;
    public static TermInfoNumbers MicroColSize;
    public static TermInfoNumbers MicroLineSize;
    public static TermInfoNumbers NumberOfPins;
    public static TermInfoNumbers OutputResChar;
    public static TermInfoNumbers OutputResLine;
    public static TermInfoNumbers OutputResHorzInch;
    public static TermInfoNumbers OutputResVertInch;
    public static TermInfoNumbers PrintRate;
    public static TermInfoNumbers WideCharSize;
    public static TermInfoNumbers Buttons;
    public static TermInfoNumbers BitImageEntwining;
    public static TermInfoNumbers BitImageType;
    public static TermInfoNumbers Last;
}
internal class System.TermInfoReader : object {
    private int boolSize;
    private int numSize;
    private int strOffsets;
    private Byte[] buffer;
    private int booleansOffset;
    private int intOffset;
    public TermInfoReader(string term, string filename);
    public TermInfoReader(string term, Byte[] buffer);
    private void DetermineVersion(short magic);
    private void ReadHeader(Byte[] buffer, Int32& position);
    private void ReadNames(Byte[] buffer, Int32& position);
    public bool Get(TermInfoBooleans boolean);
    public int Get(TermInfoNumbers number);
    public string Get(TermInfoStrings tstr);
    public Byte[] GetStringBytes(TermInfoStrings tstr);
    private short GetInt16(Byte[] buffer, int offset);
    private string GetString(Byte[] buffer, int offset);
    private Byte[] GetStringBytes(Byte[] buffer, int offset);
    internal static string Escape(string s);
}
internal enum System.TermInfoStrings : Enum {
    public int value__;
    public static TermInfoStrings BackTab;
    public static TermInfoStrings Bell;
    public static TermInfoStrings CarriageReturn;
    public static TermInfoStrings ChangeScrollRegion;
    public static TermInfoStrings ClearAllTabs;
    public static TermInfoStrings ClearScreen;
    public static TermInfoStrings ClrEol;
    public static TermInfoStrings ClrEos;
    public static TermInfoStrings ColumnAddress;
    public static TermInfoStrings CommandCharacter;
    public static TermInfoStrings CursorAddress;
    public static TermInfoStrings CursorDown;
    public static TermInfoStrings CursorHome;
    public static TermInfoStrings CursorInvisible;
    public static TermInfoStrings CursorLeft;
    public static TermInfoStrings CursorMemAddress;
    public static TermInfoStrings CursorNormal;
    public static TermInfoStrings CursorRight;
    public static TermInfoStrings CursorToLl;
    public static TermInfoStrings CursorUp;
    public static TermInfoStrings CursorVisible;
    public static TermInfoStrings DeleteCharacter;
    public static TermInfoStrings DeleteLine;
    public static TermInfoStrings DisStatusLine;
    public static TermInfoStrings DownHalfLine;
    public static TermInfoStrings EnterAltCharsetMode;
    public static TermInfoStrings EnterBlinkMode;
    public static TermInfoStrings EnterBoldMode;
    public static TermInfoStrings EnterCaMode;
    public static TermInfoStrings EnterDeleteMode;
    public static TermInfoStrings EnterDimMode;
    public static TermInfoStrings EnterInsertMode;
    public static TermInfoStrings EnterSecureMode;
    public static TermInfoStrings EnterProtectedMode;
    public static TermInfoStrings EnterReverseMode;
    public static TermInfoStrings EnterStandoutMode;
    public static TermInfoStrings EnterUnderlineMode;
    public static TermInfoStrings EraseChars;
    public static TermInfoStrings ExitAltCharsetMode;
    public static TermInfoStrings ExitAttributeMode;
    public static TermInfoStrings ExitCaMode;
    public static TermInfoStrings ExitDeleteMode;
    public static TermInfoStrings ExitInsertMode;
    public static TermInfoStrings ExitStandoutMode;
    public static TermInfoStrings ExitUnderlineMode;
    public static TermInfoStrings FlashScreen;
    public static TermInfoStrings FormFeed;
    public static TermInfoStrings FromStatusLine;
    public static TermInfoStrings Init1string;
    public static TermInfoStrings Init2string;
    public static TermInfoStrings Init3string;
    public static TermInfoStrings InitFile;
    public static TermInfoStrings InsertCharacter;
    public static TermInfoStrings InsertLine;
    public static TermInfoStrings InsertPadding;
    public static TermInfoStrings KeyBackspace;
    public static TermInfoStrings KeyCatab;
    public static TermInfoStrings KeyClear;
    public static TermInfoStrings KeyCtab;
    public static TermInfoStrings KeyDc;
    public static TermInfoStrings KeyDl;
    public static TermInfoStrings KeyDown;
    public static TermInfoStrings KeyEic;
    public static TermInfoStrings KeyEol;
    public static TermInfoStrings KeyEos;
    public static TermInfoStrings KeyF0;
    public static TermInfoStrings KeyF1;
    public static TermInfoStrings KeyF10;
    public static TermInfoStrings KeyF2;
    public static TermInfoStrings KeyF3;
    public static TermInfoStrings KeyF4;
    public static TermInfoStrings KeyF5;
    public static TermInfoStrings KeyF6;
    public static TermInfoStrings KeyF7;
    public static TermInfoStrings KeyF8;
    public static TermInfoStrings KeyF9;
    public static TermInfoStrings KeyHome;
    public static TermInfoStrings KeyIc;
    public static TermInfoStrings KeyIl;
    public static TermInfoStrings KeyLeft;
    public static TermInfoStrings KeyLl;
    public static TermInfoStrings KeyNpage;
    public static TermInfoStrings KeyPpage;
    public static TermInfoStrings KeyRight;
    public static TermInfoStrings KeySf;
    public static TermInfoStrings KeySr;
    public static TermInfoStrings KeyStab;
    public static TermInfoStrings KeyUp;
    public static TermInfoStrings KeypadLocal;
    public static TermInfoStrings KeypadXmit;
    public static TermInfoStrings LabF0;
    public static TermInfoStrings LabF1;
    public static TermInfoStrings LabF10;
    public static TermInfoStrings LabF2;
    public static TermInfoStrings LabF3;
    public static TermInfoStrings LabF4;
    public static TermInfoStrings LabF5;
    public static TermInfoStrings LabF6;
    public static TermInfoStrings LabF7;
    public static TermInfoStrings LabF8;
    public static TermInfoStrings LabF9;
    public static TermInfoStrings MetaOff;
    public static TermInfoStrings MetaOn;
    public static TermInfoStrings Newline;
    public static TermInfoStrings PadChar;
    public static TermInfoStrings ParmDch;
    public static TermInfoStrings ParmDeleteLine;
    public static TermInfoStrings ParmDownCursor;
    public static TermInfoStrings ParmIch;
    public static TermInfoStrings ParmIndex;
    public static TermInfoStrings ParmInsertLine;
    public static TermInfoStrings ParmLeftCursor;
    public static TermInfoStrings ParmRightCursor;
    public static TermInfoStrings ParmRindex;
    public static TermInfoStrings ParmUpCursor;
    public static TermInfoStrings PkeyKey;
    public static TermInfoStrings PkeyLocal;
    public static TermInfoStrings PkeyXmit;
    public static TermInfoStrings PrintScreen;
    public static TermInfoStrings PrtrOff;
    public static TermInfoStrings PrtrOn;
    public static TermInfoStrings RepeatChar;
    public static TermInfoStrings Reset1string;
    public static TermInfoStrings Reset2string;
    public static TermInfoStrings Reset3string;
    public static TermInfoStrings ResetFile;
    public static TermInfoStrings RestoreCursor;
    public static TermInfoStrings RowAddress;
    public static TermInfoStrings SaveCursor;
    public static TermInfoStrings ScrollForward;
    public static TermInfoStrings ScrollReverse;
    public static TermInfoStrings SetAttributes;
    public static TermInfoStrings SetTab;
    public static TermInfoStrings SetWindow;
    public static TermInfoStrings Tab;
    public static TermInfoStrings ToStatusLine;
    public static TermInfoStrings UnderlineChar;
    public static TermInfoStrings UpHalfLine;
    public static TermInfoStrings InitProg;
    public static TermInfoStrings KeyA1;
    public static TermInfoStrings KeyA3;
    public static TermInfoStrings KeyB2;
    public static TermInfoStrings KeyC1;
    public static TermInfoStrings KeyC3;
    public static TermInfoStrings PrtrNon;
    public static TermInfoStrings CharPadding;
    public static TermInfoStrings AcsChars;
    public static TermInfoStrings PlabNorm;
    public static TermInfoStrings KeyBtab;
    public static TermInfoStrings EnterXonMode;
    public static TermInfoStrings ExitXonMode;
    public static TermInfoStrings EnterAmMode;
    public static TermInfoStrings ExitAmMode;
    public static TermInfoStrings XonCharacter;
    public static TermInfoStrings XoffCharacter;
    public static TermInfoStrings EnaAcs;
    public static TermInfoStrings LabelOn;
    public static TermInfoStrings LabelOff;
    public static TermInfoStrings KeyBeg;
    public static TermInfoStrings KeyCancel;
    public static TermInfoStrings KeyClose;
    public static TermInfoStrings KeyCommand;
    public static TermInfoStrings KeyCopy;
    public static TermInfoStrings KeyCreate;
    public static TermInfoStrings KeyEnd;
    public static TermInfoStrings KeyEnter;
    public static TermInfoStrings KeyExit;
    public static TermInfoStrings KeyFind;
    public static TermInfoStrings KeyHelp;
    public static TermInfoStrings KeyMark;
    public static TermInfoStrings KeyMessage;
    public static TermInfoStrings KeyMove;
    public static TermInfoStrings KeyNext;
    public static TermInfoStrings KeyOpen;
    public static TermInfoStrings KeyOptions;
    public static TermInfoStrings KeyPrevious;
    public static TermInfoStrings KeyPrint;
    public static TermInfoStrings KeyRedo;
    public static TermInfoStrings KeyReference;
    public static TermInfoStrings KeyRefresh;
    public static TermInfoStrings KeyReplace;
    public static TermInfoStrings KeyRestart;
    public static TermInfoStrings KeyResume;
    public static TermInfoStrings KeySave;
    public static TermInfoStrings KeySuspend;
    public static TermInfoStrings KeyUndo;
    public static TermInfoStrings KeySbeg;
    public static TermInfoStrings KeyScancel;
    public static TermInfoStrings KeyScommand;
    public static TermInfoStrings KeyScopy;
    public static TermInfoStrings KeyScreate;
    public static TermInfoStrings KeySdc;
    public static TermInfoStrings KeySdl;
    public static TermInfoStrings KeySelect;
    public static TermInfoStrings KeySend;
    public static TermInfoStrings KeySeol;
    public static TermInfoStrings KeySexit;
    public static TermInfoStrings KeySfind;
    public static TermInfoStrings KeyShelp;
    public static TermInfoStrings KeyShome;
    public static TermInfoStrings KeySic;
    public static TermInfoStrings KeySleft;
    public static TermInfoStrings KeySmessage;
    public static TermInfoStrings KeySmove;
    public static TermInfoStrings KeySnext;
    public static TermInfoStrings KeySoptions;
    public static TermInfoStrings KeySprevious;
    public static TermInfoStrings KeySprint;
    public static TermInfoStrings KeySredo;
    public static TermInfoStrings KeySreplace;
    public static TermInfoStrings KeySright;
    public static TermInfoStrings KeySrsume;
    public static TermInfoStrings KeySsave;
    public static TermInfoStrings KeySsuspend;
    public static TermInfoStrings KeySundo;
    public static TermInfoStrings ReqForInput;
    public static TermInfoStrings KeyF11;
    public static TermInfoStrings KeyF12;
    public static TermInfoStrings KeyF13;
    public static TermInfoStrings KeyF14;
    public static TermInfoStrings KeyF15;
    public static TermInfoStrings KeyF16;
    public static TermInfoStrings KeyF17;
    public static TermInfoStrings KeyF18;
    public static TermInfoStrings KeyF19;
    public static TermInfoStrings KeyF20;
    public static TermInfoStrings KeyF21;
    public static TermInfoStrings KeyF22;
    public static TermInfoStrings KeyF23;
    public static TermInfoStrings KeyF24;
    public static TermInfoStrings KeyF25;
    public static TermInfoStrings KeyF26;
    public static TermInfoStrings KeyF27;
    public static TermInfoStrings KeyF28;
    public static TermInfoStrings KeyF29;
    public static TermInfoStrings KeyF30;
    public static TermInfoStrings KeyF31;
    public static TermInfoStrings KeyF32;
    public static TermInfoStrings KeyF33;
    public static TermInfoStrings KeyF34;
    public static TermInfoStrings KeyF35;
    public static TermInfoStrings KeyF36;
    public static TermInfoStrings KeyF37;
    public static TermInfoStrings KeyF38;
    public static TermInfoStrings KeyF39;
    public static TermInfoStrings KeyF40;
    public static TermInfoStrings KeyF41;
    public static TermInfoStrings KeyF42;
    public static TermInfoStrings KeyF43;
    public static TermInfoStrings KeyF44;
    public static TermInfoStrings KeyF45;
    public static TermInfoStrings KeyF46;
    public static TermInfoStrings KeyF47;
    public static TermInfoStrings KeyF48;
    public static TermInfoStrings KeyF49;
    public static TermInfoStrings KeyF50;
    public static TermInfoStrings KeyF51;
    public static TermInfoStrings KeyF52;
    public static TermInfoStrings KeyF53;
    public static TermInfoStrings KeyF54;
    public static TermInfoStrings KeyF55;
    public static TermInfoStrings KeyF56;
    public static TermInfoStrings KeyF57;
    public static TermInfoStrings KeyF58;
    public static TermInfoStrings KeyF59;
    public static TermInfoStrings KeyF60;
    public static TermInfoStrings KeyF61;
    public static TermInfoStrings KeyF62;
    public static TermInfoStrings KeyF63;
    public static TermInfoStrings ClrBol;
    public static TermInfoStrings ClearMargins;
    public static TermInfoStrings SetLeftMargin;
    public static TermInfoStrings SetRightMargin;
    public static TermInfoStrings LabelFormat;
    public static TermInfoStrings SetClock;
    public static TermInfoStrings DisplayClock;
    public static TermInfoStrings RemoveClock;
    public static TermInfoStrings CreateWindow;
    public static TermInfoStrings GotoWindow;
    public static TermInfoStrings Hangup;
    public static TermInfoStrings DialPhone;
    public static TermInfoStrings QuickDial;
    public static TermInfoStrings Tone;
    public static TermInfoStrings Pulse;
    public static TermInfoStrings FlashHook;
    public static TermInfoStrings FixedPause;
    public static TermInfoStrings WaitTone;
    public static TermInfoStrings User0;
    public static TermInfoStrings User1;
    public static TermInfoStrings User2;
    public static TermInfoStrings User3;
    public static TermInfoStrings User4;
    public static TermInfoStrings User5;
    public static TermInfoStrings User6;
    public static TermInfoStrings User7;
    public static TermInfoStrings User8;
    public static TermInfoStrings User9;
    public static TermInfoStrings OrigPair;
    public static TermInfoStrings OrigColors;
    public static TermInfoStrings InitializeColor;
    public static TermInfoStrings InitializePair;
    public static TermInfoStrings SetColorPair;
    public static TermInfoStrings SetForeground;
    public static TermInfoStrings SetBackground;
    public static TermInfoStrings ChangeCharPitch;
    public static TermInfoStrings ChangeLinePitch;
    public static TermInfoStrings ChangeResHorz;
    public static TermInfoStrings ChangeResVert;
    public static TermInfoStrings DefineChar;
    public static TermInfoStrings EnterDoublewideMode;
    public static TermInfoStrings EnterDraftQuality;
    public static TermInfoStrings EnterItalicsMode;
    public static TermInfoStrings EnterLeftwardMode;
    public static TermInfoStrings EnterMicroMode;
    public static TermInfoStrings EnterNearLetterQuality;
    public static TermInfoStrings EnterNormalQuality;
    public static TermInfoStrings EnterShadowMode;
    public static TermInfoStrings EnterSubscriptMode;
    public static TermInfoStrings EnterSuperscriptMode;
    public static TermInfoStrings EnterUpwardMode;
    public static TermInfoStrings ExitDoublewideMode;
    public static TermInfoStrings ExitItalicsMode;
    public static TermInfoStrings ExitLeftwardMode;
    public static TermInfoStrings ExitMicroMode;
    public static TermInfoStrings ExitShadowMode;
    public static TermInfoStrings ExitSubscriptMode;
    public static TermInfoStrings ExitSuperscriptMode;
    public static TermInfoStrings ExitUpwardMode;
    public static TermInfoStrings MicroColumnAddress;
    public static TermInfoStrings MicroDown;
    public static TermInfoStrings MicroLeft;
    public static TermInfoStrings MicroRight;
    public static TermInfoStrings MicroRowAddress;
    public static TermInfoStrings MicroUp;
    public static TermInfoStrings OrderOfPins;
    public static TermInfoStrings ParmDownMicro;
    public static TermInfoStrings ParmLeftMicro;
    public static TermInfoStrings ParmRightMicro;
    public static TermInfoStrings ParmUpMicro;
    public static TermInfoStrings SelectCharSet;
    public static TermInfoStrings SetBottomMargin;
    public static TermInfoStrings SetBottomMarginParm;
    public static TermInfoStrings SetLeftMarginParm;
    public static TermInfoStrings SetRightMarginParm;
    public static TermInfoStrings SetTopMargin;
    public static TermInfoStrings SetTopMarginParm;
    public static TermInfoStrings StartBitImage;
    public static TermInfoStrings StartCharSetDef;
    public static TermInfoStrings StopBitImage;
    public static TermInfoStrings StopCharSetDef;
    public static TermInfoStrings SubscriptCharacters;
    public static TermInfoStrings SuperscriptCharacters;
    public static TermInfoStrings TheseCauseCr;
    public static TermInfoStrings ZeroMotion;
    public static TermInfoStrings CharSetNames;
    public static TermInfoStrings KeyMouse;
    public static TermInfoStrings MouseInfo;
    public static TermInfoStrings ReqMousePos;
    public static TermInfoStrings GetMouse;
    public static TermInfoStrings SetAForeground;
    public static TermInfoStrings SetABackground;
    public static TermInfoStrings PkeyPlab;
    public static TermInfoStrings DeviceType;
    public static TermInfoStrings CodeSetInit;
    public static TermInfoStrings Set0DesSeq;
    public static TermInfoStrings Set1DesSeq;
    public static TermInfoStrings Set2DesSeq;
    public static TermInfoStrings Set3DesSeq;
    public static TermInfoStrings SetLrMargin;
    public static TermInfoStrings SetTbMargin;
    public static TermInfoStrings BitImageRepeat;
    public static TermInfoStrings BitImageNewline;
    public static TermInfoStrings BitImageCarriageReturn;
    public static TermInfoStrings ColorNames;
    public static TermInfoStrings DefineBitImageRegion;
    public static TermInfoStrings EndBitImageRegion;
    public static TermInfoStrings SetColorBand;
    public static TermInfoStrings SetPageLength;
    public static TermInfoStrings DisplayPcChar;
    public static TermInfoStrings EnterPcCharsetMode;
    public static TermInfoStrings ExitPcCharsetMode;
    public static TermInfoStrings EnterScancodeMode;
    public static TermInfoStrings ExitScancodeMode;
    public static TermInfoStrings PcTermOptions;
    public static TermInfoStrings ScancodeEscape;
    public static TermInfoStrings AltScancodeEsc;
    public static TermInfoStrings EnterHorizontalHlMode;
    public static TermInfoStrings EnterLeftHlMode;
    public static TermInfoStrings EnterLowHlMode;
    public static TermInfoStrings EnterRightHlMode;
    public static TermInfoStrings EnterTopHlMode;
    public static TermInfoStrings EnterVerticalHlMode;
    public static TermInfoStrings SetAAttributes;
    public static TermInfoStrings SetPglenInch;
    public static TermInfoStrings Last;
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback _fallback;
    internal DecoderFallbackBuffer _fallbackBuffer;
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    private void Throw(Byte[] bytesUnknown, int index);
}
public abstract class System.Text.DecoderFallback : object {
    private static DecoderFallback s_replacementFallback;
    private static DecoderFallback s_exceptionFallback;
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    public int Remaining { get; }
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] _bytesUnknown;
    private int _index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    private DecoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _bytesUsed;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal DecoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    internal DecoderReplacementFallback(SerializationInfo info, StreamingContext context);
    public DecoderReplacementFallback(string replacement);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback _fallback;
    internal EncoderFallbackBuffer _fallbackBuffer;
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.EncoderFallback : object {
    private static EncoderFallback s_replacementFallback;
    private static EncoderFallback s_exceptionFallback;
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    private static int iMaxRecursion;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal char InternalGetNextChar();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    internal void ThrowLastCharRecursive(int charRecursive);
}
public class System.Text.EncoderFallbackException : ArgumentException {
    private char _charUnknown;
    private char _charUnknownHigh;
    private char _charUnknownLow;
    private int _index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    private EncoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char _charLeftOver;
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal EncoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    internal EncoderReplacementFallback(SerializationInfo info, StreamingContext context);
    public EncoderReplacementFallback(string replacement);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
[ComVisibleAttribute("True")]
public abstract class System.Text.Encoding : object {
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) defaultEncoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) unicodeEncoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianUnicode;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf7Encoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8Encoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf32Encoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) asciiEncoding;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) latin1Encoding;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) encodings;
    private static int MIMECONTF_MAILNEWS;
    private static int MIMECONTF_BROWSER;
    private static int MIMECONTF_SAVABLE_MAILNEWS;
    private static int MIMECONTF_SAVABLE_BROWSER;
    private static int CodePageDefault;
    private static int CodePageNoOEM;
    private static int CodePageNoMac;
    private static int CodePageNoThread;
    private static int CodePageNoSymbol;
    private static int CodePageUnicode;
    private static int CodePageBigEndian;
    private static int CodePageWindows1252;
    private static int CodePageMacGB2312;
    private static int CodePageGB2312;
    private static int CodePageMacKorean;
    private static int CodePageDLLKorean;
    private static int ISO2022JP;
    private static int ISO2022JPESC;
    private static int ISO2022JPSISO;
    private static int ISOKorean;
    private static int ISOSimplifiedCN;
    private static int EUCJP;
    private static int ChineseHZ;
    private static int DuplicateEUCCN;
    private static int EUCCN;
    private static int EUCKR;
    internal static int CodePageASCII;
    internal static int ISO_8859_1;
    private static int ISCIIAssemese;
    private static int ISCIIBengali;
    private static int ISCIIDevanagari;
    private static int ISCIIGujarathi;
    private static int ISCIIKannada;
    private static int ISCIIMalayalam;
    private static int ISCIIOriya;
    private static int ISCIIPanjabi;
    private static int ISCIITamil;
    private static int ISCIITelugu;
    private static int GB18030;
    private static int ISO_8859_8I;
    private static int ISO_8859_8_Visual;
    private static int ENC50229;
    private static int CodePageUTF7;
    private static int CodePageUTF8;
    private static int CodePageUTF32;
    private static int CodePageUTF32BE;
    internal int m_codePage;
    internal CodePageDataItem dataItem;
    internal bool m_deserializedFromEverett;
    [OptionalFieldAttribute]
private bool m_isReadOnly;
    [OptionalFieldAttribute]
internal EncoderFallback encoderFallback;
    [OptionalFieldAttribute]
internal DecoderFallback decoderFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    [ComVisibleAttribute("False")]
public bool IsSingleByte { get; }
    [ComVisibleAttribute("False")]
public EncoderFallback EncoderFallback { get; public set; }
    [ComVisibleAttribute("False")]
public DecoderFallback DecoderFallback { get; public set; }
    [ComVisibleAttribute("False")]
public bool IsReadOnly { get; }
    public static Encoding ASCII { get; }
    private static Encoding Latin1 { get; }
    public int CodePage { get; }
    public static Encoding Default { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal virtual void SetDefaultFallbacks();
    internal void OnDeserializing();
    internal void OnDeserialized();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    internal void DeserializeEncoding(SerializationInfo info, StreamingContext context);
    internal void SerializeEncoding(SerializationInfo info, StreamingContext context);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    private static object get_InternalSyncObject();
    [SecurityCriticalAttribute]
public static void RegisterProvider(EncodingProvider provider);
    [SecuritySafeCriticalAttribute]
public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    [ComVisibleAttribute("False")]
public virtual object Clone();
    public bool get_IsReadOnly();
    public static Encoding get_ASCII();
    private static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string str, int index, int count);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [SecurityCriticalAttribute]
internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [SecurityCriticalAttribute]
internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [ComVisibleAttribute("False")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [SecurityCriticalAttribute]
internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [SecurityCriticalAttribute]
internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public string GetString(ReadOnlySpan`1<byte> bytes);
    public virtual int get_CodePage();
    [ComVisibleAttribute("False")]
public bool IsAlwaysNormalized();
    [ComVisibleAttribute("False")]
public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    [SecurityCriticalAttribute]
private static Encoding CreateDefaultEncoding();
    internal void setReadOnly(bool value);
    [SecuritySafeCriticalAttribute]
public static Encoding get_Default();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    internal void ThrowBytesOverflow();
    [SecurityCriticalAttribute]
internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    internal void ThrowCharsOverflow();
    [SecurityCriticalAttribute]
internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public Byte[] GetBytes(string s, int index, int count);
}
internal static class System.Text.EncodingHelper : object {
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingWithoutMarkers;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingUnsafe;
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianUTF32Encoding;
    private static object lockobj;
    private static Assembly i18nAssembly;
    private static bool i18nDisabled;
    internal static Encoding UTF8Unmarked { get; }
    internal static Encoding UTF8UnmarkedUnsafe { get; }
    internal static Encoding BigEndianUTF32 { get; }
    private static EncodingHelper();
    internal static Encoding get_UTF8Unmarked();
    internal static Encoding get_UTF8UnmarkedUnsafe();
    internal static Encoding get_BigEndianUTF32();
    internal static string InternalCodePage(Int32& code_page);
    internal static Encoding GetDefaultEncoding();
    internal static object InvokeI18N(string name, Object[] args);
}
public class System.Text.EncodingInfo : object {
    private int iCodePage;
    private string strEncodingName;
    private string strDisplayName;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_Name();
    public string get_DisplayName();
    public Encoding GetEncoding();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.EncodingProvider : object {
    private static object s_InternalSyncObject;
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static EncodingProvider();
    public abstract virtual Encoding GetEncoding(string name);
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    internal char _cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    private char _cBestFit;
    private int _iCount;
    private int _iSize;
    private InternalDecoderBestFitFallback _oFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    private char TryBestFit(Byte[] bytesCheck);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    private char _cBestFit;
    private InternalEncoderBestFitFallback _oFallback;
    private int _iCount;
    private int _iSize;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private char TryBestFit(char cUnknown);
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    internal static Latin1Encoding s_default;
    private static Char[] arrayCharBestFit;
    public bool IsSingleByte { get; }
    internal Latin1Encoding(SerializationInfo info, StreamingContext context);
    private static Latin1Encoding();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
internal class System.Text.Normalization : object {
    public static int NoNfd;
    public static int NoNfkd;
    public static int NoNfc;
    public static int MaybeNfc;
    public static int NoNfkc;
    public static int MaybeNfkc;
    public static int FullCompositionExclusion;
    public static int IsUnsafe;
    private static int HangulSBase;
    private static int HangulLBase;
    private static int HangulVBase;
    private static int HangulTBase;
    private static int HangulLCount;
    private static int HangulVCount;
    private static int HangulTCount;
    private static int HangulNCount;
    private static int HangulSCount;
    private static Byte* props;
    private static Int32* mappedChars;
    private static Int16* charMapIndex;
    private static Int16* helperIndex;
    private static UInt16* mapIdxToComposite;
    private static Byte* combiningClass;
    private static object forLock;
    public static bool isReady;
    public static bool IsReady { get; }
    private static Normalization();
    private static UInt32 PropValue(int cp);
    private static int CharMapIdx(int cp);
    private static byte GetCombiningClass(int c);
    private static int GetPrimaryCompositeFromMapIndex(int src);
    private static int GetPrimaryCompositeHelperIndex(int cp);
    private static string Compose(string source, int checkType);
    private static StringBuilder Combine(string source, int start, int checkType);
    private static void Combine(StringBuilder sb, int i, int checkType);
    private static int CombineHangul(StringBuilder sb, string s, int current);
    private static int Fetch(StringBuilder sb, string s, int i);
    private static int TryComposeWithPreviousStarter(StringBuilder sb, string s, int current);
    private static int TryCompose(int i, int starter, int candidate);
    private static string Decompose(string source, int checkType);
    private static void Decompose(string source, StringBuilder& sb, int checkType);
    private static void ReorderCanonical(string src, StringBuilder& sb, int start);
    private static void DecomposeChar(StringBuilder& sb, Int32[]& buf, string s, int i, int checkType, Int32& start);
    public static NormalizationCheck QuickCheck(char c, int type);
    private static int GetCanonicalHangul(int s, Int32[] buf, int bufIdx);
    private static int GetCanonical(int c, Int32[] buf, int bufIdx, int checkType);
    public static bool IsNormalized(string source, NormalizationForm normalizationForm);
    public static bool IsNormalized(string source, int type);
    public static string Normalize(string source, NormalizationForm normalizationForm);
    public static string Normalize(string source, int type);
    public static bool get_IsReady();
    private static void load_normalization_resource(IntPtr& props, IntPtr& mappedChars, IntPtr& charMapIndex, IntPtr& helperIndex, IntPtr& mapIdxToComposite, IntPtr& combiningClass);
}
internal enum System.Text.NormalizationCheck : Enum {
    public int value__;
    public static NormalizationCheck Yes;
    public static NormalizationCheck No;
    public static NormalizationCheck Maybe;
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    internal static int DefaultCapacity;
    private static string CapacityField;
    private static string MaxCapacityField;
    private static string StringValueField;
    private static string ThreadIDField;
    internal static int MaxChunkSize;
    private static int IndexLimit;
    private static int WidthLimit;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    private Span`1<char> RemainingCurrentChunk { get; }
    public StringBuilder(int capacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [ConditionalAttribute("DEBUG")]
private void AssertInvariants();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    private void AppendHelper(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    private StringBuilder AppendCore(StringBuilder value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    private StringBuilder AppendSpanFormattable(T value);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(ReadOnlySpan`1<char> value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    private static void FormatError();
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public StringBuilder Replace(string oldValue, string newValue);
    public bool Equals(StringBuilder sb);
    public bool Equals(ReadOnlySpan`1<char> span);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Insert(int index, Char* value, int valueCount);
    private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count);
    private static void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Span`1<char> destination, int destinationIndex, int count);
    private StringBuilder FindChunkForIndex(int index);
    private StringBuilder FindChunkForByte(int byteIndex);
    private Span`1<char> get_RemainingCurrentChunk();
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doNotMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
}
internal static class System.Text.StringBuilderCache : object {
    private static int MaxBuilderSize;
    private static int DefaultCapacity;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    internal bool isThrowException;
    internal bool bigEndian;
    internal bool byteOrderMark;
    public static int CharSize;
    private static ulong highLowPatternMask;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private UInt32 GetSurrogate(char cHigh, char cLow);
    private char GetHighSurrogate(UInt32 iChar);
    private char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF7Encoding : Encoding {
    private static string base64Chars;
    private static string directChars;
    private static string optionalChars;
    internal static UTF7Encoding s_default;
    private Byte[] _base64Bytes;
    private SByte[] _base64Values;
    private Boolean[] _directEncode;
    private bool _allowOptionals;
    private static int UTF7_CODEPAGE;
    public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    private void MakeTables();
    internal virtual void SetDefaultFallbacks();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    private static int UTF8_CODEPAGE;
    internal static UTF8EncodingSealed s_default;
    internal static Byte[] s_preamble;
    internal bool _emitUTF8Identifier;
    private bool _isThrowException;
    private static int FinalByte;
    private static int SupplimentarySeq;
    private static int ThreeByteSeq;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
    private static bool InRange(int ch, int start, int end);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private bool FallbackInvalidByteSequence(Byte*& pSrc, int ch, DecoderFallbackBuffer fallback, Char*& pTarget);
    private int FallbackInvalidByteSequence(Byte* pSrc, int ch, DecoderFallbackBuffer fallback);
    private Byte[] GetBytesUnknown(Byte*& pSrc, int ch);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int requiredAdditionalCapacity);
    public void Dispose();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.ValueUtf8Converter : ValueType {
    private Byte[] _arrayToReturnToPool;
    private Span`1<byte> _bytes;
    public ValueUtf8Converter(Span`1<byte> initialBuffer);
    public Span`1<byte> ConvertAndTerminateString(ReadOnlySpan`1<char> value);
    public void Dispose();
}
internal static class System.Threading._ThreadPoolWaitCallback : object {
    [SecurityCriticalAttribute]
internal static bool PerformWaitCallback();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    [SecurityCriticalAttribute]
private static ContextCallback _ccbt;
    [SecurityCriticalAttribute]
private static ContextCallback _ccbf;
    [SecuritySafeCriticalAttribute]
private static _ThreadPoolWaitOrTimerCallback();
    [SecurityCriticalAttribute]
internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack, StackCrawlMark& stackMark);
    [SecurityCriticalAttribute]
private static void WaitOrTimerCallback_Context_t(object state);
    [SecurityCriticalAttribute]
private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    [SecurityCriticalAttribute]
internal static void PerformWaitOrTimerCallback(object state, bool timedOut);
}
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private bool useEC;
    private ExecutionContext _ec;
    private Thread _thread;
    [SecurityCriticalAttribute]
internal void Setup();
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
public void Undo();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
[IsReadOnlyAttribute]
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; }
    public T CurrentValue { get; }
    public bool ThreadContextChanged { get; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
internal class System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
    internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> _currArrayFragment;
    internal int _currArrayIndex;
    public CancellationCallbackCoreWorkArguments(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
}
internal class System.Threading.CancellationCallbackInfo : object {
    internal Action`1<object> Callback;
    internal object StateForCallback;
    internal ExecutionContext TargetExecutionContext;
    internal CancellationTokenSource CancellationTokenSource;
    private static ContextCallback s_executionContextCallback;
    internal CancellationCallbackInfo(Action`1<object> callback, object stateForCallback, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
    internal void ExecuteCallback();
    private static void ExecutionContextCallback(object obj);
}
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
[IsReadOnlyAttribute]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource _source;
    private static Action`1<object> s_actionToActionObjShunt;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    private void ThrowOperationCanceledException();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private CancellationCallbackInfo m_callbackInfo;
    private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;
    public CancellationToken Token { get; }
    internal CancellationTokenRegistration(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
    public CancellationToken get_Token();
    public bool Unregister();
    public sealed virtual void Dispose();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
    public sealed virtual ValueTask DisposeAsync();
}
public class System.Threading.CancellationTokenSource : object {
    internal static CancellationTokenSource s_canceledSource;
    internal static CancellationTokenSource s_neverCanceledSource;
    private static int s_nLists;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _kernelEvent;
    private SparselyPopulatedArray`1[] modreq(System.Runtime.CompilerServices.IsVolatile) _registeredCallbacksLists;
    private static int CannotBeCanceled;
    private static int NotCanceledState;
    private static int NotifyingState;
    private static int NotifyingCompleteState;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadIDExecutingCallbacks;
    private bool _disposed;
    private CancellationCallbackInfo modreq(System.Runtime.CompilerServices.IsVolatile) _executingCallback;
    private Timer modreq(System.Runtime.CompilerServices.IsVolatile) _timer;
    private static TimerCallback s_timerCallback;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal bool IsDisposed { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal bool CanBeCanceled { get; }
    internal WaitHandle WaitHandle { get; }
    internal CancellationCallbackInfo ExecutingCallback { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal bool get_IsDisposed();
    internal int get_ThreadIDExecutingCallbacks();
    internal void set_ThreadIDExecutingCallbacks(int value);
    public CancellationToken get_Token();
    internal bool get_CanBeCanceled();
    internal WaitHandle get_WaitHandle();
    internal CancellationCallbackInfo get_ExecutingCallback();
    private void InitializeWithTimer(int millisecondsDelay);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    private static void TimerCallbackLogic(object obj);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ThrowIfDisposed();
    private static void ThrowObjectDisposedException();
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private void CancellationCallbackCoreWork_OnSyncContext(object obj);
    private void CancellationCallbackCoreWork(CancellationCallbackCoreWorkArguments args);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    internal static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
}
public class System.Threading.CompressedStack : object {
    private ArrayList _list;
    internal IList List { get; }
    internal CompressedStack(int length);
    internal CompressedStack(CompressedStack cs);
    [ComVisibleAttribute("False")]
public CompressedStack CreateCopy();
    public static CompressedStack Capture();
    [SecurityCriticalAttribute]
public static CompressedStack GetCompressedStack();
    [MonoTODOAttribute("incomplete")]
[SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
    internal bool Equals(CompressedStack cs);
    internal bool IsEmpty();
    internal IList get_List();
}
[ComVisibleAttribute("True")]
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.ContextCallback`1 : MulticastDelegate {
    public ContextCallback`1(object object, IntPtr method);
    public virtual void Invoke(TState& state);
    public virtual IAsyncResult BeginInvoke(TState& state, AsyncCallback callback, object object);
    public virtual void EndInvoke(TState& state, IAsyncResult result);
}
[DebuggerDisplayAttribute("Initial Count={InitialCount}, Current Count={CurrentCount}")]
public class System.Threading.CountdownEvent : object {
    private int _initialCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _currentCount;
    private ManualResetEventSlim _event;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    public int CurrentCount { get; }
    public int InitialCount { get; }
    public bool IsSet { get; }
    public WaitHandle WaitHandle { get; }
    public CountdownEvent(int initialCount);
    public int get_CurrentCount();
    public int get_InitialCount();
    public bool get_IsSet();
    public WaitHandle get_WaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool Signal();
    public bool Signal(int signalCount);
    public void AddCount();
    public bool TryAddCount();
    public void AddCount(int signalCount);
    public bool TryAddCount(int signalCount);
    public void Reset();
    public void Reset(int count);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    private static DeferredDisposableLifetime`1();
    public bool AddRef(T obj);
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[ComVisibleAttribute("True")]
public class System.Threading.EventWaitHandle : WaitHandle {
    [SecuritySafeCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    [SecurityCriticalAttribute]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity);
    [SecurityCriticalAttribute]
private EventWaitHandle(SafeWaitHandle handle);
    [SecurityCriticalAttribute]
public static EventWaitHandle OpenExisting(string name);
    [SecurityCriticalAttribute]
public static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, EventWaitHandle& result);
    [SecurityCriticalAttribute]
public static bool TryOpenExisting(string name, EventWaitHandleRights rights, EventWaitHandle& result);
    [SecurityCriticalAttribute]
private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandleRights rights, EventWaitHandle& result);
    [SecuritySafeCriticalAttribute]
public bool Reset();
    [SecuritySafeCriticalAttribute]
public bool Set();
    [SecuritySafeCriticalAttribute]
public EventWaitHandleSecurity GetAccessControl();
    [SecuritySafeCriticalAttribute]
public void SetAccessControl(EventWaitHandleSecurity eventSecurity);
}
public class System.Threading.ExecutionContext : object {
    private SynchronizationContext _syncContext;
    private SynchronizationContext _syncContextNoFlow;
    [SecurityCriticalAttribute]
private LogicalCallContext _logicalCallContext;
    private IllogicalCallContext _illogicalCallContext;
    private Flags _flags;
    private Dictionary`2<IAsyncLocal, object> _localValues;
    private List`1<IAsyncLocal> _localChangeNotifications;
    private static ExecutionContext s_dummyDefaultEC;
    internal static ExecutionContext Default;
    internal bool isNewCapture { get; internal set; }
    internal bool isFlowSuppressed { get; internal set; }
    internal static ExecutionContext PreAllocatedDefault { get; }
    internal bool IsPreAllocatedDefault { get; }
    internal LogicalCallContext LogicalCallContext { get; internal set; }
    internal IllogicalCallContext IllogicalCallContext { get; internal set; }
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    internal SynchronizationContext SynchronizationContextNoFlow { get; internal set; }
    [ReliabilityContractAttribute("3", "2")]
internal ExecutionContext(bool isPreAllocatedDefault);
    [SecurityCriticalAttribute]
private ExecutionContext(SerializationInfo info, StreamingContext context);
    private static ExecutionContext();
    internal bool get_isNewCapture();
    internal void set_isNewCapture(bool value);
    internal bool get_isFlowSuppressed();
    internal void set_isFlowSuppressed(bool value);
    [SecuritySafeCriticalAttribute]
internal static ExecutionContext get_PreAllocatedDefault();
    internal bool get_IsPreAllocatedDefault();
    [SecurityCriticalAttribute]
internal static object GetLocalValue(IAsyncLocal local);
    [SecurityCriticalAttribute]
internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal static void OnAsyncLocalContextChanged(ExecutionContext previous, ExecutionContext current);
    [SecurityCriticalAttribute]
internal LogicalCallContext get_LogicalCallContext();
    [SecurityCriticalAttribute]
internal void set_LogicalCallContext(LogicalCallContext value);
    internal IllogicalCallContext get_IllogicalCallContext();
    internal void set_IllogicalCallContext(IllogicalCallContext value);
    [ReliabilityContractAttribute("3", "2")]
internal SynchronizationContext get_SynchronizationContext();
    [ReliabilityContractAttribute("3", "2")]
internal void set_SynchronizationContext(SynchronizationContext value);
    [ReliabilityContractAttribute("3", "2")]
internal SynchronizationContext get_SynchronizationContextNoFlow();
    [ReliabilityContractAttribute("3", "2")]
internal void set_SynchronizationContextNoFlow(SynchronizationContext value);
    public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    [SecurityCriticalAttribute]
[FriendAccessAllowedAttribute]
internal static void Run(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback`1<TState> callback, TState& state);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static void RunInternal(ExecutionContext executionContext, ContextCallback`1<TState> callback, TState& state, bool preserveSyncCtx);
    [SecurityCriticalAttribute]
internal static void EstablishCopyOnWriteScope(ExecutionContextSwitcher& ecsw);
    [SecurityCriticalAttribute]
private static void EstablishCopyOnWriteScope(Thread currentThread, bool knownNullWindowsIdentity, ExecutionContextSwitcher& ecsw);
    [SecurityCriticalAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
internal static ExecutionContextSwitcher SetExecutionContext(ExecutionContext executionContext, bool preserveSyncCtx);
    [SecuritySafeCriticalAttribute]
public ExecutionContext CreateCopy();
    [SecuritySafeCriticalAttribute]
internal ExecutionContext CreateMutableCopy();
    [SecurityCriticalAttribute]
public static AsyncFlowControl SuppressFlow();
    [SecuritySafeCriticalAttribute]
public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    [SecuritySafeCriticalAttribute]
public static ExecutionContext Capture();
    [FriendAccessAllowedAttribute]
[SecuritySafeCriticalAttribute]
internal static ExecutionContext FastCapture();
    [SecurityCriticalAttribute]
internal static ExecutionContext Capture(StackCrawlMark& stackMark, CaptureOptions options);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
internal bool IsDefaultFTContext(bool ignoreSyncCtx);
}
internal class System.Threading.ExecutionContextSwitcher : ValueType {
    internal Reader outerEC;
    internal bool outerECBelongsToScope;
    internal object hecsw;
    internal Thread thread;
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
[HandleProcessCorruptedStateExceptionsAttribute]
internal bool UndoNoThrow();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
internal void Undo();
}
[MonoTODOAttribute("Useless until the runtime supports it")]
public class System.Threading.HostExecutionContext : object {
    private object _state;
    protected internal object State { get; protected internal set; }
    public HostExecutionContext(object state);
    public virtual HostExecutionContext CreateCopy();
    protected internal object get_State();
    protected internal void set_State(object value);
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
}
public class System.Threading.HostExecutionContextManager : object {
    [MonoTODOAttribute]
public virtual HostExecutionContext Capture();
    [ReliabilityContractAttribute("3", "1")]
[MonoTODOAttribute]
public virtual void Revert(object previousState);
    [MonoTODOAttribute]
public virtual object SetHostExecutionContext(HostExecutionContext hostExecutionContext);
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
public static class System.Threading.Interlocked : object {
    [ReliabilityContractAttribute("3", "2")]
public static int CompareExchange(Int32& location1, int value, int comparand);
    [ReliabilityContractAttribute("3", "2")]
internal static int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded);
    [ReliabilityContractAttribute("3", "2")]
private static void CompareExchange(Object& location1, Object& value, Object& comparand, Object& result);
    [ReliabilityContractAttribute("3", "2")]
public static object CompareExchange(Object& location1, object value, object comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    [ReliabilityContractAttribute("3", "2")]
public static int Decrement(Int32& location);
    public static long Decrement(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
public static int Increment(Int32& location);
    [ReliabilityContractAttribute("3", "2")]
public static long Increment(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
public static int Exchange(Int32& location1, int value);
    [ReliabilityContractAttribute("3", "2")]
private static void Exchange(Object& location1, Object& value, Object& result);
    [ReliabilityContractAttribute("3", "2")]
public static object Exchange(Object& location1, object value);
    public static float Exchange(Single& location1, float value);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    [ReliabilityContractAttribute("3", "2")]
public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    public static double CompareExchange(Double& location1, double value, double comparand);
    [ComVisibleAttribute("False")]
[ReliabilityContractAttribute("3", "2")]
[IntrinsicAttribute]
public static T CompareExchange(T& location1, T value, T comparand);
    public static long Exchange(Int64& location1, long value);
    [ReliabilityContractAttribute("3", "2")]
public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    public static double Exchange(Double& location1, double value);
    [ComVisibleAttribute("False")]
[IntrinsicAttribute]
[ReliabilityContractAttribute("3", "2")]
public static T Exchange(T& location1, T value);
    public static long Read(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
public static int Add(Int32& location1, int value);
    [ReliabilityContractAttribute("3", "2")]
public static long Add(Int64& location1, long value);
    public static void MemoryBarrier();
    public static void MemoryBarrierProcessWide();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void SpeculationBarrier();
}
internal class System.Threading.InternalCrossContextDelegate : MulticastDelegate {
    public InternalCrossContextDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Threading.InternalThread : CriticalFinalizerObject {
    private int lock_thread_id;
    private IntPtr handle;
    private IntPtr native_handle;
    private IntPtr name_chars;
    private int name_free;
    private int name_length;
    private ThreadState state;
    private object abort_exc;
    private int abort_state_handle;
    internal long thread_id;
    private IntPtr debugger_thread;
    private UIntPtr static_data;
    private IntPtr runtime_thread_info;
    private object current_appcontext;
    private object root_domain_thread;
    internal Byte[] _serialized_principal;
    internal int _serialized_principal_version;
    private IntPtr appdomain_refs;
    private int interruption_requested;
    private IntPtr longlived;
    internal bool threadpool_thread;
    private bool thread_interrupt_requested;
    internal int stack_size;
    internal byte apartment_state;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) critical_region_level;
    internal int managed_id;
    private int small_id;
    private IntPtr manage_callback;
    private IntPtr flags;
    private IntPtr thread_pinning_ref;
    private IntPtr abort_protected_block_count;
    private int priority;
    private IntPtr owned_mutex;
    private IntPtr suspended_event;
    private int self_suspended;
    private IntPtr thread_state;
    private IntPtr netcore0;
    private IntPtr netcore1;
    private IntPtr netcore2;
    private IntPtr last;
    private void Thread_free_internal();
    [ReliabilityContractAttribute("3", "2")]
protected virtual override void Finalize();
}
[ComVisibleAttribute("True")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Threading.IThreadPoolWorkItem {
    [SecurityCriticalAttribute]
public abstract virtual void ExecuteWorkItem();
    [SecurityCriticalAttribute]
public abstract virtual void MarkAborted(ThreadAbortException tae);
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    private static T EnsureInitializedCore(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
public class System.Threading.Lock : object {
    private object _lock;
    public void Acquire();
    public void Release();
}
[ComVisibleAttribute("True")]
public class System.Threading.LockCookie : ValueType {
    internal int ThreadId;
    internal int ReaderLocks;
    internal int WriterLocks;
    internal LockCookie(int thread_id);
    internal LockCookie(int thread_id, int reader_locks, int writer_locks);
    public virtual int GetHashCode();
    public bool Equals(LockCookie obj);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LockCookie a, LockCookie b);
    public static bool op_Inequality(LockCookie a, LockCookie b);
}
[ReflectionBlockedAttribute]
public class System.Threading.LockHolder : ValueType {
    private Lock _lock;
    public static LockHolder Hold(Lock l);
    public sealed virtual void Dispose();
}
internal class System.Threading.LockQueue : object {
    private ReaderWriterLock rwlock;
    private int lockCount;
    public bool IsEmpty { get; }
    public LockQueue(ReaderWriterLock rwlock);
    public bool Wait(int timeout);
    public bool get_IsEmpty();
    public void Pulse();
}
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private static int DEFAULT_SPIN_SP;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static int SignalledState_BitMask;
    private static int SignalledState_ShiftCount;
    private static int Dispose_BitMask;
    private static int SpinCountState_BitMask;
    private static int SpinCountState_ShiftCount;
    private static int SpinCountState_MaxValue;
    private static int NumWaitersState_BitMask;
    private static int NumWaitersState_ShiftCount;
    private static int NumWaitersState_MaxValue;
    private static Action`1<object> s_cancellationTokenCallback;
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
public static class System.Threading.Monitor : object {
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    private static void ThrowLockTakenException();
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
public static void Exit(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    private static int MillisecondsTimeoutFromTimeSpan(TimeSpan timeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    [SecuritySafeCriticalAttribute]
public static bool IsEntered(object obj);
    [SecuritySafeCriticalAttribute]
public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    [SecuritySafeCriticalAttribute]
public static void Pulse(object obj);
    [SecuritySafeCriticalAttribute]
public static void PulseAll(object obj);
    private static bool Monitor_test_synchronised(object obj);
    private static void Monitor_pulse(object obj);
    private static void ObjPulse(object obj);
    private static void Monitor_pulse_all(object obj);
    private static void ObjPulseAll(object obj);
    private static bool Monitor_wait(object obj, int ms);
    private static bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
    private static void try_enter_with_atomic_var(object obj, int millisecondsTimeout, Boolean& lockTaken);
    private static void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken);
    private static void ReliableEnter(object obj, Boolean& lockTaken);
    private static bool Monitor_test_owner(object obj);
    private static bool IsEnteredNative(object obj);
}
[ComVisibleAttribute("True")]
public class System.Threading.Mutex : WaitHandle {
    private Mutex(IntPtr handle);
    [ReliabilityContractAttribute("3", "1")]
public Mutex(bool initiallyOwned);
    [ReliabilityContractAttribute("3", "1")]
public Mutex(bool initiallyOwned, string name);
    [ReliabilityContractAttribute("3", "1")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    [ReliabilityContractAttribute("3", "1")]
[MonoTODOAttribute("Use MutexSecurity in CreateMutex_internal")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew, MutexSecurity mutexSecurity);
    private static IntPtr CreateMutex_icall(bool initiallyOwned, Char* name, int name_length, Boolean& created);
    private static IntPtr OpenMutex_icall(Char* name, int name_length, MutexRights rights, MonoIOError& error);
    private static bool ReleaseMutex_internal(IntPtr handle);
    private static IntPtr CreateMutex_internal(bool initiallyOwned, string name, Boolean& created);
    private static IntPtr OpenMutex_internal(string name, MutexRights rights, MonoIOError& error);
    public MutexSecurity GetAccessControl();
    public static Mutex OpenExisting(string name);
    public static Mutex OpenExisting(string name, MutexRights rights);
    public static bool TryOpenExisting(string name, Mutex& result);
    public static bool TryOpenExisting(string name, MutexRights rights, Mutex& result);
    [ReliabilityContractAttribute("3", "1")]
public void ReleaseMutex();
    public void SetAccessControl(MutexSecurity mutexSecurity);
}
internal static class System.Threading.NativeEventCalls : object {
    public static IntPtr CreateEvent_internal(bool manual, bool initial, string name, Int32& errorCode);
    private static IntPtr CreateEvent_icall(bool manual, bool initial, Char* name, int name_length, Int32& errorCode);
    public static bool SetEvent(SafeWaitHandle handle);
    private static bool SetEvent_internal(IntPtr handle);
    public static bool ResetEvent(SafeWaitHandle handle);
    private static bool ResetEvent_internal(IntPtr handle);
    public static void CloseEvent_internal(IntPtr handle);
    public static IntPtr OpenEvent_internal(string name, EventWaitHandleRights rights, Int32& errorCode);
    private static IntPtr OpenEvent_icall(Char* name, int name_length, EventWaitHandleRights rights, Int32& errorCode);
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
[ComVisibleAttribute("True")]
public class System.Threading.Overlapped : object {
    private IAsyncResult ares;
    private int offsetL;
    private int offsetH;
    private int evt;
    private IntPtr evt_ptr;
    public IAsyncResult AsyncResult { get; public set; }
    [ObsoleteAttribute("Not 64bit compatible.  Use EventHandleIntPtr instead.")]
public int EventHandle { get; public set; }
    [ComVisibleAttribute("False")]
public IntPtr EventHandleIntPtr { get; public set; }
    public int OffsetHigh { get; public set; }
    public int OffsetLow { get; public set; }
    [ObsoleteAttribute("Not 64bit compatible.  Please use the constructor that takes IntPtr for the event handle")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [MonoTODOAttribute("Security - we need to propagate the call stack")]
[ObsoleteAttribute("Use Pack(iocb, userData) instead")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
[MonoTODOAttribute("handle userData")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [ObsoleteAttribute("Use UnsafePack(iocb, userData) instead")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [ComVisibleAttribute("False")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    private static int PROCESSOR_COUNT_REFRESH_INTERVAL_MS;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks;
    internal static bool IsSingleProcessor;
    internal static int ProcessorCount { get; }
    private static PlatformHelper();
    internal static int get_ProcessorCount();
}
public class System.Threading.PreAllocatedOverlapped : object {
    internal Win32ThreadPoolNativeOverlapped* _overlapped;
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    private static PreAllocatedOverlapped();
    [CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    internal void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.QueueUserWorkItemCallback : object {
    private WaitCallback callback;
    private ExecutionContext context;
    private object state;
    [SecurityCriticalAttribute]
internal static ContextCallback ccb;
    [SecurityCriticalAttribute]
internal QueueUserWorkItemCallback(WaitCallback waitCallback, object stateObj, bool compressStack, StackCrawlMark& stackMark);
    internal QueueUserWorkItemCallback(WaitCallback waitCallback, object stateObj, ExecutionContext ec);
    private static QueueUserWorkItemCallback();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    [SecurityCriticalAttribute]
private static void WaitCallback_Context(object state);
}
[ComVisibleAttribute("True")]
public class System.Threading.ReaderWriterLock : CriticalFinalizerObject {
    private int seq_num;
    private int state;
    private int readers;
    private int writer_lock_owner;
    private LockQueue writer_queue;
    private Hashtable reader_locks;
    public bool IsReaderLockHeld { get; }
    public bool IsWriterLockHeld { get; }
    public int WriterSeqNum { get; }
    protected virtual override void Finalize();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsReaderLockHeld();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsWriterLockHeld();
    public int get_WriterSeqNum();
    public void AcquireReaderLock(int millisecondsTimeout);
    private void AcquireReaderLock(int millisecondsTimeout, int initialLockCount);
    public void AcquireReaderLock(TimeSpan timeout);
    public void AcquireWriterLock(int millisecondsTimeout);
    private void AcquireWriterLock(int millisecondsTimeout, int initialLockCount);
    public void AcquireWriterLock(TimeSpan timeout);
    public bool AnyWritersSince(int seqNum);
    public void DowngradeFromWriterLock(LockCookie& lockCookie);
    public LockCookie ReleaseLock();
    [ReliabilityContractAttribute("3", "2")]
public void ReleaseReaderLock();
    private void ReleaseReaderLock(int currentCount, int releaseCount);
    [ReliabilityContractAttribute("3", "2")]
public void ReleaseWriterLock();
    private void ReleaseWriterLock(int releaseCount);
    public void RestoreLock(LockCookie& lockCookie);
    public LockCookie UpgradeToWriterLock(int millisecondsTimeout);
    public LockCookie UpgradeToWriterLock(TimeSpan timeout);
    private LockCookie GetLockCookie();
    private bool HasWriterLock();
    private int CheckTimeout(TimeSpan timeout);
}
[ComVisibleAttribute("True")]
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private WaitHandle _waitObject;
    private WaitOrTimerCallback _callback;
    private object _state;
    private WaitHandle _finalEvent;
    private ManualResetEvent _cancelEvent;
    private TimeSpan _timeout;
    private int _callsInProcess;
    private bool _executeOnlyOnce;
    private bool _unregistered;
    internal RegisteredWaitHandle(WaitHandle waitObject, WaitOrTimerCallback callback, object state, TimeSpan timeout, bool executeOnlyOnce);
    internal void Wait(object state);
    private void DoCallBack(object timedOut);
    [ComVisibleAttribute("True")]
public bool Unregister(WaitHandle waitObject);
}
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_waitCount;
    private object m_lockObj;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static int NO_MAXIMUM;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__32")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    [SecuritySafeCriticalAttribute]
private static void QueueWaiterTask(TaskNode waiterTask);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
    private static string GetResourceString(string str);
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.SparselyPopulatedArray`1 : object {
    private SparselyPopulatedArrayFragment`1<T> _head;
    private SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    internal SparselyPopulatedArrayFragment`1<T> Tail { get; }
    internal SparselyPopulatedArray`1(int initialSize);
    internal SparselyPopulatedArrayFragment`1<T> get_Tail();
    internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);
}
internal class System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
    private SparselyPopulatedArrayFragment`1<T> _source;
    private int _index;
    internal SparselyPopulatedArrayFragment`1<T> Source { get; }
    internal int Index { get; }
    internal SparselyPopulatedArrayAddInfo`1(SparselyPopulatedArrayFragment`1<T> source, int index);
    internal SparselyPopulatedArrayFragment`1<T> get_Source();
    internal int get_Index();
}
[DefaultMemberAttribute("Item")]
internal class System.Threading.SparselyPopulatedArrayFragment`1 : object {
    internal T[] _elements;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _freeCount;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _next;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _prev;
    internal T Item { get; }
    internal int Length { get; }
    internal SparselyPopulatedArrayFragment`1<T> Prev { get; }
    internal SparselyPopulatedArrayFragment`1(int size);
    internal SparselyPopulatedArrayFragment`1(int size, SparselyPopulatedArrayFragment`1<T> prev);
    internal T get_Item(int index);
    internal int get_Length();
    internal SparselyPopulatedArrayFragment`1<T> get_Prev();
    internal T SafeAtomicRemove(int index, T expectedElement);
}
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner;
    private static int SPINNING_FACTOR;
    private static int SLEEP_ONE_FREQUENCY;
    private static int SLEEP_ZERO_FREQUENCY;
    private static int TIMEOUT_CHECK_FREQUENCY;
    private static int LOCK_ID_DISABLE_MASK;
    private static int LOCK_ANONYMOUS_OWNED;
    private static int WAITERS_MASK;
    private static int ID_DISABLED_AND_ANONYMOUS_OWNED;
    private static int LOCK_UNOWNED;
    private static int MAXIMUM_WAITERS;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    [ReliabilityContractAttribute("3", "2")]
public void Exit();
    [ReliabilityContractAttribute("3", "2")]
public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeld();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeldByCurrentThread();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int YieldThreshold;
    private static int Sleep0EveryHowManyYields;
    internal static int DefaultSleep1Threshold;
    internal static int SpinCountforSpinBeforeWait;
    internal static int Sleep1ThresholdForLongSpinBeforeWait;
    private int _count;
    public int Count { get; internal set; }
    public bool NextSpinWillYield { get; }
    private static SpinWait();
    public int get_Count();
    internal void set_Count(int value);
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void SpinOnce(int sleep1Threshold);
    private void SpinOnceCore(int sleep1Threshold);
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
public class System.Threading.SynchronizationContext : object {
    private SynchronizationContextProperties _props;
    private static Type s_cachedPreparedType1;
    private static Type s_cachedPreparedType2;
    private static Type s_cachedPreparedType3;
    private static Type s_cachedPreparedType4;
    private static Type s_cachedPreparedType5;
    public static SynchronizationContext Current { get; }
    internal static SynchronizationContext CurrentNoFlow { get; }
    internal static SynchronizationContext CurrentExplicit { get; }
    [SecuritySafeCriticalAttribute]
protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[PrePrepareMethodAttribute]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
[PrePrepareMethodAttribute]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [SecurityCriticalAttribute]
public static void SetSynchronizationContext(SynchronizationContext syncContext);
    public static SynchronizationContext get_Current();
    [FriendAccessAllowedAttribute]
internal static SynchronizationContext get_CurrentNoFlow();
    private static SynchronizationContext GetThreadLocalContext();
    public virtual SynchronizationContext CreateCopy();
    [SecurityCriticalAttribute]
private static int InvokeWaitMethodHelper(SynchronizationContext syncContext, IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    internal static SynchronizationContext get_CurrentExplicit();
}
[FlagsAttribute]
internal enum System.Threading.SynchronizationContextProperties : Enum {
    public int value__;
    public static SynchronizationContextProperties None;
    public static SynchronizationContextProperties RequireWaitNotification;
}
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> m_tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
[FriendAccessAllowedAttribute]
internal enum System.Threading.Tasks.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Started;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Error;
}
[FriendAccessAllowedAttribute]
internal static class System.Threading.Tasks.AsyncCausalityTracer : object {
    [FriendAccessAllowedAttribute]
internal static bool LoggingOn { get; }
    internal static void EnableToETW(bool enabled);
    [FriendAccessAllowedAttribute]
internal static bool get_LoggingOn();
    [FriendAccessAllowedAttribute]
internal static void TraceOperationCreation(CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
    [FriendAccessAllowedAttribute]
internal static void TraceOperationCompletion(CausalityTraceLevel traceLevel, int taskId, AsyncCausalityStatus status);
    internal static void TraceOperationRelation(CausalityTraceLevel traceLevel, int taskId, CausalityRelation relation);
    internal static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, int taskId, CausalitySynchronousWork work);
    internal static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);
    private static ulong GetOperationId(UInt32 taskId);
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    private static ContextCallback s_invokeActionCallback;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task ignored, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private static void InvokeAction(object state);
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining, Task& currentTask);
    internal static void UnsafeScheduleAction(Action action);
    protected static void ThrowAsyncIfNecessary(Exception exc);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    public sealed virtual void MarkAborted(ThreadAbortException e);
}
internal class System.Threading.Tasks.BeginEndAwaitableAdapter : RendezvousAwaitable`1<IAsyncResult> {
    public static AsyncCallback Callback;
    private static BeginEndAwaitableAdapter();
}
internal class System.Threading.Tasks.Box`1 : object {
    internal T Value;
    internal Box`1(T value);
}
internal enum System.Threading.Tasks.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum System.Threading.Tasks.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
[FriendAccessAllowedAttribute]
internal enum System.Threading.Tasks.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    public sealed virtual void MarkAborted(ThreadAbortException e);
}
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ThreadLocal`1<ProcessingMode> m_threadProcessingMode;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private static int UNLIMITED_PROCESSING;
    private static int EXCLUSIVE_PROCESSING_SENTINEL;
    private static int DEFAULT_MAXITEMSPERTASK;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    [ConditionalAttribute("DEBUG")]
private static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
[ExtensionAttribute]
internal static class System.Threading.Tasks.DebuggerSupport : object {
    private static LowLevelDictionary`2<int, Task> s_activeTasks;
    private static object s_activeTasksLock;
    public static bool LoggingOn { get; }
    private static DebuggerSupport();
    public static bool get_LoggingOn();
    public static void TraceOperationCreation(CausalityTraceLevel traceLevel, Task task, string operationName, ulong relatedContext);
    public static void TraceOperationCompletion(CausalityTraceLevel traceLevel, Task task, AsyncStatus status);
    public static void TraceOperationRelation(CausalityTraceLevel traceLevel, Task task, CausalityRelation relation);
    public static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, Task task, CausalitySynchronousWork work);
    public static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);
    public static void AddToActiveTasks(Task task);
    private static void AddToActiveTasksNonInlined(Task task);
    public static void RemoveFromActiveTasks(Task task);
    private static void RemoveFromActiveTasksNonInlined(Task task);
    public static Task GetActiveTaskFromId(int taskId);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncVoidMethodBuilder builder);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncTaskMethodBuilder builder);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncTaskMethodBuilder`1<TResult> builder);
}
[IsReadOnlyAttribute]
internal class System.Threading.Tasks.ForceAsyncAwaiter : ValueType {
    private Task _task;
    public bool IsCompleted { get; }
    internal ForceAsyncAwaiter(Task task);
    public ForceAsyncAwaiter GetAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action action);
    public sealed virtual void UnsafeOnCompleted(Action action);
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
internal class System.Threading.Tasks.IndexRange : ValueType {
    internal long _nFromInclusive;
    internal long _nToExclusive;
    internal Box`1 modreq(System.Runtime.CompilerServices.IsVolatile) _nSharedCurrentIndexOffset;
    internal int _bRangeFinished;
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
internal class System.Threading.Tasks.PaddingFor32 : ValueType {
}
internal static class System.Threading.Tasks.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
public static class System.Threading.Tasks.Parallel : object {
    internal static int s_forkJoinContextID;
    internal static int DEFAULT_LOOP_STRIDE;
    internal static ParallelOptions s_defaultParallelOptions;
    private static Parallel();
    public static void Invoke(Action[] actions);
    public static void Invoke(ParallelOptions parallelOptions, Action[] actions);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static bool CheckTimeoutReached(int timeoutOccursAt);
    private static int ComputeTimeoutPoint(int timeoutLength);
    private static ParallelLoopResult ForWorker(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body, Action`2<int, ParallelLoopState> bodyWithState, Func`4<int, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForWorker64(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body, Action`2<long, ParallelLoopState> bodyWithState, Func`4<long, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(TSource[] array, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(IList`1<TSource> list, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static ParallelLoopResult PartitionerForEachWorker(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> simpleBody, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static OperationCanceledException ReduceToSingleCancellationException(ICollection exceptions, CancellationToken cancelToken);
    private static void ThrowSingleCancellationExceptionOrOtherException(ICollection exceptions, CancellationToken cancelToken, Exception otherException);
}
[EventSourceAttribute]
internal class System.Threading.Tasks.ParallelEtwProvider : EventSource {
    public static ParallelEtwProvider Log;
    private static EventKeywords ALL_KEYWORDS;
    private static int PARALLELLOOPBEGIN_ID;
    private static int PARALLELLOOPEND_ID;
    private static int PARALLELINVOKEBEGIN_ID;
    private static int PARALLELINVOKEEND_ID;
    private static int PARALLELFORK_ID;
    private static int PARALLELJOIN_ID;
    private static ParallelEtwProvider();
    [EventAttribute("1")]
public void ParallelLoopBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, ForkJoinOperationType OperationType, long InclusiveFrom, long ExclusiveTo);
    [EventAttribute("2")]
public void ParallelLoopEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, long TotalIterations);
    [EventAttribute("3")]
public void ParallelInvokeBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, ForkJoinOperationType OperationType, int ActionCount);
    [EventAttribute("4")]
public void ParallelInvokeEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
    [EventAttribute("5")]
public void ParallelFork(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
    [EventAttribute("6")]
public void ParallelJoin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
}
public class System.Threading.Tasks.ParallelLoopResult : ValueType {
    internal bool _completed;
    internal Nullable`1<long> _lowestBreakIteration;
    public bool IsCompleted { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    public bool get_IsCompleted();
    public Nullable`1<long> get_LowestBreakIteration();
}
[DebuggerDisplayAttribute("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")]
public class System.Threading.Tasks.ParallelLoopState : object {
    private ParallelLoopStateFlags _flagsBase;
    internal bool InternalShouldExitCurrentIteration { get; }
    public bool ShouldExitCurrentIteration { get; }
    public bool IsStopped { get; }
    public bool IsExceptional { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    internal ParallelLoopState(ParallelLoopStateFlags fbase);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    public bool get_ShouldExitCurrentIteration();
    public bool get_IsStopped();
    public bool get_IsExceptional();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    public Nullable`1<long> get_LowestBreakIteration();
    public void Stop();
    internal virtual void InternalBreak();
    public void Break();
    internal static void Break(int iteration, ParallelLoopStateFlags32 pflags);
    internal static void Break(long iteration, ParallelLoopStateFlags64 pflags);
}
internal class System.Threading.Tasks.ParallelLoopState32 : ParallelLoopState {
    private ParallelLoopStateFlags32 _sharedParallelStateFlags;
    private int _currentIteration;
    internal int CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState32(ParallelLoopStateFlags32 sharedParallelStateFlags);
    internal int get_CurrentIteration();
    internal void set_CurrentIteration(int value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopState64 : ParallelLoopState {
    private ParallelLoopStateFlags64 _sharedParallelStateFlags;
    private long _currentIteration;
    internal long CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState64(ParallelLoopStateFlags64 sharedParallelStateFlags);
    internal long get_CurrentIteration();
    internal void set_CurrentIteration(long value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags : object {
    internal static int ParallelLoopStateNone;
    internal static int ParallelLoopStateExceptional;
    internal static int ParallelLoopStateBroken;
    internal static int ParallelLoopStateStopped;
    internal static int ParallelLoopStateCanceled;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _loopStateFlags;
    internal int LoopStateFlags { get; }
    internal int get_LoopStateFlags();
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates);
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates, Int32& oldState);
    internal void SetExceptional();
    internal void Stop();
    internal bool Cancel();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags32 : ParallelLoopStateFlags {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lowestBreakIteration;
    internal int LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal int get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(int CallerIteration);
    internal bool ShouldExitLoop();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags64 : ParallelLoopStateFlags {
    internal long _lowestBreakIteration;
    internal long LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal long get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(long CallerIteration);
    internal bool ShouldExitLoop();
}
public class System.Threading.Tasks.ParallelOptions : object {
    private TaskScheduler _scheduler;
    private int _maxDegreeOfParallelism;
    private CancellationToken _cancellationToken;
    public TaskScheduler TaskScheduler { get; public set; }
    internal TaskScheduler EffectiveTaskScheduler { get; }
    public int MaxDegreeOfParallelism { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    internal int EffectiveMaxConcurrencyLevel { get; }
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
    internal TaskScheduler get_EffectiveTaskScheduler();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    internal int get_EffectiveMaxConcurrencyLevel();
}
internal class System.Threading.Tasks.RangeManager : object {
    internal IndexRange[] _indexRanges;
    internal bool _use32BitCurrentIndex;
    internal int _nCurrentIndexRangeToAssign;
    internal long _nStep;
    internal RangeManager(long nFromInclusive, long nToExclusive, long nStep, int nNumExpectedWorkers);
    internal RangeWorker RegisterNewWorker();
}
internal class System.Threading.Tasks.RangeWorker : ValueType {
    internal IndexRange[] _indexRanges;
    internal int _nCurrentIndexRange;
    internal long _nStep;
    internal long _nIncrementValue;
    internal long _nMaxIncrementValue;
    internal bool _use32BitCurrentIndex;
    internal bool IsInitialized { get; }
    internal RangeWorker(IndexRange[] ranges, int nInitialRange, long nStep, bool use32BitCurrentIndex);
    internal bool get_IsInitialized();
    internal bool FindNewWork(Int64& nFromInclusiveLocal, Int64& nToExclusiveLocal);
    internal bool FindNewWork32(Int32& nFromInclusiveLocal32, Int32& nToExclusiveLocal32);
}
internal class System.Threading.Tasks.RendezvousAwaitable`1 : object {
    private static Action s_completionSentinel;
    private Action _continuation;
    private ExceptionDispatchInfo _error;
    private TResult _result;
    [CompilerGeneratedAttribute]
private bool <RunContinuationsAsynchronously>k__BackingField;
    public bool RunContinuationsAsynchronously { get; public set; }
    public bool IsCompleted { get; }
    private static RendezvousAwaitable`1();
    [CompilerGeneratedAttribute]
public bool get_RunContinuationsAsynchronously();
    [CompilerGeneratedAttribute]
public void set_RunContinuationsAsynchronously(bool value);
    public RendezvousAwaitable`1<TResult> GetAwaiter();
    public bool get_IsCompleted();
    public TResult GetResult();
    public void SetResult(TResult result);
    public void SetCanceled(CancellationToken token);
    public void SetException(Exception exception);
    private void NotifyAwaiter();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    [ConditionalAttribute("DEBUG")]
private void AssertResultConsistency(bool expectedCompleted);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private static int INIT_SEGMENT_SIZE;
    private static int MAX_SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public bool TryPeek(T& result);
    private bool TryPeekSlow(Segment& segment, T[]& array, T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment& segment, T[]& array, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual TResult GetResult(short token);
}
public class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private Action`1<object> _continuation;
    private object _continuationState;
    private ExecutionContext _executionContext;
    private object _capturedContext;
    private bool _completed;
    private TResult _result;
    private ExceptionDispatchInfo _error;
    private short _version;
    [CompilerGeneratedAttribute]
private bool <RunContinuationsAsynchronously>k__BackingField;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_RunContinuationsAsynchronously();
    [CompilerGeneratedAttribute]
public void set_RunContinuationsAsynchronously(bool value);
    public void Reset();
    public void SetResult(TResult result);
    public void SetException(Exception error);
    public short get_Version();
    public ValueTaskSourceStatus GetStatus(short token);
    [StackTraceHiddenAttribute]
public TResult GetResult(short token);
    public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private void ValidateToken(short token);
    private void SignalCompletion();
    private void InvokeContinuation();
}
internal static class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCoreShared : object {
    internal static Action`1<object> s_sentinel;
    private static ManualResetValueTaskSourceCoreShared();
    [StackTraceHiddenAttribute]
internal static void ThrowInvalidOperationException();
    private static void CompletionSentinel(object _);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
internal class System.Threading.Tasks.StackGuard : object {
    private int m_inliningDepth;
    private static int MAX_UNCHECKED_INLINING_DEPTH;
    internal bool TryBeginInliningScope();
    internal void EndInliningScope();
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    internal static int s_taskIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId;
    internal Delegate m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Task m_parent;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private static int OptionsMask;
    internal static int TASK_STATE_STARTED;
    internal static int TASK_STATE_DELEGATE_INVOKED;
    internal static int TASK_STATE_DISPOSED;
    internal static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT;
    internal static int TASK_STATE_CANCELLATIONACKNOWLEDGED;
    internal static int TASK_STATE_FAULTED;
    internal static int TASK_STATE_CANCELED;
    internal static int TASK_STATE_WAITING_ON_CHILDREN;
    internal static int TASK_STATE_RAN_TO_COMPLETION;
    internal static int TASK_STATE_WAITINGFORACTIVATION;
    internal static int TASK_STATE_COMPLETION_RESERVED;
    internal static int TASK_STATE_THREAD_WAS_ABORTED;
    internal static int TASK_STATE_WAIT_COMPLETION_NOTIFICATION;
    private static int TASK_STATE_COMPLETED_MASK;
    private static int CANCELLATION_REQUESTED;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    internal static bool s_asyncDebuggingEnabled;
    internal ContingentProperties modreq(System.Runtime.CompilerServices.IsVolatile) m_contingentProperties;
    private static Action`1<object> s_taskCancelCallback;
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    [ThreadStaticAttribute]
private static StackGuard t_stackGuard;
    private static Func`1<ContingentProperties> s_createContingentProperties;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    private static Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
    private static ContextCallback s_ecCallback;
    private static Predicate`1<object> s_IsTaskContinuationNullPredicate;
    private static Dictionary`2<int, Task> s_currentActiveTasks;
    private static object s_activeTasksLock;
    private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    internal static StackGuard CurrentStackGuard { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private static void TaskCancelCallback(object o);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    internal bool TrySetException(object exceptionObject);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    internal static StackGuard get_CurrentStackGuard();
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
    private ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection);
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool bUserDelegateExecuted);
    internal void FinishStageTwo();
    internal void FinishStageThree();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren();
    private void Execute();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    internal bool ExecuteEntry(bool bPreventDoubleExecution);
    private static void ExecutionContextCallback(object obj);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal void FinishContinuations();
    private void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, LowLevelListWithIList`1& list, int initSize);
    private static bool WaitAllBlockingCore(LowLevelListWithIList`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(LowLevelListWithIList`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    internal static Task FromCancellation(CancellationToken cancellationToken);
    public static Task FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    private static Task InternalWhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    private static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    private static Task GetActiveTaskFromId(int taskId);
    [FriendAccessAllowedAttribute]
internal static bool AddToActiveTasks(Task task);
    [FriendAccessAllowedAttribute]
internal static void RemoveFromActiveTasks(int taskId);
    public sealed virtual void MarkAborted(ThreadAbortException e);
    [SecurityCriticalAttribute]
private void ExecuteWithThreadLocal(Task& currentTaskSlot);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    internal TResult m_result;
    private static TaskFactory`1<TResult> s_defaultFactory;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class System.Threading.Tasks.TaskAwaiters : object {
    [ExtensionAttribute]
public static ForceAsyncAwaiter ForceAsync(Task task);
}
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task _canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> _task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    private void SpinUntilCompleted();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private static bool s_failFastOnUnobservedException;
    private Task m_task;
    private LowLevelListWithIList`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    private static TaskExceptionHolder();
    private static bool ShouldFailFastOnUnobservedException();
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject);
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
internal class System.Threading.Tasks.TaskReplicator : object {
    private TaskScheduler _scheduler;
    private bool _stopOnFirstFailure;
    private ConcurrentQueue`1<Replica> _pendingReplicas;
    private ConcurrentQueue`1<Exception> _exceptions;
    private bool _stopReplicating;
    private static int CooperativeMultitaskingTaskTimeout_Min;
    private static int CooperativeMultitaskingTaskTimeout_Increment;
    private static int CooperativeMultitaskingTaskTimeout_RootTask;
    private TaskReplicator(ParallelOptions options, bool stopOnFirstFailure);
    public static void Run(ReplicatableUserAction`1<TState> action, ParallelOptions options, bool stopOnFirstFailure);
    private static int GenerateCooperativeMultitaskingTaskTimeout();
}
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
    private static Lock _unobservedTaskExceptionLockObject;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    private void AddToActiveTaskSchedulers();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private static byte STATE_WAITING_ON_OUTER_TASK;
    private static byte STATE_WAITING_ON_INNER_TASK;
    private static byte STATE_DONE;
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    [StackTraceHiddenAttribute]
internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
[IsReadOnlyAttribute]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual string ToString();
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
public class System.Threading.Thread : CriticalFinalizerObject {
    private static LocalDataStoreMgr s_LocalDataStoreMgr;
    [ThreadStaticAttribute]
private static LocalDataStoreHolder s_LocalDataStore;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentCulture;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentUICulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
    private InternalThread internal_thread;
    private object m_ThreadStartArg;
    private object pending_exception;
    [ThreadStaticAttribute]
private static Thread current_thread;
    private MulticastDelegate m_Delegate;
    private ExecutionContext m_ExecutionContext;
    private bool m_ExecutionContextBelongsToOuterScope;
    private IPrincipal principal;
    private int principal_version;
    internal bool ExecutionContextBelongsToCurrentScope { get; internal set; }
    public ExecutionContext ExecutionContext { get; }
    public ThreadPriority Priority { get; public set; }
    public CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    private static LocalDataStoreMgr LocalDataStoreManager { get; }
    private InternalThread Internal { get; }
    public static Context CurrentContext { get; }
    public static IPrincipal CurrentPrincipal { get; public set; }
    public static Thread CurrentThread { get; }
    internal static int CurrentThreadId { get; }
    [ObsoleteAttribute("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")]
public ApartmentState ApartmentState { get; public set; }
    public bool IsThreadPoolThread { get; }
    internal bool IsThreadPoolThreadInternal { get; internal set; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public string Name { get; public set; }
    public ThreadState ThreadState { get; }
    internal object AbortReason { get; }
    public int ManagedThreadId { get; }
    [SecuritySafeCriticalAttribute]
public Thread(ThreadStart start);
    [SecuritySafeCriticalAttribute]
public Thread(ThreadStart start, int maxStackSize);
    [SecuritySafeCriticalAttribute]
public Thread(ParameterizedThreadStart start);
    [SecuritySafeCriticalAttribute]
public Thread(ParameterizedThreadStart start, int maxStackSize);
    private Thread(InternalThread it);
    private static void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    public void Start();
    public void Start(object parameter);
    [SecuritySafeCriticalAttribute]
private void Start(StackCrawlMark& stackMark);
    [ReliabilityContractAttribute("3", "2")]
internal Reader GetExecutionContextReader();
    internal bool get_ExecutionContextBelongsToCurrentScope();
    internal void set_ExecutionContextBelongsToCurrentScope(bool value);
    [SecuritySafeCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public ExecutionContext get_ExecutionContext();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
internal ExecutionContext GetMutableExecutionContext();
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal void SetExecutionContext(ExecutionContext value, bool belongsToCurrentScope);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "2")]
internal void SetExecutionContext(Reader value, bool belongsToCurrentScope);
    [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public void SetCompressedStack(CompressedStack stack);
    [SecurityCriticalAttribute]
[ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public CompressedStack GetCompressedStack();
    public static void ResetAbort();
    private void ResetAbortNative();
    [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
[SecuritySafeCriticalAttribute]
public void Suspend();
    [SecurityCriticalAttribute]
private void SuspendInternal();
    [SecuritySafeCriticalAttribute]
[ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public void Resume();
    [SecurityCriticalAttribute]
private void ResumeInternal();
    public void Interrupt();
    private void InterruptInternal();
    [SecuritySafeCriticalAttribute]
public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    private int GetPriorityNative();
    private void SetPriorityNative(int priority);
    private bool JoinInternal(int millisecondsTimeout);
    public void Join();
    public bool Join(int millisecondsTimeout);
    public bool Join(TimeSpan timeout);
    private static void SleepInternal(int millisecondsTimeout);
    [SecuritySafeCriticalAttribute]
public static void Sleep(int millisecondsTimeout);
    public static void Sleep(TimeSpan timeout);
    private static bool YieldInternal();
    public static bool Yield();
    [SecurityCriticalAttribute]
private void SetStartHelper(Delegate start, int maxStackSize);
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public static void FreeNamedDataSlot(string name);
    public static object GetData(LocalDataStoreSlot slot);
    public static void SetData(LocalDataStoreSlot slot, object data);
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    internal CultureInfo GetCurrentUICultureNoAppX();
    public CultureInfo get_CurrentCulture();
    [SecuritySafeCriticalAttribute]
public void set_CurrentCulture(CultureInfo value);
    private CultureInfo GetCurrentCultureNoAppX();
    private static void nativeInitCultureAccessors();
    public static void MemoryBarrier();
    private static LocalDataStoreMgr get_LocalDataStoreManager();
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Thread.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private void ConstructInternalThread();
    private InternalThread get_Internal();
    private static Byte[] ByteArrayToRootDomain(Byte[] arr);
    private static Byte[] ByteArrayToCurrentDomain(Byte[] arr);
    public static Context get_CurrentContext();
    private static void DeserializePrincipal(Thread th);
    private static void SerializePrincipal(Thread th, IPrincipal value);
    public static IPrincipal get_CurrentPrincipal();
    public static void set_CurrentPrincipal(IPrincipal value);
    public static AppDomain GetDomain();
    private static void GetCurrentThread_icall(Thread& thread);
    private static Thread GetCurrentThread();
    [ReliabilityContractAttribute("3", "1")]
public static Thread get_CurrentThread();
    internal static int get_CurrentThreadId();
    public static int GetDomainID();
    private bool Thread_internal(MulticastDelegate start);
    [ReliabilityContractAttribute("3", "2")]
protected virtual override void Finalize();
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    public bool get_IsThreadPoolThread();
    internal bool get_IsThreadPoolThreadInternal();
    internal void set_IsThreadPoolThreadInternal(bool value);
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    private static string GetName_internal(InternalThread thread);
    private static void SetName_icall(InternalThread thread, Char* name, int nameLength);
    private static void SetName_internal(InternalThread thread, string name);
    public string get_Name();
    public void set_Name(string value);
    public ThreadState get_ThreadState();
    private static void Abort_internal(InternalThread thread, object stateInfo);
    public void Abort();
    public void Abort(object stateInfo);
    private object GetAbortExceptionState();
    internal object get_AbortReason();
    private void ClearAbortReason();
    private static void SpinWait_nop();
    [ReliabilityContractAttribute("3", "2")]
public static void SpinWait(int iterations);
    private void StartInternal(object principal, StackCrawlMark& stackMark);
    private static void SetState(InternalThread thread, ThreadState set);
    private static void ClrState(InternalThread thread, ThreadState clr);
    private static ThreadState GetState(InternalThread thread);
    public static byte VolatileRead(Byte& address);
    public static double VolatileRead(Double& address);
    public static short VolatileRead(Int16& address);
    public static int VolatileRead(Int32& address);
    public static long VolatileRead(Int64& address);
    public static IntPtr VolatileRead(IntPtr& address);
    public static object VolatileRead(Object& address);
    [CLSCompliantAttribute("False")]
public static sbyte VolatileRead(SByte& address);
    public static float VolatileRead(Single& address);
    [CLSCompliantAttribute("False")]
public static ushort VolatileRead(UInt16& address);
    [CLSCompliantAttribute("False")]
public static UInt32 VolatileRead(UInt32& address);
    [CLSCompliantAttribute("False")]
public static ulong VolatileRead(UInt64& address);
    [CLSCompliantAttribute("False")]
public static UIntPtr VolatileRead(UIntPtr& address);
    public static void VolatileWrite(Byte& address, byte value);
    public static void VolatileWrite(Double& address, double value);
    public static void VolatileWrite(Int16& address, short value);
    public static void VolatileWrite(Int32& address, int value);
    public static void VolatileWrite(Int64& address, long value);
    public static void VolatileWrite(IntPtr& address, IntPtr value);
    public static void VolatileWrite(Object& address, object value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(SByte& address, sbyte value);
    public static void VolatileWrite(Single& address, float value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt16& address, ushort value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt32& address, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt64& address, ulong value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UIntPtr& address, UIntPtr value);
    private static int SystemMaxStackStize();
    private static int GetProcessDefaultStackSize(int maxStackSize);
    private void SetStart(MulticastDelegate start, int maxStackSize);
    [ReliabilityContractAttribute("3", "2")]
public int get_ManagedThreadId();
    [ReliabilityContractAttribute("3", "1")]
public static void BeginCriticalRegion();
    [ReliabilityContractAttribute("3", "2")]
public static void EndCriticalRegion();
    [ReliabilityContractAttribute("3", "1")]
public static void BeginThreadAffinity();
    [ReliabilityContractAttribute("3", "1")]
public static void EndThreadAffinity();
    public ApartmentState GetApartmentState();
    public void SetApartmentState(ApartmentState state);
    public bool TrySetApartmentState(ApartmentState state);
    [ComVisibleAttribute("False")]
public virtual int GetHashCode();
    internal static void GetStackTraces(Thread[]& threads, Object[]& stack_frames);
    internal static Dictionary`2<Thread, StackTrace> Mono_GetStackTraces();
    public void DisableComObjectEagerCleanup();
    private ThreadState ValidateThreadState();
    public static int GetCurrentProcessorId();
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public object get_ExceptionState();
}
internal class System.Threading.ThreadHelper : object {
    private Delegate _start;
    private object _startArg;
    private ExecutionContext _executionContext;
    [SecurityCriticalAttribute]
internal static ContextCallback _ccb;
    internal ThreadHelper(Delegate start);
    private static ThreadHelper();
    internal void SetExecutionContextHelper(ExecutionContext ec);
    [SecurityCriticalAttribute]
private static void ThreadStart_Context(object state);
    [SecurityCriticalAttribute]
internal void ThreadStart(object obj);
    [SecurityCriticalAttribute]
internal void ThreadStart();
}
[ComVisibleAttribute("True")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> m_valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int m_idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> m_linkedSlot;
    private bool m_trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
public static class System.Threading.ThreadPool : object {
    internal static bool IsThreadPoolThread { get; }
    [SecuritySafeCriticalAttribute]
public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, StackCrawlMark& stackMark, bool compressStack);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [SecurityCriticalAttribute]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [SecuritySafeCriticalAttribute]
public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    [SecuritySafeCriticalAttribute]
public static bool QueueUserWorkItem(WaitCallback callBack);
    [SecurityCriticalAttribute]
public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    [SecurityCriticalAttribute]
private static bool QueueUserWorkItemHelper(WaitCallback callBack, object state, StackCrawlMark& stackMark, bool compressStack, bool forceGlobal);
    [SecurityCriticalAttribute]
internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
    [SecurityCriticalAttribute]
internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems();
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<EnumerateQueuedWorkItems>d__23")]
internal static IEnumerable`1<IThreadPoolWorkItem> EnumerateQueuedWorkItems(WorkStealingQueue[] wsQueues, QueueSegment globalQueueTail);
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
    [SecurityCriticalAttribute]
internal static IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
    private static Object[] ToObjectArray(IEnumerable`1<IThreadPoolWorkItem> workitems);
    [SecurityCriticalAttribute]
internal static Object[] GetQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    [SecurityCriticalAttribute]
internal static bool RequestWorkerThread();
    [SecurityCriticalAttribute]
private static bool PostQueuedCompletionStatus(NativeOverlapped* overlapped);
    [SecurityCriticalAttribute]
[CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    [SecurityCriticalAttribute]
private static void EnsureVMInitialized();
    [SecurityCriticalAttribute]
private static bool SetMinThreadsNative(int workerThreads, int completionPortThreads);
    [SecurityCriticalAttribute]
private static bool SetMaxThreadsNative(int workerThreads, int completionPortThreads);
    [SecurityCriticalAttribute]
private static void GetMinThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    [SecurityCriticalAttribute]
private static void GetMaxThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    [SecurityCriticalAttribute]
private static void GetAvailableThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    [SecurityCriticalAttribute]
internal static bool NotifyWorkItemComplete();
    [SecurityCriticalAttribute]
internal static void ReportThreadStatus(bool isWorking);
    [SecuritySafeCriticalAttribute]
internal static void NotifyWorkItemProgress();
    [SecurityCriticalAttribute]
internal static void NotifyWorkItemProgressNative();
    [SecurityCriticalAttribute]
internal static void NotifyWorkItemQueued();
    [SecurityCriticalAttribute]
internal static bool IsThreadPoolHosted();
    [SecurityCriticalAttribute]
private static void InitializeVMTp(Boolean& enableWorkerTracking);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
[SecuritySafeCriticalAttribute]
public static bool BindHandle(IntPtr osHandle);
    [SecuritySafeCriticalAttribute]
public static bool BindHandle(SafeHandle osHandle);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
private static bool BindIOCompletionCallbackNative(IntPtr fileHandle);
    internal static bool get_IsThreadPoolThread();
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private SafeThreadPoolIOHandle _threadPoolHandle;
    private DeferredDisposableLifetime`1<ThreadPoolBoundHandle> _lifetime;
    public SafeHandle Handle { get; }
    private static ThreadPoolBoundHandle();
    private ThreadPoolBoundHandle(SafeHandle handle, SafeThreadPoolIOHandle threadPoolHandle);
    public SafeHandle get_Handle();
    public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    private static OverlappedData GetOverlappedData(Win32ThreadPoolNativeOverlapped* overlapped, ThreadPoolBoundHandle expectedBoundHandle);
    [NativeCallableAttribute]
private static void OnNativeIOCompleted(IntPtr instance, IntPtr context, IntPtr overlappedPtr, UInt32 ioResult, UIntPtr numberOfBytesTransferred, IntPtr ioPtr);
    private bool AddRef();
    private void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.ThreadPoolCallbackWrapper : ValueType {
    private RuntimeThread _currentThread;
    public static ThreadPoolCallbackWrapper Enter();
    public void Exit(bool resetThread);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static UInt32 tpQuantum;
    public static int processorCount;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) vmTpInitialized;
    public static bool enableWorkerTracking;
    [SecurityCriticalAttribute]
public static ThreadPoolWorkQueue workQueue;
    public static bool tpHosted { get; }
    private static ThreadPoolGlobals();
    public static bool get_tpHosted();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueHead;
    internal QueueSegment modreq(System.Runtime.CompilerServices.IsVolatile) queueTail;
    internal static SparseArray`1<WorkStealingQueue> allThreadQueues;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests;
    private static ThreadPoolWorkQueue();
    [SecurityCriticalAttribute]
public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
    [SecurityCriticalAttribute]
internal void EnsureThreadRequested();
    [SecurityCriticalAttribute]
internal void MarkThreadRequestSatisfied();
    [SecurityCriticalAttribute]
public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
    [SecurityCriticalAttribute]
internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
    [SecurityCriticalAttribute]
public void Dequeue(ThreadPoolWorkQueueThreadLocals tl, IThreadPoolWorkItem& callback, Boolean& missedSteal);
    [SecurityCriticalAttribute]
internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [SecurityCriticalAttribute]
[ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public Random random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    [SecurityCriticalAttribute]
private void CleanUp();
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    private ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    internal static UInt32 UnsignedInfinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
[ComVisibleAttribute("True")]
public class System.Threading.Timer : MarshalByRefObject {
    private TimerCallback callback;
    private object state;
    private long due_time_ms;
    private long period_ms;
    private long next_run;
    private bool disposed;
    private bool is_dead;
    private bool is_added;
    private static long MaxValue;
    private static Scheduler scheduler { get; }
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback);
    private static Scheduler get_scheduler();
    private void Init(TimerCallback callback, object state, long dueTime, long period);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public sealed virtual void Dispose();
    public bool Change(long dueTime, long period);
    private bool Change(long dueTime, long period, bool first);
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual ValueTask DisposeAsync();
    internal void KeepRootedWhileScheduled();
    private static long GetTimeMonotonic();
}
[ComVisibleAttribute("True")]
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Threading.Volatile : object {
    [IntrinsicAttribute]
public static bool Read(Boolean& location);
    [IntrinsicAttribute]
public static void Write(Boolean& location, bool value);
    [IntrinsicAttribute]
public static byte Read(Byte& location);
    [IntrinsicAttribute]
public static void Write(Byte& location, byte value);
    [IntrinsicAttribute]
public static short Read(Int16& location);
    [IntrinsicAttribute]
public static void Write(Int16& location, short value);
    [IntrinsicAttribute]
public static int Read(Int32& location);
    [IntrinsicAttribute]
public static void Write(Int32& location, int value);
    [IntrinsicAttribute]
public static IntPtr Read(IntPtr& location);
    [IntrinsicAttribute]
public static void Write(IntPtr& location, IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Read(SByte& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Write(SByte& location, sbyte value);
    [IntrinsicAttribute]
public static float Read(Single& location);
    [IntrinsicAttribute]
public static void Write(Single& location, float value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ushort Read(UInt16& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Write(UInt16& location, ushort value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static UInt32 Read(UInt32& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Write(UInt32& location, UInt32 value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static UIntPtr Read(UIntPtr& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Write(UIntPtr& location, UIntPtr value);
    [IntrinsicAttribute]
public static T Read(T& location);
    [IntrinsicAttribute]
public static void Write(T& location, T value);
    [ReliabilityContractAttribute("3", "2")]
public static long Read(Int64& location);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
public static ulong Read(UInt64& location);
    [ReliabilityContractAttribute("3", "2")]
public static double Read(Double& location);
    [ReliabilityContractAttribute("3", "2")]
public static void Write(Int64& location, long value);
    [ReliabilityContractAttribute("3", "2")]
[CLSCompliantAttribute("False")]
public static void Write(UInt64& location, ulong value);
    [ReliabilityContractAttribute("3", "2")]
public static void Write(Double& location, double value);
}
[ComVisibleAttribute("True")]
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ComVisibleAttribute("True")]
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    public static int WaitTimeout;
    private static int MAX_WAITHANDLES;
    private IntPtr waitHandle;
    [SecurityCriticalAttribute]
internal SafeWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) safeWaitHandle;
    internal bool hasThreadAffinity;
    private static int WAIT_OBJECT_0;
    private static int WAIT_ABANDONED;
    private static int WAIT_FAILED;
    private static int ERROR_TOO_MANY_POSTS;
    private static int ERROR_NOT_OWNED_BY_CALLER;
    protected static IntPtr InvalidHandle;
    internal static int MaxWaitHandles;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    [SecuritySafeCriticalAttribute]
private void Init();
    [SecuritySafeCriticalAttribute]
public virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
public virtual void set_Handle(IntPtr value);
    [SecurityCriticalAttribute]
[ReliabilityContractAttribute("3", "1")]
public SafeWaitHandle get_SafeWaitHandle();
    [ReliabilityContractAttribute("3", "2")]
[SecurityCriticalAttribute]
public void set_SafeWaitHandle(SafeWaitHandle value);
    [SecurityCriticalAttribute]
internal void SetHandleInternal(SafeWaitHandle handle);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
    [SecuritySafeCriticalAttribute]
private bool WaitOne(long timeout, bool exitContext);
    [SecurityCriticalAttribute]
internal static bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    [SecurityCriticalAttribute]
internal bool WaitOneWithoutFAS();
    [SecuritySafeCriticalAttribute]
public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    [ReliabilityContractAttribute("3", "1")]
[SecuritySafeCriticalAttribute]
public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles);
    [ReliabilityContractAttribute("3", "1")]
public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    [SecuritySafeCriticalAttribute]
public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    private static void ThrowAbandonedMutexException();
    private static void ThrowAbandonedMutexException(int location, WaitHandle handle);
    public virtual void Close();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
    private static int WaitOneNative(SafeHandle waitableSafeHandle, UInt32 millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    private static int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
    internal static int Wait_internal(IntPtr* handles, int numHandles, bool waitAll, int ms);
    private static int SignalAndWaitOne(SafeWaitHandle waitHandleToSignal, SafeWaitHandle waitHandleToWaitOn, int millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    private static int SignalAndWait_Internal(IntPtr toSignal, IntPtr toWaitOn, int ms);
    internal static int ToTimeoutMilliseconds(TimeSpan timeout);
}
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class System.Threading.WaitHandleExtensions : object {
    [SecurityCriticalAttribute]
[ExtensionAttribute]
public static SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value);
}
[ComVisibleAttribute("True")]
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.Win32ThreadPoolNativeOverlapped : ValueType {
    [ThreadStaticAttribute]
private static ExecutionContextCallbackArgs t_executionContextCallbackArgs;
    private static ContextCallback s_executionContextCallback;
    private static OverlappedData[] s_dataArray;
    private static int s_dataCount;
    private static IntPtr s_freeList;
    private NativeOverlapped _overlapped;
    private IntPtr _nextFree;
    private int _dataIndex;
    internal OverlappedData Data { get; }
    private static Win32ThreadPoolNativeOverlapped();
    internal OverlappedData get_Data();
    internal static Win32ThreadPoolNativeOverlapped* Allocate(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    private static Win32ThreadPoolNativeOverlapped* AllocateNew();
    private void SetData(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    internal static void Free(Win32ThreadPoolNativeOverlapped* overlapped);
    internal static NativeOverlapped* ToNativeOverlapped(Win32ThreadPoolNativeOverlapped* overlapped);
    internal static Win32ThreadPoolNativeOverlapped* FromNativeOverlapped(NativeOverlapped* overlapped);
    internal static void CompleteWithCallback(UInt32 errorCode, UInt32 bytesWritten, Win32ThreadPoolNativeOverlapped* overlapped);
    private static void OnExecutionContextCallback(object state);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    private static Exception CreateArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArrayTypeMismatchException();
    private static Exception CreateArrayTypeMismatchException();
    internal static void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    private static Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    internal static void ThrowArgumentException_DestinationTooShort();
    private static Exception CreateArgumentException_DestinationTooShort();
    internal static void ThrowIndexOutOfRangeException();
    private static Exception CreateIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    private static Exception CreateArgumentOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    private static Exception CreateArgumentOutOfRangeException_PrecisionTooLarge();
    internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    private static Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit();
    internal static void ThrowInvalidOperationException();
    private static Exception CreateInvalidOperationException();
    internal static void ThrowInvalidOperationException_OutstandingReferences();
    private static Exception CreateInvalidOperationException_OutstandingReferences();
    internal static void ThrowInvalidOperationException_UnexpectedSegmentType();
    private static Exception CreateInvalidOperationException_UnexpectedSegmentType();
    internal static void ThrowInvalidOperationException_EndPositionNotReached();
    private static Exception CreateInvalidOperationException_EndPositionNotReached();
    internal static void ThrowArgumentOutOfRangeException_PositionOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_PositionOutOfRange();
    internal static void ThrowArgumentOutOfRangeException_OffsetOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_OffsetOutOfRange();
    internal static void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
    private static Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
    internal static void ThrowFormatException_BadFormatSpecifier();
    private static Exception CreateFormatException_BadFormatSpecifier();
    internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    private static Exception CreateArgumentException_OverlapAlignmentMismatch();
    internal static void ThrowNotSupportedException();
    private static Exception CreateThrowNotSupportedException();
    public static bool TryFormatThrowFormatException(Int32& bytesWritten);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
    public static void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    private static Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    public static void ThrowArgumentValidationException(Array array, int start);
    private static Exception CreateArgumentValidationException(Array array, int start);
    public static void ThrowStartOrEndArgumentValidationException(long start);
    private static Exception CreateStartOrEndArgumentValidationException(long start);
    internal static void ThrowWrongKeyTypeArgumentException(object key, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
    internal static void ThrowKeyNotFoundException();
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowSecurityException(ExceptionResource resource);
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    internal static void ThrowUnauthorizedAccessException(ExceptionResource resource);
    internal static void ThrowObjectDisposedException(string objectName, ExceptionResource resource);
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, string resource);
    internal static void ThrowArgumentOutOfRange_IndexException();
    internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    internal static void ThrowArgumentException_Argument_InvalidArrayType();
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    internal static void ThrowAddingDuplicateWithKeyArgumentException(object key);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    internal static void ThrowKeyNotFoundException(object key);
    internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    internal static InvalidOperationException GetInvalidOperationException(string str);
    internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    internal static string GetArgumentName(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    internal static string GetResourceName(ExceptionResource resource);
    internal static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
}
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    private static double MillisecondsPerTick;
    public static long TicksPerSecond;
    private static double SecondsPerTick;
    public static long TicksPerMinute;
    private static double MinutesPerTick;
    public static long TicksPerHour;
    private static double HoursPerTick;
    public static long TicksPerDay;
    private static double DaysPerTick;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static long TicksPerTenthSecond;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, int scale);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    private static void ValidateStyles(TimeSpanStyles style, string parameterName);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
    internal static void ClearCachedData();
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneInfo : object {
    private static string TimeZonesRegistryHive;
    private static string DisplayValue;
    private static string DaylightValue;
    private static string StandardValue;
    private static string MuiDisplayValue;
    private static string MuiDaylightValue;
    private static string MuiStandardValue;
    private static string TimeZoneInfoValue;
    private static string FirstEntryValue;
    private static string LastEntryValue;
    private static int MaxKeyLength;
    private static Lazy`1<bool> lazyHaveRegistry;
    internal static UInt32 TIME_ZONE_ID_INVALID;
    internal static UInt32 ERROR_NO_MORE_ITEMS;
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private static string UtcId;
    private static string LocalId;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    private static TimeSpan MaxOffset;
    private static TimeSpan MinOffset;
    private static bool HaveRegistry { get; }
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private TimeZoneInfo(TIME_ZONE_INFORMATION& zone, bool dstDisabled);
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private static TimeZoneInfo();
    public AdjustmentRule[] GetAdjustmentRules();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static void PopulateAllSystemTimeZonesFromRegistry(CachedData cachedData);
    private static bool CheckDaylightSavingTimeNotSupported(TIME_ZONE_INFORMATION& timeZone);
    private static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
    private static string FindIdFromTimeZoneInformation(TIME_ZONE_INFORMATION& timeZone, Boolean& dstDisabled);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZoneFromWin32Data(TIME_ZONE_INFORMATION& timeZoneInformation, bool dstDisabled);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static bool TransitionTimeFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, TransitionTime& transitionTime, bool readStartDate);
    private static bool TryCreateAdjustmentRules(string id, REG_TZI_FORMAT& defaultTimeZoneInformation, AdjustmentRule[]& rules, Exception& e, int defaultBaseUtcOffset);
    private static bool TryGetTimeZoneEntryFromRegistry(RegistryKey key, string name, REG_TZI_FORMAT& dtzi);
    private static bool TryCompareStandardDate(TIME_ZONE_INFORMATION& timeZone, REG_TZI_FORMAT& registryTimeZoneInfo);
    private static bool TryCompareTimeZoneInformationToRegistry(TIME_ZONE_INFORMATION& timeZone, string id, Boolean& dstDisabled);
    private static string TryGetLocalizedNameByMuiNativeResource(string resource);
    private static string TryGetLocalizedNameByNativeResource(string filePath, int resource);
    private static void GetLocalizedNamesByRegistryKey(RegistryKey key, String& displayName, String& standardName, String& daylightName);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalRegistry(string id, TimeZoneInfo& value, Exception& e);
    private static bool get_HaveRegistry();
    internal static UInt32 EnumDynamicTimeZoneInformation(UInt32 dwIndex, DYNAMIC_TIME_ZONE_INFORMATION& lpTimeZoneInformation);
    internal static UInt32 GetDynamicTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION& pTimeZoneInformation);
    internal static UInt32 GetDynamicTimeZoneInformationEffectiveYears(DYNAMIC_TIME_ZONE_INFORMATION& lpTimeZoneInformation, UInt32& FirstYear, UInt32& LastYear);
    internal static bool GetTimeZoneInformationForYear(ushort wYear, DYNAMIC_TIME_ZONE_INFORMATION& pdtzi, TIME_ZONE_INFORMATION& ptzi);
    internal static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION& timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
    private static bool TransitionTimeFromTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation, TransitionTime& transitionTime, bool readStartDate);
    internal static TimeZoneInfo TryCreateTimeZone(DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation);
    internal static TimeZoneInfo GetLocalTimeZoneInfoWinRTFallback();
    internal static TimeZoneInfo FindSystemTimeZoneByIdWinRTFallback(string id);
    private static void GetSystemTimeZonesWinRTFallback(CachedData cachedData);
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime, TimeZoneInfoOptions flags);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone, TimeZoneInfoOptions flags);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static TimeSpan GetUtcOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static bool IsValidAdjustmentRuleOffest(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static void NormalizeAdjustmentRuleOffset(TimeSpan baseUtcOffset, AdjustmentRule& adjustmentRule);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public class System.Tuple`1 : object {
    private T1 m_Item1;
    public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
[ComVisibleAttribute("True")]
[ComDefaultInterfaceAttribute("System.Runtime.InteropServices._Type")]
[ClassInterfaceAttribute("0")]
public abstract class System.Type : MemberInfo {
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    internal RuntimeTypeHandle _impl;
    internal static string DefaultTypeNameWhenMissingMetadata;
    public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    public MemberTypes MemberType { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsCollectible { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSignatureType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    internal bool IsUserType { get; }
    internal bool IsWindowsRuntimeObject { get; }
    internal bool IsExportedToWindowsRuntime { get; }
    internal bool IsSzArray { get; }
    public bool IsInterface { get; }
    internal string FullNameOrDefault { get; }
    internal string InternalNameIfAvailable { get; }
    internal string NameOrDefault { get; }
    private static Type();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    [ComVisibleAttribute("True")]
public virtual bool IsSubclassOf(Type c);
    public virtual bool IsAssignableFrom(Type c);
    internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameIgnoreCaseImpl(MemberInfo m, object filterCriteria);
    public virtual MemberTypes get_MemberType();
    public sealed virtual Type GetType();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public sealed virtual bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual bool get_IsByRefLike();
    public sealed virtual bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public sealed virtual TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsImport();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsNestedAssembly();
    public sealed virtual bool get_IsNestedFamANDAssem();
    public sealed virtual bool get_IsNestedFamily();
    public sealed virtual bool get_IsNestedFamORAssem();
    public sealed virtual bool get_IsNestedPrivate();
    public sealed virtual bool get_IsNestedPublic();
    public sealed virtual bool get_IsNotPublic();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsAutoLayout();
    public sealed virtual bool get_IsExplicitLayout();
    public sealed virtual bool get_IsLayoutSequential();
    public sealed virtual bool get_IsAnsiClass();
    public sealed virtual bool get_IsAutoClass();
    public sealed virtual bool get_IsUnicodeClass();
    public sealed virtual bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public sealed virtual bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsEnum();
    public sealed virtual bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    public sealed virtual bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSignatureType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual ConstructorInfo get_TypeInitializer();
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(Type[] types);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [ComVisibleAttribute("True")]
public sealed virtual ConstructorInfo[] GetConstructors();
    [ComVisibleAttribute("True")]
public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public sealed virtual MethodInfo GetMethod(string name, Type[] types);
    public sealed virtual MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType);
    public sealed virtual PropertyInfo GetProperty(string name, Type[] types);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public sealed virtual PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    public static Type GetTypeFromCLSID(Guid clsid);
    public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server);
    public abstract virtual Type get_BaseType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public sealed virtual Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    [ComVisibleAttribute("True")]
public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] typeArguments);
    public static Type MakeGenericMethodParameter(int position);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool Equals(Type o);
    public static Binder get_DefaultBinder();
    private sealed virtual override void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    private sealed virtual override void System.Runtime.InteropServices._Type.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Type.GetTypeInfoCount(UInt32& pcTInfo);
    private sealed virtual override void System.Runtime.InteropServices._Type.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal virtual bool get_IsUserType();
    internal virtual MethodInfo GetMethod(MethodInfo fromNoninstanciated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    private static Type internal_from_handle(IntPtr handle);
    internal virtual RuntimeTypeHandle GetTypeHandleInternal();
    internal virtual bool IsWindowsRuntimeObjectImpl();
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    internal bool get_IsWindowsRuntimeObject();
    internal bool get_IsExportedToWindowsRuntime();
    internal virtual bool HasProxyAttributeImpl();
    internal virtual bool get_IsSzArray();
    internal string FormatTypeName();
    internal virtual string FormatTypeName(bool serialization);
    [SecuritySafeCriticalAttribute]
public sealed virtual bool get_IsInterface();
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static bool op_Equality(Type left, Type right);
    public static bool op_Inequality(Type left, Type right);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    internal string get_FullNameOrDefault();
    internal bool IsRuntimeImplemented();
    internal virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal string get_InternalNameIfAvailable();
    internal string get_NameOrDefault();
}
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[IsByRefLikeAttribute]
[CLSCompliantAttribute("False")]
[ComVisibleAttribute("True")]
[NonVersionableAttribute]
public class System.TypedReference : ValueType {
    private RuntimeTypeHandle type;
    private IntPtr Value;
    private IntPtr Type;
    internal bool IsNull { get; }
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    private static void InternalMakeTypedReference(Void* result, object target, IntPtr[] flds, RuntimeType lastFieldType);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    [SecuritySafeCriticalAttribute]
public static object ToObject(TypedReference value);
    internal static object InternalToObject(Void* value);
    internal bool get_IsNull();
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    [SecuritySafeCriticalAttribute]
[CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
}
internal interface System.TypeIdentifier {
    public string InternalName { get; }
    public abstract virtual string get_InternalName();
}
internal class System.TypeIdentifiers : object {
    internal static TypeIdentifier FromDisplay(string displayName);
    internal static TypeIdentifier FromInternal(string internalName);
    internal static TypeIdentifier FromInternal(string internalNameSpace, TypeIdentifier typeName);
    internal static TypeIdentifier WithoutEscape(string simpleName);
}
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
[ComVisibleAttribute("True")]
public class System.TypeLoadException : SystemException {
    private string ClassName;
    private string AssemblyName;
    private string MessageArg;
    internal int ResourceId;
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    private TypeLoadException(string className, string assemblyName);
    [SecurityCriticalAttribute]
private TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    [SecuritySafeCriticalAttribute]
public virtual string get_Message();
    [SecurityCriticalAttribute]
private void SetMessageField();
    public string get_TypeName();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal interface System.TypeName {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual TypeName NestedName(TypeIdentifier innerName);
}
internal enum System.TypeNameFormatFlags : Enum {
    public int value__;
    public static TypeNameFormatFlags FormatBasic;
    public static TypeNameFormatFlags FormatNamespace;
    public static TypeNameFormatFlags FormatFullInst;
    public static TypeNameFormatFlags FormatAssembly;
    public static TypeNameFormatFlags FormatSignature;
    public static TypeNameFormatFlags FormatNoVersion;
    public static TypeNameFormatFlags FormatAngleBrackets;
    public static TypeNameFormatFlags FormatStubInfo;
    public static TypeNameFormatFlags FormatGenericParam;
    public static TypeNameFormatFlags FormatSerialization;
}
internal enum System.TypeNameKind : Enum {
    public int value__;
    public static TypeNameKind Name;
    public static TypeNameKind ToString;
    public static TypeNameKind SerializationName;
    public static TypeNameKind FullName;
}
internal class System.TypeNameParser : object {
    internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
}
internal class System.TypeNames : object {
    internal static TypeName FromDisplay(string displayName);
}
internal class System.TypeSpec : object {
    private TypeIdentifier name;
    private string assembly_name;
    private List`1<TypeIdentifier> nested;
    private List`1<TypeSpec> generic_params;
    private List`1<ModifierSpec> modifier_spec;
    private bool is_byref;
    private string display_fullname;
    internal bool HasModifiers { get; }
    internal bool IsNested { get; }
    internal bool IsByRef { get; }
    internal TypeName Name { get; }
    internal IEnumerable`1<TypeName> Nested { get; }
    internal IEnumerable`1<ModifierSpec> Modifiers { get; }
    internal string DisplayFullName { get; }
    internal TypeName TypeName { get; }
    internal bool get_HasModifiers();
    internal bool get_IsNested();
    internal bool get_IsByRef();
    internal TypeName get_Name();
    internal IEnumerable`1<TypeName> get_Nested();
    internal IEnumerable`1<ModifierSpec> get_Modifiers();
    private string GetDisplayFullName(DisplayNameFormat flags);
    internal string ModifierString();
    private StringBuilder GetModifierString(StringBuilder sb);
    internal string get_DisplayFullName();
    internal static TypeSpec Parse(string typeName);
    internal static string EscapeDisplayName(string internalName);
    internal static string UnescapeInternalName(string displayName);
    internal static bool NeedsEscaping(string internalName);
    internal Type Resolve(Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private void AddName(string type_name);
    private void AddModifier(ModifierSpec md);
    private static void SkipSpace(string name, Int32& pos);
    private static void BoundCheck(int idx, string s);
    private static TypeIdentifier ParsedTypeIdentifier(string displayName);
    private static TypeSpec Parse(string name, Int32& p, bool is_recurse, bool allow_aqn);
    internal TypeName TypeNameWithoutModifiers();
    internal TypeName get_TypeName();
}
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [SecuritySafeCriticalAttribute]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[ComVisibleAttribute("True")]
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    public static UIntPtr Zero;
    private Void* _pointer;
    public static int Size { get; }
    public UIntPtr(ulong value);
    public UIntPtr(UInt32 value);
    [CLSCompliantAttribute("False")]
public UIntPtr(Void* value);
    private static UIntPtr();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public UInt32 ToUInt32();
    public ulong ToUInt64();
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static ulong op_Explicit(UIntPtr value);
    public static UInt32 op_Explicit(UIntPtr value);
    public static UIntPtr op_Explicit(ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(UIntPtr value);
    public static UIntPtr op_Explicit(UInt32 value);
    public static int get_Size();
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
}
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.UnitySerializationHolder : object {
    internal static int EmptyUnity;
    internal static int NullUnity;
    internal static int MissingUnity;
    internal static int RuntimeTypeUnity;
    internal static int ModuleUnity;
    internal static int AssemblyUnity;
    internal static int GenericParameterTypeUnity;
    internal static int PartialInstantiationTypeUnity;
    internal static int Pointer;
    internal static int Array;
    internal static int SzArray;
    internal static int ByRef;
    private Type[] m_instantiation;
    private Int32[] m_elementTypes;
    private int m_genericParameterPosition;
    private Type m_declaringType;
    private MethodBase m_declaringMethod;
    private string m_data;
    private string m_assemblyName;
    private int m_unityType;
    internal UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, Missing missing);
    internal static RuntimeType AddElementTypes(SerializationInfo info, RuntimeType type);
    internal Type MakeElementTypes(Type type);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType);
    internal static void GetUnitySerializationInfo(SerializationInfo info, RuntimeType type);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType, string data, RuntimeAssembly assembly);
    private void ThrowInsufficientInformation(string field);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual object GetRealObject(StreamingContext context);
}
internal class System.UnSafeCharBuffer : ValueType {
    [SecurityCriticalAttribute]
private Char* m_buffer;
    private int m_totalSize;
    private int m_length;
    public int Length { get; }
    [SecurityCriticalAttribute]
public UnSafeCharBuffer(Char* buffer, int bufferSize);
    [SecuritySafeCriticalAttribute]
public void AppendString(string stringToAppend);
    public int get_Length();
}
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`1(T1 item1);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[ComVisibleAttribute("True")]
public abstract class System.ValueType : object {
    private static bool InternalEquals(object o1, object o2, Object[]& fields);
    internal static bool DefaultEquals(object o1, object o2);
    public virtual bool Equals(object obj);
    internal static int InternalGetHashCode(object o, Object[]& fields);
    public virtual int GetHashCode();
    internal static int GetHashCodeOfPtr(IntPtr ptr);
    public virtual string ToString();
}
internal class System.Variant : ValueType {
    public short vt;
    public ushort wReserved1;
    public ushort wReserved2;
    public ushort wReserved3;
    public long llVal;
    public int lVal;
    public byte bVal;
    public short iVal;
    public float fltVal;
    public double dblVal;
    public short boolVal;
    public IntPtr bstrVal;
    public sbyte cVal;
    public ushort uiVal;
    public UInt32 ulVal;
    public ulong ullVal;
    public int intVal;
    public UInt32 uintVal;
    public IntPtr pdispVal;
    public BRECORD bRecord;
    public void SetValue(object obj);
    public static object GetValueAt(int vt, IntPtr addr);
    public object GetValue();
    public void Clear();
}
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    private int DefaultFormatFieldCount { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    public Version(string version);
    private Version(Version version);
    public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int fieldCount);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private int get_DefaultFormatFieldCount();
    private StringBuilder ToCachedStringBuilder(int fieldCount);
    public static Version Parse(string input);
    public static Version Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Version& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    private static Version ParseVersion(ReadOnlySpan`1<char> input, bool throwOnFailure);
    private static bool TryParseComponent(ReadOnlySpan`1<char> component, string componentName, bool throwOnFailure, Int32& parsedComponent);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
public class System.Void : ValueType {
}
[ComVisibleAttribute("True")]
public class System.WeakReference : object {
    private bool isLongReference;
    private GCHandle gcHandle;
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public bool TrackResurrection { get; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    private void AllocateHandle(object target);
    public virtual bool get_IsAlive();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual bool get_TrackResurrection();
    protected virtual override void Finalize();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.WeakReference`1 : object {
    private GCHandle handle;
    private bool trackResurrection;
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    private WeakReference`1(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
    public bool TryGetTarget(T& target);
    protected virtual override void Finalize();
}
internal class System.WindowsConsoleDriver : object {
    private IntPtr inputHandle;
    private IntPtr outputHandle;
    private short defaultAttribute;
    public ConsoleColor BackgroundColor { get; public set; }
    public int BufferHeight { get; public set; }
    public int BufferWidth { get; public set; }
    public bool CapsLock { get; }
    public int CursorLeft { get; public set; }
    public int CursorSize { get; public set; }
    public int CursorTop { get; public set; }
    public bool CursorVisible { get; public set; }
    public ConsoleColor ForegroundColor { get; public set; }
    public bool KeyAvailable { get; }
    public bool Initialized { get; }
    public int LargestWindowHeight { get; }
    public int LargestWindowWidth { get; }
    public bool NumberLock { get; }
    public string Title { get; public set; }
    public bool TreatControlCAsInput { get; public set; }
    public int WindowHeight { get; public set; }
    public int WindowLeft { get; public set; }
    public int WindowTop { get; public set; }
    public int WindowWidth { get; public set; }
    private static ConsoleColor GetForeground(short attr);
    private static ConsoleColor GetBackground(short attr);
    private static short GetAttrForeground(int attr, ConsoleColor color);
    private static short GetAttrBackground(int attr, ConsoleColor color);
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual void set_BackgroundColor(ConsoleColor value);
    public sealed virtual int get_BufferHeight();
    public sealed virtual void set_BufferHeight(int value);
    public sealed virtual int get_BufferWidth();
    public sealed virtual void set_BufferWidth(int value);
    public sealed virtual bool get_CapsLock();
    public sealed virtual int get_CursorLeft();
    public sealed virtual void set_CursorLeft(int value);
    public sealed virtual int get_CursorSize();
    public sealed virtual void set_CursorSize(int value);
    public sealed virtual int get_CursorTop();
    public sealed virtual void set_CursorTop(int value);
    public sealed virtual bool get_CursorVisible();
    public sealed virtual void set_CursorVisible(bool value);
    public sealed virtual ConsoleColor get_ForegroundColor();
    public sealed virtual void set_ForegroundColor(ConsoleColor value);
    public sealed virtual bool get_KeyAvailable();
    public sealed virtual bool get_Initialized();
    public sealed virtual int get_LargestWindowHeight();
    public sealed virtual int get_LargestWindowWidth();
    public sealed virtual bool get_NumberLock();
    public sealed virtual string get_Title();
    public sealed virtual void set_Title(string value);
    public sealed virtual bool get_TreatControlCAsInput();
    public sealed virtual void set_TreatControlCAsInput(bool value);
    public sealed virtual int get_WindowHeight();
    public sealed virtual void set_WindowHeight(int value);
    public sealed virtual int get_WindowLeft();
    public sealed virtual void set_WindowLeft(int value);
    public sealed virtual int get_WindowTop();
    public sealed virtual void set_WindowTop(int value);
    public sealed virtual int get_WindowWidth();
    public sealed virtual void set_WindowWidth(int value);
    public sealed virtual void Beep(int frequency, int duration);
    public sealed virtual void Clear();
    public sealed virtual void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
    public sealed virtual void Init();
    public sealed virtual string ReadLine();
    public sealed virtual ConsoleKeyInfo ReadKey(bool intercept);
    public sealed virtual void ResetColor();
    public sealed virtual void SetBufferSize(int width, int height);
    public sealed virtual void SetCursorPosition(int left, int top);
    public sealed virtual void SetWindowPosition(int left, int top);
    public sealed virtual void SetWindowSize(int width, int height);
    private static bool IsModifierKey(short virtualKeyCode);
    private static IntPtr GetStdHandle(Handles handle);
    private static void _Beep(int frequency, int duration);
    private static bool GetConsoleScreenBufferInfo(IntPtr handle, ConsoleScreenBufferInfo& info);
    private static bool FillConsoleOutputCharacter(IntPtr handle, char c, int size, Coord coord, Int32& written);
    private static bool FillConsoleOutputAttribute(IntPtr handle, short c, int size, Coord coord, Int32& written);
    private static bool SetConsoleCursorPosition(IntPtr handle, Coord coord);
    private static bool SetConsoleTextAttribute(IntPtr handle, short attribute);
    private static bool SetConsoleScreenBufferSize(IntPtr handle, Coord newSize);
    private static bool SetConsoleWindowInfo(IntPtr handle, bool absolute, SmallRect& rect);
    private static int GetConsoleTitle(StringBuilder sb, int size);
    private static bool SetConsoleTitle(string title);
    private static bool GetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info);
    private static bool SetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info);
    private static short GetKeyState(int virtKey);
    private static bool GetConsoleMode(IntPtr handle, Int32& mode);
    private static bool SetConsoleMode(IntPtr handle, int mode);
    private static bool PeekConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& eventsRead);
    private static bool ReadConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& nread);
    private static Coord GetLargestConsoleWindowSize(IntPtr handle);
    private static bool ReadConsoleOutput(IntPtr handle, Void* buffer, Coord bsize, Coord bpos, SmallRect& region);
    private static bool WriteConsoleOutput(IntPtr handle, CharInfo[] buffer, Coord bsize, Coord bpos, SmallRect& region);
}
internal class Unity.ThrowStub : ObjectDisposedException {
    public static void ThrowNotSupportedException();
}
