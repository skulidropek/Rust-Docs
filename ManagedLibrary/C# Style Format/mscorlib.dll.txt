internal Consts : object {
public string MonoVersion
public string MonoCompany
public string MonoProduct
public string MonoCopyright
public string FxVersion
public string VsVersion
public string FxFileVersion
public string VsFileVersion
public string AssemblyI18N
public string AssemblyMicrosoft_VisualStudio
public string AssemblyMicrosoft_VisualStudio_Web
public string AssemblyMicrosoft_VSDesigner
public string AssemblyMono_Http
public string AssemblyMono_Posix
public string AssemblyMono_Security
public string AssemblyMono_Messaging_RabbitMQ
public string AssemblyCorlib
public string AssemblySystem
public string AssemblySystem_Data
public string AssemblySystem_Design
public string AssemblySystem_DirectoryServices
public string AssemblySystem_Drawing
public string AssemblySystem_Drawing_Design
public string AssemblySystem_Messaging
public string AssemblySystem_Security
public string AssemblySystem_ServiceProcess
public string AssemblySystem_Web
public string AssemblySystem_Windows_Forms
public string AssemblySystem_Core
}
internal Locale : object {
public string GetText(string msg)
public string GetText(string fmt, Object[] args)
}
internal Microsoft.Win32.ExpandString : object {
private string value
public void .ctor(string s)
public string ToString()
public string Expand()
}
internal Microsoft.Win32.IRegistryApi {
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writtable)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options)
public void SetValue(RegistryKey rkey, string name, object value)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public void DeleteValue(RegistryKey rkey, string value, bool throw_if_missing)
public void DeleteKey(RegistryKey rkey, string keyName, bool throw_if_missing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
public string ToString(RegistryKey rkey)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
}
internal Microsoft.Win32.KeyHandler : object {
private Hashtable key_to_handler
private Hashtable dir_to_handler
public string Dir
private Hashtable values
private string file
private bool dirty
private Dictionary`2<string, int> <>f__switch$map1
public int ValueCount
public bool IsMarkedForDeletion
private string UserStore
private string MachineStore
private void .ctor(RegistryKey rkey, string basedir)
public void Load()
private void LoadKey(SecurityElement se)
public RegistryKey Ensure(RegistryKey rkey, string extra, bool writable)
public RegistryKey Probe(RegistryKey rkey, string extra, bool writable)
private string CombineName(RegistryKey rkey, string extra)
public KeyHandler Lookup(RegistryKey rkey, bool createNonExisting)
public void Drop(RegistryKey rkey)
public void Drop(string dir)
public object GetValue(string name, RegistryValueOptions options)
public void SetValue(string name, object value)
public String[] GetValueNames()
public void SetValue(string name, object value, RegistryValueKind valueKind)
private void SetDirty()
public void DirtyTimeout(object state)
public void Flush()
public bool ValueExists(string name)
public int get_ValueCount()
public bool get_IsMarkedForDeletion()
public void RemoveValue(string name)
protected void Finalize()
private void Save()
private void AssertNotMarkedForDeletion()
private string get_UserStore()
private string get_MachineStore()
}
public Microsoft.Win32.Registry : object {
public RegistryKey ClassesRoot
public RegistryKey CurrentConfig
public RegistryKey CurrentUser
public RegistryKey DynData
public RegistryKey LocalMachine
public RegistryKey PerformanceData
public RegistryKey Users
private Dictionary`2<string, int> <>f__switch$map0
private RegistryKey ToKey(string keyName, bool setting)
public void SetValue(string keyName, string valueName, object value)
public void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind)
public object GetValue(string keyName, string valueName, object defaultValue)
}
public Microsoft.Win32.RegistryHive : Enum {
public int value__
public RegistryHive ClassesRoot
public RegistryHive CurrentConfig
public RegistryHive CurrentUser
public RegistryHive DynData
public RegistryHive LocalMachine
public RegistryHive PerformanceData
public RegistryHive Users
}
public Microsoft.Win32.RegistryKey : MarshalByRefObject {
private object handle
private object hive
private string qname
private bool isRemoteRoot
private bool isWritable
private IRegistryApi RegistryApi
public string Name
public int SubKeyCount
public int ValueCount
internal bool IsRoot
private bool IsWritable
internal RegistryHive Hive
internal object Handle
internal void .ctor(RegistryHive hiveId)
internal void .ctor(RegistryHive hiveId, IntPtr keyHandle, bool remoteRoot)
internal void .ctor(object data, string keyName, bool writable)
private void System.IDisposable.Dispose()
protected void Finalize()
public string get_Name()
public void Flush()
public void Close()
public int get_SubKeyCount()
public int get_ValueCount()
public void SetValue(string name, object value)
public void SetValue(string name, object value, RegistryValueKind valueKind)
public RegistryKey OpenSubKey(string name)
public RegistryKey OpenSubKey(string name, bool writable)
public object GetValue(string name)
public object GetValue(string name, object defaultValue)
public object GetValue(string name, object defaultValue, RegistryValueOptions options)
public RegistryValueKind GetValueKind(string name)
public RegistryKey CreateSubKey(string subkey)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck)
public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity)
public void DeleteSubKey(string subkey)
public void DeleteSubKey(string subkey, bool throwOnMissingSubKey)
public void DeleteSubKeyTree(string subkey)
public void DeleteValue(string name)
public void DeleteValue(string name, bool throwOnMissingValue)
public RegistrySecurity GetAccessControl()
public RegistrySecurity GetAccessControl(AccessControlSections includeSections)
public String[] GetSubKeyNames()
public String[] GetValueNames()
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck)
public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights)
public void SetAccessControl(RegistrySecurity registrySecurity)
public string ToString()
internal bool get_IsRoot()
private bool get_IsWritable()
internal RegistryHive get_Hive()
internal object get_Handle()
private void AssertKeyStillValid()
private void AssertKeyNameNotNull(string subKeyName)
private void AssertKeyNameLength(string name)
private void DeleteChildKeysAndValues()
internal string DecodeString(Byte[] data)
internal IOException CreateMarkedForDeletionException()
private string GetHiveName(RegistryHive hive)
}
public Microsoft.Win32.RegistryKeyPermissionCheck : Enum {
public int value__
public RegistryKeyPermissionCheck Default
public RegistryKeyPermissionCheck ReadSubTree
public RegistryKeyPermissionCheck ReadWriteSubTree
}
public Microsoft.Win32.RegistryValueKind : Enum {
public int value__
public RegistryValueKind Unknown
public RegistryValueKind String
public RegistryValueKind ExpandString
public RegistryValueKind Binary
public RegistryValueKind DWord
public RegistryValueKind MultiString
public RegistryValueKind QWord
}
public Microsoft.Win32.RegistryValueOptions : Enum {
public int value__
public RegistryValueOptions None
public RegistryValueOptions DoNotExpandEnvironmentNames
}
public Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
public bool IsInvalid
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
public bool IsInvalid
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr preexistingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
public Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
public bool IsInvalid
protected void .ctor(bool ownsHandle)
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
public bool IsInvalid
protected void .ctor(bool ownsHandle)
public bool get_IsInvalid()
}
public Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
public void .ctor(IntPtr existingHandle, bool ownsHandle)
protected bool ReleaseHandle()
}
internal Microsoft.Win32.UnixRegistryApi : object {
private string ToUnix(string keyname)
private bool IsWellKnownKey(string parentKeyName, string keyname)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyname)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writable)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options)
public void SetValue(RegistryKey rkey, string name, object value)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public void DeleteValue(RegistryKey rkey, string name, bool throw_if_missing)
public void DeleteKey(RegistryKey rkey, string keyname, bool throw_if_missing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
public string ToString(RegistryKey rkey)
private RegistryKey CreateSubKey(RegistryKey rkey, string keyname, bool writable)
}
internal Microsoft.Win32.Win32RegistryApi : object {
private int OpenRegKeyRead
private int OpenRegKeyWrite
private int Int32ByteSize
private int BufferMaxLength
private int NativeBytesPerCharacter
private int RegCreateKey(IntPtr keyBase, string keyName, IntPtr& keyHandle)
private int RegCloseKey(IntPtr keyHandle)
private int RegConnectRegistry(string machineName, IntPtr hKey, IntPtr& keyHandle)
private int RegFlushKey(IntPtr keyHandle)
private int RegOpenKeyEx(IntPtr keyBase, string keyName, IntPtr reserved, int access, IntPtr& keyHandle)
private int RegDeleteKey(IntPtr keyHandle, string valueName)
private int RegDeleteValue(IntPtr keyHandle, string valueName)
private int RegEnumKey(IntPtr keyBase, int index, StringBuilder nameBuffer, int bufferLength)
private int RegEnumValue(IntPtr keyBase, int index, StringBuilder nameBuffer, Int32& nameLength, IntPtr reserved, RegistryValueKind& type, IntPtr data, IntPtr dataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, string data, int rawDataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, Byte[] rawData, int rawDataLength)
private int RegSetValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, Int32& data, int rawDataLength)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, IntPtr zero, Int32& dataSize)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, Byte[] data, Int32& dataSize)
private int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind& type, Int32& data, Int32& dataSize)
private IntPtr GetHandle(RegistryKey key)
private bool IsHandleValid(RegistryKey key)
public object GetValue(RegistryKey rkey, string name, object defaultValue, RegistryValueOptions options)
public void SetValue(RegistryKey rkey, string name, object value, RegistryValueKind valueKind)
public void SetValue(RegistryKey rkey, string name, object value)
private int GetBinaryValue(RegistryKey rkey, string name, RegistryValueKind type, Byte[]& data, int size)
public int SubKeyCount(RegistryKey rkey)
public int ValueCount(RegistryKey rkey)
public RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName)
public RegistryKey OpenSubKey(RegistryKey rkey, string keyName, bool writable)
public void Flush(RegistryKey rkey)
public void Close(RegistryKey rkey)
public RegistryKey CreateSubKey(RegistryKey rkey, string keyName)
public void DeleteKey(RegistryKey rkey, string keyName, bool shouldThrowWhenKeyMissing)
public void DeleteValue(RegistryKey rkey, string value, bool shouldThrowWhenKeyMissing)
public String[] GetSubKeyNames(RegistryKey rkey)
public String[] GetValueNames(RegistryKey rkey)
private void GenerateException(int errorCode)
public string ToString(RegistryKey rkey)
internal string CombineName(RegistryKey rkey, string localName)
}
internal Microsoft.Win32.Win32ResultCode : object {
public int Success
public int FileNotFound
public int AccessDenied
public int InvalidParameter
public int MoreData
public int NetworkPathNotFound
public int NoMoreEntries
public int MarkedForDeletion
}
internal Mono.DataConverter : object {
private DataConverter SwapConv
private DataConverter CopyConv
public bool IsLittleEndian
public DataConverter LittleEndian
public DataConverter BigEndian
public DataConverter Native
public double GetDouble(Byte[] data, int index)
public float GetFloat(Byte[] data, int index)
public long GetInt64(Byte[] data, int index)
public int GetInt32(Byte[] data, int index)
public short GetInt16(Byte[] data, int index)
public UInt32 GetUInt32(Byte[] data, int index)
public ushort GetUInt16(Byte[] data, int index)
public ulong GetUInt64(Byte[] data, int index)
public void PutBytes(Byte[] dest, int destIdx, double value)
public void PutBytes(Byte[] dest, int destIdx, float value)
public void PutBytes(Byte[] dest, int destIdx, int value)
public void PutBytes(Byte[] dest, int destIdx, long value)
public void PutBytes(Byte[] dest, int destIdx, short value)
public void PutBytes(Byte[] dest, int destIdx, ushort value)
public void PutBytes(Byte[] dest, int destIdx, UInt32 value)
public void PutBytes(Byte[] dest, int destIdx, ulong value)
public Byte[] GetBytes(double value)
public Byte[] GetBytes(float value)
public Byte[] GetBytes(int value)
public Byte[] GetBytes(long value)
public Byte[] GetBytes(short value)
public Byte[] GetBytes(ushort value)
public Byte[] GetBytes(UInt32 value)
public Byte[] GetBytes(ulong value)
public DataConverter get_LittleEndian()
public DataConverter get_BigEndian()
public DataConverter get_Native()
private int Align(int current, int align)
public Byte[] Pack(string description, Object[] args)
public Byte[] PackEnumerable(string description, IEnumerable args)
private bool PackOne(PackContext b, object oarg)
private bool Prepare(Byte[] buffer, Int32& idx, int size, Boolean& align)
public IList Unpack(string description, Byte[] buffer, int startIndex)
internal void Check(Byte[] dest, int destIdx, int size)
}
internal Mono.Globalization.Unicode.CodePointIndexer : object {
private TableRange[] ranges
public int TotalCount
private int defaultIndex
private int defaultCP
public void .ctor(Int32[] starts, Int32[] ends, int defaultIndex, int defaultCP)
public Array CompressArray(Array source, Type type, CodePointIndexer indexer)
public int ToIndex(int cp)
public int ToCodePoint(int i)
}
internal Mono.Globalization.Unicode.Contraction : object {
public Char[] Source
public string Replacement
public Byte[] SortKey
public void .ctor(Char[] source, string replacement, Byte[] sortkey)
}
internal Mono.Globalization.Unicode.ContractionComparer : object {
public ContractionComparer Instance
public int Compare(object o1, object o2)
}
internal Mono.Globalization.Unicode.Level2Map : object {
public byte Source
public byte Replace
public void .ctor(byte source, byte replace)
}
internal Mono.Globalization.Unicode.Level2MapComparer : object {
public Level2MapComparer Instance
public int Compare(object o1, object o2)
}
internal Mono.Globalization.Unicode.MSCompatUnicodeTable : object {
private int ResourceVersionSize
public int MaxExpansionLength
private Byte* ignorableFlags
private Byte* categories
private Byte* level1
private Byte* level2
private Byte* level3
private Byte* cjkCHScategory
private Byte* cjkCHTcategory
private Byte* cjkJAcategory
private Byte* cjkKOcategory
private Byte* cjkCHSlv1
private Byte* cjkCHTlv1
private Byte* cjkJAlv1
private Byte* cjkKOlv1
private Byte* cjkKOlv2
private Char[] tailoringArr
private TailoringInfo[] tailoringInfos
private object forLock
public bool isReady
private Dictionary`2<string, int> <>f__switch$map2
private Dictionary`2<string, int> <>f__switch$map3
private Dictionary`2<string, int> <>f__switch$map4
public bool IsReady
public TailoringInfo GetTailoringInfo(int lcid)
public void BuildTailoringTables(CultureInfo culture, TailoringInfo t, Contraction[]& contractions, Level2Map[]& diacriticals)
private void SetCJKReferences(string name, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
public byte Category(int cp)
public byte Level1(int cp)
public byte Level2(int cp)
public byte Level3(int cp)
public bool IsSortable(string s)
public bool IsSortable(int cp)
public bool IsIgnorable(int cp)
public bool IsIgnorable(int cp, byte flag)
public bool IsIgnorableSymbol(int cp)
public bool IsIgnorableNonSpacing(int cp)
public int ToKanaTypeInsensitive(int i)
public int ToWidthCompat(int i)
public bool HasSpecialWeight(char c)
public byte GetJapaneseDashType(char c)
public bool IsHalfWidthKana(char c)
public bool IsHiragana(char c)
public bool IsJapaneseSmallLetter(char c)
public bool get_IsReady()
private IntPtr GetResource(string name)
private UInt32 UInt32FromBytePtr(Byte* raw, UInt32 idx)
public void FillCJK(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
private void FillCJKCore(string culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& cjkLv2Indexer, Byte*& lv2Table)
}
internal Mono.Globalization.Unicode.MSCompatUnicodeTableUtil : object {
public byte ResourceVersion
public CodePointIndexer Ignorable
public CodePointIndexer Category
public CodePointIndexer Level1
public CodePointIndexer Level2
public CodePointIndexer Level3
public CodePointIndexer CjkCHS
public CodePointIndexer Cjk
}
internal Mono.Globalization.Unicode.Normalization : object {
public int NoNfd
public int NoNfkd
public int NoNfc
public int MaybeNfc
public int NoNfkc
public int MaybeNfkc
public int FullCompositionExclusion
public int IsUnsafe
private int HangulSBase
private int HangulLBase
private int HangulVBase
private int HangulTBase
private int HangulLCount
private int HangulVCount
private int HangulTCount
private int HangulNCount
private int HangulSCount
private Byte* props
private Int32* mappedChars
private Int16* charMapIndex
private Int16* helperIndex
private UInt16* mapIdxToComposite
private Byte* combiningClass
private object forLock
public bool isReady
public bool IsReady
private UInt32 PropValue(int cp)
private int CharMapIdx(int cp)
private int GetNormalizedStringLength(int ch)
private byte GetCombiningClass(int c)
private int GetPrimaryCompositeFromMapIndex(int src)
private int GetPrimaryCompositeHelperIndex(int cp)
private int GetPrimaryCompositeCharIndex(object chars, int start)
private string Compose(string source, int checkType)
private StringBuilder Combine(string source, int start, int checkType)
private bool CanBePrimaryComposite(int i)
private void Combine(StringBuilder sb, int start, int checkType)
private int GetPrimaryCompositeMapIndex(object o, int cur, int bufferPos)
private string Decompose(string source, int checkType)
private void Decompose(string source, StringBuilder& sb, int checkType)
private void ReorderCanonical(string src, StringBuilder& sb, int start)
private void DecomposeChar(StringBuilder& sb, Int32[]& buf, string s, int i, Int32& start)
public NormalizationCheck QuickCheck(char c, int type)
private bool GetCanonicalHangul(int s, Int32[] buf, int bufIdx)
public void GetCanonical(int c, Int32[] buf, int bufIdx)
public bool IsNormalized(string source, int type)
public string Normalize(string source, int type)
public bool get_IsReady()
private void load_normalization_resource(IntPtr& props, IntPtr& mappedChars, IntPtr& charMapIndex, IntPtr& helperIndex, IntPtr& mapIdxToComposite, IntPtr& combiningClass)
}
internal Mono.Globalization.Unicode.NormalizationCheck : Enum {
public int value__
public NormalizationCheck Yes
public NormalizationCheck No
public NormalizationCheck Maybe
}
internal Mono.Globalization.Unicode.NormalizationTableUtil : object {
public CodePointIndexer Prop
public CodePointIndexer Map
public CodePointIndexer Combining
public CodePointIndexer Composite
public CodePointIndexer Helper
public int PropCount
public int MapCount
public int PropIdx(int cp)
public int PropCP(int index)
public int get_PropCount()
public int MapIdx(int cp)
public int MapCP(int index)
public int CbIdx(int cp)
public int CbCP(int index)
public int get_MapCount()
}
internal Mono.Globalization.Unicode.SimpleCollator : object {
private int UnsafeFlagLength
private bool QuickCheckDisabled
private SimpleCollator invariant
private TextInfo textInfo
private bool frenchSort
private Byte* cjkCatTable
private Byte* cjkLv1Table
private CodePointIndexer cjkIndexer
private Byte* cjkLv2Table
private CodePointIndexer cjkLv2Indexer
private int lcid
private Contraction[] contractions
private Level2Map[] level2Maps
private Byte[] unsafeFlags
public void .ctor(CultureInfo culture)
private void SetCJKTable(CultureInfo culture, CodePointIndexer& cjkIndexer, Byte*& catTable, Byte*& lv1Table, CodePointIndexer& lv2Indexer, Byte*& lv2Table)
private CultureInfo GetNeutralCulture(CultureInfo info)
private byte Category(int cp)
private byte Level1(int cp)
private byte Level2(int cp, ExtenderType ext)
private bool IsHalfKana(int cp, CompareOptions opt)
private Contraction GetContraction(string s, int start, int end)
private Contraction GetContraction(string s, int start, int end, Contraction[] clist)
private Contraction GetTailContraction(string s, int start, int end)
private Contraction GetTailContraction(string s, int start, int end, Contraction[] clist)
private Contraction GetContraction(char c)
private Contraction GetContraction(char c, Contraction[] clist)
private int FilterOptions(int i, CompareOptions opt)
private ExtenderType GetExtenderType(int i)
private byte ToDashTypeValue(ExtenderType ext, CompareOptions opt)
private int FilterExtender(int i, ExtenderType ext, CompareOptions opt)
private bool IsIgnorable(int i, CompareOptions opt)
private bool IsSafe(int i)
public SortKey GetSortKey(string s)
public SortKey GetSortKey(string s, CompareOptions options)
public SortKey GetSortKey(string s, int start, int length, CompareOptions options)
private void GetSortKey(string s, int start, int end, SortKeyBuffer buf, CompareOptions opt)
private void FillSortKeyRaw(int i, ExtenderType ext, SortKeyBuffer buf, CompareOptions opt)
private void FillSurrogateSortKeyRaw(int i, SortKeyBuffer buf)
public int Compare(string s1, string s2)
public int Compare(string s1, string s2, CompareOptions options)
private int CompareOrdinal(string s1, int idx1, int len1, string s2, int idx2, int len2)
private int CompareQuick(string s1, int idx1, int len1, string s2, int idx2, int len2, Boolean& sourceConsumed, Boolean& targetConsumed, bool immediateBreakup)
private int CompareOrdinalIgnoreCase(string s1, int idx1, int len1, string s2, int idx2, int len2)
public int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options)
private void ClearBuffer(Byte* buffer, int size)
private bool QuickCheckPossible(string s1, int idx1, int end1, string s2, int idx2, int end2)
private int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, Boolean& targetConsumed, Boolean& sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, Context& ctx)
private int CompareFlagPair(bool b1, bool b2)
public bool IsPrefix(string src, string target, CompareOptions opt)
public bool IsPrefix(string s, string target, int start, int length, CompareOptions opt)
private bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, Context& ctx)
public bool IsSuffix(string src, string target, CompareOptions opt)
public bool IsSuffix(string s, string target, int start, int length, CompareOptions opt)
public int IndexOf(string s, string target, CompareOptions opt)
private int QuickIndexOf(string s, string target, int start, int length, Boolean& testWasUnable)
public int IndexOf(string s, string target, int start, int length, CompareOptions opt)
private int IndexOfOrdinal(string s, string target, int start, int length)
private int IndexOfOrdinalIgnoreCase(string s, string target, int start, int length)
public int IndexOf(string s, char target, CompareOptions opt)
public int IndexOf(string s, char target, int start, int length, CompareOptions opt)
private int IndexOfOrdinal(string s, char target, int start, int length)
private int IndexOfOrdinalIgnoreCase(string s, char target, int start, int length)
private int IndexOfSortKey(string s, int start, int length, Byte* sortkey, char target, int ti, bool noLv4, Context& ctx)
private int IndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx)
public int LastIndexOf(string s, string target, CompareOptions opt)
public int LastIndexOf(string s, string target, int start, int length, CompareOptions opt)
private int LastIndexOfOrdinal(string s, string target, int start, int length)
private int LastIndexOfOrdinalIgnoreCase(string s, string target, int start, int length)
public int LastIndexOf(string s, char target, CompareOptions opt)
public int LastIndexOf(string s, char target, int start, int length, CompareOptions opt)
private int LastIndexOfOrdinal(string s, char target, int start, int length)
private int LastIndexOfOrdinalIgnoreCase(string s, char target, int start, int length)
private int LastIndexOfSortKey(string s, int start, int orgStart, int length, Byte* sortkey, int ti, bool noLv4, Context& ctx)
private int LastIndexOf(string s, string target, int start, int length, Byte* targetSortKey, Context& ctx)
private bool MatchesForward(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, Context& ctx)
private bool MatchesForwardCore(string s, Int32& idx, int end, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx)
private bool MatchesPrimitive(CompareOptions opt, Byte* source, int si, ExtenderType ext, Byte* target, int ti, bool noLv4)
private bool MatchesBackward(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, Context& ctx)
private bool MatchesBackwardCore(string s, Int32& idx, int end, int orgStart, int ti, Byte* sortkey, bool noLv4, ExtenderType ext, Contraction& ct, Context& ctx)
}
internal Mono.Globalization.Unicode.SortKeyBuffer : object {
private int l1
private int l2
private int l3
private int l4s
private int l4t
private int l4k
private int l4w
private int l5
private Byte[] l1b
private Byte[] l2b
private Byte[] l3b
private Byte[] l4sb
private Byte[] l4tb
private Byte[] l4kb
private Byte[] l4wb
private Byte[] l5b
private string source
private bool processLevel2
private bool frenchSort
private bool frenchSorted
private int lcid
private CompareOptions options
public void .ctor(int lcid)
public void Reset()
internal void ClearBuffer()
internal void Initialize(CompareOptions options, int lcid, string s, bool frenchSort)
internal void AppendCJKExtension(byte lv1msb, byte lv1lsb)
internal void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth)
internal void AppendNormal(byte category, byte lv1, byte lv2, byte lv3)
private void AppendLevel5(byte category, byte lv1)
private void AppendBufferPrimitive(byte value, Byte[]& buf, Int32& bidx)
public SortKey GetResultAndReset()
private int GetOptimizedLength(Byte[] data, int len, byte defaultValue)
public SortKey GetResult()
}
internal Mono.Globalization.Unicode.TailoringInfo : object {
public int LCID
public int TailoringIndex
public int TailoringCount
public bool FrenchSort
public void .ctor(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort)
}
internal Mono.Interop.ComInteropProxy : RealProxy {
private __ComObject com_object
private int ref_count
private string type_name
public string TypeName
private void .ctor(Type t)
private void .ctor(IntPtr pUnk)
internal void .ctor(IntPtr pUnk, Type t)
private void AddProxy(IntPtr pItf, ComInteropProxy proxy)
internal ComInteropProxy FindProxy(IntPtr pItf)
private void CacheProxy()
internal ComInteropProxy GetProxy(IntPtr pItf, Type t)
internal ComInteropProxy CreateProxy(Type t)
public IMessage Invoke(IMessage msg)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
internal Mono.Math.BigInteger : object {
private UInt32 DEFAULT_LEN
private string WouldReturnNegVal
private UInt32 length
private UInt32[] data
internal UInt32[] smallPrimes
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
public void .ctor(Sign sign, UInt32 len)
public void .ctor(BigInteger bi)
public void .ctor(BigInteger bi, UInt32 len)
public void .ctor(Byte[] inData)
public void .ctor(UInt32[] inData)
public void .ctor(UInt32 ui)
public void .ctor(ulong ul)
public BigInteger Parse(string number)
public BigInteger Add(BigInteger bi1, BigInteger bi2)
public BigInteger Subtract(BigInteger bi1, BigInteger bi2)
public int Modulus(BigInteger bi, int i)
public UInt32 Modulus(BigInteger bi, UInt32 ui)
public BigInteger Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger Divid(BigInteger bi, int i)
public BigInteger Divid(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger Multiply(BigInteger bi, int i)
private RandomNumberGenerator get_Rng()
public BigInteger GenerateRandom(int bits, RandomNumberGenerator rng)
public BigInteger GenerateRandom(int bits)
public void Randomize(RandomNumberGenerator rng)
public void Randomize()
public int BitCount()
public bool TestBit(UInt32 bitNum)
public bool TestBit(int bitNum)
public void SetBit(UInt32 bitNum)
public void ClearBit(UInt32 bitNum)
public void SetBit(UInt32 bitNum, bool value)
public int LowestSetBit()
public Byte[] GetBytes()
public Sign Compare(BigInteger bi)
public string ToString(UInt32 radix)
public string ToString(UInt32 radix, string characterSet)
private void Normalize()
public void Clear()
public int GetHashCode()
public string ToString()
public bool Equals(object o)
public BigInteger GCD(BigInteger bi)
public BigInteger ModInverse(BigInteger modulus)
public BigInteger ModPow(BigInteger exp, BigInteger n)
public bool IsProbablePrime()
public BigInteger NextHighestPrime(BigInteger bi)
public BigInteger GeneratePseudoPrime(int bits)
public void Incr2()
public BigInteger op_Implicit(UInt32 value)
public BigInteger op_Implicit(int value)
public BigInteger op_Implicit(ulong value)
public BigInteger op_Addition(BigInteger bi1, BigInteger bi2)
public BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2)
public int op_Modulus(BigInteger bi, int i)
public UInt32 op_Modulus(BigInteger bi, UInt32 ui)
public BigInteger op_Modulus(BigInteger bi1, BigInteger bi2)
public BigInteger op_Division(BigInteger bi, int i)
public BigInteger op_Division(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi1, BigInteger bi2)
public BigInteger op_Multiply(BigInteger bi, int i)
public BigInteger op_LeftShift(BigInteger bi1, int shiftVal)
public BigInteger op_RightShift(BigInteger bi1, int shiftVal)
public bool op_Equality(BigInteger bi1, UInt32 ui)
public bool op_Inequality(BigInteger bi1, UInt32 ui)
public bool op_Equality(BigInteger bi1, BigInteger bi2)
public bool op_Inequality(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThan(BigInteger bi1, BigInteger bi2)
public bool op_LessThan(BigInteger bi1, BigInteger bi2)
public bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2)
public bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2)
}
internal Mono.Math.Prime.ConfidenceFactor : Enum {
public int value__
public ConfidenceFactor ExtraLow
public ConfidenceFactor Low
public ConfidenceFactor Medium
public ConfidenceFactor High
public ConfidenceFactor ExtraHigh
public ConfidenceFactor Provable
}
internal Mono.Math.Prime.Generator.NextPrimeFinder : SequentialSearchPrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object Context)
}
internal Mono.Math.Prime.Generator.PrimeGeneratorBase : object {
public ConfidenceFactor Confidence
public PrimalityTest PrimalityTest
public int TrialDivisionBounds
public ConfidenceFactor get_Confidence()
public PrimalityTest get_PrimalityTest()
public int get_TrialDivisionBounds()
protected bool PostTrialDivisionTests(BigInteger bi)
public BigInteger GenerateNewPrime(int bits)
}
internal Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase {
protected BigInteger GenerateSearchBase(int bits, object context)
public BigInteger GenerateNewPrime(int bits)
public BigInteger GenerateNewPrime(int bits, object context)
protected bool IsPrimeAcceptable(BigInteger bi, object context)
}
internal Mono.Math.Prime.PrimalityTest : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(BigInteger bi, ConfidenceFactor confidence)
public IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
internal Mono.Math.Prime.PrimalityTests : object {
private int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence)
public bool Test(BigInteger n, ConfidenceFactor confidence)
public bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence)
public bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence)
}
internal Mono.Runtime : object {
private void mono_runtime_install_handlers()
internal void InstallSignalHandlers()
internal string GetDisplayName()
}
internal Mono.Security.ASN1 : object {
private byte m_nTag
private Byte[] m_aValue
private ArrayList elist
public int Count
public byte Tag
public int Length
public Byte[] Value
public ASN1 Item
public void .ctor(byte tag)
public void .ctor(byte tag, Byte[] data)
public void .ctor(Byte[] data)
public int get_Count()
public byte get_Tag()
public int get_Length()
public Byte[] get_Value()
public void set_Value(Byte[] value)
private bool CompareArray(Byte[] array1, Byte[] array2)
public bool Equals(Byte[] asn1)
public bool CompareValue(Byte[] value)
public ASN1 Add(ASN1 asn1)
public Byte[] GetBytes()
protected void Decode(Byte[] asn1, Int32& anPos, int anLength)
protected void DecodeTLV(Byte[] asn1, Int32& pos, Byte& tag, Int32& length, Byte[]& content)
public ASN1 get_Item(int index)
public ASN1 Element(int index, byte anTag)
public string ToString()
public void SaveToFile(string filename)
}
internal Mono.Security.ASN1Convert : object {
public ASN1 FromDateTime(DateTime dt)
public ASN1 FromInt32(int value)
public ASN1 FromOid(string oid)
public ASN1 FromUnsignedBigInteger(Byte[] big)
public int ToInt32(ASN1 asn1)
public string ToOid(ASN1 asn1)
public DateTime ToDateTime(ASN1 time)
}
internal Mono.Security.Authenticode.AuthenticodeBase : object {
public string spcIndirectDataContext
private Byte[] fileblock
private FileStream fs
private int blockNo
private int blockLength
private int peOffset
private int dirSecurityOffset
private int dirSecuritySize
private int coffSymbolTableOffset
internal int PEOffset
internal int CoffSymbolTableOffset
internal int SecurityOffset
internal int get_PEOffset()
internal int get_CoffSymbolTableOffset()
internal int get_SecurityOffset()
internal void Open(string filename)
internal void Close()
internal bool ReadFirstBlock()
internal Byte[] GetSecurityEntry()
internal Byte[] GetHash(HashAlgorithm hash)
protected Byte[] HashFile(string fileName, string hashName)
}
internal Mono.Security.Authenticode.AuthenticodeDeformatter : AuthenticodeBase {
private string filename
private Byte[] hash
private X509CertificateCollection coll
private ASN1 signedHash
private DateTime timestamp
private X509Certificate signingCertificate
private int reason
private bool trustedRoot
private bool trustedTimestampRoot
private Byte[] entry
private X509Chain signerChain
private X509Chain timestampChain
private Dictionary`2<string, int> <>f__switch$map7
private Dictionary`2<string, int> <>f__switch$map8
private Dictionary`2<string, int> <>f__switch$map9
public string FileName
public Byte[] Hash
public int Reason
public Byte[] Signature
public DateTime Timestamp
public X509CertificateCollection Certificates
public X509Certificate SigningCertificate
public void .ctor(string fileName)
public string get_FileName()
public void set_FileName(string value)
public Byte[] get_Hash()
public int get_Reason()
public bool IsTrusted()
public Byte[] get_Signature()
public DateTime get_Timestamp()
public X509CertificateCollection get_Certificates()
public X509Certificate get_SigningCertificate()
private bool CheckSignature(string fileName)
private bool CompareIssuerSerial(string issuer, Byte[] serial, X509Certificate x509)
private bool VerifySignature(SignedData sd, Byte[] calculatedMessageDigest, HashAlgorithm ha)
private bool VerifyCounterSignature(SignerInfo cs, Byte[] signature)
private void Reset()
}
internal Mono.Security.Authenticode.Authority : Enum {
public int value__
public Authority Individual
public Authority Commercial
public Authority Maximum
}
internal Mono.Security.BitConverterLE : object {
private Byte[] GetUShortBytes(Byte* bytes)
private Byte[] GetUIntBytes(Byte* bytes)
private Byte[] GetULongBytes(Byte* bytes)
internal Byte[] GetBytes(bool value)
internal Byte[] GetBytes(char value)
internal Byte[] GetBytes(short value)
internal Byte[] GetBytes(int value)
internal Byte[] GetBytes(long value)
internal Byte[] GetBytes(ushort value)
internal Byte[] GetBytes(UInt32 value)
internal Byte[] GetBytes(ulong value)
internal Byte[] GetBytes(float value)
internal Byte[] GetBytes(double value)
private void UShortFromBytes(Byte* dst, Byte[] src, int startIndex)
private void UIntFromBytes(Byte* dst, Byte[] src, int startIndex)
private void ULongFromBytes(Byte* dst, Byte[] src, int startIndex)
internal bool ToBoolean(Byte[] value, int startIndex)
internal char ToChar(Byte[] value, int startIndex)
internal short ToInt16(Byte[] value, int startIndex)
internal int ToInt32(Byte[] value, int startIndex)
internal long ToInt64(Byte[] value, int startIndex)
internal ushort ToUInt16(Byte[] value, int startIndex)
internal UInt32 ToUInt32(Byte[] value, int startIndex)
internal ulong ToUInt64(Byte[] value, int startIndex)
internal float ToSingle(Byte[] value, int startIndex)
internal double ToDouble(Byte[] value, int startIndex)
}
internal Mono.Security.Cryptography.BlockProcessor : object {
private ICryptoTransform transform
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(ICryptoTransform transform)
public void .ctor(ICryptoTransform transform, int blockSize)
protected void Finalize()
public void Initialize()
public void Core(Byte[] rgb)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.CryptoConvert : object {
private int ToInt32LE(Byte[] bytes, int offset)
private UInt32 ToUInt32LE(Byte[] bytes, int offset)
private Byte[] GetBytesLE(int val)
private Byte[] Trim(Byte[] array)
public RSA FromCapiPrivateKeyBlob(Byte[] blob)
public RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob)
public DSA FromCapiPrivateKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPrivateKeyBlob(RSA rsa)
public Byte[] ToCapiPrivateKeyBlob(DSA dsa)
public RSA FromCapiPublicKeyBlob(Byte[] blob)
public RSA FromCapiPublicKeyBlob(Byte[] blob, int offset)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob)
public DSA FromCapiPublicKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiPublicKeyBlob(RSA rsa)
public Byte[] ToCapiPublicKeyBlob(DSA dsa)
public RSA FromCapiKeyBlob(Byte[] blob)
public RSA FromCapiKeyBlob(Byte[] blob, int offset)
public DSA FromCapiKeyBlobDSA(Byte[] blob)
public DSA FromCapiKeyBlobDSA(Byte[] blob, int offset)
public Byte[] ToCapiKeyBlob(AsymmetricAlgorithm keypair, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(RSA rsa, bool includePrivateKey)
public Byte[] ToCapiKeyBlob(DSA dsa, bool includePrivateKey)
public string ToHex(Byte[] input)
private byte FromHexChar(char c)
public Byte[] FromHex(string hex)
}
internal Mono.Security.Cryptography.DSAManaged : DSA {
private int defaultKeySize
private bool keypairGenerated
private bool m_disposed
private BigInteger p
private BigInteger q
private BigInteger g
private BigInteger x
private BigInteger y
private BigInteger j
private BigInteger seed
private int counter
private bool j_missing
private RandomNumberGenerator rng
private KeyGeneratedEventHandler KeyGenerated
private RandomNumberGenerator Random
public int KeySize
public string KeyExchangeAlgorithm
public bool PublicOnly
public string SignatureAlgorithm
public void .ctor(int dwKeySize)
public void add_KeyGenerated(KeyGeneratedEventHandler value)
public void remove_KeyGenerated(KeyGeneratedEventHandler value)
protected void Finalize()
private void Generate()
private void GenerateKeyPair()
private void add(Byte[] a, Byte[] b, int value)
private void GenerateParams(int keyLength)
private RandomNumberGenerator get_Random()
public int get_KeySize()
public string get_KeyExchangeAlgorithm()
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
private Byte[] NormalizeArray(Byte[] array)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
public Byte[] CreateSignature(Byte[] rgbHash)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
protected void Dispose(bool disposing)
}
internal Mono.Security.Cryptography.HMACAlgorithm : object {
private Byte[] key
private Byte[] hash
private HashAlgorithm algo
private string hashName
private BlockProcessor block
public HashAlgorithm Algo
public string HashName
public Byte[] Key
public void .ctor(string algoName)
protected void Finalize()
private void CreateHash(string algoName)
public void Dispose()
public HashAlgorithm get_Algo()
public string get_HashName()
public void set_HashName(string value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public void Initialize()
private Byte[] KeySetup(Byte[] key, byte padding)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.KeyBuilder : object {
private RandomNumberGenerator rng
private RandomNumberGenerator Rng
private RandomNumberGenerator get_Rng()
public Byte[] Key(int size)
public Byte[] IV(int size)
}
internal Mono.Security.Cryptography.KeyPairPersistence : object {
private bool _userPathExists
private string _userPath
private bool _machinePathExists
private string _machinePath
private CspParameters _params
private string _keyvalue
private string _filename
private string _container
private object lockobj
public string Filename
public string KeyValue
public CspParameters Parameters
private string UserPath
private string MachinePath
private bool CanChange
private bool UseDefaultKeyContainer
private bool UseMachineKeyStore
private string ContainerName
public void .ctor(CspParameters parameters)
public void .ctor(CspParameters parameters, string keyPair)
public string get_Filename()
public string get_KeyValue()
public void set_KeyValue(string value)
public CspParameters get_Parameters()
public bool Load()
public void Save()
public void Remove()
private string get_UserPath()
private string get_MachinePath()
internal bool _CanSecure(string root)
internal bool _ProtectUser(string path)
internal bool _ProtectMachine(string path)
internal bool _IsUserProtected(string path)
internal bool _IsMachineProtected(string path)
private bool CanSecure(string path)
private bool ProtectUser(string path)
private bool ProtectMachine(string path)
private bool IsUserProtected(string path)
private bool IsMachineProtected(string path)
private bool get_CanChange()
private bool get_UseDefaultKeyContainer()
private bool get_UseMachineKeyStore()
private string get_ContainerName()
private CspParameters Copy(CspParameters p)
private void FromXml(string xml)
private string ToXml()
}
internal Mono.Security.Cryptography.MACAlgorithm : object {
private SymmetricAlgorithm algo
private ICryptoTransform enc
private Byte[] block
private int blockSize
private int blockCount
public void .ctor(SymmetricAlgorithm algorithm)
public void Initialize(Byte[] key)
public void Core(Byte[] rgb, int ib, int cb)
public Byte[] Final()
}
internal Mono.Security.Cryptography.PKCS1 : object {
private Byte[] emptySHA1
private Byte[] emptySHA256
private Byte[] emptySHA384
private Byte[] emptySHA512
private bool Compare(Byte[] array1, Byte[] array2)
private Byte[] xor(Byte[] array1, Byte[] array2)
private Byte[] GetEmptyHash(HashAlgorithm hash)
public Byte[] I2OSP(int x, int size)
public Byte[] I2OSP(Byte[] x, int size)
public Byte[] OS2IP(Byte[] x)
public Byte[] RSAEP(RSA rsa, Byte[] m)
public Byte[] RSADP(RSA rsa, Byte[] c)
public Byte[] RSASP1(RSA rsa, Byte[] m)
public Byte[] RSAVP1(RSA rsa, Byte[] s)
public Byte[] Encrypt_OAEP(RSA rsa, HashAlgorithm hash, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_OAEP(RSA rsa, HashAlgorithm hash, Byte[] C)
public Byte[] Encrypt_v15(RSA rsa, RandomNumberGenerator rng, Byte[] M)
public Byte[] Decrypt_v15(RSA rsa, Byte[] C)
public Byte[] Sign_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature)
public bool Verify_v15(RSA rsa, HashAlgorithm hash, Byte[] hashValue, Byte[] signature, bool tryNonStandardEncoding)
public Byte[] Encode_v15(HashAlgorithm hash, Byte[] hashValue, int emLength)
public Byte[] MGF1(HashAlgorithm hash, Byte[] mgfSeed, int maskLen)
}
internal Mono.Security.Cryptography.PKCS8 : object {
public KeyInfo GetType(Byte[] data)
}
internal Mono.Security.Cryptography.RSAManaged : RSA {
private int defaultKeySize
private bool isCRTpossible
private bool keyBlinding
private bool keypairGenerated
private bool m_disposed
private BigInteger d
private BigInteger p
private BigInteger q
private BigInteger dp
private BigInteger dq
private BigInteger qInv
private BigInteger n
private BigInteger e
private KeyGeneratedEventHandler KeyGenerated
public int KeySize
public string KeyExchangeAlgorithm
public bool PublicOnly
public string SignatureAlgorithm
public bool UseKeyBlinding
public bool IsCrtPossible
public void .ctor(int keySize)
public void add_KeyGenerated(KeyGeneratedEventHandler value)
public void remove_KeyGenerated(KeyGeneratedEventHandler value)
protected void Finalize()
private void GenerateKeyPair()
public int get_KeySize()
public string get_KeyExchangeAlgorithm()
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] EncryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
protected void Dispose(bool disposing)
public string ToXmlString(bool includePrivateParameters)
public bool get_UseKeyBlinding()
public void set_UseKeyBlinding(bool value)
public bool get_IsCrtPossible()
private Byte[] GetPaddedValue(BigInteger value, int length)
}
internal Mono.Security.Cryptography.SymmetricTransform : object {
protected SymmetricAlgorithm algo
protected bool encrypt
private int BlockSizeByte
private Byte[] temp
private Byte[] temp2
private Byte[] workBuff
private Byte[] workout
private int FeedBackByte
private int FeedBackIter
private bool m_disposed
private bool lastBlock
private RandomNumberGenerator _rng
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
private bool KeepLastBlock
public void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] rgbIV)
private void System.IDisposable.Dispose()
protected void Finalize()
protected void Dispose(bool disposing)
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
protected void Transform(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
protected void CBC(Byte[] input, Byte[] output)
protected void CFB(Byte[] input, Byte[] output)
protected void OFB(Byte[] input, Byte[] output)
protected void CTS(Byte[] input, Byte[] output)
private void CheckInput(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private bool get_KeepLastBlock()
private int InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
private void Random(Byte[] buffer, int start, int length)
private void ThrowBadPaddingException(PaddingMode padding, int length, int position)
private Byte[] FinalEncrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
private Byte[] FinalDecrypt(Byte[] inputBuffer, int inputOffset, int inputCount)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
internal Mono.Security.PKCS7 : object {
public ASN1 Attribute(string oid, ASN1 value)
public ASN1 AlgorithmIdentifier(string oid)
public ASN1 AlgorithmIdentifier(string oid, ASN1 parameters)
public ASN1 IssuerAndSerialNumber(X509Certificate x509)
}
internal Mono.Security.StrongName : object {
private RSA rsa
private Byte[] publicKey
private Byte[] keyToken
private string tokenAlgorithm
private object lockObject
private bool initialized
public bool CanSign
public RSA RSA
public Byte[] PublicKey
public Byte[] PublicKeyToken
public string TokenAlgorithm
public void .ctor(int keySize)
public void .ctor(Byte[] data)
public void .ctor(RSA rsa)
private void InvalidateCache()
public bool get_CanSign()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_PublicKey()
public Byte[] get_PublicKeyToken()
public string get_TokenAlgorithm()
public void set_TokenAlgorithm(string value)
public Byte[] GetBytes()
private UInt32 RVAtoPosition(UInt32 r, int sections, Byte[] headers)
internal StrongNameSignature StrongHash(Stream stream, StrongNameOptions options)
public Byte[] Hash(string fileName)
public bool Sign(string fileName)
public bool Verify(string fileName)
public bool Verify(Stream stream)
public bool IsAssemblyStrongnamed(string assemblyName)
public bool VerifySignature(Byte[] publicKey, int algorithm, Byte[] hash, Byte[] signature)
private bool Verify(RSA rsa, AssemblyHashAlgorithm algorithm, Byte[] hash, Byte[] signature)
}
internal Mono.Security.StrongNameManager : object {
private Hashtable mappings
private Hashtable tokens
public void LoadConfig(string filename)
private void LoadMapping(SecurityElement mapping)
private void LoadVerificationSettings(SecurityElement settings)
public Byte[] GetMappedPublicKey(Byte[] token)
public bool MustVerify(AssemblyName an)
public string ToString()
}
internal Mono.Security.Uri : object {
private bool isUnixFilePath
private string source
private string scheme
private string host
private int port
private string path
private string query
private string fragment
private string userinfo
private bool isUnc
private bool isOpaquePart
private String[] segments
private bool userEscaped
private string cachedAbsoluteUri
private string cachedToString
private string cachedLocalPath
private int cachedHashCode
private bool reduce
private string hexUpperChars
public string SchemeDelimiter
public string UriSchemeFile
public string UriSchemeFtp
public string UriSchemeGopher
public string UriSchemeHttp
public string UriSchemeHttps
public string UriSchemeMailto
public string UriSchemeNews
public string UriSchemeNntp
private UriScheme[] schemes
private Dictionary`2<string, int> <>f__switch$map6
public string AbsolutePath
public string AbsoluteUri
public string Authority
public string Fragment
public string Host
public bool IsDefaultPort
public bool IsFile
public bool IsLoopback
public bool IsUnc
public string LocalPath
public string PathAndQuery
public int Port
public string Query
public string Scheme
public String[] Segments
public bool UserEscaped
public string UserInfo
public void .ctor(string uriString)
public void .ctor(string uriString, bool dontEscape)
public void .ctor(string uriString, bool dontEscape, bool reduce)
public void .ctor(Uri baseUri, string relativeUri)
public void .ctor(Uri baseUri, string relativeUri, bool dontEscape)
public string get_AbsolutePath()
public string get_AbsoluteUri()
public string get_Authority()
public string get_Fragment()
public string get_Host()
public bool get_IsDefaultPort()
public bool get_IsFile()
public bool get_IsLoopback()
public bool get_IsUnc()
public string get_LocalPath()
public string get_PathAndQuery()
public int get_Port()
public string get_Query()
public string get_Scheme()
public String[] get_Segments()
public bool get_UserEscaped()
public string get_UserInfo()
internal bool IsIPv4Address(string name)
internal bool IsDomainAddress(string name)
public bool CheckSchemeName(string schemeName)
public bool Equals(object comparant)
public int GetHashCode()
public string GetLeftPart(UriPartial part)
public int FromHex(char digit)
public string HexEscape(char character)
public char HexUnescape(string pattern, Int32& index)
public bool IsHexDigit(char digit)
public bool IsHexEncoding(string pattern, int index)
public string MakeRelative(Uri toUri)
public string ToString()
protected void Escape()
protected string EscapeString(string str)
internal string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets)
protected void Parse()
protected string Unescape(string str)
internal string Unescape(string str, bool excludeSharp)
private void ParseAsWindowsUNC(string uriString)
private void ParseAsWindowsAbsoluteFilePath(string uriString)
private void ParseAsUnixAbsoluteFilePath(string uriString)
private void Parse(string uriString)
private string Reduce(string path)
internal string GetSchemeDelimiter(string scheme)
internal int GetDefaultPort(string scheme)
private string GetOpaqueWiseSchemeDelimiter()
protected bool IsBadFileSystemCharacter(char ch)
protected bool IsExcludedCharacter(char ch)
private bool IsPredefinedScheme(string scheme)
protected bool IsReservedCharacter(char ch)
}
internal Mono.Security.UriPartial : Enum {
public int value__
public UriPartial Scheme
public UriPartial Authority
public UriPartial Path
}
internal Mono.Security.X509.Extensions.BasicConstraintsExtension : X509Extension {
public int NoPathLengthConstraint
private bool cA
private int pathLenConstraint
public bool CertificateAuthority
public string Name
public int PathLenConstraint
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public bool get_CertificateAuthority()
public void set_CertificateAuthority(bool value)
public string get_Name()
public int get_PathLenConstraint()
public void set_PathLenConstraint(int value)
public string ToString()
}
internal Mono.Security.X509.Extensions.KeyUsageExtension : X509Extension {
private int kubits
public KeyUsages KeyUsage
public string Name
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public KeyUsages get_KeyUsage()
public void set_KeyUsage(KeyUsages value)
public string get_Name()
public bool Support(KeyUsages usage)
public string ToString()
}
internal Mono.Security.X509.Extensions.KeyUsages : Enum {
public int value__
public KeyUsages digitalSignature
public KeyUsages nonRepudiation
public KeyUsages keyEncipherment
public KeyUsages dataEncipherment
public KeyUsages keyAgreement
public KeyUsages keyCertSign
public KeyUsages cRLSign
public KeyUsages encipherOnly
public KeyUsages decipherOnly
public KeyUsages none
}
internal Mono.Security.X509.Extensions.SubjectKeyIdentifierExtension : X509Extension {
private Byte[] ski
public string Name
public Byte[] Identifier
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
public string get_Name()
public Byte[] get_Identifier()
public string ToString()
}
internal Mono.Security.X509.PKCS12 : object {
public string pbeWithSHAAnd128BitRC4
public string pbeWithSHAAnd40BitRC4
public string pbeWithSHAAnd3KeyTripleDESCBC
public string pbeWithSHAAnd2KeyTripleDESCBC
public string pbeWithSHAAnd128BitRC2CBC
public string pbeWithSHAAnd40BitRC2CBC
public string keyBag
public string pkcs8ShroudedKeyBag
public string certBag
public string crlBag
public string secretBag
public string safeContentsBag
public string x509Certificate
public string sdsiCertificate
public string x509Crl
public int CryptoApiPasswordLimit
private int recommendedIterationCount
private Byte[] _password
private ArrayList _keyBags
private ArrayList _secretBags
private X509CertificateCollection _certs
private bool _keyBagsChanged
private bool _secretBagsChanged
private bool _certsChanged
private int _iterations
private ArrayList _safeBags
private RandomNumberGenerator _rng
private int password_max_length
private Dictionary`2<string, int> <>f__switch$mapA
private Dictionary`2<string, int> <>f__switch$mapB
private Dictionary`2<string, int> <>f__switch$mapC
private Dictionary`2<string, int> <>f__switch$mapD
private Dictionary`2<string, int> <>f__switch$mapE
private Dictionary`2<string, int> <>f__switch$mapF
private Dictionary`2<string, int> <>f__switch$map10
private Dictionary`2<string, int> <>f__switch$map11
public string Password
public int IterationCount
public ArrayList Keys
public ArrayList Secrets
public X509CertificateCollection Certificates
internal RandomNumberGenerator RNG
public int MaximumPasswordLength
public void .ctor(Byte[] data)
public void .ctor(Byte[] data, string password)
public void .ctor(Byte[] data, Byte[] password)
private void Decode(Byte[] data)
protected void Finalize()
public void set_Password(string value)
public int get_IterationCount()
public void set_IterationCount(int value)
public ArrayList get_Keys()
public ArrayList get_Secrets()
public X509CertificateCollection get_Certificates()
internal RandomNumberGenerator get_RNG()
private bool Compare(Byte[] expected, Byte[] actual)
private SymmetricAlgorithm GetSymmetricAlgorithm(string algorithmOid, Byte[] salt, int iterationCount)
public Byte[] Decrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] encryptedData)
public Byte[] Decrypt(EncryptedData ed)
public Byte[] Encrypt(string algorithmOid, Byte[] salt, int iterationCount, Byte[] data)
private DSAParameters GetExistingParameters(Boolean& found)
private void AddPrivateKey(PrivateKeyInfo pki)
private void ReadSafeBag(ASN1 safeBag)
private ASN1 Pkcs8ShroudedKeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 KeyBagSafeBag(AsymmetricAlgorithm aa, IDictionary attributes)
private ASN1 SecretBagSafeBag(Byte[] secret, IDictionary attributes)
private ASN1 CertificateSafeBag(X509Certificate x509, IDictionary attributes)
private Byte[] MAC(Byte[] password, Byte[] salt, int iterations, Byte[] data)
public Byte[] GetBytes()
private ContentInfo EncryptedContentInfo(ASN1 safeBags, string algorithmOid)
public void AddCertificate(X509Certificate cert)
public void AddCertificate(X509Certificate cert, IDictionary attributes)
public void RemoveCertificate(X509Certificate cert)
public void RemoveCertificate(X509Certificate cert, IDictionary attrs)
private bool CompareAsymmetricAlgorithm(AsymmetricAlgorithm a1, AsymmetricAlgorithm a2)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddPkcs8ShroudedKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemovePkcs8ShroudedKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa)
public void AddKeyBag(AsymmetricAlgorithm aa, IDictionary attributes)
public void RemoveKeyBag(AsymmetricAlgorithm aa)
public void AddSecretBag(Byte[] secret)
public void AddSecretBag(Byte[] secret, IDictionary attributes)
public void RemoveSecretBag(Byte[] secret)
public AsymmetricAlgorithm GetAsymmetricAlgorithm(IDictionary attrs)
public Byte[] GetSecret(IDictionary attrs)
public X509Certificate GetCertificate(IDictionary attrs)
public IDictionary GetAttributes(AsymmetricAlgorithm aa)
public IDictionary GetAttributes(X509Certificate cert)
public void SaveToFile(string filename)
public object Clone()
public int get_MaximumPasswordLength()
public void set_MaximumPasswordLength(int value)
private Byte[] LoadFile(string filename)
public PKCS12 LoadFromFile(string filename)
public PKCS12 LoadFromFile(string filename, string password)
}
internal Mono.Security.X509.PKCS5 : object {
public string pbeWithMD2AndDESCBC
public string pbeWithMD5AndDESCBC
public string pbeWithMD2AndRC2CBC
public string pbeWithMD5AndRC2CBC
public string pbeWithSHA1AndDESCBC
public string pbeWithSHA1AndRC2CBC
}
internal Mono.Security.X509.PKCS9 : object {
public string friendlyName
public string localKeyId
}
internal Mono.Security.X509.SafeBag : object {
private string _bagOID
private ASN1 _asn1
public string BagOID
public ASN1 ASN1
public void .ctor(string bagOID, ASN1 asn1)
public string get_BagOID()
public ASN1 get_ASN1()
}
internal Mono.Security.X509.X501 : object {
private Byte[] countryName
private Byte[] organizationName
private Byte[] organizationalUnitName
private Byte[] commonName
private Byte[] localityName
private Byte[] stateOrProvinceName
private Byte[] streetAddress
private Byte[] domainComponent
private Byte[] userid
private Byte[] email
private Byte[] dnQualifier
private Byte[] title
private Byte[] surname
private Byte[] givenName
private Byte[] initial
private Dictionary`2<string, int> <>f__switch$map12
public string ToString(ASN1 seq)
public string ToString(ASN1 seq, bool reversed, string separator, bool quotes)
private void AppendEntry(StringBuilder sb, ASN1 entry, bool quotes)
private AttributeTypeAndValue GetAttributeFromOid(string attributeType)
private bool IsOid(string oid)
private AttributeTypeAndValue ReadAttribute(string value, Int32& pos)
private bool IsHex(char c)
private string ReadHex(string value, Int32& pos)
private int ReadEscaped(StringBuilder sb, string value, int pos)
private int ReadQuoted(StringBuilder sb, string value, int pos)
private string ReadValue(string value, Int32& pos)
public ASN1 FromString(string rdn)
}
internal Mono.Security.X509.X509Certificate : object {
private ASN1 decoder
private Byte[] m_encodedcert
private DateTime m_from
private DateTime m_until
private ASN1 issuer
private string m_issuername
private string m_keyalgo
private Byte[] m_keyalgoparams
private ASN1 subject
private string m_subject
private Byte[] m_publickey
private Byte[] signature
private string m_signaturealgo
private Byte[] m_signaturealgoparams
private Byte[] certhash
private RSA _rsa
private DSA _dsa
private int version
private Byte[] serialnumber
private Byte[] issuerUniqueID
private Byte[] subjectUniqueID
private X509ExtensionCollection extensions
private string encoding_error
private Dictionary`2<string, int> <>f__switch$map13
private Dictionary`2<string, int> <>f__switch$map14
private Dictionary`2<string, int> <>f__switch$map15
public DSA DSA
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public string KeyAlgorithm
public Byte[] KeyAlgorithmParameters
public Byte[] PublicKey
public RSA RSA
public Byte[] RawData
public Byte[] SerialNumber
public Byte[] Signature
public string SignatureAlgorithm
public Byte[] SignatureAlgorithmParameters
public string SubjectName
public DateTime ValidFrom
public DateTime ValidUntil
public int Version
public bool IsCurrent
public Byte[] IssuerUniqueIdentifier
public Byte[] SubjectUniqueIdentifier
public bool IsSelfSigned
public void .ctor(Byte[] data)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void Parse(Byte[] data)
private Byte[] GetUnsignedBigInteger(Byte[] integer)
public DSA get_DSA()
public void set_DSA(DSA value)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public string get_KeyAlgorithm()
public Byte[] get_KeyAlgorithmParameters()
public void set_KeyAlgorithmParameters(Byte[] value)
public Byte[] get_PublicKey()
public RSA get_RSA()
public void set_RSA(RSA value)
public Byte[] get_RawData()
public Byte[] get_SerialNumber()
public Byte[] get_Signature()
public string get_SignatureAlgorithm()
public Byte[] get_SignatureAlgorithmParameters()
public string get_SubjectName()
public DateTime get_ValidFrom()
public DateTime get_ValidUntil()
public int get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] get_IssuerUniqueIdentifier()
public Byte[] get_SubjectUniqueIdentifier()
internal bool VerifySignature(DSA dsa)
internal string GetHashNameFromOID(string oid)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public bool CheckSignature(Byte[] hash, string hashAlgorithm, Byte[] signature)
public bool get_IsSelfSigned()
public ASN1 GetIssuerName()
public ASN1 GetSubjectName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private Byte[] PEM(string type, Byte[] data)
}
internal Mono.Security.X509.X509CertificateCollection : CollectionBase {
public X509Certificate Item
public void .ctor(X509Certificate[] value)
public void .ctor(X509CertificateCollection value)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public X509Certificate get_Item(int index)
public void set_Item(int index, X509Certificate value)
public int Add(X509Certificate value)
public void AddRange(X509Certificate[] value)
public void AddRange(X509CertificateCollection value)
public bool Contains(X509Certificate value)
public void CopyTo(X509Certificate[] array, int index)
public X509CertificateEnumerator GetEnumerator()
public int GetHashCode()
public int IndexOf(X509Certificate value)
public void Insert(int index, X509Certificate value)
public void Remove(X509Certificate value)
private bool Compare(Byte[] array1, Byte[] array2)
}
internal Mono.Security.X509.X509Chain : object {
private X509CertificateCollection roots
private X509CertificateCollection certs
private X509Certificate _root
private X509CertificateCollection _chain
private X509ChainStatusFlags _status
public X509CertificateCollection Chain
public X509Certificate Root
public X509ChainStatusFlags Status
public X509CertificateCollection TrustAnchors
public void .ctor(X509CertificateCollection chain)
public X509CertificateCollection get_Chain()
public X509Certificate get_Root()
public X509ChainStatusFlags get_Status()
public X509CertificateCollection get_TrustAnchors()
public void set_TrustAnchors(X509CertificateCollection value)
public void LoadCertificate(X509Certificate x509)
public void LoadCertificates(X509CertificateCollection collection)
public X509Certificate FindByIssuerName(string issuerName)
public bool Build(X509Certificate leaf)
public void Reset()
private bool IsValid(X509Certificate cert)
private X509Certificate FindCertificateParent(X509Certificate child)
private X509Certificate FindCertificateRoot(X509Certificate potentialRoot)
private bool IsTrusted(X509Certificate potentialTrusted)
private bool IsParent(X509Certificate child, X509Certificate parent)
}
internal Mono.Security.X509.X509ChainStatusFlags : Enum {
public int value__
public X509ChainStatusFlags InvalidBasicConstraints
public X509ChainStatusFlags NoError
public X509ChainStatusFlags NotSignatureValid
public X509ChainStatusFlags NotTimeNested
public X509ChainStatusFlags NotTimeValid
public X509ChainStatusFlags PartialChain
public X509ChainStatusFlags UntrustedRoot
}
internal Mono.Security.X509.X509Crl : object {
private string issuer
private byte version
private DateTime thisUpdate
private DateTime nextUpdate
private ArrayList entries
private string signatureOID
private Byte[] signature
private X509ExtensionCollection extensions
private Byte[] encoded
private Byte[] hash_value
private Dictionary`2<string, int> <>f__switch$map16
private Dictionary`2<string, int> <>f__switch$map17
public ArrayList Entries
public X509CrlEntry Item
public X509CrlEntry Item
public X509ExtensionCollection Extensions
public Byte[] Hash
public string IssuerName
public DateTime NextUpdate
public DateTime ThisUpdate
public string SignatureAlgorithm
public Byte[] Signature
public Byte[] RawData
public byte Version
public bool IsCurrent
public void .ctor(Byte[] crl)
private void Parse(Byte[] crl)
public ArrayList get_Entries()
public X509CrlEntry get_Item(int index)
public X509CrlEntry get_Item(Byte[] serialNumber)
public X509ExtensionCollection get_Extensions()
public Byte[] get_Hash()
public string get_IssuerName()
public DateTime get_NextUpdate()
public DateTime get_ThisUpdate()
public string get_SignatureAlgorithm()
public Byte[] get_Signature()
public Byte[] get_RawData()
public byte get_Version()
public bool get_IsCurrent()
public bool WasCurrent(DateTime instant)
public Byte[] GetBytes()
private bool Compare(Byte[] array1, Byte[] array2)
public X509CrlEntry GetCrlEntry(X509Certificate x509)
public X509CrlEntry GetCrlEntry(Byte[] serialNumber)
public bool VerifySignature(X509Certificate x509)
private string GetHashName()
internal bool VerifySignature(DSA dsa)
internal bool VerifySignature(RSA rsa)
public bool VerifySignature(AsymmetricAlgorithm aa)
public X509Crl CreateFromFile(string filename)
}
internal Mono.Security.X509.X509Extension : object {
protected string extnOid
protected bool extnCritical
protected ASN1 extnValue
public ASN1 ASN1
public string Oid
public bool Critical
public string Name
public ASN1 Value
public void .ctor(ASN1 asn1)
public void .ctor(X509Extension extension)
protected void Decode()
protected void Encode()
public ASN1 get_ASN1()
public string get_Oid()
public bool get_Critical()
public void set_Critical(bool value)
public string get_Name()
public ASN1 get_Value()
public bool Equals(object obj)
public Byte[] GetBytes()
public int GetHashCode()
private void WriteLine(StringBuilder sb, int n, int pos)
public string ToString()
}
internal Mono.Security.X509.X509ExtensionCollection : CollectionBase {
private bool readOnly
public X509Extension Item
public X509Extension Item
public void .ctor(ASN1 asn1)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int Add(X509Extension extension)
public void AddRange(X509Extension[] extension)
public void AddRange(X509ExtensionCollection collection)
public bool Contains(X509Extension extension)
public bool Contains(string oid)
public void CopyTo(X509Extension[] extensions, int index)
public int IndexOf(X509Extension extension)
public int IndexOf(string oid)
public void Insert(int index, X509Extension extension)
public void Remove(X509Extension extension)
public void Remove(string oid)
public X509Extension get_Item(int index)
public X509Extension get_Item(string oid)
public Byte[] GetBytes()
}
internal Mono.Security.X509.X509Store : object {
private string _storePath
private X509CertificateCollection _certificates
private ArrayList _crls
private bool _crl
private string _name
public X509CertificateCollection Certificates
public ArrayList Crls
public string Name
internal void .ctor(string path, bool crl)
public X509CertificateCollection get_Certificates()
public ArrayList get_Crls()
public string get_Name()
public void Clear()
public void Import(X509Certificate certificate)
public void Import(X509Crl crl)
public void Remove(X509Certificate certificate)
public void Remove(X509Crl crl)
private string GetUniqueName(X509Certificate certificate)
private string GetUniqueName(X509Crl crl)
private Byte[] GetUniqueName(X509ExtensionCollection extensions)
private string GetUniqueName(string method, Byte[] name, string fileExtension)
private Byte[] Load(string filename)
private X509Certificate LoadCertificate(string filename)
private X509Crl LoadCrl(string filename)
private bool CheckStore(string path, bool throwException)
private X509CertificateCollection BuildCertificatesCollection(string storeName)
private ArrayList BuildCrlsCollection(string storeName)
}
internal Mono.Security.X509.X509StoreManager : object {
private X509Stores _userStore
private X509Stores _machineStore
public X509Stores CurrentUser
public X509Stores LocalMachine
public X509CertificateCollection IntermediateCACertificates
public ArrayList IntermediateCACrls
public X509CertificateCollection TrustedRootCertificates
public ArrayList TrustedRootCACrls
public X509CertificateCollection UntrustedCertificates
public X509Stores get_CurrentUser()
public X509Stores get_LocalMachine()
public X509CertificateCollection get_IntermediateCACertificates()
public ArrayList get_IntermediateCACrls()
public X509CertificateCollection get_TrustedRootCertificates()
public ArrayList get_TrustedRootCACrls()
public X509CertificateCollection get_UntrustedCertificates()
}
internal Mono.Security.X509.X509Stores : object {
private string _storePath
private X509Store _personal
private X509Store _other
private X509Store _intermediate
private X509Store _trusted
private X509Store _untrusted
public X509Store Personal
public X509Store OtherPeople
public X509Store IntermediateCA
public X509Store TrustedRoot
public X509Store Untrusted
internal void .ctor(string path)
public X509Store get_Personal()
public X509Store get_OtherPeople()
public X509Store get_IntermediateCA()
public X509Store get_TrustedRoot()
public X509Store get_Untrusted()
public void Clear()
public X509Store Open(string storeName, bool create)
}
internal Mono.Xml.DefaultHandler : object {
public void OnStartParsing(SmallXmlParser parser)
public void OnEndParsing(SmallXmlParser parser)
public void OnStartElement(string name, IAttrList attrs)
public void OnEndElement(string name)
public void OnChars(string s)
public void OnIgnorableWhitespace(string s)
public void OnProcessingInstruction(string name, string text)
}
internal Mono.Xml.SecurityParser : SmallXmlParser {
private SecurityElement root
private SecurityElement current
private Stack stack
public void LoadXml(string xml)
public SecurityElement ToXml()
public void OnStartParsing(SmallXmlParser parser)
public void OnProcessingInstruction(string name, string text)
public void OnIgnorableWhitespace(string s)
public void OnStartElement(string name, IAttrList attrs)
public void OnEndElement(string name)
public void OnChars(string ch)
public void OnEndParsing(SmallXmlParser parser)
}
internal Mono.Xml.SmallXmlParser : object {
private IContentHandler handler
private TextReader reader
private Stack elementNames
private Stack xmlSpaces
private string xmlSpace
private StringBuilder buffer
private Char[] nameBuffer
private bool isWhitespace
private AttrListImpl attributes
private int line
private int column
private bool resetColumn
private Dictionary`2<string, int> <>f__switch$map18
private Exception Error(string msg)
private Exception UnexpectedEndError()
private bool IsNameChar(char c, bool start)
private bool IsWhitespace(int c)
public void SkipWhitespaces()
private void HandleWhitespaces()
public void SkipWhitespaces(bool expected)
private int Peek()
private int Read()
public void Expect(int c)
private string ReadUntil(char until, bool handleReferences)
public string ReadName()
public void Parse(TextReader input, IContentHandler handler)
private void Cleanup()
public void ReadContent()
private void HandleBufferedContent()
private void ReadCharacters()
private void ReadReference()
private int ReadCharacterReference()
private void ReadAttribute(AttrListImpl a)
private void ReadCDATASection()
private void ReadComment()
}
internal Mono.Xml.SmallXmlParserException : SystemException {
private int line
private int column
public int Line
public int Column
public void .ctor(string msg, int line, int column)
public int get_Line()
public int get_Column()
}
internal System.__ComObject : MarshalByRefObject {
private IntPtr iunknown
private IntPtr hash_table
internal IntPtr IUnknown
internal IntPtr IDispatch
internal Guid IID_IUnknown
internal Guid IID_IDispatch
internal void .ctor(Type t)
internal void .ctor(IntPtr pItf)
internal __ComObject CreateRCW(Type t)
private void ReleaseInterfaces()
protected void Finalize()
internal void Initialize(Type t)
private Guid GetCLSID(Type t)
internal IntPtr GetInterfaceInternal(Type t, bool throwException)
internal IntPtr GetInterface(Type t, bool throwException)
internal IntPtr GetInterface(Type t)
private void CheckIUnknown()
internal IntPtr get_IUnknown()
internal IntPtr get_IDispatch()
internal Guid get_IID_IUnknown()
internal Guid get_IID_IDispatch()
public bool Equals(object obj)
public int GetHashCode()
private int CoCreateInstance(Guid rclsid, IntPtr pUnkOuter, UInt32 dwClsContext, Guid riid, IntPtr& pUnk)
}
public System._AppDomain {
public string BaseDirectory
public string DynamicDirectory
public Evidence Evidence
public string FriendlyName
public string RelativeSearchPath
public bool ShadowCopyFiles
public void add_AssemblyLoad(AssemblyLoadEventHandler value)
public void remove_AssemblyLoad(AssemblyLoadEventHandler value)
public void add_AssemblyResolve(ResolveEventHandler value)
public void remove_AssemblyResolve(ResolveEventHandler value)
public void add_DomainUnload(EventHandler value)
public void remove_DomainUnload(EventHandler value)
public void add_ProcessExit(EventHandler value)
public void remove_ProcessExit(EventHandler value)
public void add_ResourceResolve(ResolveEventHandler value)
public void remove_ResourceResolve(ResolveEventHandler value)
public void add_TypeResolve(ResolveEventHandler value)
public void remove_TypeResolve(ResolveEventHandler value)
public void add_UnhandledException(UnhandledExceptionEventHandler value)
public void remove_UnhandledException(UnhandledExceptionEventHandler value)
public string get_BaseDirectory()
public string get_DynamicDirectory()
public Evidence get_Evidence()
public string get_FriendlyName()
public string get_RelativeSearchPath()
public bool get_ShadowCopyFiles()
public void AppendPrivatePath(string path)
public void ClearPrivatePath()
public void ClearShadowCopyPath()
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized)
public void DoCallBack(CrossAppDomainDelegate theDelegate)
public bool Equals(object other)
public int ExecuteAssembly(string assemblyFile)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args)
public Assembly[] GetAssemblies()
public object GetData(string name)
public int GetHashCode()
public object GetLifetimeService()
public Type GetType()
public object InitializeLifetimeService()
public Assembly Load(AssemblyName assemblyRef)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(string assemblyString)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
public void SetAppDomainPolicy(PolicyLevel domainPolicy)
public void SetCachePath(string s)
public void SetData(string name, object data)
public void SetPrincipalPolicy(PrincipalPolicy policy)
public void SetShadowCopyPath(string s)
public void SetThreadPrincipal(IPrincipal principal)
public string ToString()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.AccessViolationException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Action`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(T obj)
public IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ActivationContext : object {
private ContextForm _form
private ApplicationIdentity _appid
private bool _disposed
public ContextForm Form
public ApplicationIdentity Identity
private void .ctor(ApplicationIdentity identity)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
protected void Finalize()
public ContextForm get_Form()
public ApplicationIdentity get_Identity()
public ActivationContext CreatePartialActivationContext(ApplicationIdentity identity)
public ActivationContext CreatePartialActivationContext(ApplicationIdentity identity, String[] manifestPaths)
public void Dispose()
private void Dispose(bool disposing)
}
public System.Activator : object {
private BindingFlags _flags
private BindingFlags _accessFlags
private void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Activator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Activator.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Activator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName)
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
public ObjectHandle CreateInstance(ActivationContext activationContext)
public ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData)
public ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName)
public ObjectHandle CreateInstance(AppDomain domain, string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public T CreateInstance()
public object CreateInstance(Type type)
public object CreateInstance(Type type, Object[] args)
public object CreateInstance(Type type, Object[] args, Object[] activationAttributes)
public object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture)
public object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public object CreateInstance(Type type, bool nonPublic)
private void CheckType(Type type)
private void CheckAbstractType(Type type)
public object GetObject(Type type, string url)
public object GetObject(Type type, string url, object state)
internal object CreateInstanceInternal(Type type)
}
public System.AppDomain : MarshalByRefObject {
private IntPtr _mono_app_domain
private string _process_guid
private Hashtable type_resolve_in_progress
private Hashtable assembly_resolve_in_progress
private Hashtable assembly_resolve_in_progress_refonly
private Evidence _evidence
private PermissionSet _granted
private PrincipalPolicy _principalPolicy
private IPrincipal _principal
private AppDomain default_domain
private AppDomainManager _domain_manager
private ActivationContext _activation
private ApplicationIdentity _applicationIdentity
private AssemblyLoadEventHandler AssemblyLoad
private ResolveEventHandler AssemblyResolve
private EventHandler DomainUnload
private EventHandler ProcessExit
private ResolveEventHandler ResourceResolve
private ResolveEventHandler TypeResolve
private UnhandledExceptionEventHandler UnhandledException
private ResolveEventHandler ReflectionOnlyAssemblyResolve
private AppDomainSetup SetupInformationNoCopy
public AppDomainSetup SetupInformation
public ApplicationTrust ApplicationTrust
public string BaseDirectory
public string RelativeSearchPath
public string DynamicDirectory
public bool ShadowCopyFiles
public string FriendlyName
public Evidence Evidence
internal IPrincipal DefaultPrincipal
internal PermissionSet GrantedPermissionSet
public AppDomain CurrentDomain
internal AppDomain DefaultDomain
public AppDomainManager DomainManager
public ActivationContext ActivationContext
public ApplicationIdentity ApplicationIdentity
public int Id
public void add_AssemblyLoad(AssemblyLoadEventHandler value)
public void remove_AssemblyLoad(AssemblyLoadEventHandler value)
public void add_AssemblyResolve(ResolveEventHandler value)
public void remove_AssemblyResolve(ResolveEventHandler value)
public void add_DomainUnload(EventHandler value)
public void remove_DomainUnload(EventHandler value)
public void add_ProcessExit(EventHandler value)
public void remove_ProcessExit(EventHandler value)
public void add_ResourceResolve(ResolveEventHandler value)
public void remove_ResourceResolve(ResolveEventHandler value)
public void add_TypeResolve(ResolveEventHandler value)
public void remove_TypeResolve(ResolveEventHandler value)
public void add_UnhandledException(UnhandledExceptionEventHandler value)
public void remove_UnhandledException(UnhandledExceptionEventHandler value)
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value)
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value)
private void System._AppDomain.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System._AppDomain.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System._AppDomain.GetTypeInfoCount(UInt32& pcTInfo)
private void System._AppDomain.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private AppDomainSetup getSetup()
private AppDomainSetup get_SetupInformationNoCopy()
public AppDomainSetup get_SetupInformation()
public ApplicationTrust get_ApplicationTrust()
public string get_BaseDirectory()
public string get_RelativeSearchPath()
public string get_DynamicDirectory()
public bool get_ShadowCopyFiles()
private string getFriendlyName()
public string get_FriendlyName()
public Evidence get_Evidence()
internal IPrincipal get_DefaultPrincipal()
internal PermissionSet get_GrantedPermissionSet()
private AppDomain getCurDomain()
public AppDomain get_CurrentDomain()
private AppDomain getRootDomain()
internal AppDomain get_DefaultDomain()
public void AppendPrivatePath(string path)
public void ClearPrivatePath()
public void ClearShadowCopyPath()
public ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName)
public ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public ObjectHandle CreateInstance(string assemblyName, string typeName)
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes)
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes)
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes)
public object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, PermissionSet requiredPermissions, PermissionSet optionalPermissions, PermissionSet refusedPermissions, bool isSynchronized, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
public AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes)
internal AssemblyBuilder DefineInternalDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access)
public void DoCallBack(CrossAppDomainDelegate callBackDelegate)
public int ExecuteAssembly(string assemblyFile)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args)
public int ExecuteAssembly(string assemblyFile, Evidence assemblySecurity, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
private int ExecuteAssemblyInternal(Assembly a, String[] args)
private int ExecuteAssembly(Assembly a, String[] args)
private Assembly[] GetAssemblies(bool refOnly)
public Assembly[] GetAssemblies()
public object GetData(string name)
public Type GetType()
public object InitializeLifetimeService()
internal Assembly LoadAssembly(string assemblyRef, Evidence securityEvidence, bool refOnly)
public Assembly Load(AssemblyName assemblyRef)
internal Assembly LoadSatellite(AssemblyName assemblyRef, bool throwOnError)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(string assemblyString)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
internal Assembly Load(string assemblyString, Evidence assemblySecurity, bool refonly)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
internal Assembly LoadAssemblyRaw(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
internal Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence, bool refonly)
public void SetAppDomainPolicy(PolicyLevel domainPolicy)
public void SetCachePath(string path)
public void SetPrincipalPolicy(PrincipalPolicy policy)
public void SetShadowCopyFiles()
public void SetShadowCopyPath(string path)
public void SetThreadPrincipal(IPrincipal principal)
private AppDomain InternalSetDomainByID(int domain_id)
private AppDomain InternalSetDomain(AppDomain context)
internal void InternalPushDomainRef(AppDomain domain)
internal void InternalPushDomainRefByID(int domain_id)
internal void InternalPopDomainRef()
internal Context InternalSetContext(Context context)
internal Context InternalGetContext()
internal Context InternalGetDefaultContext()
internal string InternalGetProcessGuid(string newguid)
internal object InvokeInDomain(AppDomain domain, MethodInfo method, object obj, Object[] args)
internal object InvokeInDomainByID(int domain_id, MethodInfo method, object obj, Object[] args)
internal string GetProcessGuid()
public AppDomain CreateDomain(string friendlyName)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo)
private AppDomain createDomain(string friendlyName, AppDomainSetup info)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup info, PermissionSet grantSet, StrongName[] fullTrustAssemblies)
private AppDomainSetup CreateDomainSetup(string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles)
private bool InternalIsFinalizingForUnload(int domain_id)
public bool IsFinalizingForUnload()
private void InternalUnload(int domain_id)
private int getDomainID()
public void Unload(AppDomain domain)
public void SetData(string name, object data)
public void SetData(string name, object data, IPermission permission)
public void SetDynamicBase(string path)
public int GetCurrentThreadId()
public string ToString()
private void ValidateAssemblyName(string name)
private void DoAssemblyLoad(Assembly assembly)
private Assembly DoAssemblyResolve(string name, bool refonly)
internal Assembly DoTypeResolve(object name_or_tb)
private void DoDomainUnload()
internal Byte[] GetMarshalledDomainObjRef()
internal void ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg, Byte[]& arrResponse, CADMethodReturnMessage& cadMrm)
public AppDomainManager get_DomainManager()
public ActivationContext get_ActivationContext()
public ApplicationIdentity get_ApplicationIdentity()
public int get_Id()
public string ApplyPolicy(string assemblyName)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, String[] adInitArgs)
public int ExecuteAssemblyByName(string assemblyName)
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity)
public int ExecuteAssemblyByName(string assemblyName, Evidence assemblySecurity, String[] args)
public int ExecuteAssemblyByName(AssemblyName assemblyName, Evidence assemblySecurity, String[] args)
public bool IsDefaultAppDomain()
public Assembly[] ReflectionOnlyGetAssemblies()
unknown object System._AppDomain.GetLifetimeService()
}
public System.AppDomainInitializer : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(String[] args)
public IAsyncResult BeginInvoke(String[] args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.AppDomainManager : MarshalByRefObject {
private ApplicationActivator _activator
private AppDomainManagerInitializationOptions _flags
public ApplicationActivator ApplicationActivator
public Assembly EntryAssembly
public HostExecutionContextManager HostExecutionContextManager
public HostSecurityManager HostSecurityManager
public AppDomainManagerInitializationOptions InitializationFlags
public ApplicationActivator get_ApplicationActivator()
public Assembly get_EntryAssembly()
public HostExecutionContextManager get_HostExecutionContextManager()
public HostSecurityManager get_HostSecurityManager()
public AppDomainManagerInitializationOptions get_InitializationFlags()
public void set_InitializationFlags(AppDomainManagerInitializationOptions value)
public AppDomain CreateDomain(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo)
public void InitializeNewDomain(AppDomainSetup appDomainInfo)
public bool CheckSecuritySettings(SecurityState state)
protected AppDomain CreateDomainHelper(string friendlyName, Evidence securityInfo, AppDomainSetup appDomainInfo)
}
public System.AppDomainManagerInitializationOptions : Enum {
public int value__
public AppDomainManagerInitializationOptions None
public AppDomainManagerInitializationOptions RegisterWithHost
}
public System.AppDomainSetup : object {
private string application_base
private string application_name
private string cache_path
private string configuration_file
private string dynamic_base
private string license_file
private string private_bin_path
private string private_bin_path_probe
private string shadow_copy_directories
private string shadow_copy_files
private bool publisher_policy
private bool path_changed
private LoaderOptimization loader_optimization
private bool disallow_binding_redirects
private bool disallow_code_downloads
private ActivationArguments _activationArguments
private AppDomainInitializer domain_initializer
private ApplicationTrust application_trust
private String[] domain_initializer_args
private SecurityElement application_trust_xml
private bool disallow_appbase_probe
private Byte[] configuration_bytes
public string ApplicationBase
public string ApplicationName
public string CachePath
public string ConfigurationFile
public bool DisallowPublisherPolicy
public string DynamicBase
public string LicenseFile
public LoaderOptimization LoaderOptimization
public string PrivateBinPath
public string PrivateBinPathProbe
public string ShadowCopyDirectories
public string ShadowCopyFiles
public bool DisallowBindingRedirects
public bool DisallowCodeDownload
public ActivationArguments ActivationArguments
public AppDomainInitializer AppDomainInitializer
public String[] AppDomainInitializerArguments
public ApplicationTrust ApplicationTrust
public bool DisallowApplicationBaseProbing
internal void .ctor(AppDomainSetup setup)
public void .ctor(ActivationArguments activationArguments)
public void .ctor(ActivationContext activationContext)
private string GetAppBase(string appBase)
public string get_ApplicationBase()
public void set_ApplicationBase(string value)
public string get_ApplicationName()
public void set_ApplicationName(string value)
public string get_CachePath()
public void set_CachePath(string value)
public string get_ConfigurationFile()
public void set_ConfigurationFile(string value)
public bool get_DisallowPublisherPolicy()
public void set_DisallowPublisherPolicy(bool value)
public string get_DynamicBase()
public void set_DynamicBase(string value)
public string get_LicenseFile()
public void set_LicenseFile(string value)
public LoaderOptimization get_LoaderOptimization()
public void set_LoaderOptimization(LoaderOptimization value)
public string get_PrivateBinPath()
public void set_PrivateBinPath(string value)
public string get_PrivateBinPathProbe()
public void set_PrivateBinPathProbe(string value)
public string get_ShadowCopyDirectories()
public void set_ShadowCopyDirectories(string value)
public string get_ShadowCopyFiles()
public void set_ShadowCopyFiles(string value)
public bool get_DisallowBindingRedirects()
public void set_DisallowBindingRedirects(bool value)
public bool get_DisallowCodeDownload()
public void set_DisallowCodeDownload(bool value)
public ActivationArguments get_ActivationArguments()
public void set_ActivationArguments(ActivationArguments value)
public AppDomainInitializer get_AppDomainInitializer()
public void set_AppDomainInitializer(AppDomainInitializer value)
public String[] get_AppDomainInitializerArguments()
public void set_AppDomainInitializerArguments(String[] value)
public ApplicationTrust get_ApplicationTrust()
public void set_ApplicationTrust(ApplicationTrust value)
public bool get_DisallowApplicationBaseProbing()
public void set_DisallowApplicationBaseProbing(bool value)
public Byte[] GetConfigurationBytes()
public void SetConfigurationBytes(Byte[] value)
}
public System.AppDomainUnloadedException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ApplicationException : Exception {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ApplicationId : object {
private Byte[] _token
private string _name
private Version _version
private string _proc
private string _culture
public string Culture
public string Name
public string ProcessorArchitecture
public Byte[] PublicKeyToken
public Version Version
public void .ctor(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture)
public string get_Culture()
public string get_Name()
public string get_ProcessorArchitecture()
public Byte[] get_PublicKeyToken()
public Version get_Version()
public ApplicationId Copy()
public bool Equals(object o)
public int GetHashCode()
public string ToString()
}
public System.ApplicationIdentity : object {
private string _fullName
private string _codeBase
public string CodeBase
public string FullName
public void .ctor(string applicationIdentityFullName)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public string get_CodeBase()
public string get_FullName()
public string ToString()
}
public System.ArgIterator : ValueType {
private IntPtr sig
private IntPtr args
private int next_arg
private int num_args
public void .ctor(RuntimeArgumentHandle arglist)
public void .ctor(RuntimeArgumentHandle arglist, Void* ptr)
private void Setup(IntPtr argsp, IntPtr start)
public void End()
public bool Equals(object o)
public int GetHashCode()
public TypedReference GetNextArg()
private TypedReference IntGetNextArg()
public TypedReference GetNextArg(RuntimeTypeHandle rth)
private TypedReference IntGetNextArg(IntPtr rth)
public RuntimeTypeHandle GetNextArgType()
private IntPtr IntGetNextArgType()
public int GetRemainingCount()
}
public System.ArgumentException : SystemException {
private int Result
private string param_name
public string ParamName
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string paramName)
public void .ctor(string message, string paramName, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_ParamName()
public string get_Message()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ArgumentNullException : ArgumentException {
private int Result
public void .ctor(string paramName)
public void .ctor(string paramName, string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.ArgumentOutOfRangeException : ArgumentException {
private int Result
private object actual_value
public object ActualValue
public string Message
public void .ctor(string paramName)
public void .ctor(string paramName, string message)
public void .ctor(string paramName, object actualValue, string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
public object get_ActualValue()
public string get_Message()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ArithmeticException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Array : object {
private object System.Collections.IList.Item
private int System.Collections.ICollection.Count
public int Length
public long LongLength
public int Rank
public bool IsSynchronized
public object SyncRoot
public bool IsFixedSize
public bool IsReadOnly
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private int System.Collections.ICollection.get_Count()
internal int InternalArray__ICollection_get_Count()
internal bool InternalArray__ICollection_get_IsReadOnly()
internal IEnumerator`1<T> InternalArray__IEnumerable_GetEnumerator()
internal void InternalArray__ICollection_Clear()
internal void InternalArray__ICollection_Add(T item)
internal bool InternalArray__ICollection_Remove(T item)
internal bool InternalArray__ICollection_Contains(T item)
internal void InternalArray__ICollection_CopyTo(T[] array, int index)
internal void InternalArray__Insert(int index, T item)
internal void InternalArray__RemoveAt(int index)
internal int InternalArray__IndexOf(T item)
internal T InternalArray__get_Item(int index)
internal void InternalArray__set_Item(int index, T item)
internal void GetGenericValueImpl(int pos, T& value)
internal void SetGenericValueImpl(int pos, T& value)
public int get_Length()
public long get_LongLength()
public int get_Rank()
private int GetRank()
public int GetLength(int dimension)
public long GetLongLength(int dimension)
public int GetLowerBound(int dimension)
public object GetValue(Int32[] indices)
public void SetValue(object value, Int32[] indices)
internal object GetValueImpl(int pos)
internal void SetValueImpl(object value, int pos)
internal bool FastCopy(Array source, int source_idx, Array dest, int dest_idx, int length)
internal Array CreateInstanceImpl(Type elementType, Int32[] lengths, Int32[] bounds)
public bool get_IsSynchronized()
public object get_SyncRoot()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public IEnumerator GetEnumerator()
public int GetUpperBound(int dimension)
public object GetValue(int index)
public object GetValue(int index1, int index2)
public object GetValue(int index1, int index2, int index3)
public object GetValue(long index)
public object GetValue(long index1, long index2)
public object GetValue(long index1, long index2, long index3)
public void SetValue(object value, long index)
public void SetValue(object value, long index1, long index2)
public void SetValue(object value, long index1, long index2, long index3)
public void SetValue(object value, int index)
public void SetValue(object value, int index1, int index2)
public void SetValue(object value, int index1, int index2, int index3)
public Array CreateInstance(Type elementType, int length)
public Array CreateInstance(Type elementType, int length1, int length2)
public Array CreateInstance(Type elementType, int length1, int length2, int length3)
public Array CreateInstance(Type elementType, Int32[] lengths)
public Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds)
private Int32[] GetIntArray(Int64[] values)
public Array CreateInstance(Type elementType, Int64[] lengths)
public object GetValue(Int64[] indices)
public void SetValue(object value, Int64[] indices)
public int BinarySearch(Array array, object value)
public int BinarySearch(Array array, object value, IComparer comparer)
public int BinarySearch(Array array, int index, int length, object value)
public int BinarySearch(Array array, int index, int length, object value, IComparer comparer)
private int DoBinarySearch(Array array, int index, int length, object value, IComparer comparer)
public void Clear(Array array, int index, int length)
private void ClearInternal(Array a, int index, int count)
public object Clone()
public void Copy(Array sourceArray, Array destinationArray, int length)
public void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
public void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length)
public void Copy(Array sourceArray, Array destinationArray, long length)
public int IndexOf(Array array, object value)
public int IndexOf(Array array, object value, int startIndex)
public int IndexOf(Array array, object value, int startIndex, int count)
public void Initialize()
public int LastIndexOf(Array array, object value)
public int LastIndexOf(Array array, object value, int startIndex)
public int LastIndexOf(Array array, object value, int startIndex, int count)
private Swapper get_swapper(Array array)
private Swapper get_swapper(T[] array)
public void Reverse(Array array)
public void Reverse(Array array, int index, int length)
public void Sort(Array array)
public void Sort(Array keys, Array items)
public void Sort(Array array, IComparer comparer)
public void Sort(Array array, int index, int length)
public void Sort(Array keys, Array items, IComparer comparer)
public void Sort(Array keys, Array items, int index, int length)
public void Sort(Array array, int index, int length, IComparer comparer)
public void Sort(Array keys, Array items, int index, int length, IComparer comparer)
private void int_swapper(int i, int j)
private void obj_swapper(int i, int j)
private void slow_swapper(int i, int j)
private void double_swapper(int i, int j)
private int new_gap(int gap)
private void combsort(Double[] array, int start, int size, Swapper swap_items)
private void combsort(Int32[] array, int start, int size, Swapper swap_items)
private void combsort(Char[] array, int start, int size, Swapper swap_items)
private void qsort(Array keys, Array items, int low0, int high0, IComparer comparer)
private void swap(Array keys, Array items, int i, int j)
private int compare(object value1, object value2, IComparer comparer)
public void Sort(T[] array)
public void Sort(TKey[] keys, TValue[] items)
public void Sort(T[] array, IComparer`1<T> comparer)
public void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer)
public void Sort(T[] array, int index, int length)
public void Sort(TKey[] keys, TValue[] items, int index, int length)
public void Sort(T[] array, int index, int length, IComparer`1<T> comparer)
public void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer)
public void Sort(T[] array, Comparison`1<T> comparison)
internal void Sort(T[] array, int length, Comparison`1<T> comparison)
private void qsort(K[] keys, V[] items, int low0, int high0, IComparer`1<K> comparer)
private int compare(T value1, T value2, IComparer`1<T> comparer)
private void qsort(T[] array, int low0, int high0, Comparison`1<T> comparison)
private void swap(K[] keys, V[] items, int i, int j)
private void swap(T[] array, int i, int j)
public void CopyTo(Array array, int index)
public void CopyTo(Array array, long index)
public void Resize(T[]& array, int newSize)
internal void Resize(T[]& array, int length, int newSize)
public bool TrueForAll(T[] array, Predicate`1<T> match)
public void ForEach(T[] array, Action`1<T> action)
public TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter)
public int FindLastIndex(T[] array, Predicate`1<T> match)
public int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match)
public int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match)
public int FindIndex(T[] array, Predicate`1<T> match)
public int FindIndex(T[] array, int startIndex, Predicate`1<T> match)
public int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match)
public int BinarySearch(T[] array, T value)
public int BinarySearch(T[] array, T value, IComparer`1<T> comparer)
public int BinarySearch(T[] array, int index, int length, T value)
public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer)
public int IndexOf(T[] array, T value)
public int IndexOf(T[] array, T value, int startIndex)
public int IndexOf(T[] array, T value, int startIndex, int count)
public int LastIndexOf(T[] array, T value)
public int LastIndexOf(T[] array, T value, int startIndex)
public int LastIndexOf(T[] array, T value, int startIndex, int count)
public T[] FindAll(T[] array, Predicate`1<T> match)
public bool Exists(T[] array, Predicate`1<T> match)
public ReadOnlyCollection`1<T> AsReadOnly(T[] array)
public T Find(T[] array, Predicate`1<T> match)
public T FindLast(T[] array, Predicate`1<T> match)
public void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
}
public System.ArraySegment`1 : ValueType {
private T[] array
private int offset
private int count
public T[] Array
public int Offset
public int Count
public void .ctor(T[] array, int offset, int count)
public void .ctor(T[] array)
public T[] get_Array()
public int get_Offset()
public int get_Count()
public bool Equals(object obj)
public bool Equals(ArraySegment`1<T> obj)
public int GetHashCode()
public bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b)
public bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b)
}
public System.ArrayTypeMismatchException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.AssemblyLoadEventArgs : EventArgs {
private Assembly m_loadedAssembly
public Assembly LoadedAssembly
public void .ctor(Assembly loadedAssembly)
public Assembly get_LoadedAssembly()
}
public System.AssemblyLoadEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, AssemblyLoadEventArgs args)
public IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.AsyncCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(IAsyncResult ar)
public IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Attribute : object {
public object TypeId
private void System.Runtime.InteropServices._Attribute.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Attribute.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Attribute.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public object get_TypeId()
private void CheckParameters(object element, Type attributeType)
private Attribute FindAttribute(Object[] attributes)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType)
public Attribute GetCustomAttribute(Assembly element, Type attributeType)
public Attribute GetCustomAttribute(Module element, Type attributeType)
public Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit)
public Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(Assembly element)
public Attribute[] GetCustomAttributes(ParameterInfo element)
public Attribute[] GetCustomAttributes(MemberInfo element)
public Attribute[] GetCustomAttributes(Module element)
public Attribute[] GetCustomAttributes(Assembly element, Type attributeType)
public Attribute[] GetCustomAttributes(Module element, Type attributeType)
public Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType)
public Attribute[] GetCustomAttributes(MemberInfo element, Type type)
public Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit)
public Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit)
public Attribute[] GetCustomAttributes(Module element, bool inherit)
public Attribute[] GetCustomAttributes(Assembly element, bool inherit)
public Attribute[] GetCustomAttributes(MemberInfo element, bool inherit)
public Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit)
public int GetHashCode()
public bool IsDefaultAttribute()
public bool IsDefined(Module element, Type attributeType)
public bool IsDefined(ParameterInfo element, Type attributeType)
public bool IsDefined(MemberInfo element, Type attributeType)
public bool IsDefined(Assembly element, Type attributeType)
public bool IsDefined(MemberInfo element, Type attributeType, bool inherit)
public bool IsDefined(Assembly element, Type attributeType, bool inherit)
public bool IsDefined(Module element, Type attributeType, bool inherit)
public bool IsDefined(ParameterInfo element, Type attributeType, bool inherit)
public bool Match(object obj)
public bool Equals(object obj)
}
public System.AttributeTargets : Enum {
public int value__
public AttributeTargets Assembly
public AttributeTargets Module
public AttributeTargets Class
public AttributeTargets Struct
public AttributeTargets Enum
public AttributeTargets Constructor
public AttributeTargets Method
public AttributeTargets Property
public AttributeTargets Field
public AttributeTargets Event
public AttributeTargets Interface
public AttributeTargets Parameter
public AttributeTargets Delegate
public AttributeTargets ReturnValue
public AttributeTargets GenericParameter
public AttributeTargets All
}
public System.AttributeUsageAttribute : Attribute {
private AttributeTargets valid_on
private bool allow_multiple
private bool inherited
public bool AllowMultiple
public bool Inherited
public AttributeTargets ValidOn
public void .ctor(AttributeTargets validOn)
public bool get_AllowMultiple()
public void set_AllowMultiple(bool value)
public bool get_Inherited()
public void set_Inherited(bool value)
public AttributeTargets get_ValidOn()
}
public System.BadImageFormatException : SystemException {
private int Result
private string fileName
private string fusionLog
public string Message
public string FileName
public string FusionLog
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, string fileName)
public void .ctor(string message, string fileName, Exception inner)
public string get_Message()
public string get_FileName()
public string get_FusionLog()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Base64FormattingOptions : Enum {
public int value__
public Base64FormattingOptions InsertLineBreaks
public Base64FormattingOptions None
}
public System.BitConverter : object {
private bool SwappedWordsInDouble
public bool IsLittleEndian
private bool AmILittleEndian()
private bool DoubleWordsAreSwapped()
public long DoubleToInt64Bits(double value)
public double Int64BitsToDouble(long value)
internal double InternalInt64BitsToDouble(long value)
private Byte[] GetBytes(Byte* ptr, int count)
public Byte[] GetBytes(bool value)
public Byte[] GetBytes(char value)
public Byte[] GetBytes(short value)
public Byte[] GetBytes(int value)
public Byte[] GetBytes(long value)
public Byte[] GetBytes(ushort value)
public Byte[] GetBytes(UInt32 value)
public Byte[] GetBytes(ulong value)
public Byte[] GetBytes(float value)
public Byte[] GetBytes(double value)
private void PutBytes(Byte* dst, Byte[] src, int start_index, int count)
public bool ToBoolean(Byte[] value, int startIndex)
public char ToChar(Byte[] value, int startIndex)
public short ToInt16(Byte[] value, int startIndex)
public int ToInt32(Byte[] value, int startIndex)
public long ToInt64(Byte[] value, int startIndex)
public ushort ToUInt16(Byte[] value, int startIndex)
public UInt32 ToUInt32(Byte[] value, int startIndex)
public ulong ToUInt64(Byte[] value, int startIndex)
public float ToSingle(Byte[] value, int startIndex)
public double ToDouble(Byte[] value, int startIndex)
internal double SwappableToDouble(Byte[] value, int startIndex)
public string ToString(Byte[] value)
public string ToString(Byte[] value, int startIndex)
public string ToString(Byte[] value, int startIndex, int length)
}
public System.Boolean : ValueType {
public string FalseString
public string TrueString
internal bool m_value
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object obj)
public bool Equals(object obj)
public int CompareTo(bool value)
public bool Equals(bool obj)
public int GetHashCode()
public bool Parse(string value)
public bool TryParse(string value, Boolean& result)
public string ToString()
public TypeCode GetTypeCode()
public string ToString(IFormatProvider provider)
}
internal System.BRECORD : ValueType {
private IntPtr pvRecord
private IntPtr pRecInfo
}
public System.Buffer : object {
public int ByteLength(Array array)
public byte GetByte(Array array, int index)
public void SetByte(Array array, int index, byte value)
public void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count)
private int ByteLengthInternal(Array array)
private byte GetByteInternal(Array array, int index)
private void SetByteInternal(Array array, int index, int value)
internal bool BlockCopyInternal(Array src, int src_offset, Array dest, int dest_offset, int count)
}
public System.Byte : ValueType {
public byte MinValue
public byte MaxValue
internal byte m_value
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(byte value)
public bool Equals(byte obj)
public byte Parse(string s, IFormatProvider provider)
public byte Parse(string s, NumberStyles style)
public byte Parse(string s, NumberStyles style, IFormatProvider provider)
public byte Parse(string s)
public bool TryParse(string s, Byte& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result)
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
internal System.ByteMatcher : object {
private Hashtable map
private Hashtable starts
public void AddMapping(TermInfoStrings key, Byte[] val)
public void Sort()
public bool StartsWith(int c)
public TermInfoStrings Match(Char[] buffer, int offset, int length, Int32& used)
}
public System.CannotUnloadAppDomainException : SystemException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Char : ValueType {
public char MaxValue
public char MinValue
internal char m_value
private Byte* category_data
private Byte* numeric_data
private Double* numeric_data_values
private UInt16* to_lower_data_low
private UInt16* to_lower_data_high
private UInt16* to_upper_data_low
private UInt16* to_upper_data_high
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private void GetDataTablePointers(Byte*& category_data, Byte*& numeric_data, Double*& numeric_data_values, UInt16*& to_lower_data_low, UInt16*& to_lower_data_high, UInt16*& to_upper_data_low, UInt16*& to_upper_data_high)
public int CompareTo(object value)
public bool Equals(object obj)
public int CompareTo(char value)
public string ConvertFromUtf32(int utf32)
public int ConvertToUtf32(char highSurrogate, char lowSurrogate)
public int ConvertToUtf32(string s, int index)
public bool Equals(char obj)
public bool IsSurrogatePair(char highSurrogate, char lowSurrogate)
public bool IsSurrogatePair(string s, int index)
public int GetHashCode()
public double GetNumericValue(char c)
public double GetNumericValue(string s, int index)
public UnicodeCategory GetUnicodeCategory(char c)
public UnicodeCategory GetUnicodeCategory(string s, int index)
public bool IsControl(char c)
public bool IsControl(string s, int index)
public bool IsDigit(char c)
public bool IsDigit(string s, int index)
public bool IsHighSurrogate(char c)
public bool IsHighSurrogate(string s, int index)
public bool IsLetter(char c)
public bool IsLetter(string s, int index)
public bool IsLetterOrDigit(char c)
public bool IsLetterOrDigit(string s, int index)
public bool IsLower(char c)
public bool IsLower(string s, int index)
public bool IsLowSurrogate(char c)
public bool IsLowSurrogate(string s, int index)
public bool IsNumber(char c)
public bool IsNumber(string s, int index)
public bool IsPunctuation(char c)
public bool IsPunctuation(string s, int index)
public bool IsSeparator(char c)
public bool IsSeparator(string s, int index)
public bool IsSurrogate(char c)
public bool IsSurrogate(string s, int index)
public bool IsSymbol(char c)
public bool IsSymbol(string s, int index)
public bool IsUpper(char c)
public bool IsUpper(string s, int index)
public bool IsWhiteSpace(char c)
public bool IsWhiteSpace(string s, int index)
private void CheckParameter(string s, int index)
public bool TryParse(string s, Char& result)
public char Parse(string s)
public char ToLower(char c)
public char ToLowerInvariant(char c)
public char ToLower(char c, CultureInfo culture)
public char ToUpper(char c)
public char ToUpperInvariant(char c)
public char ToUpper(char c, CultureInfo culture)
public string ToString()
public string ToString(char c)
public string ToString(IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.CharEnumerator : object {
private string str
private int index
private int length
private object System.Collections.IEnumerator.Current
public char Current
internal void .ctor(string s)
private object System.Collections.IEnumerator.get_Current()
private void System.IDisposable.Dispose()
public char get_Current()
public object Clone()
public bool MoveNext()
public void Reset()
}
internal System.CharInfo : ValueType {
public char Character
public short Attributes
}
public System.CLSCompliantAttribute : Attribute {
private bool is_compliant
public bool IsCompliant
public void .ctor(bool isCompliant)
public bool get_IsCompliant()
}
public System.Collections.ArrayList : object {
private int DefaultInitialCapacity
private int _size
private Object[] _items
private int _version
private Object[] EmptyArray
public object Item
public int Count
public int Capacity
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object SyncRoot
public void .ctor(ICollection c)
public void .ctor(int capacity)
private void .ctor(int initialCapacity, bool forceZeroSize)
private void .ctor(Object[] array, int index, int count)
public object get_Item(int index)
public void set_Item(int index, object value)
public int get_Count()
public int get_Capacity()
public void set_Capacity(int value)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_SyncRoot()
private void EnsureCapacity(int count)
private void Shift(int index, int count)
public int Add(object value)
public void Clear()
public bool Contains(object item)
internal bool Contains(object value, int startIndex, int count)
public int IndexOf(object value)
public int IndexOf(object value, int startIndex)
public int IndexOf(object value, int startIndex, int count)
public int LastIndexOf(object value)
public int LastIndexOf(object value, int startIndex)
public int LastIndexOf(object value, int startIndex, int count)
public void Insert(int index, object value)
public void InsertRange(int index, ICollection c)
public void Remove(object obj)
public void RemoveAt(int index)
public void RemoveRange(int index, int count)
public void Reverse()
public void Reverse(int index, int count)
public void CopyTo(Array array)
public void CopyTo(Array array, int arrayIndex)
public void CopyTo(int index, Array array, int arrayIndex, int count)
public IEnumerator GetEnumerator()
public IEnumerator GetEnumerator(int index, int count)
public void AddRange(ICollection c)
public int BinarySearch(object value)
public int BinarySearch(object value, IComparer comparer)
public int BinarySearch(int index, int count, object value, IComparer comparer)
public ArrayList GetRange(int index, int count)
public void SetRange(int index, ICollection c)
public void TrimToSize()
public void Sort()
public void Sort(IComparer comparer)
public void Sort(int index, int count, IComparer comparer)
public Object[] ToArray()
public Array ToArray(Type type)
public object Clone()
internal void CheckRange(int index, int count, int listCount)
internal void ThrowNewArgumentOutOfRangeException(string name, object actual, string message)
public ArrayList Adapter(IList list)
public ArrayList Synchronized(ArrayList list)
public IList Synchronized(IList list)
public ArrayList ReadOnly(ArrayList list)
public IList ReadOnly(IList list)
public ArrayList FixedSize(ArrayList list)
public IList FixedSize(IList list)
public ArrayList Repeat(object value, int count)
}
public System.Collections.BitArray : object {
private Int32[] m_array
private int m_length
private int _version
public int Count
public bool IsReadOnly
public bool IsSynchronized
public bool Item
public int Length
public object SyncRoot
public void .ctor(BitArray bits)
public void .ctor(Boolean[] values)
public void .ctor(Byte[] bytes)
public void .ctor(Int32[] values)
public void .ctor(int length)
public void .ctor(int length, bool defaultValue)
private void .ctor(Int32[] array, int length)
private byte getByte(int byteIndex)
private void setByte(int byteIndex, byte value)
private void checkOperand(BitArray operand)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public bool get_Item(int index)
public void set_Item(int index, bool value)
public int get_Length()
public void set_Length(int value)
public object get_SyncRoot()
public object Clone()
public void CopyTo(Array array, int index)
public BitArray Not()
public BitArray And(BitArray value)
public BitArray Or(BitArray value)
public BitArray Xor(BitArray value)
public bool Get(int index)
public void Set(int index, bool value)
public void SetAll(bool value)
public IEnumerator GetEnumerator()
}
public System.Collections.CaseInsensitiveComparer : object {
private CaseInsensitiveComparer defaultComparer
private CaseInsensitiveComparer defaultInvariantComparer
private CultureInfo culture
public CaseInsensitiveComparer Default
public CaseInsensitiveComparer DefaultInvariant
private void .ctor(bool invariant)
public void .ctor(CultureInfo culture)
public CaseInsensitiveComparer get_Default()
public CaseInsensitiveComparer get_DefaultInvariant()
public int Compare(object a, object b)
}
public System.Collections.CaseInsensitiveHashCodeProvider : object {
private CaseInsensitiveHashCodeProvider singletonInvariant
private CaseInsensitiveHashCodeProvider singleton
private object sync
private TextInfo m_text
public CaseInsensitiveHashCodeProvider Default
public CaseInsensitiveHashCodeProvider DefaultInvariant
public void .ctor(CultureInfo culture)
public CaseInsensitiveHashCodeProvider get_Default()
private bool AreEqual(CultureInfo a, CultureInfo b)
private bool AreEqual(TextInfo info, CultureInfo culture)
public CaseInsensitiveHashCodeProvider get_DefaultInvariant()
public int GetHashCode(object obj)
}
public System.Collections.CollectionBase : object {
private ArrayList list
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
public int Capacity
protected ArrayList InnerList
protected IList List
protected void .ctor(int capacity)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public int get_Count()
public IEnumerator GetEnumerator()
public void Clear()
public void RemoveAt(int index)
public int get_Capacity()
public void set_Capacity(int value)
protected ArrayList get_InnerList()
protected IList get_List()
protected void OnClear()
protected void OnClearComplete()
protected void OnInsert(int index, object value)
protected void OnInsertComplete(int index, object value)
protected void OnRemove(int index, object value)
protected void OnRemoveComplete(int index, object value)
protected void OnSet(int index, object oldValue, object newValue)
protected void OnSetComplete(int index, object oldValue, object newValue)
protected void OnValidate(object value)
}
internal System.Collections.CollectionDebuggerView : object {
private ICollection c
public Object[] Items
public void .ctor(ICollection col)
public Object[] get_Items()
}
public System.Collections.Comparer : object {
public Comparer Default
public Comparer DefaultInvariant
private CompareInfo m_compareInfo
public void .ctor(CultureInfo culture)
public int Compare(object a, object b)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Collections.DictionaryBase : object {
private Hashtable hashtable
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private object System.Collections.IDictionary.Item
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
public int Count
protected IDictionary Dictionary
protected Hashtable InnerHashtable
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private void System.Collections.IDictionary.Add(object key, object value)
private void System.Collections.IDictionary.Remove(object key)
private bool System.Collections.IDictionary.Contains(object key)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Clear()
public int get_Count()
protected IDictionary get_Dictionary()
protected Hashtable get_InnerHashtable()
public void CopyTo(Array array, int index)
private void DoCopy(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
protected void OnClear()
protected void OnClearComplete()
protected object OnGet(object key, object currentValue)
protected void OnInsert(object key, object value)
protected void OnInsertComplete(object key, object value)
protected void OnSet(object key, object oldValue, object newValue)
protected void OnSetComplete(object key, object oldValue, object newValue)
protected void OnRemove(object key, object value)
protected void OnRemoveComplete(object key, object value)
protected void OnValidate(object key, object value)
}
public System.Collections.DictionaryEntry : ValueType {
private object _key
private object _value
public object Key
public object Value
public void .ctor(object key, object value)
public object get_Key()
public void set_Key(object value)
public object get_Value()
public void set_Value(object value)
}
internal System.Collections.Generic.CollectionDebuggerView`1 : object {
private ICollection`1<T> c
public T[] Items
public void .ctor(ICollection`1<T> col)
public T[] get_Items()
}
internal System.Collections.Generic.CollectionDebuggerView`2 : object {
private ICollection`1<KeyValuePair`2<T, U>> c
public KeyValuePair`2[] Items
public void .ctor(ICollection`1<KeyValuePair`2<T, U>> col)
public KeyValuePair`2[] get_Items()
}
public System.Collections.Generic.Comparer`1 : object {
private Comparer`1<T> _default
public Comparer`1<T> Default
private int System.Collections.IComparer.Compare(object x, object y)
public int Compare(T x, T y)
public Comparer`1<T> get_Default()
}
public System.Collections.Generic.Dictionary`2 : object {
private int INITIAL_SIZE
private float DEFAULT_LOAD_FACTOR
private int NO_SLOT
private int HASH_FLAG
private Int32[] table
private Link[] linkSlots
private TKey[] keySlots
private TValue[] valueSlots
private int touchedSlots
private int emptySlot
private int count
private int threshold
private IEqualityComparer`1<TKey> hcp
private SerializationInfo serialization_info
private int generation
private Transform`1<TKey, TValue, DictionaryEntry> <>f__am$cacheB
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values
private ICollection System.Collections.IDictionary.Keys
private ICollection System.Collections.IDictionary.Values
private bool System.Collections.IDictionary.IsFixedSize
private bool System.Collections.IDictionary.IsReadOnly
private object System.Collections.IDictionary.Item
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly
public int Count
public TValue Item
public IEqualityComparer`1<TKey> Comparer
public KeyCollection<TKey, TValue> Keys
public ValueCollection<TKey, TValue> Values
public void .ctor(IEqualityComparer`1<TKey> comparer)
public void .ctor(IDictionary`2<TKey, TValue> dictionary)
public void .ctor(int capacity)
public void .ctor(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer)
public void .ctor(int capacity, IEqualityComparer`1<TKey> comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys()
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values()
private ICollection System.Collections.IDictionary.get_Keys()
private ICollection System.Collections.IDictionary.get_Values()
private bool System.Collections.IDictionary.get_IsFixedSize()
private bool System.Collections.IDictionary.get_IsReadOnly()
private object System.Collections.IDictionary.get_Item(object key)
private void System.Collections.IDictionary.set_Item(object key, object value)
private void System.Collections.IDictionary.Add(object key, object value)
private bool System.Collections.IDictionary.Contains(object key)
private void System.Collections.IDictionary.Remove(object key)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly()
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair)
private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index)
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator()
private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator()
public int get_Count()
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
private void Init(int capacity, IEqualityComparer`1<TKey> hcp)
private void InitArrays(int size)
private void CopyToCheck(Array array, int index)
private void Do_CopyTo(TElem[] array, int index, Transform`1<TKey, TValue, TRet> transform)
private KeyValuePair`2<TKey, TValue> make_pair(TKey key, TValue value)
private TKey pick_key(TKey key, TValue value)
private TValue pick_value(TKey key, TValue value)
private void CopyTo(KeyValuePair`2[] array, int index)
private void Do_ICollectionCopyTo(Array array, int index, Transform`1<TKey, TValue, TRet> transform)
private void Resize()
public void Add(TKey key, TValue value)
public IEqualityComparer`1<TKey> get_Comparer()
public void Clear()
public bool ContainsKey(TKey key)
public bool ContainsValue(TValue value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public KeyCollection<TKey, TValue> get_Keys()
public ValueCollection<TKey, TValue> get_Values()
private TKey ToTKey(object key)
private TValue ToTValue(object value)
private bool ContainsKeyValuePair(KeyValuePair`2<TKey, TValue> pair)
public Enumerator<TKey, TValue> GetEnumerator()
private DictionaryEntry <CopyTo>m__2(TKey key, TValue value)
}
public System.Collections.Generic.EqualityComparer`1 : object {
private EqualityComparer`1<T> _default
public EqualityComparer`1<T> Default
private int System.Collections.IEqualityComparer.GetHashCode(object obj)
private bool System.Collections.IEqualityComparer.Equals(object x, object y)
public int GetHashCode(T obj)
public bool Equals(T x, T y)
public EqualityComparer`1<T> get_Default()
}
internal System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
public int Compare(T x, T y)
}
internal System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
public int GetHashCode(T obj)
public bool Equals(T x, T y)
}
public System.Collections.Generic.ICollection`1 {
public int Count
public bool IsReadOnly
public int get_Count()
public bool get_IsReadOnly()
public void Add(T item)
public void Clear()
public bool Contains(T item)
public void CopyTo(T[] array, int arrayIndex)
public bool Remove(T item)
}
public System.Collections.Generic.IComparer`1 {
public int Compare(T x, T y)
}
public System.Collections.Generic.IDictionary`2 {
public TValue Item
public ICollection`1<TKey> Keys
public ICollection`1<TValue> Values
public void Add(TKey key, TValue value)
public bool ContainsKey(TKey key)
public bool Remove(TKey key)
public bool TryGetValue(TKey key, TValue& value)
public TValue get_Item(TKey key)
public void set_Item(TKey key, TValue value)
public ICollection`1<TKey> get_Keys()
public ICollection`1<TValue> get_Values()
}
public System.Collections.Generic.IEnumerable`1 {
public IEnumerator`1<T> GetEnumerator()
}
public System.Collections.Generic.IEnumerator`1 {
public T Current
public T get_Current()
}
public System.Collections.Generic.IEqualityComparer`1 {
public bool Equals(T x, T y)
public int GetHashCode(T obj)
}
public System.Collections.Generic.IList`1 {
public T Item
public int IndexOf(T item)
public void Insert(int index, T item)
public void RemoveAt(int index)
public T get_Item(int index)
public void set_Item(int index, T value)
}
public System.Collections.Generic.KeyNotFoundException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Collections.Generic.KeyValuePair`2 : ValueType {
private TKey key
private TValue value
public TKey Key
public TValue Value
public void .ctor(TKey key, TValue value)
public TKey get_Key()
private void set_Key(TKey value)
public TValue get_Value()
private void set_Value(TValue value)
public string ToString()
}
internal System.Collections.Generic.Link : ValueType {
public int HashCode
public int Next
}
public System.Collections.Generic.List`1 : object {
private int DefaultCapacity
private T[] _items
private int _size
private int _version
private T[] EmptyArray
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Capacity
public int Count
public T Item
public void .ctor(IEnumerable`1<T> collection)
public void .ctor(int capacity)
internal void .ctor(T[] data, int size)
private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object item)
private bool System.Collections.IList.Contains(object item)
private int System.Collections.IList.IndexOf(object item)
private void System.Collections.IList.Insert(int index, object item)
private void System.Collections.IList.Remove(object item)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void Add(T item)
private void GrowIfNeeded(int newCount)
private void CheckRange(int idx, int count)
private void AddCollection(ICollection`1<T> collection)
private void AddEnumerable(IEnumerable`1<T> enumerable)
public void AddRange(IEnumerable`1<T> collection)
public ReadOnlyCollection`1<T> AsReadOnly()
public int BinarySearch(T item)
public int BinarySearch(T item, IComparer`1<T> comparer)
public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer)
public void Clear()
public bool Contains(T item)
public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter)
public void CopyTo(T[] array)
public void CopyTo(T[] array, int arrayIndex)
public void CopyTo(int index, T[] array, int arrayIndex, int count)
public bool Exists(Predicate`1<T> match)
public T Find(Predicate`1<T> match)
private void CheckMatch(Predicate`1<T> match)
public List`1<T> FindAll(Predicate`1<T> match)
private List`1<T> FindAllStackBits(Predicate`1<T> match)
private List`1<T> FindAllList(Predicate`1<T> match)
public int FindIndex(Predicate`1<T> match)
public int FindIndex(int startIndex, Predicate`1<T> match)
public int FindIndex(int startIndex, int count, Predicate`1<T> match)
private int GetIndex(int startIndex, int count, Predicate`1<T> match)
public T FindLast(Predicate`1<T> match)
public int FindLastIndex(Predicate`1<T> match)
public int FindLastIndex(int startIndex, Predicate`1<T> match)
public int FindLastIndex(int startIndex, int count, Predicate`1<T> match)
private int GetLastIndex(int startIndex, int count, Predicate`1<T> match)
public void ForEach(Action`1<T> action)
public Enumerator<T> GetEnumerator()
public List`1<T> GetRange(int index, int count)
public int IndexOf(T item)
public int IndexOf(T item, int index)
public int IndexOf(T item, int index, int count)
private void Shift(int start, int delta)
private void CheckIndex(int index)
public void Insert(int index, T item)
private void CheckCollection(IEnumerable`1<T> collection)
public void InsertRange(int index, IEnumerable`1<T> collection)
private void InsertCollection(int index, ICollection`1<T> collection)
private void InsertEnumeration(int index, IEnumerable`1<T> enumerable)
public int LastIndexOf(T item)
public int LastIndexOf(T item, int index)
public int LastIndexOf(T item, int index, int count)
public bool Remove(T item)
public int RemoveAll(Predicate`1<T> match)
public void RemoveAt(int index)
public void RemoveRange(int index, int count)
public void Reverse()
public void Reverse(int index, int count)
public void Sort()
public void Sort(IComparer`1<T> comparer)
public void Sort(Comparison`1<T> comparison)
public void Sort(int index, int count, IComparer`1<T> comparer)
public T[] ToArray()
public void TrimExcess()
public bool TrueForAll(Predicate`1<T> match)
public int get_Capacity()
public void set_Capacity(int value)
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
}
public System.Collections.Hashtable : object {
private int CHAIN_MARKER
private int inUse
private int modificationCount
private float loadFactor
private Slot[] table
private Int32[] hashes
private int threshold
private HashKeys hashKeys
private HashValues hashValues
private IHashCodeProvider hcpRef
private IComparer comparerRef
private SerializationInfo serializationInfo
private IEqualityComparer equalityComparer
private Int32[] primeTbl
protected IComparer comparer
protected IHashCodeProvider hcp
protected IEqualityComparer EqualityComparer
public int Count
public bool IsSynchronized
public object SyncRoot
public bool IsFixedSize
public bool IsReadOnly
public ICollection Keys
public ICollection Values
public object Item
public void .ctor(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(int capacity, float loadFactor)
public void .ctor(int capacity)
internal void .ctor(Hashtable source)
public void .ctor(int capacity, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IDictionary d, float loadFactor)
public void .ctor(IDictionary d)
public void .ctor(IDictionary d, IHashCodeProvider hcp, IComparer comparer)
public void .ctor(IHashCodeProvider hcp, IComparer comparer)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(IDictionary d, IEqualityComparer equalityComparer)
public void .ctor(IDictionary d, float loadFactor, IEqualityComparer equalityComparer)
public void .ctor(IEqualityComparer equalityComparer)
public void .ctor(int capacity, IEqualityComparer equalityComparer)
public void .ctor(int capacity, float loadFactor, IEqualityComparer equalityComparer)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
protected void set_comparer(IComparer value)
protected IComparer get_comparer()
protected void set_hcp(IHashCodeProvider value)
protected IHashCodeProvider get_hcp()
protected IEqualityComparer get_EqualityComparer()
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public ICollection get_Keys()
public ICollection get_Values()
public object get_Item(object key)
public void set_Item(object key, object value)
public void CopyTo(Array array, int arrayIndex)
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
public bool ContainsKey(object key)
public bool ContainsValue(object value)
public object Clone()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void OnDeserialization(object sender)
public Hashtable Synchronized(Hashtable table)
protected int GetHash(object key)
protected bool KeyEquals(object item, object key)
private void AdjustThreshold()
private void SetTable(Slot[] table, Int32[] hashes)
private int Find(object key)
private void Rehash()
private void PutImpl(object key, object value, bool overwrite)
private void CopyToArray(Array arr, int i, EnumeratorMode mode)
internal bool TestPrime(int x)
internal int CalcPrime(int x)
internal int ToPrime(int x)
}
public System.Collections.ICollection {
public int Count
public bool IsSynchronized
public object SyncRoot
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
}
public System.Collections.IComparer {
public int Compare(object x, object y)
}
public System.Collections.IDictionary {
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
}
public System.Collections.IDictionaryEnumerator {
public DictionaryEntry Entry
public object Key
public object Value
public DictionaryEntry get_Entry()
public object get_Key()
public object get_Value()
}
public System.Collections.IEnumerable {
public IEnumerator GetEnumerator()
}
public System.Collections.IEnumerator {
public object Current
public object get_Current()
public bool MoveNext()
public void Reset()
}
public System.Collections.IEqualityComparer {
public bool Equals(object x, object y)
public int GetHashCode(object obj)
}
public System.Collections.IHashCodeProvider {
public int GetHashCode(object obj)
}
public System.Collections.IList {
public bool IsFixedSize
public bool IsReadOnly
public object Item
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(int index)
public void set_Item(int index, object value)
public int Add(object value)
public void Clear()
public bool Contains(object value)
public int IndexOf(object value)
public void Insert(int index, object value)
public void Remove(object value)
public void RemoveAt(int index)
}
public System.Collections.ObjectModel.Collection`1 : object {
private IList`1<T> list
private object syncRoot
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
protected IList`1<T> Items
public int Count
public T Item
public void .ctor(IList`1<T> list)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public void Add(T item)
public void Clear()
protected void ClearItems()
public bool Contains(T item)
public void CopyTo(T[] array, int index)
public IEnumerator`1<T> GetEnumerator()
public int IndexOf(T item)
public void Insert(int index, T item)
protected void InsertItem(int index, T item)
protected IList`1<T> get_Items()
public bool Remove(T item)
public void RemoveAt(int index)
protected void RemoveItem(int index)
public int get_Count()
public T get_Item(int index)
public void set_Item(int index, T value)
protected void SetItem(int index, T item)
internal bool IsValidItem(object item)
internal T ConvertItem(object item)
internal void CheckWritable(IList`1<T> list)
internal bool IsSynchronized(IList`1<T> list)
internal bool IsFixedSize(IList`1<T> list)
}
public System.Collections.ObjectModel.KeyedCollection`2 : Collection`1<TItem> {
private Dictionary`2<TKey, TItem> dictionary
private IEqualityComparer`1<TKey> comparer
private int dictionaryCreationThreshold
public IEqualityComparer`1<TKey> Comparer
public TItem Item
protected IDictionary`2<TKey, TItem> Dictionary
protected void .ctor(IEqualityComparer`1<TKey> comparer)
protected void .ctor(IEqualityComparer`1<TKey> comparer, int dictionaryCreationThreshold)
public bool Contains(TKey key)
private int IndexOfKey(TKey key)
public bool Remove(TKey key)
public IEqualityComparer`1<TKey> get_Comparer()
public TItem get_Item(TKey key)
protected void ChangeItemKey(TItem item, TKey newKey)
protected void ClearItems()
protected TKey GetKeyForItem(TItem item)
protected void InsertItem(int index, TItem item)
protected void RemoveItem(int index)
protected void SetItem(int index, TItem item)
protected IDictionary`2<TKey, TItem> get_Dictionary()
}
public System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
private IList`1<T> list
private T System.Collections.Generic.IList<T>.Item
private bool System.Collections.Generic.ICollection<T>.IsReadOnly
private bool System.Collections.ICollection.IsSynchronized
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.IList.IsFixedSize
private bool System.Collections.IList.IsReadOnly
private object System.Collections.IList.Item
public int Count
protected IList`1<T> Items
public T Item
public void .ctor(IList`1<T> list)
private void System.Collections.Generic.ICollection<T>.Add(T item)
private void System.Collections.Generic.ICollection<T>.Clear()
private void System.Collections.Generic.IList<T>.Insert(int index, T item)
private bool System.Collections.Generic.ICollection<T>.Remove(T item)
private void System.Collections.Generic.IList<T>.RemoveAt(int index)
private T System.Collections.Generic.IList<T>.get_Item(int index)
private void System.Collections.Generic.IList<T>.set_Item(int index, T value)
private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private int System.Collections.IList.Add(object value)
private void System.Collections.IList.Clear()
private bool System.Collections.IList.Contains(object value)
private int System.Collections.IList.IndexOf(object value)
private void System.Collections.IList.Insert(int index, object value)
private void System.Collections.IList.Remove(object value)
private void System.Collections.IList.RemoveAt(int index)
private bool System.Collections.ICollection.get_IsSynchronized()
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.IList.get_IsFixedSize()
private bool System.Collections.IList.get_IsReadOnly()
private object System.Collections.IList.get_Item(int index)
private void System.Collections.IList.set_Item(int index, object value)
public bool Contains(T value)
public void CopyTo(T[] array, int index)
public IEnumerator`1<T> GetEnumerator()
public int IndexOf(T value)
public int get_Count()
protected IList`1<T> get_Items()
public T get_Item(int index)
}
public System.Collections.Queue : object {
private Object[] _array
private int _head
private int _size
private int _tail
private int _growFactor
private int _version
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(int capacity)
public void .ctor(ICollection col)
public void .ctor(int capacity, float growFactor)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public object Clone()
public void Clear()
public bool Contains(object obj)
public object Dequeue()
public void Enqueue(object obj)
public object Peek()
public Queue Synchronized(Queue queue)
public Object[] ToArray()
public void TrimToSize()
private void grow()
}
public System.Collections.ReadOnlyCollectionBase : object {
private ArrayList list
private object System.Collections.ICollection.SyncRoot
private bool System.Collections.ICollection.IsSynchronized
public int Count
protected ArrayList InnerList
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.Collections.ICollection.CopyTo(Array array, int index)
private object System.Collections.ICollection.get_SyncRoot()
private bool System.Collections.ICollection.get_IsSynchronized()
public int get_Count()
public IEnumerator GetEnumerator()
protected ArrayList get_InnerList()
}
public System.Collections.SortedList : object {
private int INITIAL_SIZE
private int inUse
private int modificationCount
private Slot[] table
private IComparer comparer
private int defaultCapacity
public int Count
public bool IsSynchronized
public object SyncRoot
public bool IsFixedSize
public bool IsReadOnly
public ICollection Keys
public ICollection Values
public object Item
public int Capacity
public void .ctor(int initialCapacity)
public void .ctor(IComparer comparer, int capacity)
public void .ctor(IComparer comparer)
public void .ctor(IDictionary d)
public void .ctor(IDictionary d, IComparer comparer)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public ICollection get_Keys()
public ICollection get_Values()
public object get_Item(object key)
public void set_Item(object key, object value)
public int get_Capacity()
public void set_Capacity(int value)
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
public void CopyTo(Array array, int arrayIndex)
public object Clone()
public IList GetKeyList()
public IList GetValueList()
public void RemoveAt(int index)
public int IndexOfKey(object key)
public int IndexOfValue(object value)
public bool ContainsKey(object key)
public bool ContainsValue(object value)
public object GetByIndex(int index)
public void SetByIndex(int index, object value)
public object GetKey(int index)
public SortedList Synchronized(SortedList list)
public void TrimToSize()
private void Resize(int n, bool copy)
private void EnsureCapacity(int n, int free)
private void PutImpl(object key, object value, bool overwrite)
private object GetImpl(object key)
private void InitTable(int capacity, bool forceSize)
private void CopyToArray(Array arr, int i, EnumeratorMode mode)
private int Find(object key)
}
public System.Collections.Stack : object {
private int default_capacity
private Object[] contents
private int current
private int count
private int capacity
private int modCount
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(ICollection col)
public void .ctor(int initialCapacity)
private void Resize(int ncapacity)
public Stack Synchronized(Stack stack)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void Clear()
public object Clone()
public bool Contains(object obj)
public void CopyTo(Array array, int index)
public IEnumerator GetEnumerator()
public object Peek()
public object Pop()
public void Push(object obj)
public Object[] ToArray()
}
public System.Comparison`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public int Invoke(T x, T y)
public IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object)
public int EndInvoke(IAsyncResult result)
}
public System.Configuration.Assemblies.AssemblyHash : ValueType {
private AssemblyHashAlgorithm _algorithm
private Byte[] _value
public AssemblyHash Empty
public AssemblyHashAlgorithm Algorithm
public void .ctor(AssemblyHashAlgorithm algorithm, Byte[] value)
public void .ctor(Byte[] value)
public AssemblyHashAlgorithm get_Algorithm()
public void set_Algorithm(AssemblyHashAlgorithm value)
public object Clone()
public Byte[] GetValue()
public void SetValue(Byte[] value)
}
public System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
public int value__
public AssemblyHashAlgorithm None
public AssemblyHashAlgorithm MD5
public AssemblyHashAlgorithm SHA1
}
public System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
public int value__
public AssemblyVersionCompatibility SameMachine
public AssemblyVersionCompatibility SameProcess
public AssemblyVersionCompatibility SameDomain
}
public System.Console : object {
internal TextWriter stdout
private TextWriter stderr
private TextReader stdin
private Encoding inputEncoding
private Encoding outputEncoding
private ConsoleCancelEventHandler cancel_event
private InternalCancelHandler cancel_handler
public TextWriter Error
public TextWriter Out
public TextReader In
public Encoding InputEncoding
public Encoding OutputEncoding
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorTop
public int CursorSize
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public void add_CancelKeyPress(ConsoleCancelEventHandler value)
public void remove_CancelKeyPress(ConsoleCancelEventHandler value)
private void SetEncodings(Encoding inputEncoding, Encoding outputEncoding)
public TextWriter get_Error()
public TextWriter get_Out()
public TextReader get_In()
public Stream OpenStandardError()
private Stream Open(IntPtr handle, FileAccess access, int bufferSize)
public Stream OpenStandardError(int bufferSize)
public Stream OpenStandardInput()
public Stream OpenStandardInput(int bufferSize)
public Stream OpenStandardOutput()
public Stream OpenStandardOutput(int bufferSize)
public void SetError(TextWriter newError)
public void SetIn(TextReader newIn)
public void SetOut(TextWriter newOut)
public void Write(bool value)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(decimal value)
public void Write(double value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(float value)
public void Write(string value)
public void Write(UInt32 value)
public void Write(ulong value)
public void Write(string format, object arg0)
public void Write(string format, Object[] arg)
public void Write(Char[] buffer, int index, int count)
public void Write(string format, object arg0, object arg1)
public void Write(string format, object arg0, object arg1, object arg2)
public void Write(string format, object arg0, object arg1, object arg2, object arg3)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(decimal value)
public void WriteLine(double value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(float value)
public void WriteLine(string value)
public void WriteLine(UInt32 value)
public void WriteLine(ulong value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, Object[] arg)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, object arg0, object arg1, object arg2)
public void WriteLine(string format, object arg0, object arg1, object arg2, object arg3)
public int Read()
public string ReadLine()
public Encoding get_InputEncoding()
public void set_InputEncoding(Encoding value)
public Encoding get_OutputEncoding()
public void set_OutputEncoding(Encoding value)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep()
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public ConsoleKeyInfo ReadKey()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
internal void DoConsoleCancelEvent()
}
public System.ConsoleCancelEventArgs : EventArgs {
private bool cancel
private ConsoleSpecialKey specialKey
public bool Cancel
public ConsoleSpecialKey SpecialKey
internal void .ctor(ConsoleSpecialKey key)
public bool get_Cancel()
public void set_Cancel(bool value)
public ConsoleSpecialKey get_SpecialKey()
}
public System.ConsoleCancelEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, ConsoleCancelEventArgs e)
public IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.ConsoleColor : Enum {
public int value__
public ConsoleColor Black
public ConsoleColor DarkBlue
public ConsoleColor DarkGreen
public ConsoleColor DarkCyan
public ConsoleColor DarkRed
public ConsoleColor DarkMagenta
public ConsoleColor DarkYellow
public ConsoleColor Gray
public ConsoleColor DarkGray
public ConsoleColor Blue
public ConsoleColor Green
public ConsoleColor Cyan
public ConsoleColor Red
public ConsoleColor Magenta
public ConsoleColor Yellow
public ConsoleColor White
}
internal System.ConsoleCursorInfo : ValueType {
public int Size
public bool Visible
}
internal System.ConsoleDriver : object {
internal IConsoleDriver driver
private bool is_console
private bool called_isatty
public bool Initialized
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public bool KeyAvailable
public ConsoleColor ForegroundColor
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public bool IsConsole
private IConsoleDriver CreateNullConsoleDriver()
private IConsoleDriver CreateWindowsConsoleDriver()
private IConsoleDriver CreateTermInfoDriver(string term)
public bool get_Initialized()
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public bool get_KeyAvailable()
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public int Read()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
public bool get_IsConsole()
private bool Isatty(IntPtr handle)
internal int InternalKeyAvailable(int ms_timeout)
internal bool TtySetup(string keypadXmit, string teardown, Byte[]& control_characters, Int32*& address)
internal bool SetEcho(bool wantEcho)
internal bool SetBreak(bool wantBreak)
}
public System.ConsoleKey : Enum {
public int value__
public ConsoleKey Backspace
public ConsoleKey Tab
public ConsoleKey Clear
public ConsoleKey Enter
public ConsoleKey Pause
public ConsoleKey Escape
public ConsoleKey Spacebar
public ConsoleKey PageUp
public ConsoleKey PageDown
public ConsoleKey End
public ConsoleKey Home
public ConsoleKey LeftArrow
public ConsoleKey UpArrow
public ConsoleKey RightArrow
public ConsoleKey DownArrow
public ConsoleKey Select
public ConsoleKey Print
public ConsoleKey Execute
public ConsoleKey PrintScreen
public ConsoleKey Insert
public ConsoleKey Delete
public ConsoleKey Help
public ConsoleKey D0
public ConsoleKey D1
public ConsoleKey D2
public ConsoleKey D3
public ConsoleKey D4
public ConsoleKey D5
public ConsoleKey D6
public ConsoleKey D7
public ConsoleKey D8
public ConsoleKey D9
public ConsoleKey A
public ConsoleKey B
public ConsoleKey C
public ConsoleKey D
public ConsoleKey E
public ConsoleKey F
public ConsoleKey G
public ConsoleKey H
public ConsoleKey I
public ConsoleKey J
public ConsoleKey K
public ConsoleKey L
public ConsoleKey M
public ConsoleKey N
public ConsoleKey O
public ConsoleKey P
public ConsoleKey Q
public ConsoleKey R
public ConsoleKey S
public ConsoleKey T
public ConsoleKey U
public ConsoleKey V
public ConsoleKey W
public ConsoleKey X
public ConsoleKey Y
public ConsoleKey Z
public ConsoleKey LeftWindows
public ConsoleKey RightWindows
public ConsoleKey Applications
public ConsoleKey Sleep
public ConsoleKey NumPad0
public ConsoleKey NumPad1
public ConsoleKey NumPad2
public ConsoleKey NumPad3
public ConsoleKey NumPad4
public ConsoleKey NumPad5
public ConsoleKey NumPad6
public ConsoleKey NumPad7
public ConsoleKey NumPad8
public ConsoleKey NumPad9
public ConsoleKey Multiply
public ConsoleKey Add
public ConsoleKey Separator
public ConsoleKey Subtract
public ConsoleKey Decimal
public ConsoleKey Divide
public ConsoleKey F1
public ConsoleKey F2
public ConsoleKey F3
public ConsoleKey F4
public ConsoleKey F5
public ConsoleKey F6
public ConsoleKey F7
public ConsoleKey F8
public ConsoleKey F9
public ConsoleKey F10
public ConsoleKey F11
public ConsoleKey F12
public ConsoleKey F13
public ConsoleKey F14
public ConsoleKey F15
public ConsoleKey F16
public ConsoleKey F17
public ConsoleKey F18
public ConsoleKey F19
public ConsoleKey F20
public ConsoleKey F21
public ConsoleKey F22
public ConsoleKey F23
public ConsoleKey F24
public ConsoleKey BrowserBack
public ConsoleKey BrowserForward
public ConsoleKey BrowserRefresh
public ConsoleKey BrowserStop
public ConsoleKey BrowserSearch
public ConsoleKey BrowserFavorites
public ConsoleKey BrowserHome
public ConsoleKey VolumeMute
public ConsoleKey VolumeDown
public ConsoleKey VolumeUp
public ConsoleKey MediaNext
public ConsoleKey MediaPrevious
public ConsoleKey MediaStop
public ConsoleKey MediaPlay
public ConsoleKey LaunchMail
public ConsoleKey LaunchMediaSelect
public ConsoleKey LaunchApp1
public ConsoleKey LaunchApp2
public ConsoleKey Oem1
public ConsoleKey OemPlus
public ConsoleKey OemComma
public ConsoleKey OemMinus
public ConsoleKey OemPeriod
public ConsoleKey Oem2
public ConsoleKey Oem3
public ConsoleKey Oem4
public ConsoleKey Oem5
public ConsoleKey Oem6
public ConsoleKey Oem7
public ConsoleKey Oem8
public ConsoleKey Oem102
public ConsoleKey Process
public ConsoleKey Packet
public ConsoleKey Attention
public ConsoleKey CrSel
public ConsoleKey ExSel
public ConsoleKey EraseEndOfFile
public ConsoleKey Play
public ConsoleKey Zoom
public ConsoleKey NoName
public ConsoleKey Pa1
public ConsoleKey OemClear
}
public System.ConsoleKeyInfo : ValueType {
internal ConsoleKeyInfo Empty
private ConsoleKey key
private char keychar
private ConsoleModifiers modifiers
public ConsoleKey Key
public char KeyChar
public ConsoleModifiers Modifiers
public void .ctor(char keyChar, ConsoleKey key, bool shift, bool alt, bool control)
internal void .ctor(ConsoleKeyInfo other)
internal void SetKey(ConsoleKey key)
internal void SetKeyChar(char keyChar)
internal void SetModifiers(bool shift, bool alt, bool control)
public ConsoleKey get_Key()
public char get_KeyChar()
public ConsoleModifiers get_Modifiers()
public bool Equals(object value)
public bool Equals(ConsoleKeyInfo obj)
public int GetHashCode()
public bool op_Equality(ConsoleKeyInfo a, ConsoleKeyInfo b)
public bool op_Inequality(ConsoleKeyInfo a, ConsoleKeyInfo b)
}
public System.ConsoleModifiers : Enum {
public int value__
public ConsoleModifiers Alt
public ConsoleModifiers Shift
public ConsoleModifiers Control
}
internal System.ConsoleScreenBufferInfo : ValueType {
public Coord Size
public Coord CursorPosition
public short Attribute
public SmallRect Window
public Coord MaxWindowSize
}
public System.ConsoleSpecialKey : Enum {
public int value__
public ConsoleSpecialKey ControlC
public ConsoleSpecialKey ControlBreak
}
public System.ContextMarshalException : SystemException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
internal System.ControlCharacters : object {
public int Intr
public int Quit
public int Erase
public int Kill
public int EOF
public int Time
public int Min
public int SWTC
public int Start
public int Stop
public int Susp
public int EOL
public int Reprint
public int Discard
public int WErase
public int LNext
public int EOL2
}
public System.Convert : object {
private int MaxBytesPerLine
public object DBNull
private Type[] conversionTable
private Byte[] InternalFromBase64String(string str, bool allowWhitespaceOnly)
private Byte[] InternalFromBase64CharArray(Char[] arr, int offset, int length)
public Byte[] FromBase64CharArray(Char[] inArray, int offset, int length)
public Byte[] FromBase64String(string s)
public TypeCode GetTypeCode(object value)
public bool IsDBNull(object value)
public int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut)
public string ToBase64String(Byte[] inArray)
public string ToBase64String(Byte[] inArray, int offset, int length)
public string ToBase64String(Byte[] inArray, Base64FormattingOptions options)
public string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options)
public int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options)
private StringBuilder ToBase64StringBuilderWithLine(Byte[] inArray, int offset, int length)
public bool ToBoolean(bool value)
public bool ToBoolean(byte value)
public bool ToBoolean(char value)
public bool ToBoolean(DateTime value)
public bool ToBoolean(decimal value)
public bool ToBoolean(double value)
public bool ToBoolean(float value)
public bool ToBoolean(int value)
public bool ToBoolean(long value)
public bool ToBoolean(sbyte value)
public bool ToBoolean(short value)
public bool ToBoolean(string value)
public bool ToBoolean(string value, IFormatProvider provider)
public bool ToBoolean(UInt32 value)
public bool ToBoolean(ulong value)
public bool ToBoolean(ushort value)
public bool ToBoolean(object value)
public bool ToBoolean(object value, IFormatProvider provider)
public byte ToByte(bool value)
public byte ToByte(byte value)
public byte ToByte(char value)
public byte ToByte(DateTime value)
public byte ToByte(decimal value)
public byte ToByte(double value)
public byte ToByte(float value)
public byte ToByte(int value)
public byte ToByte(long value)
public byte ToByte(sbyte value)
public byte ToByte(short value)
public byte ToByte(string value)
public byte ToByte(string value, IFormatProvider provider)
public byte ToByte(string value, int fromBase)
public byte ToByte(UInt32 value)
public byte ToByte(ulong value)
public byte ToByte(ushort value)
public byte ToByte(object value)
public byte ToByte(object value, IFormatProvider provider)
public char ToChar(bool value)
public char ToChar(byte value)
public char ToChar(char value)
public char ToChar(DateTime value)
public char ToChar(decimal value)
public char ToChar(double value)
public char ToChar(int value)
public char ToChar(long value)
public char ToChar(float value)
public char ToChar(sbyte value)
public char ToChar(short value)
public char ToChar(string value)
public char ToChar(string value, IFormatProvider provider)
public char ToChar(UInt32 value)
public char ToChar(ulong value)
public char ToChar(ushort value)
public char ToChar(object value)
public char ToChar(object value, IFormatProvider provider)
public DateTime ToDateTime(string value)
public DateTime ToDateTime(string value, IFormatProvider provider)
public DateTime ToDateTime(bool value)
public DateTime ToDateTime(byte value)
public DateTime ToDateTime(char value)
public DateTime ToDateTime(DateTime value)
public DateTime ToDateTime(decimal value)
public DateTime ToDateTime(double value)
public DateTime ToDateTime(short value)
public DateTime ToDateTime(int value)
public DateTime ToDateTime(long value)
public DateTime ToDateTime(float value)
public DateTime ToDateTime(object value)
public DateTime ToDateTime(object value, IFormatProvider provider)
public DateTime ToDateTime(sbyte value)
public DateTime ToDateTime(ushort value)
public DateTime ToDateTime(UInt32 value)
public DateTime ToDateTime(ulong value)
public decimal ToDecimal(bool value)
public decimal ToDecimal(byte value)
public decimal ToDecimal(char value)
public decimal ToDecimal(DateTime value)
public decimal ToDecimal(decimal value)
public decimal ToDecimal(double value)
public decimal ToDecimal(float value)
public decimal ToDecimal(int value)
public decimal ToDecimal(long value)
public decimal ToDecimal(sbyte value)
public decimal ToDecimal(short value)
public decimal ToDecimal(string value)
public decimal ToDecimal(string value, IFormatProvider provider)
public decimal ToDecimal(UInt32 value)
public decimal ToDecimal(ulong value)
public decimal ToDecimal(ushort value)
public decimal ToDecimal(object value)
public decimal ToDecimal(object value, IFormatProvider provider)
public double ToDouble(bool value)
public double ToDouble(byte value)
public double ToDouble(char value)
public double ToDouble(DateTime value)
public double ToDouble(decimal value)
public double ToDouble(double value)
public double ToDouble(float value)
public double ToDouble(int value)
public double ToDouble(long value)
public double ToDouble(sbyte value)
public double ToDouble(short value)
public double ToDouble(string value)
public double ToDouble(string value, IFormatProvider provider)
public double ToDouble(UInt32 value)
public double ToDouble(ulong value)
public double ToDouble(ushort value)
public double ToDouble(object value)
public double ToDouble(object value, IFormatProvider provider)
public short ToInt16(bool value)
public short ToInt16(byte value)
public short ToInt16(char value)
public short ToInt16(DateTime value)
public short ToInt16(decimal value)
public short ToInt16(double value)
public short ToInt16(float value)
public short ToInt16(int value)
public short ToInt16(long value)
public short ToInt16(sbyte value)
public short ToInt16(short value)
public short ToInt16(string value)
public short ToInt16(string value, IFormatProvider provider)
public short ToInt16(string value, int fromBase)
public short ToInt16(UInt32 value)
public short ToInt16(ulong value)
public short ToInt16(ushort value)
public short ToInt16(object value)
public short ToInt16(object value, IFormatProvider provider)
public int ToInt32(bool value)
public int ToInt32(byte value)
public int ToInt32(char value)
public int ToInt32(DateTime value)
public int ToInt32(decimal value)
public int ToInt32(double value)
public int ToInt32(float value)
public int ToInt32(int value)
public int ToInt32(long value)
public int ToInt32(sbyte value)
public int ToInt32(short value)
public int ToInt32(string value)
public int ToInt32(string value, IFormatProvider provider)
public int ToInt32(string value, int fromBase)
public int ToInt32(UInt32 value)
public int ToInt32(ulong value)
public int ToInt32(ushort value)
public int ToInt32(object value)
public int ToInt32(object value, IFormatProvider provider)
public long ToInt64(bool value)
public long ToInt64(byte value)
public long ToInt64(char value)
public long ToInt64(DateTime value)
public long ToInt64(decimal value)
public long ToInt64(double value)
public long ToInt64(float value)
public long ToInt64(int value)
public long ToInt64(long value)
public long ToInt64(sbyte value)
public long ToInt64(short value)
public long ToInt64(string value)
public long ToInt64(string value, IFormatProvider provider)
public long ToInt64(string value, int fromBase)
public long ToInt64(UInt32 value)
public long ToInt64(ulong value)
public long ToInt64(ushort value)
public long ToInt64(object value)
public long ToInt64(object value, IFormatProvider provider)
public sbyte ToSByte(bool value)
public sbyte ToSByte(byte value)
public sbyte ToSByte(char value)
public sbyte ToSByte(DateTime value)
public sbyte ToSByte(decimal value)
public sbyte ToSByte(double value)
public sbyte ToSByte(float value)
public sbyte ToSByte(int value)
public sbyte ToSByte(long value)
public sbyte ToSByte(sbyte value)
public sbyte ToSByte(short value)
public sbyte ToSByte(string value)
public sbyte ToSByte(string value, IFormatProvider provider)
public sbyte ToSByte(string value, int fromBase)
public sbyte ToSByte(UInt32 value)
public sbyte ToSByte(ulong value)
public sbyte ToSByte(ushort value)
public sbyte ToSByte(object value)
public sbyte ToSByte(object value, IFormatProvider provider)
public float ToSingle(bool value)
public float ToSingle(byte value)
public float ToSingle(char value)
public float ToSingle(DateTime value)
public float ToSingle(decimal value)
public float ToSingle(double value)
public float ToSingle(float value)
public float ToSingle(int value)
public float ToSingle(long value)
public float ToSingle(sbyte value)
public float ToSingle(short value)
public float ToSingle(string value)
public float ToSingle(string value, IFormatProvider provider)
public float ToSingle(UInt32 value)
public float ToSingle(ulong value)
public float ToSingle(ushort value)
public float ToSingle(object value)
public float ToSingle(object value, IFormatProvider provider)
public string ToString(bool value)
public string ToString(bool value, IFormatProvider provider)
public string ToString(byte value)
public string ToString(byte value, IFormatProvider provider)
public string ToString(byte value, int toBase)
public string ToString(char value)
public string ToString(char value, IFormatProvider provider)
public string ToString(DateTime value)
public string ToString(DateTime value, IFormatProvider provider)
public string ToString(decimal value)
public string ToString(decimal value, IFormatProvider provider)
public string ToString(double value)
public string ToString(double value, IFormatProvider provider)
public string ToString(float value)
public string ToString(float value, IFormatProvider provider)
public string ToString(int value)
public string ToString(int value, int toBase)
public string ToString(int value, IFormatProvider provider)
public string ToString(long value)
public string ToString(long value, int toBase)
public string ToString(long value, IFormatProvider provider)
public string ToString(object value)
public string ToString(object value, IFormatProvider provider)
public string ToString(sbyte value)
public string ToString(sbyte value, IFormatProvider provider)
public string ToString(short value)
public string ToString(short value, int toBase)
public string ToString(short value, IFormatProvider provider)
public string ToString(string value)
public string ToString(string value, IFormatProvider provider)
public string ToString(UInt32 value)
public string ToString(UInt32 value, IFormatProvider provider)
public string ToString(ulong value)
public string ToString(ulong value, IFormatProvider provider)
public string ToString(ushort value)
public string ToString(ushort value, IFormatProvider provider)
public ushort ToUInt16(bool value)
public ushort ToUInt16(byte value)
public ushort ToUInt16(char value)
public ushort ToUInt16(DateTime value)
public ushort ToUInt16(decimal value)
public ushort ToUInt16(double value)
public ushort ToUInt16(float value)
public ushort ToUInt16(int value)
public ushort ToUInt16(long value)
public ushort ToUInt16(sbyte value)
public ushort ToUInt16(short value)
public ushort ToUInt16(string value)
public ushort ToUInt16(string value, IFormatProvider provider)
public ushort ToUInt16(string value, int fromBase)
public ushort ToUInt16(UInt32 value)
public ushort ToUInt16(ulong value)
public ushort ToUInt16(ushort value)
public ushort ToUInt16(object value)
public ushort ToUInt16(object value, IFormatProvider provider)
public UInt32 ToUInt32(bool value)
public UInt32 ToUInt32(byte value)
public UInt32 ToUInt32(char value)
public UInt32 ToUInt32(DateTime value)
public UInt32 ToUInt32(decimal value)
public UInt32 ToUInt32(double value)
public UInt32 ToUInt32(float value)
public UInt32 ToUInt32(int value)
public UInt32 ToUInt32(long value)
public UInt32 ToUInt32(sbyte value)
public UInt32 ToUInt32(short value)
public UInt32 ToUInt32(string value)
public UInt32 ToUInt32(string value, IFormatProvider provider)
public UInt32 ToUInt32(string value, int fromBase)
public UInt32 ToUInt32(UInt32 value)
public UInt32 ToUInt32(ulong value)
public UInt32 ToUInt32(ushort value)
public UInt32 ToUInt32(object value)
public UInt32 ToUInt32(object value, IFormatProvider provider)
public ulong ToUInt64(bool value)
public ulong ToUInt64(byte value)
public ulong ToUInt64(char value)
public ulong ToUInt64(DateTime value)
public ulong ToUInt64(decimal value)
public ulong ToUInt64(double value)
public ulong ToUInt64(float value)
public ulong ToUInt64(int value)
public ulong ToUInt64(long value)
public ulong ToUInt64(sbyte value)
public ulong ToUInt64(short value)
public ulong ToUInt64(string value)
public ulong ToUInt64(string value, IFormatProvider provider)
public ulong ToUInt64(string value, int fromBase)
public ulong ToUInt64(UInt32 value)
public ulong ToUInt64(ulong value)
public ulong ToUInt64(ushort value)
public ulong ToUInt64(object value)
public ulong ToUInt64(object value, IFormatProvider provider)
public object ChangeType(object value, Type conversionType)
public object ChangeType(object value, TypeCode typeCode)
public object ChangeType(object value, Type conversionType, IFormatProvider provider)
public object ChangeType(object value, TypeCode typeCode, IFormatProvider provider)
private bool NotValidBase(int value)
private int ConvertFromBase(string value, int fromBase, bool unsigned)
private long ConvertFromBase64(string value, int fromBase, bool unsigned)
private void EndianSwap(Byte[]& value)
private string ConvertToBase2(Byte[] value)
private string ConvertToBase8(Byte[] value)
private string ConvertToBase16(Byte[] value)
internal object ToType(object value, Type conversionType, IFormatProvider provider, bool try_target_to_type)
}
public System.Converter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public TOutput Invoke(TInput input)
public IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object)
public TOutput EndInvoke(IAsyncResult result)
}
internal System.Coord : ValueType {
public short X
public short Y
public void .ctor(int x, int y)
}
public System.CrossAppDomainDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.CultureAwareComparer : StringComparer {
private bool _ignoreCase
private CompareInfo _compareInfo
public void .ctor(CultureInfo ci, bool ignore_case)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string s)
}
internal System.CurrentSystemTimeZone : TimeZone {
private string m_standardName
private string m_daylightName
private Hashtable m_CachedDaylightChanges
private long m_ticksOffset
private TimeSpan utcOffsetWithOutDLS
private TimeSpan utcOffsetWithDLS
private int this_year
private DaylightTime this_year_dlt
public string DaylightName
public string StandardName
internal void .ctor(long lnow)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private bool GetTimeZoneData(int year, Int64[]& data, String[]& names)
public string get_DaylightName()
public string get_StandardName()
public DaylightTime GetDaylightChanges(int year)
public TimeSpan GetUtcOffset(DateTime time)
private void OnDeserialization(DaylightTime dlt)
private DaylightTime GetDaylightTimeFromData(Int64[] data)
}
public System.DataMisalignedException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.DateTime : ValueType {
private int dp400
private int dp100
private int dp4
private long w32file_epoch
private long MAX_VALUE_TICKS
internal long UnixEpoch
private long ticks18991230
private double OAMinValue
private double OAMaxValue
private string formatExceptionMessage
private TimeSpan ticks
private DateTimeKind kind
public DateTime MaxValue
public DateTime MinValue
private String[] ParseTimeFormats
private String[] ParseYearDayMonthFormats
private String[] ParseYearMonthDayFormats
private String[] ParseDayMonthYearFormats
private String[] ParseMonthDayYearFormats
private String[] MonthDayShortFormats
private String[] DayMonthShortFormats
private Int32[] daysmonth
private Int32[] daysmonthleap
private object to_local_time_span_object
private long last_now
public DateTime Date
public int Month
public int Day
public DayOfWeek DayOfWeek
public int DayOfYear
public TimeSpan TimeOfDay
public int Hour
public int Minute
public int Second
public int Millisecond
public DateTime Now
public long Ticks
public DateTime Today
public DateTime UtcNow
public int Year
public DateTimeKind Kind
public void .ctor(long ticks)
public void .ctor(int year, int month, int day)
public void .ctor(int year, int month, int day, int hour, int minute, int second)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond)
public void .ctor(int year, int month, int day, Calendar calendar)
public void .ctor(int year, int month, int day, int hour, int minute, int second, Calendar calendar)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar)
internal void .ctor(bool check, TimeSpan value)
public void .ctor(long ticks, DateTimeKind kind)
public void .ctor(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private int AbsoluteDays(int year, int month, int day)
private int FromTicks(Which what)
public DateTime get_Date()
public int get_Month()
public int get_Day()
public DayOfWeek get_DayOfWeek()
public int get_DayOfYear()
public TimeSpan get_TimeOfDay()
public int get_Hour()
public int get_Minute()
public int get_Second()
public int get_Millisecond()
internal long GetTimeMonotonic()
internal long GetNow()
public DateTime get_Now()
public long get_Ticks()
public DateTime get_Today()
public DateTime get_UtcNow()
public int get_Year()
public DateTimeKind get_Kind()
public DateTime Add(TimeSpan value)
public DateTime AddDays(double value)
public DateTime AddTicks(long value)
public DateTime AddHours(double value)
public DateTime AddMilliseconds(double value)
private DateTime AddRoundedMilliseconds(double ms)
public DateTime AddMinutes(double value)
public DateTime AddMonths(int months)
public DateTime AddSeconds(double value)
public DateTime AddYears(int value)
public int Compare(DateTime t1, DateTime t2)
public int CompareTo(object value)
public bool IsDaylightSavingTime()
public int CompareTo(DateTime value)
public bool Equals(DateTime value)
public long ToBinary()
public DateTime FromBinary(long dateData)
public DateTime SpecifyKind(DateTime value, DateTimeKind kind)
public int DaysInMonth(int year, int month)
public bool Equals(object value)
public bool Equals(DateTime t1, DateTime t2)
public DateTime FromFileTime(long fileTime)
public DateTime FromFileTimeUtc(long fileTime)
public DateTime FromOADate(double d)
public String[] GetDateTimeFormats()
public String[] GetDateTimeFormats(char format)
public String[] GetDateTimeFormats(IFormatProvider provider)
public String[] GetDateTimeFormats(char format, IFormatProvider provider)
private String[] GetDateTimeFormats(bool adjustutc, String[] patterns, DateTimeFormatInfo dfi)
private void CheckDateTimeKind(DateTimeKind kind)
public int GetHashCode()
public TypeCode GetTypeCode()
public bool IsLeapYear(int year)
public DateTime Parse(string s)
public DateTime Parse(string s, IFormatProvider provider)
public DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles)
internal bool CoreParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result, DateTimeOffset& dto, bool setExceptionOnError, Exception& exception)
public DateTime ParseExact(string s, string format, IFormatProvider provider)
private String[] YearMonthDayFormats(DateTimeFormatInfo dfi, bool setExceptionOnError, Exception& exc)
private int _ParseNumber(string s, int valuePos, int min_digits, int digits, bool leadingzero, bool sloppy_parsing, Int32& num_parsed)
private int _ParseEnum(string s, int sPos, String[] values, String[] invValues, bool exact, Int32& num_parsed)
private bool _ParseString(string s, int sPos, int maxlength, string value, Int32& num_parsed)
private bool _ParseAmPm(string s, int valuePos, int num, DateTimeFormatInfo dfi, bool exact, Int32& num_parsed, Int32& ampm)
private bool _ParseTimeSeparator(string s, int sPos, DateTimeFormatInfo dfi, bool exact, Int32& num_parsed)
private bool _ParseDateSeparator(string s, int sPos, DateTimeFormatInfo dfi, bool exact, Int32& num_parsed)
private bool IsLetter(string s, int pos)
private bool _DoParse(string s, string firstPart, string secondPart, bool exact, DateTime& result, DateTimeOffset& dto, DateTimeFormatInfo dfi, DateTimeStyles style, bool firstPartIsDate, Boolean& incompleteFormat, Boolean& longYear)
public DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style)
public DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style)
private void CheckStyle(DateTimeStyles style)
public bool TryParse(string s, DateTime& result)
public bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result)
public bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result)
public bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result)
private bool ParseExact(string s, String[] formats, DateTimeFormatInfo dfi, DateTimeStyles style, DateTime& ret, bool exact, Boolean& longYear, bool setExceptionOnError, Exception& exception)
public TimeSpan Subtract(DateTime value)
public DateTime Subtract(TimeSpan value)
public long ToFileTime()
public long ToFileTimeUtc()
public string ToLongDateString()
public string ToLongTimeString()
public double ToOADate()
public string ToShortDateString()
public string ToShortTimeString()
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public DateTime ToLocalTime()
public DateTime ToUniversalTime()
public DateTime op_Addition(DateTime d, TimeSpan t)
public bool op_Equality(DateTime d1, DateTime d2)
public bool op_GreaterThan(DateTime t1, DateTime t2)
public bool op_GreaterThanOrEqual(DateTime t1, DateTime t2)
public bool op_Inequality(DateTime d1, DateTime d2)
public bool op_LessThan(DateTime t1, DateTime t2)
public bool op_LessThanOrEqual(DateTime t1, DateTime t2)
public TimeSpan op_Subtraction(DateTime d1, DateTime d2)
public DateTime op_Subtraction(DateTime d, TimeSpan t)
}
public System.DateTimeKind : Enum {
public int value__
public DateTimeKind Unspecified
public DateTimeKind Utc
public DateTimeKind Local
}
public System.DateTimeOffset : ValueType {
public DateTimeOffset MaxValue
public DateTimeOffset MinValue
private DateTime dt
private TimeSpan utc_offset
public DateTime Date
public DateTime DateTime
public int Day
public DayOfWeek DayOfWeek
public int DayOfYear
public int Hour
public DateTime LocalDateTime
public int Millisecond
public int Minute
public int Month
public DateTimeOffset Now
public TimeSpan Offset
public int Second
public long Ticks
public TimeSpan TimeOfDay
public DateTime UtcDateTime
public DateTimeOffset UtcNow
public long UtcTicks
public int Year
public void .ctor(DateTime dateTime)
public void .ctor(DateTime dateTime, TimeSpan offset)
public void .ctor(long ticks, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset)
public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset)
private void .ctor(SerializationInfo info, StreamingContext context)
private int System.IComparable.CompareTo(object obj)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
public DateTimeOffset Add(TimeSpan timeSpan)
public DateTimeOffset AddDays(double days)
public DateTimeOffset AddHours(double hours)
public DateTimeOffset AddMilliseconds(double milliseconds)
public DateTimeOffset AddMinutes(double minutes)
public DateTimeOffset AddMonths(int months)
public DateTimeOffset AddSeconds(double seconds)
public DateTimeOffset AddTicks(long ticks)
public DateTimeOffset AddYears(int years)
public int Compare(DateTimeOffset first, DateTimeOffset second)
public int CompareTo(DateTimeOffset other)
public bool Equals(DateTimeOffset other)
public bool Equals(object obj)
public bool Equals(DateTimeOffset first, DateTimeOffset second)
public bool EqualsExact(DateTimeOffset other)
public DateTimeOffset FromFileTime(long fileTime)
public int GetHashCode()
public DateTimeOffset Parse(string input)
public DateTimeOffset Parse(string input, IFormatProvider formatProvider)
public DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles)
public DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider)
public DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles)
public DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles)
private bool ParseExact(string input, String[] formats, DateTimeFormatInfo dfi, DateTimeStyles styles, DateTimeOffset& ret)
private bool DoParse(string input, string format, bool exact, DateTimeOffset& result, DateTimeFormatInfo dfi, DateTimeStyles styles)
private int ParseNumber(string input, int pos, int digits, bool leading_zero, bool allow_leading_white, Int32& result)
private int ParseNumber(string input, int pos, int digits, bool leading_zero, bool allow_leading_white, Int32& result, Int32& digit_parsed)
private int ParseEnum(string input, int pos, String[] enums, bool allow_leading_white, Int32& result)
private int ParseChar(string input, int pos, char c, bool allow_leading_white, Int32& result)
public TimeSpan Subtract(DateTimeOffset value)
public DateTimeOffset Subtract(TimeSpan value)
public long ToFileTime()
public DateTimeOffset ToLocalTime()
public DateTimeOffset ToOffset(TimeSpan offset)
public string ToString()
public string ToString(IFormatProvider formatProvider)
public string ToString(string format)
public string ToString(string format, IFormatProvider formatProvider)
public DateTimeOffset ToUniversalTime()
public bool TryParse(string input, DateTimeOffset& result)
public bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
public bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
public bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result)
public DateTime get_Date()
public DateTime get_DateTime()
public int get_Day()
public DayOfWeek get_DayOfWeek()
public int get_DayOfYear()
public int get_Hour()
public DateTime get_LocalDateTime()
public int get_Millisecond()
public int get_Minute()
public int get_Month()
public DateTimeOffset get_Now()
public TimeSpan get_Offset()
public int get_Second()
public long get_Ticks()
public TimeSpan get_TimeOfDay()
public DateTime get_UtcDateTime()
public DateTimeOffset get_UtcNow()
public long get_UtcTicks()
public int get_Year()
public DateTimeOffset op_Addition(DateTimeOffset dateTimeTz, TimeSpan timeSpan)
public bool op_Equality(DateTimeOffset left, DateTimeOffset right)
public bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right)
public bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right)
public DateTimeOffset op_Implicit(DateTime dateTime)
public bool op_Inequality(DateTimeOffset left, DateTimeOffset right)
public bool op_LessThan(DateTimeOffset left, DateTimeOffset right)
public bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right)
public TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right)
public DateTimeOffset op_Subtraction(DateTimeOffset dateTimeTz, TimeSpan timeSpan)
}
internal System.DateTimeUtils : object {
public int CountRepeat(string fmt, int p, char c)
public void ZeroPad(StringBuilder output, int digits, int len)
public int ParseQuotedString(string fmt, int pos, StringBuilder output)
public string GetStandardPattern(char format, DateTimeFormatInfo dfi, Boolean& useutc, Boolean& use_invariant)
public string GetStandardPattern(char format, DateTimeFormatInfo dfi, Boolean& useutc, Boolean& use_invariant, bool date_time_offset)
public string ToString(DateTime dt, string format, DateTimeFormatInfo dfi)
public string ToString(DateTime dt, Nullable`1<TimeSpan> utc_offset, string format, DateTimeFormatInfo dfi)
}
public System.DayOfWeek : Enum {
public int value__
public DayOfWeek Sunday
public DayOfWeek Monday
public DayOfWeek Tuesday
public DayOfWeek Wednesday
public DayOfWeek Thursday
public DayOfWeek Friday
public DayOfWeek Saturday
}
public System.DBNull : object {
public DBNull Value
private void .ctor(SerializationInfo info, StreamingContext context)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public TypeCode GetTypeCode()
public string ToString()
public string ToString(IFormatProvider provider)
}
public System.Decimal : ValueType {
public decimal MinValue
public decimal MaxValue
public decimal MinusOne
public decimal One
public decimal Zero
private int DECIMAL_DIVIDE_BY_ZERO
private UInt32 MAX_SCALE
private int iMAX_SCALE
private UInt32 SIGN_FLAG
private UInt32 SCALE_MASK
private int SCALE_SHIFT
private UInt32 RESERVED_SS32_BITS
private decimal MaxValueDiv10
private UInt32 flags
private UInt32 hi
private UInt32 lo
private UInt32 mid
public void .ctor(int lo, int mid, int hi, bool isNegative, byte scale)
public void .ctor(int value)
public void .ctor(UInt32 value)
public void .ctor(long value)
public void .ctor(ulong value)
public void .ctor(float value)
public void .ctor(double value)
public void .ctor(Int32[] bits)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public decimal FromOACurrency(long cy)
public Int32[] GetBits(decimal d)
public decimal Negate(decimal d)
public decimal Add(decimal d1, decimal d2)
public decimal Subtract(decimal d1, decimal d2)
public int GetHashCode()
private ulong u64(decimal value)
private long s64(decimal value)
public bool Equals(decimal d1, decimal d2)
public bool Equals(object value)
private bool IsZero()
private bool IsNegative()
public decimal Floor(decimal d)
public decimal Truncate(decimal d)
public decimal Round(decimal d, int decimals)
public decimal Round(decimal d, int decimals, MidpointRounding mode)
public decimal Round(decimal d)
public decimal Round(decimal d, MidpointRounding mode)
public decimal Multiply(decimal d1, decimal d2)
public decimal Divide(decimal d1, decimal d2)
public decimal Remainder(decimal d1, decimal d2)
public int Compare(decimal d1, decimal d2)
public int CompareTo(object value)
public int CompareTo(decimal value)
public bool Equals(decimal value)
public decimal Ceiling(decimal d)
public decimal Parse(string s)
public decimal Parse(string s, NumberStyles style)
public decimal Parse(string s, IFormatProvider provider)
private void ThrowAtPos(int pos)
private void ThrowInvalidExp()
private string stripStyles(string s, NumberStyles style, NumberFormatInfo nfi, Int32& decPos, Boolean& isNegative, Boolean& expFlag, Int32& exp, bool throwex)
public decimal Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Decimal& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result)
private bool PerformParse(string s, NumberStyles style, IFormatProvider provider, Decimal& res, bool throwex)
public TypeCode GetTypeCode()
public byte ToByte(decimal value)
public double ToDouble(decimal d)
public short ToInt16(decimal value)
public int ToInt32(decimal d)
public long ToInt64(decimal d)
public long ToOACurrency(decimal value)
public sbyte ToSByte(decimal value)
public float ToSingle(decimal d)
public ushort ToUInt16(decimal value)
public UInt32 ToUInt32(decimal d)
public ulong ToUInt64(decimal d)
public string ToString(string format, IFormatProvider provider)
public string ToString()
public string ToString(string format)
public string ToString(IFormatProvider provider)
private int decimal2UInt64(Decimal& val, UInt64& result)
private int decimal2Int64(Decimal& val, Int64& result)
private int decimalIncr(Decimal& d1, Decimal& d2)
internal int decimal2string(Decimal& val, int digits, int decimals, Char[] bufDigits, int bufSize, Int32& decPos, Int32& sign)
internal int string2decimal(Decimal& val, string sDigits, UInt32 decPos, int sign)
internal int decimalSetExponent(Decimal& val, int exp)
private double decimal2double(Decimal& val)
private void decimalFloorAndTrunc(Decimal& val, int floorFlag)
private int decimalMult(Decimal& pd1, Decimal& pd2)
private int decimalDiv(Decimal& pc, Decimal& pa, Decimal& pb)
private int decimalIntDiv(Decimal& pc, Decimal& pa, Decimal& pb)
private int decimalCompare(Decimal& d1, Decimal& d2)
public decimal op_Addition(decimal d1, decimal d2)
public decimal op_Decrement(decimal d)
public decimal op_Increment(decimal d)
public decimal op_Subtraction(decimal d1, decimal d2)
public decimal op_UnaryNegation(decimal d)
public decimal op_UnaryPlus(decimal d)
public decimal op_Multiply(decimal d1, decimal d2)
public decimal op_Division(decimal d1, decimal d2)
public decimal op_Modulus(decimal d1, decimal d2)
public byte op_Explicit(decimal value)
public sbyte op_Explicit(decimal value)
public char op_Explicit(decimal value)
public short op_Explicit(decimal value)
public ushort op_Explicit(decimal value)
public int op_Explicit(decimal value)
public UInt32 op_Explicit(decimal value)
public long op_Explicit(decimal value)
public ulong op_Explicit(decimal value)
public decimal op_Implicit(byte value)
public decimal op_Implicit(sbyte value)
public decimal op_Implicit(short value)
public decimal op_Implicit(ushort value)
public decimal op_Implicit(char value)
public decimal op_Implicit(int value)
public decimal op_Implicit(UInt32 value)
public decimal op_Implicit(long value)
public decimal op_Implicit(ulong value)
public decimal op_Explicit(float value)
public decimal op_Explicit(double value)
public float op_Explicit(decimal value)
public double op_Explicit(decimal value)
public bool op_Inequality(decimal d1, decimal d2)
public bool op_Equality(decimal d1, decimal d2)
public bool op_GreaterThan(decimal d1, decimal d2)
public bool op_GreaterThanOrEqual(decimal d1, decimal d2)
public bool op_LessThan(decimal d1, decimal d2)
public bool op_LessThanOrEqual(decimal d1, decimal d2)
}
public System.Delegate : object {
private IntPtr method_ptr
private IntPtr invoke_impl
private object m_target
private IntPtr method
private IntPtr delegate_trampoline
private IntPtr method_code
private MethodInfo method_info
private MethodInfo original_method_info
private DelegateData data
public MethodInfo Method
public object Target
protected void .ctor(object target, string method)
protected void .ctor(Type target, string method)
public MethodInfo get_Method()
public object get_Target()
internal Delegate CreateDelegate_internal(Type type, object target, MethodInfo info, bool throwOnBindFailure)
internal void SetMulticastInvoke()
private bool arg_type_match(Type delArgType, Type argType)
private bool return_type_match(Type delReturnType, Type returnType)
public Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method)
public Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, MethodInfo method)
public Delegate CreateDelegate(Type type, object target, string method)
private MethodInfo GetCandidateMethod(Type type, Type target, string method, BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, Type target, string method)
public Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase)
public Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure)
public Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase)
public object DynamicInvoke(Object[] args)
protected object DynamicInvokeImpl(Object[] args)
public object Clone()
public bool Equals(object obj)
public int GetHashCode()
protected MethodInfo GetMethodImpl()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Delegate[] GetInvocationList()
public Delegate Combine(Delegate a, Delegate b)
public Delegate Combine(Delegate[] delegates)
protected Delegate CombineImpl(Delegate d)
public Delegate Remove(Delegate source, Delegate value)
protected Delegate RemoveImpl(Delegate d)
public Delegate RemoveAll(Delegate source, Delegate value)
public bool op_Equality(Delegate d1, Delegate d2)
public bool op_Inequality(Delegate d1, Delegate d2)
}
internal System.DelegateData : object {
public Type target_type
public string method_name
}
internal System.DelegateSerializationHolder : object {
private Delegate _delegate
private void .ctor(SerializationInfo info, StreamingContext ctx)
public void GetDelegateData(Delegate instance, SerializationInfo info, StreamingContext ctx)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Deployment.Internal.InternalActivationContextHelper : object {
public object GetActivationContextData(ActivationContext appInfo)
public object GetApplicationComponentManifest(ActivationContext appInfo)
public Byte[] GetApplicationManifestBytes(ActivationContext appInfo)
public object GetDeploymentComponentManifest(ActivationContext appInfo)
public Byte[] GetDeploymentManifestBytes(ActivationContext appInfo)
public bool IsFirstRun(ActivationContext appInfo)
public void PrepareForExecution(ActivationContext appInfo)
}
public System.Deployment.Internal.InternalApplicationIdentityHelper : object {
public object GetActivationContextData(ActivationContext appInfo)
public object GetInternalAppId(ApplicationIdentity id)
}
public System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
private string category
private string checkId
private string justification
private string messageId
private string scope
private string target
public string Category
public string CheckId
public string Justification
public string MessageId
public string Scope
public string Target
public void .ctor(string category, string checkId)
public string get_Category()
public string get_CheckId()
public string get_Justification()
public void set_Justification(string value)
public string get_MessageId()
public void set_MessageId(string value)
public string get_Scope()
public void set_Scope(string value)
public string get_Target()
public void set_Target(string value)
}
public System.Diagnostics.ConditionalAttribute : Attribute {
private string myCondition
public string ConditionString
public void .ctor(string conditionString)
public string get_ConditionString()
}
public System.Diagnostics.DebuggableAttribute : Attribute {
private bool JITTrackingEnabledFlag
private bool JITOptimizerDisabledFlag
private DebuggingModes debuggingModes
public DebuggingModes DebuggingFlags
public bool IsJITTrackingEnabled
public bool IsJITOptimizerDisabled
public void .ctor(bool isJITTrackingEnabled, bool isJITOptimizerDisabled)
public void .ctor(DebuggingModes modes)
public DebuggingModes get_DebuggingFlags()
public bool get_IsJITTrackingEnabled()
public bool get_IsJITOptimizerDisabled()
}
public System.Diagnostics.Debugger : object {
public string DefaultCategory
public bool IsAttached
public bool get_IsAttached()
private bool IsAttached_internal()
public void Break()
public bool IsLogging()
public bool Launch()
public void Log(int level, string category, string message)
}
public System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
private DebuggerBrowsableState state
public DebuggerBrowsableState State
public void .ctor(DebuggerBrowsableState state)
public DebuggerBrowsableState get_State()
}
public System.Diagnostics.DebuggerBrowsableState : Enum {
public int value__
public DebuggerBrowsableState Never
public DebuggerBrowsableState Collapsed
public DebuggerBrowsableState RootHidden
}
public System.Diagnostics.DebuggerDisplayAttribute : Attribute {
private string value
private string type
private string name
private string target_type_name
private Type target_type
public string Value
public Type Target
public string TargetTypeName
public string Type
public string Name
public void .ctor(string value)
public string get_Value()
public Type get_Target()
public void set_Target(Type value)
public string get_TargetTypeName()
public void set_TargetTypeName(string value)
public string get_Type()
public void set_Type(string value)
public string get_Name()
public void set_Name(string value)
}
public System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
private string proxy_type_name
private string target_type_name
private Type target_type
public string ProxyTypeName
public Type Target
public string TargetTypeName
public void .ctor(string typeName)
public void .ctor(Type type)
public string get_ProxyTypeName()
public Type get_Target()
public void set_Target(Type value)
public string get_TargetTypeName()
public void set_TargetTypeName(string value)
}
public System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
private string description
private string visualizerSourceName
private string visualizerName
private string targetTypeName
private Type target
public string Description
public Type Target
public string TargetTypeName
public string VisualizerObjectSourceTypeName
public string VisualizerTypeName
public void .ctor(string visualizerTypeName)
public void .ctor(Type visualizer)
public void .ctor(string visualizerTypeName, string visualizerObjectSourceTypeName)
public void .ctor(string visualizerTypeName, Type visualizerObjectSource)
public void .ctor(Type visualizer, string visualizerObjectSourceTypeName)
public void .ctor(Type visualizer, Type visualizerObjectSource)
public string get_Description()
public void set_Description(string value)
public Type get_Target()
public void set_Target(Type value)
public string get_TargetTypeName()
public void set_TargetTypeName(string value)
public string get_VisualizerObjectSourceTypeName()
public string get_VisualizerTypeName()
}
public System.Diagnostics.StackFrame : object {
public int OFFSET_UNKNOWN
private int ilOffset
private int nativeOffset
private MethodBase methodBase
private string fileName
private int lineNumber
private int columnNumber
private string internalMethodName
public void .ctor(bool fNeedFileInfo)
public void .ctor(int skipFrames)
public void .ctor(int skipFrames, bool fNeedFileInfo)
public void .ctor(string fileName, int lineNumber)
public void .ctor(string fileName, int lineNumber, int colNumber)
private bool get_frame_info(int skip, bool needFileInfo, MethodBase& method, Int32& iloffset, Int32& native_offset, String& file, Int32& line, Int32& column)
public int GetFileLineNumber()
public int GetFileColumnNumber()
public string GetFileName()
internal string GetSecureFileName()
public int GetILOffset()
public MethodBase GetMethod()
public int GetNativeOffset()
internal string GetInternalMethodName()
public string ToString()
}
public System.Diagnostics.StackTrace : object {
public int METHODS_TO_SKIP
private StackFrame[] frames
private bool debug_info
public int FrameCount
public void .ctor(bool fNeedFileInfo)
public void .ctor(int skipFrames)
public void .ctor(int skipFrames, bool fNeedFileInfo)
public void .ctor(Exception e)
public void .ctor(Exception e, bool fNeedFileInfo)
public void .ctor(Exception e, int skipFrames)
public void .ctor(Exception e, int skipFrames, bool fNeedFileInfo)
internal void .ctor(Exception e, int skipFrames, bool fNeedFileInfo, bool returnNativeFrames)
public void .ctor(StackFrame frame)
public void .ctor(Thread targetThread, bool needFileInfo)
private void init_frames(int skipFrames, bool fNeedFileInfo)
private StackFrame[] get_trace(Exception e, int skipFrames, bool fNeedFileInfo)
public int get_FrameCount()
public StackFrame GetFrame(int index)
public StackFrame[] GetFrames()
public string ToString()
}
public System.Diagnostics.SymbolStore.ISymbolBinder {
public ISymbolReader GetReader(int importer, string filename, string searchPath)
}
public System.Diagnostics.SymbolStore.ISymbolBinder1 {
public ISymbolReader GetReader(IntPtr importer, string filename, string searchPath)
}
public System.Diagnostics.SymbolStore.ISymbolDocument {
public Guid CheckSumAlgorithmId
public Guid DocumentType
public bool HasEmbeddedSource
public Guid Language
public Guid LanguageVendor
public int SourceLength
public string URL
public Guid get_CheckSumAlgorithmId()
public Guid get_DocumentType()
public bool get_HasEmbeddedSource()
public Guid get_Language()
public Guid get_LanguageVendor()
public int get_SourceLength()
public string get_URL()
public int FindClosestLine(int line)
public Byte[] GetCheckSum()
public Byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn)
}
public System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
public void SetCheckSum(Guid algorithmId, Byte[] checkSum)
public void SetSource(Byte[] source)
}
public System.Diagnostics.SymbolStore.ISymbolMethod {
public ISymbolScope RootScope
public int SequencePointCount
public SymbolToken Token
public ISymbolScope get_RootScope()
public int get_SequencePointCount()
public SymbolToken get_Token()
public ISymbolNamespace GetNamespace()
public int GetOffset(ISymbolDocument document, int line, int column)
public ISymbolVariable[] GetParameters()
public Int32[] GetRanges(ISymbolDocument document, int line, int column)
public ISymbolScope GetScope(int offset)
public void GetSequencePoints(Int32[] offsets, ISymbolDocument[] documents, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public bool GetSourceStartEnd(ISymbolDocument[] docs, Int32[] lines, Int32[] columns)
}
public System.Diagnostics.SymbolStore.ISymbolNamespace {
public string Name
public string get_Name()
public ISymbolNamespace[] GetNamespaces()
public ISymbolVariable[] GetVariables()
}
public System.Diagnostics.SymbolStore.ISymbolReader {
public SymbolToken UserEntryPoint
public SymbolToken get_UserEntryPoint()
public ISymbolDocument GetDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public ISymbolDocument[] GetDocuments()
public ISymbolVariable[] GetGlobalVariables()
public ISymbolMethod GetMethod(SymbolToken method)
public ISymbolMethod GetMethod(SymbolToken method, int version)
public ISymbolMethod GetMethodFromDocumentPosition(ISymbolDocument document, int line, int column)
public ISymbolNamespace[] GetNamespaces()
public Byte[] GetSymAttribute(SymbolToken parent, string name)
public ISymbolVariable[] GetVariables(SymbolToken parent)
}
public System.Diagnostics.SymbolStore.ISymbolScope {
public int EndOffset
public ISymbolMethod Method
public ISymbolScope Parent
public int StartOffset
public int get_EndOffset()
public ISymbolMethod get_Method()
public ISymbolScope get_Parent()
public int get_StartOffset()
public ISymbolScope[] GetChildren()
public ISymbolVariable[] GetLocals()
public ISymbolNamespace[] GetNamespaces()
}
public System.Diagnostics.SymbolStore.ISymbolVariable {
public int AddressField1
public int AddressField2
public int AddressField3
public SymAddressKind AddressKind
public object Attributes
public int EndOffset
public string Name
public int StartOffset
public int get_AddressField1()
public int get_AddressField2()
public int get_AddressField3()
public SymAddressKind get_AddressKind()
public object get_Attributes()
public int get_EndOffset()
public string get_Name()
public int get_StartOffset()
public Byte[] GetSignature()
}
public System.Diagnostics.SymbolStore.ISymbolWriter {
public void Close()
public void CloseMethod()
public void CloseNamespace()
public void CloseScope(int endOffset)
public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset)
public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3)
public void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns)
public void Initialize(IntPtr emitter, string filename, bool fFullBuild)
public void OpenMethod(SymbolToken method)
public void OpenNamespace(string name)
public int OpenScope(int startOffset)
public void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn)
public void SetScopeRange(int scopeID, int startOffset, int endOffset)
public void SetSymAttribute(SymbolToken parent, string name, Byte[] data)
public void SetUnderlyingWriter(IntPtr underlyingWriter)
public void SetUserEntryPoint(SymbolToken entryMethod)
public void UsingNamespace(string fullName)
}
public System.Diagnostics.SymbolStore.SymAddressKind : Enum {
public int value__
public SymAddressKind ILOffset
public SymAddressKind NativeRVA
public SymAddressKind NativeRegister
public SymAddressKind NativeRegisterRelative
public SymAddressKind NativeOffset
public SymAddressKind NativeRegisterRegister
public SymAddressKind NativeRegisterStack
public SymAddressKind NativeStackRegister
public SymAddressKind BitField
public SymAddressKind NativeSectionOffset
}
public System.Diagnostics.SymbolStore.SymbolToken : ValueType {
private int _val
public void .ctor(int val)
public bool Equals(object obj)
public bool Equals(SymbolToken obj)
public int GetHashCode()
public int GetToken()
public bool op_Equality(SymbolToken a, SymbolToken b)
public bool op_Inequality(SymbolToken a, SymbolToken b)
}
public System.Diagnostics.SymbolStore.SymDocumentType : object {
public Guid Text
}
public System.Diagnostics.SymbolStore.SymLanguageType : object {
public Guid Basic
public Guid C
public Guid Cobol
public Guid CPlusPlus
public Guid CSharp
public Guid ILAssembly
public Guid Java
public Guid JScript
public Guid MCPlusPlus
public Guid Pascal
public Guid SMC
}
public System.Diagnostics.SymbolStore.SymLanguageVendor : object {
public Guid Microsoft
}
public System.DivideByZeroException : ArithmeticException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.DllNotFoundException : TypeLoadException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.Double : ValueType {
public double Epsilon
public double MaxValue
public double MinValue
public double NaN
public double NegativeInfinity
public double PositiveInfinity
private int State_AllowSign
private int State_Digits
private int State_Decimal
private int State_ExponentSign
private int State_Exponent
private int State_ConsumeWhiteSpace
private int State_Exit
internal double m_value
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int CompareTo(double value)
public bool Equals(double obj)
public int GetHashCode()
public bool IsInfinity(double d)
public bool IsNaN(double d)
public bool IsNegativeInfinity(double d)
public bool IsPositiveInfinity(double d)
public double Parse(string s)
public double Parse(string s, IFormatProvider provider)
public double Parse(string s, NumberStyles style)
public double Parse(string s, NumberStyles style, IFormatProvider provider)
internal bool Parse(string s, NumberStyles style, IFormatProvider provider, bool tryParse, Double& result, Exception& exc)
private bool TryParseStringConstant(string format, string s, int start, int end)
private bool ParseImpl(Byte* byte_ptr, Double& value)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result)
public bool TryParse(string s, Double& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.DuplicateWaitObjectException : ArgumentException {
private int Result
public void .ctor(string parameterName)
public void .ctor(string parameterName, string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.EntryPointNotFoundException : TypeLoadException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.Enum : ValueType {
private Char[] split_char
private object Value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public TypeCode GetTypeCode()
private object get_value()
private object get_Value()
public Array GetValues(Type enumType)
public String[] GetNames(Type enumType)
private int FindPosition(object value, Array values)
public string GetName(Type enumType, object value)
public bool IsDefined(Type enumType, object value)
private Type get_underlying_type(Type enumType)
public Type GetUnderlyingType(Type enumType)
public object Parse(Type enumType, string value)
private int FindName(Hashtable name_hash, String[] names, string name, bool ignoreCase)
private ulong GetValue(object value, TypeCode typeCode)
public object Parse(Type enumType, string value, bool ignoreCase)
private int compare_value_to(object other)
public int CompareTo(object target)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public object ToObject(Type enumType, byte value)
public object ToObject(Type enumType, short value)
public object ToObject(Type enumType, int value)
public object ToObject(Type enumType, long value)
public object ToObject(Type enumType, object value)
public object ToObject(Type enumType, sbyte value)
public object ToObject(Type enumType, ushort value)
public object ToObject(Type enumType, UInt32 value)
public object ToObject(Type enumType, ulong value)
public bool Equals(object obj)
private int get_hashcode()
public int GetHashCode()
private string FormatSpecifier_X(Type enumType, object value, bool upper)
private string FormatFlags(Type enumType, object value)
public string Format(Type enumType, object value, string format)
}
public System.Environment : object {
private int mono_corlib_version
private OperatingSystem os
public string CommandLine
public string CurrentDirectory
public int ExitCode
public bool HasShutdownStarted
public string EmbeddingHostName
public bool SocketSecurityEnabled
public bool UnityWebSecurityEnabled
public string MachineName
public string NewLine
internal PlatformID Platform
public OperatingSystem OSVersion
public string StackTrace
public string SystemDirectory
public int TickCount
public string UserDomainName
public bool UserInteractive
public string UserName
public Version Version
public long WorkingSet
public int ProcessorCount
internal bool IsRunningOnWindows
private string GacPath
public string get_CommandLine()
public string get_CurrentDirectory()
public void set_CurrentDirectory(string value)
public int get_ExitCode()
public void set_ExitCode(int value)
public bool get_HasShutdownStarted()
public string get_EmbeddingHostName()
public bool get_SocketSecurityEnabled()
public bool get_UnityWebSecurityEnabled()
public string get_MachineName()
public string get_NewLine()
internal PlatformID get_Platform()
internal string GetOSVersionString()
public OperatingSystem get_OSVersion()
public string get_StackTrace()
public string get_SystemDirectory()
public int get_TickCount()
public string get_UserDomainName()
public bool get_UserInteractive()
public string get_UserName()
public Version get_Version()
public long get_WorkingSet()
public void Exit(int exitCode)
public string ExpandEnvironmentVariables(string name)
public String[] GetCommandLineArgs()
internal string internalGetEnvironmentVariable(string variable)
public string GetEnvironmentVariable(string variable)
private Hashtable GetEnvironmentVariablesNoCase()
public IDictionary GetEnvironmentVariables()
private string GetWindowsFolderPath(int folder)
public string GetFolderPath(SpecialFolder folder)
private string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback)
internal string InternalGetFolderPath(SpecialFolder folder)
public String[] GetLogicalDrives()
private void internalBroadcastSettingChange()
public string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target)
public IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target)
public void SetEnvironmentVariable(string variable, string value)
public void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target)
internal void InternalSetEnvironmentVariable(string variable, string value)
public void FailFast(string message)
public int get_ProcessorCount()
internal bool get_IsRunningOnWindows()
private string get_GacPath()
internal string internalGetGacPath()
private String[] GetLogicalDrivesInternal()
private String[] GetEnvironmentVariableNames()
internal string GetMachineConfigPath()
internal string internalGetHome()
}
public System.EnvironmentVariableTarget : Enum {
public int value__
public EnvironmentVariableTarget Process
public EnvironmentVariableTarget User
public EnvironmentVariableTarget Machine
}
public System.EventArgs : object {
public EventArgs Empty
}
public System.EventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, EventArgs e)
public IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.EventHandler`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, TEventArgs e)
public IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Exception : object {
private IntPtr[] trace_ips
private Exception inner_exception
internal string message
private string help_link
private string class_name
private string stack_trace
private string _remoteStackTraceString
private int remote_stack_index
internal int hresult
private string source
private IDictionary _data
public Exception InnerException
public string HelpLink
protected int HResult
private string ClassName
public string Message
public string Source
public string StackTrace
public MethodBase TargetSite
public IDictionary Data
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
public Exception get_InnerException()
public string get_HelpLink()
public void set_HelpLink(string value)
protected int get_HResult()
protected void set_HResult(int value)
internal void SetMessage(string s)
internal void SetStackTrace(string s)
private string get_ClassName()
public string get_Message()
public string get_Source()
public void set_Source(string value)
public string get_StackTrace()
public MethodBase get_TargetSite()
public IDictionary get_Data()
public Exception GetBaseException()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
internal Exception FixRemotingException()
internal void GetFullNameForStackTrace(StringBuilder sb, MethodBase mi)
public Type GetType()
}
public System.ExecutionEngineException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.FieldAccessException : MemberAccessException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.FormatException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.GC : object {
public int MaxGeneration
public int get_MaxGeneration()
private void InternalCollect(int generation)
public void Collect()
public void Collect(int generation)
public void Collect(int generation, GCCollectionMode mode)
public int GetGeneration(object obj)
public int GetGeneration(WeakReference wo)
public long GetTotalMemory(bool forceFullCollection)
public void KeepAlive(object obj)
public void ReRegisterForFinalize(object obj)
public void SuppressFinalize(object obj)
public void WaitForPendingFinalizers()
public int CollectionCount(int generation)
private void RecordPressure(long bytesAllocated)
public void AddMemoryPressure(long bytesAllocated)
public void RemoveMemoryPressure(long bytesAllocated)
}
public System.GCCollectionMode : Enum {
public int value__
public GCCollectionMode Default
public GCCollectionMode Forced
public GCCollectionMode Optimized
}
public System.GCNotificationStatus : Enum {
public int value__
public GCNotificationStatus Succeeded
public GCNotificationStatus Failed
public GCNotificationStatus Canceled
public GCNotificationStatus Timeout
public GCNotificationStatus NotApplicable
}
internal System.Globalization.Bootstring : object {
private char delimiter
private int base_num
private int tmin
private int tmax
private int skew
private int damp
private int initial_bias
private int initial_n
public void .ctor(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN)
public string Encode(string s, int offset)
private char EncodeDigit(int d)
private int DecodeDigit(char c)
private int Adapt(int delta, int numPoints, bool firstTime)
public string Decode(string s, int offset)
}
public System.Globalization.Calendar : object {
public int CurrentEra
private bool m_isReadOnly
internal int twoDigitYearMax
private int M_MaxYearValue
internal String[] M_AbbrEraNames
internal String[] M_EraNames
internal int m_currentEraValue
internal int M_DaysInWeek
public Int32[] Eras
public CalendarAlgorithmType AlgorithmType
public DateTime MaxSupportedDateTime
public DateTime MinSupportedDateTime
public bool IsReadOnly
internal int M_MaxYear
public int TwoDigitYearMax
internal String[] AbbreviatedEraNames
internal String[] EraNames
internal int get_M_DaysInWeek()
internal string M_ValidValues(object a, object b)
internal void M_ArgumentInRange(string param, int arg, int a, int b)
internal void M_CheckHMSM(int hour, int minute, int second, int milliseconds)
public Int32[] get_Eras()
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MaxSupportedDateTime()
public DateTime get_MinSupportedDateTime()
public object Clone()
public int GetLeapMonth(int year)
public int GetLeapMonth(int year, int era)
public bool get_IsReadOnly()
public Calendar ReadOnly(Calendar calendar)
internal void CheckReadOnly()
internal int get_M_MaxYear()
internal void M_CheckYE(int year, Int32& era)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public DateTime AddDays(DateTime time, int days)
public DateTime AddHours(DateTime time, int hours)
public DateTime AddMilliseconds(DateTime time, double milliseconds)
public DateTime AddMinutes(DateTime time, int minutes)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddSeconds(DateTime time, int seconds)
public DateTime AddWeeks(DateTime time, int weeks)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetHour(DateTime time)
public double GetMilliseconds(DateTime time)
public int GetMinute(DateTime time)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year)
public int GetMonthsInYear(int year, int era)
public int GetSecond(DateTime time)
internal int M_DiffDays(DateTime timeA, DateTime timeB)
internal DateTime M_GetFirstDayOfSecondWeekOfYear(int year, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
internal String[] get_AbbreviatedEraNames()
internal void set_AbbreviatedEraNames(String[] value)
internal String[] get_EraNames()
internal void set_EraNames(String[] value)
}
public System.Globalization.CalendarAlgorithmType : Enum {
public int value__
public CalendarAlgorithmType Unknown
public CalendarAlgorithmType SolarCalendar
public CalendarAlgorithmType LunarCalendar
public CalendarAlgorithmType LunisolarCalendar
}
public System.Globalization.CalendarWeekRule : Enum {
public int value__
public CalendarWeekRule FirstDay
public CalendarWeekRule FirstFullWeek
public CalendarWeekRule FirstFourDayWeek
}
internal System.Globalization.CCEastAsianLunisolarCalendar : object {
private int initial_epact
public int fixed_from_dmy(int day, int month, int year)
public int year_from_fixed(int date)
public void my_from_fixed(Int32& month, Int32& year, int date)
public void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
public DateTime AddMonths(DateTime date, int months)
public DateTime AddYears(DateTime date, int years)
public int GetDayOfMonth(DateTime date)
public int GetDayOfYear(DateTime date)
public int GetDaysInMonth(int gyear, int month)
public int GetDaysInYear(int year)
public int GetMonth(DateTime date)
public bool IsLeapMonth(int gyear, int month)
public bool IsLeapYear(int gyear)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond)
}
internal System.Globalization.CCEastAsianLunisolarEraHandler : object {
private SortedList _Eras
public Int32[] Eras
public Int32[] get_Eras()
public void appendEra(int nr, int rd_start, int rd_end)
public void appendEra(int nr, int rd_start)
public int GregorianYear(int year, int era)
public int EraYear(Int32& era, int date)
public void CheckDateTime(DateTime time)
public bool ValidDate(int date)
public bool ValidEra(int era)
}
internal System.Globalization.CCFixed : object {
public DateTime ToDateTime(int date)
public DateTime ToDateTime(int date, int hour, int minute, int second, double milliseconds)
public int FromDateTime(DateTime time)
public DayOfWeek day_of_week(int date)
public int kday_on_or_before(int date, int k)
public int kday_on_or_after(int date, int k)
public int kd_nearest(int date, int k)
public int kday_after(int date, int k)
public int kday_before(int date, int k)
}
internal System.Globalization.CCGregorianCalendar : object {
private int epoch
public bool is_leap_year(int year)
public int fixed_from_dmy(int day, int month, int year)
public int year_from_fixed(int date)
public void my_from_fixed(Int32& month, Int32& year, int date)
public void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
public int month_from_fixed(int date)
public int day_from_fixed(int date)
public int date_difference(int dayA, int monthA, int yearA, int dayB, int monthB, int yearB)
public int day_number(int day, int month, int year)
public int days_remaining(int day, int month, int year)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month)
public int GetDaysInYear(int year)
public int GetMonth(DateTime time)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int milliseconds)
}
internal System.Globalization.CCGregorianEraHandler : object {
private SortedList _Eras
public Int32[] Eras
public Int32[] get_Eras()
public void appendEra(int nr, int rd_start, int rd_end)
public void appendEra(int nr, int rd_start)
public int GregorianYear(int year, int era)
public int EraYear(Int32& era, int date)
public void CheckDateTime(DateTime time)
public bool ValidDate(int date)
public bool ValidEra(int era)
}
internal System.Globalization.CCHebrewCalendar : object {
private int epoch
public bool is_leap_year(int year)
public int last_month_of_year(int year)
public int elapsed_days(int year)
public int new_year_delay(int year)
public int last_day_of_month(int month, int year)
public bool long_heshvan(int year)
public bool short_kislev(int year)
public int days_in_year(int year)
public int fixed_from_dmy(int day, int month, int year)
public int year_from_fixed(int date)
public void my_from_fixed(Int32& month, Int32& year, int date)
public void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
public int month_from_fixed(int date)
public int day_from_fixed(int date)
public int date_difference(int dayA, int monthA, int yearA, int dayB, int monthB, int yearB)
public int day_number(int day, int month, int year)
public int days_remaining(int day, int month, int year)
}
internal System.Globalization.CCHijriCalendar : object {
private int epoch
public bool is_leap_year(int year)
public int fixed_from_dmy(int day, int month, int year)
public int year_from_fixed(int date)
public void my_from_fixed(Int32& month, Int32& year, int date)
public void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
public int month_from_fixed(int date)
public int day_from_fixed(int date)
public int date_difference(int dayA, int monthA, int yearA, int dayB, int monthB, int yearB)
public int day_number(int day, int month, int year)
public int days_remaining(int day, int month, int year)
}
internal System.Globalization.CCJulianCalendar : object {
private int epoch
public bool is_leap_year(int year)
public int fixed_from_dmy(int day, int month, int year)
public int year_from_fixed(int date)
public void my_from_fixed(Int32& month, Int32& year, int date)
public void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
public int month_from_fixed(int date)
public int day_from_fixed(int date)
public int date_difference(int dayA, int monthA, int yearA, int dayB, int monthB, int yearB)
public int day_number(int day, int month, int year)
public int days_remaining(int day, int month, int year)
}
internal System.Globalization.CCMath : object {
public double round(double x)
public double mod(double x, double y)
public int div(int x, int y)
public int mod(int x, int y)
public int div_mod(Int32& remainder, int x, int y)
public int signum(double x)
public int signum(int x)
public double amod(double x, double y)
public int amod(int x, int y)
}
public System.Globalization.CharUnicodeInfo : object {
public int GetDecimalDigitValue(char ch)
public int GetDecimalDigitValue(string s, int index)
public int GetDigitValue(char ch)
public int GetDigitValue(string s, int index)
public double GetNumericValue(char ch)
public double GetNumericValue(string s, int index)
public UnicodeCategory GetUnicodeCategory(char ch)
public UnicodeCategory GetUnicodeCategory(string s, int index)
}
public System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
public int ChineseEra
internal CCEastAsianLunisolarEraHandler era_handler
private DateTime ChineseMin
private DateTime ChineseMax
public Int32[] Eras
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int GetEra(DateTime time)
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
internal System.Globalization.CodePageDataItem : object {
private string m_bodyName
private int m_codePage
private int m_dataIndex
private string m_description
private UInt32 m_flags
private string m_headerName
private int m_uiFamilyCodePage
private string m_webName
}
public System.Globalization.CompareInfo : object {
private CompareOptions ValidCompareOptions_NoStringSort
private CompareOptions ValidCompareOptions
private bool useManagedCollation
private int culture
private string icu_name
private int win32LCID
private string m_name
private SimpleCollator collator
private Hashtable collators
private object monitor
internal bool UseManagedCollation
public int LCID
public string Name
internal void .ctor(CultureInfo ci)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
internal bool get_UseManagedCollation()
private void construct_compareinfo(string locale)
private void free_internal_collator()
private int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
private void assign_sortkey(object key, string source, CompareOptions options)
private int internal_index(string source, int sindex, int count, char value, CompareOptions options, bool first)
private int internal_index(string source, int sindex, int count, string value, CompareOptions options, bool first)
protected void Finalize()
private int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
private int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options)
public int Compare(string string1, string string2)
public int Compare(string string1, string string2, CompareOptions options)
public int Compare(string string1, int offset1, string string2, int offset2)
public int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options)
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2)
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options)
public bool Equals(object value)
public CompareInfo GetCompareInfo(int culture)
public CompareInfo GetCompareInfo(string name)
public CompareInfo GetCompareInfo(int culture, Assembly assembly)
public CompareInfo GetCompareInfo(string name, Assembly assembly)
public int GetHashCode()
public SortKey GetSortKey(string source)
public SortKey GetSortKey(string source, CompareOptions options)
public int IndexOf(string source, char value)
public int IndexOf(string source, string value)
public int IndexOf(string source, char value, CompareOptions options)
public int IndexOf(string source, char value, int startIndex)
public int IndexOf(string source, string value, CompareOptions options)
public int IndexOf(string source, string value, int startIndex)
public int IndexOf(string source, char value, int startIndex, CompareOptions options)
public int IndexOf(string source, char value, int startIndex, int count)
public int IndexOf(string source, string value, int startIndex, CompareOptions options)
public int IndexOf(string source, string value, int startIndex, int count)
private int internal_index_managed(string s, int sindex, int count, char c, CompareOptions opt, bool first)
private int internal_index_switch(string s, int sindex, int count, char c, CompareOptions opt, bool first)
public int IndexOf(string source, char value, int startIndex, int count, CompareOptions options)
private int internal_index_managed(string s1, int sindex, int count, string s2, CompareOptions opt, bool first)
private int internal_index_switch(string s1, int sindex, int count, string s2, CompareOptions opt, bool first)
public int IndexOf(string source, string value, int startIndex, int count, CompareOptions options)
public bool IsPrefix(string source, string prefix)
public bool IsPrefix(string source, string prefix, CompareOptions options)
public bool IsSuffix(string source, string suffix)
public bool IsSuffix(string source, string suffix, CompareOptions options)
public int LastIndexOf(string source, char value)
public int LastIndexOf(string source, string value)
public int LastIndexOf(string source, char value, CompareOptions options)
public int LastIndexOf(string source, char value, int startIndex)
public int LastIndexOf(string source, string value, CompareOptions options)
public int LastIndexOf(string source, string value, int startIndex)
public int LastIndexOf(string source, char value, int startIndex, CompareOptions options)
public int LastIndexOf(string source, char value, int startIndex, int count)
public int LastIndexOf(string source, string value, int startIndex, CompareOptions options)
public int LastIndexOf(string source, string value, int startIndex, int count)
public int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options)
public int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options)
public bool IsSortable(char ch)
public bool IsSortable(string text)
public string ToString()
public int get_LCID()
public string get_Name()
}
public System.Globalization.CompareOptions : Enum {
public int value__
public CompareOptions None
public CompareOptions IgnoreCase
public CompareOptions IgnoreNonSpace
public CompareOptions IgnoreSymbols
public CompareOptions IgnoreKanaType
public CompareOptions IgnoreWidth
public CompareOptions StringSort
public CompareOptions Ordinal
public CompareOptions OrdinalIgnoreCase
}
public System.Globalization.CultureInfo : object {
private int NumOptionalCalendars
private int GregorianTypeMask
private int CalendarTypeBits
private int InvariantCultureId
private CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) invariant_culture_info
private object shared_table_lock
internal int BootstrapCultureID
private bool m_isReadOnly
private int cultureID
private int parent_lcid
private int specific_lcid
private int datetime_index
private int number_index
private bool m_useUserOverride
private NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) numInfo
private DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) dateTimeInfo
private TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) textInfo
private string m_name
private string displayname
private string englishname
private string nativename
private string iso3lang
private string iso2lang
private string icu_name
private string win3lang
private string territory
private CompareInfo modreq(System.Runtime.CompilerServices.IsVolatile) compareInfo
private Int32* calendar_data
private Void* textinfo_data
private Calendar[] optional_calendars
private CultureInfo parent_culture
private int m_dataItem
private Calendar calendar
private bool constructed
internal Byte[] cached_serialized_form
private string MSG_READONLY
private Hashtable shared_by_number
private Hashtable shared_by_name
private Dictionary`2<string, int> <>f__switch$map19
private Dictionary`2<string, int> <>f__switch$map1A
private Dictionary`2<string, int> <>f__switch$map1B
private Dictionary`2<string, int> <>f__switch$map1C
public CultureInfo InvariantCulture
public CultureInfo CurrentCulture
public CultureInfo CurrentUICulture
internal string Territory
public CultureTypes CultureTypes
public string IetfLanguageTag
public int KeyboardLayoutId
public int LCID
public string Name
public string NativeName
public Calendar Calendar
public Calendar[] OptionalCalendars
public CultureInfo Parent
public TextInfo TextInfo
public string ThreeLetterISOLanguageName
public string ThreeLetterWindowsLanguageName
public string TwoLetterISOLanguageName
public bool UseUserOverride
internal string IcuName
public CompareInfo CompareInfo
public bool IsNeutralCulture
public NumberFormatInfo NumberFormat
public DateTimeFormatInfo DateTimeFormat
public string DisplayName
public string EnglishName
public CultureInfo InstalledUICulture
public bool IsReadOnly
public void .ctor(int culture)
public void .ctor(int culture, bool useUserOverride)
private void .ctor(int culture, bool useUserOverride, bool read_only)
public void .ctor(string name)
public void .ctor(string name, bool useUserOverride)
private void .ctor(string name, bool useUserOverride, bool read_only)
public CultureInfo get_InvariantCulture()
public CultureInfo CreateSpecificCulture(string name)
public CultureInfo get_CurrentCulture()
public CultureInfo get_CurrentUICulture()
internal CultureInfo ConstructCurrentCulture()
internal CultureInfo ConstructCurrentUICulture()
internal string get_Territory()
public CultureTypes get_CultureTypes()
public CultureInfo GetConsoleFallbackUICulture()
public string get_IetfLanguageTag()
public int get_KeyboardLayoutId()
public int get_LCID()
public string get_Name()
public string get_NativeName()
public Calendar get_Calendar()
public Calendar[] get_OptionalCalendars()
public CultureInfo get_Parent()
public TextInfo get_TextInfo()
public string get_ThreeLetterISOLanguageName()
public string get_ThreeLetterWindowsLanguageName()
public string get_TwoLetterISOLanguageName()
public bool get_UseUserOverride()
internal string get_IcuName()
public void ClearCachedData()
public object Clone()
public bool Equals(object value)
public CultureInfo[] GetCultures(CultureTypes types)
public int GetHashCode()
public CultureInfo ReadOnly(CultureInfo ci)
public string ToString()
public CompareInfo get_CompareInfo()
internal bool IsIDNeutralCulture(int lcid)
public bool get_IsNeutralCulture()
internal void CheckNeutral()
public NumberFormatInfo get_NumberFormat()
public void set_NumberFormat(NumberFormatInfo value)
public DateTimeFormatInfo get_DateTimeFormat()
public void set_DateTimeFormat(DateTimeFormatInfo value)
public string get_DisplayName()
public string get_EnglishName()
public CultureInfo get_InstalledUICulture()
public bool get_IsReadOnly()
public object GetFormat(Type formatType)
private void Construct()
private bool ConstructInternalLocaleFromName(string locale)
private bool ConstructInternalLocaleFromLcid(int lcid)
private bool ConstructInternalLocaleFromSpecificName(CultureInfo ci, string name)
private bool ConstructInternalLocaleFromCurrentLocale(CultureInfo ci)
private bool construct_internal_locale_from_lcid(int lcid)
private bool construct_internal_locale_from_name(string name)
private bool construct_internal_locale_from_specific_name(CultureInfo ci, string name)
private bool construct_internal_locale_from_current_locale(CultureInfo ci)
private CultureInfo[] internal_get_cultures(bool neutral, bool specific, bool installed)
private void construct_datetime_format()
private void construct_number_format()
private bool internal_is_lcid_neutral(int lcid, Boolean& is_neutral)
private void ConstructInvariant(bool read_only)
private TextInfo CreateTextInfo(bool readOnly)
private void insert_into_shared_tables(CultureInfo c)
public CultureInfo GetCultureInfo(int culture)
public CultureInfo GetCultureInfo(string name)
public CultureInfo GetCultureInfo(string name, string altName)
public CultureInfo GetCultureInfoByIetfLanguageTag(string name)
internal CultureInfo CreateCulture(string name, bool reference)
internal void ConstructCalendars()
}
public System.Globalization.CultureTypes : Enum {
public int value__
public CultureTypes NeutralCultures
public CultureTypes SpecificCultures
public CultureTypes InstalledWin32Cultures
public CultureTypes AllCultures
public CultureTypes UserCustomCulture
public CultureTypes ReplacementCultures
public CultureTypes WindowsOnlyCultures
public CultureTypes FrameworkCultures
}
internal System.Globalization.DateTimeFormatFlags : Enum {
public int value__
public DateTimeFormatFlags Unused
public DateTimeFormatFlags But
public DateTimeFormatFlags Serialized
public DateTimeFormatFlags By
public DateTimeFormatFlags Microsoft
}
public System.Globalization.DateTimeFormatInfo : object {
private string _RoundtripPattern
private string MSG_READONLY
private string MSG_ARRAYSIZE_MONTH
private string MSG_ARRAYSIZE_DAY
private String[] INVARIANT_ABBREVIATED_DAY_NAMES
private String[] INVARIANT_DAY_NAMES
private String[] INVARIANT_ABBREVIATED_MONTH_NAMES
private String[] INVARIANT_MONTH_NAMES
private String[] INVARIANT_SHORT_DAY_NAMES
private DateTimeFormatInfo theInvariantDateTimeFormatInfo
private bool m_isReadOnly
private string amDesignator
private string pmDesignator
private string dateSeparator
private string timeSeparator
private string shortDatePattern
private string longDatePattern
private string shortTimePattern
private string longTimePattern
private string monthDayPattern
private string yearMonthPattern
private string fullDateTimePattern
private string _RFC1123Pattern
private string _SortableDateTimePattern
private string _UniversalSortableDateTimePattern
private int firstDayOfWeek
private Calendar calendar
private int calendarWeekRule
private String[] abbreviatedDayNames
private String[] dayNames
private String[] monthNames
private String[] abbreviatedMonthNames
private String[] allShortDatePatterns
private String[] allLongDatePatterns
private String[] allShortTimePatterns
private String[] allLongTimePatterns
private String[] monthDayPatterns
private String[] yearMonthPatterns
private String[] shortDayNames
private int nDataItem
private bool m_useUserOverride
private bool m_isDefaultCalendar
private int CultureID
private bool bUseCalendarInfo
private string generalShortTimePattern
private string generalLongTimePattern
private String[] m_eraNames
private String[] m_abbrevEraNames
private String[] m_abbrevEnglishEraNames
private String[] m_dateWords
private Int32[] optionalCalendars
private String[] m_superShortDayNames
private String[] genitiveMonthNames
private String[] m_genitiveAbbreviatedMonthNames
private String[] leapYearMonthNames
private DateTimeFormatFlags formatFlags
private string m_name
private String[] modreq(System.Runtime.CompilerServices.IsVolatile) all_date_time_patterns
public bool IsReadOnly
public String[] AbbreviatedDayNames
internal String[] RawAbbreviatedDayNames
public String[] AbbreviatedMonthNames
internal String[] RawAbbreviatedMonthNames
public String[] DayNames
internal String[] RawDayNames
public String[] MonthNames
internal String[] RawMonthNames
public string AMDesignator
public string PMDesignator
public string DateSeparator
public string TimeSeparator
public string LongDatePattern
public string ShortDatePattern
public string ShortTimePattern
public string LongTimePattern
public string MonthDayPattern
public string YearMonthPattern
public string FullDateTimePattern
public DateTimeFormatInfo CurrentInfo
public DateTimeFormatInfo InvariantInfo
public DayOfWeek FirstDayOfWeek
public Calendar Calendar
public CalendarWeekRule CalendarWeekRule
public string RFC1123Pattern
internal string RoundtripPattern
public string SortableDateTimePattern
public string UniversalSortableDateTimePattern
public String[] AbbreviatedMonthGenitiveNames
public String[] MonthGenitiveNames
public string NativeCalendarName
public String[] ShortestDayNames
internal void .ctor(bool read_only)
public DateTimeFormatInfo GetInstance(IFormatProvider provider)
public bool get_IsReadOnly()
public DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi)
public object Clone()
public object GetFormat(Type formatType)
public string GetAbbreviatedEraName(int era)
public string GetAbbreviatedMonthName(int month)
public int GetEra(string eraName)
public string GetEraName(int era)
public string GetMonthName(int month)
public String[] get_AbbreviatedDayNames()
public void set_AbbreviatedDayNames(String[] value)
internal String[] get_RawAbbreviatedDayNames()
internal void set_RawAbbreviatedDayNames(String[] value)
public String[] get_AbbreviatedMonthNames()
public void set_AbbreviatedMonthNames(String[] value)
internal String[] get_RawAbbreviatedMonthNames()
internal void set_RawAbbreviatedMonthNames(String[] value)
public String[] get_DayNames()
public void set_DayNames(String[] value)
internal String[] get_RawDayNames()
internal void set_RawDayNames(String[] value)
public String[] get_MonthNames()
public void set_MonthNames(String[] value)
internal String[] get_RawMonthNames()
internal void set_RawMonthNames(String[] value)
public string get_AMDesignator()
public void set_AMDesignator(string value)
public string get_PMDesignator()
public void set_PMDesignator(string value)
public string get_DateSeparator()
public void set_DateSeparator(string value)
public string get_TimeSeparator()
public void set_TimeSeparator(string value)
public string get_LongDatePattern()
public void set_LongDatePattern(string value)
public string get_ShortDatePattern()
public void set_ShortDatePattern(string value)
public string get_ShortTimePattern()
public void set_ShortTimePattern(string value)
public string get_LongTimePattern()
public void set_LongTimePattern(string value)
public string get_MonthDayPattern()
public void set_MonthDayPattern(string value)
public string get_YearMonthPattern()
public void set_YearMonthPattern(string value)
public string get_FullDateTimePattern()
public void set_FullDateTimePattern(string value)
public DateTimeFormatInfo get_CurrentInfo()
public DateTimeFormatInfo get_InvariantInfo()
public DayOfWeek get_FirstDayOfWeek()
public void set_FirstDayOfWeek(DayOfWeek value)
public Calendar get_Calendar()
public void set_Calendar(Calendar value)
public CalendarWeekRule get_CalendarWeekRule()
public void set_CalendarWeekRule(CalendarWeekRule value)
public string get_RFC1123Pattern()
internal string get_RoundtripPattern()
public string get_SortableDateTimePattern()
public string get_UniversalSortableDateTimePattern()
public String[] GetAllDateTimePatterns()
internal String[] GetAllDateTimePatternsInternal()
private void FillAllDateTimePatterns()
public String[] GetAllDateTimePatterns(char format)
internal String[] GetAllRawDateTimePatterns(char format)
public string GetDayName(DayOfWeek dayofweek)
public string GetAbbreviatedDayName(DayOfWeek dayofweek)
private void FillInvariantPatterns()
private String[] PopulateCombinedList(String[] dates, String[] times)
public String[] get_AbbreviatedMonthGenitiveNames()
public void set_AbbreviatedMonthGenitiveNames(String[] value)
public String[] get_MonthGenitiveNames()
public void set_MonthGenitiveNames(String[] value)
public string get_NativeCalendarName()
public String[] get_ShortestDayNames()
public void set_ShortestDayNames(String[] value)
public string GetShortestDayName(DayOfWeek dayOfWeek)
public void SetAllDateTimePatterns(String[] patterns, char format)
}
public System.Globalization.DateTimeStyles : Enum {
public int value__
public DateTimeStyles None
public DateTimeStyles AllowLeadingWhite
public DateTimeStyles AllowTrailingWhite
public DateTimeStyles AllowInnerWhite
public DateTimeStyles AllowWhiteSpaces
public DateTimeStyles NoCurrentDateDefault
public DateTimeStyles AdjustToUniversal
public DateTimeStyles AssumeLocal
public DateTimeStyles AssumeUniversal
public DateTimeStyles RoundtripKind
}
public System.Globalization.DaylightTime : object {
private DateTime m_start
private DateTime m_end
private TimeSpan m_delta
public DateTime Start
public DateTime End
public TimeSpan Delta
public void .ctor(DateTime start, DateTime end, TimeSpan delta)
public DateTime get_Start()
public DateTime get_End()
public TimeSpan get_Delta()
}
public System.Globalization.DigitShapes : Enum {
public int value__
public DigitShapes Context
public DigitShapes None
public DigitShapes NativeNational
}
public System.Globalization.EastAsianLunisolarCalendar : Calendar {
internal CCEastAsianLunisolarEraHandler M_EraHandler
public int TwoDigitYearMax
internal int ActualCurrentEra
public CalendarAlgorithmType AlgorithmType
internal void .ctor(CCEastAsianLunisolarEraHandler eraHandler)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckDateTime(DateTime time)
internal int get_ActualCurrentEra()
internal void M_CheckEra(Int32& era)
internal int M_CheckYEG(int year, Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal int M_CheckYMEG(int year, int month, Int32& era)
internal int M_CheckYMDEG(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public int GetCelestialStem(int sexagenaryYear)
public int GetSexagenaryYear(DateTime time)
public int GetTerrestrialBranch(int sexagenaryYear)
}
public System.Globalization.GregorianCalendar : Calendar {
public int ADEra
internal GregorianCalendarTypes m_type
private Nullable`1<DateTime> Min
private Nullable`1<DateTime> Max
public Int32[] Eras
public int TwoDigitYearMax
public GregorianCalendarTypes CalendarType
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public void .ctor(GregorianCalendarTypes type)
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
public GregorianCalendarTypes get_CalendarType()
public void set_CalendarType(GregorianCalendarTypes value)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.GregorianCalendarTypes : Enum {
public int value__
public GregorianCalendarTypes Localized
public GregorianCalendarTypes USEnglish
public GregorianCalendarTypes MiddleEastFrench
public GregorianCalendarTypes Arabic
public GregorianCalendarTypes TransliteratedEnglish
public GregorianCalendarTypes TransliteratedFrench
}
public System.Globalization.HebrewCalendar : Calendar {
internal long M_MinTicks
internal long M_MaxTicks
internal int M_MinYear
public int HebrewEra
private DateTime Min
private DateTime Max
internal int M_MaxYear
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
internal int get_M_MaxYear()
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckDateTime(DateTime time)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
internal int M_CCMonth(int month, int year)
internal int M_Month(int ccmonth, int year)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.HijriCalendar : Calendar {
public int HijriEra
internal int M_MinFixed
internal int M_MaxFixed
internal int M_AddHijriDate
private DateTime Min
private DateTime Max
public Int32[] Eras
public int HijriAdjustment
public int TwoDigitYearMax
internal int AddHijriDate
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_HijriAdjustment()
public void set_HijriAdjustment(int value)
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal int get_AddHijriDate()
internal void set_AddHijriDate(int value)
internal void M_CheckFixedHijri(string param, int rdHijri)
internal void M_CheckDateTime(DateTime time)
internal int M_FromDateTime(DateTime time)
internal DateTime M_ToDateTime(int rd)
internal DateTime M_ToDateTime(int date, int hour, int minute, int second, int milliseconds)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.IdnMapping : object {
private bool allow_unassigned
private bool use_std3
private Punycode puny
public bool AllowUnassigned
public bool UseStd3AsciiRules
public bool get_AllowUnassigned()
public void set_AllowUnassigned(bool value)
public bool get_UseStd3AsciiRules()
public void set_UseStd3AsciiRules(bool value)
public bool Equals(object obj)
public int GetHashCode()
public string GetAscii(string unicode)
public string GetAscii(string unicode, int index)
public string GetAscii(string unicode, int index, int count)
private string Convert(string input, int index, int count, bool toAscii)
private string ToAscii(string s, int offset)
private void VerifyLength(string s, int offset)
private string NamePrep(string s, int offset)
private void VerifyProhibitedCharacters(string s, int offset)
private void VerifyStd3AsciiRules(string s, int offset)
public string GetUnicode(string ascii)
public string GetUnicode(string ascii, int index)
public string GetUnicode(string ascii, int index, int count)
private string ToUnicode(string s, int offset)
}
public System.Globalization.JapaneseCalendar : Calendar {
internal CCGregorianEraHandler M_EraHandler
private DateTime JapanMin
private DateTime JapanMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckDateTime(DateTime time)
internal void M_CheckEra(Int32& era)
internal int M_CheckYEG(int year, Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal int M_CheckYMEG(int year, int month, Int32& era)
internal int M_CheckYMDEG(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
public int JapaneseEra
internal CCEastAsianLunisolarEraHandler era_handler
private DateTime JapanMin
private DateTime JapanMax
internal int ActualCurrentEra
public Int32[] Eras
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
internal int get_ActualCurrentEra()
public Int32[] get_Eras()
public int GetEra(DateTime time)
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.JulianCalendar : Calendar {
public int JulianEra
private DateTime JulianMin
private DateTime JulianMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.KoreanCalendar : Calendar {
public int KoreanEra
internal CCGregorianEraHandler M_EraHandler
private DateTime KoreanMin
private DateTime KoreanMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckEra(Int32& era)
internal int M_CheckYEG(int year, Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal int M_CheckYMEG(int year, int month, Int32& era)
internal int M_CheckYMDEG(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
public int GregorianEra
internal CCEastAsianLunisolarEraHandler era_handler
private DateTime KoreanMin
private DateTime KoreanMax
public Int32[] Eras
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int GetEra(DateTime time)
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.NumberFormatInfo : object {
private bool isReadOnly
private string decimalFormats
private string currencyFormats
private string percentFormats
private string digitPattern
private string zeroPattern
private int currencyDecimalDigits
private string currencyDecimalSeparator
private string currencyGroupSeparator
private Int32[] currencyGroupSizes
private int currencyNegativePattern
private int currencyPositivePattern
private string currencySymbol
private string nanSymbol
private string negativeInfinitySymbol
private string negativeSign
private int numberDecimalDigits
private string numberDecimalSeparator
private string numberGroupSeparator
private Int32[] numberGroupSizes
private int numberNegativePattern
private int percentDecimalDigits
private string percentDecimalSeparator
private string percentGroupSeparator
private Int32[] percentGroupSizes
private int percentNegativePattern
private int percentPositivePattern
private string percentSymbol
private string perMilleSymbol
private string positiveInfinitySymbol
private string positiveSign
private string ansiCurrencySymbol
private int m_dataItem
private bool m_useUserOverride
private bool validForParseAsNumber
private bool validForParseAsCurrency
private String[] nativeDigits
private int digitSubstitution
private String[] invariantNativeDigits
public int CurrencyDecimalDigits
public string CurrencyDecimalSeparator
public string CurrencyGroupSeparator
public Int32[] CurrencyGroupSizes
internal Int32[] RawCurrencyGroupSizes
public int CurrencyNegativePattern
public int CurrencyPositivePattern
public string CurrencySymbol
public NumberFormatInfo CurrentInfo
public NumberFormatInfo InvariantInfo
public bool IsReadOnly
public string NaNSymbol
public String[] NativeDigits
public DigitShapes DigitSubstitution
public string NegativeInfinitySymbol
public string NegativeSign
public int NumberDecimalDigits
public string NumberDecimalSeparator
public string NumberGroupSeparator
public Int32[] NumberGroupSizes
internal Int32[] RawNumberGroupSizes
public int NumberNegativePattern
public int PercentDecimalDigits
public string PercentDecimalSeparator
public string PercentGroupSeparator
public Int32[] PercentGroupSizes
internal Int32[] RawPercentGroupSizes
public int PercentNegativePattern
public int PercentPositivePattern
public string PercentSymbol
public string PerMilleSymbol
public string PositiveInfinitySymbol
public string PositiveSign
internal void .ctor(int lcid, bool read_only)
internal void .ctor(bool read_only)
private void InitPatterns()
public int get_CurrencyDecimalDigits()
public void set_CurrencyDecimalDigits(int value)
public string get_CurrencyDecimalSeparator()
public void set_CurrencyDecimalSeparator(string value)
public string get_CurrencyGroupSeparator()
public void set_CurrencyGroupSeparator(string value)
public Int32[] get_CurrencyGroupSizes()
public void set_CurrencyGroupSizes(Int32[] value)
internal Int32[] get_RawCurrencyGroupSizes()
internal void set_RawCurrencyGroupSizes(Int32[] value)
public int get_CurrencyNegativePattern()
public void set_CurrencyNegativePattern(int value)
public int get_CurrencyPositivePattern()
public void set_CurrencyPositivePattern(int value)
public string get_CurrencySymbol()
public void set_CurrencySymbol(string value)
public NumberFormatInfo get_CurrentInfo()
public NumberFormatInfo get_InvariantInfo()
public bool get_IsReadOnly()
public string get_NaNSymbol()
public void set_NaNSymbol(string value)
public String[] get_NativeDigits()
public void set_NativeDigits(String[] value)
public DigitShapes get_DigitSubstitution()
public void set_DigitSubstitution(DigitShapes value)
public string get_NegativeInfinitySymbol()
public void set_NegativeInfinitySymbol(string value)
public string get_NegativeSign()
public void set_NegativeSign(string value)
public int get_NumberDecimalDigits()
public void set_NumberDecimalDigits(int value)
public string get_NumberDecimalSeparator()
public void set_NumberDecimalSeparator(string value)
public string get_NumberGroupSeparator()
public void set_NumberGroupSeparator(string value)
public Int32[] get_NumberGroupSizes()
public void set_NumberGroupSizes(Int32[] value)
internal Int32[] get_RawNumberGroupSizes()
internal void set_RawNumberGroupSizes(Int32[] value)
public int get_NumberNegativePattern()
public void set_NumberNegativePattern(int value)
public int get_PercentDecimalDigits()
public void set_PercentDecimalDigits(int value)
public string get_PercentDecimalSeparator()
public void set_PercentDecimalSeparator(string value)
public string get_PercentGroupSeparator()
public void set_PercentGroupSeparator(string value)
public Int32[] get_PercentGroupSizes()
public void set_PercentGroupSizes(Int32[] value)
internal Int32[] get_RawPercentGroupSizes()
internal void set_RawPercentGroupSizes(Int32[] value)
public int get_PercentNegativePattern()
public void set_PercentNegativePattern(int value)
public int get_PercentPositivePattern()
public void set_PercentPositivePattern(int value)
public string get_PercentSymbol()
public void set_PercentSymbol(string value)
public string get_PerMilleSymbol()
public void set_PerMilleSymbol(string value)
public string get_PositiveInfinitySymbol()
public void set_PositiveInfinitySymbol(string value)
public string get_PositiveSign()
public void set_PositiveSign(string value)
public object GetFormat(Type formatType)
public object Clone()
public NumberFormatInfo ReadOnly(NumberFormatInfo nfi)
public NumberFormatInfo GetInstance(IFormatProvider formatProvider)
}
public System.Globalization.NumberStyles : Enum {
public int value__
public NumberStyles None
public NumberStyles AllowLeadingWhite
public NumberStyles AllowTrailingWhite
public NumberStyles AllowLeadingSign
public NumberStyles AllowTrailingSign
public NumberStyles AllowParentheses
public NumberStyles AllowDecimalPoint
public NumberStyles AllowThousands
public NumberStyles AllowExponent
public NumberStyles AllowCurrencySymbol
public NumberStyles AllowHexSpecifier
public NumberStyles Integer
public NumberStyles HexNumber
public NumberStyles Number
public NumberStyles Float
public NumberStyles Currency
public NumberStyles Any
}
public System.Globalization.PersianCalendar : Calendar {
internal long M_MinTicks
internal int M_MinYear
internal int epoch
public int PersianEra
private DateTime PersianMin
private DateTime PersianMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckDateTime(DateTime time)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
internal int fixed_from_dmy(int day, int month, int year)
internal int year_from_fixed(int date)
internal void my_from_fixed(Int32& month, Int32& year, int date)
internal void dmy_from_fixed(Int32& day, Int32& month, Int32& year, int date)
internal bool is_leap_year(int year)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.RegionInfo : object {
private RegionInfo currentRegion
private int lcid
private int regionId
private string iso2Name
private string iso3Name
private string win3Name
private string englishName
private string currencySymbol
private string isoCurrencySymbol
private string currencyEnglishName
private Dictionary`2<string, int> <>f__switch$map1D
public RegionInfo CurrentRegion
public string CurrencyEnglishName
public string CurrencySymbol
public string DisplayName
public string EnglishName
public int GeoId
public bool IsMetric
public string ISOCurrencySymbol
public string NativeName
public string CurrencyNativeName
public string Name
public string ThreeLetterISORegionName
public string ThreeLetterWindowsRegionName
public string TwoLetterISORegionName
public void .ctor(int culture)
public void .ctor(string name)
public RegionInfo get_CurrentRegion()
private bool GetByTerritory(CultureInfo ci)
private bool construct_internal_region_from_name(string name)
public string get_CurrencyEnglishName()
public string get_CurrencySymbol()
public string get_DisplayName()
public string get_EnglishName()
public int get_GeoId()
public bool get_IsMetric()
public string get_ISOCurrencySymbol()
public string get_NativeName()
public string get_CurrencyNativeName()
public string get_Name()
public string get_ThreeLetterISORegionName()
public string get_ThreeLetterWindowsRegionName()
public string get_TwoLetterISORegionName()
public bool Equals(object value)
public int GetHashCode()
public string ToString()
}
public System.Globalization.SortKey : object {
private string source
private CompareOptions options
private Byte[] key
private int lcid
public string OriginalString
public Byte[] KeyData
internal void .ctor(int lcid, string source, CompareOptions opt)
internal void .ctor(int lcid, string source, Byte[] buffer, CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength)
public int Compare(SortKey sortkey1, SortKey sortkey2)
public string get_OriginalString()
public Byte[] get_KeyData()
public bool Equals(object value)
public int GetHashCode()
public string ToString()
}
public System.Globalization.StringInfo : object {
private string s
private int length
public int LengthInTextElements
public string String
public void .ctor(string value)
public bool Equals(object value)
public int GetHashCode()
public int get_LengthInTextElements()
public string get_String()
public void set_String(string value)
public string SubstringByTextElements(int startingTextElement)
public string SubstringByTextElements(int startingTextElement, int lengthInTextElements)
public string GetNextTextElement(string str)
public string GetNextTextElement(string str, int index)
private int GetNextTextElementLength(string str, int index)
public TextElementEnumerator GetTextElementEnumerator(string str)
public TextElementEnumerator GetTextElementEnumerator(string str, int index)
public Int32[] ParseCombiningCharacters(string str)
}
public System.Globalization.TaiwanCalendar : Calendar {
internal CCGregorianEraHandler M_EraHandler
private DateTime TaiwanMin
private DateTime TaiwanMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckDateTime(DateTime time)
internal void M_CheckEra(Int32& era)
internal int M_CheckYEG(int year, Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal int M_CheckYMEG(int year, int month, Int32& era)
internal int M_CheckYMDEG(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
private int TaiwanEra
internal CCEastAsianLunisolarEraHandler era_handler
private DateTime TaiwanMin
private DateTime TaiwanMax
public Int32[] Eras
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int GetEra(DateTime time)
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.TextElementEnumerator : object {
private int index
private int elementindex
private int startpos
private string str
private string element
public object Current
public int ElementIndex
internal void .ctor(string str, int startpos)
public object get_Current()
public int get_ElementIndex()
public string GetTextElement()
public bool MoveNext()
public void Reset()
}
public System.Globalization.TextInfo : object {
private string m_listSeparator
private bool m_isReadOnly
private string customCultureName
private int m_nDataItem
private bool m_useUserOverride
private int m_win32LangID
private CultureInfo ci
private bool handleDotI
private Data data
public int ANSICodePage
public int EBCDICCodePage
public int LCID
public string ListSeparator
public int MacCodePage
public int OEMCodePage
public string CultureName
public bool IsReadOnly
public bool IsRightToLeft
internal void .ctor(CultureInfo ci, int lcid, Void* data, bool read_only)
private void .ctor(TextInfo textInfo)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
public int get_ANSICodePage()
public int get_EBCDICCodePage()
public int get_LCID()
public string get_ListSeparator()
public void set_ListSeparator(string value)
public int get_MacCodePage()
public int get_OEMCodePage()
public string get_CultureName()
public bool get_IsReadOnly()
public bool get_IsRightToLeft()
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
public string ToTitleCase(string str)
public char ToLower(char c)
public char ToUpper(char c)
private char ToTitleCase(char c)
public string ToLower(string str)
public string ToUpper(string str)
public TextInfo ReadOnly(TextInfo textInfo)
public object Clone()
}
public System.Globalization.ThaiBuddhistCalendar : Calendar {
public int ThaiBuddhistEra
internal CCGregorianEraHandler M_EraHandler
private DateTime ThaiMin
private DateTime ThaiMax
public Int32[] Eras
public int TwoDigitYearMax
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal void M_CheckEra(Int32& era)
internal int M_CheckYEG(int year, Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal int M_CheckYMEG(int year, int month, Int32& era)
internal int M_CheckYMDEG(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.UmAlQuraCalendar : Calendar {
public int UmAlQuraEra
internal int M_MinFixed
internal int M_MaxFixed
internal int M_AddHijriDate
private DateTime Min
private DateTime Max
public Int32[] Eras
public int TwoDigitYearMax
internal int AddHijriDate
public CalendarAlgorithmType AlgorithmType
public DateTime MinSupportedDateTime
public DateTime MaxSupportedDateTime
public Int32[] get_Eras()
public int get_TwoDigitYearMax()
public void set_TwoDigitYearMax(int value)
internal int get_AddHijriDate()
internal void set_AddHijriDate(int value)
internal void M_CheckFixedHijri(string param, int rdHijri)
internal void M_CheckDateTime(DateTime time)
internal int M_FromDateTime(DateTime time)
internal DateTime M_ToDateTime(int rd)
internal DateTime M_ToDateTime(int date, int hour, int minute, int second, int milliseconds)
internal void M_CheckEra(Int32& era)
internal void M_CheckYE(int year, Int32& era)
internal void M_CheckYME(int year, int month, Int32& era)
internal void M_CheckYMDE(int year, int month, int day, Int32& era)
public DateTime AddMonths(DateTime time, int months)
public DateTime AddYears(DateTime time, int years)
public int GetDayOfMonth(DateTime time)
public DayOfWeek GetDayOfWeek(DateTime time)
public int GetDayOfYear(DateTime time)
public int GetDaysInMonth(int year, int month, int era)
public int GetDaysInYear(int year, int era)
public int GetEra(DateTime time)
public int GetLeapMonth(int year, int era)
public int GetMonth(DateTime time)
public int GetMonthsInYear(int year, int era)
public int GetYear(DateTime time)
public bool IsLeapDay(int year, int month, int day, int era)
public bool IsLeapMonth(int year, int month, int era)
public bool IsLeapYear(int year, int era)
public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era)
public int ToFourDigitYear(int year)
public CalendarAlgorithmType get_AlgorithmType()
public DateTime get_MinSupportedDateTime()
public DateTime get_MaxSupportedDateTime()
}
public System.Globalization.UnicodeCategory : Enum {
public int value__
public UnicodeCategory UppercaseLetter
public UnicodeCategory LowercaseLetter
public UnicodeCategory TitlecaseLetter
public UnicodeCategory ModifierLetter
public UnicodeCategory OtherLetter
public UnicodeCategory NonSpacingMark
public UnicodeCategory SpacingCombiningMark
public UnicodeCategory EnclosingMark
public UnicodeCategory DecimalDigitNumber
public UnicodeCategory LetterNumber
public UnicodeCategory OtherNumber
public UnicodeCategory SpaceSeparator
public UnicodeCategory LineSeparator
public UnicodeCategory ParagraphSeparator
public UnicodeCategory Control
public UnicodeCategory Format
public UnicodeCategory Surrogate
public UnicodeCategory PrivateUse
public UnicodeCategory ConnectorPunctuation
public UnicodeCategory DashPunctuation
public UnicodeCategory OpenPunctuation
public UnicodeCategory ClosePunctuation
public UnicodeCategory InitialQuotePunctuation
public UnicodeCategory FinalQuotePunctuation
public UnicodeCategory OtherPunctuation
public UnicodeCategory MathSymbol
public UnicodeCategory CurrencySymbol
public UnicodeCategory ModifierSymbol
public UnicodeCategory OtherSymbol
public UnicodeCategory OtherNotAssigned
}
public System.Guid : ValueType {
private int _a
private short _b
private short _c
private byte _d
private byte _e
private byte _f
private byte _g
private byte _h
private byte _i
private byte _j
private byte _k
public Guid Empty
private object _rngAccess
private RandomNumberGenerator _rng
private RandomNumberGenerator _fastRng
public void .ctor(Byte[] b)
public void .ctor(string g)
public void .ctor(int a, short b, short c, Byte[] d)
public void .ctor(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
public void .ctor(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k)
private void CheckNull(object o)
private void CheckLength(Byte[] o, int l)
private void CheckArray(Byte[] o, int l)
private int Compare(int x, int y)
public int CompareTo(object value)
public bool Equals(object o)
public int CompareTo(Guid value)
public bool Equals(Guid g)
public int GetHashCode()
private char ToHex(int b)
public Guid NewGuid()
internal Byte[] FastNewGuidArray()
public Byte[] ToByteArray()
private void AppendInt(StringBuilder builder, int value)
private void AppendShort(StringBuilder builder, short value)
private void AppendByte(StringBuilder builder, byte value)
private string BaseToString(bool h, bool p, bool b)
public string ToString()
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public bool op_Equality(Guid a, Guid b)
public bool op_Inequality(Guid a, Guid b)
}
internal System.Handles : Enum {
public int value__
public Handles STD_INPUT
public Handles STD_OUTPUT
public Handles STD_ERROR
}
public System.IAppDomainSetup {
public string ApplicationBase
public string ApplicationName
public string CachePath
public string ConfigurationFile
public string DynamicBase
public string LicenseFile
public string PrivateBinPath
public string PrivateBinPathProbe
public string ShadowCopyDirectories
public string ShadowCopyFiles
public string get_ApplicationBase()
public void set_ApplicationBase(string value)
public string get_ApplicationName()
public void set_ApplicationName(string value)
public string get_CachePath()
public void set_CachePath(string value)
public string get_ConfigurationFile()
public void set_ConfigurationFile(string value)
public string get_DynamicBase()
public void set_DynamicBase(string value)
public string get_LicenseFile()
public void set_LicenseFile(string value)
public string get_PrivateBinPath()
public void set_PrivateBinPath(string value)
public string get_PrivateBinPathProbe()
public void set_PrivateBinPathProbe(string value)
public string get_ShadowCopyDirectories()
public void set_ShadowCopyDirectories(string value)
public string get_ShadowCopyFiles()
public void set_ShadowCopyFiles(string value)
}
public System.IAsyncResult {
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
}
public System.ICloneable {
public object Clone()
}
public System.IComparable {
public int CompareTo(object obj)
}
public System.IComparable`1 {
public int CompareTo(T other)
}
internal System.IConsoleDriver {
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Init()
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
public string ReadLine()
}
public System.IConvertible {
public TypeCode GetTypeCode()
public bool ToBoolean(IFormatProvider provider)
public byte ToByte(IFormatProvider provider)
public char ToChar(IFormatProvider provider)
public DateTime ToDateTime(IFormatProvider provider)
public decimal ToDecimal(IFormatProvider provider)
public double ToDouble(IFormatProvider provider)
public short ToInt16(IFormatProvider provider)
public int ToInt32(IFormatProvider provider)
public long ToInt64(IFormatProvider provider)
public sbyte ToSByte(IFormatProvider provider)
public float ToSingle(IFormatProvider provider)
public string ToString(IFormatProvider provider)
public object ToType(Type conversionType, IFormatProvider provider)
public ushort ToUInt16(IFormatProvider provider)
public UInt32 ToUInt32(IFormatProvider provider)
public ulong ToUInt64(IFormatProvider provider)
}
public System.ICustomFormatter {
public string Format(string format, object arg, IFormatProvider formatProvider)
}
public System.IDisposable {
public void Dispose()
}
public System.IEquatable`1 {
public bool Equals(T other)
}
public System.IFormatProvider {
public object GetFormat(Type formatType)
}
public System.IFormattable {
public string ToString(string format, IFormatProvider formatProvider)
}
public System.IndexOutOfRangeException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.InputRecord : ValueType {
public short EventType
public bool KeyDown
public short RepeatCount
public short VirtualKeyCode
public short VirtualScanCode
public char Character
public int ControlKeyState
private int pad1
private bool pad2
}
public System.InsufficientMemoryException : OutOfMemoryException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
}
public System.Int16 : ValueType {
public short MaxValue
public short MinValue
internal short m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(short value)
public bool Equals(short obj)
internal bool Parse(string s, bool tryParse, Int16& result, Exception& exc)
public short Parse(string s, IFormatProvider provider)
public short Parse(string s, NumberStyles style)
public short Parse(string s, NumberStyles style, IFormatProvider provider)
public short Parse(string s)
public bool TryParse(string s, Int16& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.Int32 : ValueType {
public int MaxValue
public int MinValue
internal int m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(int value)
public bool Equals(int obj)
internal bool ProcessTrailingWhitespace(bool tryParse, string s, int position, Exception& exc)
internal bool Parse(string s, bool tryParse, Int32& result, Exception& exc)
public int Parse(string s, IFormatProvider provider)
public int Parse(string s, NumberStyles style)
internal bool CheckStyle(NumberStyles style, bool tryParse, Exception& exc)
internal bool JumpOverWhite(Int32& pos, string s, bool reportError, bool tryParse, Exception& exc)
internal void FindSign(Int32& pos, string s, NumberFormatInfo nfi, Boolean& foundSign, Boolean& negative)
internal void FindCurrency(Int32& pos, string s, NumberFormatInfo nfi, Boolean& foundCurrency)
internal bool FindExponent(Int32& pos, string s, Int32& exponent, bool tryParse, Exception& exc)
internal bool FindOther(Int32& pos, string s, string other)
internal bool ValidDigit(char e, bool allowHex)
internal Exception GetFormatException()
internal bool Parse(string s, NumberStyles style, IFormatProvider fp, bool tryParse, Int32& result, Exception& exc)
public int Parse(string s)
public int Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Int32& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.Int64 : ValueType {
public long MaxValue
public long MinValue
internal long m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(long value)
public bool Equals(long obj)
internal bool Parse(string s, bool tryParse, Int64& result, Exception& exc)
public long Parse(string s, IFormatProvider provider)
public long Parse(string s, NumberStyles style)
internal bool Parse(string s, NumberStyles style, IFormatProvider fp, bool tryParse, Int64& result, Exception& exc)
public long Parse(string s)
public long Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, Int64& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.IntPtr : ValueType {
private Void* m_value
public IntPtr Zero
public int Size
public void .ctor(int value)
public void .ctor(long value)
public void .ctor(Void* value)
private void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public int get_Size()
public bool Equals(object obj)
public int GetHashCode()
public int ToInt32()
public long ToInt64()
public Void* ToPointer()
public string ToString()
public string ToString(string format)
public bool op_Equality(IntPtr value1, IntPtr value2)
public bool op_Inequality(IntPtr value1, IntPtr value2)
public IntPtr op_Explicit(int value)
public IntPtr op_Explicit(long value)
public IntPtr op_Explicit(Void* value)
public int op_Explicit(IntPtr value)
public long op_Explicit(IntPtr value)
public Void* op_Explicit(IntPtr value)
}
public System.InvalidCastException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.InvalidOperationException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.InvalidProgramException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.BinaryReader : object {
private int MaxBufferSize
private Stream m_stream
private Encoding m_encoding
private Byte[] m_buffer
private Decoder decoder
private Char[] charBuffer
private bool m_disposed
public Stream BaseStream
public void .ctor(Stream input)
public void .ctor(Stream input, Encoding encoding)
private void System.IDisposable.Dispose()
public Stream get_BaseStream()
public void Close()
protected void Dispose(bool disposing)
protected void FillBuffer(int numBytes)
public int PeekChar()
public int Read()
public int Read(Byte[] buffer, int index, int count)
public int Read(Char[] buffer, int index, int count)
private int ReadCharBytes(Char[] buffer, int index, int count, Int32& bytes_read)
protected int Read7BitEncodedInt()
public bool ReadBoolean()
public byte ReadByte()
public Byte[] ReadBytes(int count)
public char ReadChar()
public Char[] ReadChars(int count)
public decimal ReadDecimal()
public double ReadDouble()
public short ReadInt16()
public int ReadInt32()
public long ReadInt64()
public sbyte ReadSByte()
public string ReadString()
public float ReadSingle()
public ushort ReadUInt16()
public UInt32 ReadUInt32()
public ulong ReadUInt64()
private void CheckBuffer(int length)
}
public System.IO.BinaryWriter : object {
public BinaryWriter Null
protected Stream OutStream
private Encoding m_encoding
private Byte[] buffer
private bool disposed
private Byte[] stringBuffer
private int maxCharsPerRound
public Stream BaseStream
public void .ctor(Stream output)
public void .ctor(Stream output, Encoding encoding)
private void System.IDisposable.Dispose()
public Stream get_BaseStream()
public void Close()
protected void Dispose(bool disposing)
public void Flush()
public long Seek(int offset, SeekOrigin origin)
public void Write(bool value)
public void Write(byte value)
public void Write(Byte[] buffer)
public void Write(Byte[] buffer, int index, int count)
public void Write(char ch)
public void Write(Char[] chars)
public void Write(Char[] chars, int index, int count)
public void Write(decimal value)
public void Write(double value)
public void Write(short value)
public void Write(int value)
public void Write(long value)
public void Write(sbyte value)
public void Write(float value)
public void Write(string value)
public void Write(ushort value)
public void Write(UInt32 value)
public void Write(ulong value)
protected void Write7BitEncodedInt(int value)
}
public System.IO.BufferedStream : Stream {
private Stream m_stream
private Byte[] m_buffer
private int m_buffer_pos
private int m_buffer_read_ahead
private bool m_buffer_reading
private bool disposed
public bool CanRead
public bool CanWrite
public bool CanSeek
public long Length
public long Position
public void .ctor(Stream stream)
public void .ctor(Stream stream, int bufferSize)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public long get_Length()
public long get_Position()
public void set_Position(long value)
protected void Dispose(bool disposing)
public void Flush()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public int ReadByte()
public void WriteByte(byte value)
public int Read(Byte[] array, int offset, int count)
public void Write(Byte[] array, int offset, int count)
private void CheckObjectDisposedException()
}
internal System.IO.CStreamReader : StreamReader {
private TermInfoDriver driver
public void .ctor(Stream stream, Encoding encoding)
public int Peek()
public int Read()
public int Read(Char[] dest, int index, int count)
public string ReadLine()
public string ReadToEnd()
}
internal System.IO.CStreamWriter : StreamWriter {
private TermInfoDriver driver
public void .ctor(Stream stream, Encoding encoding)
public void Write(Char[] buffer, int index, int count)
public void Write(char val)
public void WriteKey(ConsoleKeyInfo key)
public void InternalWriteString(string val)
public void InternalWriteChar(char val)
public void InternalWriteChars(Char[] buffer, int n)
public void Write(Char[] val)
public void Write(string val)
}
public System.IO.Directory : object {
public DirectoryInfo CreateDirectory(string path)
public DirectoryInfo CreateDirectory(string path, DirectorySecurity directorySecurity)
private DirectoryInfo CreateDirectoriesInternal(string path)
public void Delete(string path)
private void RecursiveDelete(string path)
public void Delete(string path, bool recursive)
public bool Exists(string path)
public DateTime GetLastAccessTime(string path)
public DateTime GetLastAccessTimeUtc(string path)
public DateTime GetLastWriteTime(string path)
public DateTime GetLastWriteTimeUtc(string path)
public DateTime GetCreationTime(string path)
public DateTime GetCreationTimeUtc(string path)
public string GetCurrentDirectory()
public String[] GetDirectories(string path)
public String[] GetDirectories(string path, string searchPattern)
public String[] GetDirectories(string path, string searchPattern, SearchOption searchOption)
private void GetDirectoriesRecurse(string path, string searchPattern, ArrayList all)
public string GetDirectoryRoot(string path)
public String[] GetFiles(string path)
public String[] GetFiles(string path, string searchPattern)
public String[] GetFiles(string path, string searchPattern, SearchOption searchOption)
private void GetFilesRecurse(string path, string searchPattern, ArrayList all)
public String[] GetFileSystemEntries(string path)
public String[] GetFileSystemEntries(string path, string searchPattern)
public String[] GetLogicalDrives()
private bool IsRootDirectory(string path)
public DirectoryInfo GetParent(string path)
public void Move(string sourceDirName, string destDirName)
public void SetAccessControl(string path, DirectorySecurity directorySecurity)
public void SetCreationTime(string path, DateTime creationTime)
public void SetCreationTimeUtc(string path, DateTime creationTimeUtc)
public void SetCurrentDirectory(string path)
public void SetLastAccessTime(string path, DateTime lastAccessTime)
public void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc)
public void SetLastWriteTime(string path, DateTime lastWriteTime)
public void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc)
private void CheckPathExceptions(string path)
private String[] GetFileSystemEntries(string path, string searchPattern, FileAttributes mask, FileAttributes attrs)
public DirectorySecurity GetAccessControl(string path, AccessControlSections includeSections)
public DirectorySecurity GetAccessControl(string path)
}
public System.IO.DirectoryInfo : FileSystemInfo {
private string current
private string parent
public bool Exists
public string Name
public DirectoryInfo Parent
public DirectoryInfo Root
public void .ctor(string path)
internal void .ctor(string path, bool simpleOriginalPath)
private void .ctor(SerializationInfo info, StreamingContext context)
private void Initialize()
public bool get_Exists()
public string get_Name()
public DirectoryInfo get_Parent()
public DirectoryInfo get_Root()
public void Create()
public DirectoryInfo CreateSubdirectory(string path)
public FileInfo[] GetFiles()
public FileInfo[] GetFiles(string searchPattern)
public DirectoryInfo[] GetDirectories()
public DirectoryInfo[] GetDirectories(string searchPattern)
public FileSystemInfo[] GetFileSystemInfos()
public FileSystemInfo[] GetFileSystemInfos(string searchPattern)
public void Delete()
public void Delete(bool recursive)
public void MoveTo(string destDirName)
public string ToString()
public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption)
internal int GetFilesSubdirs(ArrayList l, string pattern)
public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption)
public void Create(DirectorySecurity directorySecurity)
public DirectoryInfo CreateSubdirectory(string path, DirectorySecurity directorySecurity)
public DirectorySecurity GetAccessControl()
public DirectorySecurity GetAccessControl(AccessControlSections includeSections)
public void SetAccessControl(DirectorySecurity directorySecurity)
}
public System.IO.DirectoryNotFoundException : IOException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.DriveInfo : object {
private _DriveType _drive_type
private string drive_format
private string path
public long AvailableFreeSpace
public long TotalFreeSpace
public long TotalSize
public string VolumeLabel
public string DriveFormat
public DriveType DriveType
public string Name
public DirectoryInfo RootDirectory
public bool IsReady
private void .ctor(_DriveType _drive_type, string path, string fstype)
public void .ctor(string driveName)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void GetDiskFreeSpace(string path, UInt64& availableFreeSpace, UInt64& totalSize, UInt64& totalFreeSpace)
public long get_AvailableFreeSpace()
public long get_TotalFreeSpace()
public long get_TotalSize()
public string get_VolumeLabel()
public void set_VolumeLabel(string value)
public string get_DriveFormat()
public DriveType get_DriveType()
public string get_Name()
public DirectoryInfo get_RootDirectory()
public bool get_IsReady()
private StreamReader TryOpen(string name)
private DriveInfo[] LinuxGetDrives()
private DriveInfo[] UnixGetDrives()
private DriveInfo[] WindowsGetDrives()
public DriveInfo[] GetDrives()
public string ToString()
private bool GetDiskFreeSpaceInternal(string pathName, UInt64& freeBytesAvail, UInt64& totalNumberOfBytes, UInt64& totalNumberOfFreeBytes, MonoIOError& error)
private UInt32 GetDriveTypeInternal(string rootPathName)
}
public System.IO.DriveNotFoundException : IOException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.DriveType : Enum {
public int value__
public DriveType CDRom
public DriveType Fixed
public DriveType Network
public DriveType NoRootDirectory
public DriveType Ram
public DriveType Removable
public DriveType Unknown
}
public System.IO.EndOfStreamException : IOException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.IO.File : object {
private Nullable`1<DateTime> defaultLocalFileTime
private DateTime DefaultLocalFileTime
public void AppendAllText(string path, string contents)
public void AppendAllText(string path, string contents, Encoding encoding)
public StreamWriter AppendText(string path)
public void Copy(string sourceFileName, string destFileName)
public void Copy(string sourceFileName, string destFileName, bool overwrite)
public FileStream Create(string path)
public FileStream Create(string path, int bufferSize)
public FileStream Create(string path, int bufferSize, FileOptions options)
public FileStream Create(string path, int bufferSize, FileOptions options, FileSecurity fileSecurity)
public StreamWriter CreateText(string path)
public void Delete(string path)
public bool Exists(string path)
public FileSecurity GetAccessControl(string path)
public FileSecurity GetAccessControl(string path, AccessControlSections includeSections)
public FileAttributes GetAttributes(string path)
public DateTime GetCreationTime(string path)
public DateTime GetCreationTimeUtc(string path)
public DateTime GetLastAccessTime(string path)
public DateTime GetLastAccessTimeUtc(string path)
public DateTime GetLastWriteTime(string path)
public DateTime GetLastWriteTimeUtc(string path)
public void Move(string sourceFileName, string destFileName)
public FileStream Open(string path, FileMode mode)
public FileStream Open(string path, FileMode mode, FileAccess access)
public FileStream Open(string path, FileMode mode, FileAccess access, FileShare share)
public FileStream OpenRead(string path)
public StreamReader OpenText(string path)
public FileStream OpenWrite(string path)
public void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName)
public void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors)
public void SetAccessControl(string path, FileSecurity fileSecurity)
public void SetAttributes(string path, FileAttributes fileAttributes)
public void SetCreationTime(string path, DateTime creationTime)
public void SetCreationTimeUtc(string path, DateTime creationTimeUtc)
public void SetLastAccessTime(string path, DateTime lastAccessTime)
public void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc)
public void SetLastWriteTime(string path, DateTime lastWriteTime)
public void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc)
private void CheckPathExceptions(string path)
public Byte[] ReadAllBytes(string path)
public String[] ReadAllLines(string path)
public String[] ReadAllLines(string path, Encoding encoding)
private String[] ReadAllLines(StreamReader reader)
public string ReadAllText(string path)
public string ReadAllText(string path, Encoding encoding)
public void WriteAllBytes(string path, Byte[] bytes)
public void WriteAllLines(string path, String[] contents)
public void WriteAllLines(string path, String[] contents, Encoding encoding)
private void WriteAllLines(StreamWriter writer, String[] contents)
public void WriteAllText(string path, string contents)
public void WriteAllText(string path, string contents, Encoding encoding)
private DateTime get_DefaultLocalFileTime()
public void Encrypt(string path)
public void Decrypt(string path)
}
public System.IO.FileAccess : Enum {
public int value__
public FileAccess Read
public FileAccess Write
public FileAccess ReadWrite
}
public System.IO.FileAttributes : Enum {
public int value__
public FileAttributes Archive
public FileAttributes Compressed
public FileAttributes Device
public FileAttributes Directory
public FileAttributes Encrypted
public FileAttributes Hidden
public FileAttributes Normal
public FileAttributes NotContentIndexed
public FileAttributes Offline
public FileAttributes ReadOnly
public FileAttributes ReparsePoint
public FileAttributes SparseFile
public FileAttributes System
public FileAttributes Temporary
}
public System.IO.FileInfo : FileSystemInfo {
private bool exists
public bool Exists
public string Name
public bool IsReadOnly
public long Length
public string DirectoryName
public DirectoryInfo Directory
public void .ctor(string fileName)
private void .ctor(SerializationInfo info, StreamingContext context)
internal void InternalRefresh()
public bool get_Exists()
public string get_Name()
public bool get_IsReadOnly()
public void set_IsReadOnly(bool value)
public void Encrypt()
public void Decrypt()
public long get_Length()
public string get_DirectoryName()
public DirectoryInfo get_Directory()
public StreamReader OpenText()
public StreamWriter CreateText()
public StreamWriter AppendText()
public FileStream Create()
public FileStream OpenRead()
public FileStream OpenWrite()
public FileStream Open(FileMode mode)
public FileStream Open(FileMode mode, FileAccess access)
public FileStream Open(FileMode mode, FileAccess access, FileShare share)
public void Delete()
public void MoveTo(string destFileName)
public FileInfo CopyTo(string destFileName)
public FileInfo CopyTo(string destFileName, bool overwrite)
public string ToString()
public FileSecurity GetAccessControl()
public FileSecurity GetAccessControl(AccessControlSections includeSections)
public FileInfo Replace(string destinationFileName, string destinationBackupFileName)
public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors)
public void SetAccessControl(FileSecurity fileSecurity)
}
public System.IO.FileLoadException : IOException {
private int Result
private string msg
private string fileName
private string fusionLog
public string Message
public string FileName
public string FusionLog
public void .ctor(string message)
public void .ctor(string message, string fileName)
public void .ctor(string message, Exception inner)
public void .ctor(string message, string fileName, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
public string get_FileName()
public string get_FusionLog()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.IO.FileMode : Enum {
public int value__
public FileMode CreateNew
public FileMode Create
public FileMode Open
public FileMode OpenOrCreate
public FileMode Truncate
public FileMode Append
}
public System.IO.FileNotFoundException : IOException {
private int Result
private string fileName
private string fusionLog
public string FileName
public string FusionLog
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, string fileName)
public void .ctor(string message, string fileName, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_FileName()
public string get_FusionLog()
public string get_Message()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.IO.FileOptions : Enum {
public int value__
public FileOptions None
public FileOptions Encrypted
public FileOptions DeleteOnClose
public FileOptions SequentialScan
public FileOptions RandomAccess
public FileOptions Asynchronous
public FileOptions WriteThrough
}
public System.IO.FileShare : Enum {
public int value__
public FileShare None
public FileShare Read
public FileShare Write
public FileShare ReadWrite
public FileShare Delete
public FileShare Inheritable
}
public System.IO.FileStream : Stream {
internal int DefaultBufferSize
private FileAccess access
private bool owner
private bool async
private bool canseek
private long append_startpos
private bool anonymous
private Byte[] buf
private int buf_size
private int buf_length
private int buf_offset
private bool buf_dirty
private long buf_start
private string name
private IntPtr handle
private SafeFileHandle safeHandle
public bool CanRead
public bool CanWrite
public bool CanSeek
public bool IsAsync
public string Name
public long Length
public long Position
public IntPtr Handle
public SafeFileHandle SafeFileHandle
public void .ctor(IntPtr handle, FileAccess access)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize)
public void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync)
internal void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool noBuffering)
public void .ctor(string path, FileMode mode)
public void .ctor(string path, FileMode mode, FileAccess access)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options)
public void .ctor(SafeFileHandle handle, FileAccess access)
public void .ctor(SafeFileHandle handle, FileAccess access, int bufferSize)
public void .ctor(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync)
public void .ctor(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options)
public void .ctor(string path, FileMode mode, FileSystemRights rights, FileShare share, int bufferSize, FileOptions options, FileSecurity fileSecurity)
internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool isAsync, bool anonymous)
internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool anonymous, FileOptions options)
public bool get_CanRead()
public bool get_CanWrite()
public bool get_CanSeek()
public bool get_IsAsync()
public string get_Name()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IntPtr get_Handle()
public SafeFileHandle get_SafeFileHandle()
public int ReadByte()
public void WriteByte(byte value)
public int Read(Byte[] array, int offset, int count)
private int ReadInternal(Byte[] dest, int offset, int count)
public IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public int EndRead(IAsyncResult asyncResult)
public void Write(Byte[] array, int offset, int count)
private void WriteInternal(Byte[] src, int offset, int count)
public IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public void EndWrite(IAsyncResult asyncResult)
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Flush()
public void Lock(long position, long length)
public void Unlock(long position, long length)
protected void Finalize()
protected void Dispose(bool disposing)
public FileSecurity GetAccessControl()
public void SetAccessControl(FileSecurity fileSecurity)
private int ReadSegment(Byte[] dest, int dest_offset, int count)
private int WriteSegment(Byte[] src, int src_offset, int count)
private void FlushBuffer(Stream st)
private void FlushBuffer()
private void FlushBufferIfDirty()
private void RefillBuffer()
private int ReadData(IntPtr handle, Byte[] buf, int offset, int count)
private void InitBuffer(int size, bool noBuffering)
private string GetSecureFileName(string filename)
private string GetSecureFileName(string filename, bool full)
}
internal System.IO.FileStreamAsyncResult : object {
private object state
private bool completed
private bool done
private Exception exc
private ManualResetEvent wh
private AsyncCallback cb
private bool completedSynch
public Byte[] Buffer
public int Offset
public int Count
public int OriginalCount
public int BytesRead
private AsyncCallback realcb
public object AsyncState
public bool CompletedSynchronously
public WaitHandle AsyncWaitHandle
public bool IsCompleted
public Exception Exception
public bool Done
public void .ctor(AsyncCallback cb, object state)
private void CBWrapper(IAsyncResult ares)
public void SetComplete(Exception e)
public void SetComplete(Exception e, int nbytes)
public void SetComplete(Exception e, int nbytes, bool synch)
public object get_AsyncState()
public bool get_CompletedSynchronously()
public WaitHandle get_AsyncWaitHandle()
public bool get_IsCompleted()
public Exception get_Exception()
public bool get_Done()
public void set_Done(bool value)
}
public System.IO.FileSystemInfo : MarshalByRefObject {
protected string FullPath
protected string OriginalPath
internal MonoIOStat stat
internal bool valid
public bool Exists
public string Name
public string FullName
public string Extension
public FileAttributes Attributes
public DateTime CreationTime
public DateTime CreationTimeUtc
public DateTime LastAccessTime
public DateTime LastAccessTimeUtc
public DateTime LastWriteTime
public DateTime LastWriteTimeUtc
protected void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool get_Exists()
public string get_Name()
public string get_FullName()
public string get_Extension()
public FileAttributes get_Attributes()
public void set_Attributes(FileAttributes value)
public DateTime get_CreationTime()
public void set_CreationTime(DateTime value)
public DateTime get_CreationTimeUtc()
public void set_CreationTimeUtc(DateTime value)
public DateTime get_LastAccessTime()
public void set_LastAccessTime(DateTime value)
public DateTime get_LastAccessTimeUtc()
public void set_LastAccessTimeUtc(DateTime value)
public DateTime get_LastWriteTime()
public void set_LastWriteTime(DateTime value)
public DateTime get_LastWriteTimeUtc()
public void set_LastWriteTimeUtc(DateTime value)
public void Delete()
public void Refresh()
internal void Refresh(bool force)
internal void InternalRefresh()
internal void CheckPath(string path)
}
public System.IO.IOException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, int hresult)
}
public System.IO.IsolatedStorage.INormalizeForIsolatedStorage {
public object Normalize()
}
public System.IO.IsolatedStorage.IsolatedStorage : MarshalByRefObject {
internal IsolatedStorageScope storage_scope
internal object _assemblyIdentity
internal object _domainIdentity
internal object _applicationIdentity
public object ApplicationIdentity
public object AssemblyIdentity
public ulong CurrentSize
public object DomainIdentity
public ulong MaximumSize
public IsolatedStorageScope Scope
protected char SeparatorExternal
protected char SeparatorInternal
public object get_ApplicationIdentity()
public object get_AssemblyIdentity()
public ulong get_CurrentSize()
public object get_DomainIdentity()
public ulong get_MaximumSize()
public IsolatedStorageScope get_Scope()
protected char get_SeparatorExternal()
protected char get_SeparatorInternal()
protected IsolatedStoragePermission GetPermission(PermissionSet ps)
protected void InitStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType)
protected void InitStore(IsolatedStorageScope scope, Type appEvidenceType)
public void Remove()
}
public System.IO.IsolatedStorage.IsolatedStorageException : Exception {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.IO.IsolatedStorage.IsolatedStorageFile : IsolatedStorage {
private bool _resolved
private ulong _maxSize
private Evidence _fullEvidences
private Mutex mutex
private DirectoryInfo directory
public ulong CurrentSize
public ulong MaximumSize
internal string Root
private void .ctor(IsolatedStorageScope scope)
internal void .ctor(IsolatedStorageScope scope, string location)
public IEnumerator GetEnumerator(IsolatedStorageScope scope)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Evidence domainEvidence, Type domainEvidenceType, Evidence assemblyEvidence, Type assemblyEvidenceType)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, object applicationIdentity)
public IsolatedStorageFile GetStore(IsolatedStorageScope scope, Type applicationEvidenceType)
public IsolatedStorageFile GetMachineStoreForApplication()
public IsolatedStorageFile GetMachineStoreForAssembly()
public IsolatedStorageFile GetMachineStoreForDomain()
public IsolatedStorageFile GetUserStoreForApplication()
public IsolatedStorageFile GetUserStoreForAssembly()
public IsolatedStorageFile GetUserStoreForDomain()
public void Remove(IsolatedStorageScope scope)
internal string GetIsolatedStorageRoot(IsolatedStorageScope scope)
private void Demand(IsolatedStorageScope scope)
private IsolatedStorageContainment ScopeToContainment(IsolatedStorageScope scope)
internal ulong GetDirectorySize(DirectoryInfo di)
protected void Finalize()
private void PostInit()
public ulong get_CurrentSize()
public ulong get_MaximumSize()
internal string get_Root()
public void Close()
public void CreateDirectory(string dir)
public void DeleteDirectory(string dir)
public void DeleteFile(string file)
public void Dispose()
public String[] GetDirectoryNames(string searchPattern)
private String[] GetNames(FileSystemInfo[] afsi)
public String[] GetFileNames(string searchPattern)
public void Remove()
protected IsolatedStoragePermission GetPermission(PermissionSet ps)
private string GetNameFromIdentity(object identity)
private object GetTypeFromEvidence(Evidence e, Type t)
internal object GetAssemblyIdentityFromEvidence(Evidence e)
internal object GetDomainIdentityFromEvidence(Evidence e)
private void SaveIdentities(string root)
}
internal System.IO.IsolatedStorage.IsolatedStorageFileEnumerator : object {
private IsolatedStorageScope _scope
private String[] _storages
private int _pos
public object Current
public void .ctor(IsolatedStorageScope scope, string root)
public object get_Current()
public bool MoveNext()
public void Reset()
}
public System.IO.IsolatedStorage.IsolatedStorageFileStream : FileStream {
public bool CanRead
public bool CanSeek
public bool CanWrite
public SafeFileHandle SafeFileHandle
public IntPtr Handle
public bool IsAsync
public long Length
public long Position
public void .ctor(string path, FileMode mode)
public void .ctor(string path, FileMode mode, FileAccess access)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, FileAccess access, IsolatedStorageFile isf)
public void .ctor(string path, FileMode mode, IsolatedStorageFile isf)
private string CreateIsolatedPath(IsolatedStorageFile isf, string path, FileMode mode)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public SafeFileHandle get_SafeFileHandle()
public IntPtr get_Handle()
public bool get_IsAsync()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
protected void Dispose(bool disposing)
}
public System.IO.IsolatedStorage.IsolatedStorageScope : Enum {
public int value__
public IsolatedStorageScope None
public IsolatedStorageScope User
public IsolatedStorageScope Domain
public IsolatedStorageScope Assembly
public IsolatedStorageScope Roaming
public IsolatedStorageScope Machine
public IsolatedStorageScope Application
}
public System.IO.MemoryStream : Stream {
private bool canWrite
private bool allowGetBuffer
private int capacity
private int length
private Byte[] internalBuffer
private int initialIndex
private bool expandable
private bool streamClosed
private int position
private int dirty_bytes
public bool CanRead
public bool CanSeek
public bool CanWrite
public int Capacity
public long Length
public long Position
public void .ctor(int capacity)
public void .ctor(Byte[] buffer)
public void .ctor(Byte[] buffer, bool writable)
public void .ctor(Byte[] buffer, int index, int count)
public void .ctor(Byte[] buffer, int index, int count, bool writable)
public void .ctor(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible)
private void InternalConstructor(Byte[] buffer, int index, int count, bool writable, bool publicallyVisible)
private void CheckIfClosedThrowDisposed()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public int get_Capacity()
public void set_Capacity(int value)
public long get_Length()
public long get_Position()
public void set_Position(long value)
protected void Dispose(bool disposing)
public void Flush()
public Byte[] GetBuffer()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin loc)
private int CalculateNewCapacity(int minimum)
private void Expand(int newSize)
public void SetLength(long value)
public Byte[] ToArray()
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public void WriteTo(Stream stream)
}
internal System.IO.MonoFileType : Enum {
public int value__
public MonoFileType Unknown
public MonoFileType Disk
public MonoFileType Char
public MonoFileType Pipe
public MonoFileType Remote
}
internal System.IO.MonoIO : object {
public FileAttributes InvalidFileAttributes
public IntPtr InvalidHandle
public IntPtr ConsoleOutput
public IntPtr ConsoleInput
public IntPtr ConsoleError
public char VolumeSeparatorChar
public char DirectorySeparatorChar
public char AltDirectorySeparatorChar
public char PathSeparator
public Exception GetException(MonoIOError error)
public Exception GetException(string path, MonoIOError error)
public bool CreateDirectory(string path, MonoIOError& error)
public bool RemoveDirectory(string path, MonoIOError& error)
public String[] GetFileSystemEntries(string path, string path_with_pattern, int attrs, int mask, MonoIOError& error)
public string GetCurrentDirectory(MonoIOError& error)
public bool SetCurrentDirectory(string path, MonoIOError& error)
public bool MoveFile(string path, string dest, MonoIOError& error)
public bool CopyFile(string path, string dest, bool overwrite, MonoIOError& error)
public bool DeleteFile(string path, MonoIOError& error)
public bool ReplaceFile(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors, MonoIOError& error)
public FileAttributes GetFileAttributes(string path, MonoIOError& error)
public bool SetFileAttributes(string path, FileAttributes attrs, MonoIOError& error)
public MonoFileType GetFileType(IntPtr handle, MonoIOError& error)
public bool Exists(string path, MonoIOError& error)
public bool ExistsFile(string path, MonoIOError& error)
public bool ExistsDirectory(string path, MonoIOError& error)
public bool ExistsSymlink(string path, MonoIOError& error)
public bool GetFileStat(string path, MonoIOStat& stat, MonoIOError& error)
public IntPtr Open(string filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, MonoIOError& error)
public bool Close(IntPtr handle, MonoIOError& error)
public int Read(IntPtr handle, Byte[] dest, int dest_offset, int count, MonoIOError& error)
public int Write(IntPtr handle, Byte[] src, int src_offset, int count, MonoIOError& error)
public long Seek(IntPtr handle, long offset, SeekOrigin origin, MonoIOError& error)
public bool Flush(IntPtr handle, MonoIOError& error)
public long GetLength(IntPtr handle, MonoIOError& error)
public bool SetLength(IntPtr handle, long length, MonoIOError& error)
public bool SetFileTime(IntPtr handle, long creation_time, long last_access_time, long last_write_time, MonoIOError& error)
public bool SetFileTime(string path, long creation_time, long last_access_time, long last_write_time, MonoIOError& error)
public bool SetCreationTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetLastAccessTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetLastWriteTime(string path, DateTime dateTime, MonoIOError& error)
public bool SetFileTime(string path, int type, long creation_time, long last_access_time, long last_write_time, DateTime dateTime, MonoIOError& error)
public void Lock(IntPtr handle, long position, long length, MonoIOError& error)
public void Unlock(IntPtr handle, long position, long length, MonoIOError& error)
public IntPtr get_ConsoleOutput()
public IntPtr get_ConsoleInput()
public IntPtr get_ConsoleError()
public bool CreatePipe(IntPtr& read_handle, IntPtr& write_handle)
public bool DuplicateHandle(IntPtr source_process_handle, IntPtr source_handle, IntPtr target_process_handle, IntPtr& target_handle, int access, int inherit, int options)
public char get_VolumeSeparatorChar()
public char get_DirectorySeparatorChar()
public char get_AltDirectorySeparatorChar()
public char get_PathSeparator()
public int GetTempPath(String& path)
public bool RemapPath(string path, String& newPath)
}
internal System.IO.MonoIOError : Enum {
public int value__
public MonoIOError ERROR_SUCCESS
public MonoIOError ERROR_FILE_NOT_FOUND
public MonoIOError ERROR_PATH_NOT_FOUND
public MonoIOError ERROR_TOO_MANY_OPEN_FILES
public MonoIOError ERROR_ACCESS_DENIED
public MonoIOError ERROR_INVALID_HANDLE
public MonoIOError ERROR_INVALID_DRIVE
public MonoIOError ERROR_NOT_SAME_DEVICE
public MonoIOError ERROR_NO_MORE_FILES
public MonoIOError ERROR_WRITE_FAULT
public MonoIOError ERROR_READ_FAULT
public MonoIOError ERROR_GEN_FAILURE
public MonoIOError ERROR_SHARING_VIOLATION
public MonoIOError ERROR_LOCK_VIOLATION
public MonoIOError ERROR_HANDLE_DISK_FULL
public MonoIOError ERROR_FILE_EXISTS
public MonoIOError ERROR_CANNOT_MAKE
public MonoIOError ERROR_INVALID_PARAMETER
public MonoIOError ERROR_BROKEN_PIPE
public MonoIOError ERROR_INVALID_NAME
public MonoIOError ERROR_DIR_NOT_EMPTY
public MonoIOError ERROR_ALREADY_EXISTS
public MonoIOError ERROR_FILENAME_EXCED_RANGE
public MonoIOError ERROR_ENCRYPTION_FAILED
}
internal System.IO.MonoIOStat : ValueType {
public string Name
public FileAttributes Attributes
public long Length
public long CreationTime
public long LastAccessTime
public long LastWriteTime
}
internal System.IO.NullStream : Stream {
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
}
public System.IO.Path : object {
public Char[] InvalidPathChars
public char AltDirectorySeparatorChar
public char DirectorySeparatorChar
public char PathSeparator
internal string DirectorySeparatorStr
public char VolumeSeparatorChar
internal Char[] PathSeparatorChars
private bool dirEqualsVolume
public string ChangeExtension(string path, string extension)
public string Combine(string path1, string path2)
internal string CleanPath(string s)
public string GetDirectoryName(string path)
public string GetExtension(string path)
public string GetFileName(string path)
public string GetFileNameWithoutExtension(string path)
public string GetFullPath(string path)
internal string WindowsDriveAdjustment(string path)
internal string InsecureGetFullPath(string path)
private bool IsDsc(char c)
public string GetPathRoot(string path)
public string GetTempFileName()
public string GetTempPath()
private string get_temp_path()
public bool HasExtension(string path)
public bool IsPathRooted(string path)
public Char[] GetInvalidFileNameChars()
public Char[] GetInvalidPathChars()
public string GetRandomFileName()
private int findExtension(string path)
private string GetServerAndShare(string path)
private bool SameRoot(string root, string path)
private string CanonicalizePath(string path)
internal bool IsPathSubsetOf(string subset, string path)
}
public System.IO.PathTooLongException : IOException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.IO.SearchOption : Enum {
public int value__
public SearchOption TopDirectoryOnly
public SearchOption AllDirectories
}
internal System.IO.SearchPattern : object {
private Op ops
private bool ignore
internal Char[] WildcardChars
internal Char[] InvalidChars
public void .ctor(string pattern)
public void .ctor(string pattern, bool ignore)
public bool IsMatch(string text)
private void Compile(string pattern)
private bool Match(Op op, string text, int ptr)
}
public System.IO.SeekOrigin : Enum {
public int value__
public SeekOrigin Begin
public SeekOrigin Current
public SeekOrigin End
}
public System.IO.Stream : MarshalByRefObject {
public Stream Null
public bool CanRead
public bool CanSeek
public bool CanWrite
public bool CanTimeout
public long Length
public long Position
public int ReadTimeout
public int WriteTimeout
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public bool get_CanTimeout()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Dispose()
protected void Dispose(bool disposing)
public void Close()
public int get_ReadTimeout()
public void set_ReadTimeout(int value)
public int get_WriteTimeout()
public void set_WriteTimeout(int value)
public Stream Synchronized(Stream stream)
protected WaitHandle CreateWaitHandle()
public void Flush()
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
public IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state)
public int EndRead(IAsyncResult asyncResult)
public void EndWrite(IAsyncResult asyncResult)
}
internal System.IO.StreamAsyncResult : object {
private object state
private bool completed
private bool done
private Exception exc
private int nbytes
private ManualResetEvent wh
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public Exception Exception
public int NBytes
public bool Done
public void .ctor(object state)
public void SetComplete(Exception e)
public void SetComplete(Exception e, int nbytes)
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
public Exception get_Exception()
public int get_NBytes()
public bool get_Done()
public void set_Done(bool value)
}
public System.IO.StreamReader : TextReader {
private int DefaultBufferSize
private int DefaultFileBufferSize
private int MinimumBufferSize
private Byte[] input_buffer
private Char[] decoded_buffer
private int decoded_count
private int pos
private int buffer_size
private int do_checks
private Encoding encoding
private Decoder decoder
private Stream base_stream
private bool mayBlock
private StringBuilder line_builder
public StreamReader Null
private bool foundCR
public Stream BaseStream
public Encoding CurrentEncoding
public bool EndOfStream
public void .ctor(Stream stream)
public void .ctor(Stream stream, bool detectEncodingFromByteOrderMarks)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks)
public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
public void .ctor(string path)
public void .ctor(string path, bool detectEncodingFromByteOrderMarks)
public void .ctor(string path, Encoding encoding)
public void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks)
public void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
internal void Initialize(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize)
public Stream get_BaseStream()
public Encoding get_CurrentEncoding()
public bool get_EndOfStream()
public void Close()
protected void Dispose(bool disposing)
private int DoChecks(int count)
public void DiscardBufferedData()
private int ReadBuffer()
public int Peek()
internal bool DataAvailable()
public int Read()
public int Read(Char[] buffer, int index, int count)
private int FindNextEOL()
public string ReadLine()
public string ReadToEnd()
}
public System.IO.StreamWriter : TextWriter {
private int DefaultBufferSize
private int DefaultFileBufferSize
private int MinimumBufferSize
private Encoding internalEncoding
private Stream internalStream
private bool iflush
private Byte[] byte_buf
private int byte_pos
private Char[] decode_buf
private int decode_pos
private bool DisposedAlready
private bool preamble_done
public StreamWriter Null
public bool AutoFlush
public Stream BaseStream
public Encoding Encoding
public void .ctor(Stream stream)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, int bufferSize)
public void .ctor(string path)
public void .ctor(string path, bool append)
public void .ctor(string path, bool append, Encoding encoding)
public void .ctor(string path, bool append, Encoding encoding, int bufferSize)
internal void Initialize(Encoding encoding, int bufferSize)
public bool get_AutoFlush()
public void set_AutoFlush(bool value)
public Stream get_BaseStream()
public Encoding get_Encoding()
protected void Dispose(bool disposing)
public void Flush()
private void FlushBytes()
private void Decode()
public void Write(Char[] buffer, int index, int count)
private void LowLevelWrite(Char[] buffer, int index, int count)
private void LowLevelWrite(string s)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(string value)
public void Close()
protected void Finalize()
}
public System.IO.StringReader : TextReader {
private string source
private int nextChar
private int sourceLength
public void .ctor(string s)
public void Close()
protected void Dispose(bool disposing)
public int Peek()
public int Read()
public int Read(Char[] buffer, int index, int count)
public string ReadLine()
public string ReadToEnd()
private void CheckObjectDisposedException()
}
public System.IO.StringWriter : TextWriter {
private StringBuilder internalString
private bool disposed
public Encoding Encoding
public void .ctor(IFormatProvider formatProvider)
public void .ctor(StringBuilder sb)
public void .ctor(StringBuilder sb, IFormatProvider formatProvider)
public Encoding get_Encoding()
public void Close()
protected void Dispose(bool disposing)
public StringBuilder GetStringBuilder()
public string ToString()
public void Write(char value)
public void Write(string value)
public void Write(Char[] buffer, int index, int count)
}
internal System.IO.SynchronizedReader : TextReader {
private TextReader reader
public void .ctor(TextReader reader)
public void Close()
public int Peek()
public int ReadBlock(Char[] buffer, int index, int count)
public string ReadLine()
public string ReadToEnd()
public int Read()
public int Read(Char[] buffer, int index, int count)
}
internal System.IO.SynchronizedWriter : TextWriter {
private TextWriter writer
private bool neverClose
public Encoding Encoding
public IFormatProvider FormatProvider
public string NewLine
public void .ctor(TextWriter writer)
public void .ctor(TextWriter writer, bool neverClose)
public void Close()
public void Flush()
public void Write(bool value)
public void Write(char value)
public void Write(Char[] value)
public void Write(decimal value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(float value)
public void Write(string value)
public void Write(UInt32 value)
public void Write(ulong value)
public void Write(string format, object value)
public void Write(string format, Object[] value)
public void Write(Char[] buffer, int index, int count)
public void Write(string format, object arg0, object arg1)
public void Write(string format, object arg0, object arg1, object arg2)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] value)
public void WriteLine(decimal value)
public void WriteLine(double value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(float value)
public void WriteLine(string value)
public void WriteLine(UInt32 value)
public void WriteLine(ulong value)
public void WriteLine(string format, object value)
public void WriteLine(string format, Object[] value)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, object arg0, object arg1, object arg2)
public Encoding get_Encoding()
public IFormatProvider get_FormatProvider()
public string get_NewLine()
public void set_NewLine(string value)
}
public System.IO.TextReader : MarshalByRefObject {
public TextReader Null
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public int Peek()
public int Read()
public int Read(Char[] buffer, int index, int count)
public int ReadBlock(Char[] buffer, int index, int count)
public string ReadLine()
public string ReadToEnd()
public TextReader Synchronized(TextReader reader)
}
public System.IO.TextWriter : MarshalByRefObject {
protected Char[] CoreNewLine
internal IFormatProvider internalFormatProvider
public TextWriter Null
public Encoding Encoding
public IFormatProvider FormatProvider
public string NewLine
protected void .ctor(IFormatProvider formatProvider)
public Encoding get_Encoding()
public IFormatProvider get_FormatProvider()
public string get_NewLine()
public void set_NewLine(string value)
public void Close()
protected void Dispose(bool disposing)
public void Dispose()
public void Flush()
public TextWriter Synchronized(TextWriter writer)
internal TextWriter Synchronized(TextWriter writer, bool neverClose)
public void Write(bool value)
public void Write(char value)
public void Write(Char[] buffer)
public void Write(decimal value)
public void Write(double value)
public void Write(int value)
public void Write(long value)
public void Write(object value)
public void Write(float value)
public void Write(string value)
public void Write(UInt32 value)
public void Write(ulong value)
public void Write(string format, object arg0)
public void Write(string format, Object[] arg)
public void Write(Char[] buffer, int index, int count)
public void Write(string format, object arg0, object arg1)
public void Write(string format, object arg0, object arg1, object arg2)
public void WriteLine()
public void WriteLine(bool value)
public void WriteLine(char value)
public void WriteLine(Char[] buffer)
public void WriteLine(decimal value)
public void WriteLine(double value)
public void WriteLine(int value)
public void WriteLine(long value)
public void WriteLine(object value)
public void WriteLine(float value)
public void WriteLine(string value)
public void WriteLine(UInt32 value)
public void WriteLine(ulong value)
public void WriteLine(string format, object arg0)
public void WriteLine(string format, Object[] arg)
public void WriteLine(Char[] buffer, int index, int count)
public void WriteLine(string format, object arg0, object arg1)
public void WriteLine(string format, object arg0, object arg1, object arg2)
}
internal System.IO.UnexceptionalStreamReader : StreamReader {
private Boolean[] newline
private char newlineChar
public void .ctor(Stream stream)
public void .ctor(Stream stream, bool detect_encoding_from_bytemarks)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, bool detect_encoding_from_bytemarks)
public void .ctor(Stream stream, Encoding encoding, bool detect_encoding_from_bytemarks, int buffer_size)
public void .ctor(string path)
public void .ctor(string path, bool detect_encoding_from_bytemarks)
public void .ctor(string path, Encoding encoding)
public void .ctor(string path, Encoding encoding, bool detect_encoding_from_bytemarks)
public void .ctor(string path, Encoding encoding, bool detect_encoding_from_bytemarks, int buffer_size)
public int Peek()
public int Read()
public int Read(Char[] dest_buffer, int index, int count)
private bool CheckEOL(char current)
public string ReadLine()
public string ReadToEnd()
}
internal System.IO.UnexceptionalStreamWriter : StreamWriter {
public void .ctor(Stream stream)
public void .ctor(Stream stream, Encoding encoding)
public void .ctor(Stream stream, Encoding encoding, int bufferSize)
public void .ctor(string path)
public void .ctor(string path, bool append)
public void .ctor(string path, bool append, Encoding encoding)
public void .ctor(string path, bool append, Encoding encoding, int bufferSize)
public void Flush()
public void Write(Char[] buffer, int index, int count)
public void Write(char value)
public void Write(Char[] value)
public void Write(string value)
}
public System.IO.UnmanagedMemoryStream : Stream {
private long length
private bool closed
private long capacity
private FileAccess fileaccess
private IntPtr initial_pointer
private long initial_position
private long current_position
private EventHandler Closed
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Capacity
public long Length
public long Position
public Byte* PositionPointer
public void .ctor(Byte* pointer, long length)
public void .ctor(Byte* pointer, long length, long capacity, FileAccess access)
internal void add_Closed(EventHandler value)
internal void remove_Closed(EventHandler value)
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Capacity()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public Byte* get_PositionPointer()
public void set_PositionPointer(Byte* value)
public int Read(Byte[] buffer, int offset, int count)
public int ReadByte()
public long Seek(long offset, SeekOrigin loc)
public void SetLength(long value)
public void Flush()
protected void Dispose(bool disposing)
public void Write(Byte[] buffer, int offset, int count)
public void WriteByte(byte value)
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access)
}
public System.IServiceProvider {
public object GetService(Type serviceType)
}
internal System.KnownTerminals : object {
public Byte[] linux
public Byte[] xterm
public Byte[] ansi
public Byte[] get_linux()
public Byte[] get_xterm()
public Byte[] get_ansi()
}
public System.LoaderOptimization : Enum {
public int value__
public LoaderOptimization NotSpecified
public LoaderOptimization SingleDomain
public LoaderOptimization MultiDomain
public LoaderOptimization MultiDomainHost
public LoaderOptimization DomainMask
public LoaderOptimization DisallowBindings
}
public System.LoaderOptimizationAttribute : Attribute {
private LoaderOptimization lo
public LoaderOptimization Value
public void .ctor(byte value)
public void .ctor(LoaderOptimization value)
public LoaderOptimization get_Value()
}
public System.LocalDataStoreSlot : object {
internal int slot
internal bool thread_local
private object lock_obj
private Boolean[] slot_bitmap_thread
private Boolean[] slot_bitmap_context
internal void .ctor(bool in_thread)
protected void Finalize()
}
public System.MarshalByRefObject : object {
private ServerIdentity _identity
internal ServerIdentity ObjectIdentity
internal Identity GetObjectIdentity(MarshalByRefObject obj, Boolean& IsClient)
internal ServerIdentity get_ObjectIdentity()
internal void set_ObjectIdentity(ServerIdentity value)
public ObjRef CreateObjRef(Type requestedType)
public object GetLifetimeService()
public object InitializeLifetimeService()
protected MarshalByRefObject MemberwiseClone(bool cloneIdentity)
}
public System.Math : object {
public double E
public double PI
public decimal Abs(decimal value)
public double Abs(double value)
public float Abs(float value)
public int Abs(int value)
public long Abs(long value)
public sbyte Abs(sbyte value)
public short Abs(short value)
public decimal Ceiling(decimal d)
public double Ceiling(double a)
public long BigMul(int a, int b)
public int DivRem(int a, int b, Int32& result)
public long DivRem(long a, long b, Int64& result)
public double Floor(double d)
public double IEEERemainder(double x, double y)
public double Log(double a, double newBase)
public byte Max(byte val1, byte val2)
public decimal Max(decimal val1, decimal val2)
public double Max(double val1, double val2)
public float Max(float val1, float val2)
public int Max(int val1, int val2)
public long Max(long val1, long val2)
public sbyte Max(sbyte val1, sbyte val2)
public short Max(short val1, short val2)
public UInt32 Max(UInt32 val1, UInt32 val2)
public ulong Max(ulong val1, ulong val2)
public ushort Max(ushort val1, ushort val2)
public byte Min(byte val1, byte val2)
public decimal Min(decimal val1, decimal val2)
public double Min(double val1, double val2)
public float Min(float val1, float val2)
public int Min(int val1, int val2)
public long Min(long val1, long val2)
public sbyte Min(sbyte val1, sbyte val2)
public short Min(short val1, short val2)
public UInt32 Min(UInt32 val1, UInt32 val2)
public ulong Min(ulong val1, ulong val2)
public ushort Min(ushort val1, ushort val2)
public decimal Round(decimal d)
public decimal Round(decimal d, int decimals)
public decimal Round(decimal d, MidpointRounding mode)
private decimal RoundAwayFromZero(decimal d)
public decimal Round(decimal d, int decimals, MidpointRounding mode)
public double Round(double a)
public double Round(double value, int digits)
private double Round2(double value, int digits, bool away_from_zero)
public double Round(double value, MidpointRounding mode)
public double Round(double value, int digits, MidpointRounding mode)
public double Truncate(double d)
public decimal Truncate(decimal d)
public decimal Floor(decimal d)
public int Sign(decimal value)
public int Sign(double value)
public int Sign(float value)
public int Sign(int value)
public int Sign(long value)
public int Sign(sbyte value)
public int Sign(short value)
public double Sin(double a)
public double Cos(double d)
public double Tan(double a)
public double Sinh(double value)
public double Cosh(double value)
public double Tanh(double value)
public double Acos(double d)
public double Asin(double d)
public double Atan(double d)
public double Atan2(double y, double x)
public double Exp(double d)
public double Log(double d)
public double Log10(double d)
public double Pow(double x, double y)
public double Sqrt(double d)
}
public System.MemberAccessException : SystemException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.MethodAccessException : MemberAccessException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.MidpointRounding : Enum {
public int value__
public MidpointRounding ToEven
public MidpointRounding AwayFromZero
}
public System.MissingFieldException : MissingMemberException {
private int Result
public string Message
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string className, string fieldName)
public string get_Message()
}
public System.MissingMemberException : MemberAccessException {
private int Result
protected string ClassName
protected string MemberName
protected Byte[] Signature
public string Message
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string className, string memberName)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string get_Message()
}
public System.MissingMethodException : MissingMemberException {
private int Result
public string Message
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string className, string methodName)
public string get_Message()
}
public System.ModuleHandle : ValueType {
private IntPtr value
public ModuleHandle EmptyHandle
internal IntPtr Value
public int MDStreamVersion
internal void .ctor(IntPtr v)
internal IntPtr get_Value()
public int get_MDStreamVersion()
internal void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine)
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken)
public RuntimeMethodHandle ResolveMethodHandle(int methodToken)
public RuntimeTypeHandle ResolveTypeHandle(int typeToken)
private IntPtr[] ptrs_from_handles(RuntimeTypeHandle[] handles)
public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)
public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken)
public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken)
public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken)
public bool Equals(object obj)
public bool Equals(ModuleHandle handle)
public int GetHashCode()
public bool op_Equality(ModuleHandle left, ModuleHandle right)
public bool op_Inequality(ModuleHandle left, ModuleHandle right)
}
internal System.MonoAsyncCall : object {
private object msg
private IntPtr cb_method
private object cb_target
private object state
private object res
private object out_args
private long wait_event
}
internal System.MonoCustomAttrs : object {
private Assembly corlib
private Type AttributeUsageType
private AttributeUsageAttribute DefaultAttributeUsage
private bool IsUserCattrProvider(object obj)
internal Object[] GetCustomAttributesInternal(ICustomAttributeProvider obj, Type attributeType, bool pseudoAttrs)
internal Object[] GetPseudoCustomAttributes(ICustomAttributeProvider obj, Type attributeType)
internal Object[] GetCustomAttributesBase(ICustomAttributeProvider obj, Type attributeType)
internal Attribute GetCustomAttribute(ICustomAttributeProvider obj, Type attributeType, bool inherit)
internal Object[] GetCustomAttributes(ICustomAttributeProvider obj, Type attributeType, bool inherit)
internal Object[] GetCustomAttributes(ICustomAttributeProvider obj, bool inherit)
private CustomAttributeData[] GetCustomAttributesDataInternal(ICustomAttributeProvider obj)
internal IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj)
internal bool IsDefined(ICustomAttributeProvider obj, Type attributeType, bool inherit)
internal bool IsDefinedInternal(ICustomAttributeProvider obj, Type AttributeType)
private PropertyInfo GetBasePropertyDefinition(PropertyInfo property)
private ICustomAttributeProvider GetBase(ICustomAttributeProvider obj)
private AttributeUsageAttribute RetrieveAttributeUsage(Type attributeType)
}
internal System.MonoDocumentationNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoEnumInfo : ValueType {
internal Type utype
internal Array values
internal String[] names
internal Hashtable name_hash
private Hashtable cache
private Hashtable global_cache
private object global_cache_monitor
internal SByteComparer sbyte_comparer
internal ShortComparer short_comparer
internal IntComparer int_comparer
internal LongComparer long_comparer
private Hashtable Cache
private void .ctor(MonoEnumInfo other)
private void get_enum_info(Type enumType, MonoEnumInfo& info)
private Hashtable get_Cache()
internal void GetInfo(Type enumType, MonoEnumInfo& info)
}
internal System.MonoExtensionAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoInternalNoteAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoLimitationAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoListItem : object {
private MonoListItem next
private object data
}
internal System.MonoNotSupportedAttribute : MonoTODOAttribute {
public void .ctor(string comment)
}
internal System.MonoTODOAttribute : Attribute {
private string comment
public string Comment
public void .ctor(string comment)
public string get_Comment()
}
internal System.MonoType : Type {
private MonoTypeInfo type_info
public Type UnderlyingSystemType
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public string FullName
public Guid GUID
public MemberTypes MemberType
public string Name
public string Namespace
public Module Module
public Type DeclaringType
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public bool ContainsGenericParameters
public bool IsGenericParameter
public MethodBase DeclaringMethod
internal void .ctor(object obj)
private void type_from_obj(MonoType type, object obj)
private TypeAttributes get_attributes(Type type)
internal ConstructorInfo GetDefaultConstructor()
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
internal ConstructorInfo[] GetConstructors_internal(BindingFlags bindingAttr, Type reflected_type)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
private EventInfo InternalGetEvent(string name, BindingFlags bindingAttr)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
internal EventInfo[] GetEvents_internal(BindingFlags bindingAttr, Type reflected_type)
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
internal FieldInfo[] GetFields_internal(BindingFlags bindingAttr, Type reflected_type)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
internal MethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, Type reflected_type)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
private MethodInfo GetCorrespondingInflatedMethod(MethodInfo generic)
private ConstructorInfo GetCorrespondingInflatedConstructor(ConstructorInfo generic)
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
internal PropertyInfo[] GetPropertiesByName(string name, BindingFlags bindingAttr, bool icase, Type reflected_type)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
public bool IsSubclassOf(Type type)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Type GetElementType()
public Type get_UnderlyingSystemType()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
private string getFullName(bool full_name, bool assembly_qualified)
public Type get_BaseType()
public string get_FullName()
public Guid get_GUID()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MemberTypes get_MemberType()
public string get_Name()
public string get_Namespace()
public Module get_Module()
public Type get_DeclaringType()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public int GetArrayRank()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericParameter()
public MethodBase get_DeclaringMethod()
public Type GetGenericTypeDefinition()
private MethodBase CheckMethodSecurity(MethodBase mb)
private void ReorderParamArrayArguments(Object[]& args, MethodBase method)
}
internal System.MonoTypeInfo : object {
public string full_name
public ConstructorInfo default_ctor
}
public System.MulticastDelegate : Delegate {
private MulticastDelegate prev
private MulticastDelegate kpm_next
protected void .ctor(object target, string method)
protected void .ctor(Type target, string method)
public void GetObjectData(SerializationInfo info, StreamingContext context)
protected object DynamicInvokeImpl(Object[] args)
public bool Equals(object obj)
public int GetHashCode()
public Delegate[] GetInvocationList()
protected Delegate CombineImpl(Delegate follow)
private bool BaseEquals(MulticastDelegate value)
private MulticastDelegate KPM(MulticastDelegate needle, MulticastDelegate haystack, MulticastDelegate& tail)
protected Delegate RemoveImpl(Delegate value)
public bool op_Equality(MulticastDelegate d1, MulticastDelegate d2)
public bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2)
}
public System.MulticastNotSupportedException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.NotFiniteNumberException : ArithmeticException {
private int Result
private double offending_number
public double OffendingNumber
public void .ctor(double offendingNumber)
public void .ctor(string message)
public void .ctor(string message, double offendingNumber)
public void .ctor(string message, double offendingNumber, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
public double get_OffendingNumber()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.NotImplementedException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.NotSupportedException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Nullable : object {
public int Compare(Nullable`1<T> value1, Nullable`1<T> value2)
public bool Equals(Nullable`1<T> value1, Nullable`1<T> value2)
public Type GetUnderlyingType(Type nullableType)
}
public System.Nullable`1 : ValueType {
internal T value
internal bool has_value
public bool HasValue
public T Value
public void .ctor(T value)
public bool get_HasValue()
public T get_Value()
public bool Equals(object other)
private bool Equals(Nullable`1<T> other)
public int GetHashCode()
public T GetValueOrDefault()
public T GetValueOrDefault(T defaultValue)
public string ToString()
private object Box(Nullable`1<T> o)
private Nullable`1<T> Unbox(object o)
public Nullable`1<T> op_Implicit(T value)
public T op_Explicit(Nullable`1<T> value)
}
internal System.NullConsoleDriver : object {
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
}
public System.NullReferenceException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.NumberFormatter : object {
private int DefaultExpPrecision
private int HundredMillion
private long SeventeenDigitsThreshold
private ulong ULongDivHundredMillion
private ulong ULongModHundredMillion
private int DoubleBitsExponentShift
private int DoubleBitsExponentMask
private long DoubleBitsMantissaMask
private int DecimalBitsScaleMask
private int SingleDefPrecision
private int DoubleDefPrecision
private int Int8DefPrecision
private int UInt8DefPrecision
private int Int16DefPrecision
private int UInt16DefPrecision
private int Int32DefPrecision
private int UInt32DefPrecision
private int Int64DefPrecision
private int UInt64DefPrecision
private int DecimalDefPrecision
private int TenPowersListLength
private double MinRoundtripVal
private double MaxRoundtripVal
private UInt64* MantissaBitsTable
private Int32* TensExponentTable
private Char* DigitLowerTable
private Char* DigitUpperTable
private Int64* TenPowersList
private Int32* DecHexDigits
private Thread _thread
private NumberFormatInfo _nfi
private bool _NaN
private bool _infinity
private bool _isCustomFormat
private bool _specifierIsUpper
private bool _positive
private char _specifier
private int _precision
private int _defPrecision
private int _digitsLen
private int _offset
private int _decPointPos
private UInt32 _val1
private UInt32 _val2
private UInt32 _val3
private UInt32 _val4
private Char[] _cbuf
private int _ind
private NumberFormatter threadNumberFormatter
public CultureInfo CurrentCulture
private int IntegerDigits
private int DecimalDigits
private bool IsFloatingSource
private bool IsZero
private bool IsZeroInteger
public void .ctor(Thread current)
private void GetFormatterTables(UInt64*& MantissaBitsTable, Int32*& TensExponentTable, Char*& DigitLowerTable, Char*& DigitUpperTable, Int64*& TenPowersList, Int32*& DecHexDigits)
private long GetTenPowerOf(int i)
private void InitDecHexDigits(UInt32 value)
private void InitDecHexDigits(ulong value)
private void InitDecHexDigits(UInt32 hi, ulong lo)
private UInt32 FastToDecHex(int val)
private UInt32 ToDecHex(int val)
private int FastDecHexLen(int val)
private int DecHexLen(UInt32 val)
private int DecHexLen()
private int ScaleOrder(long hi)
private int InitialFloatingPrecision()
private int ParsePrecision(string format)
private void Init(string format)
private void InitHex(ulong value)
private void Init(string format, int value, int defPrecision)
private void Init(string format, UInt32 value, int defPrecision)
private void Init(string format, long value)
private void Init(string format, ulong value)
private void Init(string format, double value, int defPrecision)
private void Init(string format, decimal value)
private void ResetCharBuf(int size)
private void Resize(int len)
private void Append(char c)
private void Append(char c, int cnt)
private void Append(string s)
private NumberFormatInfo GetNumberFormatInstance(IFormatProvider fp)
public void set_CurrentCulture(CultureInfo value)
private int get_IntegerDigits()
private int get_DecimalDigits()
private bool get_IsFloatingSource()
private bool get_IsZero()
private bool get_IsZeroInteger()
private void RoundPos(int pos)
private bool RoundDecimal(int decimals)
private bool RoundBits(int shift)
private void RemoveTrailingZeros()
private void AddOneToDecHex()
private UInt32 AddOneToDecHex(UInt32 val)
private int CountTrailingZeros()
private int CountTrailingZeros(UInt32 val)
private NumberFormatter GetInstance()
private void Release()
internal void SetThreadCurrentCulture(CultureInfo culture)
public string NumberToString(string format, sbyte value, IFormatProvider fp)
public string NumberToString(string format, byte value, IFormatProvider fp)
public string NumberToString(string format, ushort value, IFormatProvider fp)
public string NumberToString(string format, short value, IFormatProvider fp)
public string NumberToString(string format, UInt32 value, IFormatProvider fp)
public string NumberToString(string format, int value, IFormatProvider fp)
public string NumberToString(string format, ulong value, IFormatProvider fp)
public string NumberToString(string format, long value, IFormatProvider fp)
public string NumberToString(string format, float value, IFormatProvider fp)
public string NumberToString(string format, double value, IFormatProvider fp)
public string NumberToString(string format, decimal value, IFormatProvider fp)
public string NumberToString(UInt32 value, IFormatProvider fp)
public string NumberToString(int value, IFormatProvider fp)
public string NumberToString(ulong value, IFormatProvider fp)
public string NumberToString(long value, IFormatProvider fp)
public string NumberToString(float value, IFormatProvider fp)
public string NumberToString(double value, IFormatProvider fp)
private string FastIntegerToString(int value, IFormatProvider fp)
private string IntegerToString(string format, IFormatProvider fp)
private string NumberToString(string format, NumberFormatInfo nfi)
public string FormatCurrency(int precision, NumberFormatInfo nfi)
private string FormatDecimal(int precision, NumberFormatInfo nfi)
private string FormatHexadecimal(int precision)
public string FormatFixedPoint(int precision, NumberFormatInfo nfi)
private string FormatRoundtrip(double origval, NumberFormatInfo nfi)
private string FormatRoundtrip(float origval, NumberFormatInfo nfi)
private string FormatGeneral(int precision, NumberFormatInfo nfi)
public string FormatNumber(int precision, NumberFormatInfo nfi)
public string FormatPercent(int precision, NumberFormatInfo nfi)
public string FormatExponential(int precision, NumberFormatInfo nfi)
private string FormatExponential(int precision, NumberFormatInfo nfi, int expDigits)
public string FormatCustom(string format, NumberFormatInfo nfi)
private void ZeroTrimEnd(StringBuilder sb, bool canEmpty)
private bool IsZeroOnly(StringBuilder sb)
private void AppendNonNegativeNumber(StringBuilder sb, int v)
private void AppendIntegerString(int minLength, StringBuilder sb)
private void AppendIntegerString(int minLength)
private void AppendDecimalString(int precision, StringBuilder sb)
private void AppendDecimalString(int precision)
private void AppendIntegerStringWithGroupSeparator(Int32[] groups, string groupSeparator)
private void AppendExponent(NumberFormatInfo nfi, int exponent, int minDigits)
private void AppendOneDigit(int start)
private void FastAppendDigits(int val, bool force)
private void AppendDigits(int start, int end)
private void AppendDigits(int start, int end, StringBuilder sb)
private void Multiply10(int count)
private void Divide10(int count)
private NumberFormatter GetClone()
}
public System.Object {
public bool Equals(object obj)
public bool Equals(object objA, object objB)
protected void Finalize()
public int GetHashCode()
public Type GetType()
protected object MemberwiseClone()
public string ToString()
public bool ReferenceEquals(object objA, object objB)
internal int InternalGetHashCode(object o)
internal IntPtr obj_address()
private void FieldGetter(string typeName, string fieldName, Object& val)
private void FieldSetter(string typeName, string fieldName, object val)
}
public System.ObjectDisposedException : InvalidOperationException {
private string obj_name
private string msg
public string Message
public string ObjectName
public void .ctor(string objectName)
public void .ctor(string objectName, string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
public string get_ObjectName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.ObsoleteAttribute : Attribute {
private string _message
private bool _error
public string Message
public bool IsError
public void .ctor(string message)
public void .ctor(string message, bool error)
public string get_Message()
public bool get_IsError()
}
public System.OperatingSystem : object {
private PlatformID _platform
private Version _version
private string _servicePack
public PlatformID Platform
public Version Version
public string ServicePack
public string VersionString
public void .ctor(PlatformID platform, Version version)
public PlatformID get_Platform()
public Version get_Version()
public string get_ServicePack()
public string get_VersionString()
public object Clone()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.OperationCanceledException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.OrdinalComparer : StringComparer {
private bool _ignoreCase
public void .ctor(bool ignoreCase)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string s)
}
public System.OutOfMemoryException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.OverflowException : ArithmeticException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.PlatformID : Enum {
public int value__
public PlatformID Win32S
public PlatformID Win32Windows
public PlatformID Win32NT
public PlatformID WinCE
public PlatformID Unix
public PlatformID Xbox
public PlatformID MacOSX
}
public System.PlatformNotSupportedException : NotSupportedException {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.Predicate`1 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(T obj)
public IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Random : object {
private int MBIG
private int MSEED
private int MZ
private int inext
private int inextp
private Int32[] SeedArray
public void .ctor(int Seed)
protected double Sample()
public int Next()
public int Next(int maxValue)
public int Next(int minValue, int maxValue)
public void NextBytes(Byte[] buffer)
public double NextDouble()
}
public System.RankException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.AmbiguousMatchException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.Assembly : object {
private IntPtr _mono_assembly
private ResolveEventHolder resolve_event_holder
private Evidence _evidence
internal PermissionSet _minimum
internal PermissionSet _optional
internal PermissionSet _refuse
private PermissionSet _granted
private PermissionSet _denied
private bool fromByteArray
private string assemblyName
public string CodeBase
public string EscapedCodeBase
public string FullName
public MethodInfo EntryPoint
public Evidence Evidence
public bool GlobalAssemblyCache
internal bool FromByteArray
public string Location
public string ImageRuntimeVersion
public long HostContext
public Module ManifestModule
public bool ReflectionOnly
internal PermissionSet GrantedPermissionSet
internal PermissionSet DeniedPermissionSet
public void add_ModuleResolve(ModuleResolveEventHandler value)
public void remove_ModuleResolve(ModuleResolveEventHandler value)
private string get_code_base(bool escaped)
private string get_fullname()
private string get_location()
private string InternalImageRuntimeVersion()
private string GetCodeBase(bool escaped)
public string get_CodeBase()
public string get_EscapedCodeBase()
public string get_FullName()
public MethodInfo get_EntryPoint()
public Evidence get_Evidence()
internal Evidence UnprotectedGetEvidence()
private bool get_global_assembly_cache()
public bool get_GlobalAssemblyCache()
internal void set_FromByteArray(bool value)
public string get_Location()
public string get_ImageRuntimeVersion()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
private object GetFilesInternal(string name, bool getResourceModules)
public FileStream[] GetFiles()
public FileStream[] GetFiles(bool getResourceModules)
public FileStream GetFile(string name)
internal IntPtr GetManifestResourceInternal(string name, Int32& size, Module& module)
public Stream GetManifestResourceStream(string name)
public Stream GetManifestResourceStream(Type type, string name)
internal Type[] GetTypes(bool exportedOnly)
public Type[] GetTypes()
public Type[] GetExportedTypes()
public Type GetType(string name, bool throwOnError)
public Type GetType(string name)
internal Type InternalGetType(Module module, string name, bool throwOnError, bool ignoreCase)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
internal void InternalGetAssemblyName(string assemblyFile, AssemblyName aname)
private void FillName(Assembly ass, AssemblyName aname)
public AssemblyName GetName(bool copiedName)
public AssemblyName GetName()
internal AssemblyName UnprotectedGetName()
public string ToString()
public string CreateQualifiedName(string assemblyName, string typeName)
public Assembly GetAssembly(Type type)
public Assembly GetEntryAssembly()
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
internal Assembly GetSatelliteAssemblyNoThrow(CultureInfo culture, Version version)
private Assembly GetSatelliteAssembly(CultureInfo culture, Version version, bool throwOnError)
private Assembly LoadFrom(string assemblyFile, bool refonly)
public Assembly LoadFrom(string assemblyFile)
public Assembly LoadFrom(string assemblyFile, Evidence securityEvidence)
public Assembly LoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm)
public Assembly LoadFile(string path, Evidence securityEvidence)
public Assembly LoadFile(string path)
public Assembly Load(string assemblyString)
public Assembly Load(string assemblyString, Evidence assemblySecurity)
public Assembly Load(AssemblyName assemblyRef)
public Assembly Load(AssemblyName assemblyRef, Evidence assemblySecurity)
public Assembly Load(Byte[] rawAssembly)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore)
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore, Evidence securityEvidence)
public Assembly ReflectionOnlyLoad(Byte[] rawAssembly)
public Assembly ReflectionOnlyLoad(string assemblyString)
public Assembly ReflectionOnlyLoadFrom(string assemblyFile)
public Assembly LoadWithPartialName(string partialName)
public Module LoadModule(string moduleName, Byte[] rawModule)
public Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore)
private Assembly load_with_partial_name(string name, Evidence e)
public Assembly LoadWithPartialName(string partialName, Evidence securityEvidence)
internal Assembly LoadWithPartialName(string partialName, Evidence securityEvidence, bool oldBehavior)
public object CreateInstance(string typeName)
public object CreateInstance(string typeName, bool ignoreCase)
public object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public Module[] GetLoadedModules()
public Module[] GetLoadedModules(bool getResourceModules)
public Module[] GetModules()
public Module GetModule(string name)
internal Module[] GetModulesInternal()
public Module[] GetModules(bool getResourceModules)
internal String[] GetNamespaces()
public String[] GetManifestResourceNames()
public Assembly GetExecutingAssembly()
public Assembly GetCallingAssembly()
public AssemblyName[] GetReferencedAssemblies()
private bool GetManifestResourceInfoInternal(string name, ManifestResourceInfo info)
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
internal int MonoDebugger_GetMethodToken(MethodBase method)
public long get_HostContext()
public Module get_ManifestModule()
internal Module GetManifestModule()
internal Module GetManifestModuleInternal()
public bool get_ReflectionOnly()
internal void Resolve()
internal PermissionSet get_GrantedPermissionSet()
internal PermissionSet get_DeniedPermissionSet()
internal bool LoadPermissions(Assembly a, IntPtr& minimum, Int32& minLength, IntPtr& optional, Int32& optLength, IntPtr& refused, Int32& refLength)
private void LoadAssemblyPermissions()
unknown Type System.Runtime.InteropServices._Assembly.GetType()
}
public System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
private UInt32 id
public UInt32 AlgorithmId
public void .ctor(AssemblyHashAlgorithm algorithmId)
public void .ctor(UInt32 algorithmId)
public UInt32 get_AlgorithmId()
}
public System.Reflection.AssemblyCompanyAttribute : Attribute {
private string name
public string Company
public void .ctor(string company)
public string get_Company()
}
public System.Reflection.AssemblyConfigurationAttribute : Attribute {
private string name
public string Configuration
public void .ctor(string configuration)
public string get_Configuration()
}
public System.Reflection.AssemblyCopyrightAttribute : Attribute {
private string name
public string Copyright
public void .ctor(string copyright)
public string get_Copyright()
}
public System.Reflection.AssemblyCultureAttribute : Attribute {
private string name
public string Culture
public void .ctor(string culture)
public string get_Culture()
}
public System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
private string name
public string DefaultAlias
public void .ctor(string defaultAlias)
public string get_DefaultAlias()
}
public System.Reflection.AssemblyDelaySignAttribute : Attribute {
private bool delay
public bool DelaySign
public void .ctor(bool delaySign)
public bool get_DelaySign()
}
public System.Reflection.AssemblyDescriptionAttribute : Attribute {
private string name
public string Description
public void .ctor(string description)
public string get_Description()
}
public System.Reflection.AssemblyFileVersionAttribute : Attribute {
private string name
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Reflection.AssemblyFlagsAttribute : Attribute {
private UInt32 flags
public UInt32 Flags
public int AssemblyFlags
public void .ctor(UInt32 flags)
public void .ctor(int assemblyFlags)
public void .ctor(AssemblyNameFlags assemblyFlags)
public UInt32 get_Flags()
public int get_AssemblyFlags()
}
public System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
private string name
public string InformationalVersion
public void .ctor(string informationalVersion)
public string get_InformationalVersion()
}
public System.Reflection.AssemblyKeyFileAttribute : Attribute {
private string name
public string KeyFile
public void .ctor(string keyFile)
public string get_KeyFile()
}
public System.Reflection.AssemblyKeyNameAttribute : Attribute {
private string name
public string KeyName
public void .ctor(string keyName)
public string get_KeyName()
}
public System.Reflection.AssemblyName : object {
private string name
private string codebase
private int major
private int minor
private int build
private int revision
private CultureInfo cultureinfo
private AssemblyNameFlags flags
private AssemblyHashAlgorithm hashalg
private StrongNameKeyPair keypair
private Byte[] publicKey
private Byte[] keyToken
private AssemblyVersionCompatibility versioncompat
private Version version
private ProcessorArchitecture processor_architecture
public ProcessorArchitecture ProcessorArchitecture
public string Name
public string CodeBase
public string EscapedCodeBase
public CultureInfo CultureInfo
public AssemblyNameFlags Flags
public string FullName
public AssemblyHashAlgorithm HashAlgorithm
public StrongNameKeyPair KeyPair
public Version Version
public AssemblyVersionCompatibility VersionCompatibility
private bool IsPublicKeyValid
public void .ctor(string assemblyName)
internal void .ctor(SerializationInfo si, StreamingContext sc)
private void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._AssemblyName.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private bool ParseName(AssemblyName aname, string assemblyName)
public ProcessorArchitecture get_ProcessorArchitecture()
public void set_ProcessorArchitecture(ProcessorArchitecture value)
public string get_Name()
public void set_Name(string value)
public string get_CodeBase()
public void set_CodeBase(string value)
public string get_EscapedCodeBase()
public CultureInfo get_CultureInfo()
public void set_CultureInfo(CultureInfo value)
public AssemblyNameFlags get_Flags()
public void set_Flags(AssemblyNameFlags value)
public string get_FullName()
public AssemblyHashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(AssemblyHashAlgorithm value)
public StrongNameKeyPair get_KeyPair()
public void set_KeyPair(StrongNameKeyPair value)
public Version get_Version()
public void set_Version(Version value)
public AssemblyVersionCompatibility get_VersionCompatibility()
public void set_VersionCompatibility(AssemblyVersionCompatibility value)
public string ToString()
public Byte[] GetPublicKey()
public Byte[] GetPublicKeyToken()
private bool get_IsPublicKeyValid()
private Byte[] InternalGetPublicKeyToken()
private Byte[] ComputePublicKeyToken()
public bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition)
public void SetPublicKey(Byte[] publicKey)
public void SetPublicKeyToken(Byte[] publicKeyToken)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object Clone()
public void OnDeserialization(object sender)
public AssemblyName GetAssemblyName(string assemblyFile)
}
public System.Reflection.AssemblyNameFlags : Enum {
public int value__
public AssemblyNameFlags None
public AssemblyNameFlags PublicKey
public AssemblyNameFlags Retargetable
public AssemblyNameFlags EnableJITcompileOptimizer
public AssemblyNameFlags EnableJITcompileTracking
}
public System.Reflection.AssemblyNameProxy : MarshalByRefObject {
public AssemblyName GetAssemblyName(string assemblyFile)
}
public System.Reflection.AssemblyProductAttribute : Attribute {
private string name
public string Product
public void .ctor(string product)
public string get_Product()
}
public System.Reflection.AssemblyTitleAttribute : Attribute {
private string name
public string Title
public void .ctor(string title)
public string get_Title()
}
public System.Reflection.AssemblyTrademarkAttribute : Attribute {
private string name
public string Trademark
public void .ctor(string trademark)
public string get_Trademark()
}
public System.Reflection.AssemblyVersionAttribute : Attribute {
private string name
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Reflection.Binder : object {
private Binder default_binder
internal Binder DefaultBinder
public FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture)
public MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state)
public object ChangeType(object value, Type type, CultureInfo culture)
public void ReorderArgumentArray(Object[]& args, object state)
public MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers)
internal Binder get_DefaultBinder()
internal bool ConvertArgs(Binder binder, Object[] args, ParameterInfo[] pinfo, CultureInfo culture)
internal int GetDerivedLevel(Type type)
internal MethodBase FindMostDerivedMatch(MethodBase[] match)
}
public System.Reflection.BindingFlags : Enum {
public int value__
public BindingFlags Default
public BindingFlags IgnoreCase
public BindingFlags DeclaredOnly
public BindingFlags Instance
public BindingFlags Static
public BindingFlags Public
public BindingFlags NonPublic
public BindingFlags FlattenHierarchy
public BindingFlags InvokeMethod
public BindingFlags CreateInstance
public BindingFlags GetField
public BindingFlags SetField
public BindingFlags GetProperty
public BindingFlags SetProperty
public BindingFlags PutDispProperty
public BindingFlags PutRefDispProperty
public BindingFlags ExactBinding
public BindingFlags SuppressChangeType
public BindingFlags OptionalParamBinding
public BindingFlags IgnoreReturn
}
public System.Reflection.CallingConventions : Enum {
public int value__
public CallingConventions Standard
public CallingConventions VarArgs
public CallingConventions Any
public CallingConventions HasThis
public CallingConventions ExplicitThis
}
public System.Reflection.ConstructorInfo : MethodBase {
public string ConstructorName
public string TypeConstructorName
public MemberTypes MemberType
private void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ConstructorInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, Object[] parameters)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
private object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(Object[] parameters)
public MemberTypes get_MemberType()
public object Invoke(Object[] parameters)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
unknown Type System.Runtime.InteropServices._ConstructorInfo.GetType()
}
public System.Reflection.CustomAttributeData : object {
private ConstructorInfo ctorInfo
private IList`1<CustomAttributeTypedArgument> ctorArgs
private IList`1<CustomAttributeNamedArgument> namedArgs
public ConstructorInfo Constructor
public IList`1<CustomAttributeTypedArgument> ConstructorArguments
public IList`1<CustomAttributeNamedArgument> NamedArguments
internal void .ctor(ConstructorInfo ctorInfo, Object[] ctorArgs, Object[] namedArgs)
public ConstructorInfo get_Constructor()
public IList`1<CustomAttributeTypedArgument> get_ConstructorArguments()
public IList`1<CustomAttributeNamedArgument> get_NamedArguments()
public IList`1<CustomAttributeData> GetCustomAttributes(Assembly target)
public IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target)
public IList`1<CustomAttributeData> GetCustomAttributes(Module target)
public IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target)
public string ToString()
private T[] UnboxValues(Object[] values)
public bool Equals(object obj)
public int GetHashCode()
}
public System.Reflection.CustomAttributeFormatException : FormatException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.CustomAttributeNamedArgument : ValueType {
private CustomAttributeTypedArgument typedArgument
private MemberInfo memberInfo
public MemberInfo MemberInfo
public CustomAttributeTypedArgument TypedValue
internal void .ctor(MemberInfo memberInfo, object typedArgument)
public MemberInfo get_MemberInfo()
public CustomAttributeTypedArgument get_TypedValue()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right)
public bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right)
}
public System.Reflection.CustomAttributeTypedArgument : ValueType {
private Type argumentType
private object value
public Type ArgumentType
public object Value
internal void .ctor(Type argumentType, object value)
public Type get_ArgumentType()
public object get_Value()
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
public bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right)
public bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right)
}
public System.Reflection.DefaultMemberAttribute : Attribute {
private string member_name
public string MemberName
public void .ctor(string memberName)
public string get_MemberName()
}
internal System.Reflection.Emit.ArrayType : DerivedType {
private int rank
public Type BaseType
internal void .ctor(Type elementType, int rank)
protected bool IsArrayImpl()
public int GetArrayRank()
public Type get_BaseType()
protected TypeAttributes GetAttributeFlagsImpl()
internal string FormatName(string elementName)
}
public System.Reflection.Emit.AssemblyBuilder : Assembly {
private AssemblyBuilderAccess COMPILER_ACCESS
private UIntPtr dynamic_assembly
private MethodInfo entry_point
private ModuleBuilder[] modules
private string name
private string dir
private CustomAttributeBuilder[] cattrs
private MonoResource[] resources
private Byte[] public_key
private string version
private string culture
private UInt32 algid
private UInt32 flags
private PEFileKinds pekind
private bool delay_sign
private UInt32 access
private Module[] loaded_modules
private MonoWin32Resource[] win32_resources
private RefEmitPermissionSet[] permissions_minimum
private RefEmitPermissionSet[] permissions_optional
private RefEmitPermissionSet[] permissions_refused
private PortableExecutableKinds peKind
private ImageFileMachine machine
private bool corlib_internal
private Type[] type_forwarders
private Byte[] pktoken
internal Type corlib_object_type
internal Type corlib_value_type
internal Type corlib_enum_type
internal Type corlib_void_type
private ArrayList resource_writers
private Win32VersionResource version_res
private bool created
private bool is_module_only
private StrongName sn
private NativeResourceType native_resource
private bool is_compiler_context
private string versioninfo_culture
private ModuleBuilder manifest_module
public string CodeBase
public MethodInfo EntryPoint
public string Location
public string ImageRuntimeVersion
public bool ReflectionOnly
internal bool IsCompilerContext
internal bool IsSave
internal bool IsRun
internal string AssemblyDir
internal bool IsModuleOnly
internal void .ctor(AssemblyName n, string directory, AssemblyBuilderAccess access, bool corlib_internal)
private void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._AssemblyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private void basic_init(AssemblyBuilder ab)
public string get_CodeBase()
public MethodInfo get_EntryPoint()
public string get_Location()
public string get_ImageRuntimeVersion()
public bool get_ReflectionOnly()
public void AddResourceFile(string name, string fileName)
public void AddResourceFile(string name, string fileName, ResourceAttributes attribute)
private void AddResourceFile(string name, string fileName, ResourceAttributes attribute, bool fileNeedsToExists)
internal void AddPermissionRequests(PermissionSet required, PermissionSet optional, PermissionSet refused)
internal void EmbedResourceFile(string name, string fileName)
internal void EmbedResourceFile(string name, string fileName, ResourceAttributes attribute)
internal void EmbedResource(string name, Byte[] blob, ResourceAttributes attribute)
internal void AddTypeForwarder(Type t)
public ModuleBuilder DefineDynamicModule(string name)
public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo)
public ModuleBuilder DefineDynamicModule(string name, string fileName)
public ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo)
private ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo, bool transient)
private Module InternalAddModule(string fileName)
internal Module AddModule(string fileName)
public IResourceWriter DefineResource(string name, string description, string fileName)
public IResourceWriter DefineResource(string name, string description, string fileName, ResourceAttributes attribute)
private void AddUnmanagedResource(Win32Resource res)
public void DefineUnmanagedResource(Byte[] resource)
public void DefineUnmanagedResource(string resourceFileName)
public void DefineVersionInfoResource()
public void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark)
internal void DefineIconResource(string iconFileName)
private void DefineVersionInfoResourceImpl(string fileName)
public ModuleBuilder GetDynamicModule(string name)
public Type[] GetExportedTypes()
public FileStream GetFile(string name)
public FileStream[] GetFiles(bool getResourceModules)
internal Module[] GetModulesInternal()
internal Type[] GetTypes(bool exportedOnly)
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
public String[] GetManifestResourceNames()
public Stream GetManifestResourceStream(string name)
public Stream GetManifestResourceStream(Type type, string name)
internal bool get_IsCompilerContext()
internal bool get_IsSave()
internal bool get_IsRun()
internal string get_AssemblyDir()
internal bool get_IsModuleOnly()
internal void set_IsModuleOnly(bool value)
internal Module GetManifestModule()
public void Save(string assemblyFileName, PortableExecutableKinds portableExecutableKind, ImageFileMachine imageFileMachine)
public void Save(string assemblyFileName)
public void SetEntryPoint(MethodInfo entryMethod)
public void SetEntryPoint(MethodInfo entryMethod, PEFileKinds fileKind)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
internal void SetCorlibTypeBuilders(Type corlib_object_type, Type corlib_value_type, Type corlib_enum_type)
internal void SetCorlibTypeBuilders(Type corlib_object_type, Type corlib_value_type, Type corlib_enum_type, Type corlib_void_type)
private Exception not_supported()
private void check_name_and_filename(string name, string fileName, bool fileNeedsToExists)
private string create_assembly_version(string version)
private string GetCultureString(string str)
internal AssemblyName UnprotectedGetName()
}
public System.Reflection.Emit.AssemblyBuilderAccess : Enum {
public int value__
public AssemblyBuilderAccess Run
public AssemblyBuilderAccess Save
public AssemblyBuilderAccess RunAndSave
public AssemblyBuilderAccess ReflectionOnly
}
internal System.Reflection.Emit.ByRefType : DerivedType {
public Type BaseType
internal void .ctor(Type elementType)
protected bool IsByRefImpl()
public Type get_BaseType()
internal string FormatName(string elementName)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
}
public System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
private RuntimeMethodHandle mhandle
private ILGenerator ilgen
internal Type[] parameters
private MethodAttributes attrs
private MethodImplAttributes iattrs
private int table_idx
private CallingConventions call_conv
private TypeBuilder type
internal ParameterBuilder[] pinfo
private CustomAttributeBuilder[] cattrs
private bool init_locals
private Type[][] paramModReq
private Type[][] paramModOpt
private RefEmitPermissionSet[] permissions
public CallingConventions CallingConvention
public bool InitLocals
internal TypeBuilder TypeBuilder
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public Type ReflectedType
public Type DeclaringType
public Type ReturnType
public string Name
public string Signature
public Module Module
private bool IsCompilerContext
internal void .ctor(TypeBuilder tb, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
private void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ConstructorBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public CallingConventions get_CallingConvention()
public bool get_InitLocals()
public void set_InitLocals(bool value)
internal TypeBuilder get_TypeBuilder()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal ParameterInfo[] GetParametersInternal()
internal int GetParameterCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public Type get_ReflectedType()
public Type get_DeclaringType()
public Type get_ReturnType()
public string get_Name()
public string get_Signature()
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int streamSize)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetImplementationFlags(MethodImplAttributes attributes)
public Module GetModule()
public MethodToken GetToken()
public void SetSymCustomAttribute(string name, Byte[] data)
public Module get_Module()
public string ToString()
internal void fixup()
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
internal int get_next_table_index(object obj, int table, bool inc)
private bool get_IsCompilerContext()
private void RejectIfCreated()
private Exception not_supported()
private Exception not_after_created()
private Exception not_created()
}
internal System.Reflection.Emit.ConstructorOnTypeBuilderInst : ConstructorInfo {
private MonoGenericClass instantiation
private ConstructorBuilder cb
public Type DeclaringType
public string Name
public Type ReflectedType
public int MetadataToken
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool ContainsGenericParameters
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public void .ctor(MonoGenericClass instantiation, ConstructorBuilder cb)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public int get_MetadataToken()
internal int GetParameterCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
}
public System.Reflection.Emit.CustomAttributeBuilder : object {
private ConstructorInfo ctor
private Byte[] data
private Dictionary`2<string, int> <>f__switch$map1E
internal ConstructorInfo Ctor
internal Byte[] Data
internal void .ctor(ConstructorInfo con, Byte[] cdata)
public void .ctor(ConstructorInfo con, Object[] constructorArgs)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues)
public void .ctor(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal ConstructorInfo get_Ctor()
internal Byte[] get_Data()
private Byte[] GetBlob(Assembly asmb, ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
private bool IsValidType(Type t)
private void Initialize(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues)
internal int decode_len(Byte[] data, int pos, Int32& rpos)
internal string string_from_bytes(Byte[] data, int pos, int len)
internal string string_arg()
internal UnmanagedMarshal get_umarshal(CustomAttributeBuilder customBuilder, bool is_field)
private Type elementTypeToType(int elementType)
private object decode_cattr_value(Type t, Byte[] data, int pos, Int32& rpos)
internal CustomAttributeInfo decode_cattr(CustomAttributeBuilder customBuilder)
private ParameterInfo[] GetParameters(ConstructorInfo ctor)
}
internal System.Reflection.Emit.DerivedType : Type {
internal Type elementType
public bool ContainsGenericParameters
public GenericParameterAttributes GenericParameterAttributes
public StructLayoutAttribute StructLayoutAttribute
public Assembly Assembly
public string AssemblyQualifiedName
public string FullName
public string Name
public Guid GUID
public Module Module
public string Namespace
public RuntimeTypeHandle TypeHandle
public Type UnderlyingSystemType
internal void .ctor(Type elementType)
internal void create_unmanaged_type(Type type)
internal string FormatName(string elementName)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected TypeAttributes GetAttributeFlagsImpl()
protected bool HasElementTypeImpl()
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public bool IsInstanceOfType(object o)
public bool IsAssignableFrom(Type c)
public bool get_ContainsGenericParameters()
public Type MakeGenericType(Type[] typeArguments)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
public string ToString()
public GenericParameterAttributes get_GenericParameterAttributes()
public StructLayoutAttribute get_StructLayoutAttribute()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public string get_FullName()
public string get_Name()
public Guid get_GUID()
public Module get_Module()
public string get_Namespace()
public RuntimeTypeHandle get_TypeHandle()
public Type get_UnderlyingSystemType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
public System.Reflection.Emit.DynamicILInfo : object {
public DynamicMethod DynamicMethod
public DynamicMethod get_DynamicMethod()
public int GetTokenFor(Byte[] signature)
public int GetTokenFor(DynamicMethod method)
public int GetTokenFor(RuntimeFieldHandle field)
public int GetTokenFor(RuntimeMethodHandle method)
public int GetTokenFor(RuntimeTypeHandle type)
public int GetTokenFor(string literal)
public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType)
public void SetCode(Byte[] code, int maxStackSize)
public void SetCode(Byte* code, int codeSize, int maxStackSize)
public void SetExceptions(Byte[] exceptions)
public void SetExceptions(Byte* exceptions, int exceptionsSize)
public void SetLocalSignature(Byte[] localSignature)
public void SetLocalSignature(Byte* localSignature, int signatureSize)
}
public System.Reflection.Emit.DynamicMethod : MethodInfo {
private RuntimeMethodHandle mhandle
private string name
private Type returnType
private Type[] parameters
private MethodAttributes attributes
private CallingConventions callingConvention
private Module module
private bool skipVisibility
private bool init_locals
private ILGenerator ilgen
private int nrefs
private Object[] refs
private IntPtr referenced_by
private Type owner
private Delegate deleg
private MonoMethod method
private ParameterBuilder[] pinfo
internal bool creating
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool InitLocals
public RuntimeMethodHandle MethodHandle
public Module Module
public string Name
public Type ReflectedType
public ParameterInfo ReturnParameter
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public void .ctor(string name, Type returnType, Type[] parameterTypes, Module m)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Type owner)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility)
public void .ctor(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility)
public void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility)
public void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility)
public void .ctor(string name, Type returnType, Type[] parameterTypes)
public void .ctor(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility)
private void .ctor(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, Module m, bool skipVisibility, bool anonHosted)
private void create_dynamic_method(DynamicMethod m)
private void destroy_dynamic_method(DynamicMethod m)
private void CreateDynMethod()
protected void Finalize()
public Delegate CreateDelegate(Type delegateType)
public Delegate CreateDelegate(Type delegateType, object target)
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName)
public MethodInfo GetBaseDefinition()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public DynamicILInfo GetDynamicILInfo()
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int streamSize)
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_InitLocals()
public void set_InitLocals(bool value)
public RuntimeMethodHandle get_MethodHandle()
public Module get_Module()
public string get_Name()
public Type get_ReflectedType()
public ParameterInfo get_ReturnParameter()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
private void RejectIfCreated()
internal int AddRef(object reference)
}
internal System.Reflection.Emit.DynamicMethodTokenGenerator : object {
private DynamicMethod m
public void .ctor(DynamicMethod m)
public int GetToken(string str)
public int GetToken(MethodInfo method, Type[] opt_param_types)
public int GetToken(MemberInfo member)
public int GetToken(SignatureHelper helper)
}
public System.Reflection.Emit.EnumBuilder : Type {
private TypeBuilder _tb
private FieldBuilder _underlyingField
private Type _underlyingType
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public Type DeclaringType
public string FullName
public Guid GUID
public Module Module
public string Name
public string Namespace
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public TypeToken TypeToken
public FieldBuilder UnderlyingField
public Type UnderlyingSystemType
internal void .ctor(ModuleBuilder mb, string name, TypeAttributes visibility, Type underlyingType)
private void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EnumBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal TypeBuilder GetTypeBuilder()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public Type get_DeclaringType()
public string get_FullName()
public Guid get_GUID()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public TypeToken get_TypeToken()
public FieldBuilder get_UnderlyingField()
public Type get_UnderlyingSystemType()
public Type CreateType()
private void setup_enum_type(Type t)
public FieldBuilder DefineLiteral(string literalName, object literalValue)
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public bool IsDefined(Type attributeType, bool inherit)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private Exception CreateNotSupportedException()
}
public System.Reflection.Emit.EventBuilder : object {
internal string name
private Type type
private TypeBuilder typeb
private CustomAttributeBuilder[] cattrs
internal MethodBuilder add_method
internal MethodBuilder remove_method
internal MethodBuilder raise_method
internal MethodBuilder[] other_methods
internal EventAttributes attrs
private int table_idx
internal void .ctor(TypeBuilder tb, string eventName, EventAttributes eventAttrs, Type eventType)
private void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EventBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
internal int get_next_table_index(object obj, int table, bool inc)
public void AddOtherMethod(MethodBuilder mdBuilder)
public EventToken GetEventToken()
public void SetAddOnMethod(MethodBuilder mdBuilder)
public void SetRaiseMethod(MethodBuilder mdBuilder)
public void SetRemoveOnMethod(MethodBuilder mdBuilder)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private void RejectIfCreated()
}
internal System.Reflection.Emit.EventOnTypeBuilderInst : EventInfo {
private MonoGenericClass instantiation
private EventBuilder evt
public EventAttributes Attributes
public Type DeclaringType
public string Name
public Type ReflectedType
internal void .ctor(MonoGenericClass instantiation, EventBuilder evt)
public EventAttributes get_Attributes()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
public System.Reflection.Emit.EventToken : ValueType {
internal int tokValue
public EventToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(EventToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(EventToken a, EventToken b)
public bool op_Inequality(EventToken a, EventToken b)
}
public System.Reflection.Emit.FieldBuilder : FieldInfo {
private FieldAttributes attrs
private Type type
private string name
private object def_value
private int offset
private int table_idx
internal TypeBuilder typeb
private Byte[] rva_data
private CustomAttributeBuilder[] cattrs
private UnmanagedMarshal marshal_info
private RuntimeFieldHandle handle
private Type[] modReq
private Type[] modOpt
public FieldAttributes Attributes
public Type DeclaringType
public RuntimeFieldHandle FieldHandle
public Type FieldType
public string Name
public Type ReflectedType
internal UnmanagedMarshal UMarshal
public Module Module
internal void .ctor(TypeBuilder tb, string fieldName, Type type, FieldAttributes attributes, Type[] modReq, Type[] modOpt)
private void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._FieldBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public FieldAttributes get_Attributes()
public Type get_DeclaringType()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public string get_Name()
public Type get_ReflectedType()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public FieldToken GetToken()
public object GetValue(object obj)
public bool IsDefined(Type attributeType, bool inherit)
internal int GetFieldOffset()
internal void SetRVAData(Byte[] data)
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
public void SetOffset(int iOffset)
public void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal UnmanagedMarshal get_UMarshal()
private Exception CreateNotSupportedException()
private void RejectIfCreated()
public Module get_Module()
}
internal System.Reflection.Emit.FieldOnTypeBuilderInst : FieldInfo {
internal MonoGenericClass instantiation
internal FieldBuilder fb
public Type DeclaringType
public string Name
public Type ReflectedType
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public int MetadataToken
public Type FieldType
public void .ctor(MonoGenericClass instantiation, FieldBuilder fb)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
public int get_MetadataToken()
public Type get_FieldType()
public object GetValue(object obj)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
}
public System.Reflection.Emit.FieldToken : ValueType {
internal int tokValue
public FieldToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(FieldToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(FieldToken a, FieldToken b)
public bool op_Inequality(FieldToken a, FieldToken b)
}
public System.Reflection.Emit.FlowControl : Enum {
public int value__
public FlowControl Branch
public FlowControl Break
public FlowControl Call
public FlowControl Cond_Branch
public FlowControl Meta
public FlowControl Next
public FlowControl Phi
public FlowControl Return
public FlowControl Throw
}
public System.Reflection.Emit.GenericTypeParameterBuilder : Type {
private TypeBuilder tbuilder
private MethodBuilder mbuilder
private string name
private int index
private Type base_type
private Type[] iface_constraints
private CustomAttributeBuilder[] cattrs
private GenericParameterAttributes attrs
public Type UnderlyingSystemType
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public string FullName
public Guid GUID
public string Name
public string Namespace
public Module Module
public Type DeclaringType
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public bool ContainsGenericParameters
public bool IsGenericParameter
public bool IsGenericType
public bool IsGenericTypeDefinition
public GenericParameterAttributes GenericParameterAttributes
public int GenericParameterPosition
public MethodBase DeclaringMethod
internal void .ctor(TypeBuilder tbuilder, MethodBuilder mbuilder, string name, int index)
public void SetBaseTypeConstraint(Type baseTypeConstraint)
public void SetInterfaceConstraints(Type[] interfaceConstraints)
public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes)
private void initialize()
public bool IsSubclassOf(Type c)
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public bool IsAssignableFrom(Type c)
public bool IsInstanceOfType(object o)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public Type GetElementType()
public Type get_UnderlyingSystemType()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public string get_FullName()
public Guid get_GUID()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public string get_Name()
public string get_Namespace()
public Module get_Module()
public Type get_DeclaringType()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public Type[] GetGenericArguments()
public Type GetGenericTypeDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericParameter()
public bool get_IsGenericType()
public bool get_IsGenericTypeDefinition()
public GenericParameterAttributes get_GenericParameterAttributes()
public int get_GenericParameterPosition()
public Type[] GetGenericParameterConstraints()
public MethodBase get_DeclaringMethod()
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
private Exception not_supported()
public string ToString()
public bool Equals(object o)
public int GetHashCode()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakeGenericType(Type[] typeArguments)
public Type MakePointerType()
}
internal System.Reflection.Emit.ILExceptionBlock : ValueType {
public int CATCH
public int FILTER
public int FINALLY
public int FAULT
public int FILTER_START
internal Type extype
internal int type
internal int start
internal int len
internal int filter_offset
internal void Debug()
}
internal System.Reflection.Emit.ILExceptionInfo : ValueType {
private ILExceptionBlock[] handlers
internal int start
private int len
internal Label end
internal int NumHandlers()
internal void AddCatch(Type extype, int offset)
internal void AddFinally(int offset)
internal void AddFault(int offset)
internal void AddFilter(int offset)
internal void End(int offset)
internal int LastClauseType()
internal void PatchFilterClause(int start)
internal void Debug(int b)
private void add_block(int offset)
}
public System.Reflection.Emit.ILGenerator : object {
private int defaultFixupSize
private int defaultLabelsSize
private int defaultExceptionStackSize
private Type void_type
private Byte[] code
private int code_len
private int max_stack
private int cur_stack
private LocalBuilder[] locals
private ILExceptionInfo[] ex_handlers
private int num_token_fixups
private ILTokenInfo[] token_fixups
private LabelData[] labels
private int num_labels
private LabelFixup[] fixups
private int num_fixups
internal Module module
private int cur_block
private Stack open_blocks
private TokenGenerator token_gen
private ArrayList sequencePointLists
private SequencePointList currentSequence
internal bool HasDebugInfo
internal void .ctor(Module m, TokenGenerator token_gen, int size)
private void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ILGenerator.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private void add_token_fixup(MemberInfo mi)
private void make_room(int nbytes)
private void emit_int(int val)
private void ll_emit(OpCode opcode)
private int target_len(OpCode opcode)
private void InternalEndClause()
public void BeginCatchBlock(Type exceptionType)
public void BeginExceptFilterBlock()
public Label BeginExceptionBlock()
public void BeginFaultBlock()
public void BeginFinallyBlock()
public void BeginScope()
public LocalBuilder DeclareLocal(Type localType)
public LocalBuilder DeclareLocal(Type localType, bool pinned)
public Label DefineLabel()
public void Emit(OpCode opcode)
public void Emit(OpCode opcode, byte arg)
public void Emit(OpCode opcode, ConstructorInfo con)
public void Emit(OpCode opcode, double arg)
public void Emit(OpCode opcode, FieldInfo field)
public void Emit(OpCode opcode, short arg)
public void Emit(OpCode opcode, int arg)
public void Emit(OpCode opcode, long arg)
public void Emit(OpCode opcode, Label label)
public void Emit(OpCode opcode, Label[] labels)
public void Emit(OpCode opcode, LocalBuilder local)
public void Emit(OpCode opcode, MethodInfo meth)
private void Emit(OpCode opcode, MethodInfo method, int token)
public void Emit(OpCode opcode, sbyte arg)
public void Emit(OpCode opcode, SignatureHelper signature)
public void Emit(OpCode opcode, float arg)
public void Emit(OpCode opcode, string str)
public void Emit(OpCode opcode, Type cls)
public void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
public void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
public void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
public void EmitWriteLine(FieldInfo fld)
public void EmitWriteLine(LocalBuilder localBuilder)
public void EmitWriteLine(string value)
public void EndExceptionBlock()
public void EndScope()
public void MarkLabel(Label loc)
public void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn)
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
internal bool get_HasDebugInfo()
public void ThrowException(Type excType)
public void UsingNamespace(string usingNamespace)
internal void label_fixup()
internal int Mono_GetCurrentOffset(ILGenerator ig)
}
internal System.Reflection.Emit.ILTokenInfo : ValueType {
public MemberInfo member
public int code_pos
}
public System.Reflection.Emit.Label : ValueType {
internal int label
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(Label obj)
public int GetHashCode()
public bool op_Equality(Label a, Label b)
public bool op_Inequality(Label a, Label b)
}
public System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
private string name
internal ILGenerator ilgen
private int startOffset
private int endOffset
public Type LocalType
public bool IsPinned
public int LocalIndex
internal string Name
internal int StartOffset
internal int EndOffset
internal void .ctor(Type t, ILGenerator ilgen)
private void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._LocalBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public void SetLocalSymInfo(string name, int startOffset, int endOffset)
public void SetLocalSymInfo(string name)
public Type get_LocalType()
public bool get_IsPinned()
public int get_LocalIndex()
internal int Mono_GetLocalIndex(LocalBuilder builder)
internal string get_Name()
internal int get_StartOffset()
internal int get_EndOffset()
}
public System.Reflection.Emit.MethodBuilder : MethodInfo {
private RuntimeMethodHandle mhandle
private Type rtype
internal Type[] parameters
private MethodAttributes attrs
private MethodImplAttributes iattrs
private string name
private int table_idx
private Byte[] code
private ILGenerator ilgen
private TypeBuilder type
internal ParameterBuilder[] pinfo
private CustomAttributeBuilder[] cattrs
private MethodInfo override_method
private string pi_dll
private string pi_entry
private CharSet charset
private UInt32 extra_flags
private CallingConvention native_cc
private CallingConventions call_conv
private bool init_locals
private IntPtr generic_container
internal GenericTypeParameterBuilder[] generic_params
private Type[] returnModReq
private Type[] returnModOpt
private Type[][] paramModReq
private Type[][] paramModOpt
private RefEmitPermissionSet[] permissions
private Dictionary`2<string, int> <>f__switch$map1F
public bool ContainsGenericParameters
public bool InitLocals
internal TypeBuilder TypeBuilder
public RuntimeMethodHandle MethodHandle
public Type ReturnType
public Type ReflectedType
public Type DeclaringType
public string Name
public MethodAttributes Attributes
public ICustomAttributeProvider ReturnTypeCustomAttributes
public CallingConventions CallingConvention
public string Signature
internal bool BestFitMapping
internal bool ThrowOnUnmappableChar
internal bool ExactSpelling
internal bool SetLastError
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public Module Module
internal void .ctor(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
internal void .ctor(TypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt, string dllName, string entryName, CallingConvention nativeCConv, CharSet nativeCharset)
private void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public bool get_ContainsGenericParameters()
public bool get_InitLocals()
public void set_InitLocals(bool value)
internal TypeBuilder get_TypeBuilder()
public RuntimeMethodHandle get_MethodHandle()
public Type get_ReturnType()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public MethodAttributes get_Attributes()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public CallingConventions get_CallingConvention()
public string get_Signature()
internal void set_BestFitMapping(bool value)
internal void set_ThrowOnUnmappableChar(bool value)
internal void set_ExactSpelling(bool value)
internal void set_SetLastError(bool value)
public MethodToken GetToken()
public MethodInfo GetBaseDefinition()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal int GetParameterCount()
public Module GetModule()
public void CreateMethodBody(Byte[] il, int count)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public ILGenerator GetILGenerator()
public ILGenerator GetILGenerator(int size)
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName)
internal void check_override()
internal void fixup()
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetImplementationFlags(MethodImplAttributes attributes)
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
public void SetSymCustomAttribute(string name, Byte[] data)
public string ToString()
public bool Equals(object obj)
public int GetHashCode()
internal int get_next_table_index(object obj, int table, bool inc)
internal void set_override(MethodInfo mdecl)
private void RejectIfCreated()
private Exception NotSupported()
public MethodInfo MakeGenericMethod(Type[] typeArguments)
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public MethodInfo GetGenericMethodDefinition()
public Type[] GetGenericArguments()
public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names)
public void SetReturnType(Type returnType)
public void SetParameters(Type[] parameterTypes)
public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public Module get_Module()
}
internal System.Reflection.Emit.MethodOnTypeBuilderInst : MethodInfo {
private MonoGenericClass instantiation
internal MethodBuilder mb
private Type[] method_arguments
private MethodOnTypeBuilderInst generic_method_definition
public Type DeclaringType
public string Name
public Type ReflectedType
public Type ReturnType
public int MetadataToken
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool ContainsGenericParameters
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public ICustomAttributeProvider ReturnTypeCustomAttributes
public void .ctor(MonoGenericClass instantiation, MethodBuilder mb)
internal void .ctor(MethodOnTypeBuilderInst gmd, Type[] typeArguments)
public Type get_DeclaringType()
public string get_Name()
public Type get_ReflectedType()
public Type get_ReturnType()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public int get_MetadataToken()
internal int GetParameterCount()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public MethodInfo MakeGenericMethod(Type[] typeArguments)
public Type[] GetGenericArguments()
public MethodInfo GetGenericMethodDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public MethodInfo GetBaseDefinition()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
}
public System.Reflection.Emit.MethodRental : object {
public int JitImmediate
public int JitOnDemand
private void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodRental.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodRental.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public void SwapMethodBody(Type cls, int methodtoken, IntPtr rgIL, int methodSize, int flags)
}
public System.Reflection.Emit.MethodToken : ValueType {
internal int tokValue
public MethodToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(MethodToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(MethodToken a, MethodToken b)
public bool op_Inequality(MethodToken a, MethodToken b)
}
public System.Reflection.Emit.ModuleBuilder : Module {
private UIntPtr dynamic_image
private int num_types
private TypeBuilder[] types
private CustomAttributeBuilder[] cattrs
private Byte[] guid
private int table_idx
internal AssemblyBuilder assemblyb
private MethodBuilder[] global_methods
private FieldBuilder[] global_fields
private bool is_main
private MonoResource[] resources
private TypeBuilder global_type
private Type global_type_created
private Hashtable name_cache
private Hashtable us_string_cache
private Int32[] table_indexes
private bool transient
private ModuleBuilderTokenGenerator token_gen
private Hashtable resource_writers
private ISymbolWriter symbolWriter
private Char[] type_modifiers
public string FullyQualifiedName
internal string FileName
internal bool IsMain
internal void .ctor(AssemblyBuilder assb, string name, string fullyqname, bool emitSymbolInfo, bool transient)
private void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ModuleBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private void basic_init(ModuleBuilder ab)
private void set_wrappers_type(ModuleBuilder mb, Type ab)
public string get_FullyQualifiedName()
public bool IsTransient()
public void CreateGlobalFunctions()
public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes)
public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes)
private void addGlobalMethod(MethodBuilder mb)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public TypeBuilder DefineType(string name)
public TypeBuilder DefineType(string name, TypeAttributes attr)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent)
private void AddType(TypeBuilder tb)
private TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize)
internal void RegisterTypeName(TypeBuilder tb, string name)
internal TypeBuilder GetRegisteredType(string name)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize)
public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize)
public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType)
public Type GetType(string className)
public Type GetType(string className, bool ignoreCase)
private TypeBuilder search_in_array(TypeBuilder[] arr, int validElementsInArray, string className)
private TypeBuilder search_nested_in_array(TypeBuilder[] arr, int validElementsInArray, string className)
private Type create_modified_type(TypeBuilder tb, string modifiers)
private TypeBuilder GetMaybeNested(TypeBuilder t, string className)
public Type GetType(string className, bool throwOnError, bool ignoreCase)
internal int get_next_table_index(object obj, int table, bool inc)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public ISymbolWriter GetSymWriter()
public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
public Type[] GetTypes()
public IResourceWriter DefineResource(string name, string description, ResourceAttributes attribute)
public IResourceWriter DefineResource(string name, string description)
public void DefineUnmanagedResource(Byte[] resource)
public void DefineUnmanagedResource(string resourceFileName)
public void DefineManifestResource(string name, Stream stream, ResourceAttributes attribute)
public void SetSymCustomAttribute(string name, Byte[] data)
public void SetUserEntryPoint(MethodInfo entryPoint)
public MethodToken GetMethodToken(MethodInfo method)
public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodToken GetConstructorToken(ConstructorInfo con)
public FieldToken GetFieldToken(FieldInfo field)
public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength)
public SignatureToken GetSignatureToken(SignatureHelper sigHelper)
public StringToken GetStringConstant(string str)
public TypeToken GetTypeToken(Type type)
public TypeToken GetTypeToken(string name)
private int getUSIndex(ModuleBuilder mb, string str)
private int getToken(ModuleBuilder mb, object obj)
private int getMethodToken(ModuleBuilder mb, MethodInfo method, Type[] opt_param_types)
internal int GetToken(string str)
internal int GetToken(MemberInfo member)
internal int GetToken(MethodInfo method, Type[] opt_param_types)
internal int GetToken(SignatureHelper helper)
internal void RegisterToken(object obj, int token)
internal TokenGenerator GetTokenGenerator()
private void build_metadata(ModuleBuilder mb)
private void WriteToFile(IntPtr handle)
internal void Save()
internal string get_FileName()
internal void set_IsMain(bool value)
internal void CreateGlobalType()
internal Guid GetModuleVersionId()
internal Guid Mono_GetGuid(ModuleBuilder mb)
}
internal System.Reflection.Emit.ModuleBuilderTokenGenerator : object {
private ModuleBuilder mb
public void .ctor(ModuleBuilder mb)
public int GetToken(string str)
public int GetToken(MemberInfo member)
public int GetToken(MethodInfo method, Type[] opt_param_types)
public int GetToken(SignatureHelper helper)
}
internal System.Reflection.Emit.MonoResource : ValueType {
public Byte[] data
public string name
public string filename
public ResourceAttributes attrs
public int offset
public Stream stream
}
internal System.Reflection.Emit.MonoWin32Resource : ValueType {
public int res_type
public int res_id
public int lang_id
public Byte[] data
public void .ctor(int res_type, int res_id, int lang_id, Byte[] data)
}
internal System.Reflection.Emit.NativeResourceType : Enum {
public int value__
public NativeResourceType None
public NativeResourceType Unmanaged
public NativeResourceType Assembly
public NativeResourceType Explicit
}
public System.Reflection.Emit.OpCode : ValueType {
internal byte op1
internal byte op2
private byte push
private byte pop
private byte size
private byte type
private byte args
private byte flow
public string Name
public int Size
public OpCodeType OpCodeType
public OperandType OperandType
public FlowControl FlowControl
public StackBehaviour StackBehaviourPop
public StackBehaviour StackBehaviourPush
public short Value
internal void .ctor(int p, int q)
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(OpCode obj)
public string ToString()
public string get_Name()
public int get_Size()
public OpCodeType get_OpCodeType()
public OperandType get_OperandType()
public FlowControl get_FlowControl()
public StackBehaviour get_StackBehaviourPop()
public StackBehaviour get_StackBehaviourPush()
public short get_Value()
public bool op_Equality(OpCode a, OpCode b)
public bool op_Inequality(OpCode a, OpCode b)
}
internal System.Reflection.Emit.OpCodeNames : object {
internal String[] names
}
public System.Reflection.Emit.OpCodes : object {
public OpCode Nop
public OpCode Break
public OpCode Ldarg_0
public OpCode Ldarg_1
public OpCode Ldarg_2
public OpCode Ldarg_3
public OpCode Ldloc_0
public OpCode Ldloc_1
public OpCode Ldloc_2
public OpCode Ldloc_3
public OpCode Stloc_0
public OpCode Stloc_1
public OpCode Stloc_2
public OpCode Stloc_3
public OpCode Ldarg_S
public OpCode Ldarga_S
public OpCode Starg_S
public OpCode Ldloc_S
public OpCode Ldloca_S
public OpCode Stloc_S
public OpCode Ldnull
public OpCode Ldc_I4_M1
public OpCode Ldc_I4_0
public OpCode Ldc_I4_1
public OpCode Ldc_I4_2
public OpCode Ldc_I4_3
public OpCode Ldc_I4_4
public OpCode Ldc_I4_5
public OpCode Ldc_I4_6
public OpCode Ldc_I4_7
public OpCode Ldc_I4_8
public OpCode Ldc_I4_S
public OpCode Ldc_I4
public OpCode Ldc_I8
public OpCode Ldc_R4
public OpCode Ldc_R8
public OpCode Dup
public OpCode Pop
public OpCode Jmp
public OpCode Call
public OpCode Calli
public OpCode Ret
public OpCode Br_S
public OpCode Brfalse_S
public OpCode Brtrue_S
public OpCode Beq_S
public OpCode Bge_S
public OpCode Bgt_S
public OpCode Ble_S
public OpCode Blt_S
public OpCode Bne_Un_S
public OpCode Bge_Un_S
public OpCode Bgt_Un_S
public OpCode Ble_Un_S
public OpCode Blt_Un_S
public OpCode Br
public OpCode Brfalse
public OpCode Brtrue
public OpCode Beq
public OpCode Bge
public OpCode Bgt
public OpCode Ble
public OpCode Blt
public OpCode Bne_Un
public OpCode Bge_Un
public OpCode Bgt_Un
public OpCode Ble_Un
public OpCode Blt_Un
public OpCode Switch
public OpCode Ldind_I1
public OpCode Ldind_U1
public OpCode Ldind_I2
public OpCode Ldind_U2
public OpCode Ldind_I4
public OpCode Ldind_U4
public OpCode Ldind_I8
public OpCode Ldind_I
public OpCode Ldind_R4
public OpCode Ldind_R8
public OpCode Ldind_Ref
public OpCode Stind_Ref
public OpCode Stind_I1
public OpCode Stind_I2
public OpCode Stind_I4
public OpCode Stind_I8
public OpCode Stind_R4
public OpCode Stind_R8
public OpCode Add
public OpCode Sub
public OpCode Mul
public OpCode Div
public OpCode Div_Un
public OpCode Rem
public OpCode Rem_Un
public OpCode And
public OpCode Or
public OpCode Xor
public OpCode Shl
public OpCode Shr
public OpCode Shr_Un
public OpCode Neg
public OpCode Not
public OpCode Conv_I1
public OpCode Conv_I2
public OpCode Conv_I4
public OpCode Conv_I8
public OpCode Conv_R4
public OpCode Conv_R8
public OpCode Conv_U4
public OpCode Conv_U8
public OpCode Callvirt
public OpCode Cpobj
public OpCode Ldobj
public OpCode Ldstr
public OpCode Newobj
public OpCode Castclass
public OpCode Isinst
public OpCode Conv_R_Un
public OpCode Unbox
public OpCode Throw
public OpCode Ldfld
public OpCode Ldflda
public OpCode Stfld
public OpCode Ldsfld
public OpCode Ldsflda
public OpCode Stsfld
public OpCode Stobj
public OpCode Conv_Ovf_I1_Un
public OpCode Conv_Ovf_I2_Un
public OpCode Conv_Ovf_I4_Un
public OpCode Conv_Ovf_I8_Un
public OpCode Conv_Ovf_U1_Un
public OpCode Conv_Ovf_U2_Un
public OpCode Conv_Ovf_U4_Un
public OpCode Conv_Ovf_U8_Un
public OpCode Conv_Ovf_I_Un
public OpCode Conv_Ovf_U_Un
public OpCode Box
public OpCode Newarr
public OpCode Ldlen
public OpCode Ldelema
public OpCode Ldelem_I1
public OpCode Ldelem_U1
public OpCode Ldelem_I2
public OpCode Ldelem_U2
public OpCode Ldelem_I4
public OpCode Ldelem_U4
public OpCode Ldelem_I8
public OpCode Ldelem_I
public OpCode Ldelem_R4
public OpCode Ldelem_R8
public OpCode Ldelem_Ref
public OpCode Stelem_I
public OpCode Stelem_I1
public OpCode Stelem_I2
public OpCode Stelem_I4
public OpCode Stelem_I8
public OpCode Stelem_R4
public OpCode Stelem_R8
public OpCode Stelem_Ref
public OpCode Ldelem
public OpCode Stelem
public OpCode Unbox_Any
public OpCode Conv_Ovf_I1
public OpCode Conv_Ovf_U1
public OpCode Conv_Ovf_I2
public OpCode Conv_Ovf_U2
public OpCode Conv_Ovf_I4
public OpCode Conv_Ovf_U4
public OpCode Conv_Ovf_I8
public OpCode Conv_Ovf_U8
public OpCode Refanyval
public OpCode Ckfinite
public OpCode Mkrefany
public OpCode Ldtoken
public OpCode Conv_U2
public OpCode Conv_U1
public OpCode Conv_I
public OpCode Conv_Ovf_I
public OpCode Conv_Ovf_U
public OpCode Add_Ovf
public OpCode Add_Ovf_Un
public OpCode Mul_Ovf
public OpCode Mul_Ovf_Un
public OpCode Sub_Ovf
public OpCode Sub_Ovf_Un
public OpCode Endfinally
public OpCode Leave
public OpCode Leave_S
public OpCode Stind_I
public OpCode Conv_U
public OpCode Prefix7
public OpCode Prefix6
public OpCode Prefix5
public OpCode Prefix4
public OpCode Prefix3
public OpCode Prefix2
public OpCode Prefix1
public OpCode Prefixref
public OpCode Arglist
public OpCode Ceq
public OpCode Cgt
public OpCode Cgt_Un
public OpCode Clt
public OpCode Clt_Un
public OpCode Ldftn
public OpCode Ldvirtftn
public OpCode Ldarg
public OpCode Ldarga
public OpCode Starg
public OpCode Ldloc
public OpCode Ldloca
public OpCode Stloc
public OpCode Localloc
public OpCode Endfilter
public OpCode Unaligned
public OpCode Volatile
public OpCode Tailcall
public OpCode Initobj
public OpCode Constrained
public OpCode Cpblk
public OpCode Initblk
public OpCode Rethrow
public OpCode Sizeof
public OpCode Refanytype
public OpCode Readonly
public bool TakesSingleByteArgument(OpCode inst)
}
public System.Reflection.Emit.OpCodeType : Enum {
public int value__
public OpCodeType Annotation
public OpCodeType Macro
public OpCodeType Nternal
public OpCodeType Objmodel
public OpCodeType Prefix
public OpCodeType Primitive
}
public System.Reflection.Emit.OperandType : Enum {
public int value__
public OperandType InlineBrTarget
public OperandType InlineField
public OperandType InlineI
public OperandType InlineI8
public OperandType InlineMethod
public OperandType InlineNone
public OperandType InlinePhi
public OperandType InlineR
public OperandType InlineSig
public OperandType InlineString
public OperandType InlineSwitch
public OperandType InlineTok
public OperandType InlineType
public OperandType InlineVar
public OperandType ShortInlineBrTarget
public OperandType ShortInlineI
public OperandType ShortInlineR
public OperandType ShortInlineVar
}
public System.Reflection.Emit.PackingSize : Enum {
public int value__
public PackingSize Unspecified
public PackingSize Size1
public PackingSize Size2
public PackingSize Size4
public PackingSize Size8
public PackingSize Size16
public PackingSize Size32
public PackingSize Size64
public PackingSize Size128
}
public System.Reflection.Emit.ParameterBuilder : object {
private MethodBase methodb
private string name
private CustomAttributeBuilder[] cattrs
private UnmanagedMarshal marshal_info
private ParameterAttributes attrs
private int position
private int table_idx
private object def_value
public int Attributes
public bool IsIn
public bool IsOut
public bool IsOptional
public string Name
public int Position
internal void .ctor(MethodBase mb, int pos, ParameterAttributes attributes, string strParamName)
private void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ParameterBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public int get_Attributes()
public bool get_IsIn()
public bool get_IsOut()
public bool get_IsOptional()
public string get_Name()
public int get_Position()
public ParameterToken GetToken()
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetMarshal(UnmanagedMarshal unmanagedMarshal)
}
public System.Reflection.Emit.ParameterToken : ValueType {
internal int tokValue
public ParameterToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(ParameterToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(ParameterToken a, ParameterToken b)
public bool op_Inequality(ParameterToken a, ParameterToken b)
}
public System.Reflection.Emit.PEFileKinds : Enum {
public int value__
public PEFileKinds Dll
public PEFileKinds ConsoleApplication
public PEFileKinds WindowApplication
}
internal System.Reflection.Emit.PointerType : DerivedType {
public Type BaseType
internal void .ctor(Type elementType)
protected bool IsPointerImpl()
public Type get_BaseType()
internal string FormatName(string elementName)
}
public System.Reflection.Emit.PropertyBuilder : PropertyInfo {
private PropertyAttributes attrs
private string name
private Type type
private Type[] parameters
private CustomAttributeBuilder[] cattrs
private object def_value
private MethodBuilder set_method
private MethodBuilder get_method
private int table_idx
internal TypeBuilder typeb
private Type[] returnModReq
private Type[] returnModOpt
private Type[][] paramModReq
private Type[][] paramModOpt
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type DeclaringType
public string Name
public PropertyToken PropertyToken
public Type PropertyType
public Type ReflectedType
public Module Module
internal void .ctor(TypeBuilder tb, string name, PropertyAttributes attributes, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt)
private void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._PropertyBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_DeclaringType()
public string get_Name()
public PropertyToken get_PropertyToken()
public Type get_PropertyType()
public Type get_ReflectedType()
public void AddOtherMethod(MethodBuilder mdBuilder)
public MethodInfo[] GetAccessors(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public void SetConstant(object defaultValue)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public void SetGetMethod(MethodBuilder mdBuilder)
public void SetSetMethod(MethodBuilder mdBuilder)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public Module get_Module()
private Exception not_supported()
}
internal System.Reflection.Emit.PropertyOnTypeBuilderInst : PropertyInfo {
private MonoGenericClass instantiation
private PropertyInfo prop
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type PropertyType
public Type DeclaringType
public Type ReflectedType
public string Name
internal void .ctor(MonoGenericClass instantiation, PropertyInfo prop)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_PropertyType()
public Type get_DeclaringType()
public Type get_ReflectedType()
public string get_Name()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public string ToString()
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
public System.Reflection.Emit.PropertyToken : ValueType {
internal int tokValue
public PropertyToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(PropertyToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(PropertyToken a, PropertyToken b)
public bool op_Inequality(PropertyToken a, PropertyToken b)
}
internal System.Reflection.Emit.RefEmitPermissionSet : ValueType {
public SecurityAction action
public string pset
public void .ctor(SecurityAction action, string pset)
}
internal System.Reflection.Emit.SequencePoint : ValueType {
public int Offset
public int Line
public int Col
public int EndLine
public int EndCol
}
internal System.Reflection.Emit.SequencePointList : object {
private int arrayGrow
private ISymbolDocumentWriter doc
private SequencePoint[] points
private int count
public ISymbolDocumentWriter Document
public int StartLine
public int EndLine
public int StartColumn
public int EndColumn
public void .ctor(ISymbolDocumentWriter doc)
public ISymbolDocumentWriter get_Document()
public Int32[] GetOffsets()
public Int32[] GetLines()
public Int32[] GetColumns()
public Int32[] GetEndLines()
public Int32[] GetEndColumns()
public int get_StartLine()
public int get_EndLine()
public int get_StartColumn()
public int get_EndColumn()
public void AddSequencePoint(int offset, int line, int col, int endLine, int endCol)
}
public System.Reflection.Emit.SignatureHelper : object {
private ModuleBuilder module
private Type[] arguments
private SignatureHelperType type
private Type returnType
private CallingConventions callConv
private CallingConvention unmanagedCallConv
private Type[][] modreqs
private Type[][] modopts
internal void .ctor(ModuleBuilder module, SignatureHelperType type)
private void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._SignatureHelper.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public SignatureHelper GetFieldSigHelper(Module mod)
public SignatureHelper GetLocalVarSigHelper(Module mod)
public SignatureHelper GetLocalVarSigHelper()
public SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType)
public SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes)
public SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes)
private int AppendArray(Type[]& array, Type t)
private void AppendArrayAt(Type[][]& array, Type[] t, int pos)
private void ValidateParameterModifiers(string name, Type[] parameter_modifiers)
private void ValidateCustomModifier(int n, Type[][] custom_modifiers, string name)
private Exception MissingFeature()
public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
public void AddArgument(Type argument, bool pinned)
public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
public SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers)
public void AddArgument(Type clsArgument)
public void AddSentinel()
private bool CompareOK(Type[][] one, Type[][] two)
public bool Equals(object obj)
public int GetHashCode()
internal Byte[] get_signature_local()
internal Byte[] get_signature_field()
public Byte[] GetSignature()
public string ToString()
internal SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, CallingConvention unmanagedCallingConvention, Type returnType, Type[] parameters)
}
public System.Reflection.Emit.SignatureToken : ValueType {
internal int tokValue
public SignatureToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(SignatureToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(SignatureToken a, SignatureToken b)
public bool op_Inequality(SignatureToken a, SignatureToken b)
}
public System.Reflection.Emit.StackBehaviour : Enum {
public int value__
public StackBehaviour Pop0
public StackBehaviour Pop1
public StackBehaviour Pop1_pop1
public StackBehaviour Popi
public StackBehaviour Popi_pop1
public StackBehaviour Popi_popi
public StackBehaviour Popi_popi8
public StackBehaviour Popi_popi_popi
public StackBehaviour Popi_popr4
public StackBehaviour Popi_popr8
public StackBehaviour Popref
public StackBehaviour Popref_pop1
public StackBehaviour Popref_popi
public StackBehaviour Popref_popi_popi
public StackBehaviour Popref_popi_popi8
public StackBehaviour Popref_popi_popr4
public StackBehaviour Popref_popi_popr8
public StackBehaviour Popref_popi_popref
public StackBehaviour Push0
public StackBehaviour Push1
public StackBehaviour Push1_push1
public StackBehaviour Pushi
public StackBehaviour Pushi8
public StackBehaviour Pushr4
public StackBehaviour Pushr8
public StackBehaviour Pushref
public StackBehaviour Varpop
public StackBehaviour Varpush
public StackBehaviour Popref_popi_pop1
}
public System.Reflection.Emit.StringToken : ValueType {
internal int tokValue
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(StringToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(StringToken a, StringToken b)
public bool op_Inequality(StringToken a, StringToken b)
}
internal System.Reflection.Emit.TokenGenerator {
public int GetToken(string str)
public int GetToken(MemberInfo member)
public int GetToken(MethodInfo method, Type[] opt_param_types)
public int GetToken(SignatureHelper helper)
}
public System.Reflection.Emit.TypeBuilder : Type {
public int UnspecifiedTypeSize
private string tname
private string nspace
private Type parent
private Type nesting_type
internal Type[] interfaces
internal int num_methods
internal MethodBuilder[] methods
internal ConstructorBuilder[] ctors
internal PropertyBuilder[] properties
internal int num_fields
internal FieldBuilder[] fields
internal EventBuilder[] events
private CustomAttributeBuilder[] cattrs
internal TypeBuilder[] subtypes
internal TypeAttributes attrs
private int table_idx
private ModuleBuilder pmodule
private int class_size
private PackingSize packing_size
private IntPtr generic_container
private GenericTypeParameterBuilder[] generic_params
private RefEmitPermissionSet[] permissions
private Type created
private string fullname
private bool createTypeCalled
private Type underlying_type
private Dictionary`2<string, int> <>f__switch$map20
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public Type DeclaringType
public Type UnderlyingSystemType
public string FullName
public Guid GUID
public Module Module
public string Name
public string Namespace
public PackingSize PackingSize
public int Size
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public TypeToken TypeToken
internal bool IsCompilerContext
internal bool is_created
public bool ContainsGenericParameters
public bool IsGenericParameter
public GenericParameterAttributes GenericParameterAttributes
public bool IsGenericTypeDefinition
public bool IsGenericType
public int GenericParameterPosition
public MethodBase DeclaringMethod
internal void .ctor(ModuleBuilder mb, TypeAttributes attr, int table_idx)
internal void .ctor(ModuleBuilder mb, string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packing_size, int type_size, Type nesting_type)
private void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
protected TypeAttributes GetAttributeFlagsImpl()
private void setup_internal_class(TypeBuilder tb)
private void create_internal_class(TypeBuilder tb)
private void setup_generic_class()
private void create_generic_class()
private EventInfo get_event_info(EventBuilder eb)
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public Type get_DeclaringType()
public Type get_UnderlyingSystemType()
private string GetFullName()
public string get_FullName()
public Guid get_GUID()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public PackingSize get_PackingSize()
public int get_Size()
public Type get_ReflectedType()
public void AddDeclarativeSecurity(SecurityAction action, PermissionSet pset)
public void AddInterfaceImplementation(Type interfaceType)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public TypeBuilder DefineNestedType(string name)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent)
private TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize)
public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize)
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes)
public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes)
private void append_method(MethodBuilder mb)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes)
public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention)
public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes)
public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes)
public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
public ConstructorBuilder DefineTypeInitializer()
private Type create_runtime_class(TypeBuilder tb)
private bool is_nested_in(Type t)
private bool has_ctor_method()
public Type CreateType()
internal void GenerateDebugInfo(ISymbolWriter symbolWriter)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
internal ConstructorInfo[] GetConstructorsInternal(BindingFlags bindingAttr)
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
internal EventInfo[] GetEvents_internal(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
private MethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, Type reflected_type)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakeGenericType(Type[] typeArguments)
public Type MakePointerType()
public RuntimeTypeHandle get_TypeHandle()
internal void SetCharSet(TypeAttributes ta)
public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute)
public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes)
public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes)
public TypeToken get_TypeToken()
public void SetParent(Type parent)
internal int get_next_table_index(object obj, int table, bool inc)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
internal bool get_IsCompilerContext()
internal bool get_is_created()
private Exception not_supported()
private void check_not_created()
private void check_created()
private void check_name(string argName, string name)
public string ToString()
public bool IsAssignableFrom(Type c)
public bool IsSubclassOf(Type c)
internal bool IsAssignableTo(Type c)
public bool IsCreated()
public Type[] GetGenericArguments()
public Type GetGenericTypeDefinition()
public bool get_ContainsGenericParameters()
public bool get_IsGenericParameter()
public GenericParameterAttributes get_GenericParameterAttributes()
public bool get_IsGenericTypeDefinition()
public bool get_IsGenericType()
public int get_GenericParameterPosition()
public MethodBase get_DeclaringMethod()
public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names)
public ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor)
private bool IsValidGetMethodType(Type type)
public MethodInfo GetMethod(Type type, MethodInfo method)
public FieldInfo GetField(Type type, FieldInfo field)
}
internal System.Reflection.Emit.TypeKind : Enum {
public int value__
public TypeKind SZARRAY
public TypeKind ARRAY
}
public System.Reflection.Emit.TypeToken : ValueType {
internal int tokValue
public TypeToken Empty
public int Token
internal void .ctor(int val)
public bool Equals(object obj)
public bool Equals(TypeToken obj)
public int GetHashCode()
public int get_Token()
public bool op_Equality(TypeToken a, TypeToken b)
public bool op_Inequality(TypeToken a, TypeToken b)
}
public System.Reflection.Emit.UnmanagedMarshal : object {
private int count
private UnmanagedType t
private UnmanagedType tbase
private string guid
private string mcookie
private string marshaltype
private Type marshaltyperef
private int param_num
private bool has_size
public UnmanagedType BaseType
public int ElementCount
public UnmanagedType GetUnmanagedType
public Guid IIDGuid
private void .ctor(UnmanagedType maint, int cnt)
private void .ctor(UnmanagedType maint, UnmanagedType elemt)
public UnmanagedType get_BaseType()
public int get_ElementCount()
public UnmanagedType get_GetUnmanagedType()
public Guid get_IIDGuid()
public UnmanagedMarshal DefineByValArray(int elemCount)
public UnmanagedMarshal DefineByValTStr(int elemCount)
public UnmanagedMarshal DefineLPArray(UnmanagedType elemType)
public UnmanagedMarshal DefineSafeArray(UnmanagedType elemType)
public UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType)
public UnmanagedMarshal DefineCustom(Type typeref, string cookie, string mtype, Guid id)
internal UnmanagedMarshal DefineLPArrayInternal(UnmanagedType elemType, int sizeConst, int sizeParamIndex)
internal MarshalAsAttribute ToMarshalAsAttribute()
}
public System.Reflection.EventAttributes : Enum {
public int value__
public EventAttributes None
public EventAttributes SpecialName
public EventAttributes ReservedMask
public EventAttributes RTSpecialName
}
public System.Reflection.EventInfo : MemberInfo {
private AddEventAdapter cached_add_event
public EventAttributes Attributes
public Type EventHandlerType
public bool IsMulticast
public bool IsSpecialName
public MemberTypes MemberType
private void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._EventInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._EventInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public EventAttributes get_Attributes()
public Type get_EventHandlerType()
public bool get_IsMulticast()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public void AddEventHandler(object target, Delegate handler)
public MethodInfo GetAddMethod()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod()
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod()
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public MethodInfo[] GetOtherMethods()
public void RemoveEventHandler(object target, Delegate handler)
private void AddEventFrame(AddEvent`2<T, D> addEvent, object obj, object dele)
private void StaticAddEventAdapterFrame(StaticAddEvent`1<D> addEvent, object obj, object dele)
private AddEventAdapter CreateAddEventDelegate(MethodInfo method)
unknown Type System.Runtime.InteropServices._EventInfo.GetType()
}
public System.Reflection.ExceptionHandlingClause : object {
internal Type catch_type
internal int filter_offset
internal ExceptionHandlingClauseOptions flags
internal int try_offset
internal int try_length
internal int handler_offset
internal int handler_length
public Type CatchType
public int FilterOffset
public ExceptionHandlingClauseOptions Flags
public int HandlerLength
public int HandlerOffset
public int TryLength
public int TryOffset
public Type get_CatchType()
public int get_FilterOffset()
public ExceptionHandlingClauseOptions get_Flags()
public int get_HandlerLength()
public int get_HandlerOffset()
public int get_TryLength()
public int get_TryOffset()
public string ToString()
}
public System.Reflection.ExceptionHandlingClauseOptions : Enum {
public int value__
public ExceptionHandlingClauseOptions Clause
public ExceptionHandlingClauseOptions Filter
public ExceptionHandlingClauseOptions Finally
public ExceptionHandlingClauseOptions Fault
}
public System.Reflection.FieldAttributes : Enum {
public int value__
public FieldAttributes FieldAccessMask
public FieldAttributes PrivateScope
public FieldAttributes Private
public FieldAttributes FamANDAssem
public FieldAttributes Assembly
public FieldAttributes Family
public FieldAttributes FamORAssem
public FieldAttributes Public
public FieldAttributes Static
public FieldAttributes InitOnly
public FieldAttributes Literal
public FieldAttributes NotSerialized
public FieldAttributes HasFieldRVA
public FieldAttributes SpecialName
public FieldAttributes RTSpecialName
public FieldAttributes HasFieldMarshal
public FieldAttributes PinvokeImpl
public FieldAttributes HasDefault
public FieldAttributes ReservedMask
}
public System.Reflection.FieldInfo : MemberInfo {
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public Type FieldType
public MemberTypes MemberType
public bool IsLiteral
public bool IsStatic
public bool IsInitOnly
public bool IsPublic
public bool IsPrivate
public bool IsFamily
public bool IsAssembly
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsPinvokeImpl
public bool IsSpecialName
public bool IsNotSerialized
internal UnmanagedMarshal UMarshal
private void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._FieldInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public object GetValue(object obj)
public MemberTypes get_MemberType()
public bool get_IsLiteral()
public bool get_IsStatic()
public bool get_IsInitOnly()
public bool get_IsPublic()
public bool get_IsPrivate()
public bool get_IsFamily()
public bool get_IsAssembly()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsPinvokeImpl()
public bool get_IsSpecialName()
public bool get_IsNotSerialized()
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
public void SetValue(object obj, object value)
private FieldInfo internal_from_handle_type(IntPtr field_handle, IntPtr type_handle)
public FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle)
public FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType)
internal int GetFieldOffset()
public object GetValueDirect(TypedReference obj)
public void SetValueDirect(TypedReference obj, object value)
private UnmanagedMarshal GetUnmanagedMarshal()
internal UnmanagedMarshal get_UMarshal()
internal Object[] GetPseudoCustomAttributes()
private Type[] GetTypeModifiers(bool optional)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public object GetRawConstantValue()
unknown Type System.Runtime.InteropServices._FieldInfo.GetType()
}
public System.Reflection.GenericParameterAttributes : Enum {
public int value__
public GenericParameterAttributes Covariant
public GenericParameterAttributes Contravariant
public GenericParameterAttributes VarianceMask
public GenericParameterAttributes None
public GenericParameterAttributes ReferenceTypeConstraint
public GenericParameterAttributes NotNullableValueTypeConstraint
public GenericParameterAttributes DefaultConstructorConstraint
public GenericParameterAttributes SpecialConstraintMask
}
internal System.Reflection.Getter`2 : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public R Invoke(T _this)
public IAsyncResult BeginInvoke(T _this, AsyncCallback callback, object object)
public R EndInvoke(IAsyncResult result)
}
internal System.Reflection.GetterAdapter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(object _this)
public IAsyncResult BeginInvoke(object _this, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
public System.Reflection.ICustomAttributeProvider {
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
}
public System.Reflection.ImageFileMachine : Enum {
public int value__
public ImageFileMachine I386
public ImageFileMachine IA64
public ImageFileMachine AMD64
}
public System.Reflection.InterfaceMapping : ValueType {
public MethodInfo[] InterfaceMethods
public Type InterfaceType
public MethodInfo[] TargetMethods
public Type TargetType
}
public System.Reflection.InvalidFilterCriteriaException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.IReflect {
public Type UnderlyingSystemType
public Type get_UnderlyingSystemType()
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
}
public System.Reflection.LocalVariableInfo : object {
internal Type type
internal bool is_pinned
internal ushort position
public bool IsPinned
public int LocalIndex
public Type LocalType
public bool get_IsPinned()
public int get_LocalIndex()
public Type get_LocalType()
public string ToString()
}
public System.Reflection.ManifestResourceInfo : object {
private Assembly _assembly
private string _filename
private ResourceLocation _location
public string FileName
public Assembly ReferencedAssembly
public ResourceLocation ResourceLocation
internal void .ctor(Assembly assembly, string filename, ResourceLocation location)
public string get_FileName()
public Assembly get_ReferencedAssembly()
public ResourceLocation get_ResourceLocation()
}
public System.Reflection.MemberFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(MemberInfo m, object filterCriteria)
public IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Reflection.MemberInfo : object {
public Type DeclaringType
public MemberTypes MemberType
public string Name
public Type ReflectedType
public Module Module
public int MetadataToken
private void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MemberInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type get_DeclaringType()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
public Module get_Module()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int get_MetadataToken()
unknown Type System.Runtime.InteropServices._MemberInfo.GetType()
}
internal System.Reflection.MemberInfoSerializationHolder : object {
private BindingFlags DefaultBinding
private string _memberName
private string _memberSignature
private MemberTypes _memberType
private Type _reflectedType
private Type[] _genericArguments
private void .ctor(SerializationInfo info, StreamingContext ctx)
public void Serialize(SerializationInfo info, string name, Type klass, string signature, MemberTypes type)
public void Serialize(SerializationInfo info, string name, Type klass, string signature, MemberTypes type, Type[] genericArguments)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Reflection.MemberTypes : Enum {
public int value__
public MemberTypes Constructor
public MemberTypes Event
public MemberTypes Field
public MemberTypes Method
public MemberTypes Property
public MemberTypes TypeInfo
public MemberTypes Custom
public MemberTypes NestedType
public MemberTypes All
}
public System.Reflection.MethodAttributes : Enum {
public int value__
public MethodAttributes MemberAccessMask
public MethodAttributes PrivateScope
public MethodAttributes Private
public MethodAttributes FamANDAssem
public MethodAttributes Assembly
public MethodAttributes Family
public MethodAttributes FamORAssem
public MethodAttributes Public
public MethodAttributes Static
public MethodAttributes Final
public MethodAttributes Virtual
public MethodAttributes HideBySig
public MethodAttributes VtableLayoutMask
public MethodAttributes CheckAccessOnOverride
public MethodAttributes ReuseSlot
public MethodAttributes NewSlot
public MethodAttributes Abstract
public MethodAttributes SpecialName
public MethodAttributes PinvokeImpl
public MethodAttributes UnmanagedExport
public MethodAttributes RTSpecialName
public MethodAttributes ReservedMask
public MethodAttributes HasSecurity
public MethodAttributes RequireSecObject
}
public System.Reflection.MethodBase : MemberInfo {
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public bool IsPublic
public bool IsPrivate
public bool IsFamily
public bool IsAssembly
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsStatic
public bool IsFinal
public bool IsVirtual
public bool IsHideBySig
public bool IsAbstract
public bool IsSpecialName
public bool IsConstructor
public bool ContainsGenericParameters
public bool IsGenericMethodDefinition
public bool IsGenericMethod
private void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodBase.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodBase.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public MethodBase GetCurrentMethod()
internal MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle)
private MethodBase GetMethodFromIntPtr(IntPtr handle, IntPtr declaringType)
public MethodBase GetMethodFromHandle(RuntimeMethodHandle handle)
private MethodBase GetMethodFromHandleInternalType(IntPtr method_handle, IntPtr type_handle)
public MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType)
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal int GetParameterCount()
public object Invoke(object obj, Object[] parameters)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public bool get_IsPublic()
public bool get_IsPrivate()
public bool get_IsFamily()
public bool get_IsAssembly()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsStatic()
public bool get_IsFinal()
public bool get_IsVirtual()
public bool get_IsHideBySig()
public bool get_IsAbstract()
public bool get_IsSpecialName()
public bool get_IsConstructor()
internal int get_next_table_index(object obj, int table, bool inc)
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
internal MethodBody GetMethodBodyInternal(IntPtr handle)
internal MethodBody GetMethodBody(IntPtr handle)
public MethodBody GetMethodBody()
unknown Type System.Runtime.InteropServices._MethodBase.GetType()
}
public System.Reflection.MethodBody : object {
private ExceptionHandlingClause[] clauses
private LocalVariableInfo[] locals
private Byte[] il
private bool init_locals
private int sig_token
private int max_stack
public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses
public IList`1<LocalVariableInfo> LocalVariables
public bool InitLocals
public int LocalSignatureMetadataToken
public int MaxStackSize
public IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses()
public IList`1<LocalVariableInfo> get_LocalVariables()
public bool get_InitLocals()
public int get_LocalSignatureMetadataToken()
public int get_MaxStackSize()
public Byte[] GetILAsByteArray()
}
public System.Reflection.MethodImplAttributes : Enum {
public int value__
public MethodImplAttributes CodeTypeMask
public MethodImplAttributes IL
public MethodImplAttributes Native
public MethodImplAttributes OPTIL
public MethodImplAttributes Runtime
public MethodImplAttributes ManagedMask
public MethodImplAttributes Unmanaged
public MethodImplAttributes Managed
public MethodImplAttributes ForwardRef
public MethodImplAttributes PreserveSig
public MethodImplAttributes InternalCall
public MethodImplAttributes Synchronized
public MethodImplAttributes NoInlining
public MethodImplAttributes MaxMethodImplVal
}
public System.Reflection.MethodInfo : MethodBase {
public MemberTypes MemberType
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public bool IsGenericMethod
public bool IsGenericMethodDefinition
public bool ContainsGenericParameters
public ParameterInfo ReturnParameter
private void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._MethodInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public MethodInfo GetBaseDefinition()
public MemberTypes get_MemberType()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodInfo GetGenericMethodDefinition()
public MethodInfo MakeGenericMethod(Type[] typeArguments)
public Type[] GetGenericArguments()
public bool get_IsGenericMethod()
public bool get_IsGenericMethodDefinition()
public bool get_ContainsGenericParameters()
public ParameterInfo get_ReturnParameter()
unknown Type System.Runtime.InteropServices._MethodInfo.GetType()
}
public System.Reflection.Missing : object {
public Missing Value
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Reflection.Module : object {
private BindingFlags defaultBindingFlags
public TypeFilter FilterTypeName
public TypeFilter FilterTypeNameIgnoreCase
private IntPtr _impl
internal Assembly assembly
internal string fqname
internal string name
internal string scopename
internal bool is_resource
internal int token
public Assembly Assembly
public string FullyQualifiedName
public string Name
public string ScopeName
public ModuleHandle ModuleHandle
public int MetadataToken
public int MDStreamVersion
internal Guid MvId
public Guid ModuleVersionId
private void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Module.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Module.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Module.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Assembly get_Assembly()
public string get_FullyQualifiedName()
public string get_Name()
public string get_ScopeName()
public ModuleHandle get_ModuleHandle()
public int get_MetadataToken()
public int get_MDStreamVersion()
internal int GetMDStreamVersion(IntPtr module_handle)
public Type[] FindTypes(TypeFilter filter, object filterCriteria)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public FieldInfo GetField(string name)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields()
public MethodInfo GetMethod(string name)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods()
public MethodInfo[] GetMethods(BindingFlags bindingFlags)
public FieldInfo[] GetFields(BindingFlags bindingFlags)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public X509Certificate GetSignerCertificate()
public Type GetType(string className)
public Type GetType(string className, bool ignoreCase)
public Type GetType(string className, bool throwOnError, bool ignoreCase)
private Type[] InternalGetTypes()
public Type[] GetTypes()
public bool IsDefined(Type attributeType, bool inherit)
public bool IsResource()
public string ToString()
internal Guid get_MvId()
public Guid get_ModuleVersionId()
public void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine)
private Exception resolve_token_exception(int metadataToken, ResolveTokenError error, string tokenType)
private IntPtr[] ptrs_from_types(Type[] types)
public FieldInfo ResolveField(int metadataToken)
public FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MemberInfo ResolveMember(int metadataToken)
public MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public MethodBase ResolveMethod(int metadataToken)
public MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public string ResolveString(int metadataToken)
public Type ResolveType(int metadataToken)
public Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)
public Byte[] ResolveSignature(int metadataToken)
internal Type MonoDebugger_ResolveType(Module module, int token)
internal Guid Mono_GetGuid(Module module)
internal Guid GetModuleVersionId()
private bool filter_by_type_name(Type m, object filterCriteria)
private bool filter_by_type_name_ignore_case(Type m, object filterCriteria)
internal IntPtr GetHINSTANCE()
private string GetGuidInternal()
private Type GetGlobalType()
internal IntPtr ResolveTypeToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal IntPtr ResolveMethodToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal IntPtr ResolveFieldToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal string ResolveStringToken(IntPtr module, int token, ResolveTokenError& error)
internal MemberInfo ResolveMemberToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error)
internal Byte[] ResolveSignature(IntPtr module, int metadataToken, ResolveTokenError& error)
internal void GetPEKind(IntPtr module, PortableExecutableKinds& peKind, ImageFileMachine& machine)
}
public System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Module Invoke(object sender, ResolveEventArgs e)
public IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object)
public Module EndInvoke(IAsyncResult result)
}
internal System.Reflection.MonoArrayMethod : MethodInfo {
internal RuntimeMethodHandle mhandle
internal Type parent
internal Type ret
internal Type[] parameters
internal string name
internal int table_idx
internal CallingConventions call_conv
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public Type ReflectedType
public Type DeclaringType
public string Name
internal void .ctor(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
public MethodInfo GetBaseDefinition()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public string ToString()
}
internal System.Reflection.MonoCMethod : ConstructorInfo {
internal IntPtr mhandle
private string name
private Type reftype
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type ReflectedType
public Type DeclaringType
public string Name
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal object InternalInvoke(object obj, Object[] parameters, Exception& exc)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodBody GetMethodBody()
public string ToString()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.MonoEvent : EventInfo {
private IntPtr klass
private IntPtr handle
public EventAttributes Attributes
public Type DeclaringType
public Type ReflectedType
public string Name
public EventAttributes get_Attributes()
public MethodInfo GetAddMethod(bool nonPublic)
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod(bool nonPublic)
public MethodInfo[] GetOtherMethods(bool nonPublic)
public Type get_DeclaringType()
public Type get_ReflectedType()
public string get_Name()
public string ToString()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.MonoEventInfo : ValueType {
public Type declaring_type
public Type reflected_type
public string name
public MethodInfo add_method
public MethodInfo remove_method
public MethodInfo raise_method
public EventAttributes attrs
public MethodInfo[] other_methods
private void get_event_info(MonoEvent ev, MonoEventInfo& info)
internal MonoEventInfo GetEventInfo(MonoEvent ev)
}
internal System.Reflection.MonoField : FieldInfo {
internal IntPtr klass
internal RuntimeFieldHandle fhandle
private string name
private Type type
private FieldAttributes attrs
public FieldAttributes Attributes
public RuntimeFieldHandle FieldHandle
public Type FieldType
public Type ReflectedType
public Type DeclaringType
public string Name
public FieldAttributes get_Attributes()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
private Type GetParentType(bool declaring)
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
internal int GetFieldOffset()
private object GetValueInternal(object obj)
public object GetValue(object obj)
public string ToString()
private void SetValueInternal(FieldInfo fi, object obj, object value)
public void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
internal MonoField Clone(string newName)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRawConstantValue()
private void CheckGeneric()
}
internal System.Reflection.MonoGenericClass : MonoType {
private BindingFlags flags
internal TypeBuilder generic_type
private Type[] type_arguments
private bool initialized
private Hashtable fields
private Hashtable ctors
private Hashtable methods
private int event_count
public Type BaseType
public Type UnderlyingSystemType
public string Name
public string Namespace
public string FullName
public string AssemblyQualifiedName
public Guid GUID
internal void .ctor(TypeBuilder tb, Type[] args)
private void initialize(MethodInfo[] methods, ConstructorInfo[] ctors, FieldInfo[] fields, PropertyInfo[] properties, EventInfo[] events)
private void initialize()
private Type GetParentType()
internal Type InflateType(Type type)
internal Type InflateType(Type type, Type[] method_args)
public Type get_BaseType()
private Type[] GetInterfacesInternal()
public Type[] GetInterfaces()
protected bool IsValueTypeImpl()
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
public MethodInfo[] GetMethods(BindingFlags bf)
private MethodInfo[] GetMethodsInternal(BindingFlags bf, MonoGenericClass reftype)
public ConstructorInfo[] GetConstructors(BindingFlags bf)
private ConstructorInfo[] GetConstructorsInternal(BindingFlags bf, MonoGenericClass reftype)
public FieldInfo[] GetFields(BindingFlags bf)
private FieldInfo[] GetFieldsInternal(BindingFlags bf, MonoGenericClass reftype)
public PropertyInfo[] GetProperties(BindingFlags bf)
private PropertyInfo[] GetPropertiesInternal(BindingFlags bf, MonoGenericClass reftype)
public EventInfo[] GetEvents(BindingFlags bf)
private EventInfo[] GetEventsInternal(BindingFlags bf, MonoGenericClass reftype)
public Type[] GetNestedTypes(BindingFlags bf)
public bool IsAssignableFrom(Type c)
public Type get_UnderlyingSystemType()
public string get_Name()
public string get_Namespace()
public string get_FullName()
public string get_AssemblyQualifiedName()
public Guid get_GUID()
private string format_name(bool full_name, bool assembly_qualified)
public string ToString()
public Type MakeArrayType()
public Type MakeArrayType(int rank)
public Type MakeByRefType()
public Type MakePointerType()
protected bool IsCOMObjectImpl()
protected bool IsPrimitiveImpl()
protected TypeAttributes GetAttributeFlagsImpl()
public Type GetInterface(string name, bool ignoreCase)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
}
internal System.Reflection.MonoGenericCMethod : MonoCMethod {
public Type ReflectedType
public Type get_ReflectedType()
}
internal System.Reflection.MonoGenericMethod : MonoMethod {
public Type ReflectedType
public Type get_ReflectedType()
}
internal System.Reflection.MonoMethod : MethodInfo {
internal IntPtr mhandle
private string name
private Type reftype
public ParameterInfo ReturnParameter
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public RuntimeMethodHandle MethodHandle
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type ReflectedType
public Type DeclaringType
public string Name
public bool IsGenericMethodDefinition
public bool IsGenericMethod
public bool ContainsGenericParameters
internal void .ctor(RuntimeMethodHandle mhandle)
internal string get_name(MethodBase method)
internal MonoMethod get_base_definition(MonoMethod method)
public MethodInfo GetBaseDefinition()
public ParameterInfo get_ReturnParameter()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
internal object InternalInvoke(object obj, Object[] parameters, Exception& exc)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public RuntimeMethodHandle get_MethodHandle()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
internal DllImportAttribute GetDllImportAttribute(IntPtr mhandle)
internal Object[] GetPseudoCustomAttributes()
private bool ShouldPrintFullName(Type type)
public string ToString()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public MethodInfo MakeGenericMethod(Type[] methodInstantiation)
private MethodInfo MakeGenericMethod_impl(Type[] types)
public Type[] GetGenericArguments()
private MethodInfo GetGenericMethodDefinition_impl()
public MethodInfo GetGenericMethodDefinition()
public bool get_IsGenericMethodDefinition()
public bool get_IsGenericMethod()
public bool get_ContainsGenericParameters()
public MethodBody GetMethodBody()
}
internal System.Reflection.MonoMethodInfo : ValueType {
private Type parent
private Type ret
internal MethodAttributes attrs
internal MethodImplAttributes iattrs
private CallingConventions callconv
private void get_method_info(IntPtr handle, MonoMethodInfo& info)
internal MonoMethodInfo GetMethodInfo(IntPtr handle)
internal Type GetDeclaringType(IntPtr handle)
internal Type GetReturnType(IntPtr handle)
internal MethodAttributes GetAttributes(IntPtr handle)
internal CallingConventions GetCallingConvention(IntPtr handle)
internal MethodImplAttributes GetMethodImplementationFlags(IntPtr handle)
private ParameterInfo[] get_parameter_info(IntPtr handle, MemberInfo member)
internal ParameterInfo[] GetParametersInfo(IntPtr handle, MemberInfo member)
private UnmanagedMarshal get_retval_marshal(IntPtr handle)
internal ParameterInfo GetReturnParameterInfo(MonoMethod method)
}
internal System.Reflection.MonoProperty : PropertyInfo {
internal IntPtr klass
internal IntPtr prop
private MonoPropertyInfo info
private PInfo cached
private GetterAdapter cached_getter
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type PropertyType
public Type ReflectedType
public Type DeclaringType
public string Name
private void CachePropertyInfo(PInfo flags)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_PropertyType()
public Type get_ReflectedType()
public Type get_DeclaringType()
public string get_Name()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod(bool nonPublic)
public bool IsDefined(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
private object GetterAdapterFrame(Getter`2<T, R> getter, object obj)
private object StaticGetterAdapterFrame(StaticGetter`1<R> getter, object obj)
private GetterAdapter CreateGetterDelegate(MethodInfo method)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public string ToString()
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.MonoPropertyInfo : ValueType {
public Type parent
public string name
public MethodInfo get_method
public MethodInfo set_method
public PropertyAttributes attrs
internal void get_property_info(MonoProperty prop, MonoPropertyInfo& info, PInfo req_info)
internal Type[] GetTypeModifiers(MonoProperty prop, bool optional)
}
public System.Reflection.ObfuscateAssemblyAttribute : Attribute {
private bool is_private
private bool strip
public bool AssemblyIsPrivate
public bool StripAfterObfuscation
public void .ctor(bool assemblyIsPrivate)
public bool get_AssemblyIsPrivate()
public bool get_StripAfterObfuscation()
public void set_StripAfterObfuscation(bool value)
}
public System.Reflection.ObfuscationAttribute : Attribute {
private bool exclude
private bool strip
private bool applyToMembers
private string feature
public bool Exclude
public bool StripAfterObfuscation
public bool ApplyToMembers
public string Feature
public bool get_Exclude()
public void set_Exclude(bool value)
public bool get_StripAfterObfuscation()
public void set_StripAfterObfuscation(bool value)
public bool get_ApplyToMembers()
public void set_ApplyToMembers(bool value)
public string get_Feature()
public void set_Feature(string value)
}
public System.Reflection.ParameterAttributes : Enum {
public int value__
public ParameterAttributes None
public ParameterAttributes In
public ParameterAttributes Out
public ParameterAttributes Lcid
public ParameterAttributes Retval
public ParameterAttributes Optional
public ParameterAttributes ReservedMask
public ParameterAttributes HasDefault
public ParameterAttributes HasFieldMarshal
public ParameterAttributes Reserved3
public ParameterAttributes Reserved4
}
public System.Reflection.ParameterInfo : object {
protected Type ClassImpl
protected object DefaultValueImpl
protected MemberInfo MemberImpl
protected string NameImpl
protected int PositionImpl
protected ParameterAttributes AttrsImpl
private UnmanagedMarshal marshalAs
public Type ParameterType
public ParameterAttributes Attributes
public object DefaultValue
public bool IsIn
public bool IsLcid
public bool IsOptional
public bool IsOut
public bool IsRetval
public MemberInfo Member
public string Name
public int Position
public int MetadataToken
public object RawDefaultValue
internal void .ctor(ParameterBuilder pb, Type type, MemberInfo member, int position)
internal void .ctor(ParameterInfo pinfo, MemberInfo member)
internal void .ctor(Type type, MemberInfo member, UnmanagedMarshal marshalAs)
private void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._ParameterInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public string ToString()
public Type get_ParameterType()
public ParameterAttributes get_Attributes()
public object get_DefaultValue()
public bool get_IsIn()
public bool get_IsLcid()
public bool get_IsOptional()
public bool get_IsOut()
public bool get_IsRetval()
public MemberInfo get_Member()
public string get_Name()
public int get_Position()
private int GetMetadataToken()
public int get_MetadataToken()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
internal Object[] GetPseudoCustomAttributes()
private Type[] GetTypeModifiers(bool optional)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public object get_RawDefaultValue()
}
public System.Reflection.ParameterModifier : ValueType {
private Boolean[] _byref
public bool Item
public void .ctor(int parameterCount)
public bool get_Item(int index)
public void set_Item(int index, bool value)
}
internal System.Reflection.PInfo : Enum {
public int value__
public PInfo Attributes
public PInfo GetMethod
public PInfo SetMethod
public PInfo ReflectedType
public PInfo DeclaringType
public PInfo Name
}
public System.Reflection.Pointer : object {
private Void* data
private Type type
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public object Box(Void* ptr, Type type)
public Void* Unbox(object ptr)
}
public System.Reflection.PortableExecutableKinds : Enum {
public int value__
public PortableExecutableKinds NotAPortableExecutableImage
public PortableExecutableKinds ILOnly
public PortableExecutableKinds Required32Bit
public PortableExecutableKinds PE32Plus
public PortableExecutableKinds Unmanaged32Bit
}
public System.Reflection.ProcessorArchitecture : Enum {
public int value__
public ProcessorArchitecture None
public ProcessorArchitecture MSIL
public ProcessorArchitecture X86
public ProcessorArchitecture IA64
public ProcessorArchitecture Amd64
}
public System.Reflection.PropertyAttributes : Enum {
public int value__
public PropertyAttributes None
public PropertyAttributes SpecialName
public PropertyAttributes ReservedMask
public PropertyAttributes RTSpecialName
public PropertyAttributes HasDefault
public PropertyAttributes Reserved2
public PropertyAttributes Reserved3
public PropertyAttributes Reserved4
}
public System.Reflection.PropertyInfo : MemberInfo {
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public bool IsSpecialName
public MemberTypes MemberType
public Type PropertyType
private void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._PropertyInfo.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public Type get_PropertyType()
public MethodInfo[] GetAccessors()
public MethodInfo[] GetAccessors(bool nonPublic)
public MethodInfo GetGetMethod()
public MethodInfo GetGetMethod(bool nonPublic)
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod()
public MethodInfo GetSetMethod(bool nonPublic)
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public Type[] GetOptionalCustomModifiers()
public Type[] GetRequiredCustomModifiers()
public object GetConstantValue()
public object GetRawConstantValue()
unknown Type System.Runtime.InteropServices._PropertyInfo.GetType()
}
public System.Reflection.ReflectionTypeLoadException : SystemException {
private Exception[] loaderExceptions
private Type[] types
public Type[] Types
public Exception[] LoaderExceptions
public void .ctor(Type[] classes, Exception[] exceptions)
public void .ctor(Type[] classes, Exception[] exceptions, string message)
private void .ctor(SerializationInfo info, StreamingContext sc)
public Type[] get_Types()
public Exception[] get_LoaderExceptions()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.Reflection.ResolveTokenError : Enum {
public int value__
public ResolveTokenError OutOfRange
public ResolveTokenError BadTable
public ResolveTokenError Other
}
public System.Reflection.ResourceAttributes : Enum {
public int value__
public ResourceAttributes Public
public ResourceAttributes Private
}
public System.Reflection.ResourceLocation : Enum {
public int value__
public ResourceLocation Embedded
public ResourceLocation ContainedInAnotherAssembly
public ResourceLocation ContainedInManifestFile
}
public System.Reflection.StrongNameKeyPair : object {
private Byte[] _publicKey
private string _keyPairContainer
private bool _keyPairExported
private Byte[] _keyPairArray
private RSA _rsa
public Byte[] PublicKey
public void .ctor(Byte[] keyPairArray)
public void .ctor(FileStream keyPairFile)
public void .ctor(string keyPairContainer)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private RSA GetRSA()
private void LoadKey(Byte[] key)
public Byte[] get_PublicKey()
internal StrongName StrongName()
}
public System.Reflection.TargetException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.TargetInvocationException : ApplicationException {
public void .ctor(Exception inner)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext sc)
}
public System.Reflection.TargetParameterCountException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Reflection.TypeAttributes : Enum {
public int value__
public TypeAttributes VisibilityMask
public TypeAttributes NotPublic
public TypeAttributes Public
public TypeAttributes NestedPublic
public TypeAttributes NestedPrivate
public TypeAttributes NestedFamily
public TypeAttributes NestedAssembly
public TypeAttributes NestedFamANDAssem
public TypeAttributes NestedFamORAssem
public TypeAttributes LayoutMask
public TypeAttributes AutoLayout
public TypeAttributes SequentialLayout
public TypeAttributes ExplicitLayout
public TypeAttributes ClassSemanticsMask
public TypeAttributes Class
public TypeAttributes Interface
public TypeAttributes Abstract
public TypeAttributes Sealed
public TypeAttributes SpecialName
public TypeAttributes Import
public TypeAttributes Serializable
public TypeAttributes StringFormatMask
public TypeAttributes AnsiClass
public TypeAttributes UnicodeClass
public TypeAttributes AutoClass
public TypeAttributes BeforeFieldInit
public TypeAttributes ReservedMask
public TypeAttributes RTSpecialName
public TypeAttributes HasSecurity
public TypeAttributes CustomFormatClass
public TypeAttributes CustomFormatMask
}
public System.Reflection.TypeDelegator : Type {
protected Type typeImpl
public Assembly Assembly
public string AssemblyQualifiedName
public Type BaseType
public string FullName
public Guid GUID
public Module Module
public string Name
public string Namespace
public RuntimeTypeHandle TypeHandle
public Type UnderlyingSystemType
public int MetadataToken
public void .ctor(Type delegatingType)
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public Type get_BaseType()
public string get_FullName()
public Guid get_GUID()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public RuntimeTypeHandle get_TypeHandle()
public Type get_UnderlyingSystemType()
protected TypeAttributes GetAttributeFlagsImpl()
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Type GetElementType()
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public Type GetInterface(string name, bool ignoreCase)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected bool HasElementTypeImpl()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
public bool IsDefined(Type attributeType, bool inherit)
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
protected bool IsValueTypeImpl()
public int get_MetadataToken()
}
public System.Reflection.TypeFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(Type m, object filterCriteria)
public IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.ResolveEventArgs : EventArgs {
private string m_Name
public string Name
public void .ctor(string name)
public string get_Name()
}
public System.ResolveEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public Assembly Invoke(object sender, ResolveEventArgs args)
public IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object)
public Assembly EndInvoke(IAsyncResult result)
}
internal System.Resources.ICONDIRENTRY : object {
public byte bWidth
public byte bHeight
public byte bColorCount
public byte bReserved
public short wPlanes
public short wBitCount
public int dwBytesInRes
public int dwImageOffset
public Byte[] image
public string ToString()
}
public System.Resources.IResourceReader {
public void Close()
public IDictionaryEnumerator GetEnumerator()
}
public System.Resources.IResourceWriter {
public void AddResource(string name, Byte[] value)
public void AddResource(string name, object value)
public void AddResource(string name, string value)
public void Close()
public void Generate()
}
public System.Resources.MissingManifestResourceException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
}
public System.Resources.MissingSatelliteAssemblyException : SystemException {
private string culture
public string CultureName
public void .ctor(string message)
public void .ctor(string message, string cultureName)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public string get_CultureName()
}
internal System.Resources.NameOrId : object {
private string name
private int id
public bool IsName
public string Name
public int Id
public void .ctor(string name)
public void .ctor(int id)
public bool get_IsName()
public string get_Name()
public int get_Id()
public string ToString()
}
public System.Resources.NeutralResourcesLanguageAttribute : Attribute {
private string culture
private UltimateResourceFallbackLocation loc
public string CultureName
public UltimateResourceFallbackLocation Location
public void .ctor(string cultureName)
public void .ctor(string cultureName, UltimateResourceFallbackLocation location)
public string get_CultureName()
public UltimateResourceFallbackLocation get_Location()
}
internal System.Resources.PredefinedResourceType : Enum {
public int value__
public PredefinedResourceType Null
public PredefinedResourceType String
public PredefinedResourceType Bool
public PredefinedResourceType Char
public PredefinedResourceType Byte
public PredefinedResourceType SByte
public PredefinedResourceType Int16
public PredefinedResourceType UInt16
public PredefinedResourceType Int32
public PredefinedResourceType UInt32
public PredefinedResourceType Int64
public PredefinedResourceType UInt64
public PredefinedResourceType Single
public PredefinedResourceType Double
public PredefinedResourceType Decimal
public PredefinedResourceType DateTime
public PredefinedResourceType TimeSpan
public PredefinedResourceType ByteArray
public PredefinedResourceType Stream
public PredefinedResourceType FistCustom
}
public System.Resources.ResourceManager : object {
private Hashtable ResourceCache
private Hashtable NonExistent
public int HeaderVersionNumber
public int MagicNumber
protected string BaseNameField
protected Assembly MainAssembly
protected Hashtable ResourceSets
private bool ignoreCase
private Type resourceSource
private Type resourceSetType
private string resourceDir
private CultureInfo neutral_culture
private UltimateResourceFallbackLocation fallbackLocation
public string BaseName
public bool IgnoreCase
public Type ResourceSetType
protected UltimateResourceFallbackLocation FallbackLocation
public void .ctor(Type resourceSource)
public void .ctor(string baseName, Assembly assembly)
public void .ctor(string baseName, Assembly assembly, Type usingResourceSet)
private void .ctor(string baseName, string resourceDir, Type usingResourceSet)
private Hashtable GetResourceSets(Assembly assembly, string basename)
private Type CheckResourceSetType(Type usingResourceSet, bool verifyType)
public ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet)
public string get_BaseName()
public bool get_IgnoreCase()
public void set_IgnoreCase(bool value)
public Type get_ResourceSetType()
public object GetObject(string name)
public object GetObject(string name, CultureInfo culture)
public ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents)
public string GetString(string name)
public string GetString(string name, CultureInfo culture)
protected string GetResourceFileName(CultureInfo culture)
private string GetResourceFilePath(CultureInfo culture)
private Stream GetManifestResourceStreamNoCase(Assembly ass, string fn)
public UnmanagedMemoryStream GetStream(string name)
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture)
protected ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents)
public void ReleaseAllResources()
protected CultureInfo GetNeutralResourcesLanguage(Assembly a)
protected Version GetSatelliteContractVersion(Assembly a)
protected UltimateResourceFallbackLocation get_FallbackLocation()
protected void set_FallbackLocation(UltimateResourceFallbackLocation value)
private MissingManifestResourceException AssemblyResourceMissing(string fileName)
private string GetManifestResourceName(string fn)
}
public System.Resources.ResourceReader : object {
private BinaryReader reader
private object readerLock
private IFormatter formatter
internal int resourceCount
private int typeCount
private String[] typeNames
private Int32[] hashes
private ResourceInfo[] infos
private int dataSectionOffset
private long nameSectionOffset
private int resource_ver
private ResourceCacheItem[] cache
private object cache_lock
public void .ctor(Stream stream)
public void .ctor(string fileName)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
private void System.IDisposable.Dispose()
private void ReadHeaders()
private void CreateResourceInfo(long position, ResourceInfo& info)
private int Read7BitEncodedInt()
private object ReadValueVer2(int type_index)
private object ReadValueVer1(Type type)
private object ReadNonPredefinedValue(Type exp_type)
private void LoadResourceValues(ResourceCacheItem[] store)
internal UnmanagedMemoryStream ResourceValueAsStream(string name, int index)
public void Close()
public IDictionaryEnumerator GetEnumerator()
public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData)
private void GetResourceDataAt(int index, String& resourceType, Byte[]& data)
private void Dispose(bool disposing)
}
public System.Resources.ResourceSet : object {
protected IResourceReader Reader
protected Hashtable Table
private bool resources_read
private bool disposed
public void .ctor(IResourceReader reader)
public void .ctor(Stream stream)
internal void .ctor(UnmanagedMemoryStream stream)
public void .ctor(string fileName)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
public Type GetDefaultReader()
public Type GetDefaultWriter()
public IDictionaryEnumerator GetEnumerator()
private object GetObjectInternal(string name, bool ignoreCase)
public object GetObject(string name)
public object GetObject(string name, bool ignoreCase)
private string GetStringInternal(string name, bool ignoreCase)
public string GetString(string name)
public string GetString(string name, bool ignoreCase)
protected void ReadResources()
internal UnmanagedMemoryStream GetStream(string name, bool ignoreCase)
}
public System.Resources.ResourceWriter : object {
private SortedList resources
private Stream stream
internal Stream Stream
public void .ctor(Stream stream)
public void .ctor(string fileName)
public void AddResource(string name, Byte[] value)
public void AddResource(string name, object value)
public void AddResource(string name, string value)
public void Close()
public void Dispose()
private void Dispose(bool disposing)
public void AddResourceData(string name, string typeName, Byte[] serializedData)
public void Generate()
private int GetHash(string name)
private void Write7BitEncodedInt(BinaryWriter writer, int value)
internal Stream get_Stream()
}
internal System.Resources.RuntimeResourceSet : ResourceSet {
public void .ctor(UnmanagedMemoryStream stream)
public void .ctor(Stream stream)
public void .ctor(string fileName)
public object GetObject(string name)
public object GetObject(string name, bool ignoreCase)
private object CloneDisposableObjectIfPossible(object value)
}
public System.Resources.SatelliteContractVersionAttribute : Attribute {
private Version ver
public string Version
public void .ctor(string version)
public string get_Version()
}
public System.Resources.UltimateResourceFallbackLocation : Enum {
public int value__
public UltimateResourceFallbackLocation MainAssembly
public UltimateResourceFallbackLocation Satellite
}
internal System.Resources.Win32EncodedResource : Win32Resource {
private Byte[] data
public Byte[] Data
internal void .ctor(NameOrId type, NameOrId name, int language, Byte[] data)
public Byte[] get_Data()
public void WriteTo(Stream s)
}
internal System.Resources.Win32GroupIconResource : Win32Resource {
private Win32IconResource[] icons
public void .ctor(int id, int language, Win32IconResource[] icons)
public void WriteTo(Stream s)
}
internal System.Resources.Win32IconFileReader : object {
private Stream iconFile
public void .ctor(Stream s)
public ICONDIRENTRY[] ReadIcons()
}
internal System.Resources.Win32IconResource : Win32Resource {
private ICONDIRENTRY icon
public ICONDIRENTRY Icon
public void .ctor(int id, int language, ICONDIRENTRY icon)
public ICONDIRENTRY get_Icon()
public void WriteTo(Stream s)
}
internal System.Resources.Win32ResFileReader : object {
private Stream res_file
public void .ctor(Stream s)
private int read_int16()
private int read_int32()
private void read_padding()
private NameOrId read_ordinal()
public ICollection ReadResources()
}
internal System.Resources.Win32Resource : object {
private NameOrId type
private NameOrId name
private int language
public Win32ResourceType ResourceType
public NameOrId Name
public NameOrId Type
public int Language
internal void .ctor(NameOrId type, NameOrId name, int language)
internal void .ctor(Win32ResourceType type, int name, int language)
public Win32ResourceType get_ResourceType()
public NameOrId get_Name()
public NameOrId get_Type()
public int get_Language()
public void WriteTo(Stream s)
public string ToString()
}
internal System.Resources.Win32ResourceType : Enum {
public int value__
public Win32ResourceType RT_CURSOR
public Win32ResourceType RT_FONT
public Win32ResourceType RT_BITMAP
public Win32ResourceType RT_ICON
public Win32ResourceType RT_MENU
public Win32ResourceType RT_DIALOG
public Win32ResourceType RT_STRING
public Win32ResourceType RT_FONTDIR
public Win32ResourceType RT_ACCELERATOR
public Win32ResourceType RT_RCDATA
public Win32ResourceType RT_MESSAGETABLE
public Win32ResourceType RT_GROUP_CURSOR
public Win32ResourceType RT_GROUP_ICON
public Win32ResourceType RT_VERSION
public Win32ResourceType RT_DLGINCLUDE
public Win32ResourceType RT_PLUGPLAY
public Win32ResourceType RT_VXD
public Win32ResourceType RT_ANICURSOR
public Win32ResourceType RT_ANIICON
public Win32ResourceType RT_HTML
}
internal System.Resources.Win32VersionResource : Win32Resource {
public String[] WellKnownProperties
private long signature
private int struct_version
private long file_version
private long product_version
private int file_flags_mask
private int file_flags
private int file_os
private int file_type
private int file_subtype
private long file_date
private int file_lang
private int file_codepage
private Hashtable properties
public string Version
public string Item
public string Comments
public string CompanyName
public string LegalCopyright
public string LegalTrademarks
public string OriginalFilename
public string ProductName
public string ProductVersion
public string InternalName
public string FileDescription
public int FileLanguage
public string FileVersion
public void .ctor(int id, int language, bool compilercontext)
public string get_Version()
public void set_Version(string value)
public void set_Item(string key, string value)
public string get_Comments()
public void set_Comments(string value)
public string get_CompanyName()
public void set_CompanyName(string value)
public string get_LegalCopyright()
public void set_LegalCopyright(string value)
public string get_LegalTrademarks()
public void set_LegalTrademarks(string value)
public string get_OriginalFilename()
public void set_OriginalFilename(string value)
public string get_ProductName()
public void set_ProductName(string value)
public string get_ProductVersion()
public void set_ProductVersion(string value)
public string get_InternalName()
public void set_InternalName(string value)
public string get_FileDescription()
public void set_FileDescription(string value)
public int get_FileLanguage()
public void set_FileLanguage(int value)
public string get_FileVersion()
public void set_FileVersion(string value)
private void emit_padding(BinaryWriter w)
private void patch_length(BinaryWriter w, long len_pos)
public void WriteTo(Stream ms)
}
public System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
private string name
public string PropertyName
public void .ctor(string propertyName)
public string get_PropertyName()
}
public System.Runtime.CompilerServices.CompilationRelaxations : Enum {
public int value__
public CompilationRelaxations NoStringInterning
}
public System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
private int relax
public int CompilationRelaxations
public void .ctor(int relaxations)
public void .ctor(CompilationRelaxations relaxations)
public int get_CompilationRelaxations()
}
public System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
public object Value
public object get_Value()
}
public System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
private long ticks
internal long Ticks
public object Value
public void .ctor(long ticks)
internal long get_Ticks()
public object get_Value()
}
public System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
private byte scale
private bool sign
private int hi
private int mid
private int low
public decimal Value
public void .ctor(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low)
public void .ctor(byte scale, byte sign, int hi, int mid, int low)
public decimal get_Value()
}
public System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
private LoadHint hint
public LoadHint LoadHint
public void .ctor(LoadHint loadHintArgument)
public LoadHint get_LoadHint()
}
public System.Runtime.CompilerServices.DependencyAttribute : Attribute {
private string dependentAssembly
private LoadHint hint
public string DependentAssembly
public LoadHint LoadHint
public void .ctor(string dependentAssemblyArgument, LoadHint loadHintArgument)
public string get_DependentAssembly()
public LoadHint get_LoadHint()
}
public System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
private Type elementType
private int length
public Type ElementType
public int Length
public void .ctor(Type elementType, int length)
public Type get_ElementType()
public int get_Length()
}
public System.Runtime.CompilerServices.IDispatchConstantAttribute : CustomConstantAttribute {
public object Value
public object get_Value()
}
public System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
public void .ctor(string indexerName)
}
public System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
private string assemblyName
private bool all_visible
public string AssemblyName
public bool AllInternalsVisible
public void .ctor(string assemblyName)
public string get_AssemblyName()
public bool get_AllInternalsVisible()
public void set_AllInternalsVisible(bool value)
}
public System.Runtime.CompilerServices.IUnknownConstantAttribute : CustomConstantAttribute {
public object Value
public object get_Value()
}
public System.Runtime.CompilerServices.LoadHint : Enum {
public int value__
public LoadHint Default
public LoadHint Always
public LoadHint Sometimes
}
public System.Runtime.CompilerServices.MethodCodeType : Enum {
public int value__
public MethodCodeType IL
public MethodCodeType Native
public MethodCodeType OPTIL
public MethodCodeType Runtime
}
public System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
private MethodImplOptions _val
public MethodCodeType MethodCodeType
public MethodImplOptions Value
public void .ctor(short value)
public void .ctor(MethodImplOptions methodImplOptions)
public MethodImplOptions get_Value()
}
public System.Runtime.CompilerServices.MethodImplOptions : Enum {
public int value__
public MethodImplOptions Unmanaged
public MethodImplOptions ForwardRef
public MethodImplOptions InternalCall
public MethodImplOptions Synchronized
public MethodImplOptions NoInlining
public MethodImplOptions PreserveSig
public MethodImplOptions NoOptimization
}
public System.Runtime.CompilerServices.RequiredAttributeAttribute : Attribute {
public Type RequiredContract
public void .ctor(Type requiredContract)
public Type get_RequiredContract()
}
public System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
private bool wrap_non_exception_throws
public bool WrapNonExceptionThrows
public bool get_WrapNonExceptionThrows()
public void set_WrapNonExceptionThrows(bool value)
}
public System.Runtime.CompilerServices.RuntimeHelpers : object {
public int OffsetToStringData
private void InitializeArray(Array array, IntPtr fldHandle)
public void InitializeArray(Array array, RuntimeFieldHandle fldHandle)
public int get_OffsetToStringData()
public int GetHashCode(object o)
public bool Equals(object o1, object o2)
public object GetObjectValue(object obj)
private void RunClassConstructor(IntPtr type)
public void RunClassConstructor(RuntimeTypeHandle type)
public void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData)
public void PrepareConstrainedRegions()
public void PrepareConstrainedRegionsNoOP()
public void ProbeForSufficientStack()
public void PrepareDelegate(Delegate d)
public void PrepareMethod(RuntimeMethodHandle method)
public void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation)
public void RunModuleConstructor(ModuleHandle module)
public void RunModuleConstructor(IntPtr module)
}
public System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
private object wrapped_exception
public object WrappedException
public object get_WrappedException()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
private Type destination
public Type Destination
public void .ctor(Type destination)
public Type get_Destination()
}
public System.Runtime.ConstrainedExecution.Cer : Enum {
public int value__
public Cer None
public Cer MayFail
public Cer Success
}
public System.Runtime.ConstrainedExecution.Consistency : Enum {
public int value__
public Consistency MayCorruptAppDomain
public Consistency MayCorruptInstance
public Consistency MayCorruptProcess
public Consistency WillNotCorruptState
}
public System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
protected void Finalize()
}
public System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
private Consistency consistency
private Cer cer
public Cer Cer
public Consistency ConsistencyGuarantee
public void .ctor(Consistency consistencyGuarantee, Cer cer)
public Cer get_Cer()
public Consistency get_ConsistencyGuarantee()
}
public System.Runtime.GCLatencyMode : Enum {
public int value__
public GCLatencyMode Batch
public GCLatencyMode Interactive
public GCLatencyMode LowLatency
}
public System.Runtime.GCSettings : object {
public bool IsServerGC
public GCLatencyMode LatencyMode
public bool get_IsServerGC()
public GCLatencyMode get_LatencyMode()
public void set_LatencyMode(GCLatencyMode value)
}
public System.Runtime.Hosting.ActivationArguments : object {
private ActivationContext _context
private ApplicationIdentity _identity
private String[] _data
public ActivationContext ActivationContext
public String[] ActivationData
public ApplicationIdentity ApplicationIdentity
public void .ctor(ActivationContext activationData)
public void .ctor(ApplicationIdentity applicationIdentity)
public void .ctor(ActivationContext activationContext, String[] activationData)
public void .ctor(ApplicationIdentity applicationIdentity, String[] activationData)
public ActivationContext get_ActivationContext()
public String[] get_ActivationData()
public ApplicationIdentity get_ApplicationIdentity()
}
public System.Runtime.Hosting.ApplicationActivator : object {
public ObjectHandle CreateInstance(ActivationContext activationContext)
public ObjectHandle CreateInstance(ActivationContext activationContext, String[] activationCustomData)
protected ObjectHandle CreateInstanceHelper(AppDomainSetup adSetup)
}
public System.Runtime.InteropServices._Activator {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Assembly {
public string CodeBase
public string EscapedCodeBase
public string FullName
public MethodInfo EntryPoint
public string Location
public Evidence Evidence
public bool GlobalAssemblyCache
public void add_ModuleResolve(ModuleResolveEventHandler value)
public void remove_ModuleResolve(ModuleResolveEventHandler value)
public string ToString()
public bool Equals(object other)
public int GetHashCode()
public Type GetType()
public string get_CodeBase()
public string get_EscapedCodeBase()
public AssemblyName GetName()
public AssemblyName GetName(bool copiedName)
public string get_FullName()
public MethodInfo get_EntryPoint()
public Type GetType(string name)
public Type GetType(string name, bool throwOnError)
public Type[] GetExportedTypes()
public Type[] GetTypes()
public Stream GetManifestResourceStream(Type type, string name)
public Stream GetManifestResourceStream(string name)
public FileStream GetFile(string name)
public FileStream[] GetFiles()
public FileStream[] GetFiles(bool getResourceModules)
public String[] GetManifestResourceNames()
public ManifestResourceInfo GetManifestResourceInfo(string resourceName)
public string get_Location()
public Evidence get_Evidence()
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public Object[] GetCustomAttributes(bool inherit)
public bool IsDefined(Type attributeType, bool inherit)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type GetType(string name, bool throwOnError, bool ignoreCase)
public Assembly GetSatelliteAssembly(CultureInfo culture)
public Assembly GetSatelliteAssembly(CultureInfo culture, Version version)
public Module LoadModule(string moduleName, Byte[] rawModule)
public Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore)
public object CreateInstance(string typeName)
public object CreateInstance(string typeName, bool ignoreCase)
public object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)
public Module[] GetLoadedModules()
public Module[] GetLoadedModules(bool getResourceModules)
public Module[] GetModules()
public Module[] GetModules(bool getResourceModules)
public Module GetModule(string name)
public AssemblyName[] GetReferencedAssemblies()
public bool get_GlobalAssemblyCache()
}
public System.Runtime.InteropServices._AssemblyBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._AssemblyName {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Attribute {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ConstructorBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ConstructorInfo {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke_5(Object[] parameters)
public object Invoke_3(object obj, Object[] parameters)
public object Invoke_4(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public object Invoke_2(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._CustomAttributeBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EnumBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EventBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._EventInfo {
public EventAttributes Attributes
public Type DeclaringType
public Type EventHandlerType
public bool IsMulticast
public bool IsSpecialName
public MemberTypes MemberType
public string Name
public Type ReflectedType
public void AddEventHandler(object target, Delegate handler)
public bool Equals(object other)
public MethodInfo GetAddMethod()
public MethodInfo GetAddMethod(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public MethodInfo GetRaiseMethod()
public MethodInfo GetRaiseMethod(bool nonPublic)
public MethodInfo GetRemoveMethod()
public MethodInfo GetRemoveMethod(bool nonPublic)
public Type GetType()
public bool IsDefined(Type attributeType, bool inherit)
public void RemoveEventHandler(object target, Delegate handler)
public string ToString()
public EventAttributes get_Attributes()
public Type get_DeclaringType()
public Type get_EventHandlerType()
public bool get_IsMulticast()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._Exception {
public string HelpLink
public Exception InnerException
public string Message
public string Source
public string StackTrace
public MethodBase TargetSite
public string get_HelpLink()
public void set_HelpLink(string value)
public Exception get_InnerException()
public string get_Message()
public string get_Source()
public void set_Source(string value)
public string get_StackTrace()
public MethodBase get_TargetSite()
public bool Equals(object obj)
public Exception GetBaseException()
public int GetHashCode()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public Type GetType()
public string ToString()
}
public System.Runtime.InteropServices._FieldBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._FieldInfo {
public FieldAttributes Attributes
public Type DeclaringType
public RuntimeFieldHandle FieldHandle
public Type FieldType
public bool IsAssembly
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsInitOnly
public bool IsLiteral
public bool IsNotSerialized
public bool IsPinvokeImpl
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public MemberTypes MemberType
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public Type GetType()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public object GetValue(object obj)
public object GetValueDirect(TypedReference obj)
public bool IsDefined(Type attributeType, bool inherit)
public void SetValue(object obj, object value)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture)
public void SetValueDirect(TypedReference obj, object value)
public string ToString()
public FieldAttributes get_Attributes()
public Type get_DeclaringType()
public RuntimeFieldHandle get_FieldHandle()
public Type get_FieldType()
public bool get_IsAssembly()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsInitOnly()
public bool get_IsLiteral()
public bool get_IsNotSerialized()
public bool get_IsPinvokeImpl()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._ILGenerator {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._LocalBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MemberInfo {
public Type DeclaringType
public MemberTypes MemberType
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public Type GetType()
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public Type get_DeclaringType()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_ReflectedType()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MethodBase {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public bool Equals(object other)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke(object obj, Object[] parameters)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._MethodBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._MethodInfo {
public MethodAttributes Attributes
public CallingConventions CallingConvention
public Type DeclaringType
public bool IsAbstract
public bool IsAssembly
public bool IsConstructor
public bool IsFamily
public bool IsFamilyAndAssembly
public bool IsFamilyOrAssembly
public bool IsFinal
public bool IsHideBySig
public bool IsPrivate
public bool IsPublic
public bool IsSpecialName
public bool IsStatic
public bool IsVirtual
public MemberTypes MemberType
public RuntimeMethodHandle MethodHandle
public string Name
public Type ReflectedType
public Type ReturnType
public ICustomAttributeProvider ReturnTypeCustomAttributes
public bool Equals(object other)
public MethodInfo GetBaseDefinition()
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public int GetHashCode()
public MethodImplAttributes GetMethodImplementationFlags()
public ParameterInfo[] GetParameters()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object Invoke(object obj, Object[] parameters)
public object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public string ToString()
public MethodAttributes get_Attributes()
public CallingConventions get_CallingConvention()
public Type get_DeclaringType()
public bool get_IsAbstract()
public bool get_IsAssembly()
public bool get_IsConstructor()
public bool get_IsFamily()
public bool get_IsFamilyAndAssembly()
public bool get_IsFamilyOrAssembly()
public bool get_IsFinal()
public bool get_IsHideBySig()
public bool get_IsPrivate()
public bool get_IsPublic()
public bool get_IsSpecialName()
public bool get_IsStatic()
public bool get_IsVirtual()
public MemberTypes get_MemberType()
public RuntimeMethodHandle get_MethodHandle()
public string get_Name()
public Type get_ReflectedType()
public Type get_ReturnType()
public ICustomAttributeProvider get_ReturnTypeCustomAttributes()
}
public System.Runtime.InteropServices._MethodRental {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Module {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ModuleBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ParameterBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._ParameterInfo {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._PropertyBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._PropertyInfo {
public PropertyAttributes Attributes
public bool CanRead
public bool CanWrite
public Type DeclaringType
public bool IsSpecialName
public MemberTypes MemberType
public string Name
public Type PropertyType
public Type ReflectedType
public bool Equals(object other)
public MethodInfo[] GetAccessors()
public MethodInfo[] GetAccessors(bool nonPublic)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MethodInfo GetGetMethod()
public MethodInfo GetGetMethod(bool nonPublic)
public int GetHashCode()
public ParameterInfo[] GetIndexParameters()
public MethodInfo GetSetMethod()
public MethodInfo GetSetMethod(bool nonPublic)
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetType()
public object GetValue(object obj, Object[] index)
public object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public bool IsDefined(Type attributeType, bool inherit)
public void SetValue(object obj, object value, Object[] index)
public void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture)
public string ToString()
public PropertyAttributes get_Attributes()
public bool get_CanRead()
public bool get_CanWrite()
public Type get_DeclaringType()
public bool get_IsSpecialName()
public MemberTypes get_MemberType()
public string get_Name()
public Type get_PropertyType()
public Type get_ReflectedType()
}
public System.Runtime.InteropServices._SignatureHelper {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Thread {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices._Type {
public Assembly Assembly
public string AssemblyQualifiedName
public TypeAttributes Attributes
public Type BaseType
public Type DeclaringType
public string FullName
public Guid GUID
public bool HasElementType
public bool IsAbstract
public bool IsAnsiClass
public bool IsArray
public bool IsAutoClass
public bool IsAutoLayout
public bool IsByRef
public bool IsClass
public bool IsCOMObject
public bool IsContextful
public bool IsEnum
public bool IsExplicitLayout
public bool IsImport
public bool IsInterface
public bool IsLayoutSequential
public bool IsMarshalByRef
public bool IsNestedAssembly
public bool IsNestedFamANDAssem
public bool IsNestedFamily
public bool IsNestedFamORAssem
public bool IsNestedPrivate
public bool IsNestedPublic
public bool IsNotPublic
public bool IsPointer
public bool IsPrimitive
public bool IsPublic
public bool IsSealed
public bool IsSerializable
public bool IsSpecialName
public bool IsUnicodeClass
public bool IsValueType
public MemberTypes MemberType
public Module Module
public string Name
public string Namespace
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public ConstructorInfo TypeInitializer
public Type UnderlyingSystemType
public bool Equals(object other)
public bool Equals(Type o)
public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
public int GetArrayRank()
public ConstructorInfo GetConstructor(Type[] types)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors()
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public Object[] GetCustomAttributes(bool inherit)
public Object[] GetCustomAttributes(Type attributeType, bool inherit)
public MemberInfo[] GetDefaultMembers()
public Type GetElementType()
public EventInfo GetEvent(string name)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields()
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public int GetHashCode()
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Type GetInterface(string name)
public Type GetInterface(string name, bool ignoreCase)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public MemberInfo[] GetMember(string name)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMembers()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MethodInfo GetMethod(string name)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public MethodInfo[] GetMethods()
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes()
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties()
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, Type returnType)
public PropertyInfo GetProperty(string name, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
public Type GetType()
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public bool IsAssignableFrom(Type c)
public bool IsDefined(Type attributeType, bool inherit)
public bool IsInstanceOfType(object o)
public bool IsSubclassOf(Type c)
public string ToString()
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public TypeAttributes get_Attributes()
public Type get_BaseType()
public Type get_DeclaringType()
public string get_FullName()
public Guid get_GUID()
public bool get_HasElementType()
public bool get_IsAbstract()
public bool get_IsAnsiClass()
public bool get_IsArray()
public bool get_IsAutoClass()
public bool get_IsAutoLayout()
public bool get_IsByRef()
public bool get_IsClass()
public bool get_IsCOMObject()
public bool get_IsContextful()
public bool get_IsEnum()
public bool get_IsExplicitLayout()
public bool get_IsImport()
public bool get_IsInterface()
public bool get_IsLayoutSequential()
public bool get_IsMarshalByRef()
public bool get_IsNestedAssembly()
public bool get_IsNestedFamANDAssem()
public bool get_IsNestedFamily()
public bool get_IsNestedFamORAssem()
public bool get_IsNestedPrivate()
public bool get_IsNestedPublic()
public bool get_IsNotPublic()
public bool get_IsPointer()
public bool get_IsPrimitive()
public bool get_IsPublic()
public bool get_IsSealed()
public bool get_IsSerializable()
public bool get_IsSpecialName()
public bool get_IsUnicodeClass()
public bool get_IsValueType()
public MemberTypes get_MemberType()
public Module get_Module()
public string get_Name()
public string get_Namespace()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public ConstructorInfo get_TypeInitializer()
public Type get_UnderlyingSystemType()
}
public System.Runtime.InteropServices._TypeBuilder {
public void GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
public void GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
public void GetTypeInfoCount(UInt32& pcTInfo)
public void Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
}
public System.Runtime.InteropServices.ArrayWithOffset : ValueType {
private object array
private int offset
public void .ctor(object array, int offset)
public bool Equals(object obj)
public bool Equals(ArrayWithOffset obj)
public int GetHashCode()
public object GetArray()
public int GetOffset()
public bool op_Equality(ArrayWithOffset a, ArrayWithOffset b)
public bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b)
}
public System.Runtime.InteropServices.AssemblyRegistrationFlags : Enum {
public int value__
public AssemblyRegistrationFlags None
public AssemblyRegistrationFlags SetCodeBase
}
public System.Runtime.InteropServices.AutomationProxyAttribute : Attribute {
private bool val
public bool Value
public void .ctor(bool val)
public bool get_Value()
}
public System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
private bool bfm
public bool ThrowOnUnmappableChar
public bool BestFitMapping
public void .ctor(bool BestFitMapping)
public bool get_BestFitMapping()
}
public System.Runtime.InteropServices.BIND_OPTS : ValueType {
public int cbStruct
public int grfFlags
public int grfMode
public int dwTickCountDeadline
}
public System.Runtime.InteropServices.BINDPTR : ValueType {
public IntPtr lpfuncdesc
public IntPtr lptcomp
public IntPtr lpvardesc
}
public System.Runtime.InteropServices.BStrWrapper : object {
private string _value
public string WrappedObject
public void .ctor(string value)
public string get_WrappedObject()
}
public System.Runtime.InteropServices.CALLCONV : Enum {
public int value__
public CALLCONV CC_CDECL
public CALLCONV CC_PASCAL
public CALLCONV CC_MSCPASCAL
public CALLCONV CC_MACPASCAL
public CALLCONV CC_STDCALL
public CALLCONV CC_RESERVED
public CALLCONV CC_SYSCALL
public CALLCONV CC_MPWCDECL
public CALLCONV CC_MPWPASCAL
public CALLCONV CC_MAX
}
public System.Runtime.InteropServices.CallingConvention : Enum {
public int value__
public CallingConvention Winapi
public CallingConvention Cdecl
public CallingConvention StdCall
public CallingConvention ThisCall
public CallingConvention FastCall
}
public System.Runtime.InteropServices.CharSet : Enum {
public int value__
public CharSet None
public CharSet Ansi
public CharSet Unicode
public CharSet Auto
}
public System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
private ClassInterfaceType ciType
public ClassInterfaceType Value
public void .ctor(short classInterfaceType)
public void .ctor(ClassInterfaceType classInterfaceType)
public ClassInterfaceType get_Value()
}
public System.Runtime.InteropServices.ClassInterfaceType : Enum {
public int value__
public ClassInterfaceType None
public ClassInterfaceType AutoDispatch
public ClassInterfaceType AutoDual
}
public System.Runtime.InteropServices.CoClassAttribute : Attribute {
private Type klass
public Type CoClass
public void .ctor(Type coClass)
public Type get_CoClass()
}
public System.Runtime.InteropServices.ComAliasNameAttribute : Attribute {
private string val
public string Value
public void .ctor(string alias)
public string get_Value()
}
public System.Runtime.InteropServices.ComCompatibleVersionAttribute : Attribute {
private int major
private int minor
private int build
private int revision
public int MajorVersion
public int MinorVersion
public int BuildNumber
public int RevisionNumber
public void .ctor(int major, int minor, int build, int revision)
public int get_MajorVersion()
public int get_MinorVersion()
public int get_BuildNumber()
public int get_RevisionNumber()
}
public System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
private Type _type
public Type Value
public void .ctor(Type defaultInterface)
public Type get_Value()
}
public System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
private Type si
private Type ep
public Type EventProvider
public Type SourceInterface
public void .ctor(Type SourceInterface, Type EventProvider)
public Type get_EventProvider()
public Type get_SourceInterface()
}
public System.Runtime.InteropServices.COMException : ExternalException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string message, int errorCode)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Runtime.InteropServices.ComInterfaceType : Enum {
public int value__
public ComInterfaceType InterfaceIsDual
public ComInterfaceType InterfaceIsIUnknown
public ComInterfaceType InterfaceIsIDispatch
}
public System.Runtime.InteropServices.ComMemberType : Enum {
public int value__
public ComMemberType Method
public ComMemberType PropGet
public ComMemberType PropSet
}
public System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
private string internalValue
public string Value
public void .ctor(string sourceInterfaces)
public void .ctor(Type sourceInterface)
public void .ctor(Type sourceInterface1, Type sourceInterface2)
public void .ctor(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3)
public void .ctor(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4)
public string get_Value()
}
public System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
public int cbStruct
public int grfFlags
public int grfMode
public int dwTickCountDeadline
}
public System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
public IntPtr lpfuncdesc
public IntPtr lptcomp
public IntPtr lpvardesc
}
public System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
public int value__
public CALLCONV CC_CDECL
public CALLCONV CC_PASCAL
public CALLCONV CC_MSCPASCAL
public CALLCONV CC_MACPASCAL
public CALLCONV CC_STDCALL
public CALLCONV CC_RESERVED
public CALLCONV CC_SYSCALL
public CALLCONV CC_MPWCDECL
public CALLCONV CC_MPWPASCAL
public CALLCONV CC_MAX
}
public System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
public object pUnk
public int dwCookie
}
public System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
public int value__
public DESCKIND DESCKIND_NONE
public DESCKIND DESCKIND_FUNCDESC
public DESCKIND DESCKIND_VARDESC
public DESCKIND DESCKIND_TYPECOMP
public DESCKIND DESCKIND_IMPLICITAPPOBJ
public DESCKIND DESCKIND_MAX
}
public System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
public IntPtr rgvarg
public IntPtr rgdispidNamedArgs
public int cArgs
public int cNamedArgs
}
public System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
public TYPEDESC tdesc
public DESCUNION desc
}
public System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
public short wCode
public short wReserved
public string bstrSource
public string bstrDescription
public string bstrHelpFile
public int dwHelpContext
public IntPtr pvReserved
public IntPtr pfnDeferredFillIn
public int scode
}
public System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
public int dwLowDateTime
public int dwHighDateTime
}
public System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
public int memid
public IntPtr lprgscode
public IntPtr lprgelemdescParam
public FUNCKIND funckind
public INVOKEKIND invkind
public CALLCONV callconv
public short cParams
public short cParamsOpt
public short oVft
public short cScodes
public ELEMDESC elemdescFunc
public short wFuncFlags
}
public System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
public int value__
public FUNCFLAGS FUNCFLAG_FRESTRICTED
public FUNCFLAGS FUNCFLAG_FSOURCE
public FUNCFLAGS FUNCFLAG_FBINDABLE
public FUNCFLAGS FUNCFLAG_FREQUESTEDIT
public FUNCFLAGS FUNCFLAG_FDISPLAYBIND
public FUNCFLAGS FUNCFLAG_FDEFAULTBIND
public FUNCFLAGS FUNCFLAG_FHIDDEN
public FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR
public FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM
public FUNCFLAGS FUNCFLAG_FUIDEFAULT
public FUNCFLAGS FUNCFLAG_FNONBROWSABLE
public FUNCFLAGS FUNCFLAG_FREPLACEABLE
public FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
public int value__
public FUNCKIND FUNC_VIRTUAL
public FUNCKIND FUNC_PUREVIRTUAL
public FUNCKIND FUNC_NONVIRTUAL
public FUNCKIND FUNC_STATIC
public FUNCKIND FUNC_DISPATCH
}
public System.Runtime.InteropServices.ComTypes.IBindCtx {
public void RegisterObjectBound(object punk)
public void RevokeObjectBound(object punk)
public void ReleaseBoundObjects()
public void SetBindOptions(BIND_OPTS& pbindopts)
public void GetBindOptions(BIND_OPTS& pbindopts)
public void GetRunningObjectTable(IRunningObjectTable& pprot)
public void RegisterObjectParam(string pszKey, object punk)
public void GetObjectParam(string pszKey, Object& ppunk)
public void EnumObjectParam(IEnumString& ppenum)
public int RevokeObjectParam(string pszKey)
}
public System.Runtime.InteropServices.ComTypes.IConnectionPoint {
public void GetConnectionInterface(Guid& pIID)
public void GetConnectionPointContainer(IConnectionPointContainer& ppCPC)
public void Advise(object pUnkSink, Int32& pdwCookie)
public void Unadvise(int dwCookie)
public void EnumConnections(IEnumConnections& ppEnum)
}
public System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
public void EnumConnectionPoints(IEnumConnectionPoints& ppEnum)
public void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP)
}
public System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
public IntPtr dwReserved
public IDLFLAG wIDLFlags
}
public System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
public int value__
public IDLFLAG IDLFLAG_NONE
public IDLFLAG IDLFLAG_FIN
public IDLFLAG IDLFLAG_FOUT
public IDLFLAG IDLFLAG_FLCID
public IDLFLAG IDLFLAG_FRETVAL
}
public System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
public int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumConnectionPoints& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumConnections {
public int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumConnections& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumMoniker {
public int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumMoniker& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumString {
public int Next(int celt, String[] rgelt, IntPtr pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(IEnumString& ppenum)
}
public System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
public int Next(int celt, Object[] rgVar, IntPtr pceltFetched)
public int Skip(int celt)
public int Reset()
public IEnumVARIANT Clone()
}
public System.Runtime.InteropServices.ComTypes.IMoniker {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(IStream pStm)
public void Save(IStream pStm, bool fClearDirty)
public void GetSizeMax(Int64& pcbSize)
public void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult)
public void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj)
public void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced)
public void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite)
public void Enum(bool fForward, IEnumMoniker& ppenumMoniker)
public int IsEqual(IMoniker pmkOtherMoniker)
public void Hash(Int32& pdwHash)
public int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning)
public void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime)
public void Inverse(IMoniker& ppmk)
public void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix)
public void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath)
public void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName)
public void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut)
public int IsSystemMoniker(Int32& pdwMksys)
}
public System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
public int value__
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT
public IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE
public IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE
}
public System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
public int value__
public INVOKEKIND INVOKE_FUNC
public INVOKEKIND INVOKE_PROPERTYGET
public INVOKEKIND INVOKE_PROPERTYPUT
public INVOKEKIND INVOKE_PROPERTYPUTREF
}
public System.Runtime.InteropServices.ComTypes.IPersistFile {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(string pszFileName, int dwMode)
public void Save(string pszFileName, bool fRemember)
public void SaveCompleted(string pszFileName)
public void GetCurFile(String& ppszFileName)
}
public System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
public int Register(int grfFlags, object punkObject, IMoniker pmkObjectName)
public void Revoke(int dwRegister)
public int IsRunning(IMoniker pmkObjectName)
public int GetObject(IMoniker pmkObjectName, Object& ppunkObject)
public void NoteChangeTime(int dwRegister, FILETIME& pfiletime)
public int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime)
public void EnumRunning(IEnumMoniker& ppenumMoniker)
}
public System.Runtime.InteropServices.ComTypes.IStream {
public void Read(Byte[] pv, int cb, IntPtr pcbRead)
public void Write(Byte[] pv, int cb, IntPtr pcbWritten)
public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
public void SetSize(long libNewSize)
public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
public void Commit(int grfCommitFlags)
public void Revert()
public void LockRegion(long libOffset, long cb, int dwLockType)
public void UnlockRegion(long libOffset, long cb, int dwLockType)
public void Stat(STATSTG& pstatstg, int grfStatFlag)
public void Clone(IStream& ppstm)
}
public System.Runtime.InteropServices.ComTypes.ITypeComp {
public void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr)
public void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp)
}
public System.Runtime.InteropServices.ComTypes.ITypeInfo {
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal)
public void GetRefTypeInfo(int hRef, ITypeInfo& ppTI)
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetMops(int memid, String& pBstrMops)
public void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
}
public System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex)
public void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags)
public void GetTypeKind(TYPEKIND& pTypeKind)
public void GetTypeFlags(Int32& pTypeFlags)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetMops(int memid, String& pBstrMops)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeInfo(int hRef, ITypeInfo& ppTI)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex)
public void GetVarIndexOfMemId(int memid, Int32& pVarIndex)
public void GetCustData(Guid& guid, Object& pVarVal)
public void GetFuncCustData(int index, Guid& guid, Object& pVarVal)
public void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal)
public void GetVarCustData(int index, Guid& guid, Object& pVarVal)
public void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal)
public void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll)
public void GetAllCustData(IntPtr pCustData)
public void GetAllFuncCustData(int index, IntPtr pCustData)
public void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData)
public void GetAllVarCustData(int index, IntPtr pCustData)
public void GetAllImplTypeCustData(int index, IntPtr pCustData)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
}
public System.Runtime.InteropServices.ComTypes.ITypeLib {
public int GetTypeInfoCount()
public void GetTypeInfo(int index, ITypeInfo& ppTI)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public bool IsName(string szNameBuf, int lHashVal)
public void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
}
public System.Runtime.InteropServices.ComTypes.ITypeLib2 {
public void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void GetCustData(Guid& guid, Object& pVarVal)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames)
public void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll)
public void GetAllCustData(IntPtr pCustData)
public void GetTypeComp(ITypeComp& ppTComp)
public void GetTypeInfo(int index, ITypeInfo& ppTI)
public void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public bool IsName(string szNameBuf, int lHashVal)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
public int GetTypeInfoCount()
}
public System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
public int value__
public LIBFLAGS LIBFLAG_FRESTRICTED
public LIBFLAGS LIBFLAG_FCONTROL
public LIBFLAGS LIBFLAG_FHIDDEN
public LIBFLAGS LIBFLAG_FHASDISKIMAGE
}
public System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
public IntPtr lpVarValue
public PARAMFLAG wParamFlags
}
public System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
public int value__
public PARAMFLAG PARAMFLAG_NONE
public PARAMFLAG PARAMFLAG_FIN
public PARAMFLAG PARAMFLAG_FOUT
public PARAMFLAG PARAMFLAG_FLCID
public PARAMFLAG PARAMFLAG_FRETVAL
public PARAMFLAG PARAMFLAG_FOPT
public PARAMFLAG PARAMFLAG_FHASDEFAULT
public PARAMFLAG PARAMFLAG_FHASCUSTDATA
}
public System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
public string pwcsName
public int type
public long cbSize
public FILETIME mtime
public FILETIME ctime
public FILETIME atime
public int grfMode
public int grfLocksSupported
public Guid clsid
public int grfStateBits
public int reserved
}
public System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
public int value__
public SYSKIND SYS_WIN16
public SYSKIND SYS_WIN32
public SYSKIND SYS_MAC
public SYSKIND SYS_WIN64
}
public System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
public int MEMBER_ID_NIL
public Guid guid
public int lcid
public int dwReserved
public int memidConstructor
public int memidDestructor
public IntPtr lpstrSchema
public int cbSizeInstance
public TYPEKIND typekind
public short cFuncs
public short cVars
public short cImplTypes
public short cbSizeVft
public short cbAlignment
public TYPEFLAGS wTypeFlags
public short wMajorVerNum
public short wMinorVerNum
public TYPEDESC tdescAlias
public IDLDESC idldescType
}
public System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
public IntPtr lpValue
public short vt
}
public System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
public int value__
public TYPEFLAGS TYPEFLAG_FAPPOBJECT
public TYPEFLAGS TYPEFLAG_FCANCREATE
public TYPEFLAGS TYPEFLAG_FLICENSED
public TYPEFLAGS TYPEFLAG_FPREDECLID
public TYPEFLAGS TYPEFLAG_FHIDDEN
public TYPEFLAGS TYPEFLAG_FCONTROL
public TYPEFLAGS TYPEFLAG_FDUAL
public TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE
public TYPEFLAGS TYPEFLAG_FOLEAUTOMATION
public TYPEFLAGS TYPEFLAG_FRESTRICTED
public TYPEFLAGS TYPEFLAG_FAGGREGATABLE
public TYPEFLAGS TYPEFLAG_FREPLACEABLE
public TYPEFLAGS TYPEFLAG_FDISPATCHABLE
public TYPEFLAGS TYPEFLAG_FREVERSEBIND
public TYPEFLAGS TYPEFLAG_FPROXY
}
public System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
public int value__
public TYPEKIND TKIND_ENUM
public TYPEKIND TKIND_RECORD
public TYPEKIND TKIND_MODULE
public TYPEKIND TKIND_INTERFACE
public TYPEKIND TKIND_DISPATCH
public TYPEKIND TKIND_COCLASS
public TYPEKIND TKIND_ALIAS
public TYPEKIND TKIND_UNION
public TYPEKIND TKIND_MAX
}
public System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
public Guid guid
public int lcid
public SYSKIND syskind
public short wMajorVerNum
public short wMinorVerNum
public LIBFLAGS wLibFlags
}
public System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
public int memid
public string lpstrSchema
public DESCUNION desc
public ELEMDESC elemdescVar
public short wVarFlags
public VARKIND varkind
}
public System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
public int value__
public VARFLAGS VARFLAG_FREADONLY
public VARFLAGS VARFLAG_FSOURCE
public VARFLAGS VARFLAG_FBINDABLE
public VARFLAGS VARFLAG_FREQUESTEDIT
public VARFLAGS VARFLAG_FDISPLAYBIND
public VARFLAGS VARFLAG_FDEFAULTBIND
public VARFLAGS VARFLAG_FHIDDEN
public VARFLAGS VARFLAG_FRESTRICTED
public VARFLAGS VARFLAG_FDEFAULTCOLLELEM
public VARFLAGS VARFLAG_FUIDEFAULT
public VARFLAGS VARFLAG_FNONBROWSABLE
public VARFLAGS VARFLAG_FREPLACEABLE
public VARFLAGS VARFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
public int value__
public VARKIND VAR_PERINSTANCE
public VARKIND VAR_STATIC
public VARKIND VAR_CONST
public VARKIND VAR_DISPATCH
}
public System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
private bool Visible
public bool Value
public void .ctor(bool visibility)
public bool get_Value()
}
public System.Runtime.InteropServices.CONNECTDATA : ValueType {
public object pUnk
public int dwCookie
}
public System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
protected IntPtr handle
private bool _disposed
public bool IsClosed
public bool IsInvalid
protected void .ctor(IntPtr invalidHandleValue)
protected void Finalize()
public void Close()
public void Dispose()
protected void Dispose(bool disposing)
protected bool ReleaseHandle()
protected void SetHandle(IntPtr handle)
public void SetHandleAsInvalid()
public bool get_IsClosed()
public bool get_IsInvalid()
}
public System.Runtime.InteropServices.CurrencyWrapper : object {
private decimal currency
public decimal WrappedObject
public void .ctor(decimal obj)
public void .ctor(object obj)
public decimal get_WrappedObject()
}
public System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
private CharSet _set
public CharSet CharSet
public void .ctor(CharSet charSet)
public CharSet get_CharSet()
}
public System.Runtime.InteropServices.DESCKIND : Enum {
public int value__
public DESCKIND DESCKIND_NONE
public DESCKIND DESCKIND_FUNCDESC
public DESCKIND DESCKIND_VARDESC
public DESCKIND DESCKIND_TYPECOMP
public DESCKIND DESCKIND_IMPLICITAPPOBJ
public DESCKIND DESCKIND_MAX
}
public System.Runtime.InteropServices.DispatchWrapper : object {
private object wrappedObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.InteropServices.DispIdAttribute : Attribute {
private int id
public int Value
public void .ctor(int dispId)
public int get_Value()
}
public System.Runtime.InteropServices.DISPPARAMS : ValueType {
public IntPtr rgvarg
public IntPtr rgdispidNamedArgs
public int cArgs
public int cNamedArgs
}
public System.Runtime.InteropServices.DllImportAttribute : Attribute {
public CallingConvention CallingConvention
public CharSet CharSet
private string Dll
public string EntryPoint
public bool ExactSpelling
public bool PreserveSig
public bool SetLastError
public bool BestFitMapping
public bool ThrowOnUnmappableChar
public string Value
public void .ctor(string dllName)
public string get_Value()
}
public System.Runtime.InteropServices.ELEMDESC : ValueType {
public TYPEDESC tdesc
public DESCUNION desc
}
public System.Runtime.InteropServices.ErrorWrapper : object {
private int errorCode
public int ErrorCode
public void .ctor(Exception e)
public void .ctor(int errorCode)
public void .ctor(object errorCode)
public int get_ErrorCode()
}
public System.Runtime.InteropServices.EXCEPINFO : ValueType {
public short wCode
public short wReserved
public string bstrSource
public string bstrDescription
public string bstrHelpFile
public int dwHelpContext
public IntPtr pvReserved
public IntPtr pfnDeferredFillIn
}
public System.Runtime.InteropServices.Expando.IExpando {
public FieldInfo AddField(string name)
public MethodInfo AddMethod(string name, Delegate method)
public PropertyInfo AddProperty(string name)
public void RemoveMember(MemberInfo m)
}
public System.Runtime.InteropServices.ExporterEventKind : Enum {
public int value__
public ExporterEventKind NOTIF_TYPECONVERTED
public ExporterEventKind NOTIF_CONVERTWARNING
public ExporterEventKind ERROR_REFTOINVALIDASSEMBLY
}
public System.Runtime.InteropServices.ExtensibleClassFactory : object {
private Hashtable hashtable
internal ObjectCreationDelegate GetObjectCreationCallback(Type t)
public void RegisterObjectCreationCallback(ObjectCreationDelegate callback)
}
public System.Runtime.InteropServices.ExternalException : SystemException {
public int ErrorCode
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, int errorCode)
public int get_ErrorCode()
}
public System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
private int val
public int Value
public void .ctor(int offset)
public int get_Value()
}
public System.Runtime.InteropServices.FILETIME : ValueType {
public int dwLowDateTime
public int dwHighDateTime
}
public System.Runtime.InteropServices.FUNCDESC : ValueType {
public int memid
public IntPtr lprgscode
public IntPtr lprgelemdescParam
public FUNCKIND funckind
public INVOKEKIND invkind
public CALLCONV callconv
public short cParams
public short cParamsOpt
public short oVft
public short cScodes
public ELEMDESC elemdescFunc
public short wFuncFlags
}
public System.Runtime.InteropServices.FUNCFLAGS : Enum {
public int value__
public FUNCFLAGS FUNCFLAG_FRESTRICTED
public FUNCFLAGS FUNCFLAG_FSOURCE
public FUNCFLAGS FUNCFLAG_FBINDABLE
public FUNCFLAGS FUNCFLAG_FREQUESTEDIT
public FUNCFLAGS FUNCFLAG_FDISPLAYBIND
public FUNCFLAGS FUNCFLAG_FDEFAULTBIND
public FUNCFLAGS FUNCFLAG_FHIDDEN
public FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR
public FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM
public FUNCFLAGS FUNCFLAG_FUIDEFAULT
public FUNCFLAGS FUNCFLAG_FNONBROWSABLE
public FUNCFLAGS FUNCFLAG_FREPLACEABLE
public FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.FUNCKIND : Enum {
public int value__
public FUNCKIND FUNC_VIRTUAL
public FUNCKIND FUNC_PUREVIRTUAL
public FUNCKIND FUNC_NONVIRTUAL
public FUNCKIND FUNC_STATIC
public FUNCKIND FUNC_DISPATCH
}
public System.Runtime.InteropServices.GCHandle : ValueType {
private int handle
public bool IsAllocated
public object Target
private void .ctor(IntPtr h)
private void .ctor(object obj)
private void .ctor(object value, GCHandleType type)
public bool get_IsAllocated()
public object get_Target()
public void set_Target(object value)
public IntPtr AddrOfPinnedObject()
public GCHandle Alloc(object value)
public GCHandle Alloc(object value, GCHandleType type)
public void Free()
private bool CheckCurrentDomain(int handle)
private object GetTarget(int handle)
private int GetTargetHandle(object obj, int handle, GCHandleType type)
private void FreeHandle(int handle)
private IntPtr GetAddrOfPinnedObject(int handle)
public bool Equals(object o)
public int GetHashCode()
public GCHandle FromIntPtr(IntPtr value)
public IntPtr ToIntPtr(GCHandle value)
public IntPtr op_Explicit(GCHandle value)
public GCHandle op_Explicit(IntPtr value)
public bool op_Equality(GCHandle a, GCHandle b)
public bool op_Inequality(GCHandle a, GCHandle b)
}
public System.Runtime.InteropServices.GCHandleType : Enum {
public int value__
public GCHandleType Weak
public GCHandleType WeakTrackResurrection
public GCHandleType Normal
public GCHandleType Pinned
}
public System.Runtime.InteropServices.GuidAttribute : Attribute {
private string guidValue
public string Value
public void .ctor(string guid)
public string get_Value()
}
public System.Runtime.InteropServices.HandleRef : ValueType {
private object wrapper
private IntPtr handle
public IntPtr Handle
public object Wrapper
public void .ctor(object wrapper, IntPtr handle)
public IntPtr get_Handle()
public object get_Wrapper()
public IntPtr ToIntPtr(HandleRef value)
public IntPtr op_Explicit(HandleRef value)
}
public System.Runtime.InteropServices.ICustomAdapter {
public object GetUnderlyingObject()
}
public System.Runtime.InteropServices.ICustomFactory {
public MarshalByRefObject CreateInstance(Type serverType)
}
public System.Runtime.InteropServices.ICustomMarshaler {
public void CleanUpManagedData(object ManagedObj)
public void CleanUpNativeData(IntPtr pNativeData)
public int GetNativeDataSize()
public IntPtr MarshalManagedToNative(object ManagedObj)
public object MarshalNativeToManaged(IntPtr pNativeData)
}
public System.Runtime.InteropServices.IDispatchImplAttribute : Attribute {
private IDispatchImplType Impl
public IDispatchImplType Value
public void .ctor(IDispatchImplType implType)
public void .ctor(short implType)
public IDispatchImplType get_Value()
}
public System.Runtime.InteropServices.IDispatchImplType : Enum {
public int value__
public IDispatchImplType SystemDefinedImpl
public IDispatchImplType InternalImpl
public IDispatchImplType CompatibleImpl
}
public System.Runtime.InteropServices.IDLDESC : ValueType {
public int dwReserved
public IDLFLAG wIDLFlags
}
public System.Runtime.InteropServices.IDLFLAG : Enum {
public int value__
public IDLFLAG IDLFLAG_NONE
public IDLFLAG IDLFLAG_FIN
public IDLFLAG IDLFLAG_FOUT
public IDLFLAG IDLFLAG_FLCID
public IDLFLAG IDLFLAG_FRETVAL
}
public System.Runtime.InteropServices.IMPLTYPEFLAGS : Enum {
public int value__
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT
public IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE
public IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED
public IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE
}
public System.Runtime.InteropServices.ImportedFromTypeLibAttribute : Attribute {
private string TlbFile
public string Value
public void .ctor(string tlbFile)
public string get_Value()
}
public System.Runtime.InteropServices.ImporterEventKind : Enum {
public int value__
public ImporterEventKind NOTIF_TYPECONVERTED
public ImporterEventKind NOTIF_CONVERTWARNING
public ImporterEventKind ERROR_REFTOINVALIDTYPELIB
}
public System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
private ComInterfaceType intType
public ComInterfaceType Value
public void .ctor(ComInterfaceType interfaceType)
public void .ctor(short interfaceType)
public ComInterfaceType get_Value()
}
public System.Runtime.InteropServices.InvalidComObjectException : SystemException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.INVOKEKIND : Enum {
public int value__
public INVOKEKIND INVOKE_FUNC
public INVOKEKIND INVOKE_PROPERTYGET
public INVOKEKIND INVOKE_PROPERTYPUT
public INVOKEKIND INVOKE_PROPERTYPUTREF
}
public System.Runtime.InteropServices.IRegistrationServices {
public Guid GetManagedCategoryGuid()
public string GetProgIdForType(Type type)
public Type[] GetRegistrableTypesInAssembly(Assembly assembly)
public bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags)
public void RegisterTypeForComClients(Type type, Guid& g)
public bool TypeRepresentsComType(Type type)
public bool TypeRequiresRegistration(Type type)
public bool UnregisterAssembly(Assembly assembly)
}
public System.Runtime.InteropServices.ITypeLibConverter {
public object ConvertAssemblyToTypeLib(Assembly assembly, string typeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion)
public bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase)
}
public System.Runtime.InteropServices.ITypeLibExporterNameProvider {
public String[] GetNames()
}
public System.Runtime.InteropServices.ITypeLibExporterNotifySink {
public void ReportEvent(ExporterEventKind eventKind, int eventCode, string eventMsg)
public object ResolveRef(Assembly assembly)
}
public System.Runtime.InteropServices.ITypeLibImporterNotifySink {
public void ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg)
public Assembly ResolveRef(object typeLib)
}
public System.Runtime.InteropServices.LayoutKind : Enum {
public int value__
public LayoutKind Sequential
public LayoutKind Explicit
public LayoutKind Auto
}
public System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
private int id
public int Value
public void .ctor(int lcid)
public int get_Value()
}
public System.Runtime.InteropServices.LIBFLAGS : Enum {
public int value__
public LIBFLAGS LIBFLAG_FRESTRICTED
public LIBFLAGS LIBFLAG_FCONTROL
public LIBFLAGS LIBFLAG_FHIDDEN
public LIBFLAGS LIBFLAG_FHASDISKIMAGE
}
public System.Runtime.InteropServices.Marshal : object {
public int SystemMaxDBCSCharSize
public int SystemDefaultCharSize
private int AddRefInternal(IntPtr pUnk)
public int AddRef(IntPtr pUnk)
public IntPtr AllocCoTaskMem(int cb)
public IntPtr AllocHGlobal(IntPtr cb)
public IntPtr AllocHGlobal(int cb)
public object BindToMoniker(string monikerName)
public void ChangeWrapperHandleStrength(object otp, bool fIsWeak)
private void copy_to_unmanaged(Array source, int startIndex, IntPtr destination, int length)
private void copy_from_unmanaged(IntPtr source, int startIndex, Array destination, int length)
public void Copy(Byte[] source, int startIndex, IntPtr destination, int length)
public void Copy(Char[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int16[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int32[] source, int startIndex, IntPtr destination, int length)
public void Copy(Int64[] source, int startIndex, IntPtr destination, int length)
public void Copy(Single[] source, int startIndex, IntPtr destination, int length)
public void Copy(Double[] source, int startIndex, IntPtr destination, int length)
public void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length)
public void Copy(IntPtr source, Byte[] destination, int startIndex, int length)
public void Copy(IntPtr source, Char[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int16[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int32[] destination, int startIndex, int length)
public void Copy(IntPtr source, Int64[] destination, int startIndex, int length)
public void Copy(IntPtr source, Single[] destination, int startIndex, int length)
public void Copy(IntPtr source, Double[] destination, int startIndex, int length)
public void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length)
public IntPtr CreateAggregatedObject(IntPtr pOuter, object o)
public object CreateWrapperOfType(object o, Type t)
public void DestroyStructure(IntPtr ptr, Type structuretype)
public void FreeBSTR(IntPtr ptr)
public void FreeCoTaskMem(IntPtr ptr)
public void FreeHGlobal(IntPtr hglobal)
private void ClearBSTR(IntPtr ptr)
public void ZeroFreeBSTR(IntPtr s)
private void ClearAnsi(IntPtr ptr)
private void ClearUnicode(IntPtr ptr)
public void ZeroFreeCoTaskMemAnsi(IntPtr s)
public void ZeroFreeCoTaskMemUnicode(IntPtr s)
public void ZeroFreeGlobalAllocAnsi(IntPtr s)
public void ZeroFreeGlobalAllocUnicode(IntPtr s)
public Guid GenerateGuidForType(Type type)
public string GenerateProgIdForType(Type type)
public object GetActiveObject(string progID)
private IntPtr GetCCW(object o, Type T)
private IntPtr GetComInterfaceForObjectInternal(object o, Type T)
public IntPtr GetComInterfaceForObject(object o, Type T)
public IntPtr GetComInterfaceForObjectInContext(object o, Type t)
public object GetComObjectData(object obj, object key)
private int GetComSlotForMethodInfoInternal(MemberInfo m)
public int GetComSlotForMethodInfo(MemberInfo m)
public int GetEndComSlot(Type t)
public int GetExceptionCode()
public IntPtr GetExceptionPointers()
public IntPtr GetHINSTANCE(Module m)
public int GetHRForException(Exception e)
public int GetHRForLastWin32Error()
private IntPtr GetIDispatchForObjectInternal(object o)
public IntPtr GetIDispatchForObject(object o)
public IntPtr GetIDispatchForObjectInContext(object o)
public IntPtr GetITypeInfoForType(Type t)
private IntPtr GetIUnknownForObjectInternal(object o)
public IntPtr GetIUnknownForObject(object o)
public IntPtr GetIUnknownForObjectInContext(object o)
public IntPtr GetManagedThunkForUnmanagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature)
public MemberInfo GetMethodInfoForComSlot(Type t, int slot, ComMemberType& memberType)
public void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant)
private object GetObjectForCCW(IntPtr pUnk)
public object GetObjectForIUnknown(IntPtr pUnk)
public object GetObjectForNativeVariant(IntPtr pSrcNativeVariant)
public Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars)
public int GetStartComSlot(Type t)
public Thread GetThreadFromFiberCookie(int cookie)
public object GetTypedObjectForIUnknown(IntPtr pUnk, Type t)
public Type GetTypeForITypeInfo(IntPtr piTypeInfo)
public string GetTypeInfoName(UCOMITypeInfo pTI)
public string GetTypeInfoName(ITypeInfo typeInfo)
public Guid GetTypeLibGuid(UCOMITypeLib pTLB)
public Guid GetTypeLibGuid(ITypeLib typelib)
public Guid GetTypeLibGuidForAssembly(Assembly asm)
public int GetTypeLibLcid(UCOMITypeLib pTLB)
public int GetTypeLibLcid(ITypeLib typelib)
public string GetTypeLibName(UCOMITypeLib pTLB)
public string GetTypeLibName(ITypeLib typelib)
public void GetTypeLibVersionForAssembly(Assembly inputAssembly, Int32& majorVersion, Int32& minorVersion)
public object GetUniqueObjectForIUnknown(IntPtr unknown)
public IntPtr GetUnmanagedThunkForManagedMethodPtr(IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature)
public bool IsComObject(object o)
public bool IsTypeVisibleFromCom(Type t)
public int NumParamBytes(MethodInfo m)
public int GetLastWin32Error()
public IntPtr OffsetOf(Type t, string fieldName)
public void Prelink(MethodInfo m)
public void PrelinkAll(Type c)
public string PtrToStringAnsi(IntPtr ptr)
public string PtrToStringAnsi(IntPtr ptr, int len)
public string PtrToStringAuto(IntPtr ptr)
public string PtrToStringAuto(IntPtr ptr, int len)
public string PtrToStringUni(IntPtr ptr)
public string PtrToStringUni(IntPtr ptr, int len)
public string PtrToStringBSTR(IntPtr ptr)
public void PtrToStructure(IntPtr ptr, object structure)
public object PtrToStructure(IntPtr ptr, Type structureType)
private int QueryInterfaceInternal(IntPtr pUnk, Guid& iid, IntPtr& ppv)
public int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv)
public byte ReadByte(IntPtr ptr)
public byte ReadByte(IntPtr ptr, int ofs)
public byte ReadByte(object ptr, int ofs)
public short ReadInt16(IntPtr ptr)
public short ReadInt16(IntPtr ptr, int ofs)
public short ReadInt16(object ptr, int ofs)
public int ReadInt32(IntPtr ptr)
public int ReadInt32(IntPtr ptr, int ofs)
public int ReadInt32(object ptr, int ofs)
public long ReadInt64(IntPtr ptr)
public long ReadInt64(IntPtr ptr, int ofs)
public long ReadInt64(object ptr, int ofs)
public IntPtr ReadIntPtr(IntPtr ptr)
public IntPtr ReadIntPtr(IntPtr ptr, int ofs)
public IntPtr ReadIntPtr(object ptr, int ofs)
public IntPtr ReAllocCoTaskMem(IntPtr pv, int cb)
public IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb)
private int ReleaseInternal(IntPtr pUnk)
public int Release(IntPtr pUnk)
private int ReleaseComObjectInternal(object co)
public int ReleaseComObject(object o)
public void ReleaseThreadCache()
public bool SetComObjectData(object obj, object key, object data)
public int SizeOf(object structure)
public int SizeOf(Type t)
public IntPtr StringToBSTR(string s)
public IntPtr StringToCoTaskMemAnsi(string s)
public IntPtr StringToCoTaskMemAuto(string s)
public IntPtr StringToCoTaskMemUni(string s)
public IntPtr StringToHGlobalAnsi(string s)
public IntPtr StringToHGlobalAuto(string s)
public IntPtr StringToHGlobalUni(string s)
public IntPtr SecureStringToBSTR(SecureString s)
public IntPtr SecureStringToCoTaskMemAnsi(SecureString s)
public IntPtr SecureStringToCoTaskMemUnicode(SecureString s)
public IntPtr SecureStringToGlobalAllocAnsi(SecureString s)
public IntPtr SecureStringToGlobalAllocUnicode(SecureString s)
public void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld)
public void ThrowExceptionForHR(int errorCode)
public void ThrowExceptionForHR(int errorCode, IntPtr errorInfo)
public IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index)
public void WriteByte(IntPtr ptr, byte val)
public void WriteByte(IntPtr ptr, int ofs, byte val)
public void WriteByte(object ptr, int ofs, byte val)
public void WriteInt16(IntPtr ptr, short val)
public void WriteInt16(IntPtr ptr, int ofs, short val)
public void WriteInt16(object ptr, int ofs, short val)
public void WriteInt16(IntPtr ptr, char val)
public void WriteInt16(IntPtr ptr, int ofs, char val)
public void WriteInt16(object ptr, int ofs, char val)
public void WriteInt32(IntPtr ptr, int val)
public void WriteInt32(IntPtr ptr, int ofs, int val)
public void WriteInt32(object ptr, int ofs, int val)
public void WriteInt64(IntPtr ptr, long val)
public void WriteInt64(IntPtr ptr, int ofs, long val)
public void WriteInt64(object ptr, int ofs, long val)
public void WriteIntPtr(IntPtr ptr, IntPtr val)
public void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val)
public void WriteIntPtr(object ptr, int ofs, IntPtr val)
public Exception GetExceptionForHR(int errorCode)
public Exception GetExceptionForHR(int errorCode, IntPtr errorInfo)
public int FinalReleaseComObject(object o)
private Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t)
public Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t)
private IntPtr GetFunctionPointerForDelegateInternal(Delegate d)
public IntPtr GetFunctionPointerForDelegate(Delegate d)
}
public System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
private UnmanagedType utype
public UnmanagedType ArraySubType
public string MarshalCookie
public string MarshalType
public Type MarshalTypeRef
public VarEnum SafeArraySubType
public int SizeConst
public short SizeParamIndex
public Type SafeArrayUserDefinedSubType
public int IidParameterIndex
public UnmanagedType Value
public void .ctor(short unmanagedType)
public void .ctor(UnmanagedType unmanagedType)
public UnmanagedType get_Value()
}
public System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.ObjectCreationDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public IntPtr Invoke(IntPtr aggregator)
public IAsyncResult BeginInvoke(IntPtr aggregator, AsyncCallback callback, object object)
public IntPtr EndInvoke(IAsyncResult result)
}
public System.Runtime.InteropServices.PARAMDESC : ValueType {
public IntPtr lpVarValue
public PARAMFLAG wParamFlags
}
public System.Runtime.InteropServices.PARAMFLAG : Enum {
public int value__
public PARAMFLAG PARAMFLAG_NONE
public PARAMFLAG PARAMFLAG_FIN
public PARAMFLAG PARAMFLAG_FOUT
public PARAMFLAG PARAMFLAG_FLCID
public PARAMFLAG PARAMFLAG_FRETVAL
public PARAMFLAG PARAMFLAG_FOPT
public PARAMFLAG PARAMFLAG_FHASDEFAULT
public PARAMFLAG PARAMFLAG_FHASCUSTDATA
}
public System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute : Attribute {
private int major
private int minor
public int MajorVersion
public int MinorVersion
public void .ctor(int major, int minor)
public int get_MajorVersion()
public int get_MinorVersion()
}
public System.Runtime.InteropServices.ProgIdAttribute : Attribute {
private string pid
public string Value
public void .ctor(string progId)
public string get_Value()
}
public System.Runtime.InteropServices.RegistrationClassContext : Enum {
public int value__
public RegistrationClassContext DisableActivateAsActivator
public RegistrationClassContext EnableActivateAsActivator
public RegistrationClassContext EnableCodeDownload
public RegistrationClassContext FromDefaultContext
public RegistrationClassContext InProcessHandler
public RegistrationClassContext InProcessHandler16
public RegistrationClassContext InProcessServer
public RegistrationClassContext InProcessServer16
public RegistrationClassContext LocalServer
public RegistrationClassContext NoCodeDownload
public RegistrationClassContext NoCustomMarshal
public RegistrationClassContext NoFailureLog
public RegistrationClassContext RemoteServer
public RegistrationClassContext Reserved1
public RegistrationClassContext Reserved2
public RegistrationClassContext Reserved3
public RegistrationClassContext Reserved4
public RegistrationClassContext Reserved5
}
public System.Runtime.InteropServices.RegistrationConnectionType : Enum {
public int value__
public RegistrationConnectionType MultipleUse
public RegistrationConnectionType MultiSeparate
public RegistrationConnectionType SingleUse
public RegistrationConnectionType Suspended
public RegistrationConnectionType Surrogate
}
public System.Runtime.InteropServices.RegistrationServices : object {
public Guid GetManagedCategoryGuid()
public string GetProgIdForType(Type type)
public Type[] GetRegistrableTypesInAssembly(Assembly assembly)
public bool RegisterAssembly(Assembly assembly, AssemblyRegistrationFlags flags)
public void RegisterTypeForComClients(Type type, Guid& g)
public bool TypeRepresentsComType(Type type)
public bool TypeRequiresRegistration(Type type)
public bool UnregisterAssembly(Assembly assembly)
public int RegisterTypeForComClients(Type type, RegistrationClassContext classContext, RegistrationConnectionType flags)
public void UnregisterTypeForComClients(int cookie)
}
public System.Runtime.InteropServices.RuntimeEnvironment : object {
public string SystemConfigurationFile
public string get_SystemConfigurationFile()
public bool FromGlobalAccessCache(Assembly a)
public string GetRuntimeDirectory()
public string GetSystemVersion()
}
public System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
private int ErrorCode
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
protected IntPtr handle
private IntPtr invalid_handle_value
private int refcount
private bool owns_handle
public bool IsClosed
public bool IsInvalid
protected void .ctor(IntPtr invalidHandleValue, bool ownsHandle)
public void Close()
public void DangerousAddRef(Boolean& success)
public IntPtr DangerousGetHandle()
public void DangerousRelease()
public void Dispose()
public void SetHandleAsInvalid()
protected void Dispose(bool disposing)
protected bool ReleaseHandle()
protected void SetHandle(IntPtr handle)
public bool get_IsClosed()
public bool get_IsInvalid()
protected void Finalize()
}
public System.Runtime.InteropServices.SEHException : ExternalException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
public bool CanResume()
}
public System.Runtime.InteropServices.STATSTG : ValueType {
public string pwcsName
public int type
public long cbSize
public FILETIME mtime
public FILETIME ctime
public FILETIME atime
public int grfMode
public int grfLocksSupported
public Guid clsid
public int grfStateBits
public int reserved
}
public System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
public CharSet CharSet
public int Pack
public int Size
private LayoutKind lkind
public LayoutKind Value
public void .ctor(short layoutKind)
public void .ctor(LayoutKind layoutKind)
public LayoutKind get_Value()
}
public System.Runtime.InteropServices.SYSKIND : Enum {
public int value__
public SYSKIND SYS_WIN16
public SYSKIND SYS_WIN32
public SYSKIND SYS_MAC
}
public System.Runtime.InteropServices.TYPEATTR : ValueType {
public int MEMBER_ID_NIL
public Guid guid
public int lcid
public int dwReserved
public int memidConstructor
public int memidDestructor
public IntPtr lpstrSchema
public int cbSizeInstance
public TYPEKIND typekind
public short cFuncs
public short cVars
public short cImplTypes
public short cbSizeVft
public short cbAlignment
public TYPEFLAGS wTypeFlags
public short wMajorVerNum
public short wMinorVerNum
public TYPEDESC tdescAlias
public IDLDESC idldescType
}
public System.Runtime.InteropServices.TYPEDESC : ValueType {
public IntPtr lpValue
public short vt
}
public System.Runtime.InteropServices.TYPEFLAGS : Enum {
public int value__
public TYPEFLAGS TYPEFLAG_FAPPOBJECT
public TYPEFLAGS TYPEFLAG_FCANCREATE
public TYPEFLAGS TYPEFLAG_FLICENSED
public TYPEFLAGS TYPEFLAG_FPREDECLID
public TYPEFLAGS TYPEFLAG_FHIDDEN
public TYPEFLAGS TYPEFLAG_FCONTROL
public TYPEFLAGS TYPEFLAG_FDUAL
public TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE
public TYPEFLAGS TYPEFLAG_FOLEAUTOMATION
public TYPEFLAGS TYPEFLAG_FRESTRICTED
public TYPEFLAGS TYPEFLAG_FAGGREGATABLE
public TYPEFLAGS TYPEFLAG_FREPLACEABLE
public TYPEFLAGS TYPEFLAG_FDISPATCHABLE
public TYPEFLAGS TYPEFLAG_FREVERSEBIND
public TYPEFLAGS TYPEFLAG_FPROXY
}
public System.Runtime.InteropServices.TYPEKIND : Enum {
public int value__
public TYPEKIND TKIND_ENUM
public TYPEKIND TKIND_RECORD
public TYPEKIND TKIND_MODULE
public TYPEKIND TKIND_INTERFACE
public TYPEKIND TKIND_DISPATCH
public TYPEKIND TKIND_COCLASS
public TYPEKIND TKIND_ALIAS
public TYPEKIND TKIND_UNION
public TYPEKIND TKIND_MAX
}
public System.Runtime.InteropServices.TYPELIBATTR : ValueType {
public Guid guid
public int lcid
public SYSKIND syskind
public short wMajorVerNum
public short wMinorVerNum
public LIBFLAGS wLibFlags
}
public System.Runtime.InteropServices.TypeLibConverter : object {
public object ConvertAssemblyToTypeLib(Assembly assembly, string strTypeLibName, TypeLibExporterFlags flags, ITypeLibExporterNotifySink notifySink)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, bool unsafeInterfaces)
public AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, TypeLibImporterFlags flags, ITypeLibImporterNotifySink notifySink, Byte[] publicKey, StrongNameKeyPair keyPair, string asmNamespace, Version asmVersion)
public bool GetPrimaryInteropAssembly(Guid g, int major, int minor, int lcid, String& asmName, String& asmCodeBase)
}
public System.Runtime.InteropServices.TypeLibExporterFlags : Enum {
public int value__
public TypeLibExporterFlags OnlyReferenceRegistered
public TypeLibExporterFlags None
public TypeLibExporterFlags CallerResolvedReferences
public TypeLibExporterFlags OldNames
public TypeLibExporterFlags ExportAs32Bit
public TypeLibExporterFlags ExportAs64Bit
}
public System.Runtime.InteropServices.TypeLibFuncAttribute : Attribute {
private TypeLibFuncFlags flags
public TypeLibFuncFlags Value
public void .ctor(short flags)
public void .ctor(TypeLibFuncFlags flags)
public TypeLibFuncFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibFuncFlags : Enum {
public int value__
public TypeLibFuncFlags FRestricted
public TypeLibFuncFlags FSource
public TypeLibFuncFlags FBindable
public TypeLibFuncFlags FRequestEdit
public TypeLibFuncFlags FDisplayBind
public TypeLibFuncFlags FDefaultBind
public TypeLibFuncFlags FHidden
public TypeLibFuncFlags FUsesGetLastError
public TypeLibFuncFlags FDefaultCollelem
public TypeLibFuncFlags FUiDefault
public TypeLibFuncFlags FNonBrowsable
public TypeLibFuncFlags FReplaceable
public TypeLibFuncFlags FImmediateBind
}
public System.Runtime.InteropServices.TypeLibImportClassAttribute : Attribute {
private string _importClass
public string Value
public void .ctor(Type importClass)
public string get_Value()
}
public System.Runtime.InteropServices.TypeLibImporterFlags : Enum {
public int value__
public TypeLibImporterFlags PrimaryInteropAssembly
public TypeLibImporterFlags UnsafeInterfaces
public TypeLibImporterFlags SafeArrayAsSystemArray
public TypeLibImporterFlags TransformDispRetVals
public TypeLibImporterFlags None
public TypeLibImporterFlags PreventClassMembers
public TypeLibImporterFlags ImportAsAgnostic
public TypeLibImporterFlags ImportAsItanium
public TypeLibImporterFlags ImportAsX64
public TypeLibImporterFlags ImportAsX86
public TypeLibImporterFlags ReflectionOnlyLoading
public TypeLibImporterFlags SerializableValueClasses
}
public System.Runtime.InteropServices.TypeLibTypeAttribute : Attribute {
private TypeLibTypeFlags flags
public TypeLibTypeFlags Value
public void .ctor(short flags)
public void .ctor(TypeLibTypeFlags flags)
public TypeLibTypeFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibTypeFlags : Enum {
public int value__
public TypeLibTypeFlags FAppObject
public TypeLibTypeFlags FCanCreate
public TypeLibTypeFlags FLicensed
public TypeLibTypeFlags FPreDeclId
public TypeLibTypeFlags FHidden
public TypeLibTypeFlags FControl
public TypeLibTypeFlags FDual
public TypeLibTypeFlags FNonExtensible
public TypeLibTypeFlags FOleAutomation
public TypeLibTypeFlags FRestricted
public TypeLibTypeFlags FAggregatable
public TypeLibTypeFlags FReplaceable
public TypeLibTypeFlags FDispatchable
public TypeLibTypeFlags FReverseBind
}
public System.Runtime.InteropServices.TypeLibVarAttribute : Attribute {
private TypeLibVarFlags flags
public TypeLibVarFlags Value
public void .ctor(short flags)
public void .ctor(TypeLibVarFlags flags)
public TypeLibVarFlags get_Value()
}
public System.Runtime.InteropServices.TypeLibVarFlags : Enum {
public int value__
public TypeLibVarFlags FReadOnly
public TypeLibVarFlags FSource
public TypeLibVarFlags FBindable
public TypeLibVarFlags FRequestEdit
public TypeLibVarFlags FDisplayBind
public TypeLibVarFlags FDefaultBind
public TypeLibVarFlags FHidden
public TypeLibVarFlags FRestricted
public TypeLibVarFlags FDefaultCollelem
public TypeLibVarFlags FUiDefault
public TypeLibVarFlags FNonBrowsable
public TypeLibVarFlags FReplaceable
public TypeLibVarFlags FImmediateBind
}
public System.Runtime.InteropServices.TypeLibVersionAttribute : Attribute {
private int major
private int minor
public int MajorVersion
public int MinorVersion
public void .ctor(int major, int minor)
public int get_MajorVersion()
public int get_MinorVersion()
}
public System.Runtime.InteropServices.UCOMIBindCtx {
public void RegisterObjectBound(object punk)
public void RevokeObjectBound(object punk)
public void ReleaseBoundObjects()
public void SetBindOptions(BIND_OPTS& pbindopts)
public void GetBindOptions(BIND_OPTS& pbindopts)
public void GetRunningObjectTable(UCOMIRunningObjectTable& pprot)
public void RegisterObjectParam(string pszKey, object punk)
public void GetObjectParam(string pszKey, Object& ppunk)
public void EnumObjectParam(UCOMIEnumString& ppenum)
public void RevokeObjectParam(string pszKey)
}
public System.Runtime.InteropServices.UCOMIConnectionPoint {
public void GetConnectionInterface(Guid& pIID)
public void GetConnectionPointContainer(UCOMIConnectionPointContainer& ppCPC)
public void Advise(object pUnkSink, Int32& pdwCookie)
public void Unadvise(int dwCookie)
public void EnumConnections(UCOMIEnumConnections& ppEnum)
}
public System.Runtime.InteropServices.UCOMIConnectionPointContainer {
public void EnumConnectionPoints(UCOMIEnumConnectionPoints& ppEnum)
public void FindConnectionPoint(Guid& riid, UCOMIConnectionPoint& ppCP)
}
public System.Runtime.InteropServices.UCOMIEnumConnectionPoints {
public int Next(int celt, UCOMIConnectionPoint[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumConnectionPoints& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumConnections {
public int Next(int celt, CONNECTDATA[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public void Reset()
public void Clone(UCOMIEnumConnections& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumMoniker {
public int Next(int celt, UCOMIMoniker[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumMoniker& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumString {
public int Next(int celt, String[] rgelt, Int32& pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(UCOMIEnumString& ppenum)
}
public System.Runtime.InteropServices.UCOMIEnumVARIANT {
public int Next(int celt, int rgvar, int pceltFetched)
public int Skip(int celt)
public int Reset()
public void Clone(int ppenum)
}
public System.Runtime.InteropServices.UCOMIMoniker {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(UCOMIStream pStm)
public void Save(UCOMIStream pStm, bool fClearDirty)
public void GetSizeMax(Int64& pcbSize)
public void BindToObject(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riidResult, Object& ppvResult)
public void BindToStorage(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, Guid& riid, Object& ppvObj)
public void Reduce(UCOMIBindCtx pbc, int dwReduceHowFar, UCOMIMoniker& ppmkToLeft, UCOMIMoniker& ppmkReduced)
public void ComposeWith(UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, UCOMIMoniker& ppmkComposite)
public void Enum(bool fForward, UCOMIEnumMoniker& ppenumMoniker)
public void IsEqual(UCOMIMoniker pmkOtherMoniker)
public void Hash(Int32& pdwHash)
public void IsRunning(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, UCOMIMoniker pmkNewlyRunning)
public void GetTimeOfLastChange(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, FILETIME& pFileTime)
public void Inverse(UCOMIMoniker& ppmk)
public void CommonPrefixWith(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkPrefix)
public void RelativePathTo(UCOMIMoniker pmkOther, UCOMIMoniker& ppmkRelPath)
public void GetDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, String& ppszDisplayName)
public void ParseDisplayName(UCOMIBindCtx pbc, UCOMIMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, UCOMIMoniker& ppmkOut)
public void IsSystemMoniker(Int32& pdwMksys)
}
public System.Runtime.InteropServices.UCOMIPersistFile {
public void GetClassID(Guid& pClassID)
public int IsDirty()
public void Load(string pszFileName, int dwMode)
public void Save(string pszFileName, bool fRemember)
public void SaveCompleted(string pszFileName)
public void GetCurFile(String& ppszFileName)
}
public System.Runtime.InteropServices.UCOMIRunningObjectTable {
public void Register(int grfFlags, object punkObject, UCOMIMoniker pmkObjectName, Int32& pdwRegister)
public void Revoke(int dwRegister)
public void IsRunning(UCOMIMoniker pmkObjectName)
public void GetObject(UCOMIMoniker pmkObjectName, Object& ppunkObject)
public void NoteChangeTime(int dwRegister, FILETIME& pfiletime)
public void GetTimeOfLastChange(UCOMIMoniker pmkObjectName, FILETIME& pfiletime)
public void EnumRunning(UCOMIEnumMoniker& ppenumMoniker)
}
public System.Runtime.InteropServices.UCOMIStream {
public void Read(Byte[] pv, int cb, IntPtr pcbRead)
public void Write(Byte[] pv, int cb, IntPtr pcbWritten)
public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition)
public void SetSize(long libNewSize)
public void CopyTo(UCOMIStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten)
public void Commit(int grfCommitFlags)
public void Revert()
public void LockRegion(long libOffset, long cb, int dwLockType)
public void UnlockRegion(long libOffset, long cb, int dwLockType)
public void Stat(STATSTG& pstatstg, int grfStatFlag)
public void Clone(UCOMIStream& ppstm)
}
public System.Runtime.InteropServices.UCOMITypeComp {
public void Bind(string szName, int lHashVal, short wFlags, UCOMITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr)
public void BindType(string szName, int lHashVal, UCOMITypeInfo& ppTInfo, UCOMITypeComp& ppTComp)
}
public System.Runtime.InteropServices.UCOMITypeInfo {
public void GetTypeAttr(IntPtr& ppTypeAttr)
public void GetTypeComp(UCOMITypeComp& ppTComp)
public void GetFuncDesc(int index, IntPtr& ppFuncDesc)
public void GetVarDesc(int index, IntPtr& ppVarDesc)
public void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames)
public void GetRefTypeOfImplType(int index, Int32& href)
public void GetImplTypeFlags(int index, Int32& pImplTypeFlags)
public void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId)
public void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, Object& pVarResult, EXCEPINFO& pExcepInfo, Int32& puArgErr)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public void GetDllEntry(int memid, INVOKEKIND invKind, String& pBstrDllName, String& pBstrName, Int16& pwOrdinal)
public void GetRefTypeInfo(int hRef, UCOMITypeInfo& ppTI)
public void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv)
public void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj)
public void GetMops(int memid, String& pBstrMops)
public void GetContainingTypeLib(UCOMITypeLib& ppTLB, Int32& pIndex)
public void ReleaseTypeAttr(IntPtr pTypeAttr)
public void ReleaseFuncDesc(IntPtr pFuncDesc)
public void ReleaseVarDesc(IntPtr pVarDesc)
}
public System.Runtime.InteropServices.UCOMITypeLib {
public int GetTypeInfoCount()
public void GetTypeInfo(int index, UCOMITypeInfo& ppTI)
public void GetTypeInfoType(int index, TYPEKIND& pTKind)
public void GetTypeInfoOfGuid(Guid& guid, UCOMITypeInfo& ppTInfo)
public void GetLibAttr(IntPtr& ppTLibAttr)
public void GetTypeComp(UCOMITypeComp& ppTComp)
public void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile)
public bool IsName(string szNameBuf, int lHashVal)
public void FindName(string szNameBuf, int lHashVal, UCOMITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound)
public void ReleaseTLibAttr(IntPtr pTLibAttr)
}
public System.Runtime.InteropServices.UnknownWrapper : object {
private object InternalObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
private CallingConvention call_conv
public CharSet CharSet
public bool SetLastError
public bool BestFitMapping
public bool ThrowOnUnmappableChar
public CallingConvention CallingConvention
public void .ctor(CallingConvention callingConvention)
public CallingConvention get_CallingConvention()
}
public System.Runtime.InteropServices.UnmanagedType : Enum {
public int value__
public UnmanagedType Bool
public UnmanagedType I1
public UnmanagedType U1
public UnmanagedType I2
public UnmanagedType U2
public UnmanagedType I4
public UnmanagedType U4
public UnmanagedType I8
public UnmanagedType U8
public UnmanagedType R4
public UnmanagedType R8
public UnmanagedType Currency
public UnmanagedType BStr
public UnmanagedType LPStr
public UnmanagedType LPWStr
public UnmanagedType LPTStr
public UnmanagedType ByValTStr
public UnmanagedType IUnknown
public UnmanagedType IDispatch
public UnmanagedType Struct
public UnmanagedType Interface
public UnmanagedType SafeArray
public UnmanagedType ByValArray
public UnmanagedType SysInt
public UnmanagedType SysUInt
public UnmanagedType VBByRefStr
public UnmanagedType AnsiBStr
public UnmanagedType TBStr
public UnmanagedType VariantBool
public UnmanagedType FunctionPtr
public UnmanagedType AsAny
public UnmanagedType LPArray
public UnmanagedType LPStruct
public UnmanagedType CustomMarshaler
public UnmanagedType Error
}
public System.Runtime.InteropServices.VARDESC : ValueType {
public int memid
public string lpstrSchema
public ELEMDESC elemdescVar
public short wVarFlags
public VarEnum varkind
}
public System.Runtime.InteropServices.VarEnum : Enum {
public int value__
public VarEnum VT_EMPTY
public VarEnum VT_NULL
public VarEnum VT_I2
public VarEnum VT_I4
public VarEnum VT_R4
public VarEnum VT_R8
public VarEnum VT_CY
public VarEnum VT_DATE
public VarEnum VT_BSTR
public VarEnum VT_DISPATCH
public VarEnum VT_ERROR
public VarEnum VT_BOOL
public VarEnum VT_VARIANT
public VarEnum VT_UNKNOWN
public VarEnum VT_DECIMAL
public VarEnum VT_I1
public VarEnum VT_UI1
public VarEnum VT_UI2
public VarEnum VT_UI4
public VarEnum VT_I8
public VarEnum VT_UI8
public VarEnum VT_INT
public VarEnum VT_UINT
public VarEnum VT_VOID
public VarEnum VT_HRESULT
public VarEnum VT_PTR
public VarEnum VT_SAFEARRAY
public VarEnum VT_CARRAY
public VarEnum VT_USERDEFINED
public VarEnum VT_LPSTR
public VarEnum VT_LPWSTR
public VarEnum VT_RECORD
public VarEnum VT_FILETIME
public VarEnum VT_BLOB
public VarEnum VT_STREAM
public VarEnum VT_STORAGE
public VarEnum VT_STREAMED_OBJECT
public VarEnum VT_STORED_OBJECT
public VarEnum VT_BLOB_OBJECT
public VarEnum VT_CF
public VarEnum VT_CLSID
public VarEnum VT_VECTOR
public VarEnum VT_ARRAY
public VarEnum VT_BYREF
}
public System.Runtime.InteropServices.VARFLAGS : Enum {
public int value__
public VARFLAGS VARFLAG_FREADONLY
public VARFLAGS VARFLAG_FSOURCE
public VARFLAGS VARFLAG_FBINDABLE
public VARFLAGS VARFLAG_FREQUESTEDIT
public VARFLAGS VARFLAG_FDISPLAYBIND
public VARFLAGS VARFLAG_FDEFAULTBIND
public VARFLAGS VARFLAG_FHIDDEN
public VARFLAGS VARFLAG_FRESTRICTED
public VARFLAGS VARFLAG_FDEFAULTCOLLELEM
public VARFLAGS VARFLAG_FUIDEFAULT
public VARFLAGS VARFLAG_FNONBROWSABLE
public VARFLAGS VARFLAG_FREPLACEABLE
public VARFLAGS VARFLAG_FIMMEDIATEBIND
}
public System.Runtime.InteropServices.VariantWrapper : object {
private object _wrappedObject
public object WrappedObject
public void .ctor(object obj)
public object get_WrappedObject()
}
public System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
public void .ctor(int sizeInMegabytes)
protected void Finalize()
public void Dispose()
}
public System.Runtime.Remoting.ActivatedClientTypeEntry : TypeEntry {
private string applicationUrl
private Type obj_type
public string ApplicationUrl
public IContextAttribute[] ContextAttributes
public Type ObjectType
public void .ctor(Type type, string appUrl)
public void .ctor(string typeName, string assemblyName, string appUrl)
public string get_ApplicationUrl()
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public Type get_ObjectType()
public string ToString()
}
public System.Runtime.Remoting.ActivatedServiceTypeEntry : TypeEntry {
private Type obj_type
public IContextAttribute[] ContextAttributes
public Type ObjectType
public void .ctor(Type type)
public void .ctor(string typeName, string assemblyName)
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public Type get_ObjectType()
public string ToString()
}
internal System.Runtime.Remoting.Activation.ActivationServices : object {
private IActivator _constructionActivator
private IActivator ConstructionActivator
private IActivator get_ConstructionActivator()
public IMessage Activate(RemotingProxy proxy, ConstructionCall ctorCall)
public IMessage RemoteActivate(IConstructionCallMessage ctorCall)
public object CreateProxyFromAttributes(Type type, Object[] activationAttributes)
public ConstructionCall CreateConstructionCall(Type type, string activationUrl, Object[] activationAttributes)
public IMessage CreateInstanceFromMessage(IConstructionCallMessage ctorCall)
public object CreateProxyForType(Type type)
public object AllocateUninitializedClassInstance(Type type)
public void EnableProxyActivation(Type type, bool enable)
}
public System.Runtime.Remoting.Activation.ActivatorLevel : Enum {
public int value__
public ActivatorLevel Construction
public ActivatorLevel Context
public ActivatorLevel AppDomain
public ActivatorLevel Process
public ActivatorLevel Machine
}
internal System.Runtime.Remoting.Activation.AppDomainLevelActivator : object {
private string _activationUrl
private IActivator _next
public ActivatorLevel Level
public IActivator NextActivator
public void .ctor(string activationUrl, IActivator next)
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall)
}
internal System.Runtime.Remoting.Activation.ConstructionLevelActivator : object {
public ActivatorLevel Level
public IActivator NextActivator
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
}
internal System.Runtime.Remoting.Activation.ContextLevelActivator : object {
private IActivator m_NextActivator
public ActivatorLevel Level
public IActivator NextActivator
public void .ctor(IActivator next)
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall)
}
public System.Runtime.Remoting.Activation.IActivator {
public ActivatorLevel Level
public IActivator NextActivator
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Activation.IConstructionCallMessage {
public Type ActivationType
public string ActivationTypeName
public IActivator Activator
public Object[] CallSiteActivationAttributes
public IList ContextProperties
public Type get_ActivationType()
public string get_ActivationTypeName()
public IActivator get_Activator()
public void set_Activator(IActivator value)
public Object[] get_CallSiteActivationAttributes()
public IList get_ContextProperties()
}
internal System.Runtime.Remoting.Activation.RemoteActivationAttribute : Attribute {
private IList _contextProperties
public void .ctor(IList contextProperties)
public bool IsContextOK(Context ctx, IConstructionCallMessage ctor)
public void GetPropertiesForNewContext(IConstructionCallMessage ctor)
}
internal System.Runtime.Remoting.Activation.RemoteActivator : MarshalByRefObject {
public ActivatorLevel Level
public IActivator NextActivator
public IConstructionReturnMessage Activate(IConstructionCallMessage msg)
public object InitializeLifetimeService()
public ActivatorLevel get_Level()
public IActivator get_NextActivator()
public void set_NextActivator(IActivator value)
}
public System.Runtime.Remoting.Activation.UrlAttribute : ContextAttribute {
private string url
public string UrlValue
public void .ctor(string callsiteURL)
public string get_UrlValue()
public bool Equals(object o)
public int GetHashCode()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
internal System.Runtime.Remoting.ChannelData : object {
internal string Ref
internal string Type
internal string Id
internal string DelayLoadAsClientChannel
private ArrayList _serverProviders
private ArrayList _clientProviders
private Hashtable _customProperties
internal ArrayList ServerProviders
public ArrayList ClientProviders
public Hashtable CustomProperties
internal ArrayList get_ServerProviders()
public ArrayList get_ClientProviders()
public Hashtable get_CustomProperties()
public void CopyFrom(ChannelData other)
}
internal System.Runtime.Remoting.ChannelInfo : object {
private Object[] channelData
public Object[] ChannelData
public void .ctor(object remoteChannelData)
public Object[] get_ChannelData()
public void set_ChannelData(Object[] value)
}
internal System.Runtime.Remoting.Channels.AggregateDictionary : object {
private IDictionary[] dictionaries
private ArrayList _values
private ArrayList _keys
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(IDictionary[] dics)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object ob)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object ob)
public void CopyTo(Array array, int index)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
}
internal System.Runtime.Remoting.Channels.AggregateEnumerator : object {
private IDictionary[] dictionaries
private int pos
private IDictionaryEnumerator currente
public DictionaryEntry Entry
public object Key
public object Value
public object Current
public void .ctor(IDictionary[] dics)
public DictionaryEntry get_Entry()
public object get_Key()
public object get_Value()
public object get_Current()
public bool MoveNext()
public void Reset()
}
internal System.Runtime.Remoting.Channels.AsyncRequest : object {
internal IMessageSink ReplySink
internal IMessage MsgRequest
public void .ctor(IMessage msgRequest, IMessageSink replySink)
}
public System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties : object {
private Hashtable table
public int Count
public bool IsFixedSize
public bool IsReadOnly
public bool IsSynchronized
public object Item
public ICollection Keys
public IDictionary Properties
public object SyncRoot
public ICollection Values
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public object get_Item(object key)
public void set_Item(object key, object value)
public ICollection get_Keys()
public IDictionary get_Properties()
public object get_SyncRoot()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
public void Remove(object key)
}
public System.Runtime.Remoting.Channels.BaseChannelWithProperties : BaseChannelObjectWithProperties {
protected IChannelSinkBase SinksWithProperties
public IDictionary Properties
public IDictionary get_Properties()
}
internal System.Runtime.Remoting.Channels.CADSerializer : object {
internal IMessage DeserializeMessage(MemoryStream mem, IMethodCallMessage msg)
internal MemoryStream SerializeMessage(IMessage msg)
internal MemoryStream SerializeObject(object obj)
internal object DeserializeObject(MemoryStream mem)
}
internal System.Runtime.Remoting.Channels.ChanelSinkStackEntry : object {
public IChannelSinkBase Sink
public object State
public ChanelSinkStackEntry Next
public void .ctor(IChannelSinkBase sink, object state, ChanelSinkStackEntry next)
}
public System.Runtime.Remoting.Channels.ChannelDataStore : object {
private String[] _channelURIs
private DictionaryEntry[] _extraData
public String[] ChannelUris
public object Item
public void .ctor(String[] channelURIs)
public String[] get_ChannelUris()
public void set_ChannelUris(String[] value)
public object get_Item(object key)
public void set_Item(object key, object value)
}
public System.Runtime.Remoting.Channels.ChannelServices : object {
private ArrayList registeredChannels
private ArrayList delayedClientChannels
private CrossContextChannel _crossContextSink
internal string CrossContextUrl
private IList oldStartModeTypes
internal CrossContextChannel CrossContextChannel
public IChannel[] RegisteredChannels
internal CrossContextChannel get_CrossContextChannel()
internal IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, String& objectUri)
internal IMessageSink CreateClientChannelSinkChain(IChannelSender sender, string url, Object[] channelDataArray, String& objectUri)
public IChannel[] get_RegisteredChannels()
public IServerChannelSink CreateServerChannelSinkChain(IServerChannelSinkProvider provider, IChannelReceiver channel)
public ServerProcessing DispatchMessage(IServerChannelSinkStack sinkStack, IMessage msg, IMessage& replyMsg)
public IChannel GetChannel(string name)
public IDictionary GetChannelSinkProperties(object obj)
public String[] GetUrlsForObject(MarshalByRefObject obj)
public void RegisterChannel(IChannel chnl)
public void RegisterChannel(IChannel chnl, bool ensureSecurity)
internal void RegisterChannelConfig(ChannelData channel)
private object CreateProvider(ProviderData prov)
public IMessage SyncDispatchMessage(IMessage msg)
public IMessageCtrl AsyncDispatchMessage(IMessage msg, IMessageSink replySink)
private ReturnMessage CheckIncomingMessage(IMessage msg)
internal IMessage CheckReturnMessage(IMessage callMsg, IMessage retMsg)
private bool IsLocalCall(IMessage callMsg)
public void UnregisterChannel(IChannel chnl)
internal Object[] GetCurrentChannelInfo()
}
public System.Runtime.Remoting.Channels.ClientChannelSinkStack : object {
private IMessageSink _replySink
private ChanelSinkStackEntry _sinkStack
public void .ctor(IMessageSink replySink)
public void AsyncProcessResponse(ITransportHeaders headers, Stream stream)
public void DispatchException(Exception e)
public void DispatchReplyMessage(IMessage msg)
public object Pop(IClientChannelSink sink)
public void Push(IClientChannelSink sink, object state)
}
internal System.Runtime.Remoting.Channels.CrossAppDomainChannel : object {
private string _strName
private string _strBaseURI
private object s_lock
public string ChannelName
public int ChannelPriority
public object ChannelData
internal void RegisterCrossAppDomainChannel()
public string get_ChannelName()
public int get_ChannelPriority()
public string Parse(string url, String& objectURI)
public object get_ChannelData()
public String[] GetUrlsForUri(string objectURI)
public void StartListening(object data)
public void StopListening(object data)
public IMessageSink CreateMessageSink(string url, object data, String& uri)
}
internal System.Runtime.Remoting.Channels.CrossAppDomainData : object {
private object _ContextID
private int _DomainID
private string _processGuid
internal int DomainID
internal string ProcessID
internal void .ctor(int domainId)
internal int get_DomainID()
internal string get_ProcessID()
}
internal System.Runtime.Remoting.Channels.CrossAppDomainSink : object {
private Hashtable s_sinks
private MethodInfo processMessageMethod
private int _domainID
internal int TargetDomainId
public IMessageSink NextSink
internal void .ctor(int domainID)
internal CrossAppDomainSink GetSink(int domainID)
internal int get_TargetDomainId()
private ProcessMessageRes ProcessMessageInDomain(Byte[] arrRequest, CADMethodCallMessage cadMsg)
public IMessage SyncProcessMessage(IMessage msgRequest)
public IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink)
public void SendAsyncMessage(object data)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Channels.ExceptionFilterSink : object {
private IMessageSink _next
private IMessage _call
public IMessageSink NextSink
public void .ctor(IMessage call, IMessageSink next)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Channels.IChannel {
public string ChannelName
public int ChannelPriority
public string get_ChannelName()
public int get_ChannelPriority()
public string Parse(string url, String& objectURI)
}
public System.Runtime.Remoting.Channels.IChannelDataStore {
public String[] ChannelUris
public object Item
public String[] get_ChannelUris()
public object get_Item(object key)
public void set_Item(object key, object value)
}
public System.Runtime.Remoting.Channels.IChannelReceiver {
public object ChannelData
public object get_ChannelData()
public String[] GetUrlsForUri(string objectURI)
public void StartListening(object data)
public void StopListening(object data)
}
public System.Runtime.Remoting.Channels.IChannelReceiverHook {
public string ChannelScheme
public IServerChannelSink ChannelSinkChain
public bool WantsToListen
public string get_ChannelScheme()
public IServerChannelSink get_ChannelSinkChain()
public bool get_WantsToListen()
public void AddHookChannelUri(string channelUri)
}
public System.Runtime.Remoting.Channels.IChannelSender {
public IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI)
}
public System.Runtime.Remoting.Channels.IChannelSinkBase {
public IDictionary Properties
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Channels.IClientChannelSink {
public IClientChannelSink NextChannelSink
public IClientChannelSink get_NextChannelSink()
public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream)
public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream)
}
public System.Runtime.Remoting.Channels.IClientChannelSinkProvider {
public IClientChannelSinkProvider Next
public IClientChannelSinkProvider get_Next()
public void set_Next(IClientChannelSinkProvider value)
public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
}
public System.Runtime.Remoting.Channels.IClientChannelSinkStack {
public object Pop(IClientChannelSink sink)
public void Push(IClientChannelSink sink, object state)
}
public System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack {
public void AsyncProcessResponse(ITransportHeaders headers, Stream stream)
public void DispatchException(Exception e)
public void DispatchReplyMessage(IMessage msg)
}
public System.Runtime.Remoting.Channels.ISecurableChannel {
public bool IsSecured
public bool get_IsSecured()
public void set_IsSecured(bool value)
}
public System.Runtime.Remoting.Channels.IServerChannelSink {
public IServerChannelSink NextChannelSink
public IServerChannelSink get_NextChannelSink()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
}
public System.Runtime.Remoting.Channels.IServerChannelSinkProvider {
public IServerChannelSinkProvider Next
public IServerChannelSinkProvider get_Next()
public void set_Next(IServerChannelSinkProvider value)
public IServerChannelSink CreateSink(IChannelReceiver channel)
public void GetChannelData(IChannelDataStore channelData)
}
public System.Runtime.Remoting.Channels.IServerChannelSinkStack {
public object Pop(IServerChannelSink sink)
public void Push(IServerChannelSink sink, object state)
public void ServerCallback(IAsyncResult ar)
public void Store(IServerChannelSink sink, object state)
public void StoreAndDispatch(IServerChannelSink sink, object state)
}
public System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack {
public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IMessage msg, ITransportHeaders headers)
}
public System.Runtime.Remoting.Channels.ITransportHeaders {
public object Item
public object get_Item(object key)
public void set_Item(object key, object value)
public IEnumerator GetEnumerator()
}
public System.Runtime.Remoting.Channels.ServerChannelSinkStack : object {
private ChanelSinkStackEntry _sinkStack
public Stream GetResponseStream(IMessage msg, ITransportHeaders headers)
public object Pop(IServerChannelSink sink)
public void Push(IServerChannelSink sink, object state)
public void ServerCallback(IAsyncResult ar)
public void Store(IServerChannelSink sink, object state)
public void StoreAndDispatch(IServerChannelSink sink, object state)
public void AsyncProcessResponse(IMessage msg, ITransportHeaders headers, Stream stream)
}
internal System.Runtime.Remoting.Channels.ServerDispatchSink : object {
public IServerChannelSink NextChannelSink
public IDictionary Properties
public IServerChannelSink get_NextChannelSink()
public IDictionary get_Properties()
public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream)
public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream)
}
internal System.Runtime.Remoting.Channels.ServerDispatchSinkProvider : object {
public IServerChannelSinkProvider Next
public void .ctor(IDictionary properties, ICollection providerData)
public IServerChannelSinkProvider get_Next()
public void set_Next(IServerChannelSinkProvider value)
public IServerChannelSink CreateSink(IChannelReceiver channel)
public void GetChannelData(IChannelDataStore channelData)
}
public System.Runtime.Remoting.Channels.ServerProcessing : Enum {
public int value__
public ServerProcessing Complete
public ServerProcessing OneWay
public ServerProcessing Async
}
public System.Runtime.Remoting.Channels.SinkProviderData : object {
private string sinkName
private ArrayList children
private Hashtable properties
public IList Children
public string Name
public IDictionary Properties
public void .ctor(string name)
public IList get_Children()
public string get_Name()
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Channels.TransportHeaders : object {
private Hashtable hash_table
public object Item
public object get_Item(object key)
public void set_Item(object key, object value)
public IEnumerator GetEnumerator()
}
internal System.Runtime.Remoting.ClientActivatedIdentity : ServerIdentity {
private MarshalByRefObject _targetThis
public void .ctor(string objectUri, Type objectType)
public MarshalByRefObject GetServerObject()
public MarshalByRefObject GetClientProxy()
public void SetClientProxy(MarshalByRefObject obj)
public void OnLifetimeExpired()
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
internal System.Runtime.Remoting.ClientIdentity : Identity {
private WeakReference _proxyReference
public MarshalByRefObject ClientProxy
public string TargetUri
public void .ctor(string objectUri, ObjRef objRef)
public MarshalByRefObject get_ClientProxy()
public void set_ClientProxy(MarshalByRefObject value)
public ObjRef CreateObjRef(Type requestedType)
public string get_TargetUri()
}
internal System.Runtime.Remoting.ConfigHandler : object {
private ArrayList typeEntries
private ArrayList channelInstances
private ChannelData currentChannel
private Stack currentProviderData
private string currentClientUrl
private string appName
private string currentXmlPath
private bool onlyDelayedChannels
private Dictionary`2<string, int> <>f__switch$map22
private Dictionary`2<string, int> <>f__switch$map23
public void .ctor(bool onlyDelayedChannels)
private void ValidatePath(string element, String[] paths)
private bool CheckPath(string path)
public void OnStartParsing(SmallXmlParser parser)
public void OnProcessingInstruction(string name, string text)
public void OnIgnorableWhitespace(string s)
public void OnStartElement(string name, IAttrList attrs)
public void ParseElement(string name, IAttrList attrs)
public void OnEndElement(string name)
private void ReadCustomProviderData(string name, IAttrList attrs)
private void ReadLifetine(IAttrList attrs)
private TimeSpan ParseTime(string s)
private void ReadChannel(IAttrList attrs, bool isTemplate)
private ProviderData ReadProvider(string name, IAttrList attrs, bool isTemplate)
private void ReadClientActivated(IAttrList attrs)
private void ReadServiceActivated(IAttrList attrs)
private void ReadClientWellKnown(IAttrList attrs)
private void ReadServiceWellKnown(IAttrList attrs)
private void ReadInteropXml(IAttrList attrs, bool isElement)
private void ReadPreload(IAttrList attrs)
private string GetNotNull(IAttrList attrs, string name)
private string ExtractAssembly(String& type)
public void OnChars(string ch)
public void OnEndParsing(SmallXmlParser parser)
}
public System.Runtime.Remoting.Contexts.Context : object {
private int domain_id
private int context_id
private UIntPtr static_data
private IMessageSink default_server_context_sink
private IMessageSink server_context_sink_chain
private IMessageSink client_context_sink_chain
private Object[] datastore
private ArrayList context_properties
private bool frozen
private int global_count
private Hashtable namedSlots
private DynamicPropertyCollection global_dynamic_properties
private DynamicPropertyCollection context_dynamic_properties
private ContextCallbackObject callback_object
public Context DefaultContext
public int ContextID
public IContextProperty[] ContextProperties
internal bool IsDefaultContext
internal bool NeedsContextSink
internal bool HasGlobalDynamicSinks
internal bool HasDynamicSinks
internal bool HasExitSinks
protected void Finalize()
public Context get_DefaultContext()
public int get_ContextID()
public IContextProperty[] get_ContextProperties()
internal bool get_IsDefaultContext()
internal bool get_NeedsContextSink()
public bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx)
public bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx)
private DynamicPropertyCollection GetDynamicPropertyCollection(ContextBoundObject obj, Context ctx)
internal void NotifyGlobalDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
internal bool get_HasGlobalDynamicSinks()
internal void NotifyDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
internal bool get_HasDynamicSinks()
internal bool get_HasExitSinks()
public IContextProperty GetProperty(string name)
public void SetProperty(IContextProperty prop)
public void Freeze()
public string ToString()
internal IMessageSink GetServerContextSinkChain()
internal IMessageSink GetClientContextSinkChain()
internal IMessageSink CreateServerObjectSinkChain(MarshalByRefObject obj, bool forceInternalExecute)
internal IMessageSink CreateEnvoySink(MarshalByRefObject serverObject)
internal Context SwitchToContext(Context newContext)
internal Context CreateNewContext(IConstructionCallMessage msg)
public void DoCallBack(CrossContextDelegate deleg)
public LocalDataStoreSlot AllocateDataSlot()
public LocalDataStoreSlot AllocateNamedDataSlot(string name)
public void FreeNamedDataSlot(string name)
public object GetData(LocalDataStoreSlot slot)
public LocalDataStoreSlot GetNamedDataSlot(string name)
public void SetData(LocalDataStoreSlot slot, object data)
}
public System.Runtime.Remoting.Contexts.ContextAttribute : Attribute {
protected string AttributeName
public string Name
public void .ctor(string name)
public string get_Name()
public bool Equals(object o)
public void Freeze(Context newContext)
public int GetHashCode()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public bool IsContextOK(Context ctx, IConstructionCallMessage ctorMsg)
public bool IsNewContextOK(Context newCtx)
}
internal System.Runtime.Remoting.Contexts.ContextCallbackObject : ContextBoundObject {
public void DoCallBack(CrossContextDelegate deleg)
}
public System.Runtime.Remoting.Contexts.ContextProperty : object {
private string name
private object prop
public string Name
public object Property
private void .ctor(string name, object prop)
public string get_Name()
public object get_Property()
}
internal System.Runtime.Remoting.Contexts.CrossContextChannel : object {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Contexts.CrossContextDelegate : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.Runtime.Remoting.Contexts.DynamicPropertyCollection : object {
private ArrayList _properties
public bool HasProperties
public bool get_HasProperties()
public bool RegisterDynamicProperty(IDynamicProperty prop)
public bool UnregisterDynamicProperty(string name)
public void NotifyMessage(bool start, IMessage msg, bool client_site, bool async)
private int FindProperty(string name)
}
public System.Runtime.Remoting.Contexts.IContextAttribute {
public void GetPropertiesForNewContext(IConstructionCallMessage msg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Contexts.IContextProperty {
public string Name
public string get_Name()
public void Freeze(Context newContext)
public bool IsNewContextOK(Context newCtx)
}
public System.Runtime.Remoting.Contexts.IContextPropertyActivator {
public void CollectFromClientContext(IConstructionCallMessage msg)
public void CollectFromServerContext(IConstructionReturnMessage msg)
public bool DeliverClientContextToServerContext(IConstructionCallMessage msg)
public bool DeliverServerContextToClientContext(IConstructionReturnMessage msg)
public bool IsOKToActivate(IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Contexts.IContributeClientContextSink {
public IMessageSink GetClientContextSink(IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeDynamicSink {
public IDynamicMessageSink GetDynamicSink()
}
public System.Runtime.Remoting.Contexts.IContributeEnvoySink {
public IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeObjectSink {
public IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IContributeServerContextSink {
public IMessageSink GetServerContextSink(IMessageSink nextSink)
}
public System.Runtime.Remoting.Contexts.IDynamicMessageSink {
public void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync)
public void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync)
}
public System.Runtime.Remoting.Contexts.IDynamicProperty {
public string Name
public string get_Name()
}
public System.Runtime.Remoting.Contexts.SynchronizationAttribute : ContextAttribute {
public int NOT_SUPPORTED
public int SUPPORTED
public int REQUIRED
public int REQUIRES_NEW
private bool _bReEntrant
private int _flavor
private bool _locked
private int _lockCount
private Mutex _mutex
private Thread _ownerThread
public bool IsReEntrant
public bool Locked
public void .ctor(bool reEntrant)
public void .ctor(int flag)
public void .ctor(int flag, bool reEntrant)
public bool get_IsReEntrant()
public bool get_Locked()
public void set_Locked(bool value)
internal void AcquireLock()
internal void ReleaseLock()
public void GetPropertiesForNewContext(IConstructionCallMessage ctorMsg)
public IMessageSink GetClientContextSink(IMessageSink nextSink)
public IMessageSink GetServerContextSink(IMessageSink nextSink)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
internal void ExitContext()
internal void EnterContext()
}
internal System.Runtime.Remoting.Contexts.SynchronizedClientContextSink : object {
private IMessageSink _next
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
internal System.Runtime.Remoting.Contexts.SynchronizedContextReplySink : object {
private IMessageSink _next
private bool _newLock
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att, bool newLock)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
internal System.Runtime.Remoting.Contexts.SynchronizedServerContextSink : object {
private IMessageSink _next
private SynchronizationAttribute _att
public IMessageSink NextSink
public void .ctor(IMessageSink next, SynchronizationAttribute att)
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
}
public System.Runtime.Remoting.CustomErrorsModes : Enum {
public int value__
public CustomErrorsModes On
public CustomErrorsModes Off
public CustomErrorsModes RemoteOnly
}
internal System.Runtime.Remoting.DisposerReplySink : object {
private IMessageSink _next
private IDisposable _disposable
public IMessageSink NextSink
public void .ctor(IMessageSink next, IDisposable disposable)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.EnvoyInfo : object {
private IMessageSink envoySinks
public IMessageSink EnvoySinks
public void .ctor(IMessageSink sinks)
public IMessageSink get_EnvoySinks()
public void set_EnvoySinks(IMessageSink value)
}
public System.Runtime.Remoting.IChannelInfo {
public Object[] ChannelData
public Object[] get_ChannelData()
public void set_ChannelData(Object[] value)
}
internal System.Runtime.Remoting.Identity : object {
protected string _objectUri
protected IMessageSink _channelSink
protected IMessageSink _envoySink
private DynamicPropertyCollection _clientDynamicProperties
private DynamicPropertyCollection _serverDynamicProperties
protected ObjRef _objRef
private bool _disposed
public bool IsFromThisAppDomain
public IMessageSink ChannelSink
public IMessageSink EnvoySink
public string ObjectUri
public bool IsConnected
public bool Disposed
public DynamicPropertyCollection ClientDynamicProperties
public DynamicPropertyCollection ServerDynamicProperties
public bool HasClientDynamicSinks
public bool HasServerDynamicSinks
public void .ctor(string objectUri)
public ObjRef CreateObjRef(Type requestedType)
public bool get_IsFromThisAppDomain()
public IMessageSink get_ChannelSink()
public void set_ChannelSink(IMessageSink value)
public IMessageSink get_EnvoySink()
public string get_ObjectUri()
public void set_ObjectUri(string value)
public bool get_IsConnected()
public bool get_Disposed()
public void set_Disposed(bool value)
public DynamicPropertyCollection get_ClientDynamicProperties()
public DynamicPropertyCollection get_ServerDynamicProperties()
public bool get_HasClientDynamicSinks()
public bool get_HasServerDynamicSinks()
public void NotifyClientDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
public void NotifyServerDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async)
}
public System.Runtime.Remoting.IEnvoyInfo {
public IMessageSink EnvoySinks
public IMessageSink get_EnvoySinks()
public void set_EnvoySinks(IMessageSink value)
}
public System.Runtime.Remoting.InternalRemotingServices : object {
private Hashtable _soapAttributes
public void DebugOutChnl(string s)
public SoapAttribute GetCachedSoapAttribute(object reflectionObject)
public void RemotingAssert(bool condition, string message)
public void RemotingTrace(Object[] messages)
public void SetServerIdentity(MethodCall m, object srvID)
}
public System.Runtime.Remoting.IObjectHandle {
public object Unwrap()
}
public System.Runtime.Remoting.IRemotingTypeInfo {
public string TypeName
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
public System.Runtime.Remoting.Lifetime.ClientSponsor : MarshalByRefObject {
private TimeSpan renewal_time
private Hashtable registered_objects
public TimeSpan RenewalTime
public void .ctor(TimeSpan renewalTime)
public TimeSpan get_RenewalTime()
public void set_RenewalTime(TimeSpan value)
public void Close()
protected void Finalize()
public object InitializeLifetimeService()
public bool Register(MarshalByRefObject obj)
public TimeSpan Renewal(ILease lease)
public void Unregister(MarshalByRefObject obj)
}
public System.Runtime.Remoting.Lifetime.ILease {
public TimeSpan CurrentLeaseTime
public LeaseState CurrentState
public TimeSpan InitialLeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_CurrentLeaseTime()
public LeaseState get_CurrentState()
public TimeSpan get_InitialLeaseTime()
public void set_InitialLeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
public void Register(ISponsor obj)
public void Register(ISponsor obj, TimeSpan renewalTime)
public TimeSpan Renew(TimeSpan renewalTime)
public void Unregister(ISponsor obj)
}
public System.Runtime.Remoting.Lifetime.ISponsor {
public TimeSpan Renewal(ILease lease)
}
internal System.Runtime.Remoting.Lifetime.Lease : MarshalByRefObject {
private DateTime _leaseExpireTime
private LeaseState _currentState
private TimeSpan _initialLeaseTime
private TimeSpan _renewOnCallTime
private TimeSpan _sponsorshipTimeout
private ArrayList _sponsors
private Queue _renewingSponsors
private RenewalDelegate _renewalDelegate
public TimeSpan CurrentLeaseTime
public LeaseState CurrentState
public TimeSpan InitialLeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_CurrentLeaseTime()
public LeaseState get_CurrentState()
public void Activate()
public TimeSpan get_InitialLeaseTime()
public void set_InitialLeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
public void Register(ISponsor obj)
public void Register(ISponsor obj, TimeSpan renewalTime)
public TimeSpan Renew(TimeSpan renewalTime)
public void Unregister(ISponsor obj)
internal void UpdateState()
private void CheckNextSponsor()
private void ProcessSponsorResponse(object state, bool timedOut)
}
internal System.Runtime.Remoting.Lifetime.LeaseManager : object {
private ArrayList _objects
private Timer _timer
public void SetPollTime(TimeSpan timeSpan)
public void TrackLifetime(ServerIdentity identity)
public void StopTrackingLifetime(ServerIdentity identity)
public void StartManager()
public void StopManager()
public void ManageLeases(object state)
}
internal System.Runtime.Remoting.Lifetime.LeaseSink : object {
private IMessageSink _nextSink
public IMessageSink NextSink
public void .ctor(IMessageSink nextSink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
private void RenewLease(IMessage msg)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Lifetime.LeaseState : Enum {
public int value__
public LeaseState Null
public LeaseState Initial
public LeaseState Active
public LeaseState Renewing
public LeaseState Expired
}
public System.Runtime.Remoting.Lifetime.LifetimeServices : object {
private TimeSpan _leaseManagerPollTime
private TimeSpan _leaseTime
private TimeSpan _renewOnCallTime
private TimeSpan _sponsorshipTimeout
private LeaseManager _leaseManager
public TimeSpan LeaseManagerPollTime
public TimeSpan LeaseTime
public TimeSpan RenewOnCallTime
public TimeSpan SponsorshipTimeout
public TimeSpan get_LeaseManagerPollTime()
public void set_LeaseManagerPollTime(TimeSpan value)
public TimeSpan get_LeaseTime()
public void set_LeaseTime(TimeSpan value)
public TimeSpan get_RenewOnCallTime()
public void set_RenewOnCallTime(TimeSpan value)
public TimeSpan get_SponsorshipTimeout()
public void set_SponsorshipTimeout(TimeSpan value)
internal void TrackLifetime(ServerIdentity identity)
internal void StopTrackingLifetime(ServerIdentity identity)
}
internal System.Runtime.Remoting.Messaging.ArgInfo : object {
private Int32[] _paramMap
private int _inoutArgCount
private MethodBase _method
public void .ctor(MethodBase method, ArgInfoType type)
public int GetInOutArgIndex(int inoutArgNum)
public string GetInOutArgName(int index)
public int GetInOutArgCount()
public Object[] GetInOutArgs(Object[] args)
}
internal System.Runtime.Remoting.Messaging.ArgInfoType : Enum {
public byte value__
public ArgInfoType In
public ArgInfoType Out
}
public System.Runtime.Remoting.Messaging.AsyncResult : object {
private object async_state
private WaitHandle handle
private object async_delegate
private IntPtr data
private object object_data
private bool sync_completed
private bool completed
private bool endinvoke_called
private object async_callback
private ExecutionContext current
private ExecutionContext original
private int gchandle
private MonoMethodMessage call_message
private IMessageCtrl message_ctrl
private IMessage reply_message
public object AsyncState
public WaitHandle AsyncWaitHandle
public bool CompletedSynchronously
public bool IsCompleted
public bool EndInvokeCalled
public object AsyncDelegate
public IMessageSink NextSink
internal MonoMethodMessage CallMessage
public object get_AsyncState()
public WaitHandle get_AsyncWaitHandle()
public bool get_CompletedSynchronously()
public bool get_IsCompleted()
public bool get_EndInvokeCalled()
public void set_EndInvokeCalled(bool value)
public object get_AsyncDelegate()
public IMessageSink get_NextSink()
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessage GetReplyMessage()
public void SetMessageCtrl(IMessageCtrl mc)
internal void SetCompletedSynchronously(bool completed)
internal IMessage EndInvoke()
public IMessage SyncProcessMessage(IMessage msg)
internal MonoMethodMessage get_CallMessage()
internal void set_CallMessage(MonoMethodMessage value)
}
internal System.Runtime.Remoting.Messaging.CADArgHolder : object {
public int index
public void .ctor(int i)
}
internal System.Runtime.Remoting.Messaging.CADMessageBase : object {
protected Object[] _args
protected Byte[] _serializedArgs
protected int _propertyCount
protected CADArgHolder _callContext
internal int MarshalProperties(IDictionary dict, ArrayList& args)
internal void UnmarshalProperties(IDictionary dict, int count, ArrayList args)
private bool IsPossibleToIgnoreMarshal(object obj)
protected object MarshalArgument(object arg, ArrayList& args)
protected object UnmarshalArgument(object arg, ArrayList args)
internal Object[] MarshalArguments(Object[] arguments, ArrayList& args)
internal Object[] UnmarshalArguments(Object[] arguments, ArrayList args)
protected void SaveLogicalCallContext(IMethodMessage msg, ArrayList& serializeList)
internal LogicalCallContext GetLogicalCallContext(ArrayList args)
}
internal System.Runtime.Remoting.Messaging.CADMethodCallMessage : CADMessageBase {
private string _uri
internal RuntimeMethodHandle MethodHandle
internal string FullTypeName
internal string Uri
internal int PropertiesCount
internal void .ctor(IMethodCallMessage callMsg)
internal string get_Uri()
internal CADMethodCallMessage Create(IMessage callMsg)
internal ArrayList GetArguments()
internal Object[] GetArgs(ArrayList args)
internal int get_PropertiesCount()
private Type[] GetSignature(MethodBase methodBase, bool load)
internal MethodBase GetMethod()
}
internal System.Runtime.Remoting.Messaging.CADMethodReturnMessage : CADMessageBase {
private object _returnValue
private CADArgHolder _exception
internal int PropertiesCount
internal void .ctor(IMethodReturnMessage retMsg)
internal CADMethodReturnMessage Create(IMessage callMsg)
internal ArrayList GetArguments()
internal Object[] GetArgs(ArrayList args)
internal object GetReturnValue(ArrayList args)
internal Exception GetException(ArrayList args)
internal int get_PropertiesCount()
}
internal System.Runtime.Remoting.Messaging.CADObjRef : object {
private ObjRef objref
public int SourceDomain
public string TypeName
public string URI
public void .ctor(ObjRef o, int sourceDomain)
public string get_TypeName()
public string get_URI()
}
public System.Runtime.Remoting.Messaging.CallContext : object {
private Header[] Headers
private Hashtable datastore
public object HostContext
private Hashtable Datastore
public object get_HostContext()
public void set_HostContext(object value)
public void FreeNamedDataSlot(string name)
public object GetData(string name)
public void SetData(string name, object data)
public object LogicalGetData(string name)
public void LogicalSetData(string name, object data)
public Header[] GetHeaders()
public void SetHeaders(Header[] headers)
internal LogicalCallContext CreateLogicalCallContext(bool createEmpty)
internal object SetCurrentCallContext(LogicalCallContext ctx)
internal void UpdateCurrentCallContext(LogicalCallContext ctx)
internal void RestoreCallContext(object oldContext)
private Hashtable get_Datastore()
}
internal System.Runtime.Remoting.Messaging.CallContextRemotingData : object {
private string _logicalCallID
public string LogicalCallID
public string get_LogicalCallID()
public void set_LogicalCallID(string value)
public object Clone()
}
internal System.Runtime.Remoting.Messaging.CallType : Enum {
public int value__
public CallType Sync
public CallType BeginInvoke
public CallType EndInvoke
public CallType OneWay
}
internal System.Runtime.Remoting.Messaging.ClientContextReplySink : object {
private IMessageSink _replySink
private Context _context
public IMessageSink NextSink
public void .ctor(Context ctx, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ClientContextTerminatorSink : object {
private Context _context
public IMessageSink NextSink
public void .ctor(Context ctx)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Messaging.ConstructionCall : MethodCall {
private IActivator _activator
private Object[] _activationAttributes
private IList _contextProperties
private Type _activationType
private string _activationTypeName
private bool _isContextOk
private RemotingProxy _sourceProxy
private Dictionary`2<string, int> <>f__switch$map25
internal bool IsContextOk
public Type ActivationType
public string ActivationTypeName
public IActivator Activator
public Object[] CallSiteActivationAttributes
public IList ContextProperties
public IDictionary Properties
internal RemotingProxy SourceProxy
public void .ctor(IMessage m)
internal void .ctor(Type type)
public void .ctor(Header[] headers)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void InitDictionary()
internal bool get_IsContextOk()
internal void set_IsContextOk(bool value)
public Type get_ActivationType()
public string get_ActivationTypeName()
public IActivator get_Activator()
public void set_Activator(IActivator value)
public Object[] get_CallSiteActivationAttributes()
internal void SetActivationAttributes(Object[] attributes)
public IList get_ContextProperties()
internal void InitMethodProperty(string key, object value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public IDictionary get_Properties()
internal RemotingProxy get_SourceProxy()
internal void set_SourceProxy(RemotingProxy value)
}
internal System.Runtime.Remoting.Messaging.ConstructionCallDictionary : MethodDictionary {
public String[] InternalKeys
private Dictionary`2<string, int> <>f__switch$map28
private Dictionary`2<string, int> <>f__switch$map29
public void .ctor(IConstructionCallMessage message)
protected object GetMethodProperty(string key)
protected void SetMethodProperty(string key, object value)
}
public System.Runtime.Remoting.Messaging.ConstructionResponse : MethodResponse {
public IDictionary Properties
public void .ctor(Header[] h, IMethodCallMessage mcm)
internal void .ctor(object resultObject, LogicalCallContext callCtx, IMethodCallMessage msg)
internal void .ctor(Exception e, IMethodCallMessage msg)
internal void .ctor(SerializationInfo info, StreamingContext context)
public IDictionary get_Properties()
}
internal System.Runtime.Remoting.Messaging.EnvoyTerminatorSink : object {
public EnvoyTerminatorSink Instance
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ErrorMessage : object {
private string _uri
public int ArgCount
public Object[] Args
public bool HasVarArgs
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int arg_num)
public string GetArgName(int arg_num)
public int get_InArgCount()
public string GetInArgName(int index)
public object GetInArg(int argNum)
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
}
public System.Runtime.Remoting.Messaging.Header : object {
public string HeaderNamespace
public bool MustUnderstand
public string Name
public object Value
public void .ctor(string _Name, object _Value)
public void .ctor(string _Name, object _Value, bool _MustUnderstand)
public void .ctor(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace)
}
public System.Runtime.Remoting.Messaging.HeaderHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public object Invoke(Header[] headers)
public IAsyncResult BeginInvoke(Header[] headers, AsyncCallback callback, object object)
public object EndInvoke(IAsyncResult result)
}
internal System.Runtime.Remoting.Messaging.IInternalMessage {
public Identity TargetIdentity
public string Uri
public Identity get_TargetIdentity()
public void set_TargetIdentity(Identity value)
public string get_Uri()
public void set_Uri(string value)
}
public System.Runtime.Remoting.Messaging.IMessage {
public IDictionary Properties
public IDictionary get_Properties()
}
public System.Runtime.Remoting.Messaging.IMessageCtrl {
public void Cancel(int msToCancel)
}
public System.Runtime.Remoting.Messaging.IMessageSink {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
public System.Runtime.Remoting.Messaging.IMethodCallMessage {
public int InArgCount
public Object[] InArgs
public int get_InArgCount()
public Object[] get_InArgs()
public object GetInArg(int argNum)
public string GetInArgName(int index)
}
public System.Runtime.Remoting.Messaging.IMethodMessage {
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public string TypeName
public string Uri
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public string get_TypeName()
public string get_Uri()
public object GetArg(int argNum)
public string GetArgName(int index)
}
public System.Runtime.Remoting.Messaging.IMethodReturnMessage {
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
}
public System.Runtime.Remoting.Messaging.InternalMessageWrapper : object {
protected IMessage WrappedMessage
public void .ctor(IMessage msg)
}
public System.Runtime.Remoting.Messaging.IRemotingFormatter {
public object Deserialize(Stream serializationStream, HeaderHandler handler)
public void Serialize(Stream serializationStream, object graph, Header[] headers)
}
internal System.Runtime.Remoting.Messaging.ISerializationRootObject {
public void RootSetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Remoting.Messaging.LogicalCallContext : object {
private Hashtable _data
private CallContextRemotingData _remotingData
public bool HasInfo
internal Hashtable Datastore
internal void .ctor(SerializationInfo info, StreamingContext context)
public bool get_HasInfo()
public void FreeNamedDataSlot(string name)
public object GetData(string name)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void SetData(string name, object data)
public object Clone()
internal Hashtable get_Datastore()
}
public System.Runtime.Remoting.Messaging.MessageSurrogateFilter : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public bool Invoke(string key, object value)
public IAsyncResult BeginInvoke(string key, object value, AsyncCallback callback, object object)
public bool EndInvoke(IAsyncResult result)
}
public System.Runtime.Remoting.Messaging.MethodCall : object {
private string _uri
private string _typeName
private string _methodName
private Object[] _args
private Type[] _methodSignature
private MethodBase _methodBase
private LogicalCallContext _callContext
private ArgInfo _inArgInfo
private Identity _targetIdentity
private Type[] _genericArguments
protected IDictionary ExternalProperties
protected IDictionary InternalProperties
private Dictionary`2<string, int> <>f__switch$map24
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public int ArgCount
public Object[] Args
public bool HasVarArgs
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
private Type[] GenericArguments
public void .ctor(Header[] h1)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(CADMethodCallMessage msg)
public void .ctor(IMessage msg)
internal void .ctor(string uri, string typeName, string methodName, Object[] args)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
internal void CopyFrom(IMethodMessage call)
internal void InitMethodProperty(string key, object value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public int get_InArgCount()
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
internal void InitDictionary()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetInArg(int argNum)
public string GetInArgName(int index)
public object HeaderHandler(Header[] h)
public void Init()
public void ResolveMethod()
private Type CastTo(string clientType, Type serverType)
private string GetTypeNameFromAssemblyQualifiedName(string aqname)
public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
private Type[] get_GenericArguments()
}
internal System.Runtime.Remoting.Messaging.MethodCallDictionary : MethodDictionary {
public String[] InternalKeys
public void .ctor(IMethodMessage message)
}
public System.Runtime.Remoting.Messaging.MethodCallMessageWrapper : InternalMessageWrapper {
private Object[] _args
private ArgInfo _inArgInfo
private DictionaryWrapper _properties
public int ArgCount
public Object[] Args
public bool HasVarArgs
public int InArgCount
public Object[] InArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
public void .ctor(IMethodCallMessage msg)
public int get_ArgCount()
public Object[] get_Args()
public void set_Args(Object[] value)
public bool get_HasVarArgs()
public int get_InArgCount()
public Object[] get_InArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetInArg(int argNum)
public string GetInArgName(int index)
}
internal System.Runtime.Remoting.Messaging.MethodDictionary : object {
private IDictionary _internalProperties
protected IMethodMessage _message
private String[] _methodKeys
private bool _ownProperties
private Dictionary`2<string, int> <>f__switch$map26
private Dictionary`2<string, int> <>f__switch$map27
internal bool HasInternalProperties
internal IDictionary InternalProperties
public String[] MethodKeys
public bool IsFixedSize
public bool IsReadOnly
public object Item
public ICollection Keys
public ICollection Values
public int Count
public bool IsSynchronized
public object SyncRoot
public void .ctor(IMethodMessage message)
public void .ctor(String[] keys)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
internal bool get_HasInternalProperties()
internal IDictionary get_InternalProperties()
public String[] get_MethodKeys()
public void set_MethodKeys(String[] value)
protected IDictionary AllocInternalProperties()
public IDictionary GetInternalProperties()
private bool IsOverridenKey(string key)
public bool get_IsFixedSize()
public bool get_IsReadOnly()
public object get_Item(object key)
public void set_Item(object key, object value)
protected object GetMethodProperty(string key)
protected void SetMethodProperty(string key, object value)
public ICollection get_Keys()
public ICollection get_Values()
public void Add(object key, object value)
public void Clear()
public bool Contains(object key)
public void Remove(object key)
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public void CopyTo(Array array, int index)
public IDictionaryEnumerator GetEnumerator()
}
public System.Runtime.Remoting.Messaging.MethodResponse : object {
private string _methodName
private string _uri
private string _typeName
private MethodBase _methodBase
private object _returnValue
private Exception _exception
private Type[] _methodSignature
private ArgInfo _inArgInfo
private Object[] _args
private Object[] _outArgs
private IMethodCallMessage _callMsg
private LogicalCallContext _callContext
private Identity _targetIdentity
protected IDictionary ExternalProperties
protected IDictionary InternalProperties
private Dictionary`2<string, int> <>f__switch$map2A
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public int ArgCount
public Object[] Args
public Exception Exception
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public int OutArgCount
public Object[] OutArgs
public IDictionary Properties
public object ReturnValue
public string TypeName
public string Uri
public void .ctor(Header[] h1, IMethodCallMessage mcm)
internal void .ctor(Exception e, IMethodCallMessage msg)
internal void .ctor(object returnValue, Object[] outArgs, LogicalCallContext callCtx, IMethodCallMessage msg)
internal void .ctor(IMethodCallMessage msg, CADMethodReturnMessage retmsg)
internal void .ctor(SerializationInfo info, StreamingContext context)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
internal void InitMethodProperty(string key, object value)
public int get_ArgCount()
public Object[] get_Args()
public Exception get_Exception()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public int get_OutArgCount()
public Object[] get_OutArgs()
public IDictionary get_Properties()
public object get_ReturnValue()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
public object HeaderHandler(Header[] h)
public void RootSetObjectData(SerializationInfo info, StreamingContext ctx)
}
internal System.Runtime.Remoting.Messaging.MethodReturnDictionary : MethodDictionary {
public String[] InternalReturnKeys
public String[] InternalExceptionKeys
public void .ctor(IMethodReturnMessage message)
}
public System.Runtime.Remoting.Messaging.MethodReturnMessageWrapper : InternalMessageWrapper {
private Object[] _args
private ArgInfo _outArgInfo
private DictionaryWrapper _properties
private Exception _exception
private object _return
public int ArgCount
public Object[] Args
public Exception Exception
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public int OutArgCount
public Object[] OutArgs
public IDictionary Properties
public object ReturnValue
public string TypeName
public string Uri
public void .ctor(IMethodReturnMessage msg)
public int get_ArgCount()
public Object[] get_Args()
public void set_Args(Object[] value)
public Exception get_Exception()
public void set_Exception(Exception value)
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public int get_OutArgCount()
public Object[] get_OutArgs()
public IDictionary get_Properties()
public object get_ReturnValue()
public void set_ReturnValue(object value)
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
}
internal System.Runtime.Remoting.Messaging.MonoMethodMessage : object {
private MonoMethod method
private Object[] args
private String[] names
private Byte[] arg_types
public LogicalCallContext ctx
public object rval
public Exception exc
private AsyncResult asyncResult
private CallType call_type
private string uri
private MethodCallDictionary properties
private Type[] methodSignature
private Identity identity
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public IDictionary Properties
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public string TypeName
public string Uri
public int InArgCount
public Object[] InArgs
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
public bool IsAsync
public AsyncResult AsyncResult
internal CallType CallType
public void .ctor(MethodBase method, Object[] out_args)
public void .ctor(Type type, string method_name, Object[] in_args)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
internal void InitMessage(MonoMethod method, Object[] out_args)
public IDictionary get_Properties()
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public void set_LogicalCallContext(LogicalCallContext value)
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int arg_num)
public string GetArgName(int arg_num)
public int get_InArgCount()
public Object[] get_InArgs()
public object GetInArg(int arg_num)
public string GetInArgName(int arg_num)
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int arg_num)
public string GetOutArgName(int arg_num)
public bool get_IsAsync()
public AsyncResult get_AsyncResult()
internal CallType get_CallType()
public bool NeedsOutProcessing(Int32& outCount)
}
internal System.Runtime.Remoting.Messaging.ObjRefSurrogate : object {
public void GetObjectData(object obj, SerializationInfo si, StreamingContext sc)
public object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector)
}
internal System.Runtime.Remoting.Messaging.RemotingSurrogate : object {
public void GetObjectData(object obj, SerializationInfo si, StreamingContext sc)
public object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector)
}
public System.Runtime.Remoting.Messaging.RemotingSurrogateSelector : object {
private Type s_cachedTypeObjRef
private ObjRefSurrogate _objRefSurrogate
private RemotingSurrogate _objRemotingSurrogate
private object _rootObj
private MessageSurrogateFilter _filter
private ISurrogateSelector _next
public MessageSurrogateFilter Filter
public MessageSurrogateFilter get_Filter()
public void set_Filter(MessageSurrogateFilter value)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
public object GetRootObject()
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& ssout)
public void SetRootObject(object obj)
public void UseSoapFormat()
}
public System.Runtime.Remoting.Messaging.ReturnMessage : object {
private Object[] _outArgs
private Object[] _args
private int _outArgsCount
private LogicalCallContext _callCtx
private object _returnValue
private string _uri
private Exception _exception
private MethodBase _methodBase
private string _methodName
private Type[] _methodSignature
private string _typeName
private MethodReturnDictionary _properties
private Identity _targetIdentity
private ArgInfo _inArgInfo
private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity
public int ArgCount
public Object[] Args
public bool HasVarArgs
public LogicalCallContext LogicalCallContext
public MethodBase MethodBase
public string MethodName
public object MethodSignature
public IDictionary Properties
public string TypeName
public string Uri
public Exception Exception
public int OutArgCount
public Object[] OutArgs
public object ReturnValue
public void .ctor(object ret, Object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm)
public void .ctor(Exception e, IMethodCallMessage mcm)
private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value)
private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity()
private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value)
public int get_ArgCount()
public Object[] get_Args()
public bool get_HasVarArgs()
public LogicalCallContext get_LogicalCallContext()
public MethodBase get_MethodBase()
public string get_MethodName()
public object get_MethodSignature()
public IDictionary get_Properties()
public string get_TypeName()
public string get_Uri()
public void set_Uri(string value)
public object GetArg(int argNum)
public string GetArgName(int index)
public Exception get_Exception()
public int get_OutArgCount()
public Object[] get_OutArgs()
public object get_ReturnValue()
public object GetOutArg(int argNum)
public string GetOutArgName(int index)
}
internal System.Runtime.Remoting.Messaging.ServerContextTerminatorSink : object {
public IMessageSink NextSink
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ServerObjectReplySink : object {
private IMessageSink _replySink
private ServerIdentity _identity
public IMessageSink NextSink
public void .ctor(ServerIdentity identity, IMessageSink replySink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.ServerObjectTerminatorSink : object {
private IMessageSink _nextSink
public IMessageSink NextSink
public void .ctor(IMessageSink nextSink)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
public IMessageSink get_NextSink()
}
internal System.Runtime.Remoting.Messaging.StackBuilderSink : object {
private MarshalByRefObject _target
private RealProxy _rp
public IMessageSink NextSink
public void .ctor(MarshalByRefObject obj, bool forceInternalExecute)
public IMessage SyncProcessMessage(IMessage msg)
public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
private void ExecuteAsyncMessage(object ob)
public IMessageSink get_NextSink()
private void CheckParameters(IMessage msg)
}
public System.Runtime.Remoting.Metadata.SoapAttribute : Attribute {
private bool _nested
private bool _useAttribute
protected string ProtXmlNamespace
protected object ReflectInfo
public bool Embedded
public bool UseAttribute
public string XmlNamespace
public bool get_Embedded()
public void set_Embedded(bool value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapFieldAttribute : SoapAttribute {
private int _order
private string _elementName
private bool _isElement
public int Order
public string XmlElementName
public int get_Order()
public void set_Order(int value)
public string get_XmlElementName()
public void set_XmlElementName(string value)
public bool IsInteropXmlElement()
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapMethodAttribute : SoapAttribute {
private string _responseElement
private string _responseNamespace
private string _returnElement
private string _soapAction
private bool _useAttribute
private string _namespace
public string ResponseXmlElementName
public string ResponseXmlNamespace
public string ReturnXmlElementName
public string SoapAction
public bool UseAttribute
public string XmlNamespace
public string get_ResponseXmlElementName()
public void set_ResponseXmlElementName(string value)
public string get_ResponseXmlNamespace()
public void set_ResponseXmlNamespace(string value)
public string get_ReturnXmlElementName()
public void set_ReturnXmlElementName(string value)
public string get_SoapAction()
public void set_SoapAction(string value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.SoapOption : Enum {
public int value__
public SoapOption None
public SoapOption AlwaysIncludeTypes
public SoapOption XsdString
public SoapOption EmbedAll
public SoapOption Option1
public SoapOption Option2
}
public System.Runtime.Remoting.Metadata.SoapTypeAttribute : SoapAttribute {
private SoapOption _soapOption
private bool _useAttribute
private string _xmlElementName
private XmlFieldOrderOption _xmlFieldOrder
private string _xmlNamespace
private string _xmlTypeName
private string _xmlTypeNamespace
private bool _isType
private bool _isElement
public SoapOption SoapOptions
public bool UseAttribute
public string XmlElementName
public XmlFieldOrderOption XmlFieldOrder
public string XmlNamespace
public string XmlTypeName
public string XmlTypeNamespace
internal bool IsInteropXmlElement
internal bool IsInteropXmlType
public SoapOption get_SoapOptions()
public void set_SoapOptions(SoapOption value)
public bool get_UseAttribute()
public void set_UseAttribute(bool value)
public string get_XmlElementName()
public void set_XmlElementName(string value)
public XmlFieldOrderOption get_XmlFieldOrder()
public void set_XmlFieldOrder(XmlFieldOrderOption value)
public string get_XmlNamespace()
public void set_XmlNamespace(string value)
public string get_XmlTypeName()
public void set_XmlTypeName(string value)
public string get_XmlTypeNamespace()
public void set_XmlTypeNamespace(string value)
internal bool get_IsInteropXmlElement()
internal bool get_IsInteropXmlType()
internal void SetReflectionObject(object reflectionObject)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd {
public string GetXsdType()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapAnyUri Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary : object {
private Byte[] _value
public Byte[] Value
public string XsdType
public void .ctor(Byte[] value)
public Byte[] get_Value()
public void set_Value(Byte[] value)
public string get_XsdType()
public string GetXsdType()
public SoapBase64Binary Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapDate Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDateTime : object {
private String[] _datetimeFormats
public string XsdType
public string get_XsdType()
public DateTime Parse(string value)
public string ToString(DateTime value)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapDay Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDuration : object {
public string XsdType
public string get_XsdType()
public TimeSpan Parse(string value)
public string ToString(TimeSpan timeSpan)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapEntities Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapEntity Parse(string value)
public string ToString()
}
internal System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHelper : object {
public Exception GetException(ISoapXsd type, string msg)
public string Normalize(string s)
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary : object {
private Byte[] _value
private StringBuilder sb
public Byte[] Value
public string XsdType
public void .ctor(Byte[] value)
public Byte[] get_Value()
public void set_Value(Byte[] value)
public string get_XsdType()
public string GetXsdType()
public SoapHexBinary Parse(string value)
internal Byte[] FromBinHexString(string value)
private byte FromHex(char hexDigit, string value)
private Exception CreateInvalidValueException(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapId Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapIdref Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapIdrefs Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapLanguage Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapMonth Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapMonthDay Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNcName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNegativeInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNmtoken Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNmtokens Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNonNegativeInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapNonPositiveInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNormalizedString Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapNotation Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger : object {
private decimal _value
public decimal Value
public string XsdType
public void .ctor(decimal value)
public decimal get_Value()
public void set_Value(decimal value)
public string get_XsdType()
public string GetXsdType()
public SoapPositiveInteger Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName : object {
private string _name
private string _key
private string _namespace
public string Key
public string Name
public string Namespace
public string XsdType
public void .ctor(string value)
public void .ctor(string key, string name)
public void .ctor(string key, string name, string namespaceValue)
public string get_Key()
public void set_Key(string value)
public string get_Name()
public void set_Name(string value)
public string get_Namespace()
public void set_Namespace(string value)
public string get_XsdType()
public string GetXsdType()
public SoapQName Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime : object {
private String[] _datetimeFormats
private DateTime _value
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapTime Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken : object {
private string _value
public string Value
public string XsdType
public void .ctor(string value)
public string get_Value()
public void set_Value(string value)
public string get_XsdType()
public string GetXsdType()
public SoapToken Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapYear Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth : object {
private String[] _datetimeFormats
private int _sign
private DateTime _value
public int Sign
public DateTime Value
public string XsdType
public void .ctor(DateTime value)
public void .ctor(DateTime value, int sign)
public int get_Sign()
public void set_Sign(int value)
public DateTime get_Value()
public void set_Value(DateTime value)
public string get_XsdType()
public string GetXsdType()
public SoapYearMonth Parse(string value)
public string ToString()
}
public System.Runtime.Remoting.Metadata.XmlFieldOrderOption : Enum {
public int value__
public XmlFieldOrderOption All
public XmlFieldOrderOption Sequence
public XmlFieldOrderOption Choice
}
public System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
private object _wrapped
public void .ctor(object o)
public object InitializeLifetimeService()
public object Unwrap()
}
public System.Runtime.Remoting.ObjRef : object {
private IChannelInfo channel_info
private string uri
private IRemotingTypeInfo typeInfo
private IEnvoyInfo envoyInfo
private int flags
private Type _serverType
private int MarshalledObjectRef
private int WellKnowObjectRef
private Dictionary`2<string, int> <>f__switch$map21
internal bool IsReferenceToWellKnow
public IChannelInfo ChannelInfo
public IEnvoyInfo EnvoyInfo
public IRemotingTypeInfo TypeInfo
public string URI
internal Type ServerType
internal void .ctor(string typeName, string uri, IChannelInfo cinfo)
internal void .ctor(ObjRef o, bool unmarshalAsProxy)
public void .ctor(MarshalByRefObject o, Type requestedType)
internal void .ctor(Type type, string url, object remoteChannelData)
protected void .ctor(SerializationInfo info, StreamingContext context)
internal bool IsPossibleToCAD()
internal bool get_IsReferenceToWellKnow()
public IChannelInfo get_ChannelInfo()
public void set_ChannelInfo(IChannelInfo value)
public IEnvoyInfo get_EnvoyInfo()
public void set_EnvoyInfo(IEnvoyInfo value)
public IRemotingTypeInfo get_TypeInfo()
public void set_TypeInfo(IRemotingTypeInfo value)
public string get_URI()
public void set_URI(string value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
public bool IsFromThisAppDomain()
public bool IsFromThisProcess()
internal void UpdateChannelInfo()
internal Type get_ServerType()
}
internal System.Runtime.Remoting.ProviderData : object {
internal string Ref
internal string Type
internal string Id
internal Hashtable CustomProperties
internal IList CustomData
public void CopyFrom(ProviderData other)
}
public System.Runtime.Remoting.Proxies.ProxyAttribute : Attribute {
public MarshalByRefObject CreateInstance(Type serverType)
public RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext)
public void GetPropertiesForNewContext(IConstructionCallMessage msg)
public bool IsContextOK(Context ctx, IConstructionCallMessage msg)
}
public System.Runtime.Remoting.Proxies.RealProxy : object {
private Type class_to_proxy
internal Context _targetContext
private MarshalByRefObject _server
private int _targetDomainId
internal string _targetUri
internal Identity _objectIdentity
private object _objTP
private object _stubData
internal Identity ObjectIdentity
protected void .ctor(Type classToProxy)
internal void .ctor(Type classToProxy, ClientIdentity identity)
protected void .ctor(Type classToProxy, IntPtr stub, object stubData)
private Type InternalGetProxyType(object transparentProxy)
public Type GetProxiedType()
public ObjRef CreateObjRef(Type requestedType)
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal Identity get_ObjectIdentity()
internal void set_ObjectIdentity(Identity value)
public IntPtr GetCOMIUnknown(bool fIsMarshalled)
public void SetCOMIUnknown(IntPtr i)
public IntPtr SupportsInterface(Guid& iid)
public object GetStubData(RealProxy rp)
public void SetStubData(RealProxy rp, object stubData)
public IMessage Invoke(IMessage msg)
internal object PrivateInvoke(RealProxy rp, IMessage msg, Exception& exc, Object[]& out_args)
internal object InternalGetTransparentProxy(string className)
public object GetTransparentProxy()
public IConstructionReturnMessage InitializeServerObject(IConstructionCallMessage ctorMsg)
protected void AttachServer(MarshalByRefObject s)
protected MarshalByRefObject DetachServer()
protected MarshalByRefObject GetUnwrappedServer()
internal void SetTargetDomain(int domainId)
internal object GetAppDomainTarget()
private Object[] ProcessResponse(IMethodReturnMessage mrm, MonoMethodMessage call)
}
internal System.Runtime.Remoting.Proxies.RemotingProxy : RealProxy {
private MethodInfo _cache_GetTypeMethod
private MethodInfo _cache_GetHashCodeMethod
private IMessageSink _sink
private bool _hasEnvoySink
private ConstructionCall _ctorCall
public string TypeName
internal void .ctor(Type type, ClientIdentity identity)
internal void .ctor(Type type, string activationUrl, Object[] activationAttributes)
public IMessage Invoke(IMessage request)
internal void AttachIdentity(Identity identity)
internal IMessage ActivateRemoteObject(IMethodMessage request)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
protected void Finalize()
}
internal System.Runtime.Remoting.Proxies.TransparentProxy : object {
public RealProxy _rp
private IntPtr _class
private bool _custom_type_info
}
public System.Runtime.Remoting.RemotingConfiguration : object {
private string applicationID
private string applicationName
private string processGuid
private bool defaultConfigRead
private bool defaultDelayedConfigRead
private string _errorMode
private Hashtable wellKnownClientEntries
private Hashtable activatedClientEntries
private Hashtable wellKnownServiceEntries
private Hashtable activatedServiceEntries
private Hashtable channelTemplates
private Hashtable clientProviderTemplates
private Hashtable serverProviderTemplates
public string ApplicationId
public string ApplicationName
public CustomErrorsModes CustomErrorsMode
public string ProcessId
public string get_ApplicationId()
public string get_ApplicationName()
public void set_ApplicationName(string value)
public CustomErrorsModes get_CustomErrorsMode()
public void set_CustomErrorsMode(CustomErrorsModes value)
public string get_ProcessId()
public void Configure(string filename, bool ensureSecurity)
public void Configure(string filename)
private void ReadConfigFile(string filename)
internal void LoadDefaultDelayedChannels()
public ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes()
public ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes()
public WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes()
public WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes()
public bool IsActivationAllowed(Type svrType)
public ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType)
public ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName)
public WellKnownClientTypeEntry IsWellKnownClientType(Type svrType)
public WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName)
public void RegisterActivatedClientType(ActivatedClientTypeEntry entry)
public void RegisterActivatedClientType(Type type, string appUrl)
public void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry)
public void RegisterActivatedServiceType(Type type)
public void RegisterWellKnownClientType(Type type, string objectUrl)
public void RegisterWellKnownClientType(WellKnownClientTypeEntry entry)
public void RegisterWellKnownServiceType(Type type, string objectUri, WellKnownObjectMode mode)
public void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry)
internal void RegisterChannelTemplate(ChannelData channel)
internal void RegisterClientProviderTemplate(ProviderData prov)
internal void RegisterServerProviderTemplate(ProviderData prov)
internal void RegisterChannels(ArrayList channels, bool onlyDelayed)
internal void RegisterTypes(ArrayList types)
public bool CustomErrorsEnabled(bool isLocalRequest)
internal void SetCustomErrorsMode(string mode)
}
public System.Runtime.Remoting.RemotingException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception InnerException)
}
public System.Runtime.Remoting.RemotingServices : object {
private Hashtable uri_hash
private BinaryFormatter _serializationFormatter
private BinaryFormatter _deserializationFormatter
internal string app_id
private int next_id
private BindingFlags methodBindings
private MethodInfo FieldSetterMethod
private MethodInfo FieldGetterMethod
internal object InternalExecute(MethodBase method, object obj, Object[] parameters, Object[]& out_args)
internal MethodBase GetVirtualMethod(Type type, MethodBase method)
public bool IsTransparentProxy(object proxy)
internal IMethodReturnMessage InternalExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg)
public IMethodReturnMessage ExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg)
public object Connect(Type classToProxy, string url)
public object Connect(Type classToProxy, string url, object data)
public bool Disconnect(MarshalByRefObject obj)
public Type GetServerTypeForUri(string URI)
public string GetObjectUri(MarshalByRefObject obj)
public object Unmarshal(ObjRef objectRef)
public object Unmarshal(ObjRef objectRef, bool fRefine)
public ObjRef Marshal(MarshalByRefObject Obj)
public ObjRef Marshal(MarshalByRefObject Obj, string URI)
public ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType)
private string NewUri()
public RealProxy GetRealProxy(object proxy)
public MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg)
internal MethodBase GetMethodBaseFromName(Type type, string methodName, Type[] signature)
private MethodBase FindInterfaceMethod(Type type, string methodName, Type[] signature)
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public ObjRef GetObjRefForProxy(MarshalByRefObject obj)
public object GetLifetimeService(MarshalByRefObject obj)
public IMessageSink GetEnvoyChainForProxy(MarshalByRefObject obj)
public void LogRemotingStage(int stage)
public string GetSessionIdForMethodMessage(IMethodMessage msg)
public bool IsMethodOverloaded(IMethodMessage msg)
public bool IsObjectOutOfAppDomain(object tp)
public bool IsObjectOutOfContext(object tp)
public bool IsOneWay(MethodBase method)
internal bool IsAsyncMessage(IMessage msg)
public void SetObjectUriForMarshal(MarshalByRefObject obj, string uri)
internal object CreateClientProxy(ActivatedClientTypeEntry entry, Object[] activationAttributes)
internal object CreateClientProxy(Type objectType, string url, Object[] activationAttributes)
internal object CreateClientProxy(WellKnownClientTypeEntry entry)
internal object CreateClientProxyForContextBound(Type type, Object[] activationAttributes)
internal object CreateClientProxyForComInterop(Type type)
internal Identity GetIdentityForUri(string uri)
private string RemoveAppNameFromUri(string uri)
internal Identity GetObjectIdentity(MarshalByRefObject obj)
internal ClientIdentity GetOrCreateClientIdentity(ObjRef objRef, Type proxyType, Object& clientProxy)
private IMessageSink GetClientChannelSinkChain(string url, object channelData, String& objectUri)
internal ClientActivatedIdentity CreateContextBoundObjectIdentity(Type objectType)
internal ClientActivatedIdentity CreateClientActivatedServerIdentity(MarshalByRefObject realObject, Type objectType, string objectUri)
internal ServerIdentity CreateWellKnownServerIdentity(Type objectType, string objectUri, WellKnownObjectMode mode)
private void RegisterServerIdentity(ServerIdentity identity)
internal object GetProxyForRemoteObject(ObjRef objref, Type classToProxy)
internal object GetRemoteObject(ObjRef objRef, Type proxyType)
internal object GetServerObject(string uri)
internal Byte[] SerializeCallData(object obj)
internal object DeserializeCallData(Byte[] array)
internal Byte[] SerializeExceptionData(Exception ex)
internal object GetDomainProxy(AppDomain domain)
private void RegisterInternalChannels()
internal void DisposeIdentity(Identity ident)
internal Identity GetMessageTargetIdentity(IMessage msg)
internal void SetMessageTargetIdentity(IMessage msg, Identity ident)
internal bool UpdateOutArgObject(ParameterInfo pi, object local, object remote)
private string GetNormalizedUri(string uri)
}
public System.Runtime.Remoting.RemotingTimeoutException : RemotingException {
public void .ctor(string message)
public void .ctor(string message, Exception InnerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Remoting.ServerException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception InnerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
internal System.Runtime.Remoting.ServerIdentity : Identity {
protected Type _objectType
protected MarshalByRefObject _serverObject
protected IMessageSink _serverSink
protected Context _context
protected Lease _lease
public Type ObjectType
public Lease Lease
public Context Context
public void .ctor(string objectUri, Context context, Type objectType)
public Type get_ObjectType()
public void StartTrackingLifetime(ILease lease)
public void OnLifetimeExpired()
public ObjRef CreateObjRef(Type requestedType)
public void AttachServerObject(MarshalByRefObject serverObject, Context context)
public Lease get_Lease()
public Context get_Context()
public void set_Context(Context value)
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
protected void DisposeServerObject()
}
public System.Runtime.Remoting.Services.EnterpriseServicesHelper : object {
public IConstructionReturnMessage CreateConstructionReturnMessage(IConstructionCallMessage ctorMsg, MarshalByRefObject retObj)
public void SwitchWrappers(RealProxy oldcp, RealProxy newcp)
public object WrapIUnknownWithComObject(IntPtr punk)
}
public System.Runtime.Remoting.Services.ITrackingHandler {
public void DisconnectedObject(object obj)
public void MarshaledObject(object obj, ObjRef or)
public void UnmarshaledObject(object obj, ObjRef or)
}
public System.Runtime.Remoting.Services.TrackingServices : object {
private ArrayList _handlers
public ITrackingHandler[] RegisteredHandlers
public void RegisterTrackingHandler(ITrackingHandler handler)
public void UnregisterTrackingHandler(ITrackingHandler handler)
public ITrackingHandler[] get_RegisteredHandlers()
internal void NotifyMarshaledObject(object obj, ObjRef or)
internal void NotifyUnmarshaledObject(object obj, ObjRef or)
internal void NotifyDisconnectedObject(object obj)
}
internal System.Runtime.Remoting.SingleCallIdentity : ServerIdentity {
public void .ctor(string objectUri, Context context, Type objectType)
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
internal System.Runtime.Remoting.SingletonIdentity : ServerIdentity {
public void .ctor(string objectUri, Context context, Type objectType)
public MarshalByRefObject GetServerObject()
public IMessage SyncObjectProcessMessage(IMessage msg)
public IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink)
}
public System.Runtime.Remoting.SoapServices : object {
private Hashtable _xmlTypes
private Hashtable _xmlElements
private Hashtable _soapActions
private Hashtable _soapActionsMethods
private Hashtable _typeInfos
public string XmlNsForClrType
public string XmlNsForClrTypeWithAssembly
public string XmlNsForClrTypeWithNs
public string XmlNsForClrTypeWithNsAndAssembly
public string get_XmlNsForClrType()
public string get_XmlNsForClrTypeWithAssembly()
public string get_XmlNsForClrTypeWithNs()
public string get_XmlNsForClrTypeWithNsAndAssembly()
public string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName)
public bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, String& typeNamespace, String& assemblyName)
public void GetInteropFieldTypeAndNameFromXmlAttribute(Type containingType, string xmlAttribute, string xmlNamespace, Type& type, String& name)
public void GetInteropFieldTypeAndNameFromXmlElement(Type containingType, string xmlElement, string xmlNamespace, Type& type, String& name)
private void GetInteropFieldInfo(Hashtable fields, string xmlName, string xmlNamespace, Type& type, String& name)
private string GetNameKey(string name, string namspace)
public Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace)
public Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace)
private string GetAssemblyName(MethodBase mb)
public string GetSoapActionFromMethodBase(MethodBase mb)
public bool GetTypeAndMethodNameFromSoapAction(string soapAction, String& typeName, String& methodName)
public bool GetXmlElementForInteropType(Type type, String& xmlElement, String& xmlNamespace)
public string GetXmlNamespaceForMethodCall(MethodBase mb)
public string GetXmlNamespaceForMethodResponse(MethodBase mb)
public bool GetXmlTypeForInteropType(Type type, String& xmlType, String& xmlTypeNamespace)
public bool IsClrTypeNamespace(string namespaceString)
public bool IsSoapActionValidForMethodBase(string soapAction, MethodBase mb)
public void PreLoad(Assembly assembly)
public void PreLoad(Type type)
public void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type)
public void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type)
public void RegisterSoapActionForMethodBase(MethodBase mb)
private string InternalGetSoapAction(MethodBase mb)
public void RegisterSoapActionForMethodBase(MethodBase mb, string soapAction)
private string EncodeNs(string ns)
private string DecodeNs(string ns)
}
public System.Runtime.Remoting.TypeEntry : object {
private string assembly_name
private string type_name
public string AssemblyName
public string TypeName
public string get_AssemblyName()
public void set_AssemblyName(string value)
public string get_TypeName()
public void set_TypeName(string value)
}
internal System.Runtime.Remoting.TypeInfo : object {
private string serverType
private String[] serverHierarchy
private String[] interfacesImplemented
public string TypeName
public void .ctor(Type type)
public string get_TypeName()
public void set_TypeName(string value)
public bool CanCastTo(Type fromType, object o)
}
public System.Runtime.Remoting.WellKnownClientTypeEntry : TypeEntry {
private Type obj_type
private string obj_url
private string app_url
public string ApplicationUrl
public Type ObjectType
public string ObjectUrl
public void .ctor(Type type, string objectUrl)
public void .ctor(string typeName, string assemblyName, string objectUrl)
public string get_ApplicationUrl()
public void set_ApplicationUrl(string value)
public Type get_ObjectType()
public string get_ObjectUrl()
public string ToString()
}
public System.Runtime.Remoting.WellKnownObjectMode : Enum {
public int value__
public WellKnownObjectMode Singleton
public WellKnownObjectMode SingleCall
}
public System.Runtime.Remoting.WellKnownServiceTypeEntry : TypeEntry {
private Type obj_type
private string obj_uri
private WellKnownObjectMode obj_mode
public IContextAttribute[] ContextAttributes
public WellKnownObjectMode Mode
public Type ObjectType
public string ObjectUri
public void .ctor(Type type, string objectUri, WellKnownObjectMode mode)
public void .ctor(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode)
public IContextAttribute[] get_ContextAttributes()
public void set_ContextAttributes(IContextAttribute[] value)
public WellKnownObjectMode get_Mode()
public Type get_ObjectType()
public string get_ObjectUri()
public string ToString()
}
internal System.Runtime.Serialization.ArrayFixupRecord : BaseFixupRecord {
private int _index
public void .ctor(ObjectRecord objectToBeFixed, int index, ObjectRecord objectRequired)
protected void FixupImpl(ObjectManager manager)
}
internal System.Runtime.Serialization.BaseFixupRecord : object {
protected internal ObjectRecord ObjectToBeFixed
protected internal ObjectRecord ObjectRequired
public BaseFixupRecord NextSameContainer
public BaseFixupRecord NextSameRequired
public void .ctor(ObjectRecord objectToBeFixed, ObjectRecord objectRequired)
public bool DoFixup(ObjectManager manager, bool strict)
protected void FixupImpl(ObjectManager manager)
}
internal System.Runtime.Serialization.DelayedFixupRecord : BaseFixupRecord {
public string _memberName
public void .ctor(ObjectRecord objectToBeFixed, string memberName, ObjectRecord objectRequired)
protected void FixupImpl(ObjectManager manager)
}
internal System.Runtime.Serialization.FixupRecord : BaseFixupRecord {
public MemberInfo _member
public void .ctor(ObjectRecord objectToBeFixed, MemberInfo member, ObjectRecord objectRequired)
protected void FixupImpl(ObjectManager manager)
}
public System.Runtime.Serialization.Formatter : object {
protected ObjectIDGenerator m_idGenerator
protected Queue m_objectQueue
public SerializationBinder Binder
public StreamingContext Context
public ISurrogateSelector SurrogateSelector
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public object Deserialize(Stream serializationStream)
protected object GetNext(Int64& objID)
protected long Schedule(object obj)
public void Serialize(Stream serializationStream, object graph)
protected void WriteArray(object obj, string name, Type memberType)
protected void WriteBoolean(bool val, string name)
protected void WriteByte(byte val, string name)
protected void WriteChar(char val, string name)
protected void WriteDateTime(DateTime val, string name)
protected void WriteDecimal(decimal val, string name)
protected void WriteDouble(double val, string name)
protected void WriteInt16(short val, string name)
protected void WriteInt32(int val, string name)
protected void WriteInt64(long val, string name)
protected void WriteMember(string memberName, object data)
protected void WriteObjectRef(object obj, string name, Type memberType)
protected void WriteSByte(sbyte val, string name)
protected void WriteSingle(float val, string name)
protected void WriteTimeSpan(TimeSpan val, string name)
protected void WriteUInt16(ushort val, string name)
protected void WriteUInt32(UInt32 val, string name)
protected void WriteUInt64(ulong val, string name)
protected void WriteValueType(object obj, string name, Type memberType)
}
public System.Runtime.Serialization.FormatterConverter : object {
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public byte ToByte(object value)
public char ToChar(object value)
public DateTime ToDateTime(object value)
public decimal ToDecimal(object value)
public double ToDouble(object value)
public short ToInt16(object value)
public int ToInt32(object value)
public long ToInt64(object value)
public float ToSingle(object value)
public string ToString(object value)
public sbyte ToSByte(object value)
public ushort ToUInt16(object value)
public UInt32 ToUInt32(object value)
public ulong ToUInt64(object value)
}
internal System.Runtime.Serialization.Formatters.Binary.ArrayStructure : Enum {
public byte value__
public ArrayStructure SingleDimensional
public ArrayStructure Jagged
public ArrayStructure MultiDimensional
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryCommon : object {
public Byte[] BinaryHeader
private Type[] _typeCodesToType
private Byte[] _typeCodeMap
public bool UseReflectionSerialization
public bool IsPrimitive(Type type)
public byte GetTypeCode(Type type)
public Type GetTypeFromCode(int code)
public void CheckSerializable(Type type, ISurrogateSelector selector, StreamingContext context)
public void SwapBytes(Byte[] byteArray, int size, int dataSize)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryElement : Enum {
public byte value__
public BinaryElement Header
public BinaryElement RefTypeObject
public BinaryElement UntypedRuntimeObject
public BinaryElement UntypedExternalObject
public BinaryElement RuntimeObject
public BinaryElement ExternalObject
public BinaryElement String
public BinaryElement GenericArray
public BinaryElement BoxedPrimitiveTypeValue
public BinaryElement ObjectReference
public BinaryElement NullValue
public BinaryElement End
public BinaryElement Assembly
public BinaryElement ArrayFiller8b
public BinaryElement ArrayFiller32b
public BinaryElement ArrayOfPrimitiveType
public BinaryElement ArrayOfObject
public BinaryElement ArrayOfString
public BinaryElement Method
public BinaryElement _Unknown4
public BinaryElement _Unknown5
public BinaryElement MethodCall
public BinaryElement MethodResponse
}
public System.Runtime.Serialization.Formatters.Binary.BinaryFormatter : object {
private FormatterAssemblyStyle assembly_format
private SerializationBinder binder
private StreamingContext context
private ISurrogateSelector surrogate_selector
private FormatterTypeStyle type_format
private TypeFilterLevel filter_level
private ISurrogateSelector <DefaultSurrogateSelector>k__BackingField
public ISurrogateSelector DefaultSurrogateSelector
public FormatterAssemblyStyle AssemblyFormat
public SerializationBinder Binder
public StreamingContext Context
public ISurrogateSelector SurrogateSelector
public FormatterTypeStyle TypeFormat
public TypeFilterLevel FilterLevel
public void .ctor(ISurrogateSelector selector, StreamingContext context)
public ISurrogateSelector get_DefaultSurrogateSelector()
public void set_DefaultSurrogateSelector(ISurrogateSelector value)
public FormatterAssemblyStyle get_AssemblyFormat()
public void set_AssemblyFormat(FormatterAssemblyStyle value)
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public FormatterTypeStyle get_TypeFormat()
public void set_TypeFormat(FormatterTypeStyle value)
public TypeFilterLevel get_FilterLevel()
public void set_FilterLevel(TypeFilterLevel value)
public object Deserialize(Stream serializationStream)
public object Deserialize(Stream serializationStream, HeaderHandler handler)
private object NoCheckDeserialize(Stream serializationStream, HeaderHandler handler)
public object DeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage)
private object NoCheckDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage)
public void Serialize(Stream serializationStream, object graph)
public void Serialize(Stream serializationStream, object graph, Header[] headers)
public object UnsafeDeserialize(Stream serializationStream, HeaderHandler handler)
public object UnsafeDeserializeMethodResponse(Stream serializationStream, HeaderHandler handler, IMethodCallMessage methodCallMessage)
private void WriteBinaryHeader(BinaryWriter writer, bool hasHeaders)
private void ReadBinaryHeader(BinaryReader reader, Boolean& hasHeaders)
}
internal System.Runtime.Serialization.Formatters.Binary.BinaryTypeCode : Enum {
public byte value__
public BinaryTypeCode Boolean
public BinaryTypeCode Byte
public BinaryTypeCode Char
public BinaryTypeCode Decimal
public BinaryTypeCode Double
public BinaryTypeCode Int16
public BinaryTypeCode Int32
public BinaryTypeCode Int64
public BinaryTypeCode SByte
public BinaryTypeCode Single
public BinaryTypeCode TimeSpan
public BinaryTypeCode DateTime
public BinaryTypeCode UInt16
public BinaryTypeCode UInt32
public BinaryTypeCode UInt64
public BinaryTypeCode Null
public BinaryTypeCode String
}
internal System.Runtime.Serialization.Formatters.Binary.ClrTypeMetadata : TypeMetadata {
public Type InstanceType
public bool RequiresTypes
public void .ctor(Type instanceType)
public bool get_RequiresTypes()
}
internal System.Runtime.Serialization.Formatters.Binary.CodeGenerator : object {
private object monitor
private ModuleBuilder _module
public Type GenerateMetadataType(Type type, StreamingContext context)
public Type GenerateMetadataTypeInternal(Type type, StreamingContext context)
public void LoadFromPtr(ILGenerator ig, Type t)
private void EmitWriteTypeSpec(ILGenerator gen, Type type, string member)
private void EmitLoadTypeAssembly(ILGenerator gen, Type type, string member)
private void EmitWrite(ILGenerator gen, Type type)
public void EmitWritePrimitiveValue(ILGenerator gen, Type type)
public Type EnumToUnderlying(Type t)
}
internal System.Runtime.Serialization.Formatters.Binary.MemberTypeMetadata : ClrTypeMetadata {
private MemberInfo[] members
public void .ctor(Type type, StreamingContext context)
public void WriteAssemblies(ObjectWriter ow, BinaryWriter writer)
public void WriteTypeData(ObjectWriter ow, BinaryWriter writer, bool writeTypes)
public void WriteObjectData(ObjectWriter ow, BinaryWriter writer, object data)
}
internal System.Runtime.Serialization.Formatters.Binary.MessageFormatter : object {
public void WriteMethodCall(BinaryWriter writer, object obj, Header[] headers, ISurrogateSelector surrogateSelector, StreamingContext context, FormatterAssemblyStyle assemblyFormat, FormatterTypeStyle typeFormat)
public void WriteMethodResponse(BinaryWriter writer, object obj, Header[] headers, ISurrogateSelector surrogateSelector, StreamingContext context, FormatterAssemblyStyle assemblyFormat, FormatterTypeStyle typeFormat)
public object ReadMethodCall(BinaryReader reader, bool hasHeaders, HeaderHandler headerHandler, BinaryFormatter formatter)
public object ReadMethodCall(BinaryElement elem, BinaryReader reader, bool hasHeaders, HeaderHandler headerHandler, BinaryFormatter formatter)
public object ReadMethodResponse(BinaryReader reader, bool hasHeaders, HeaderHandler headerHandler, IMethodCallMessage methodCallMessage, BinaryFormatter formatter)
public object ReadMethodResponse(BinaryElement elem, BinaryReader reader, bool hasHeaders, HeaderHandler headerHandler, IMethodCallMessage methodCallMessage, BinaryFormatter formatter)
private bool AllTypesArePrimitive(Object[] objects)
public bool IsMethodPrimitive(Type type)
private Object[] GetExtraProperties(IDictionary properties, String[] internalKeys)
private bool IsInternalKey(string key, String[] internalKeys)
}
internal System.Runtime.Serialization.Formatters.Binary.MethodFlags : Enum {
public int value__
public MethodFlags NoArguments
public MethodFlags PrimitiveArguments
public MethodFlags ArgumentsInSimpleArray
public MethodFlags ArgumentsInMultiArray
public MethodFlags ExcludeLogicalCallContext
public MethodFlags IncludesLogicalCallContext
public MethodFlags IncludesSignature
public MethodFlags FormatMask
public MethodFlags GenericArguments
public MethodFlags NeedsInfoArrayMask
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectReader : object {
private ISurrogateSelector _surrogateSelector
private StreamingContext _context
private SerializationBinder _binder
private TypeFilterLevel _filterLevel
private ObjectManager _manager
private Hashtable _registeredAssemblies
private Hashtable _typeMetadataCache
private object _lastObject
private long _lastObjectID
private long _rootObjectID
private Byte[] arrayBuffer
private int ArrayBufferLength
public object CurrentObject
public void .ctor(BinaryFormatter formatter)
public void ReadObjectGraph(BinaryReader reader, bool readHeaders, Object& result, Header[]& headers)
public void ReadObjectGraph(BinaryElement elem, BinaryReader reader, bool readHeaders, Object& result, Header[]& headers)
private bool ReadNextObject(BinaryElement element, BinaryReader reader)
public bool ReadNextObject(BinaryReader reader)
public object get_CurrentObject()
private void ReadObject(BinaryElement element, BinaryReader reader, Int64& objectId, Object& value, SerializationInfo& info)
private void ReadAssembly(BinaryReader reader)
private void ReadObjectInstance(BinaryReader reader, bool isRuntimeObject, bool hasTypeInfo, Int64& objectId, Object& value, SerializationInfo& info)
private void ReadRefTypeObjectInstance(BinaryReader reader, Int64& objectId, Object& value, SerializationInfo& info)
private void ReadObjectContent(BinaryReader reader, TypeMetadata metadata, long objectId, Object& objectInstance, SerializationInfo& info)
private void RegisterObject(long objectId, object objectInstance, SerializationInfo info, long parentObjectId, MemberInfo parentObjectMemeber, Int32[] indices)
private void ReadStringIntance(BinaryReader reader, Int64& objectId, Object& value)
private void ReadGenericArray(BinaryReader reader, Int64& objectId, Object& val)
private object ReadBoxedPrimitiveTypeValue(BinaryReader reader)
private void ReadArrayOfPrimitiveType(BinaryReader reader, Int64& objectId, Object& val)
private void BlockRead(BinaryReader reader, Array array, int dataSize)
private void ReadArrayOfObject(BinaryReader reader, Int64& objectId, Object& array)
private void ReadArrayOfString(BinaryReader reader, Int64& objectId, Object& array)
private void ReadSimpleArray(BinaryReader reader, Type elementType, Int64& objectId, Object& val)
private TypeMetadata ReadTypeMetadata(BinaryReader reader, bool isRuntimeObject, bool hasTypeInfo)
private void ReadValue(BinaryReader reader, object parentObject, long parentObjectId, SerializationInfo info, Type valueType, string fieldName, MemberInfo memberInfo, Int32[] indices)
private void SetObjectValue(object parentObject, string fieldName, MemberInfo memberInfo, SerializationInfo info, object value, Type valueType, Int32[] indices)
private void RecordFixup(long parentObjectId, long childObjectId, object parentObject, SerializationInfo info, string fieldName, MemberInfo memberInfo, Int32[] indices)
private Type GetDeserializationType(long assemblyId, string className)
public Type ReadType(BinaryReader reader, TypeTag code)
public object ReadPrimitiveTypeValue(BinaryReader reader, Type type)
}
internal System.Runtime.Serialization.Formatters.Binary.ObjectWriter : object {
private ObjectIDGenerator _idGenerator
private Hashtable _cachedMetadata
private Queue _pendingObjects
private Hashtable _assemblyCache
private Hashtable _cachedTypes
internal Assembly CorlibAssembly
internal string CorlibAssemblyName
private ISurrogateSelector _surrogateSelector
private StreamingContext _context
private FormatterAssemblyStyle _assemblyFormat
private FormatterTypeStyle _typeFormat
private Byte[] arrayBuffer
private int ArrayBufferLength
private SerializationObjectManager _manager
public void .ctor(ISurrogateSelector surrogateSelector, StreamingContext context, FormatterAssemblyStyle assemblyFormat, FormatterTypeStyle typeFormat)
public void WriteObjectGraph(BinaryWriter writer, object obj, Header[] headers)
public void QueueObject(object obj)
public void WriteQueuedObjects(BinaryWriter writer)
public void WriteObjectInstance(BinaryWriter writer, object obj, bool isValueObject)
public void WriteSerializationEnd(BinaryWriter writer)
private void WriteObject(BinaryWriter writer, long id, object obj)
private void GetObjectData(object obj, TypeMetadata& metadata, Object& data)
private TypeMetadata CreateMemberTypeMetadata(Type type)
private void WriteArray(BinaryWriter writer, long id, Array array)
private void WriteGenericArray(BinaryWriter writer, long id, Array array)
private void WriteObjectArray(BinaryWriter writer, long id, Array array)
private void WriteStringArray(BinaryWriter writer, long id, Array array)
private void WritePrimitiveTypeArray(BinaryWriter writer, long id, Array array)
private void BlockWrite(BinaryWriter writer, Array array, int dataSize)
private void WriteSingleDimensionArrayElements(BinaryWriter writer, Array array, Type elementType)
private void WriteNullFiller(BinaryWriter writer, int numNulls)
private void WriteObjectReference(BinaryWriter writer, long id)
public void WriteValue(BinaryWriter writer, Type valueType, object val)
private void WriteString(BinaryWriter writer, long id, string str)
public int WriteAssembly(BinaryWriter writer, Assembly assembly)
public int WriteAssemblyName(BinaryWriter writer, string assembly)
public int GetAssemblyId(Assembly assembly)
public int GetAssemblyNameId(string assembly)
private int RegisterAssembly(string assembly, Boolean& firstTime)
public void WritePrimitiveValue(BinaryWriter writer, object value)
public void WriteTypeCode(BinaryWriter writer, Type type)
public TypeTag GetTypeTag(Type type)
public void WriteTypeSpec(BinaryWriter writer, Type type)
}
internal System.Runtime.Serialization.Formatters.Binary.ReturnTypeTag : Enum {
public byte value__
public ReturnTypeTag Null
public ReturnTypeTag PrimitiveType
public ReturnTypeTag ObjectType
public ReturnTypeTag Exception
}
internal System.Runtime.Serialization.Formatters.Binary.SerializableTypeMetadata : TypeMetadata {
private Type[] types
private String[] names
public bool RequiresTypes
public void .ctor(Type itype, SerializationInfo info)
public bool IsCompatible(TypeMetadata other)
public void WriteAssemblies(ObjectWriter ow, BinaryWriter writer)
public void WriteTypeData(ObjectWriter ow, BinaryWriter writer, bool writeTypes)
public void WriteObjectData(ObjectWriter ow, BinaryWriter writer, object data)
public bool get_RequiresTypes()
}
internal System.Runtime.Serialization.Formatters.Binary.TypeMetadata : object {
public string TypeAssemblyName
public string InstanceTypeName
public bool RequiresTypes
public void WriteAssemblies(ObjectWriter ow, BinaryWriter writer)
public void WriteTypeData(ObjectWriter ow, BinaryWriter writer, bool writeTypes)
public void WriteObjectData(ObjectWriter ow, BinaryWriter writer, object data)
public bool IsCompatible(TypeMetadata other)
public bool get_RequiresTypes()
}
internal System.Runtime.Serialization.Formatters.Binary.TypeTag : Enum {
public byte value__
public TypeTag PrimitiveType
public TypeTag String
public TypeTag ObjectType
public TypeTag RuntimeType
public TypeTag GenericType
public TypeTag ArrayOfObject
public TypeTag ArrayOfString
public TypeTag ArrayOfPrimitiveType
}
public System.Runtime.Serialization.Formatters.FormatterAssemblyStyle : Enum {
public int value__
public FormatterAssemblyStyle Simple
public FormatterAssemblyStyle Full
}
public System.Runtime.Serialization.Formatters.FormatterTypeStyle : Enum {
public int value__
public FormatterTypeStyle TypesWhenNeeded
public FormatterTypeStyle TypesAlways
public FormatterTypeStyle XsdString
}
public System.Runtime.Serialization.Formatters.IFieldInfo {
public String[] FieldNames
public Type[] FieldTypes
public String[] get_FieldNames()
public void set_FieldNames(String[] value)
public Type[] get_FieldTypes()
public void set_FieldTypes(Type[] value)
}
public System.Runtime.Serialization.Formatters.InternalRM : object {
public void InfoSoap(Object[] messages)
public bool SoapCheckEnabled()
}
public System.Runtime.Serialization.Formatters.InternalST : object {
public void InfoSoap(Object[] messages)
public Assembly LoadAssemblyFromString(string assemblyString)
public void SerializationSetValue(FieldInfo fi, object target, object value)
public void Soap(Object[] messages)
public void SoapAssert(bool condition, string message)
public bool SoapCheckEnabled()
}
public System.Runtime.Serialization.Formatters.ISoapMessage {
public Header[] Headers
public string MethodName
public String[] ParamNames
public Type[] ParamTypes
public Object[] ParamValues
public string XmlNameSpace
public Header[] get_Headers()
public void set_Headers(Header[] value)
public string get_MethodName()
public void set_MethodName(string value)
public String[] get_ParamNames()
public void set_ParamNames(String[] value)
public Type[] get_ParamTypes()
public void set_ParamTypes(Type[] value)
public Object[] get_ParamValues()
public void set_ParamValues(Object[] value)
public string get_XmlNameSpace()
public void set_XmlNameSpace(string value)
}
public System.Runtime.Serialization.Formatters.ServerFault : object {
private string exceptionType
private string message
private string stackTrace
private Exception exception
public string ExceptionType
public string ExceptionMessage
public string StackTrace
public void .ctor(string exceptionType, string message, string stackTrace)
public string get_ExceptionType()
public void set_ExceptionType(string value)
public string get_ExceptionMessage()
public void set_ExceptionMessage(string value)
public string get_StackTrace()
public void set_StackTrace(string value)
}
public System.Runtime.Serialization.Formatters.SoapFault : object {
private string code
private string actor
private string faultString
private object detail
public object Detail
public string FaultActor
public string FaultCode
public string FaultString
private void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string faultCode, string faultString, string faultActor, ServerFault serverFault)
public object get_Detail()
public void set_Detail(object value)
public string get_FaultActor()
public void set_FaultActor(string value)
public string get_FaultCode()
public void set_FaultCode(string value)
public string get_FaultString()
public void set_FaultString(string value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Serialization.Formatters.SoapMessage : object {
private Header[] headers
private string methodName
private String[] paramNames
private Type[] paramTypes
private Object[] paramValues
private string xmlNameSpace
public Header[] Headers
public string MethodName
public String[] ParamNames
public Type[] ParamTypes
public Object[] ParamValues
public string XmlNameSpace
public Header[] get_Headers()
public void set_Headers(Header[] value)
public string get_MethodName()
public void set_MethodName(string value)
public String[] get_ParamNames()
public void set_ParamNames(String[] value)
public Type[] get_ParamTypes()
public void set_ParamTypes(Type[] value)
public Object[] get_ParamValues()
public void set_ParamValues(Object[] value)
public string get_XmlNameSpace()
public void set_XmlNameSpace(string value)
}
public System.Runtime.Serialization.Formatters.TypeFilterLevel : Enum {
public int value__
public TypeFilterLevel Low
public TypeFilterLevel Full
}
public System.Runtime.Serialization.FormatterServices : object {
private BindingFlags fieldFlags
public Object[] GetObjectData(object obj, MemberInfo[] members)
public MemberInfo[] GetSerializableMembers(Type type)
public MemberInfo[] GetSerializableMembers(Type type, StreamingContext context)
private void GetFields(Type reflectedType, Type type, ArrayList fields)
public Type GetTypeFromAssembly(Assembly assem, string name)
public object GetUninitializedObject(Type type)
public object PopulateObjectMembers(object obj, MemberInfo[] members, Object[] data)
public void CheckTypeSecurity(Type t, TypeFilterLevel securityLevel)
private void CheckNotAssignable(Type basetype, Type type)
public object GetSafeUninitializedObject(Type type)
}
public System.Runtime.Serialization.IDeserializationCallback {
public void OnDeserialization(object sender)
}
public System.Runtime.Serialization.IFormatter {
public SerializationBinder Binder
public StreamingContext Context
public ISurrogateSelector SurrogateSelector
public SerializationBinder get_Binder()
public void set_Binder(SerializationBinder value)
public StreamingContext get_Context()
public void set_Context(StreamingContext value)
public ISurrogateSelector get_SurrogateSelector()
public void set_SurrogateSelector(ISurrogateSelector value)
public object Deserialize(Stream serializationStream)
public void Serialize(Stream serializationStream, object graph)
}
public System.Runtime.Serialization.IFormatterConverter {
public object Convert(object value, Type type)
public object Convert(object value, TypeCode typeCode)
public bool ToBoolean(object value)
public byte ToByte(object value)
public char ToChar(object value)
public DateTime ToDateTime(object value)
public decimal ToDecimal(object value)
public double ToDouble(object value)
public short ToInt16(object value)
public int ToInt32(object value)
public long ToInt64(object value)
public sbyte ToSByte(object value)
public float ToSingle(object value)
public string ToString(object value)
public ushort ToUInt16(object value)
public UInt32 ToUInt32(object value)
public ulong ToUInt64(object value)
}
public System.Runtime.Serialization.IObjectReference {
public object GetRealObject(StreamingContext context)
}
public System.Runtime.Serialization.ISerializable {
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Serialization.ISerializationSurrogate {
public void GetObjectData(object obj, SerializationInfo info, StreamingContext context)
public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector)
}
public System.Runtime.Serialization.ISurrogateSelector {
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
}
internal System.Runtime.Serialization.MultiArrayFixupRecord : BaseFixupRecord {
private Int32[] _indices
public void .ctor(ObjectRecord objectToBeFixed, Int32[] indices, ObjectRecord objectRequired)
protected void FixupImpl(ObjectManager manager)
}
public System.Runtime.Serialization.ObjectIDGenerator : object {
private Hashtable table
private long current
private InstanceComparer comparer
internal long NextId
public long GetId(object obj, Boolean& firstTime)
public long HasId(object obj, Boolean& firstTime)
internal long get_NextId()
}
public System.Runtime.Serialization.ObjectManager : object {
private ObjectRecord _objectRecordChain
private ObjectRecord _lastObjectRecord
private ArrayList _deserializedRecords
private ArrayList _onDeserializedCallbackRecords
private Hashtable _objectRecords
private bool _finalFixup
private ISurrogateSelector _selector
private StreamingContext _context
private int _registeredObjectsCount
public void .ctor(ISurrogateSelector selector, StreamingContext context)
public void DoFixups()
internal ObjectRecord GetObjectRecord(long objectID)
public object GetObject(long objectID)
public void RaiseDeserializationEvent()
public void RaiseOnDeserializingEvent(object obj)
private void RaiseOnDeserializedEvent(object obj)
private void AddFixup(BaseFixupRecord record)
public void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired)
public void RecordArrayElementFixup(long arrayToBeFixed, Int32[] indices, long objectRequired)
public void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired)
public void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired)
private void RegisterObjectInternal(object obj, ObjectRecord record)
public void RegisterObject(object obj, long objectID)
public void RegisterObject(object obj, long objectID, SerializationInfo info)
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member)
public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, Int32[] arrayIndex)
}
internal System.Runtime.Serialization.ObjectRecord : object {
public ObjectRecordStatus Status
public object OriginalObject
public object ObjectInstance
public long ObjectID
public SerializationInfo Info
public long IdOfContainingObj
public ISerializationSurrogate Surrogate
public ISurrogateSelector SurrogateSelector
public MemberInfo Member
public Int32[] ArrayIndex
public BaseFixupRecord FixupChainAsContainer
public BaseFixupRecord FixupChainAsRequired
public ObjectRecord Next
public bool IsInstanceReady
public bool IsUnsolvedObjectReference
public bool IsRegistered
public bool HasPendingFixups
public void SetMemberValue(ObjectManager manager, MemberInfo member, object value)
public void SetArrayValue(ObjectManager manager, object value, Int32[] indices)
public void SetMemberValue(ObjectManager manager, string memberName, object value)
public bool get_IsInstanceReady()
public bool get_IsUnsolvedObjectReference()
public bool get_IsRegistered()
public bool DoFixups(bool asContainer, ObjectManager manager, bool strict)
public void RemoveFixup(BaseFixupRecord fixupToRemove, bool asContainer)
private void UnchainFixup(BaseFixupRecord fixup, BaseFixupRecord prevFixup, bool asContainer)
public void ChainFixup(BaseFixupRecord fixup, bool asContainer)
public bool LoadData(ObjectManager manager, ISurrogateSelector selector, StreamingContext context)
public bool get_HasPendingFixups()
}
internal System.Runtime.Serialization.ObjectRecordStatus : Enum {
public byte value__
public ObjectRecordStatus Unregistered
public ObjectRecordStatus ReferenceUnsolved
public ObjectRecordStatus ReferenceSolvingDelayed
public ObjectRecordStatus ReferenceSolved
}
public System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
private int version_added
public int VersionAdded
public int get_VersionAdded()
public void set_VersionAdded(int value)
}
public System.Runtime.Serialization.SerializationBinder : object {
public Type BindToType(string assemblyName, string typeName)
}
internal System.Runtime.Serialization.SerializationCallbacks : object {
private BindingFlags DefaultBindingFlags
private ArrayList onSerializingList
private ArrayList onSerializedList
private ArrayList onDeserializingList
private ArrayList onDeserializedList
private Hashtable cache
private object cache_lock
public bool HasSerializingCallbacks
public bool HasSerializedCallbacks
public bool HasDeserializingCallbacks
public bool HasDeserializedCallbacks
public void .ctor(Type type)
public bool get_HasSerializingCallbacks()
public bool get_HasSerializedCallbacks()
public bool get_HasDeserializingCallbacks()
public bool get_HasDeserializedCallbacks()
private ArrayList GetMethodsByAttribute(Type type, Type attr)
private void Invoke(ArrayList list, object target, StreamingContext context)
public void RaiseOnSerializing(object target, StreamingContext contex)
public void RaiseOnSerialized(object target, StreamingContext contex)
public void RaiseOnDeserializing(object target, StreamingContext contex)
public void RaiseOnDeserialized(object target, StreamingContext contex)
public SerializationCallbacks GetSerializationCallbacks(Type t)
}
public System.Runtime.Serialization.SerializationEntry : ValueType {
private string name
private Type objectType
private object value
public string Name
public Type ObjectType
public object Value
internal void .ctor(string name, Type type, object value)
public string get_Name()
public Type get_ObjectType()
public object get_Value()
}
public System.Runtime.Serialization.SerializationException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Runtime.Serialization.SerializationInfo : object {
private Hashtable serialized
private ArrayList values
private string assemblyName
private string fullTypeName
private IFormatterConverter converter
public string AssemblyName
public string FullTypeName
public int MemberCount
private void .ctor(Type type)
private void .ctor(Type type, SerializationEntry[] data)
public void .ctor(Type type, IFormatterConverter converter)
public string get_AssemblyName()
public void set_AssemblyName(string value)
public string get_FullTypeName()
public void set_FullTypeName(string value)
public int get_MemberCount()
public void AddValue(string name, object value, Type type)
public object GetValue(string name, Type type)
public void SetType(Type type)
public SerializationInfoEnumerator GetEnumerator()
public void AddValue(string name, short value)
public void AddValue(string name, ushort value)
public void AddValue(string name, int value)
public void AddValue(string name, byte value)
public void AddValue(string name, bool value)
public void AddValue(string name, char value)
public void AddValue(string name, sbyte value)
public void AddValue(string name, double value)
public void AddValue(string name, decimal value)
public void AddValue(string name, DateTime value)
public void AddValue(string name, float value)
public void AddValue(string name, UInt32 value)
public void AddValue(string name, long value)
public void AddValue(string name, ulong value)
public void AddValue(string name, object value)
public bool GetBoolean(string name)
public byte GetByte(string name)
public char GetChar(string name)
public DateTime GetDateTime(string name)
public decimal GetDecimal(string name)
public double GetDouble(string name)
public short GetInt16(string name)
public int GetInt32(string name)
public long GetInt64(string name)
public sbyte GetSByte(string name)
public float GetSingle(string name)
public string GetString(string name)
public ushort GetUInt16(string name)
public UInt32 GetUInt32(string name)
public ulong GetUInt64(string name)
private SerializationEntry[] get_entries()
}
public System.Runtime.Serialization.SerializationInfoEnumerator : object {
private IEnumerator enumerator
private object System.Collections.IEnumerator.Current
public SerializationEntry Current
public string Name
public Type ObjectType
public object Value
internal void .ctor(ArrayList list)
private object System.Collections.IEnumerator.get_Current()
public SerializationEntry get_Current()
public string get_Name()
public Type get_ObjectType()
public object get_Value()
public bool MoveNext()
public void Reset()
}
public System.Runtime.Serialization.SerializationObjectManager : object {
private StreamingContext context
private Hashtable seen
private CallbackHandler callbacks
public void .ctor(StreamingContext context)
private void add_callbacks(CallbackHandler value)
private void remove_callbacks(CallbackHandler value)
public void RegisterObject(object obj)
public void RaiseOnSerializedEvent()
}
public System.Runtime.Serialization.StreamingContext : ValueType {
private StreamingContextStates state
private object additional
public object Context
public StreamingContextStates State
public void .ctor(StreamingContextStates state)
public void .ctor(StreamingContextStates state, object additional)
public object get_Context()
public StreamingContextStates get_State()
public bool Equals(object obj)
public int GetHashCode()
}
public System.Runtime.Serialization.StreamingContextStates : Enum {
public int value__
public StreamingContextStates CrossProcess
public StreamingContextStates CrossMachine
public StreamingContextStates File
public StreamingContextStates Persistence
public StreamingContextStates Remoting
public StreamingContextStates Other
public StreamingContextStates Clone
public StreamingContextStates CrossAppDomain
public StreamingContextStates All
}
public System.Runtime.Serialization.SurrogateSelector : object {
private Hashtable Surrogates
private ISurrogateSelector nextSelector
public void AddSurrogate(Type type, StreamingContext context, ISerializationSurrogate surrogate)
public void ChainSelector(ISurrogateSelector selector)
public ISurrogateSelector GetNextSelector()
public ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, ISurrogateSelector& selector)
public void RemoveSurrogate(Type type, StreamingContext context)
}
public System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
private ResourceScope resource
private ResourceScope consumption
public ResourceScope ConsumptionScope
public ResourceScope ResourceScope
public void .ctor(ResourceScope resourceScope)
public void .ctor(ResourceScope resourceScope, ResourceScope consumptionScope)
public ResourceScope get_ConsumptionScope()
public ResourceScope get_ResourceScope()
}
public System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
private ResourceScope exposure
public ResourceScope ResourceExposureLevel
public void .ctor(ResourceScope exposureLevel)
public ResourceScope get_ResourceExposureLevel()
}
public System.Runtime.Versioning.ResourceScope : Enum {
public int value__
public ResourceScope None
public ResourceScope Machine
public ResourceScope Process
public ResourceScope AppDomain
public ResourceScope Library
public ResourceScope Private
public ResourceScope Assembly
}
public System.Runtime.Versioning.VersioningHelper : object {
private int GetDomainId()
private int GetProcessId()
private string SafeName(string name, bool process, bool appdomain)
private string ConvertFromMachine(string name, ResourceScope to, Type type)
private string ConvertFromProcess(string name, ResourceScope to, Type type)
private string ConvertFromAppDomain(string name, ResourceScope to, Type type)
public string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to)
public string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type)
}
public System.RuntimeArgumentHandle : ValueType {
internal IntPtr args
}
public System.RuntimeFieldHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public bool Equals(RuntimeFieldHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right)
public bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right)
}
public System.RuntimeMethodHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr v)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
private IntPtr GetFunctionPointer(IntPtr m)
public IntPtr GetFunctionPointer()
public bool Equals(object obj)
public bool Equals(RuntimeMethodHandle handle)
public int GetHashCode()
public bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right)
public bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right)
}
public System.RuntimeTypeHandle : ValueType {
private IntPtr value
public IntPtr Value
internal void .ctor(IntPtr val)
private void .ctor(SerializationInfo info, StreamingContext context)
public IntPtr get_Value()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public bool Equals(RuntimeTypeHandle handle)
public int GetHashCode()
public ModuleHandle GetModuleHandle()
public bool op_Equality(RuntimeTypeHandle left, object right)
public bool op_Inequality(RuntimeTypeHandle left, object right)
public bool op_Equality(object left, RuntimeTypeHandle right)
public bool op_Inequality(object left, RuntimeTypeHandle right)
}
public System.SByte : ValueType {
public sbyte MinValue
public sbyte MaxValue
internal sbyte m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object obj)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(sbyte value)
public bool Equals(sbyte obj)
internal bool Parse(string s, bool tryParse, SByte& result, Exception& exc)
public sbyte Parse(string s, IFormatProvider provider)
public sbyte Parse(string s, NumberStyles style)
public sbyte Parse(string s, NumberStyles style, IFormatProvider provider)
public sbyte Parse(string s)
public bool TryParse(string s, SByte& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.Security.AccessControl.AccessControlActions : Enum {
public int value__
public AccessControlActions None
public AccessControlActions View
public AccessControlActions Change
}
public System.Security.AccessControl.AccessControlModification : Enum {
public int value__
public AccessControlModification Add
public AccessControlModification Set
public AccessControlModification Reset
public AccessControlModification Remove
public AccessControlModification RemoveAll
public AccessControlModification RemoveSpecific
}
public System.Security.AccessControl.AccessControlSections : Enum {
public int value__
public AccessControlSections None
public AccessControlSections Audit
public AccessControlSections Access
public AccessControlSections Owner
public AccessControlSections Group
public AccessControlSections All
}
public System.Security.AccessControl.AccessControlType : Enum {
public int value__
public AccessControlType Allow
public AccessControlType Deny
}
public System.Security.AccessControl.AccessRule : AuthorizationRule {
private AccessControlType type
public AccessControlType AccessControlType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public AccessControlType get_AccessControlType()
}
public System.Security.AccessControl.AceEnumerator : object {
private GenericAcl owner
private int current
private object System.Collections.IEnumerator.Current
public GenericAce Current
internal void .ctor(GenericAcl owner)
private object System.Collections.IEnumerator.get_Current()
public GenericAce get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.AccessControl.AceFlags : Enum {
public byte value__
public AceFlags None
public AceFlags ObjectInherit
public AceFlags ContainerInherit
public AceFlags NoPropagateInherit
public AceFlags InheritOnly
public AceFlags InheritanceFlags
public AceFlags Inherited
public AceFlags SuccessfulAccess
public AceFlags FailedAccess
public AceFlags AuditFlags
}
public System.Security.AccessControl.AceQualifier : Enum {
public int value__
public AceQualifier AccessAllowed
public AceQualifier AccessDenied
public AceQualifier SystemAudit
public AceQualifier SystemAlarm
}
public System.Security.AccessControl.AceType : Enum {
public int value__
public AceType AccessAllowed
public AceType AccessDenied
public AceType SystemAudit
public AceType SystemAlarm
public AceType AccessAllowedCompound
public AceType AccessAllowedObject
public AceType AccessDeniedObject
public AceType SystemAuditObject
public AceType SystemAlarmObject
public AceType AccessAllowedCallback
public AceType AccessDeniedCallback
public AceType AccessAllowedCallbackObject
public AceType AccessDeniedCallbackObject
public AceType SystemAuditCallback
public AceType SystemAlarmCallback
public AceType SystemAuditCallbackObject
public AceType SystemAlarmCallbackObject
public AceType MaxDefinedAceType
}
public System.Security.AccessControl.AuditFlags : Enum {
public int value__
public AuditFlags None
public AuditFlags Success
public AuditFlags Failure
}
public System.Security.AccessControl.AuditRule : AuthorizationRule {
private AuditFlags auditFlags
public AuditFlags AuditFlags
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags)
public AuditFlags get_AuditFlags()
}
public System.Security.AccessControl.AuthorizationRule : object {
private IdentityReference identity
private int accessMask
private bool isInherited
private InheritanceFlags inheritanceFlags
private PropagationFlags propagationFlags
public IdentityReference IdentityReference
public InheritanceFlags InheritanceFlags
public bool IsInherited
public PropagationFlags PropagationFlags
protected internal int AccessMask
protected internal void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public IdentityReference get_IdentityReference()
public InheritanceFlags get_InheritanceFlags()
public bool get_IsInherited()
public PropagationFlags get_PropagationFlags()
protected internal int get_AccessMask()
}
public System.Security.AccessControl.AuthorizationRuleCollection : ReadOnlyCollectionBase {
public AuthorizationRule Item
private void .ctor(AuthorizationRule[] rules)
public AuthorizationRule get_Item(int index)
public void CopyTo(AuthorizationRule[] rules, int index)
}
public System.Security.AccessControl.CommonAce : QualifiedAce {
public int BinaryLength
public void .ctor(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, Byte[] opaque)
public int get_BinaryLength()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int MaxOpaqueLength(bool isCallback)
}
public System.Security.AccessControl.CommonAcl : GenericAcl {
private int default_capacity
private bool is_container
private bool is_ds
private byte revision
private List`1<GenericAce> list
public int BinaryLength
public int Count
public bool IsCanonical
public bool IsContainer
public bool IsDS
public GenericAce Item
public byte Revision
internal void .ctor(bool isContainer, bool isDS, byte revision)
internal void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
public int get_BinaryLength()
public int get_Count()
public bool get_IsCanonical()
public bool get_IsContainer()
public bool get_IsDS()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public byte get_Revision()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public void Purge(SecurityIdentifier sid)
public void RemoveInheritedAces()
}
public System.Security.AccessControl.CommonObjectSecurity : ObjectSecurity {
private List`1<AccessRule> access_rules
private List`1<AuditRule> audit_rules
protected void .ctor(bool isContainer)
public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType)
public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType)
protected void AddAccessRule(AccessRule rule)
protected bool RemoveAccessRule(AccessRule rule)
protected void RemoveAccessRuleAll(AccessRule rule)
protected void RemoveAccessRuleSpecific(AccessRule rule)
protected void ResetAccessRule(AccessRule rule)
protected void SetAccessRule(AccessRule rule)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected void AddAuditRule(AuditRule rule)
protected bool RemoveAuditRule(AuditRule rule)
protected void RemoveAuditRuleAll(AuditRule rule)
protected void RemoveAuditRuleSpecific(AuditRule rule)
protected void SetAuditRule(AuditRule rule)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
}
public System.Security.AccessControl.CommonSecurityDescriptor : GenericSecurityDescriptor {
private bool isContainer
private bool isDS
private ControlFlags flags
private SecurityIdentifier owner
private SecurityIdentifier group
private SystemAcl systemAcl
private DiscretionaryAcl discretionaryAcl
public ControlFlags ControlFlags
public DiscretionaryAcl DiscretionaryAcl
public SecurityIdentifier Group
public bool IsContainer
public bool IsDiscretionaryAclCanonical
public bool IsDS
public bool IsSystemAclCanonical
public SecurityIdentifier Owner
public SystemAcl SystemAcl
public void .ctor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor)
public void .ctor(bool isContainer, bool isDS, string sddlForm)
public void .ctor(bool isContainer, bool isDS, Byte[] binaryForm, int offset)
public void .ctor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl)
public ControlFlags get_ControlFlags()
public DiscretionaryAcl get_DiscretionaryAcl()
public void set_DiscretionaryAcl(DiscretionaryAcl value)
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public bool get_IsContainer()
public bool get_IsDiscretionaryAclCanonical()
public bool get_IsDS()
public bool get_IsSystemAclCanonical()
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public SystemAcl get_SystemAcl()
public void set_SystemAcl(SystemAcl value)
public void PurgeAccessControl(SecurityIdentifier sid)
public void PurgeAudit(SecurityIdentifier sid)
public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance)
public void SetSystemAclProtection(bool isProtected, bool preserveInheritance)
}
public System.Security.AccessControl.CompoundAce : KnownAce {
private CompoundAceType compound_ace_type
public int BinaryLength
public CompoundAceType CompoundAceType
public void .ctor(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid)
public int get_BinaryLength()
public CompoundAceType get_CompoundAceType()
public void set_CompoundAceType(CompoundAceType value)
public void GetBinaryForm(Byte[] binaryForm, int offset)
}
public System.Security.AccessControl.CompoundAceType : Enum {
public int value__
public CompoundAceType Impersonation
}
public System.Security.AccessControl.ControlFlags : Enum {
public int value__
public ControlFlags None
public ControlFlags OwnerDefaulted
public ControlFlags GroupDefaulted
public ControlFlags DiscretionaryAclPresent
public ControlFlags DiscretionaryAclDefaulted
public ControlFlags SystemAclPresent
public ControlFlags SystemAclDefaulted
public ControlFlags DiscretionaryAclUntrusted
public ControlFlags ServerSecurity
public ControlFlags DiscretionaryAclAutoInheritRequired
public ControlFlags SystemAclAutoInheritRequired
public ControlFlags DiscretionaryAclAutoInherited
public ControlFlags SystemAclAutoInherited
public ControlFlags DiscretionaryAclProtected
public ControlFlags SystemAclProtected
public ControlFlags RMControlValid
public ControlFlags SelfRelative
}
public System.Security.AccessControl.CryptoKeyAccessRule : AccessRule {
private CryptoKeyRights rights
public CryptoKeyRights CryptoKeyRights
public void .ctor(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AccessControlType type)
public void .ctor(string identity, CryptoKeyRights cryptoKeyRights, AccessControlType type)
public CryptoKeyRights get_CryptoKeyRights()
}
public System.Security.AccessControl.CryptoKeyAuditRule : AuditRule {
private CryptoKeyRights rights
public CryptoKeyRights CryptoKeyRights
public void .ctor(IdentityReference identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags)
public void .ctor(string identity, CryptoKeyRights cryptoKeyRights, AuditFlags flags)
public CryptoKeyRights get_CryptoKeyRights()
}
public System.Security.AccessControl.CryptoKeyRights : Enum {
public int value__
public CryptoKeyRights ReadData
public CryptoKeyRights WriteData
public CryptoKeyRights ReadExtendedAttributes
public CryptoKeyRights WriteExtendedAttributes
public CryptoKeyRights ReadAttributes
public CryptoKeyRights WriteAttributes
public CryptoKeyRights Delete
public CryptoKeyRights ReadPermissions
public CryptoKeyRights ChangePermissions
public CryptoKeyRights TakeOwnership
public CryptoKeyRights Synchronize
public CryptoKeyRights FullControl
public CryptoKeyRights GenericAll
public CryptoKeyRights GenericExecute
public CryptoKeyRights GenericWrite
public CryptoKeyRights GenericRead
}
public System.Security.AccessControl.CryptoKeySecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(CommonSecurityDescriptor securityDescriptor)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(CryptoKeyAccessRule rule)
public bool RemoveAccessRule(CryptoKeyAccessRule rule)
public void RemoveAccessRuleAll(CryptoKeyAccessRule rule)
public void RemoveAccessRuleSpecific(CryptoKeyAccessRule rule)
public void ResetAccessRule(CryptoKeyAccessRule rule)
public void SetAccessRule(CryptoKeyAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(CryptoKeyAuditRule rule)
public bool RemoveAuditRule(CryptoKeyAuditRule rule)
public void RemoveAuditRuleAll(CryptoKeyAuditRule rule)
public void RemoveAuditRuleSpecific(CryptoKeyAuditRule rule)
public void SetAuditRule(CryptoKeyAuditRule rule)
}
public System.Security.AccessControl.CustomAce : GenericAce {
private Byte[] opaque
public int MaxOpaqueLength
public int BinaryLength
public int OpaqueLength
public void .ctor(AceType type, AceFlags flags, Byte[] opaque)
public int get_BinaryLength()
public int get_OpaqueLength()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public Byte[] GetOpaque()
public void SetOpaque(Byte[] opaque)
}
public System.Security.AccessControl.DirectoryObjectSecurity : ObjectSecurity {
protected void .ctor(CommonSecurityDescriptor securityDescriptor)
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType)
public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType)
public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType)
protected void AddAccessRule(ObjectAccessRule rule)
protected void AddAuditRule(ObjectAuditRule rule)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
protected bool RemoveAccessRule(ObjectAccessRule rule)
protected void RemoveAccessRuleAll(ObjectAccessRule rule)
protected void RemoveAccessRuleSpecific(ObjectAccessRule rule)
protected bool RemoveAuditRule(ObjectAuditRule rule)
protected void RemoveAuditRuleAll(ObjectAuditRule rule)
protected void RemoveAuditRuleSpecific(ObjectAuditRule rule)
protected void ResetAccessRule(ObjectAccessRule rule)
protected void SetAccessRule(ObjectAccessRule rule)
protected void SetAuditRule(ObjectAuditRule rule)
}
public System.Security.AccessControl.DirectorySecurity : FileSystemSecurity {
public void .ctor(string name, AccessControlSections includeSections)
}
public System.Security.AccessControl.DiscretionaryAcl : CommonAcl {
public void .ctor(bool isContainer, bool isDS, int capacity)
public void .ctor(bool isContainer, bool isDS, RawAcl rawAcl)
public void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
}
public System.Security.AccessControl.EventWaitHandleAccessRule : AccessRule {
private EventWaitHandleRights rights
public EventWaitHandleRights EventWaitHandleRights
public void .ctor(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type)
public void .ctor(string identity, EventWaitHandleRights eventRights, AccessControlType type)
public EventWaitHandleRights get_EventWaitHandleRights()
}
public System.Security.AccessControl.EventWaitHandleAuditRule : AuditRule {
private EventWaitHandleRights rights
public EventWaitHandleRights EventWaitHandleRights
public void .ctor(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags)
public EventWaitHandleRights get_EventWaitHandleRights()
}
public System.Security.AccessControl.EventWaitHandleRights : Enum {
public int value__
public EventWaitHandleRights Modify
public EventWaitHandleRights Delete
public EventWaitHandleRights ReadPermissions
public EventWaitHandleRights ChangePermissions
public EventWaitHandleRights TakeOwnership
public EventWaitHandleRights Synchronize
public EventWaitHandleRights FullControl
}
public System.Security.AccessControl.EventWaitHandleSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(EventWaitHandleAccessRule rule)
public bool RemoveAccessRule(EventWaitHandleAccessRule rule)
public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule)
public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule)
public void ResetAccessRule(EventWaitHandleAccessRule rule)
public void SetAccessRule(EventWaitHandleAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(EventWaitHandleAuditRule rule)
public bool RemoveAuditRule(EventWaitHandleAuditRule rule)
public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule)
public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule)
public void SetAuditRule(EventWaitHandleAuditRule rule)
}
public System.Security.AccessControl.FileSecurity : FileSystemSecurity {
public void .ctor(string fileName, AccessControlSections includeSections)
}
public System.Security.AccessControl.FileSystemAccessRule : AccessRule {
private FileSystemRights rights
public FileSystemRights FileSystemRights
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type)
public void .ctor(string identity, FileSystemRights fileSystemRights, AccessControlType type)
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void .ctor(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public FileSystemRights get_FileSystemRights()
}
public System.Security.AccessControl.FileSystemAuditRule : AuditRule {
private FileSystemRights rights
public FileSystemRights FileSystemRights
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags)
public void .ctor(string identity, FileSystemRights fileSystemRights, AuditFlags flags)
public void .ctor(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void .ctor(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public FileSystemRights get_FileSystemRights()
}
public System.Security.AccessControl.FileSystemRights : Enum {
public int value__
public FileSystemRights ListDirectory
public FileSystemRights ReadData
public FileSystemRights CreateFiles
public FileSystemRights WriteData
public FileSystemRights AppendData
public FileSystemRights CreateDirectories
public FileSystemRights ReadExtendedAttributes
public FileSystemRights WriteExtendedAttributes
public FileSystemRights ExecuteFile
public FileSystemRights Traverse
public FileSystemRights DeleteSubdirectoriesAndFiles
public FileSystemRights ReadAttributes
public FileSystemRights WriteAttributes
public FileSystemRights Write
public FileSystemRights Delete
public FileSystemRights ReadPermissions
public FileSystemRights Read
public FileSystemRights ReadAndExecute
public FileSystemRights Modify
public FileSystemRights ChangePermissions
public FileSystemRights TakeOwnership
public FileSystemRights Synchronize
public FileSystemRights FullControl
}
public System.Security.AccessControl.FileSystemSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
internal void .ctor(bool isContainer)
internal void .ctor(bool isContainer, string name, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(FileSystemAccessRule rule)
public bool RemoveAccessRule(FileSystemAccessRule rule)
public void RemoveAccessRuleAll(FileSystemAccessRule rule)
public void RemoveAccessRuleSpecific(FileSystemAccessRule rule)
public void ResetAccessRule(FileSystemAccessRule rule)
public void SetAccessRule(FileSystemAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(FileSystemAuditRule rule)
public bool RemoveAuditRule(FileSystemAuditRule rule)
public void RemoveAuditRuleAll(FileSystemAuditRule rule)
public void RemoveAuditRuleSpecific(FileSystemAuditRule rule)
public void SetAuditRule(FileSystemAuditRule rule)
}
public System.Security.AccessControl.GenericAce : object {
private InheritanceFlags inheritance
private PropagationFlags propagation
private AceFlags aceflags
private AceType ace_type
public AceFlags AceFlags
public AceType AceType
public AuditFlags AuditFlags
public int BinaryLength
public InheritanceFlags InheritanceFlags
public bool IsInherited
public PropagationFlags PropagationFlags
internal void .ctor(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
internal void .ctor(AceType type)
public AceFlags get_AceFlags()
public void set_AceFlags(AceFlags value)
public AceType get_AceType()
public AuditFlags get_AuditFlags()
public int get_BinaryLength()
public InheritanceFlags get_InheritanceFlags()
public bool get_IsInherited()
public PropagationFlags get_PropagationFlags()
public GenericAce Copy()
public GenericAce CreateFromBinaryForm(Byte[] binaryForm, int offset)
public bool Equals(object o)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int GetHashCode()
public bool op_Equality(GenericAce left, GenericAce right)
public bool op_Inequality(GenericAce left, GenericAce right)
}
public System.Security.AccessControl.GenericAcl : object {
public byte AclRevision
public byte AclRevisionDS
public int MaxBinaryLength
public int BinaryLength
public int Count
public bool IsSynchronized
public GenericAce Item
public byte Revision
public object SyncRoot
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_BinaryLength()
public int get_Count()
public bool get_IsSynchronized()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public byte get_Revision()
public object get_SyncRoot()
public void CopyTo(GenericAce[] array, int index)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public AceEnumerator GetEnumerator()
}
public System.Security.AccessControl.GenericSecurityDescriptor : object {
public int BinaryLength
public ControlFlags ControlFlags
public SecurityIdentifier Group
public SecurityIdentifier Owner
public byte Revision
public int get_BinaryLength()
public ControlFlags get_ControlFlags()
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public byte get_Revision()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public string GetSddlForm(AccessControlSections includeSections)
public bool IsSddlConversionSupported()
}
public System.Security.AccessControl.InheritanceFlags : Enum {
public int value__
public InheritanceFlags None
public InheritanceFlags ContainerInherit
public InheritanceFlags ObjectInherit
}
public System.Security.AccessControl.KnownAce : GenericAce {
private int access_mask
private SecurityIdentifier identifier
public int AccessMask
public SecurityIdentifier SecurityIdentifier
internal void .ctor(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public int get_AccessMask()
public void set_AccessMask(int value)
public SecurityIdentifier get_SecurityIdentifier()
public void set_SecurityIdentifier(SecurityIdentifier value)
}
public System.Security.AccessControl.MutexAccessRule : AccessRule {
private MutexRights rights
public MutexRights MutexRights
public void .ctor(IdentityReference identity, MutexRights eventRights, AccessControlType type)
public void .ctor(string identity, MutexRights eventRights, AccessControlType type)
public MutexRights get_MutexRights()
}
public System.Security.AccessControl.MutexAuditRule : AuditRule {
private MutexRights rights
public MutexRights MutexRights
public void .ctor(IdentityReference identity, MutexRights eventRights, AuditFlags flags)
public MutexRights get_MutexRights()
}
public System.Security.AccessControl.MutexRights : Enum {
public int value__
public MutexRights Modify
public MutexRights Delete
public MutexRights ReadPermissions
public MutexRights ChangePermissions
public MutexRights TakeOwnership
public MutexRights Synchronize
public MutexRights FullControl
}
public System.Security.AccessControl.MutexSecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public void .ctor(string name, AccessControlSections includeSections)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(MutexAccessRule rule)
public bool RemoveAccessRule(MutexAccessRule rule)
public void RemoveAccessRuleAll(MutexAccessRule rule)
public void RemoveAccessRuleSpecific(MutexAccessRule rule)
public void ResetAccessRule(MutexAccessRule rule)
public void SetAccessRule(MutexAccessRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void AddAuditRule(MutexAuditRule rule)
public bool RemoveAuditRule(MutexAuditRule rule)
public void RemoveAuditRuleAll(MutexAuditRule rule)
public void RemoveAuditRuleSpecific(MutexAuditRule rule)
public void SetAuditRule(MutexAuditRule rule)
}
public System.Security.AccessControl.NativeObjectSecurity : CommonObjectSecurity {
protected void .ctor(bool isContainer, ResourceType resourceType)
protected void .ctor(bool isContainer, ResourceType resourceType, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections)
protected void .ctor(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void .ctor(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext)
protected void Persist(SafeHandle handle, AccessControlSections includeSections)
protected void Persist(string name, AccessControlSections includeSections)
protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext)
protected void Persist(string name, AccessControlSections includeSections, object exceptionContext)
}
public System.Security.AccessControl.ObjectAccessRule : AccessRule {
private Guid object_type
private Guid inherited_object_type
public Guid InheritedObjectType
public ObjectAceFlags ObjectFlags
public Guid ObjectType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type)
public Guid get_InheritedObjectType()
public ObjectAceFlags get_ObjectFlags()
public Guid get_ObjectType()
}
public System.Security.AccessControl.ObjectAce : QualifiedAce {
private Guid object_ace_type
private Guid inherited_object_type
private ObjectAceFlags object_ace_flags
public int BinaryLength
public Guid InheritedObjectAceType
public ObjectAceFlags ObjectAceFlags
public Guid ObjectAceType
public void .ctor(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, Byte[] opaque)
public int get_BinaryLength()
public Guid get_InheritedObjectAceType()
public void set_InheritedObjectAceType(Guid value)
public ObjectAceFlags get_ObjectAceFlags()
public void set_ObjectAceFlags(ObjectAceFlags value)
public Guid get_ObjectAceType()
public void set_ObjectAceType(Guid value)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int MaxOpaqueLength(bool isCallback)
}
public System.Security.AccessControl.ObjectAceFlags : Enum {
public int value__
public ObjectAceFlags None
public ObjectAceFlags ObjectAceTypePresent
public ObjectAceFlags InheritedObjectAceTypePresent
}
public System.Security.AccessControl.ObjectAuditRule : AuditRule {
private Guid inherited_object_type
private Guid object_type
public Guid InheritedObjectType
public ObjectAceFlags ObjectFlags
public Guid ObjectType
protected void .ctor(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags)
public Guid get_InheritedObjectType()
public ObjectAceFlags get_ObjectFlags()
public Guid get_ObjectType()
}
public System.Security.AccessControl.ObjectSecurity : object {
private bool is_container
private bool is_ds
private bool access_rules_modified
private bool audit_rules_modified
private bool group_modified
private bool owner_modified
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public bool AreAccessRulesCanonical
public bool AreAccessRulesProtected
public bool AreAuditRulesCanonical
public bool AreAuditRulesProtected
protected bool AccessRulesModified
protected bool AuditRulesModified
protected bool GroupModified
protected bool IsContainer
protected bool IsDS
protected bool OwnerModified
protected void .ctor(bool isContainer, bool isDS)
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public bool get_AreAccessRulesCanonical()
public bool get_AreAccessRulesProtected()
public bool get_AreAuditRulesCanonical()
public bool get_AreAuditRulesProtected()
protected bool get_AccessRulesModified()
protected void set_AccessRulesModified(bool value)
protected bool get_AuditRulesModified()
protected void set_AuditRulesModified(bool value)
protected bool get_GroupModified()
protected void set_GroupModified(bool value)
protected bool get_IsContainer()
protected bool get_IsDS()
protected bool get_OwnerModified()
protected void set_OwnerModified(bool value)
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public IdentityReference GetGroup(Type targetType)
public IdentityReference GetOwner(Type targetType)
public Byte[] GetSecurityDescriptorBinaryForm()
public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections)
public bool IsSddlConversionSupported()
public bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, Boolean& modified)
public bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, Boolean& modified)
public void PurgeAccessRules(IdentityReference identity)
public void PurgeAuditRules(IdentityReference identity)
public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance)
public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance)
public void SetGroup(IdentityReference identity)
public void SetOwner(IdentityReference identity)
public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm)
public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm, AccessControlSections includeSections)
public void SetSecurityDescriptorSddlForm(string sddlForm)
public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections)
protected bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified)
protected bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified)
protected void Persist(SafeHandle handle, AccessControlSections includeSections)
protected void Persist(string name, AccessControlSections includeSections)
protected void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections)
protected void ReadLock()
protected void ReadUnlock()
protected void WriteLock()
protected void WriteUnlock()
}
public System.Security.AccessControl.PrivilegeNotHeldException : UnauthorizedAccessException {
public string PrivilegeName
public void .ctor(string privilege)
public void .ctor(string privilege, Exception inner)
public string get_PrivilegeName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.Security.AccessControl.PropagationFlags : Enum {
public int value__
public PropagationFlags None
public PropagationFlags NoPropagateInherit
public PropagationFlags InheritOnly
}
public System.Security.AccessControl.QualifiedAce : KnownAce {
private AceQualifier ace_qualifier
private bool is_callback
private Byte[] opaque
public AceQualifier AceQualifier
public bool IsCallback
public int OpaqueLength
internal void .ctor(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AceQualifier aceQualifier, bool isCallback, Byte[] opaque)
public AceQualifier get_AceQualifier()
public bool get_IsCallback()
public int get_OpaqueLength()
public Byte[] GetOpaque()
public void SetOpaque(Byte[] opaque)
}
public System.Security.AccessControl.RawAcl : GenericAcl {
private byte revision
private List`1<GenericAce> list
public int BinaryLength
public int Count
public GenericAce Item
public byte Revision
public void .ctor(byte revision, int capacity)
public void .ctor(Byte[] binaryForm, int offset)
public int get_BinaryLength()
public int get_Count()
public GenericAce get_Item(int index)
public void set_Item(int index, GenericAce value)
public byte get_Revision()
public void GetBinaryForm(Byte[] binaryForm, int offset)
public void InsertAce(int index, GenericAce ace)
public void RemoveAce(int index)
}
public System.Security.AccessControl.RawSecurityDescriptor : GenericSecurityDescriptor {
public ControlFlags ControlFlags
public RawAcl DiscretionaryAcl
public SecurityIdentifier Group
public SecurityIdentifier Owner
public byte ResourceManagerControl
public RawAcl SystemAcl
public void .ctor(string sddlForm)
public void .ctor(Byte[] binaryForm, int offset)
public void .ctor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl)
public ControlFlags get_ControlFlags()
public RawAcl get_DiscretionaryAcl()
public void set_DiscretionaryAcl(RawAcl value)
public SecurityIdentifier get_Group()
public void set_Group(SecurityIdentifier value)
public SecurityIdentifier get_Owner()
public void set_Owner(SecurityIdentifier value)
public byte get_ResourceManagerControl()
public void set_ResourceManagerControl(byte value)
public RawAcl get_SystemAcl()
public void set_SystemAcl(RawAcl value)
public void SetFlags(ControlFlags flags)
}
public System.Security.AccessControl.RegistryAccessRule : AccessRule {
private RegistryRights rights
public RegistryRights RegistryRights
public void .ctor(IdentityReference identity, RegistryRights registryRights, AccessControlType type)
public void .ctor(string identity, RegistryRights registryRights, AccessControlType type)
public void .ctor(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void .ctor(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public RegistryRights get_RegistryRights()
}
public System.Security.AccessControl.RegistryAuditRule : AuditRule {
private RegistryRights rights
public RegistryRights RegistryRights
public void .ctor(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public void .ctor(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public RegistryRights get_RegistryRights()
}
public System.Security.AccessControl.RegistryRights : Enum {
public int value__
public RegistryRights QueryValues
public RegistryRights SetValue
public RegistryRights CreateSubKey
public RegistryRights EnumerateSubKeys
public RegistryRights Notify
public RegistryRights CreateLink
public RegistryRights Delete
public RegistryRights ReadPermissions
public RegistryRights WriteKey
public RegistryRights ReadKey
public RegistryRights ExecuteKey
public RegistryRights ChangePermissions
public RegistryRights TakeOwnership
public RegistryRights FullControl
}
public System.Security.AccessControl.RegistrySecurity : NativeObjectSecurity {
public Type AccessRightType
public Type AccessRuleType
public Type AuditRuleType
public Type get_AccessRightType()
public Type get_AccessRuleType()
public Type get_AuditRuleType()
public AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
public void AddAccessRule(RegistryAccessRule rule)
public void AddAuditRule(RegistryAuditRule rule)
public AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
public bool RemoveAccessRule(RegistryAccessRule rule)
public void RemoveAccessRuleAll(RegistryAccessRule rule)
public void RemoveAccessRuleSpecific(RegistryAccessRule rule)
public bool RemoveAuditRule(RegistryAuditRule rule)
public void RemoveAuditRuleAll(RegistryAuditRule rule)
public void RemoveAuditRuleSpecific(RegistryAuditRule rule)
public void ResetAccessRule(RegistryAccessRule rule)
public void SetAccessRule(RegistryAccessRule rule)
public void SetAuditRule(RegistryAuditRule rule)
}
public System.Security.AccessControl.ResourceType : Enum {
public int value__
public ResourceType Unknown
public ResourceType FileObject
public ResourceType Service
public ResourceType Printer
public ResourceType RegistryKey
public ResourceType LMShare
public ResourceType KernelObject
public ResourceType WindowObject
public ResourceType DSObject
public ResourceType DSObjectAll
public ResourceType ProviderDefined
public ResourceType WmiGuidObject
public ResourceType RegistryWow6432Key
}
public System.Security.AccessControl.SecurityInfos : Enum {
public int value__
public SecurityInfos Owner
public SecurityInfos Group
public SecurityInfos DiscretionaryAcl
public SecurityInfos SystemAcl
}
public System.Security.AccessControl.SystemAcl : CommonAcl {
public void .ctor(bool isContainer, bool isDS, int capacity)
public void .ctor(bool isContainer, bool isDS, RawAcl rawAcl)
public void .ctor(bool isContainer, bool isDS, byte revision, int capacity)
public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags)
public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType)
}
public System.Security.CodeAccessPermission : object {
public void Assert()
internal bool CheckAssert(CodeAccessPermission asserted)
internal bool CheckDemand(CodeAccessPermission target)
internal bool CheckDeny(CodeAccessPermission denied)
internal bool CheckPermitOnly(CodeAccessPermission target)
public IPermission Copy()
public void Demand()
public void Deny()
public bool Equals(object obj)
public void FromXml(SecurityElement elem)
public int GetHashCode()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public string ToString()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public void PermitOnly()
public void RevertAll()
public void RevertAssert()
public void RevertDeny()
public void RevertPermitOnly()
internal SecurityElement Element(int version)
internal PermissionState CheckPermissionState(PermissionState state, bool allowUnrestricted)
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal bool IsUnrestricted(SecurityElement se)
internal bool ProcessFrame(SecurityFrame frame)
internal void ThrowInvalidPermission(IPermission target, Type expected)
internal void ThrowExecutionEngineException(SecurityAction stackmod)
internal void ThrowSecurityException(object demanded, string message, SecurityFrame frame, SecurityAction action, IPermission failed)
}
public System.Security.Cryptography.AsymmetricAlgorithm : object {
protected int KeySizeValue
protected KeySizes[] LegalKeySizesValue
public string KeyExchangeAlgorithm
public int KeySize
public KeySizes[] LegalKeySizes
public string SignatureAlgorithm
private void System.IDisposable.Dispose()
public string get_KeyExchangeAlgorithm()
public int get_KeySize()
public void set_KeySize(int value)
public KeySizes[] get_LegalKeySizes()
public string get_SignatureAlgorithm()
public void Clear()
protected void Dispose(bool disposing)
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
public AsymmetricAlgorithm Create()
public AsymmetricAlgorithm Create(string algName)
internal Byte[] GetNamedParam(string xml, string param)
}
public System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
public string Parameters
public string get_Parameters()
public void set_Parameters(string value)
public Byte[] DecryptKeyExchange(Byte[] rgb)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
public string Parameters
public string get_Parameters()
public Byte[] CreateKeyExchange(Byte[] data)
public Byte[] CreateKeyExchange(Byte[] data, Type symAlgType)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
public bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature)
}
public System.Security.Cryptography.AsymmetricSignatureFormatter : object {
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
public Byte[] CreateSignature(Byte[] rgbHash)
public Byte[] CreateSignature(HashAlgorithm hash)
}
internal System.Security.Cryptography.Base64Constants : object {
public Byte[] EncodeTable
public Byte[] DecodeTable
}
public System.Security.Cryptography.CipherMode : Enum {
public int value__
public CipherMode CBC
public CipherMode ECB
public CipherMode OFB
public CipherMode CFB
public CipherMode CTS
}
public System.Security.Cryptography.CryptoAPITransform : object {
private bool m_disposed
public bool CanReuseTransform
public bool CanTransformMultipleBlocks
public int InputBlockSize
public IntPtr KeyHandle
public int OutputBlockSize
private void System.IDisposable.Dispose()
public bool get_CanReuseTransform()
public bool get_CanTransformMultipleBlocks()
public int get_InputBlockSize()
public IntPtr get_KeyHandle()
public int get_OutputBlockSize()
public void Clear()
private void Dispose(bool disposing)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
public void Reset()
}
public System.Security.Cryptography.CryptoConfig : object {
private string defaultNamespace
private string defaultSHA1
private string defaultMD5
private string defaultSHA256
private string defaultSHA384
private string defaultSHA512
private string defaultRSA
private string defaultDSA
private string defaultDES
private string default3DES
private string defaultRC2
private string defaultAES
private string defaultRNG
private string defaultHMAC
private string defaultMAC3DES
private string defaultDSASigDesc
private string defaultRSASigDesc
private string defaultRIPEMD160
private string defaultHMACMD5
private string defaultHMACRIPEMD160
private string defaultHMACSHA256
private string defaultHMACSHA384
private string defaultHMACSHA512
private string defaultC14N
private string defaultC14NWithComments
private string defaultBase64
private string defaultXPath
private string defaultXslt
private string defaultEnveloped
private string defaultXmlDecryption
private string defaultExcC14N
private string defaultExcC14NWithComments
private string defaultX509Data
private string defaultKeyName
private string defaultKeyValueDSA
private string defaultKeyValueRSA
private string defaultRetrievalMethod
private string managedSHA1
private string oidSHA1
private string oidMD5
private string oidSHA256
private string oidSHA384
private string oidSHA512
private string oidDSA
private string oidDES
private string oid3DES
private string oidRC2
private string oid3DESKeyWrap
private string nameSHA1a
private string nameSHA1b
private string nameSHA1c
private string nameSHA1d
private string nameMD5a
private string nameMD5b
private string nameSHA256a
private string nameSHA256b
private string nameSHA256c
private string nameSHA384a
private string nameSHA384b
private string nameSHA384c
private string nameSHA512a
private string nameSHA512b
private string nameSHA512c
private string nameRSAa
private string nameRSAb
private string nameRSAc
private string nameDSAa
private string nameDSAb
private string nameDESa
private string nameDESb
private string name3DESa
private string name3DESb
private string name3DESc
private string name3DESd
private string nameRC2a
private string nameRC2b
private string nameAESa
private string nameAESb
private string nameAESc
private string nameRNGa
private string nameRNGb
private string nameKeyHasha
private string nameHMACSHA1a
private string nameHMACSHA1b
private string nameMAC3DESa
private string nameMAC3DESb
private string name3DESKeyWrap
private string nameRIPEMD160a
private string nameRIPEMD160b
private string nameRIPEMD160c
private string nameHMACa
private string nameHMACb
private string nameHMACMD5a
private string nameHMACMD5b
private string nameHMACRIPEMD160a
private string nameHMACRIPEMD160b
private string nameHMACSHA256a
private string nameHMACSHA256b
private string nameHMACSHA384a
private string nameHMACSHA384b
private string nameHMACSHA512a
private string nameHMACSHA512b
private string urlXmlDsig
private string urlDSASHA1
private string urlRSASHA1
private string urlSHA1
private string urlC14N
private string urlC14NWithComments
private string urlBase64
private string urlXPath
private string urlXslt
private string urlEnveloped
private string urlXmlDecryption
private string urlExcC14NWithComments
private string urlExcC14N
private string urlSHA256
private string urlSHA512
private string urlHMACSHA256
private string urlHMACSHA384
private string urlHMACSHA512
private string urlHMACRIPEMD160
private string urlX509Data
private string urlKeyName
private string urlKeyValueDSA
private string urlKeyValueRSA
private string urlRetrievalMethod
private string oidX509SubjectKeyIdentifier
private string oidX509KeyUsage
private string oidX509BasicConstraints
private string oidX509EnhancedKeyUsage
private string nameX509SubjectKeyIdentifier
private string nameX509KeyUsage
private string nameX509BasicConstraints
private string nameX509EnhancedKeyUsage
private string nameX509Chain
private string defaultX509Chain
private object lockObject
private Hashtable algorithms
private Hashtable oid
private void Initialize()
private void LoadConfig(string filename, Hashtable algorithms, Hashtable oid)
public object CreateFromName(string name)
public object CreateFromName(string name, Object[] args)
public string MapNameToOID(string name)
public Byte[] EncodeOID(string str)
private Byte[] EncodeLongNumber(long x)
}
public System.Security.Cryptography.CryptographicException : SystemException {
public void .ctor(int hr)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string format, string insert)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public void .ctor(string format, string insert)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Security.Cryptography.CryptoStream : Stream {
private Stream _stream
private ICryptoTransform _transform
private CryptoStreamMode _mode
private Byte[] _currentBlock
private bool _disposed
private bool _flushedFinalBlock
private int _partialCount
private bool _endOfStream
private Byte[] _waitingBlock
private int _waitingCount
private Byte[] _transformedBlock
private int _transformedPos
private int _transformedCount
private Byte[] _workingBlock
private int _workingCount
public bool CanRead
public bool CanSeek
public bool CanWrite
public long Length
public long Position
public void .ctor(Stream stream, ICryptoTransform transform, CryptoStreamMode mode)
protected void Finalize()
public bool get_CanRead()
public bool get_CanSeek()
public bool get_CanWrite()
public long get_Length()
public long get_Position()
public void set_Position(long value)
public void Clear()
public void Close()
public int Read(Byte[] buffer, int offset, int count)
public void Write(Byte[] buffer, int offset, int count)
public void Flush()
public void FlushFinalBlock()
public long Seek(long offset, SeekOrigin origin)
public void SetLength(long value)
protected void Dispose(bool disposing)
}
public System.Security.Cryptography.CryptoStreamMode : Enum {
public int value__
public CryptoStreamMode Read
public CryptoStreamMode Write
}
public System.Security.Cryptography.CspKeyContainerInfo : object {
private CspParameters _params
internal bool _random
public bool Accessible
public CryptoKeySecurity CryptoKeySecurity
public bool Exportable
public bool HardwareDevice
public string KeyContainerName
public KeyNumber KeyNumber
public bool MachineKeyStore
public bool Protected
public string ProviderName
public int ProviderType
public bool RandomlyGenerated
public bool Removable
public string UniqueKeyContainerName
public void .ctor(CspParameters parameters)
public bool get_Accessible()
public CryptoKeySecurity get_CryptoKeySecurity()
public bool get_Exportable()
public bool get_HardwareDevice()
public string get_KeyContainerName()
public KeyNumber get_KeyNumber()
public bool get_MachineKeyStore()
public bool get_Protected()
public string get_ProviderName()
public int get_ProviderType()
public bool get_RandomlyGenerated()
public bool get_Removable()
public string get_UniqueKeyContainerName()
}
public System.Security.Cryptography.CspParameters : object {
private CspProviderFlags _Flags
public string KeyContainerName
public int KeyNumber
public string ProviderName
public int ProviderType
private SecureString _password
private IntPtr _windowHandle
public CspProviderFlags Flags
public CryptoKeySecurity CryptoKeySecurity
public SecureString KeyPassword
public IntPtr ParentWindowHandle
public void .ctor(int dwTypeIn)
public void .ctor(int dwTypeIn, string strProviderNameIn)
public void .ctor(int dwTypeIn, string strProviderNameIn, string strContainerNameIn)
public void .ctor(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, IntPtr parentWindowHandle)
public void .ctor(int providerType, string providerName, string keyContainerName, CryptoKeySecurity cryptoKeySecurity, SecureString keyPassword)
public CspProviderFlags get_Flags()
public void set_Flags(CspProviderFlags value)
public CryptoKeySecurity get_CryptoKeySecurity()
public void set_CryptoKeySecurity(CryptoKeySecurity value)
public SecureString get_KeyPassword()
public void set_KeyPassword(SecureString value)
public IntPtr get_ParentWindowHandle()
public void set_ParentWindowHandle(IntPtr value)
}
public System.Security.Cryptography.CspProviderFlags : Enum {
public int value__
public CspProviderFlags UseMachineKeyStore
public CspProviderFlags UseDefaultKeyContainer
public CspProviderFlags UseExistingKey
public CspProviderFlags NoFlags
public CspProviderFlags NoPrompt
public CspProviderFlags UseArchivableKey
public CspProviderFlags UseNonExportableKey
public CspProviderFlags UseUserProtectedKey
}
public System.Security.Cryptography.DeriveBytes : object {
public Byte[] GetBytes(int cb)
public void Reset()
}
public System.Security.Cryptography.DES : SymmetricAlgorithm {
private int keySizeByte
internal Byte[,] weakKeys
internal Byte[,] semiWeakKeys
public Byte[] Key
public DES Create()
public DES Create(string algName)
public bool IsWeakKey(Byte[] rgbKey)
public bool IsSemiWeakKey(Byte[] rgbKey)
public Byte[] get_Key()
public void set_Key(Byte[] value)
}
public System.Security.Cryptography.DESCryptoServiceProvider : DES {
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateIV()
public void GenerateKey()
}
internal System.Security.Cryptography.DESTransform : SymmetricTransform {
internal int KEY_BIT_SIZE
internal int KEY_BYTE_SIZE
internal int BLOCK_BIT_SIZE
internal int BLOCK_BYTE_SIZE
private Byte[] keySchedule
private Byte[] byteBuff
private UInt32[] dwordBuff
private UInt32[] spBoxes
private Byte[] PC1
private Byte[] leftRotTotal
private Byte[] PC2
internal UInt32[] ipTab
internal UInt32[] fpTab
internal void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, Byte[] key, Byte[] iv)
private UInt32 CipherFunct(UInt32 r, int n)
internal void Permutation(Byte[] input, Byte[] output, UInt32[] permTab, bool preSwap)
private void BSwap(Byte[] byteBuff)
internal void SetKey(Byte[] key)
public void ProcessBlock(Byte[] input, Byte[] output)
protected void ECB(Byte[] input, Byte[] output)
internal Byte[] GetStrongKey()
}
public System.Security.Cryptography.DSA : AsymmetricAlgorithm {
public DSA Create()
public DSA Create(string algName)
public Byte[] CreateSignature(Byte[] rgbHash)
public DSAParameters ExportParameters(bool includePrivateParameters)
internal void ZeroizePrivateKey(DSAParameters parameters)
public void FromXmlString(string xmlString)
public void ImportParameters(DSAParameters parameters)
public string ToXmlString(bool includePrivateParameters)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
public System.Security.Cryptography.DSACryptoServiceProvider : DSA {
private int PROV_DSS_DH
private KeyPairPersistence store
private bool persistKey
private bool persisted
private bool privateKeyExportable
private bool m_disposed
private DSAManaged dsa
private bool useMachineKeyStore
public string KeyExchangeAlgorithm
public int KeySize
public bool PersistKeyInCsp
public bool PublicOnly
public string SignatureAlgorithm
public bool UseMachineKeyStore
public CspKeyContainerInfo CspKeyContainerInfo
public void .ctor(CspParameters parameters)
public void .ctor(int dwKeySize)
public void .ctor(int dwKeySize, CspParameters parameters)
protected void Finalize()
public string get_KeyExchangeAlgorithm()
public int get_KeySize()
public bool get_PersistKeyInCsp()
public void set_PersistKeyInCsp(bool value)
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public bool get_UseMachineKeyStore()
public void set_UseMachineKeyStore(bool value)
public DSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(DSAParameters parameters)
public Byte[] CreateSignature(Byte[] rgbHash)
public Byte[] SignData(Byte[] buffer)
public Byte[] SignData(Byte[] buffer, int offset, int count)
public Byte[] SignData(Stream inputStream)
public Byte[] SignHash(Byte[] rgbHash, string str)
public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature)
public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
protected void Dispose(bool disposing)
private void OnKeyGenerated(object sender, EventArgs e)
public CspKeyContainerInfo get_CspKeyContainerInfo()
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] keyBlob)
}
public System.Security.Cryptography.DSAParameters : ValueType {
public int Counter
public Byte[] G
public Byte[] J
public Byte[] P
public Byte[] Q
public Byte[] Seed
public Byte[] X
public Byte[] Y
}
public System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
private DSA dsa
public void .ctor(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
public System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
private DSA dsa
public void .ctor(AsymmetricAlgorithm key)
public Byte[] CreateSignature(Byte[] rgbHash)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.FromBase64Transform : object {
private byte TerminatorByte
private FromBase64TransformMode mode
private Byte[] accumulator
private int accPtr
private bool m_disposed
private Byte[] lookupTable
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
public void .ctor(FromBase64TransformMode whitespaces)
private void System.IDisposable.Dispose()
protected void Finalize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
public void Clear()
protected void Dispose(bool disposing)
private byte lookup(byte input)
private int ProcessBlock(Byte[] output, int offset)
private void CheckInputParameters(Byte[] inputBuffer, int inputOffset, int inputCount)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Security.Cryptography.FromBase64TransformMode : Enum {
public int value__
public FromBase64TransformMode IgnoreWhiteSpaces
public FromBase64TransformMode DoNotIgnoreWhiteSpaces
}
public System.Security.Cryptography.HashAlgorithm : object {
protected internal Byte[] HashValue
protected int HashSizeValue
protected int State
private bool disposed
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public Byte[] Hash
public int HashSize
public int InputBlockSize
public int OutputBlockSize
private void System.IDisposable.Dispose()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public void Clear()
public Byte[] ComputeHash(Byte[] buffer)
public Byte[] ComputeHash(Byte[] buffer, int offset, int count)
public Byte[] ComputeHash(Stream inputStream)
public HashAlgorithm Create()
public HashAlgorithm Create(string hashName)
public Byte[] get_Hash()
protected void HashCore(Byte[] array, int ibStart, int cbSize)
protected Byte[] HashFinal()
public int get_HashSize()
public void Initialize()
protected void Dispose(bool disposing)
public int get_InputBlockSize()
public int get_OutputBlockSize()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
private bool _disposed
private string _hashName
private HashAlgorithm _algo
private BlockProcessor _block
private int _blockSizeValue
protected int BlockSizeValue
public string HashName
public Byte[] Key
internal BlockProcessor Block
protected int get_BlockSizeValue()
protected void set_BlockSizeValue(int value)
public string get_HashName()
public void set_HashName(string value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
internal BlockProcessor get_Block()
private Byte[] KeySetup(Byte[] key, byte padding)
protected void Dispose(bool disposing)
protected void HashCore(Byte[] rgb, int ib, int cb)
protected Byte[] HashFinal()
public void Initialize()
public HMAC Create()
public HMAC Create(string algorithmName)
}
public System.Security.Cryptography.HMACMD5 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACRIPEMD160 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACSHA1 : HMAC {
public void .ctor(Byte[] key)
public void .ctor(Byte[] key, bool useManagedSha1)
}
public System.Security.Cryptography.HMACSHA256 : HMAC {
public void .ctor(Byte[] key)
}
public System.Security.Cryptography.HMACSHA384 : HMAC {
private bool legacy_mode
private bool legacy
public bool ProduceLegacyHmacValues
public void .ctor(Byte[] key)
public bool get_ProduceLegacyHmacValues()
public void set_ProduceLegacyHmacValues(bool value)
}
public System.Security.Cryptography.HMACSHA512 : HMAC {
private bool legacy_mode
private bool legacy
public bool ProduceLegacyHmacValues
public void .ctor(Byte[] key)
public bool get_ProduceLegacyHmacValues()
public void set_ProduceLegacyHmacValues(bool value)
}
public System.Security.Cryptography.ICryptoTransform {
public bool CanReuseTransform
public bool CanTransformMultipleBlocks
public int InputBlockSize
public int OutputBlockSize
public bool get_CanReuseTransform()
public bool get_CanTransformMultipleBlocks()
public int get_InputBlockSize()
public int get_OutputBlockSize()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Security.Cryptography.ICspAsymmetricAlgorithm {
public CspKeyContainerInfo CspKeyContainerInfo
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] rawData)
public CspKeyContainerInfo get_CspKeyContainerInfo()
}
public System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
protected Byte[] KeyValue
public Byte[] Key
protected void Finalize()
public Byte[] get_Key()
public void set_Key(Byte[] value)
protected void Dispose(bool disposing)
private void ZeroizeKey()
public KeyedHashAlgorithm Create()
public KeyedHashAlgorithm Create(string algName)
}
public System.Security.Cryptography.KeyNumber : Enum {
public int value__
public KeyNumber Exchange
public KeyNumber Signature
}
public System.Security.Cryptography.KeySizes : object {
private int _maxSize
private int _minSize
private int _skipSize
public int MaxSize
public int MinSize
public int SkipSize
public void .ctor(int minSize, int maxSize, int skipSize)
public int get_MaxSize()
public int get_MinSize()
public int get_SkipSize()
internal bool IsLegal(int keySize)
internal bool IsLegalKeySize(KeySizes[] legalKeys, int size)
}
public System.Security.Cryptography.MACTripleDES : KeyedHashAlgorithm {
private TripleDES tdes
private MACAlgorithm mac
private bool m_disposed
public PaddingMode Padding
public void .ctor(Byte[] rgbKey)
public void .ctor(string strTripleDES, Byte[] rgbKey)
private void Setup(string strTripleDES, Byte[] rgbKey)
protected void Finalize()
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
protected void Dispose(bool disposing)
public void Initialize()
protected void HashCore(Byte[] rgbData, int ibStart, int cbSize)
protected Byte[] HashFinal()
}
public System.Security.Cryptography.MaskGenerationMethod : object {
public Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn)
}
public System.Security.Cryptography.MD5 : HashAlgorithm {
public MD5 Create()
public MD5 Create(string algName)
}
public System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
private int BLOCK_SIZE_BYTES
private int HASH_SIZE_BYTES
private UInt32[] _H
private UInt32[] buff
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] K
protected void Finalize()
protected void Dispose(bool disposing)
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, int inputOffset)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
public System.Security.Cryptography.PaddingMode : Enum {
public int value__
public PaddingMode None
public PaddingMode PKCS7
public PaddingMode Zeros
public PaddingMode ANSIX923
public PaddingMode ISO10126
}
public System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
private string HashNameValue
private Byte[] SaltValue
private int IterationsValue
private HashAlgorithm hash
private int state
private Byte[] password
private Byte[] initial
private Byte[] output
private int position
private int hashnumber
public string HashName
public int IterationCount
public Byte[] Salt
public void .ctor(string strPassword, Byte[] rgbSalt)
public void .ctor(string strPassword, Byte[] rgbSalt, CspParameters cspParams)
public void .ctor(string strPassword, Byte[] rgbSalt, string strHashName, int iterations)
public void .ctor(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams)
public void .ctor(Byte[] password, Byte[] salt)
public void .ctor(Byte[] password, Byte[] salt, CspParameters cspParams)
public void .ctor(Byte[] password, Byte[] salt, string hashName, int iterations)
public void .ctor(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams)
protected void Finalize()
private void Prepare(string strPassword, Byte[] rgbSalt, string strHashName, int iterations)
private void Prepare(Byte[] password, Byte[] rgbSalt, string strHashName, int iterations)
public string get_HashName()
public void set_HashName(string value)
public int get_IterationCount()
public void set_IterationCount(int value)
public Byte[] get_Salt()
public void set_Salt(Byte[] value)
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV)
public Byte[] GetBytes(int cb)
public void Reset()
}
public System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
private string hashName
public string HashName
public string get_HashName()
public void set_HashName(string value)
public Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn)
}
public System.Security.Cryptography.RandomNumberGenerator : object {
public RandomNumberGenerator Create()
public RandomNumberGenerator Create(string rngName)
public void GetBytes(Byte[] data)
public void GetNonZeroBytes(Byte[] data)
}
public System.Security.Cryptography.RC2 : SymmetricAlgorithm {
protected int EffectiveKeySizeValue
public int EffectiveKeySize
public int KeySize
public RC2 Create()
public RC2 Create(string AlgName)
public int get_EffectiveKeySize()
public void set_EffectiveKeySize(int value)
public int get_KeySize()
public void set_KeySize(int value)
}
public System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
private bool _useSalt
public int EffectiveKeySize
public bool UseSalt
public int get_EffectiveKeySize()
public void set_EffectiveKeySize(int value)
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateIV()
public void GenerateKey()
public bool get_UseSalt()
public void set_UseSalt(bool value)
}
internal System.Security.Cryptography.RC2Transform : SymmetricTransform {
private ushort R0
private ushort R1
private ushort R2
private ushort R3
private UInt16[] K
private int j
private Byte[] pitable
public void .ctor(RC2 rc2Algo, bool encryption, Byte[] key, Byte[] iv)
protected void ECB(Byte[] input, Byte[] output)
}
public System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
private int defaultIterations
private int _iteration
private Byte[] _salt
private HMACSHA1 _hmac
private Byte[] _buffer
private int _pos
private int _f
public int IterationCount
public Byte[] Salt
public void .ctor(string password, Byte[] salt)
public void .ctor(string password, Byte[] salt, int iterations)
public void .ctor(Byte[] password, Byte[] salt, int iterations)
public void .ctor(string password, int saltSize)
public void .ctor(string password, int saltSize, int iterations)
public int get_IterationCount()
public void set_IterationCount(int value)
public Byte[] get_Salt()
public void set_Salt(Byte[] value)
private Byte[] F(Byte[] s, int c, int i)
public Byte[] GetBytes(int cb)
public void Reset()
}
public System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
public Rijndael Create()
public Rijndael Create(string algName)
}
public System.Security.Cryptography.RijndaelManaged : Rijndael {
public void GenerateIV()
public void GenerateKey()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
}
public System.Security.Cryptography.RijndaelManagedTransform : object {
private RijndaelTransform _st
private int _bs
public int BlockSizeValue
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
internal void .ctor(Rijndael algo, bool encryption, Byte[] key, Byte[] iv)
private void System.IDisposable.Dispose()
public int get_BlockSizeValue()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
public void Clear()
public void Reset()
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
internal System.Security.Cryptography.RijndaelTransform : SymmetricTransform {
private UInt32[] expandedKey
private int Nb
private int Nk
private int Nr
private UInt32[] Rcon
private Byte[] SBox
private Byte[] iSBox
private UInt32[] T0
private UInt32[] T1
private UInt32[] T2
private UInt32[] T3
private UInt32[] iT0
private UInt32[] iT1
private UInt32[] iT2
private UInt32[] iT3
public void .ctor(Rijndael algo, bool encryption, Byte[] key, Byte[] iv)
public void Clear()
protected void ECB(Byte[] input, Byte[] output)
private UInt32 SubByte(UInt32 a)
private void Encrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Encrypt192(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Encrypt256(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Decrypt128(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Decrypt192(Byte[] indata, Byte[] outdata, UInt32[] ekey)
private void Decrypt256(Byte[] indata, Byte[] outdata, UInt32[] ekey)
}
public System.Security.Cryptography.RIPEMD160 : HashAlgorithm {
public RIPEMD160 Create()
public RIPEMD160 Create(string hashName)
}
public System.Security.Cryptography.RIPEMD160Managed : RIPEMD160 {
private int BLOCK_SIZE_BYTES
private Byte[] _ProcessingBuffer
private UInt32[] _X
private UInt32[] _HashValue
private ulong _Length
private int _ProcessingBufferCount
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
protected void Finalize()
private void ProcessBlock(Byte[] buffer, int offset)
private void Compress()
private void CompressFinal(ulong length)
private UInt32 ROL(UInt32 x, int n)
private UInt32 F(UInt32 x, UInt32 y, UInt32 z)
private UInt32 G(UInt32 x, UInt32 y, UInt32 z)
private UInt32 H(UInt32 x, UInt32 y, UInt32 z)
private UInt32 I(UInt32 x, UInt32 y, UInt32 z)
private UInt32 J(UInt32 x, UInt32 y, UInt32 z)
private void FF(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void GG(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void HH(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void II(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void JJ(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void FFF(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void GGG(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void HHH(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void III(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
private void JJJ(UInt32& a, UInt32 b, UInt32& c, UInt32 d, UInt32 e, UInt32 x, int s)
}
public System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
private object _lock
private IntPtr _handle
public void .ctor(Byte[] rgb)
public void .ctor(CspParameters cspParams)
public void .ctor(string str)
private void Check()
private bool RngOpen()
private IntPtr RngInitialize(Byte[] seed)
private IntPtr RngGetBytes(IntPtr handle, Byte[] data)
private void RngClose(IntPtr handle)
public void GetBytes(Byte[] data)
public void GetNonZeroBytes(Byte[] data)
protected void Finalize()
}
public System.Security.Cryptography.RSA : AsymmetricAlgorithm {
public RSA Create()
public RSA Create(string algName)
public Byte[] EncryptValue(Byte[] rgb)
public Byte[] DecryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
internal void ZeroizePrivateKey(RSAParameters parameters)
public void FromXmlString(string xmlString)
public string ToXmlString(bool includePrivateParameters)
}
public System.Security.Cryptography.RSACryptoServiceProvider : RSA {
private int PROV_RSA_FULL
private KeyPairPersistence store
private bool persistKey
private bool persisted
private bool privateKeyExportable
private bool m_disposed
private RSAManaged rsa
private bool useMachineKeyStore
private Dictionary`2<string, int> <>f__switch$map2D
public bool UseMachineKeyStore
public string KeyExchangeAlgorithm
public int KeySize
public bool PersistKeyInCsp
public bool PublicOnly
public string SignatureAlgorithm
public CspKeyContainerInfo CspKeyContainerInfo
public void .ctor(CspParameters parameters)
public void .ctor(int dwKeySize)
public void .ctor(int dwKeySize, CspParameters parameters)
private void Common(int dwKeySize, CspParameters p)
public bool get_UseMachineKeyStore()
public void set_UseMachineKeyStore(bool value)
protected void Finalize()
public string get_KeyExchangeAlgorithm()
public int get_KeySize()
public bool get_PersistKeyInCsp()
public void set_PersistKeyInCsp(bool value)
public bool get_PublicOnly()
public string get_SignatureAlgorithm()
public Byte[] Decrypt(Byte[] rgb, bool fOAEP)
public Byte[] DecryptValue(Byte[] rgb)
public Byte[] Encrypt(Byte[] rgb, bool fOAEP)
public Byte[] EncryptValue(Byte[] rgb)
public RSAParameters ExportParameters(bool includePrivateParameters)
public void ImportParameters(RSAParameters parameters)
private HashAlgorithm GetHash(object halg)
public Byte[] SignData(Byte[] buffer, object halg)
public Byte[] SignData(Stream inputStream, object halg)
public Byte[] SignData(Byte[] buffer, int offset, int count, object halg)
private string GetHashNameFromOID(string oid)
public Byte[] SignHash(Byte[] rgbHash, string str)
public bool VerifyData(Byte[] buffer, object halg, Byte[] signature)
public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature)
protected void Dispose(bool disposing)
private void OnKeyGenerated(object sender, EventArgs e)
public CspKeyContainerInfo get_CspKeyContainerInfo()
public Byte[] ExportCspBlob(bool includePrivateParameters)
public void ImportCspBlob(Byte[] keyBlob)
}
public System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
private RSA rsa
public string Parameters
public void .ctor(AsymmetricAlgorithm key)
public string get_Parameters()
public void set_Parameters(string value)
public Byte[] DecryptKeyExchange(Byte[] rgbData)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
private RSA rsa
private RandomNumberGenerator random
private Byte[] param
public Byte[] Parameter
public string Parameters
public RandomNumberGenerator Rng
public void .ctor(AsymmetricAlgorithm key)
public Byte[] get_Parameter()
public void set_Parameter(Byte[] value)
public string get_Parameters()
public RandomNumberGenerator get_Rng()
public void set_Rng(RandomNumberGenerator value)
public Byte[] CreateKeyExchange(Byte[] rgbData)
public Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSAParameters : ValueType {
public Byte[] P
public Byte[] Q
public Byte[] D
public Byte[] DP
public Byte[] DQ
public Byte[] InverseQ
public Byte[] Modulus
public Byte[] Exponent
}
public System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
private RSA rsa
private RandomNumberGenerator random
public string Parameters
public RandomNumberGenerator RNG
public void .ctor(AsymmetricAlgorithm key)
public string get_Parameters()
public void set_Parameters(string value)
public RandomNumberGenerator get_RNG()
public void set_RNG(RandomNumberGenerator value)
public Byte[] DecryptKeyExchange(Byte[] rgbIn)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
private RSA rsa
private RandomNumberGenerator random
public RandomNumberGenerator Rng
public string Parameters
public void .ctor(AsymmetricAlgorithm key)
public RandomNumberGenerator get_Rng()
public void set_Rng(RandomNumberGenerator value)
public string get_Parameters()
public Byte[] CreateKeyExchange(Byte[] rgbData)
public Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType)
private void SetRSAKey(AsymmetricAlgorithm key)
public void SetKey(AsymmetricAlgorithm key)
}
internal System.Security.Cryptography.RSAPKCS1SHA1SignatureDescription : SignatureDescription {
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
private RSA rsa
private string hashName
public void .ctor(AsymmetricAlgorithm key)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature)
}
public System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
private RSA rsa
private HashAlgorithm hash
public void .ctor(AsymmetricAlgorithm key)
public Byte[] CreateSignature(Byte[] rgbHash)
public void SetHashAlgorithm(string strName)
public void SetKey(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.SHA1 : HashAlgorithm {
public SHA1 Create()
public SHA1 Create(string hashName)
}
public System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
private SHA1Internal sha
protected void Finalize()
protected void Dispose(bool disposing)
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
}
internal System.Security.Cryptography.SHA1Internal : object {
private int BLOCK_SIZE_BYTES
private int HASH_SIZE_BYTES
private UInt32[] _H
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] buff
public void HashCore(Byte[] rgb, int ibStart, int cbSize)
public Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, UInt32 inputOffset)
private void InitialiseBuff(UInt32[] buff, Byte[] input, UInt32 inputOffset)
private void FillBuff(UInt32[] buff)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
public System.Security.Cryptography.SHA1Managed : SHA1 {
private SHA1Internal sha
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
}
public System.Security.Cryptography.SHA256 : HashAlgorithm {
public SHA256 Create()
public SHA256 Create(string hashName)
}
public System.Security.Cryptography.SHA256Managed : SHA256 {
private int BLOCK_SIZE_BYTES
private int HASH_SIZE_BYTES
private UInt32[] _H
private ulong count
private Byte[] _ProcessingBuffer
private int _ProcessingBufferCount
private UInt32[] buff
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
public void Initialize()
private void ProcessBlock(Byte[] inputBuffer, int inputOffset)
private void ProcessFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal void AddLength(ulong length, Byte[] buffer, int position)
}
public System.Security.Cryptography.SHA384 : HashAlgorithm {
public SHA384 Create()
public SHA384 Create(string hashName)
}
public System.Security.Cryptography.SHA384Managed : SHA384 {
private Byte[] xBuf
private int xBufOff
private ulong byteCount1
private ulong byteCount2
private ulong H1
private ulong H2
private ulong H3
private ulong H4
private ulong H5
private ulong H6
private ulong H7
private ulong H8
private UInt64[] W
private int wOff
private void Initialize(bool reuse)
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void update(byte input)
private void processWord(Byte[] input, int inOff)
private void unpackWord(ulong word, Byte[] output, int outOff)
private void adjustByteCounts()
private void processLength(ulong lowW, ulong hiW)
private void processBlock()
}
public System.Security.Cryptography.SHA512 : HashAlgorithm {
public SHA512 Create()
public SHA512 Create(string hashName)
}
public System.Security.Cryptography.SHA512Managed : SHA512 {
private Byte[] xBuf
private int xBufOff
private ulong byteCount1
private ulong byteCount2
private ulong H1
private ulong H2
private ulong H3
private ulong H4
private ulong H5
private ulong H6
private ulong H7
private ulong H8
private UInt64[] W
private int wOff
private void Initialize(bool reuse)
public void Initialize()
protected void HashCore(Byte[] rgb, int ibStart, int cbSize)
protected Byte[] HashFinal()
private void update(byte input)
private void processWord(Byte[] input, int inOff)
private void unpackWord(ulong word, Byte[] output, int outOff)
private void adjustByteCounts()
private void processLength(ulong lowW, ulong hiW)
private void processBlock()
private ulong rotateRight(ulong x, int n)
private ulong Ch(ulong x, ulong y, ulong z)
private ulong Maj(ulong x, ulong y, ulong z)
private ulong Sum0(ulong x)
private ulong Sum1(ulong x)
private ulong Sigma0(ulong x)
private ulong Sigma1(ulong x)
}
internal System.Security.Cryptography.SHAConstants : object {
public UInt32[] K1
public UInt64[] K2
}
public System.Security.Cryptography.SignatureDescription : object {
private string _DeformatterAlgorithm
private string _DigestAlgorithm
private string _FormatterAlgorithm
private string _KeyAlgorithm
public string DeformatterAlgorithm
public string DigestAlgorithm
public string FormatterAlgorithm
public string KeyAlgorithm
public void .ctor(SecurityElement el)
public string get_DeformatterAlgorithm()
public void set_DeformatterAlgorithm(string value)
public string get_DigestAlgorithm()
public void set_DigestAlgorithm(string value)
public string get_FormatterAlgorithm()
public void set_FormatterAlgorithm(string value)
public string get_KeyAlgorithm()
public void set_KeyAlgorithm(string value)
public AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)
public HashAlgorithm CreateDigest()
public AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key)
}
public System.Security.Cryptography.SymmetricAlgorithm : object {
protected int BlockSizeValue
protected Byte[] IVValue
protected int KeySizeValue
protected Byte[] KeyValue
protected KeySizes[] LegalBlockSizesValue
protected KeySizes[] LegalKeySizesValue
protected int FeedbackSizeValue
protected CipherMode ModeValue
protected PaddingMode PaddingValue
private bool m_disposed
public int BlockSize
public int FeedbackSize
public Byte[] IV
public Byte[] Key
public int KeySize
public KeySizes[] LegalBlockSizes
public KeySizes[] LegalKeySizes
public CipherMode Mode
public PaddingMode Padding
private void System.IDisposable.Dispose()
protected void Finalize()
public void Clear()
protected void Dispose(bool disposing)
public int get_BlockSize()
public void set_BlockSize(int value)
public int get_FeedbackSize()
public void set_FeedbackSize(int value)
public Byte[] get_IV()
public void set_IV(Byte[] value)
public Byte[] get_Key()
public void set_Key(Byte[] value)
public int get_KeySize()
public void set_KeySize(int value)
public KeySizes[] get_LegalBlockSizes()
public KeySizes[] get_LegalKeySizes()
public CipherMode get_Mode()
public void set_Mode(CipherMode value)
public PaddingMode get_Padding()
public void set_Padding(PaddingMode value)
public ICryptoTransform CreateDecryptor()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor()
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
public void GenerateIV()
public void GenerateKey()
public bool ValidKeySize(int bitLength)
public SymmetricAlgorithm Create()
public SymmetricAlgorithm Create(string algName)
}
public System.Security.Cryptography.ToBase64Transform : object {
private int inputBlockSize
private int outputBlockSize
private bool m_disposed
public bool CanTransformMultipleBlocks
public bool CanReuseTransform
public int InputBlockSize
public int OutputBlockSize
private void System.IDisposable.Dispose()
protected void Finalize()
public bool get_CanTransformMultipleBlocks()
public bool get_CanReuseTransform()
public int get_InputBlockSize()
public int get_OutputBlockSize()
public void Clear()
protected void Dispose(bool disposing)
public int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
internal void InternalTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset)
public Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
internal Byte[] InternalTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount)
}
public System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
public Byte[] Key
public Byte[] get_Key()
public void set_Key(Byte[] value)
public bool IsWeakKey(Byte[] rgbKey)
public TripleDES Create()
public TripleDES Create(string str)
}
public System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
public void GenerateIV()
public void GenerateKey()
public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV)
public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV)
}
internal System.Security.Cryptography.TripleDESTransform : SymmetricTransform {
private DESTransform E1
private DESTransform D2
private DESTransform E3
private DESTransform D1
private DESTransform E2
private DESTransform D3
public void .ctor(TripleDES algo, bool encryption, Byte[] key, Byte[] iv)
protected void ECB(Byte[] input, Byte[] output)
internal Byte[] GetStrongKey()
}
public System.Security.Cryptography.X509Certificates.X509Certificate : object {
private X509Certificate x509
private bool hideDates
private Byte[] cachedCertificateHash
private string issuer_name
private string subject_name
public string Issuer
public string Subject
public IntPtr Handle
internal void .ctor(Byte[] data, bool dates)
public void .ctor(Byte[] data)
public void .ctor(IntPtr handle)
public void .ctor(X509Certificate cert)
public void .ctor(Byte[] rawData, string password)
public void .ctor(Byte[] rawData, SecureString password)
public void .ctor(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName)
public void .ctor(string fileName, string password)
public void .ctor(string fileName, SecureString password)
public void .ctor(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
private string tostr(Byte[] data)
public X509Certificate CreateFromCertFile(string filename)
public X509Certificate CreateFromSignedFile(string filename)
private void InitFromHandle(IntPtr handle)
public bool Equals(X509Certificate other)
public Byte[] GetCertHash()
public string GetCertHashString()
public string GetEffectiveDateString()
public string GetExpirationDateString()
public string GetFormat()
public int GetHashCode()
public string GetIssuerName()
public string GetKeyAlgorithm()
public Byte[] GetKeyAlgorithmParameters()
public string GetKeyAlgorithmParametersString()
public string GetName()
public Byte[] GetPublicKey()
public string GetPublicKeyString()
public Byte[] GetRawCertData()
public string GetRawCertDataString()
public Byte[] GetSerialNumber()
public string GetSerialNumberString()
public string ToString()
public string ToString(bool fVerbose)
private Byte[] Load(string fileName)
public string get_Issuer()
public string get_Subject()
public IntPtr get_Handle()
public bool Equals(object obj)
public Byte[] Export(X509ContentType contentType)
public Byte[] Export(X509ContentType contentType, string password)
public Byte[] Export(X509ContentType contentType, SecureString password)
internal Byte[] Export(X509ContentType contentType, Byte[] password)
public void Import(Byte[] rawData)
public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName)
public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags)
public void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags)
public void Reset()
}
public System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
public int value__
public X509ContentType Unknown
public X509ContentType Cert
public X509ContentType SerializedCert
public X509ContentType Pfx
public X509ContentType SerializedStore
public X509ContentType Pkcs7
public X509ContentType Authenticode
public X509ContentType Pkcs12
}
public System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
public int value__
public X509KeyStorageFlags DefaultKeySet
public X509KeyStorageFlags UserKeySet
public X509KeyStorageFlags MachineKeySet
public X509KeyStorageFlags Exportable
public X509KeyStorageFlags UserProtected
public X509KeyStorageFlags PersistKeySet
}
public System.Security.HostProtectionException : SystemException {
private HostProtectionResource _protected
private HostProtectionResource _demanded
public HostProtectionResource DemandedResources
public HostProtectionResource ProtectedResources
public void .ctor(string message)
public void .ctor(string message, Exception e)
public void .ctor(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources)
protected void .ctor(SerializationInfo info, StreamingContext context)
public HostProtectionResource get_DemandedResources()
public HostProtectionResource get_ProtectedResources()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
public System.Security.HostSecurityManager : object {
public PolicyLevel DomainPolicy
public HostSecurityManagerOptions Flags
public PolicyLevel get_DomainPolicy()
public HostSecurityManagerOptions get_Flags()
public ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context)
public Evidence ProvideAppDomainEvidence(Evidence inputEvidence)
public Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence)
public PermissionSet ResolvePolicy(Evidence evidence)
}
public System.Security.HostSecurityManagerOptions : Enum {
public int value__
public HostSecurityManagerOptions None
public HostSecurityManagerOptions HostAppDomainEvidence
public HostSecurityManagerOptions HostPolicyLevel
public HostSecurityManagerOptions HostAssemblyEvidence
public HostSecurityManagerOptions HostDetermineApplicationTrust
public HostSecurityManagerOptions HostResolvePolicy
public HostSecurityManagerOptions AllFlags
}
public System.Security.IEvidenceFactory {
public Evidence Evidence
public Evidence get_Evidence()
}
public System.Security.IPermission {
public IPermission Copy()
public void Demand()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
}
public System.Security.ISecurityEncodable {
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
}
public System.Security.ISecurityPolicyEncodable {
public void FromXml(SecurityElement e, PolicyLevel level)
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.IStackWalk {
public void Assert()
public void Demand()
public void Deny()
public void PermitOnly()
}
public System.Security.NamedPermissionSet : PermissionSet {
private string name
private string description
public string Description
public string Name
public void .ctor(string name, PermissionSet permSet)
public void .ctor(string name, PermissionState state)
public void .ctor(NamedPermissionSet permSet)
public void .ctor(string name)
public string get_Description()
public void set_Description(string value)
public string get_Name()
public void set_Name(string value)
public PermissionSet Copy()
public NamedPermissionSet Copy(string name)
public void FromXml(SecurityElement et)
public SecurityElement ToXml()
public bool Equals(object obj)
public int GetHashCode()
}
internal System.Security.PermissionBuilder : object {
private Object[] psNone
public IPermission Create(string fullname, PermissionState state)
public IPermission Create(SecurityElement se)
public IPermission Create(string fullname, SecurityElement se)
public IPermission Create(Type type)
internal IPermission CreatePermission(string fullname, SecurityElement se)
}
internal System.Security.Permissions.BuiltInToken : Enum {
public int value__
public BuiltInToken Environment
public BuiltInToken FileDialog
public BuiltInToken FileIO
public BuiltInToken IsolatedStorageFile
public BuiltInToken Reflection
public BuiltInToken Registry
public BuiltInToken Security
public BuiltInToken UI
public BuiltInToken Principal
public BuiltInToken HostProtection
public BuiltInToken PublisherIdentity
public BuiltInToken SiteIdentity
public BuiltInToken StrongNameIdentity
public BuiltInToken UrlIdentity
public BuiltInToken ZoneIdentity
public BuiltInToken GacIdentity
public BuiltInToken KeyContainer
}
public System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
protected void .ctor(SecurityAction action)
}
public System.Security.Permissions.EnvironmentPermission : CodeAccessPermission {
private int version
private PermissionState _state
private ArrayList readList
private ArrayList writeList
public void .ctor(PermissionState state)
public void .ctor(EnvironmentPermissionAccess flag, string pathList)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public void AddPathList(EnvironmentPermissionAccess flag, string pathList)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public string GetPathList(EnvironmentPermissionAccess flag)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public void SetPathList(EnvironmentPermissionAccess flag, string pathList)
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private bool IsEmpty()
private EnvironmentPermission Cast(IPermission target)
internal void ThrowInvalidFlag(EnvironmentPermissionAccess flag, bool context)
private string GetPathList(ArrayList list)
}
public System.Security.Permissions.EnvironmentPermissionAccess : Enum {
public int value__
public EnvironmentPermissionAccess NoAccess
public EnvironmentPermissionAccess Read
public EnvironmentPermissionAccess Write
public EnvironmentPermissionAccess AllAccess
}
public System.Security.Permissions.EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
private string read
private string write
public string All
public string Read
public string Write
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.FileDialogPermission : CodeAccessPermission {
private int version
private FileDialogPermissionAccess _access
public FileDialogPermissionAccess Access
public void .ctor(PermissionState state)
public void .ctor(FileDialogPermissionAccess access)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public FileDialogPermissionAccess get_Access()
public void set_Access(FileDialogPermissionAccess value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private FileDialogPermission Cast(IPermission target)
}
public System.Security.Permissions.FileDialogPermissionAccess : Enum {
public int value__
public FileDialogPermissionAccess None
public FileDialogPermissionAccess Open
public FileDialogPermissionAccess Save
public FileDialogPermissionAccess OpenSave
}
public System.Security.Permissions.FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
private bool canOpen
private bool canSave
public bool Open
public bool Save
public void .ctor(SecurityAction action)
public bool get_Open()
public void set_Open(bool value)
public bool get_Save()
public void set_Save(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.FileIOPermission : CodeAccessPermission {
private int version
private Char[] BadPathNameCharacters
private Char[] BadFileNameCharacters
private bool m_Unrestricted
private FileIOPermissionAccess m_AllFilesAccess
private FileIOPermissionAccess m_AllLocalFilesAccess
private ArrayList readList
private ArrayList writeList
private ArrayList appendList
private ArrayList pathList
public FileIOPermissionAccess AllFiles
public FileIOPermissionAccess AllLocalFiles
public void .ctor(PermissionState state)
public void .ctor(FileIOPermissionAccess access, string path)
public void .ctor(FileIOPermissionAccess access, String[] pathList)
public void .ctor(FileIOPermissionAccess access, AccessControlActions control, string path)
public void .ctor(FileIOPermissionAccess access, AccessControlActions control, String[] pathList)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
internal void CreateLists()
public FileIOPermissionAccess get_AllFiles()
public void set_AllFiles(FileIOPermissionAccess value)
public FileIOPermissionAccess get_AllLocalFiles()
public void set_AllLocalFiles(FileIOPermissionAccess value)
public void AddPathList(FileIOPermissionAccess access, string path)
public void AddPathList(FileIOPermissionAccess access, String[] pathList)
internal void AddPathInternal(FileIOPermissionAccess access, string path)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public String[] GetPathList(FileIOPermissionAccess access)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public void SetPathList(FileIOPermissionAccess access, string path)
public void SetPathList(FileIOPermissionAccess access, String[] pathList)
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public bool Equals(object obj)
public int GetHashCode()
private bool IsEmpty()
private FileIOPermission Cast(IPermission target)
internal void ThrowInvalidFlag(FileIOPermissionAccess access, bool context)
internal void ThrowIfInvalidPath(string path)
internal void ThrowIfInvalidPath(String[] paths)
internal void Clear(FileIOPermissionAccess access)
internal bool KeyIsSubsetOf(IList local, IList target)
internal void UnionKeys(IList list, String[] paths)
internal void IntersectKeys(IList local, IList target, IList result)
}
public System.Security.Permissions.FileIOPermissionAccess : Enum {
public int value__
public FileIOPermissionAccess NoAccess
public FileIOPermissionAccess Read
public FileIOPermissionAccess Write
public FileIOPermissionAccess Append
public FileIOPermissionAccess PathDiscovery
public FileIOPermissionAccess AllAccess
}
public System.Security.Permissions.FileIOPermissionAttribute : CodeAccessSecurityAttribute {
private string append
private string path
private string read
private string write
private FileIOPermissionAccess allFiles
private FileIOPermissionAccess allLocalFiles
private string changeAccessControl
private string viewAccessControl
public string All
public string Append
public string PathDiscovery
public string Read
public string Write
public FileIOPermissionAccess AllFiles
public FileIOPermissionAccess AllLocalFiles
public string ChangeAccessControl
public string ViewAccessControl
public string ViewAndModify
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Append()
public void set_Append(string value)
public string get_PathDiscovery()
public void set_PathDiscovery(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public FileIOPermissionAccess get_AllFiles()
public void set_AllFiles(FileIOPermissionAccess value)
public FileIOPermissionAccess get_AllLocalFiles()
public void set_AllLocalFiles(FileIOPermissionAccess value)
public string get_ChangeAccessControl()
public void set_ChangeAccessControl(string value)
public string get_ViewAccessControl()
public void set_ViewAccessControl(string value)
public string get_ViewAndModify()
public void set_ViewAndModify(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.GacIdentityPermission : CodeAccessPermission {
private int version
public void .ctor(PermissionState state)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public void FromXml(SecurityElement securityElement)
public SecurityElement ToXml()
private GacIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Security.Permissions.HostProtectionAttribute : CodeAccessSecurityAttribute {
private HostProtectionResource _resources
public bool ExternalProcessMgmt
public bool ExternalThreading
public bool MayLeakOnAbort
public bool SecurityInfrastructure
public bool SelfAffectingProcessMgmt
public bool SelfAffectingThreading
public bool SharedState
public bool Synchronization
public bool UI
public HostProtectionResource Resources
public void .ctor(SecurityAction action)
public bool get_ExternalProcessMgmt()
public void set_ExternalProcessMgmt(bool value)
public bool get_ExternalThreading()
public void set_ExternalThreading(bool value)
public bool get_MayLeakOnAbort()
public void set_MayLeakOnAbort(bool value)
public bool get_SecurityInfrastructure()
public void set_SecurityInfrastructure(bool value)
public bool get_SelfAffectingProcessMgmt()
public void set_SelfAffectingProcessMgmt(bool value)
public bool get_SelfAffectingThreading()
public void set_SelfAffectingThreading(bool value)
public bool get_SharedState()
public void set_SharedState(bool value)
public bool get_Synchronization()
public void set_Synchronization(bool value)
public bool get_UI()
public void set_UI(bool value)
public HostProtectionResource get_Resources()
public void set_Resources(HostProtectionResource value)
public IPermission CreatePermission()
}
internal System.Security.Permissions.HostProtectionPermission : CodeAccessPermission {
private int version
private HostProtectionResource _resources
public HostProtectionResource Resources
public void .ctor(PermissionState state)
public void .ctor(HostProtectionResource resources)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public HostProtectionResource get_Resources()
public void set_Resources(HostProtectionResource value)
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
public bool IsUnrestricted()
private HostProtectionPermission Cast(IPermission target)
}
public System.Security.Permissions.HostProtectionResource : Enum {
public int value__
public HostProtectionResource None
public HostProtectionResource Synchronization
public HostProtectionResource SharedState
public HostProtectionResource ExternalProcessMgmt
public HostProtectionResource SelfAffectingProcessMgmt
public HostProtectionResource ExternalThreading
public HostProtectionResource SelfAffectingThreading
public HostProtectionResource SecurityInfrastructure
public HostProtectionResource UI
public HostProtectionResource MayLeakOnAbort
public HostProtectionResource All
}
internal System.Security.Permissions.IBuiltInPermission {
public int GetTokenIndex()
}
public System.Security.Permissions.IsolatedStorageContainment : Enum {
public int value__
public IsolatedStorageContainment None
public IsolatedStorageContainment DomainIsolationByUser
public IsolatedStorageContainment AssemblyIsolationByUser
public IsolatedStorageContainment DomainIsolationByRoamingUser
public IsolatedStorageContainment AssemblyIsolationByRoamingUser
public IsolatedStorageContainment AdministerIsolatedStorageByUser
public IsolatedStorageContainment UnrestrictedIsolatedStorage
public IsolatedStorageContainment ApplicationIsolationByUser
public IsolatedStorageContainment DomainIsolationByMachine
public IsolatedStorageContainment AssemblyIsolationByMachine
public IsolatedStorageContainment ApplicationIsolationByMachine
public IsolatedStorageContainment ApplicationIsolationByRoamingUser
}
public System.Security.Permissions.IsolatedStorageFilePermission : IsolatedStoragePermission {
private int version
public void .ctor(PermissionState state)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public SecurityElement ToXml()
private IsolatedStorageFilePermission Cast(IPermission target)
}
public System.Security.Permissions.IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
public void .ctor(SecurityAction action)
public IPermission CreatePermission()
}
public System.Security.Permissions.IsolatedStoragePermission : CodeAccessPermission {
private int version
internal long m_userQuota
internal long m_machineQuota
internal long m_expirationDays
internal bool m_permanentData
internal IsolatedStorageContainment m_allowed
public long UserQuota
public IsolatedStorageContainment UsageAllowed
protected void .ctor(PermissionState state)
public long get_UserQuota()
public void set_UserQuota(long value)
public IsolatedStorageContainment get_UsageAllowed()
public void set_UsageAllowed(IsolatedStorageContainment value)
public bool IsUnrestricted()
public SecurityElement ToXml()
public void FromXml(SecurityElement esd)
internal bool IsEmpty()
}
public System.Security.Permissions.IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
private IsolatedStorageContainment usage_allowed
private long user_quota
public IsolatedStorageContainment UsageAllowed
public long UserQuota
protected void .ctor(SecurityAction action)
public IsolatedStorageContainment get_UsageAllowed()
public void set_UsageAllowed(IsolatedStorageContainment value)
public long get_UserQuota()
public void set_UserQuota(long value)
}
public System.Security.Permissions.IUnrestrictedPermission {
public bool IsUnrestricted()
}
public System.Security.Permissions.KeyContainerPermission : CodeAccessPermission {
private int version
private KeyContainerPermissionAccessEntryCollection _accessEntries
private KeyContainerPermissionFlags _flags
public KeyContainerPermissionAccessEntryCollection AccessEntries
public KeyContainerPermissionFlags Flags
public void .ctor(PermissionState state)
public void .ctor(KeyContainerPermissionFlags flags)
public void .ctor(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public KeyContainerPermissionAccessEntryCollection get_AccessEntries()
public KeyContainerPermissionFlags get_Flags()
public IPermission Copy()
public void FromXml(SecurityElement securityElement)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private void SetFlags(KeyContainerPermissionFlags flags)
private KeyContainerPermission Cast(IPermission target)
}
public System.Security.Permissions.KeyContainerPermissionAccessEntry : object {
private KeyContainerPermissionFlags _flags
private string _containerName
private int _spec
private string _store
private string _providerName
private int _type
public KeyContainerPermissionFlags Flags
public string KeyContainerName
public int KeySpec
public string KeyStore
public string ProviderName
public int ProviderType
public void .ctor(CspParameters parameters, KeyContainerPermissionFlags flags)
public void .ctor(string keyContainerName, KeyContainerPermissionFlags flags)
public void .ctor(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags)
public KeyContainerPermissionFlags get_Flags()
public void set_Flags(KeyContainerPermissionFlags value)
public string get_KeyContainerName()
public void set_KeyContainerName(string value)
public int get_KeySpec()
public void set_KeySpec(int value)
public string get_KeyStore()
public void set_KeyStore(string value)
public string get_ProviderName()
public void set_ProviderName(string value)
public int get_ProviderType()
public void set_ProviderType(int value)
public bool Equals(object o)
public int GetHashCode()
}
public System.Security.Permissions.KeyContainerPermissionAccessEntryCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public KeyContainerPermissionAccessEntry Item
public object SyncRoot
internal void .ctor(KeyContainerPermissionAccessEntry[] entries)
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public KeyContainerPermissionAccessEntry get_Item(int index)
public object get_SyncRoot()
public int Add(KeyContainerPermissionAccessEntry accessEntry)
public void Clear()
public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index)
public KeyContainerPermissionAccessEntryEnumerator GetEnumerator()
public int IndexOf(KeyContainerPermissionAccessEntry accessEntry)
public void Remove(KeyContainerPermissionAccessEntry accessEntry)
}
public System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator : object {
private IEnumerator e
private object System.Collections.IEnumerator.Current
public KeyContainerPermissionAccessEntry Current
internal void .ctor(ArrayList list)
private object System.Collections.IEnumerator.get_Current()
public KeyContainerPermissionAccessEntry get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Permissions.KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
private KeyContainerPermissionFlags _flags
private string _containerName
private int _spec
private string _store
private string _providerName
private int _type
public KeyContainerPermissionFlags Flags
public string KeyContainerName
public int KeySpec
public string KeyStore
public string ProviderName
public int ProviderType
public void .ctor(SecurityAction action)
public KeyContainerPermissionFlags get_Flags()
public void set_Flags(KeyContainerPermissionFlags value)
public string get_KeyContainerName()
public void set_KeyContainerName(string value)
public int get_KeySpec()
public void set_KeySpec(int value)
public string get_KeyStore()
public void set_KeyStore(string value)
public string get_ProviderName()
public void set_ProviderName(string value)
public int get_ProviderType()
public void set_ProviderType(int value)
public IPermission CreatePermission()
private bool EmptyEntry()
}
public System.Security.Permissions.KeyContainerPermissionFlags : Enum {
public int value__
public KeyContainerPermissionFlags NoFlags
public KeyContainerPermissionFlags Create
public KeyContainerPermissionFlags Open
public KeyContainerPermissionFlags Delete
public KeyContainerPermissionFlags Import
public KeyContainerPermissionFlags Export
public KeyContainerPermissionFlags Sign
public KeyContainerPermissionFlags Decrypt
public KeyContainerPermissionFlags ViewAcl
public KeyContainerPermissionFlags ChangeAcl
public KeyContainerPermissionFlags AllFlags
}
public System.Security.Permissions.PermissionSetAttribute : CodeAccessSecurityAttribute {
private string file
private string name
private bool isUnicodeEncoded
private string xml
private string hex
public string File
public string Hex
public string Name
public bool UnicodeEncoded
public string XML
public void .ctor(SecurityAction action)
public string get_File()
public void set_File(string value)
public string get_Hex()
public void set_Hex(string value)
public string get_Name()
public void set_Name(string value)
public bool get_UnicodeEncoded()
public void set_UnicodeEncoded(bool value)
public string get_XML()
public void set_XML(string value)
public IPermission CreatePermission()
private PermissionSet CreateFromXml(string xml)
public PermissionSet CreatePermissionSet()
}
public System.Security.Permissions.PermissionState : Enum {
public int value__
public PermissionState Unrestricted
public PermissionState None
}
public System.Security.Permissions.PrincipalPermission : object {
private int version
private ArrayList principals
public void .ctor(PermissionState state)
public void .ctor(string name, string role)
public void .ctor(string name, string role, bool isAuthenticated)
internal void .ctor(ArrayList principals)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public IPermission Copy()
public void Demand()
public void FromXml(SecurityElement elem)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public string ToString()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
public bool Equals(object obj)
public int GetHashCode()
private PrincipalPermission Cast(IPermission target)
private bool IsEmpty()
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
}
public System.Security.Permissions.PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
private bool authenticated
private string name
private string role
public bool Authenticated
public string Name
public string Role
public void .ctor(SecurityAction action)
public bool get_Authenticated()
public void set_Authenticated(bool value)
public string get_Name()
public void set_Name(string value)
public string get_Role()
public void set_Role(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.PublisherIdentityPermission : CodeAccessPermission {
private int version
private X509Certificate x509
public X509Certificate Certificate
public void .ctor(PermissionState state)
public void .ctor(X509Certificate certificate)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public X509Certificate get_Certificate()
public void set_Certificate(X509Certificate value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private PublisherIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string certFile
private string signedFile
private string x509data
public string CertFile
public string SignedFile
public string X509Certificate
public void .ctor(SecurityAction action)
public string get_CertFile()
public void set_CertFile(string value)
public string get_SignedFile()
public void set_SignedFile(string value)
public string get_X509Certificate()
public void set_X509Certificate(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ReflectionPermission : CodeAccessPermission {
private int version
private ReflectionPermissionFlag flags
public ReflectionPermissionFlag Flags
public void .ctor(PermissionState state)
public void .ctor(ReflectionPermissionFlag flag)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public ReflectionPermissionFlag get_Flags()
public void set_Flags(ReflectionPermissionFlag value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private ReflectionPermission Cast(IPermission target)
}
public System.Security.Permissions.ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
private ReflectionPermissionFlag flags
private bool memberAccess
private bool reflectionEmit
private bool typeInfo
public ReflectionPermissionFlag Flags
public bool MemberAccess
public bool ReflectionEmit
public bool RestrictedMemberAccess
public bool TypeInformation
public void .ctor(SecurityAction action)
public ReflectionPermissionFlag get_Flags()
public void set_Flags(ReflectionPermissionFlag value)
public bool get_MemberAccess()
public void set_MemberAccess(bool value)
public bool get_ReflectionEmit()
public void set_ReflectionEmit(bool value)
public bool get_RestrictedMemberAccess()
public void set_RestrictedMemberAccess(bool value)
public bool get_TypeInformation()
public void set_TypeInformation(bool value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ReflectionPermissionFlag : Enum {
public int value__
public ReflectionPermissionFlag NoFlags
public ReflectionPermissionFlag TypeInformation
public ReflectionPermissionFlag MemberAccess
public ReflectionPermissionFlag ReflectionEmit
public ReflectionPermissionFlag AllFlags
public ReflectionPermissionFlag RestrictedMemberAccess
}
public System.Security.Permissions.RegistryPermission : CodeAccessPermission {
private int version
private PermissionState _state
private ArrayList createList
private ArrayList readList
private ArrayList writeList
public void .ctor(PermissionState state)
public void .ctor(RegistryPermissionAccess access, string pathList)
public void .ctor(RegistryPermissionAccess access, AccessControlActions control, string pathList)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public void AddPathList(RegistryPermissionAccess access, string pathList)
public void AddPathList(RegistryPermissionAccess access, AccessControlActions control, string pathList)
public string GetPathList(RegistryPermissionAccess access)
public void SetPathList(RegistryPermissionAccess access, string pathList)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission other)
private bool IsEmpty()
private RegistryPermission Cast(IPermission target)
internal void ThrowInvalidFlag(RegistryPermissionAccess flag, bool context)
private string GetPathList(ArrayList list)
internal bool KeyIsSubsetOf(IList local, IList target)
internal void AddWithUnionKey(IList list, string pathList)
internal void IntersectKeys(IList local, IList target, IList result)
}
public System.Security.Permissions.RegistryPermissionAccess : Enum {
public int value__
public RegistryPermissionAccess NoAccess
public RegistryPermissionAccess Read
public RegistryPermissionAccess Write
public RegistryPermissionAccess Create
public RegistryPermissionAccess AllAccess
}
public System.Security.Permissions.RegistryPermissionAttribute : CodeAccessSecurityAttribute {
private string create
private string read
private string write
private string changeAccessControl
private string viewAccessControl
public string All
public string Create
public string Read
public string Write
public string ChangeAccessControl
public string ViewAccessControl
public string ViewAndModify
public void .ctor(SecurityAction action)
public string get_All()
public void set_All(string value)
public string get_Create()
public void set_Create(string value)
public string get_Read()
public void set_Read(string value)
public string get_Write()
public void set_Write(string value)
public string get_ChangeAccessControl()
public void set_ChangeAccessControl(string value)
public string get_ViewAccessControl()
public void set_ViewAccessControl(string value)
public string get_ViewAndModify()
public void set_ViewAndModify(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.SecurityAction : Enum {
public int value__
public SecurityAction Demand
public SecurityAction Assert
public SecurityAction Deny
public SecurityAction PermitOnly
public SecurityAction LinkDemand
public SecurityAction InheritanceDemand
public SecurityAction RequestMinimum
public SecurityAction RequestOptional
public SecurityAction RequestRefuse
}
public System.Security.Permissions.SecurityAttribute : Attribute {
private SecurityAction m_Action
private bool m_Unrestricted
public bool Unrestricted
public SecurityAction Action
protected void .ctor(SecurityAction action)
public IPermission CreatePermission()
public bool get_Unrestricted()
public void set_Unrestricted(bool value)
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
}
public System.Security.Permissions.SecurityPermission : CodeAccessPermission {
private int version
private SecurityPermissionFlag flags
public SecurityPermissionFlag Flags
public void .ctor(PermissionState state)
public void .ctor(SecurityPermissionFlag flag)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public SecurityPermissionFlag get_Flags()
public void set_Flags(SecurityPermissionFlag value)
public bool IsUnrestricted()
public IPermission Copy()
public IPermission Intersect(IPermission target)
public IPermission Union(IPermission target)
public bool IsSubsetOf(IPermission target)
public void FromXml(SecurityElement esd)
public SecurityElement ToXml()
private bool IsEmpty()
private SecurityPermission Cast(IPermission target)
}
public System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
private SecurityPermissionFlag m_Flags
public bool Assertion
public bool BindingRedirects
public bool ControlAppDomain
public bool ControlDomainPolicy
public bool ControlEvidence
public bool ControlPolicy
public bool ControlPrincipal
public bool ControlThread
public bool Execution
public bool Infrastructure
public bool RemotingConfiguration
public bool SerializationFormatter
public bool SkipVerification
public bool UnmanagedCode
public SecurityPermissionFlag Flags
public void .ctor(SecurityAction action)
public bool get_Assertion()
public void set_Assertion(bool value)
public bool get_BindingRedirects()
public void set_BindingRedirects(bool value)
public bool get_ControlAppDomain()
public void set_ControlAppDomain(bool value)
public bool get_ControlDomainPolicy()
public void set_ControlDomainPolicy(bool value)
public bool get_ControlEvidence()
public void set_ControlEvidence(bool value)
public bool get_ControlPolicy()
public void set_ControlPolicy(bool value)
public bool get_ControlPrincipal()
public void set_ControlPrincipal(bool value)
public bool get_ControlThread()
public void set_ControlThread(bool value)
public bool get_Execution()
public void set_Execution(bool value)
public bool get_Infrastructure()
public void set_Infrastructure(bool value)
public bool get_RemotingConfiguration()
public void set_RemotingConfiguration(bool value)
public bool get_SerializationFormatter()
public void set_SerializationFormatter(bool value)
public bool get_SkipVerification()
public void set_SkipVerification(bool value)
public bool get_UnmanagedCode()
public void set_UnmanagedCode(bool value)
public IPermission CreatePermission()
public SecurityPermissionFlag get_Flags()
public void set_Flags(SecurityPermissionFlag value)
}
public System.Security.Permissions.SecurityPermissionFlag : Enum {
public int value__
public SecurityPermissionFlag NoFlags
public SecurityPermissionFlag Assertion
public SecurityPermissionFlag UnmanagedCode
public SecurityPermissionFlag SkipVerification
public SecurityPermissionFlag Execution
public SecurityPermissionFlag ControlThread
public SecurityPermissionFlag ControlEvidence
public SecurityPermissionFlag ControlPolicy
public SecurityPermissionFlag SerializationFormatter
public SecurityPermissionFlag ControlDomainPolicy
public SecurityPermissionFlag ControlPrincipal
public SecurityPermissionFlag ControlAppDomain
public SecurityPermissionFlag RemotingConfiguration
public SecurityPermissionFlag Infrastructure
public SecurityPermissionFlag BindingRedirects
public SecurityPermissionFlag AllFlags
}
public System.Security.Permissions.SiteIdentityPermission : CodeAccessPermission {
private int version
private string _site
private Boolean[] valid
public string Site
public void .ctor(PermissionState state)
public void .ctor(string site)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public string get_Site()
public void set_Site(string value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty()
private SiteIdentityPermission Cast(IPermission target)
private bool IsValid(string s)
private bool Match(string target)
}
public System.Security.Permissions.SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string site
public string Site
public void .ctor(SecurityAction action)
public string get_Site()
public void set_Site(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StrongNameIdentityPermission : CodeAccessPermission {
private int version
private Version defaultVersion
private PermissionState _state
private ArrayList _list
public string Name
public StrongNamePublicKeyBlob PublicKey
public Version Version
public void .ctor(PermissionState state)
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
internal void .ctor(StrongNameIdentityPermission snip)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public string get_Name()
public void set_Name(string value)
public StrongNamePublicKeyBlob get_PublicKey()
public void set_PublicKey(StrongNamePublicKeyBlob value)
public Version get_Version()
public void set_Version(Version value)
internal void ResetToDefault()
public IPermission Copy()
public void FromXml(SecurityElement e)
private SNIP FromSecurityElement(SecurityElement se)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
private void ToSecurityElement(SecurityElement se, SNIP snip)
public IPermission Union(IPermission target)
private bool IsUnrestricted()
private bool Contains(SNIP snip)
private bool IsEmpty(SNIP snip)
private bool IsEmpty()
private StrongNameIdentityPermission Cast(IPermission target)
private bool Match(string target)
}
public System.Security.Permissions.StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string name
private string key
private string version
public string Name
public string PublicKey
public string Version
public void .ctor(SecurityAction action)
public string get_Name()
public void set_Name(string value)
public string get_PublicKey()
public void set_PublicKey(string value)
public string get_Version()
public void set_Version(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.StrongNamePublicKeyBlob : object {
internal Byte[] pubkey
public void .ctor(Byte[] publicKey)
internal StrongNamePublicKeyBlob FromString(string s)
private byte CharToByte(char c)
public bool Equals(object obj)
public int GetHashCode()
public string ToString()
}
public System.Security.Permissions.UIPermission : CodeAccessPermission {
private int version
private UIPermissionWindow _window
private UIPermissionClipboard _clipboard
public UIPermissionClipboard Clipboard
public UIPermissionWindow Window
public void .ctor(PermissionState state)
public void .ctor(UIPermissionClipboard clipboardFlag)
public void .ctor(UIPermissionWindow windowFlag)
public void .ctor(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public UIPermissionClipboard get_Clipboard()
public void set_Clipboard(UIPermissionClipboard value)
public UIPermissionWindow get_Window()
public void set_Window(UIPermissionWindow value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public bool IsUnrestricted()
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty(UIPermissionWindow w, UIPermissionClipboard c)
private UIPermission Cast(IPermission target)
}
public System.Security.Permissions.UIPermissionAttribute : CodeAccessSecurityAttribute {
private UIPermissionClipboard clipboard
private UIPermissionWindow window
public UIPermissionClipboard Clipboard
public UIPermissionWindow Window
public void .ctor(SecurityAction action)
public UIPermissionClipboard get_Clipboard()
public void set_Clipboard(UIPermissionClipboard value)
public UIPermissionWindow get_Window()
public void set_Window(UIPermissionWindow value)
public IPermission CreatePermission()
}
public System.Security.Permissions.UIPermissionClipboard : Enum {
public int value__
public UIPermissionClipboard NoClipboard
public UIPermissionClipboard OwnClipboard
public UIPermissionClipboard AllClipboard
}
public System.Security.Permissions.UIPermissionWindow : Enum {
public int value__
public UIPermissionWindow NoWindows
public UIPermissionWindow SafeSubWindows
public UIPermissionWindow SafeTopLevelWindows
public UIPermissionWindow AllWindows
}
public System.Security.Permissions.UrlIdentityPermission : CodeAccessPermission {
private int version
private string url
public string Url
public void .ctor(PermissionState state)
public void .ctor(string site)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public string get_Url()
public void set_Url(string value)
public IPermission Copy()
public void FromXml(SecurityElement esd)
public IPermission Intersect(IPermission target)
public bool IsSubsetOf(IPermission target)
public SecurityElement ToXml()
public IPermission Union(IPermission target)
private bool IsEmpty()
private UrlIdentityPermission Cast(IPermission target)
private bool Match(string target)
}
public System.Security.Permissions.UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private string url
public string Url
public void .ctor(SecurityAction action)
public string get_Url()
public void set_Url(string value)
public IPermission CreatePermission()
}
public System.Security.Permissions.ZoneIdentityPermission : CodeAccessPermission {
private int version
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(PermissionState state)
public void .ctor(SecurityZone zone)
private int System.Security.Permissions.IBuiltInPermission.GetTokenIndex()
public IPermission Copy()
public bool IsSubsetOf(IPermission target)
public IPermission Union(IPermission target)
public IPermission Intersect(IPermission target)
public void FromXml(SecurityElement esd)
public SecurityElement ToXml()
public SecurityZone get_SecurityZone()
public void set_SecurityZone(SecurityZone value)
private ZoneIdentityPermission Cast(IPermission target)
}
public System.Security.Permissions.ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
private SecurityZone zone
public SecurityZone Zone
public void .ctor(SecurityAction action)
public SecurityZone get_Zone()
public void set_Zone(SecurityZone value)
public IPermission CreatePermission()
}
public System.Security.PermissionSet : object {
private string tagName
private int version
private Object[] psUnrestricted
private PermissionState state
private ArrayList list
private PolicyLevel _policyLevel
private bool _declsec
private bool _readOnly
private Boolean[] _ignored
private Object[] action
private Dictionary`2<string, int> <>f__switch$map2B
private Dictionary`2<string, int> <>f__switch$map2C
public int Count
public bool IsSynchronized
public bool IsReadOnly
public object SyncRoot
internal bool DeclarativeSecurity
internal PolicyLevel Resolver
public void .ctor(PermissionState state)
public void .ctor(PermissionSet permSet)
internal void .ctor(string xml)
internal void .ctor(IPermission perm)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
public IPermission AddPermission(IPermission perm)
public void Assert()
internal void Clear()
public PermissionSet Copy()
public void CopyTo(Array array, int index)
public void Demand()
internal void CasOnlyDemand(int skip)
public void Deny()
public void FromXml(SecurityElement et)
public IEnumerator GetEnumerator()
public bool IsSubsetOf(PermissionSet target)
public void PermitOnly()
public bool ContainsNonCodeAccessPermissions()
public Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat)
public IPermission GetPermission(Type permClass)
public PermissionSet Intersect(PermissionSet other)
internal void InternalIntersect(PermissionSet intersect, PermissionSet a, PermissionSet b, bool unrestricted)
public bool IsEmpty()
public bool IsUnrestricted()
public IPermission RemovePermission(Type permClass)
public IPermission SetPermission(IPermission perm)
public string ToString()
public SecurityElement ToXml()
public PermissionSet Union(PermissionSet other)
public int get_Count()
public bool get_IsSynchronized()
public bool get_IsReadOnly()
public object get_SyncRoot()
internal bool get_DeclarativeSecurity()
internal void set_DeclarativeSecurity(bool value)
public bool Equals(object obj)
public int GetHashCode()
public void RevertAssert()
internal PolicyLevel get_Resolver()
internal void set_Resolver(PolicyLevel value)
internal void SetReadOnly(bool value)
private bool AllIgnored()
internal bool ProcessFrame(SecurityFrame frame, Assembly& current, AppDomain& domain)
internal void CheckAssembly(Assembly a, SecurityFrame frame)
internal void CheckAppDomain(AppDomain domain, SecurityFrame frame)
internal PermissionSet CreateFromBinaryFormat(Byte[] data)
internal int ReadEncodedInt(Byte[] data, Int32& position)
internal IPermission ProcessAttribute(Byte[] data, Int32& position)
}
public System.Security.Policy.AllMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.ApplicationDirectory : object {
private string directory
public string Directory
public void .ctor(string name)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public string get_Directory()
public object Copy()
public bool Equals(object o)
public int GetHashCode()
public string ToString()
private void ThrowOnInvalid(string appdir)
}
public System.Security.Policy.ApplicationDirectoryMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.ApplicationSecurityInfo : object {
private ActivationContext _context
private Evidence _evidence
private ApplicationId _appid
private PermissionSet _defaultSet
private ApplicationId _deployid
public Evidence ApplicationEvidence
public ApplicationId ApplicationId
public PermissionSet DefaultRequestSet
public ApplicationId DeploymentId
public void .ctor(ActivationContext activationContext)
public Evidence get_ApplicationEvidence()
public void set_ApplicationEvidence(Evidence value)
public ApplicationId get_ApplicationId()
public void set_ApplicationId(ApplicationId value)
public PermissionSet get_DefaultRequestSet()
public void set_DefaultRequestSet(PermissionSet value)
public ApplicationId get_DeploymentId()
public void set_DeploymentId(ApplicationId value)
}
public System.Security.Policy.ApplicationSecurityManager : object {
private string config
private IApplicationTrustManager _appTrustManager
private ApplicationTrustCollection _userAppTrusts
public IApplicationTrustManager ApplicationTrustManager
public ApplicationTrustCollection UserApplicationTrusts
public IApplicationTrustManager get_ApplicationTrustManager()
public ApplicationTrustCollection get_UserApplicationTrusts()
public bool DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
}
public System.Security.Policy.ApplicationTrust : object {
private ApplicationIdentity _appid
private PolicyStatement _defaultPolicy
private object _xtranfo
private bool _trustrun
private bool _persist
private IList`1<StrongName> fullTrustAssemblies
public ApplicationIdentity ApplicationIdentity
public PolicyStatement DefaultGrantSet
public object ExtraInfo
public bool IsApplicationTrustedToRun
public bool Persist
public void .ctor(ApplicationIdentity applicationIdentity)
internal void .ctor(PermissionSet defaultGrantSet, IEnumerable`1<StrongName> fullTrustAssemblies)
public ApplicationIdentity get_ApplicationIdentity()
public void set_ApplicationIdentity(ApplicationIdentity value)
public PolicyStatement get_DefaultGrantSet()
public void set_DefaultGrantSet(PolicyStatement value)
public object get_ExtraInfo()
public void set_ExtraInfo(object value)
public bool get_IsApplicationTrustedToRun()
public void set_IsApplicationTrustedToRun(bool value)
public bool get_Persist()
public void set_Persist(bool value)
public void FromXml(SecurityElement element)
public SecurityElement ToXml()
private PolicyStatement GetDefaultGrantSet()
}
public System.Security.Policy.ApplicationTrustCollection : object {
private ArrayList _list
public int Count
public bool IsSynchronized
public object SyncRoot
public ApplicationTrust Item
public ApplicationTrust Item
private void System.Collections.ICollection.CopyTo(Array array, int index)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsSynchronized()
public object get_SyncRoot()
public ApplicationTrust get_Item(int index)
public ApplicationTrust get_Item(string appFullName)
public int Add(ApplicationTrust trust)
public void AddRange(ApplicationTrust[] trusts)
public void AddRange(ApplicationTrustCollection trusts)
public void Clear()
public void CopyTo(ApplicationTrust[] array, int index)
public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch)
public ApplicationTrustEnumerator GetEnumerator()
public void Remove(ApplicationTrust trust)
public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch)
public void RemoveRange(ApplicationTrust[] trusts)
public void RemoveRange(ApplicationTrustCollection trusts)
internal void RemoveAllInstances(ApplicationTrust trust)
}
public System.Security.Policy.ApplicationTrustEnumerator : object {
private IEnumerator e
private object System.Collections.IEnumerator.Current
public ApplicationTrust Current
internal void .ctor(ApplicationTrustCollection collection)
private object System.Collections.IEnumerator.get_Current()
public ApplicationTrust get_Current()
public bool MoveNext()
public void Reset()
}
public System.Security.Policy.ApplicationVersionMatch : Enum {
public int value__
public ApplicationVersionMatch MatchExactVersion
public ApplicationVersionMatch MatchAllVersions
}
public System.Security.Policy.CodeConnectAccess : object {
public string AnyScheme
public int DefaultPort
public int OriginPort
public string OriginScheme
private string _scheme
private int _port
public int Port
public string Scheme
public void .ctor(string allowScheme, int allowPort)
public int get_Port()
public string get_Scheme()
public bool Equals(object o)
public int GetHashCode()
public CodeConnectAccess CreateAnySchemeAccess(int allowPort)
public CodeConnectAccess CreateOriginSchemeAccess(int allowPort)
}
public System.Security.Policy.CodeGroup : object {
private PolicyStatement m_policy
private IMembershipCondition m_membershipCondition
private string m_description
private string m_name
private ArrayList m_children
private Dictionary`2<string, int> <>f__switch$map2E
public string MergeLogic
public PolicyStatement PolicyStatement
public string Description
public IMembershipCondition MembershipCondition
public string Name
public IList Children
public string AttributeString
public string PermissionSetName
protected void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
public string get_MergeLogic()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public PolicyStatement get_PolicyStatement()
public void set_PolicyStatement(PolicyStatement value)
public string get_Description()
public void set_Description(string value)
public IMembershipCondition get_MembershipCondition()
public void set_MembershipCondition(IMembershipCondition value)
public string get_Name()
public void set_Name(string value)
public IList get_Children()
public void set_Children(IList value)
public string get_AttributeString()
public string get_PermissionSetName()
public void AddChild(CodeGroup group)
public bool Equals(object o)
public bool Equals(CodeGroup cg, bool compareChildren)
public void RemoveChild(CodeGroup group)
public int GetHashCode()
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
protected void ParseXml(SecurityElement e, PolicyLevel level)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
protected void CreateXml(SecurityElement element, PolicyLevel level)
internal CodeGroup CreateFromXml(SecurityElement se, PolicyLevel level)
}
internal System.Security.Policy.DefaultPolicies : object {
private string DnsPermissionClass
private string EventLogPermissionClass
private string PrintingPermissionClass
private string SocketPermissionClass
private string WebPermissionClass
private string PerformanceCounterPermissionClass
private string DirectoryServicesPermissionClass
private string MessageQueuePermissionClass
private string ServiceControllerPermissionClass
private string OleDbPermissionClass
private string SqlClientPermissionClass
private string DataProtectionPermissionClass
private string StorePermissionClass
private Version _fxVersion
private Byte[] _ecmaKey
private StrongNamePublicKeyBlob _ecma
private Byte[] _msFinalKey
private StrongNamePublicKeyBlob _msFinal
private NamedPermissionSet _fullTrust
private NamedPermissionSet _localIntranet
private NamedPermissionSet _internet
private NamedPermissionSet _skipVerification
private NamedPermissionSet _execution
private NamedPermissionSet _nothing
private NamedPermissionSet _everything
private Dictionary`2<string, int> <>f__switch$map2F
public PermissionSet FullTrust
public PermissionSet LocalIntranet
public PermissionSet Internet
public PermissionSet SkipVerification
public PermissionSet Execution
public PermissionSet Nothing
public PermissionSet Everything
public PermissionSet GetSpecialPermissionSet(string name)
public PermissionSet get_FullTrust()
public PermissionSet get_LocalIntranet()
public PermissionSet get_Internet()
public PermissionSet get_SkipVerification()
public PermissionSet get_Execution()
public PermissionSet get_Nothing()
public PermissionSet get_Everything()
public StrongNameMembershipCondition FullTrustMembership(string name, Key key)
private NamedPermissionSet BuildFullTrust()
private NamedPermissionSet BuildLocalIntranet()
private NamedPermissionSet BuildInternet()
private NamedPermissionSet BuildSkipVerification()
private NamedPermissionSet BuildExecution()
private NamedPermissionSet BuildNothing()
private NamedPermissionSet BuildEverything()
private SecurityElement PrintingPermission(string level)
}
public System.Security.Policy.Evidence : object {
private bool _locked
private ArrayList hostEvidenceList
private ArrayList assemblyEvidenceList
private int _hashCode
public int Count
public bool IsReadOnly
public bool IsSynchronized
public bool Locked
public object SyncRoot
internal ArrayList HostEvidenceList
internal ArrayList AssemblyEvidenceList
public void .ctor(Evidence evidence)
public void .ctor(Object[] hostEvidence, Object[] assemblyEvidence)
public int get_Count()
public bool get_IsReadOnly()
public bool get_IsSynchronized()
public bool get_Locked()
public void set_Locked(bool value)
public object get_SyncRoot()
internal ArrayList get_HostEvidenceList()
internal ArrayList get_AssemblyEvidenceList()
public void AddAssembly(object id)
public void AddHost(object id)
public void Clear()
public void CopyTo(Array array, int index)
public bool Equals(object obj)
public IEnumerator GetEnumerator()
public IEnumerator GetAssemblyEnumerator()
public int GetHashCode()
public IEnumerator GetHostEnumerator()
public void Merge(Evidence evidence)
public void RemoveType(Type t)
private bool IsAuthenticodePresent(Assembly a)
internal Evidence GetDefaultHostEvidence(Assembly a)
}
public System.Security.Policy.FileCodeGroup : CodeGroup {
private FileIOPermissionAccess m_access
public string MergeLogic
public string AttributeString
public string PermissionSetName
public void .ctor(IMembershipCondition membershipCondition, FileIOPermissionAccess access)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
public string get_MergeLogic()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public string get_AttributeString()
public string get_PermissionSetName()
public bool Equals(object o)
public int GetHashCode()
protected void ParseXml(SecurityElement e, PolicyLevel level)
protected void CreateXml(SecurityElement element, PolicyLevel level)
}
public System.Security.Policy.FirstMatchCodeGroup : CodeGroup {
public string MergeLogic
public void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public string get_MergeLogic()
public CodeGroup Copy()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
private FirstMatchCodeGroup CopyNoChildren()
}
public System.Security.Policy.GacInstalled : object {
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
}
public System.Security.Policy.GacMembershipCondition : object {
private int version
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.Hash : object {
private Assembly assembly
private Byte[] data
internal Byte[] _md5
internal Byte[] _sha1
public Byte[] MD5
public Byte[] SHA1
public void .ctor(Assembly assembly)
internal void .ctor(SerializationInfo info, StreamingContext context)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public Byte[] get_MD5()
public Byte[] get_SHA1()
public Byte[] GenerateHash(HashAlgorithm hashAlg)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
private Byte[] GetData()
public Hash CreateMD5(Byte[] md5)
public Hash CreateSHA1(Byte[] sha1)
}
public System.Security.Policy.HashMembershipCondition : object {
private int version
private HashAlgorithm hash_algorithm
private Byte[] hash_value
public HashAlgorithm HashAlgorithm
public Byte[] HashValue
public void .ctor(HashAlgorithm hashAlg, Byte[] value)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public HashAlgorithm get_HashAlgorithm()
public void set_HashAlgorithm(HashAlgorithm value)
public Byte[] get_HashValue()
public void set_HashValue(Byte[] value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
private bool Compare(Byte[] expected, Byte[] actual)
}
public System.Security.Policy.IApplicationTrustManager {
public ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
}
internal System.Security.Policy.IBuiltInEvidence {
public int GetRequiredSize(bool verbose)
public int InitFromBuffer(Char[] buffer, int position)
public int OutputToBuffer(Char[] buffer, int position, bool verbose)
}
public System.Security.Policy.IIdentityPermissionFactory {
public IPermission CreateIdentityPermission(Evidence evidence)
}
public System.Security.Policy.IMembershipCondition {
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object obj)
public string ToString()
}
internal System.Security.Policy.MembershipConditionHelper : object {
private string XmlTag
internal int CheckSecurityElement(SecurityElement se, string parameterName, int minimumVersion, int maximumVersion)
internal SecurityElement Element(Type type, int version)
}
internal System.Security.Policy.MonoTrustManager : object {
private string tag
public ApplicationTrust DetermineApplicationTrust(ActivationContext activationContext, TrustManagerContext context)
public void FromXml(SecurityElement e)
public SecurityElement ToXml()
}
public System.Security.Policy.NetCodeGroup : CodeGroup {
public string AbsentOriginScheme
public string AnyOtherOriginScheme
private Hashtable _rules
private int _hashcode
public string AttributeString
public string MergeLogic
public string PermissionSetName
public void .ctor(IMembershipCondition membershipCondition)
internal void .ctor(SecurityElement e, PolicyLevel level)
public string get_AttributeString()
public string get_MergeLogic()
public string get_PermissionSetName()
public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess)
public CodeGroup Copy()
private bool Equals(CodeConnectAccess[] rules1, CodeConnectAccess[] rules2)
public bool Equals(object o)
public DictionaryEntry[] GetConnectAccessRules()
public int GetHashCode()
public PolicyStatement Resolve(Evidence evidence)
public void ResetConnectAccess()
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
protected void CreateXml(SecurityElement element, PolicyLevel level)
protected void ParseXml(SecurityElement e, PolicyLevel level)
}
public System.Security.Policy.PermissionRequestEvidence : object {
private PermissionSet requested
private PermissionSet optional
private PermissionSet denied
public PermissionSet DeniedPermissions
public PermissionSet OptionalPermissions
public PermissionSet RequestedPermissions
public void .ctor(PermissionSet request, PermissionSet optional, PermissionSet denied)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public PermissionSet get_DeniedPermissions()
public PermissionSet get_OptionalPermissions()
public PermissionSet get_RequestedPermissions()
public PermissionRequestEvidence Copy()
public string ToString()
}
public System.Security.Policy.PolicyException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception exception)
}
public System.Security.Policy.PolicyLevel : object {
private string label
private CodeGroup root_code_group
private ArrayList full_trust_assemblies
private ArrayList named_permission_sets
private string _location
private PolicyLevelType _type
private Hashtable fullNames
private SecurityElement xml
public IList FullTrustAssemblies
public string Label
public IList NamedPermissionSets
public CodeGroup RootCodeGroup
public string StoreLocation
public PolicyLevelType Type
internal void .ctor(string label, PolicyLevelType type)
internal void LoadFromFile(string filename)
internal void LoadFromString(string xml)
private SecurityElement FromString(string xml)
public IList get_FullTrustAssemblies()
public string get_Label()
public IList get_NamedPermissionSets()
public CodeGroup get_RootCodeGroup()
public void set_RootCodeGroup(CodeGroup value)
public string get_StoreLocation()
public PolicyLevelType get_Type()
public void AddFullTrustAssembly(StrongName sn)
public void AddFullTrustAssembly(StrongNameMembershipCondition snMC)
public void AddNamedPermissionSet(NamedPermissionSet permSet)
public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet)
public PolicyLevel CreateAppDomainLevel()
public void FromXml(SecurityElement e)
public NamedPermissionSet GetNamedPermissionSet(string name)
public void Recover()
public void RemoveFullTrustAssembly(StrongName sn)
public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC)
public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet)
public NamedPermissionSet RemoveNamedPermissionSet(string name)
public void Reset()
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public SecurityElement ToXml()
internal void Save()
internal void CreateDefaultLevel(PolicyLevelType type)
internal void CreateDefaultFullTrustAssemblies()
internal void CreateDefaultNamedPermissionSets()
internal string ResolveClassName(string className)
internal bool IsFullTrustAssembly(Assembly a)
}
public System.Security.Policy.PolicyStatement : object {
private PermissionSet perms
private PolicyStatementAttribute attrs
public PermissionSet PermissionSet
public PolicyStatementAttribute Attributes
public string AttributeString
public void .ctor(PermissionSet permSet)
public void .ctor(PermissionSet permSet, PolicyStatementAttribute attributes)
public PermissionSet get_PermissionSet()
public void set_PermissionSet(PermissionSet value)
public PolicyStatementAttribute get_Attributes()
public void set_Attributes(PolicyStatementAttribute value)
public string get_AttributeString()
public PolicyStatement Copy()
public void FromXml(SecurityElement et)
public void FromXml(SecurityElement et, PolicyLevel level)
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
public bool Equals(object obj)
public int GetHashCode()
internal PolicyStatement Empty()
}
public System.Security.Policy.PolicyStatementAttribute : Enum {
public int value__
public PolicyStatementAttribute Nothing
public PolicyStatementAttribute Exclusive
public PolicyStatementAttribute LevelFinal
public PolicyStatementAttribute All
}
public System.Security.Policy.Publisher : object {
private X509Certificate m_cert
public X509Certificate Certificate
public void .ctor(X509Certificate cert)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public X509Certificate get_Certificate()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
}
public System.Security.Policy.PublisherMembershipCondition : object {
private int version
private X509Certificate x509
public X509Certificate Certificate
public void .ctor(X509Certificate certificate)
public X509Certificate get_Certificate()
public void set_Certificate(X509Certificate value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.Site : object {
internal string origin_site
public string Name
public void .ctor(string name)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public Site CreateFromUrl(string url)
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
public string get_Name()
internal bool IsValid(string name)
internal string UrlToSite(string url)
}
public System.Security.Policy.SiteMembershipCondition : object {
private int version
private string _site
public string Site
public void .ctor(string site)
public string get_Site()
public void set_Site(string value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.StrongName : object {
private StrongNamePublicKeyBlob publickey
private string name
private Version version
public string Name
public StrongNamePublicKeyBlob PublicKey
public Version Version
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public string get_Name()
public StrongNamePublicKeyBlob get_PublicKey()
public Version get_Version()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
}
public System.Security.Policy.StrongNameMembershipCondition : object {
private int version
private StrongNamePublicKeyBlob blob
private string name
private Version assemblyVersion
public string Name
public Version Version
public StrongNamePublicKeyBlob PublicKey
public void .ctor(StrongNamePublicKeyBlob blob, string name, Version version)
internal void .ctor(SecurityElement e)
public string get_Name()
public void set_Name(string value)
public Version get_Version()
public void set_Version(Version value)
public StrongNamePublicKeyBlob get_PublicKey()
public void set_PublicKey(StrongNamePublicKeyBlob value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public int GetHashCode()
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.Policy.TrustManagerContext : object {
private bool _ignorePersistedDecision
private bool _noPrompt
private bool _keepAlive
private bool _persist
private ApplicationIdentity _previousId
private TrustManagerUIContext _ui
public bool IgnorePersistedDecision
public bool KeepAlive
public bool NoPrompt
public bool Persist
public ApplicationIdentity PreviousApplicationIdentity
public TrustManagerUIContext UIContext
public void .ctor(TrustManagerUIContext uiContext)
public bool get_IgnorePersistedDecision()
public void set_IgnorePersistedDecision(bool value)
public bool get_KeepAlive()
public void set_KeepAlive(bool value)
public bool get_NoPrompt()
public void set_NoPrompt(bool value)
public bool get_Persist()
public void set_Persist(bool value)
public ApplicationIdentity get_PreviousApplicationIdentity()
public void set_PreviousApplicationIdentity(ApplicationIdentity value)
public TrustManagerUIContext get_UIContext()
public void set_UIContext(TrustManagerUIContext value)
}
public System.Security.Policy.TrustManagerUIContext : Enum {
public int value__
public TrustManagerUIContext Install
public TrustManagerUIContext Upgrade
public TrustManagerUIContext Run
}
public System.Security.Policy.UnionCodeGroup : CodeGroup {
public string MergeLogic
public void .ctor(IMembershipCondition membershipCondition, PolicyStatement policy)
internal void .ctor(SecurityElement e, PolicyLevel level)
public CodeGroup Copy()
internal CodeGroup Copy(bool childs)
public PolicyStatement Resolve(Evidence evidence)
public CodeGroup ResolveMatchingCodeGroups(Evidence evidence)
public string get_MergeLogic()
}
public System.Security.Policy.Url : object {
private string origin_url
public string Value
public void .ctor(string name)
internal void .ctor(string name, bool validated)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
public string get_Value()
private string Prepare(string url)
}
public System.Security.Policy.UrlMembershipCondition : object {
private int version
private Url url
private string userUrl
public string Url
public void .ctor(string url)
internal void .ctor(Url url, string userUrl)
public string get_Url()
public void set_Url(string value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
internal void CheckUrl(string url)
}
public System.Security.Policy.Zone : object {
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(SecurityZone zone)
private int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose)
private int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(Char[] buffer, int position)
private int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(Char[] buffer, int position, bool verbose)
public SecurityZone get_SecurityZone()
public object Copy()
public IPermission CreateIdentityPermission(Evidence evidence)
public Zone CreateFromUrl(string url)
public bool Equals(object o)
public int GetHashCode()
public string ToString()
}
public System.Security.Policy.ZoneMembershipCondition : object {
private int version
private SecurityZone zone
public SecurityZone SecurityZone
public void .ctor(SecurityZone zone)
public SecurityZone get_SecurityZone()
public void set_SecurityZone(SecurityZone value)
public bool Check(Evidence evidence)
public IMembershipCondition Copy()
public bool Equals(object o)
public void FromXml(SecurityElement e)
public void FromXml(SecurityElement e, PolicyLevel level)
public int GetHashCode()
public string ToString()
public SecurityElement ToXml()
public SecurityElement ToXml(PolicyLevel level)
}
public System.Security.PolicyLevelType : Enum {
public int value__
public PolicyLevelType User
public PolicyLevelType Machine
public PolicyLevelType Enterprise
public PolicyLevelType AppDomain
}
public System.Security.Principal.GenericIdentity : object {
private string m_name
private string m_type
public string AuthenticationType
public string Name
public bool IsAuthenticated
public void .ctor(string name, string type)
public void .ctor(string name)
public string get_AuthenticationType()
public string get_Name()
public bool get_IsAuthenticated()
}
public System.Security.Principal.GenericPrincipal : object {
private IIdentity m_identity
private String[] m_roles
public IIdentity Identity
public void .ctor(IIdentity identity, String[] roles)
public IIdentity get_Identity()
public bool IsInRole(string role)
}
public System.Security.Principal.IdentityNotMappedException : SystemException {
private IdentityReferenceCollection _coll
public IdentityReferenceCollection UnmappedIdentities
public void .ctor(string message)
public void .ctor(string message, Exception inner)
public IdentityReferenceCollection get_UnmappedIdentities()
public void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
}
public System.Security.Principal.IdentityReference : object {
public string Value
public string get_Value()
public bool Equals(object o)
public int GetHashCode()
public bool IsValidTargetType(Type targetType)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(IdentityReference left, IdentityReference right)
public bool op_Inequality(IdentityReference left, IdentityReference right)
}
public System.Security.Principal.IdentityReferenceCollection : object {
private ArrayList _list
public int Count
public bool IsReadOnly
public IdentityReference Item
public void .ctor(int capacity)
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public int get_Count()
public bool get_IsReadOnly()
public IdentityReference get_Item(int index)
public void set_Item(int index, IdentityReference value)
public void Add(IdentityReference identity)
public void Clear()
public bool Contains(IdentityReference identity)
public void CopyTo(IdentityReference[] array, int offset)
public IEnumerator`1<IdentityReference> GetEnumerator()
public bool Remove(IdentityReference identity)
public IdentityReferenceCollection Translate(Type targetType)
public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess)
}
public System.Security.Principal.IIdentity {
public string AuthenticationType
public bool IsAuthenticated
public string Name
public string get_AuthenticationType()
public bool get_IsAuthenticated()
public string get_Name()
}
public System.Security.Principal.IPrincipal {
public IIdentity Identity
public IIdentity get_Identity()
public bool IsInRole(string role)
}
public System.Security.Principal.NTAccount : IdentityReference {
private string _value
public string Value
public void .ctor(string name)
public void .ctor(string domainName, string accountName)
public string get_Value()
public bool Equals(object o)
public int GetHashCode()
public bool IsValidTargetType(Type targetType)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(NTAccount left, NTAccount right)
public bool op_Inequality(NTAccount left, NTAccount right)
}
public System.Security.Principal.PrincipalPolicy : Enum {
public int value__
public PrincipalPolicy UnauthenticatedPrincipal
public PrincipalPolicy NoPrincipal
public PrincipalPolicy WindowsPrincipal
}
public System.Security.Principal.SecurityIdentifier : IdentityReference {
private string _value
public int MaxBinaryLength
public int MinBinaryLength
public SecurityIdentifier AccountDomainSid
public int BinaryLength
public string Value
public void .ctor(string sddlForm)
public void .ctor(Byte[] binaryForm, int offset)
public void .ctor(IntPtr binaryForm)
public void .ctor(WellKnownSidType sidType, SecurityIdentifier domainSid)
public SecurityIdentifier get_AccountDomainSid()
public int get_BinaryLength()
public string get_Value()
public int CompareTo(SecurityIdentifier sid)
public bool Equals(object o)
public bool Equals(SecurityIdentifier sid)
public void GetBinaryForm(Byte[] binaryForm, int offset)
public int GetHashCode()
public bool IsAccountSid()
public bool IsEqualDomainSid(SecurityIdentifier sid)
public bool IsValidTargetType(Type targetType)
public bool IsWellKnown(WellKnownSidType type)
public string ToString()
public IdentityReference Translate(Type targetType)
public bool op_Equality(SecurityIdentifier left, SecurityIdentifier right)
public bool op_Inequality(SecurityIdentifier left, SecurityIdentifier right)
}
public System.Security.Principal.TokenAccessLevels : Enum {
public int value__
public TokenAccessLevels AssignPrimary
public TokenAccessLevels Duplicate
public TokenAccessLevels Impersonate
public TokenAccessLevels Query
public TokenAccessLevels QuerySource
public TokenAccessLevels AdjustPrivileges
public TokenAccessLevels AdjustGroups
public TokenAccessLevels AdjustDefault
public TokenAccessLevels AdjustSessionId
public TokenAccessLevels Read
public TokenAccessLevels Write
public TokenAccessLevels AllAccess
public TokenAccessLevels MaximumAllowed
}
public System.Security.Principal.TokenImpersonationLevel : Enum {
public int value__
public TokenImpersonationLevel Anonymous
public TokenImpersonationLevel Delegation
public TokenImpersonationLevel Identification
public TokenImpersonationLevel Impersonation
public TokenImpersonationLevel None
}
public System.Security.Principal.WellKnownSidType : Enum {
public int value__
public WellKnownSidType NullSid
public WellKnownSidType WorldSid
public WellKnownSidType LocalSid
public WellKnownSidType CreatorOwnerSid
public WellKnownSidType CreatorGroupSid
public WellKnownSidType CreatorOwnerServerSid
public WellKnownSidType CreatorGroupServerSid
public WellKnownSidType NTAuthoritySid
public WellKnownSidType DialupSid
public WellKnownSidType NetworkSid
public WellKnownSidType BatchSid
public WellKnownSidType InteractiveSid
public WellKnownSidType ServiceSid
public WellKnownSidType AnonymousSid
public WellKnownSidType ProxySid
public WellKnownSidType EnterpriseControllersSid
public WellKnownSidType SelfSid
public WellKnownSidType AuthenticatedUserSid
public WellKnownSidType RestrictedCodeSid
public WellKnownSidType TerminalServerSid
public WellKnownSidType RemoteLogonIdSid
public WellKnownSidType LogonIdsSid
public WellKnownSidType LocalSystemSid
public WellKnownSidType LocalServiceSid
public WellKnownSidType NetworkServiceSid
public WellKnownSidType BuiltinDomainSid
public WellKnownSidType BuiltinAdministratorsSid
public WellKnownSidType BuiltinUsersSid
public WellKnownSidType BuiltinGuestsSid
public WellKnownSidType BuiltinPowerUsersSid
public WellKnownSidType BuiltinAccountOperatorsSid
public WellKnownSidType BuiltinSystemOperatorsSid
public WellKnownSidType BuiltinPrintOperatorsSid
public WellKnownSidType BuiltinBackupOperatorsSid
public WellKnownSidType BuiltinReplicatorSid
public WellKnownSidType BuiltinPreWindows2000CompatibleAccessSid
public WellKnownSidType BuiltinRemoteDesktopUsersSid
public WellKnownSidType BuiltinNetworkConfigurationOperatorsSid
public WellKnownSidType AccountAdministratorSid
public WellKnownSidType AccountGuestSid
public WellKnownSidType AccountKrbtgtSid
public WellKnownSidType AccountDomainAdminsSid
public WellKnownSidType AccountDomainUsersSid
public WellKnownSidType AccountDomainGuestsSid
public WellKnownSidType AccountComputersSid
public WellKnownSidType AccountControllersSid
public WellKnownSidType AccountCertAdminsSid
public WellKnownSidType AccountSchemaAdminsSid
public WellKnownSidType AccountEnterpriseAdminsSid
public WellKnownSidType AccountPolicyAdminsSid
public WellKnownSidType AccountRasAndIasServersSid
public WellKnownSidType NtlmAuthenticationSid
public WellKnownSidType DigestAuthenticationSid
public WellKnownSidType SChannelAuthenticationSid
public WellKnownSidType ThisOrganizationSid
public WellKnownSidType OtherOrganizationSid
public WellKnownSidType BuiltinIncomingForestTrustBuildersSid
public WellKnownSidType BuiltinPerformanceMonitoringUsersSid
public WellKnownSidType BuiltinPerformanceLoggingUsersSid
public WellKnownSidType BuiltinAuthorizationAccessSid
public WellKnownSidType WinBuiltinTerminalServerLicenseServersSid
public WellKnownSidType MaxDefined
}
public System.Security.Principal.WindowsAccountType : Enum {
public int value__
public WindowsAccountType Normal
public WindowsAccountType Guest
public WindowsAccountType System
public WindowsAccountType Anonymous
}
public System.Security.Principal.WindowsBuiltInRole : Enum {
public int value__
public WindowsBuiltInRole Administrator
public WindowsBuiltInRole User
public WindowsBuiltInRole Guest
public WindowsBuiltInRole PowerUser
public WindowsBuiltInRole AccountOperator
public WindowsBuiltInRole SystemOperator
public WindowsBuiltInRole PrintOperator
public WindowsBuiltInRole BackupOperator
public WindowsBuiltInRole Replicator
}
public System.Security.Principal.WindowsIdentity : object {
private IntPtr _token
private string _type
private WindowsAccountType _account
private bool _authenticated
private string _name
private SerializationInfo _info
private IntPtr invalidWindows
public string AuthenticationType
public bool IsAnonymous
public bool IsAuthenticated
public bool IsGuest
public bool IsSystem
public string Name
public IntPtr Token
public IdentityReferenceCollection Groups
public TokenImpersonationLevel ImpersonationLevel
public SecurityIdentifier Owner
public SecurityIdentifier User
private bool IsPosix
public void .ctor(IntPtr userToken)
public void .ctor(IntPtr userToken, string type)
public void .ctor(IntPtr userToken, string type, WindowsAccountType acctType)
public void .ctor(IntPtr userToken, string type, WindowsAccountType acctType, bool isAuthenticated)
public void .ctor(string sUserPrincipalName)
public void .ctor(string sUserPrincipalName, string type)
public void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public void Dispose()
protected void Dispose(bool disposing)
public WindowsIdentity GetAnonymous()
public WindowsIdentity GetCurrent()
public WindowsIdentity GetCurrent(bool ifImpersonating)
public WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess)
public WindowsImpersonationContext Impersonate()
public WindowsImpersonationContext Impersonate(IntPtr userToken)
public string get_AuthenticationType()
public bool get_IsAnonymous()
public bool get_IsAuthenticated()
public bool get_IsGuest()
public bool get_IsSystem()
public string get_Name()
public IntPtr get_Token()
public IdentityReferenceCollection get_Groups()
public TokenImpersonationLevel get_ImpersonationLevel()
public SecurityIdentifier get_Owner()
public SecurityIdentifier get_User()
private bool get_IsPosix()
private void SetToken(IntPtr token)
internal String[] _GetRoles(IntPtr token)
internal IntPtr GetCurrentToken()
private string GetTokenName(IntPtr token)
private IntPtr GetUserToken(string username)
}
public System.Security.Principal.WindowsImpersonationContext : object {
private IntPtr _token
private bool undo
internal void .ctor(IntPtr token)
public void Dispose()
protected void Dispose(bool disposing)
public void Undo()
private bool CloseToken(IntPtr token)
private IntPtr DuplicateToken(IntPtr token)
private bool SetCurrentToken(IntPtr token)
private bool RevertToSelf()
}
public System.Security.Principal.WindowsPrincipal : object {
private WindowsIdentity _identity
private String[] m_roles
public IIdentity Identity
private bool IsPosix
private IntPtr Token
public void .ctor(WindowsIdentity ntIdentity)
public IIdentity get_Identity()
public bool IsInRole(int rid)
public bool IsInRole(string role)
public bool IsInRole(WindowsBuiltInRole role)
public bool IsInRole(SecurityIdentifier sid)
private bool get_IsPosix()
private IntPtr get_Token()
private bool IsMemberOfGroupId(IntPtr user, IntPtr group)
private bool IsMemberOfGroupName(IntPtr user, string group)
}
internal System.Security.RuntimeDeclSecurityActions : ValueType {
public RuntimeDeclSecurityEntry cas
public RuntimeDeclSecurityEntry noncas
public RuntimeDeclSecurityEntry choice
}
internal System.Security.RuntimeDeclSecurityEntry : ValueType {
public IntPtr blob
public int size
public int index
}
internal System.Security.RuntimeSecurityFrame : object {
public AppDomain domain
public MethodInfo method
public RuntimeDeclSecurityEntry assert
public RuntimeDeclSecurityEntry deny
public RuntimeDeclSecurityEntry permitonly
}
public System.Security.SecureString : CriticalFinalizerObject {
private int BlockSize
private int MaxSize
private int length
private bool disposed
private bool read_only
private Byte[] data
public int Length
public void .ctor(Char* value, int length)
public int get_Length()
public void AppendChar(char c)
public void Clear()
public SecureString Copy()
public void Dispose()
public void InsertAt(int index, char c)
public bool IsReadOnly()
public void MakeReadOnly()
public void RemoveAt(int index)
public void SetAt(int index, char c)
private void Encrypt()
private void Decrypt()
private void Alloc(int length, bool realloc)
internal Byte[] GetBuffer()
}
public System.Security.SecurityContext : object {
private bool _capture
private IntPtr _winid
private CompressedStack _stack
private bool _suppressFlowWindowsIdentity
private bool _suppressFlow
internal bool FlowSuppressed
internal bool WindowsIdentityFlowSuppressed
internal CompressedStack CompressedStack
internal IntPtr IdentityToken
internal void .ctor(SecurityContext sc)
public SecurityContext CreateCopy()
public SecurityContext Capture()
internal bool get_FlowSuppressed()
internal void set_FlowSuppressed(bool value)
internal bool get_WindowsIdentityFlowSuppressed()
internal void set_WindowsIdentityFlowSuppressed(bool value)
internal CompressedStack get_CompressedStack()
internal void set_CompressedStack(CompressedStack value)
internal IntPtr get_IdentityToken()
internal void set_IdentityToken(IntPtr value)
public bool IsFlowSuppressed()
public bool IsWindowsIdentityFlowSuppressed()
public void RestoreFlow()
public void Run(SecurityContext securityContext, ContextCallback callback, object state)
public AsyncFlowControl SuppressFlow()
public AsyncFlowControl SuppressFlowWindowsIdentity()
}
public System.Security.SecurityCriticalAttribute : Attribute {
private SecurityCriticalScope _scope
public SecurityCriticalScope Scope
public void .ctor(SecurityCriticalScope scope)
public SecurityCriticalScope get_Scope()
}
public System.Security.SecurityCriticalScope : Enum {
public int value__
public SecurityCriticalScope Explicit
public SecurityCriticalScope Everything
}
public System.Security.SecurityElement : object {
private string text
private string tag
private ArrayList attributes
private ArrayList children
private Char[] invalid_tag_chars
private Char[] invalid_text_chars
private Char[] invalid_attr_name_chars
private Char[] invalid_attr_value_chars
private Char[] invalid_chars
public Hashtable Attributes
public ArrayList Children
public string Tag
public string Text
public void .ctor(string tag)
public void .ctor(string tag, string text)
internal void .ctor(SecurityElement se)
public Hashtable get_Attributes()
public void set_Attributes(Hashtable value)
public ArrayList get_Children()
public void set_Children(ArrayList value)
public string get_Tag()
public void set_Tag(string value)
public string get_Text()
public void set_Text(string value)
public void AddAttribute(string name, string value)
public void AddChild(SecurityElement child)
public string Attribute(string name)
public SecurityElement Copy()
public bool Equal(SecurityElement other)
public string Escape(string str)
private string Unescape(string str)
public SecurityElement FromString(string xml)
public bool IsValidAttributeName(string name)
public bool IsValidAttributeValue(string value)
public bool IsValidTag(string tag)
public bool IsValidText(string text)
public SecurityElement SearchForChildByTag(string tag)
public string SearchForTextOfTag(string tag)
public string ToString()
private void ToXml(StringBuilder& s, int level)
internal SecurityAttribute GetAttribute(string name)
}
public System.Security.SecurityException : SystemException {
private string permissionState
private Type permissionType
private string _granted
private string _refused
private object _demanded
private IPermission _firstperm
private MethodInfo _method
private Evidence _evidence
private SecurityAction _action
private object _denyset
private object _permitset
private AssemblyName _assembly
private string _url
private SecurityZone _zone
public SecurityAction Action
public object DenySetInstance
public AssemblyName FailedAssemblyInfo
public MethodInfo Method
public object PermitOnlySetInstance
public string Url
public SecurityZone Zone
public object Demanded
public IPermission FirstPermissionThatFailed
public string PermissionState
public Type PermissionType
public string GrantedSet
public string RefusedSet
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, Type type)
public void .ctor(string message, Type type, string state)
internal void .ctor(string message, PermissionSet granted, PermissionSet refused)
public void .ctor(string message, object deny, object permitOnly, MethodInfo method, object demanded, IPermission permThatFailed)
public void .ctor(string message, AssemblyName assemblyName, PermissionSet grant, PermissionSet refused, MethodInfo method, SecurityAction action, object demanded, IPermission permThatFailed, Evidence evidence)
public SecurityAction get_Action()
public void set_Action(SecurityAction value)
public object get_DenySetInstance()
public void set_DenySetInstance(object value)
public AssemblyName get_FailedAssemblyInfo()
public void set_FailedAssemblyInfo(AssemblyName value)
public MethodInfo get_Method()
public void set_Method(MethodInfo value)
public object get_PermitOnlySetInstance()
public void set_PermitOnlySetInstance(object value)
public string get_Url()
public void set_Url(string value)
public SecurityZone get_Zone()
public void set_Zone(SecurityZone value)
public object get_Demanded()
public void set_Demanded(object value)
public IPermission get_FirstPermissionThatFailed()
public void set_FirstPermissionThatFailed(IPermission value)
public string get_PermissionState()
public void set_PermissionState(string value)
public Type get_PermissionType()
public void set_PermissionType(Type value)
public string get_GrantedSet()
public void set_GrantedSet(string value)
public string get_RefusedSet()
public void set_RefusedSet(string value)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public string ToString()
}
internal System.Security.SecurityFrame : ValueType {
private AppDomain _domain
private MethodInfo _method
private PermissionSet _assert
private PermissionSet _deny
private PermissionSet _permitonly
public Assembly Assembly
public AppDomain Domain
public MethodInfo Method
public PermissionSet Assert
public PermissionSet Deny
public PermissionSet PermitOnly
public bool HasStackModifiers
internal void .ctor(RuntimeSecurityFrame frame)
internal void .ctor(int skip)
private RuntimeSecurityFrame _GetSecurityFrame(int skip)
private Array _GetSecurityStack(int skip)
internal void InitFromRuntimeFrame(RuntimeSecurityFrame frame)
public Assembly get_Assembly()
public AppDomain get_Domain()
public MethodInfo get_Method()
public PermissionSet get_Assert()
public PermissionSet get_Deny()
public PermissionSet get_PermitOnly()
public bool get_HasStackModifiers()
public bool Equals(SecurityFrame sf)
public string ToString()
public ArrayList GetStack(int skipFrames)
}
public System.Security.SecurityManager : object {
private object _lockObject
private ArrayList _hierarchy
private IPermission _unmanagedCode
private Hashtable _declsecCache
private PolicyLevel _level
private SecurityPermission _execution
public bool CheckExecutionRights
public bool SecurityEnabled
private IEnumerator Hierarchy
internal PolicyLevel ResolvingPolicyLevel
private IPermission UnmanagedCode
public bool get_CheckExecutionRights()
public void set_CheckExecutionRights(bool value)
public bool get_SecurityEnabled()
public void set_SecurityEnabled(bool value)
public void GetZoneAndOrigin(ArrayList& zone, ArrayList& origin)
public bool IsGranted(IPermission perm)
internal bool IsGranted(Assembly a, IPermission perm)
internal IPermission CheckPermissionSet(Assembly a, PermissionSet ps, bool noncas)
internal IPermission CheckPermissionSet(AppDomain ad, PermissionSet ps)
public PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type)
public PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type)
public IEnumerator PolicyHierarchy()
public PermissionSet ResolvePolicy(Evidence evidence)
public PermissionSet ResolvePolicy(Evidence[] evidences)
public PermissionSet ResolveSystemPolicy(Evidence evidence)
public PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, PermissionSet& denied)
public IEnumerator ResolvePolicyGroups(Evidence evidence)
public void SavePolicy()
public void SavePolicyLevel(PolicyLevel level)
private IEnumerator get_Hierarchy()
private void InitializePolicyHierarchy()
internal bool ResolvePolicyLevel(PermissionSet& ps, PolicyLevel pl, Evidence evidence)
internal void ResolveIdentityPermissions(PermissionSet ps, Evidence evidence)
internal PolicyLevel get_ResolvingPolicyLevel()
internal void set_ResolvingPolicyLevel(PolicyLevel value)
internal PermissionSet Decode(IntPtr permissions, int length)
internal PermissionSet Decode(Byte[] encodedPermissions)
private IPermission get_UnmanagedCode()
private bool GetLinkDemandSecurity(MethodBase method, RuntimeDeclSecurityActions* cdecl, RuntimeDeclSecurityActions* mdecl)
internal void ReflectedLinkDemandInvoke(MethodBase mb)
internal bool ReflectedLinkDemandQuery(MethodBase mb)
private bool LinkDemand(Assembly a, RuntimeDeclSecurityActions* klass, RuntimeDeclSecurityActions* method)
private bool LinkDemandFullTrust(Assembly a)
private bool LinkDemandUnmanaged(Assembly a)
private void LinkDemandSecurityException(int securityViolation, IntPtr methodHandle)
private void InheritanceDemandSecurityException(int securityViolation, Assembly a, Type t, MethodInfo method)
private void ThrowException(Exception ex)
private bool InheritanceDemand(AppDomain ad, Assembly a, RuntimeDeclSecurityActions* actions)
private void DemandUnmanaged()
private void InternalDemand(IntPtr permissions, int length)
private void InternalDemandChoice(IntPtr permissions, int length)
}
public System.Security.SecurityState : object {
public void EnsureState()
public bool IsStateAvailable()
}
public System.Security.SecurityZone : Enum {
public int value__
public SecurityZone MyComputer
public SecurityZone Intranet
public SecurityZone Trusted
public SecurityZone Internet
public SecurityZone Untrusted
public SecurityZone NoZone
}
public System.Security.VerificationException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Security.XmlSyntaxException : SystemException {
public void .ctor(int lineNumber)
public void .ctor(int lineNumber, string message)
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Single : ValueType {
public float Epsilon
public float MaxValue
public float MinValue
public float NaN
public float PositiveInfinity
public float NegativeInfinity
private double MaxValueEpsilon
internal float m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int CompareTo(float value)
public bool Equals(float obj)
public int GetHashCode()
public bool IsInfinity(float f)
public bool IsNaN(float f)
public bool IsNegativeInfinity(float f)
public bool IsPositiveInfinity(float f)
public float Parse(string s)
public float Parse(string s, IFormatProvider provider)
public float Parse(string s, NumberStyles style)
public float Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result)
public bool TryParse(string s, Single& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
internal System.SmallRect : ValueType {
public short Left
public short Top
public short Right
public short Bottom
public void .ctor(int left, int top, int right, int bottom)
}
public System.StackOverflowException : SystemException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
}
public System.String : object {
private int length
private char start_char
public string Empty
private Char[] WhiteChars
public char Chars
public int Length
public void .ctor(Char* value)
public void .ctor(Char* value, int startIndex, int length)
public void .ctor(SByte* value)
public void .ctor(SByte* value, int startIndex, int length)
public void .ctor(SByte* value, int startIndex, int length, Encoding enc)
public void .ctor(Char[] value, int startIndex, int length)
public void .ctor(Char[] value)
public void .ctor(char c, int count)
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
private IEnumerator`1<char> System.Collections.Generic.IEnumerable<char>.GetEnumerator()
private IEnumerator System.Collections.IEnumerable.GetEnumerator()
public bool Equals(string a, string b)
public bool Equals(object obj)
public bool Equals(string value)
public char get_Chars(int index)
public object Clone()
public TypeCode GetTypeCode()
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count)
public Char[] ToCharArray()
public Char[] ToCharArray(int startIndex, int length)
public String[] Split(Char[] separator)
public String[] Split(Char[] separator, int count)
public String[] Split(Char[] separator, int count, StringSplitOptions options)
public String[] Split(String[] separator, int count, StringSplitOptions options)
public String[] Split(Char[] separator, StringSplitOptions options)
public String[] Split(String[] separator, StringSplitOptions options)
public string Substring(int startIndex)
public string Substring(int startIndex, int length)
internal string SubstringUnchecked(int startIndex, int length)
public string Trim()
public string Trim(Char[] trimChars)
public string TrimStart(Char[] trimChars)
public string TrimEnd(Char[] trimChars)
private int FindNotWhiteSpace(int pos, int target, int change)
private int FindNotInTable(int pos, int target, int change, Char[] table)
public int Compare(string strA, string strB)
public int Compare(string strA, string strB, bool ignoreCase)
public int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture)
public int Compare(string strA, int indexA, string strB, int indexB, int length)
public int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase)
public int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture)
public int Compare(string strA, string strB, StringComparison comparisonType)
public int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType)
public bool Equals(string a, string b, StringComparison comparisonType)
public bool Equals(string value, StringComparison comparisonType)
public int Compare(string strA, string strB, CultureInfo culture, CompareOptions options)
public int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options)
public int CompareTo(object value)
public int CompareTo(string strB)
public int CompareOrdinal(string strA, string strB)
public int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length)
internal int CompareOrdinalCaseInsensitive(string strA, int indexA, string strB, int indexB, int length)
internal int CompareOrdinalUnchecked(string strA, int indexA, int lenA, string strB, int indexB, int lenB)
internal int CompareOrdinalCaseInsensitiveUnchecked(string strA, int indexA, int lenA, string strB, int indexB, int lenB)
public bool EndsWith(string value)
public bool EndsWith(string value, bool ignoreCase, CultureInfo culture)
public int IndexOfAny(Char[] anyOf)
public int IndexOfAny(Char[] anyOf, int startIndex)
public int IndexOfAny(Char[] anyOf, int startIndex, int count)
private int IndexOfAnyUnchecked(Char[] anyOf, int startIndex, int count)
public int IndexOf(string value, StringComparison comparisonType)
public int IndexOf(string value, int startIndex, StringComparison comparisonType)
public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType)
internal int IndexOfOrdinal(string value, int startIndex, int count, CompareOptions options)
internal int IndexOfOrdinalUnchecked(string value, int startIndex, int count)
internal int IndexOfOrdinalIgnoreCaseUnchecked(string value, int startIndex, int count)
public int LastIndexOf(string value, StringComparison comparisonType)
public int LastIndexOf(string value, int startIndex, StringComparison comparisonType)
public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType)
internal int LastIndexOfOrdinal(string value, int startIndex, int count, CompareOptions options)
internal int LastIndexOfOrdinalUnchecked(string value, int startIndex, int count)
internal int LastIndexOfOrdinalIgnoreCaseUnchecked(string value, int startIndex, int count)
public int IndexOf(char value)
public int IndexOf(char value, int startIndex)
public int IndexOf(char value, int startIndex, int count)
internal int IndexOfUnchecked(char value, int startIndex, int count)
internal int IndexOfOrdinalIgnoreCase(char value, int startIndex, int count)
public int IndexOf(string value)
public int IndexOf(string value, int startIndex)
public int IndexOf(string value, int startIndex, int count)
public int LastIndexOfAny(Char[] anyOf)
public int LastIndexOfAny(Char[] anyOf, int startIndex)
public int LastIndexOfAny(Char[] anyOf, int startIndex, int count)
private int LastIndexOfAnyUnchecked(Char[] anyOf, int startIndex, int count)
public int LastIndexOf(char value)
public int LastIndexOf(char value, int startIndex)
public int LastIndexOf(char value, int startIndex, int count)
internal int LastIndexOfUnchecked(char value, int startIndex, int count)
internal int LastIndexOfOrdinalIgnoreCase(char value, int startIndex, int count)
public int LastIndexOf(string value)
public int LastIndexOf(string value, int startIndex)
public int LastIndexOf(string value, int startIndex, int count)
public bool Contains(string value)
public bool IsNullOrEmpty(string value)
public string Normalize()
public string Normalize(NormalizationForm normalizationForm)
public bool IsNormalized()
public bool IsNormalized(NormalizationForm normalizationForm)
public string Remove(int startIndex)
public string PadLeft(int totalWidth)
public string PadLeft(int totalWidth, char paddingChar)
public string PadRight(int totalWidth)
public string PadRight(int totalWidth, char paddingChar)
public bool StartsWith(string value)
public bool StartsWith(string value, StringComparison comparisonType)
public bool EndsWith(string value, StringComparison comparisonType)
public bool StartsWith(string value, bool ignoreCase, CultureInfo culture)
public string Replace(char oldChar, char newChar)
public string Replace(string oldValue, string newValue)
private string ReplaceUnchecked(string oldValue, string newValue)
private string ReplaceFallback(string oldValue, string newValue, int testedCount)
public string Remove(int startIndex, int count)
public string ToLower()
public string ToLower(CultureInfo culture)
public string ToLowerInvariant()
public string ToUpper()
public string ToUpper(CultureInfo culture)
public string ToUpperInvariant()
public string ToString()
public string ToString(IFormatProvider provider)
public string Format(string format, object arg0)
public string Format(string format, object arg0, object arg1)
public string Format(string format, object arg0, object arg1, object arg2)
public string Format(string format, Object[] args)
public string Format(IFormatProvider provider, string format, Object[] args)
internal StringBuilder FormatHelper(StringBuilder result, IFormatProvider provider, string format, Object[] args)
public string Copy(string str)
public string Concat(object arg0)
public string Concat(object arg0, object arg1)
public string Concat(object arg0, object arg1, object arg2)
public string Concat(object arg0, object arg1, object arg2, object arg3)
public string Concat(string str0, string str1)
public string Concat(string str0, string str1, string str2)
public string Concat(string str0, string str1, string str2, string str3)
public string Concat(Object[] args)
public string Concat(String[] values)
private string ConcatInternal(String[] values, int length)
public string Insert(int startIndex, string value)
public string Intern(string str)
public string IsInterned(string str)
public string Join(string separator, String[] value)
public string Join(string separator, String[] value, int startIndex, int count)
private string JoinUnchecked(string separator, String[] value, int startIndex, int count)
public int get_Length()
public CharEnumerator GetEnumerator()
private void ParseFormatSpecifier(string str, Int32& ptr, Int32& n, Int32& width, Boolean& left_align, String& format)
private int ParseDecimal(string str, Int32& ptr)
internal void InternalSetChar(int idx, char val)
internal void InternalSetLength(int newLength)
public int GetHashCode()
internal int GetCaseInsensitiveHashCode()
private string CreateString(SByte* value)
private string CreateString(SByte* value, int startIndex, int length)
private string CreateString(SByte* value, int startIndex, int length, Encoding enc)
private string CreateString(Char* value)
private string CreateString(Char* value, int startIndex, int length)
private string CreateString(Char[] val, int startIndex, int length)
private string CreateString(Char[] val)
private string CreateString(char c, int count)
internal void memset(Byte* dest, int val, int len)
private void memcpy4(Byte* dest, Byte* src, int size)
private void memcpy2(Byte* dest, Byte* src, int size)
private void memcpy1(Byte* dest, Byte* src, int size)
internal void memcpy(Byte* dest, Byte* src, int size)
internal void CharCopy(Char* dest, Char* src, int count)
internal void CharCopyReverse(Char* dest, Char* src, int count)
internal void CharCopy(string target, int targetIndex, string source, int sourceIndex, int count)
internal void CharCopy(string target, int targetIndex, Char[] source, int sourceIndex, int count)
internal void CharCopyReverse(string target, int targetIndex, string source, int sourceIndex, int count)
private String[] InternalSplit(Char[] separator, int count, int options)
internal string InternalAllocateStr(int length)
private string InternalIntern(string str)
private string InternalIsInterned(string str)
public bool op_Equality(string a, string b)
public bool op_Inequality(string a, string b)
}
public System.StringComparer : object {
private StringComparer invariantCultureIgnoreCase
private StringComparer invariantCulture
private StringComparer ordinalIgnoreCase
private StringComparer ordinal
public StringComparer CurrentCulture
public StringComparer CurrentCultureIgnoreCase
public StringComparer InvariantCulture
public StringComparer InvariantCultureIgnoreCase
public StringComparer Ordinal
public StringComparer OrdinalIgnoreCase
public StringComparer get_CurrentCulture()
public StringComparer get_CurrentCultureIgnoreCase()
public StringComparer get_InvariantCulture()
public StringComparer get_InvariantCultureIgnoreCase()
public StringComparer get_Ordinal()
public StringComparer get_OrdinalIgnoreCase()
public StringComparer Create(CultureInfo culture, bool ignoreCase)
public int Compare(object x, object y)
public bool Equals(object x, object y)
public int GetHashCode(object obj)
public int Compare(string x, string y)
public bool Equals(string x, string y)
public int GetHashCode(string obj)
}
public System.StringComparison : Enum {
public int value__
public StringComparison CurrentCulture
public StringComparison CurrentCultureIgnoreCase
public StringComparison InvariantCulture
public StringComparison InvariantCultureIgnoreCase
public StringComparison Ordinal
public StringComparison OrdinalIgnoreCase
}
public System.StringSplitOptions : Enum {
public int value__
public StringSplitOptions None
public StringSplitOptions RemoveEmptyEntries
}
public System.SystemException : Exception {
private int Result
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
internal System.TermInfoBooleans : Enum {
public int value__
public TermInfoBooleans AutoLeftMargin
public TermInfoBooleans AutoRightMargin
public TermInfoBooleans NoEscCtlc
public TermInfoBooleans CeolStandoutGlitch
public TermInfoBooleans EatNewlineGlitch
public TermInfoBooleans EraseOverstrike
public TermInfoBooleans GenericType
public TermInfoBooleans HardCopy
public TermInfoBooleans HasMetaKey
public TermInfoBooleans HasStatusLine
public TermInfoBooleans InsertNullGlitch
public TermInfoBooleans MemoryAbove
public TermInfoBooleans MemoryBelow
public TermInfoBooleans MoveInsertMode
public TermInfoBooleans MoveStandoutMode
public TermInfoBooleans OverStrike
public TermInfoBooleans StatusLineEscOk
public TermInfoBooleans DestTabsMagicSmso
public TermInfoBooleans TildeGlitch
public TermInfoBooleans TransparentUnderline
public TermInfoBooleans XonXoff
public TermInfoBooleans NeedsXonXoff
public TermInfoBooleans PrtrSilent
public TermInfoBooleans HardCursor
public TermInfoBooleans NonRevRmcup
public TermInfoBooleans NoPadChar
public TermInfoBooleans NonDestScrollRegion
public TermInfoBooleans CanChange
public TermInfoBooleans BackColorErase
public TermInfoBooleans HueLightnessSaturation
public TermInfoBooleans ColAddrGlitch
public TermInfoBooleans CrCancelsMicroMode
public TermInfoBooleans HasPrintWheel
public TermInfoBooleans RowAddrGlitch
public TermInfoBooleans SemiAutoRightMargin
public TermInfoBooleans CpiChangesRes
public TermInfoBooleans LpiChangesRes
public TermInfoBooleans Last
}
internal System.TermInfoDriver : object {
private Int32* native_terminal_size
private int terminal_size
private String[] locations
private TermInfoReader reader
private int cursorLeft
private int cursorTop
private string title
private string titleFormat
private bool cursorVisible
private string csrVisible
private string csrInvisible
private string clear
private string bell
private string term
private StreamReader stdin
private CStreamWriter stdout
private int windowWidth
private int windowHeight
private int bufferHeight
private int bufferWidth
private Char[] buffer
private int readpos
private int writepos
private string keypadXmit
private string keypadLocal
private bool controlCAsInput
private bool inited
private object initLock
private bool initKeys
private string origPair
private string origColors
private string cursorAddress
private ConsoleColor fgcolor
private ConsoleColor bgcolor
private bool color16
private string setlfgcolor
private string setlbgcolor
private string setfgcolor
private string setbgcolor
private bool noGetPosition
private Hashtable keymap
private ByteMatcher rootmap
private bool home_1_1
private int rl_startx
private int rl_starty
private Byte[] control_characters
private Char[] echobuf
private int echon
private TermInfoStrings[] UsedKeys
public bool Initialized
public ConsoleColor BackgroundColor
public ConsoleColor ForegroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorTop
public bool CursorVisible
public int CursorSize
public bool KeyAvailable
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
public void .ctor(string term)
private string SearchTerminfo(string term)
private void WriteConsole(string str)
public bool get_Initialized()
public void Init()
private string MangleParameters(string str)
private int TranslateColor(ConsoleColor desired, Boolean& light)
private void IncrementX()
public void WriteSpecialKey(ConsoleKeyInfo key)
public void WriteSpecialKey(char c)
public bool IsSpecialKey(ConsoleKeyInfo key)
public bool IsSpecialKey(char c)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
private void GetCursorPosition()
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public int get_CursorSize()
public void set_CursorSize(int value)
public bool get_KeyAvailable()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
private void CheckWindowDimensions()
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Clear()
public void Beep(int frequency, int duration)
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
private void AddToBuffer(int b)
private void AdjustBuffer()
private ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt)
private object GetKeyFromBuffer(bool cooked)
private ConsoleKeyInfo ReadKeyInternal(Boolean& fresh)
private bool InputPending()
private void QueueEcho(char c)
private void Echo(ConsoleKeyInfo key)
private void EchoFlush()
public int Read(Char[] dest, int index, int count)
public ConsoleKeyInfo ReadKey(bool intercept)
public string ReadLine()
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
private void CreateKeyMap()
private void InitKeys()
private void AddStringMapping(TermInfoStrings s)
}
internal System.TermInfoNumbers : Enum {
public int value__
public TermInfoNumbers Columns
public TermInfoNumbers InitTabs
public TermInfoNumbers Lines
public TermInfoNumbers LinesOfMemory
public TermInfoNumbers MagicCookieGlitch
public TermInfoNumbers PaddingBaudRate
public TermInfoNumbers VirtualTerminal
public TermInfoNumbers WidthStatusLine
public TermInfoNumbers NumLabels
public TermInfoNumbers LabelHeight
public TermInfoNumbers LabelWidth
public TermInfoNumbers MaxAttributes
public TermInfoNumbers MaximumWindows
public TermInfoNumbers MaxColors
public TermInfoNumbers MaxPairs
public TermInfoNumbers NoColorVideo
public TermInfoNumbers BufferCapacity
public TermInfoNumbers DotVertSpacing
public TermInfoNumbers DotHorzSpacing
public TermInfoNumbers MaxMicroAddress
public TermInfoNumbers MaxMicroJump
public TermInfoNumbers MicroColSize
public TermInfoNumbers MicroLineSize
public TermInfoNumbers NumberOfPins
public TermInfoNumbers OutputResChar
public TermInfoNumbers OutputResLine
public TermInfoNumbers OutputResHorzInch
public TermInfoNumbers OutputResVertInch
public TermInfoNumbers PrintRate
public TermInfoNumbers WideCharSize
public TermInfoNumbers Buttons
public TermInfoNumbers BitImageEntwining
public TermInfoNumbers BitImageType
public TermInfoNumbers Last
}
internal System.TermInfoReader : object {
private short boolSize
private short numSize
private short strOffsets
private Byte[] buffer
private int booleansOffset
public void .ctor(string term, string filename)
public void .ctor(string term, Byte[] buffer)
private void ReadHeader(Byte[] buffer, Int32& position)
private void ReadNames(Byte[] buffer, Int32& position)
public bool Get(TermInfoBooleans boolean)
public int Get(TermInfoNumbers number)
public string Get(TermInfoStrings tstr)
public Byte[] GetStringBytes(TermInfoStrings tstr)
private short GetInt16(Byte[] buffer, int offset)
private string GetString(Byte[] buffer, int offset)
private Byte[] GetStringBytes(Byte[] buffer, int offset)
internal string Escape(string s)
}
internal System.TermInfoStrings : Enum {
public int value__
public TermInfoStrings BackTab
public TermInfoStrings Bell
public TermInfoStrings CarriageReturn
public TermInfoStrings ChangeScrollRegion
public TermInfoStrings ClearAllTabs
public TermInfoStrings ClearScreen
public TermInfoStrings ClrEol
public TermInfoStrings ClrEos
public TermInfoStrings ColumnAddress
public TermInfoStrings CommandCharacter
public TermInfoStrings CursorAddress
public TermInfoStrings CursorDown
public TermInfoStrings CursorHome
public TermInfoStrings CursorInvisible
public TermInfoStrings CursorLeft
public TermInfoStrings CursorMemAddress
public TermInfoStrings CursorNormal
public TermInfoStrings CursorRight
public TermInfoStrings CursorToLl
public TermInfoStrings CursorUp
public TermInfoStrings CursorVisible
public TermInfoStrings DeleteCharacter
public TermInfoStrings DeleteLine
public TermInfoStrings DisStatusLine
public TermInfoStrings DownHalfLine
public TermInfoStrings EnterAltCharsetMode
public TermInfoStrings EnterBlinkMode
public TermInfoStrings EnterBoldMode
public TermInfoStrings EnterCaMode
public TermInfoStrings EnterDeleteMode
public TermInfoStrings EnterDimMode
public TermInfoStrings EnterInsertMode
public TermInfoStrings EnterSecureMode
public TermInfoStrings EnterProtectedMode
public TermInfoStrings EnterReverseMode
public TermInfoStrings EnterStandoutMode
public TermInfoStrings EnterUnderlineMode
public TermInfoStrings EraseChars
public TermInfoStrings ExitAltCharsetMode
public TermInfoStrings ExitAttributeMode
public TermInfoStrings ExitCaMode
public TermInfoStrings ExitDeleteMode
public TermInfoStrings ExitInsertMode
public TermInfoStrings ExitStandoutMode
public TermInfoStrings ExitUnderlineMode
public TermInfoStrings FlashScreen
public TermInfoStrings FormFeed
public TermInfoStrings FromStatusLine
public TermInfoStrings Init1string
public TermInfoStrings Init2string
public TermInfoStrings Init3string
public TermInfoStrings InitFile
public TermInfoStrings InsertCharacter
public TermInfoStrings InsertLine
public TermInfoStrings InsertPadding
public TermInfoStrings KeyBackspace
public TermInfoStrings KeyCatab
public TermInfoStrings KeyClear
public TermInfoStrings KeyCtab
public TermInfoStrings KeyDc
public TermInfoStrings KeyDl
public TermInfoStrings KeyDown
public TermInfoStrings KeyEic
public TermInfoStrings KeyEol
public TermInfoStrings KeyEos
public TermInfoStrings KeyF0
public TermInfoStrings KeyF1
public TermInfoStrings KeyF10
public TermInfoStrings KeyF2
public TermInfoStrings KeyF3
public TermInfoStrings KeyF4
public TermInfoStrings KeyF5
public TermInfoStrings KeyF6
public TermInfoStrings KeyF7
public TermInfoStrings KeyF8
public TermInfoStrings KeyF9
public TermInfoStrings KeyHome
public TermInfoStrings KeyIc
public TermInfoStrings KeyIl
public TermInfoStrings KeyLeft
public TermInfoStrings KeyLl
public TermInfoStrings KeyNpage
public TermInfoStrings KeyPpage
public TermInfoStrings KeyRight
public TermInfoStrings KeySf
public TermInfoStrings KeySr
public TermInfoStrings KeyStab
public TermInfoStrings KeyUp
public TermInfoStrings KeypadLocal
public TermInfoStrings KeypadXmit
public TermInfoStrings LabF0
public TermInfoStrings LabF1
public TermInfoStrings LabF10
public TermInfoStrings LabF2
public TermInfoStrings LabF3
public TermInfoStrings LabF4
public TermInfoStrings LabF5
public TermInfoStrings LabF6
public TermInfoStrings LabF7
public TermInfoStrings LabF8
public TermInfoStrings LabF9
public TermInfoStrings MetaOff
public TermInfoStrings MetaOn
public TermInfoStrings Newline
public TermInfoStrings PadChar
public TermInfoStrings ParmDch
public TermInfoStrings ParmDeleteLine
public TermInfoStrings ParmDownCursor
public TermInfoStrings ParmIch
public TermInfoStrings ParmIndex
public TermInfoStrings ParmInsertLine
public TermInfoStrings ParmLeftCursor
public TermInfoStrings ParmRightCursor
public TermInfoStrings ParmRindex
public TermInfoStrings ParmUpCursor
public TermInfoStrings PkeyKey
public TermInfoStrings PkeyLocal
public TermInfoStrings PkeyXmit
public TermInfoStrings PrintScreen
public TermInfoStrings PrtrOff
public TermInfoStrings PrtrOn
public TermInfoStrings RepeatChar
public TermInfoStrings Reset1string
public TermInfoStrings Reset2string
public TermInfoStrings Reset3string
public TermInfoStrings ResetFile
public TermInfoStrings RestoreCursor
public TermInfoStrings RowAddress
public TermInfoStrings SaveCursor
public TermInfoStrings ScrollForward
public TermInfoStrings ScrollReverse
public TermInfoStrings SetAttributes
public TermInfoStrings SetTab
public TermInfoStrings SetWindow
public TermInfoStrings Tab
public TermInfoStrings ToStatusLine
public TermInfoStrings UnderlineChar
public TermInfoStrings UpHalfLine
public TermInfoStrings InitProg
public TermInfoStrings KeyA1
public TermInfoStrings KeyA3
public TermInfoStrings KeyB2
public TermInfoStrings KeyC1
public TermInfoStrings KeyC3
public TermInfoStrings PrtrNon
public TermInfoStrings CharPadding
public TermInfoStrings AcsChars
public TermInfoStrings PlabNorm
public TermInfoStrings KeyBtab
public TermInfoStrings EnterXonMode
public TermInfoStrings ExitXonMode
public TermInfoStrings EnterAmMode
public TermInfoStrings ExitAmMode
public TermInfoStrings XonCharacter
public TermInfoStrings XoffCharacter
public TermInfoStrings EnaAcs
public TermInfoStrings LabelOn
public TermInfoStrings LabelOff
public TermInfoStrings KeyBeg
public TermInfoStrings KeyCancel
public TermInfoStrings KeyClose
public TermInfoStrings KeyCommand
public TermInfoStrings KeyCopy
public TermInfoStrings KeyCreate
public TermInfoStrings KeyEnd
public TermInfoStrings KeyEnter
public TermInfoStrings KeyExit
public TermInfoStrings KeyFind
public TermInfoStrings KeyHelp
public TermInfoStrings KeyMark
public TermInfoStrings KeyMessage
public TermInfoStrings KeyMove
public TermInfoStrings KeyNext
public TermInfoStrings KeyOpen
public TermInfoStrings KeyOptions
public TermInfoStrings KeyPrevious
public TermInfoStrings KeyPrint
public TermInfoStrings KeyRedo
public TermInfoStrings KeyReference
public TermInfoStrings KeyRefresh
public TermInfoStrings KeyReplace
public TermInfoStrings KeyRestart
public TermInfoStrings KeyResume
public TermInfoStrings KeySave
public TermInfoStrings KeySuspend
public TermInfoStrings KeyUndo
public TermInfoStrings KeySbeg
public TermInfoStrings KeyScancel
public TermInfoStrings KeyScommand
public TermInfoStrings KeyScopy
public TermInfoStrings KeyScreate
public TermInfoStrings KeySdc
public TermInfoStrings KeySdl
public TermInfoStrings KeySelect
public TermInfoStrings KeySend
public TermInfoStrings KeySeol
public TermInfoStrings KeySexit
public TermInfoStrings KeySfind
public TermInfoStrings KeyShelp
public TermInfoStrings KeyShome
public TermInfoStrings KeySic
public TermInfoStrings KeySleft
public TermInfoStrings KeySmessage
public TermInfoStrings KeySmove
public TermInfoStrings KeySnext
public TermInfoStrings KeySoptions
public TermInfoStrings KeySprevious
public TermInfoStrings KeySprint
public TermInfoStrings KeySredo
public TermInfoStrings KeySreplace
public TermInfoStrings KeySright
public TermInfoStrings KeySrsume
public TermInfoStrings KeySsave
public TermInfoStrings KeySsuspend
public TermInfoStrings KeySundo
public TermInfoStrings ReqForInput
public TermInfoStrings KeyF11
public TermInfoStrings KeyF12
public TermInfoStrings KeyF13
public TermInfoStrings KeyF14
public TermInfoStrings KeyF15
public TermInfoStrings KeyF16
public TermInfoStrings KeyF17
public TermInfoStrings KeyF18
public TermInfoStrings KeyF19
public TermInfoStrings KeyF20
public TermInfoStrings KeyF21
public TermInfoStrings KeyF22
public TermInfoStrings KeyF23
public TermInfoStrings KeyF24
public TermInfoStrings KeyF25
public TermInfoStrings KeyF26
public TermInfoStrings KeyF27
public TermInfoStrings KeyF28
public TermInfoStrings KeyF29
public TermInfoStrings KeyF30
public TermInfoStrings KeyF31
public TermInfoStrings KeyF32
public TermInfoStrings KeyF33
public TermInfoStrings KeyF34
public TermInfoStrings KeyF35
public TermInfoStrings KeyF36
public TermInfoStrings KeyF37
public TermInfoStrings KeyF38
public TermInfoStrings KeyF39
public TermInfoStrings KeyF40
public TermInfoStrings KeyF41
public TermInfoStrings KeyF42
public TermInfoStrings KeyF43
public TermInfoStrings KeyF44
public TermInfoStrings KeyF45
public TermInfoStrings KeyF46
public TermInfoStrings KeyF47
public TermInfoStrings KeyF48
public TermInfoStrings KeyF49
public TermInfoStrings KeyF50
public TermInfoStrings KeyF51
public TermInfoStrings KeyF52
public TermInfoStrings KeyF53
public TermInfoStrings KeyF54
public TermInfoStrings KeyF55
public TermInfoStrings KeyF56
public TermInfoStrings KeyF57
public TermInfoStrings KeyF58
public TermInfoStrings KeyF59
public TermInfoStrings KeyF60
public TermInfoStrings KeyF61
public TermInfoStrings KeyF62
public TermInfoStrings KeyF63
public TermInfoStrings ClrBol
public TermInfoStrings ClearMargins
public TermInfoStrings SetLeftMargin
public TermInfoStrings SetRightMargin
public TermInfoStrings LabelFormat
public TermInfoStrings SetClock
public TermInfoStrings DisplayClock
public TermInfoStrings RemoveClock
public TermInfoStrings CreateWindow
public TermInfoStrings GotoWindow
public TermInfoStrings Hangup
public TermInfoStrings DialPhone
public TermInfoStrings QuickDial
public TermInfoStrings Tone
public TermInfoStrings Pulse
public TermInfoStrings FlashHook
public TermInfoStrings FixedPause
public TermInfoStrings WaitTone
public TermInfoStrings User0
public TermInfoStrings User1
public TermInfoStrings User2
public TermInfoStrings User3
public TermInfoStrings User4
public TermInfoStrings User5
public TermInfoStrings User6
public TermInfoStrings User7
public TermInfoStrings User8
public TermInfoStrings User9
public TermInfoStrings OrigPair
public TermInfoStrings OrigColors
public TermInfoStrings InitializeColor
public TermInfoStrings InitializePair
public TermInfoStrings SetColorPair
public TermInfoStrings SetForeground
public TermInfoStrings SetBackground
public TermInfoStrings ChangeCharPitch
public TermInfoStrings ChangeLinePitch
public TermInfoStrings ChangeResHorz
public TermInfoStrings ChangeResVert
public TermInfoStrings DefineChar
public TermInfoStrings EnterDoublewideMode
public TermInfoStrings EnterDraftQuality
public TermInfoStrings EnterItalicsMode
public TermInfoStrings EnterLeftwardMode
public TermInfoStrings EnterMicroMode
public TermInfoStrings EnterNearLetterQuality
public TermInfoStrings EnterNormalQuality
public TermInfoStrings EnterShadowMode
public TermInfoStrings EnterSubscriptMode
public TermInfoStrings EnterSuperscriptMode
public TermInfoStrings EnterUpwardMode
public TermInfoStrings ExitDoublewideMode
public TermInfoStrings ExitItalicsMode
public TermInfoStrings ExitLeftwardMode
public TermInfoStrings ExitMicroMode
public TermInfoStrings ExitShadowMode
public TermInfoStrings ExitSubscriptMode
public TermInfoStrings ExitSuperscriptMode
public TermInfoStrings ExitUpwardMode
public TermInfoStrings MicroColumnAddress
public TermInfoStrings MicroDown
public TermInfoStrings MicroLeft
public TermInfoStrings MicroRight
public TermInfoStrings MicroRowAddress
public TermInfoStrings MicroUp
public TermInfoStrings OrderOfPins
public TermInfoStrings ParmDownMicro
public TermInfoStrings ParmLeftMicro
public TermInfoStrings ParmRightMicro
public TermInfoStrings ParmUpMicro
public TermInfoStrings SelectCharSet
public TermInfoStrings SetBottomMargin
public TermInfoStrings SetBottomMarginParm
public TermInfoStrings SetLeftMarginParm
public TermInfoStrings SetRightMarginParm
public TermInfoStrings SetTopMargin
public TermInfoStrings SetTopMarginParm
public TermInfoStrings StartBitImage
public TermInfoStrings StartCharSetDef
public TermInfoStrings StopBitImage
public TermInfoStrings StopCharSetDef
public TermInfoStrings SubscriptCharacters
public TermInfoStrings SuperscriptCharacters
public TermInfoStrings TheseCauseCr
public TermInfoStrings ZeroMotion
public TermInfoStrings CharSetNames
public TermInfoStrings KeyMouse
public TermInfoStrings MouseInfo
public TermInfoStrings ReqMousePos
public TermInfoStrings GetMouse
public TermInfoStrings SetAForeground
public TermInfoStrings SetABackground
public TermInfoStrings PkeyPlab
public TermInfoStrings DeviceType
public TermInfoStrings CodeSetInit
public TermInfoStrings Set0DesSeq
public TermInfoStrings Set1DesSeq
public TermInfoStrings Set2DesSeq
public TermInfoStrings Set3DesSeq
public TermInfoStrings SetLrMargin
public TermInfoStrings SetTbMargin
public TermInfoStrings BitImageRepeat
public TermInfoStrings BitImageNewline
public TermInfoStrings BitImageCarriageReturn
public TermInfoStrings ColorNames
public TermInfoStrings DefineBitImageRegion
public TermInfoStrings EndBitImageRegion
public TermInfoStrings SetColorBand
public TermInfoStrings SetPageLength
public TermInfoStrings DisplayPcChar
public TermInfoStrings EnterPcCharsetMode
public TermInfoStrings ExitPcCharsetMode
public TermInfoStrings EnterScancodeMode
public TermInfoStrings ExitScancodeMode
public TermInfoStrings PcTermOptions
public TermInfoStrings ScancodeEscape
public TermInfoStrings AltScancodeEsc
public TermInfoStrings EnterHorizontalHlMode
public TermInfoStrings EnterLeftHlMode
public TermInfoStrings EnterLowHlMode
public TermInfoStrings EnterRightHlMode
public TermInfoStrings EnterTopHlMode
public TermInfoStrings EnterVerticalHlMode
public TermInfoStrings SetAAttributes
public TermInfoStrings SetPglenInch
public TermInfoStrings Last
}
public System.Text.ASCIIEncoding : Encoding {
internal int ASCII_CODE_PAGE
public bool IsSingleByte
public bool get_IsSingleByte()
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string chars)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, EncoderFallbackBuffer& buffer, Char[]& fallback_chars)
public int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, EncoderFallbackBuffer& buffer, Char[]& fallback_chars)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
private int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, DecoderFallbackBuffer& buffer)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public string GetString(Byte[] bytes, int byteIndex, int byteCount)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public int GetCharCount(Byte* bytes, int count)
public int GetByteCount(Char* chars, int count)
public Decoder GetDecoder()
public Encoder GetEncoder()
}
internal System.Text.CodePageEncoding : object {
private int codePage
private bool isReadOnly
private EncoderFallback encoderFallback
private DecoderFallback decoderFallback
private Encoding realObject
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Text.Decoder : object {
private DecoderFallback fallback
private DecoderFallbackBuffer fallback_buffer
public DecoderFallback Fallback
public DecoderFallbackBuffer FallbackBuffer
public DecoderFallback get_Fallback()
public void set_Fallback(DecoderFallback value)
public DecoderFallbackBuffer get_FallbackBuffer()
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetCharCount(Byte[] bytes, int index, int count, bool flush)
public int GetCharCount(Byte* bytes, int count, bool flush)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush)
public void Reset()
public void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
public void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed)
private void CheckArguments(Char[] chars, int charIndex)
private void CheckArguments(Byte[] bytes, int byteIndex, int byteCount)
private void CheckArguments(Char* chars, int charCount, Byte* bytes, int byteCount)
}
public System.Text.DecoderExceptionFallback : DecoderFallback {
public int MaxCharCount
public int get_MaxCharCount()
public DecoderFallbackBuffer CreateFallbackBuffer()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
public int Remaining
public int get_Remaining()
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
}
public System.Text.DecoderFallback : object {
private DecoderFallback exception_fallback
private DecoderFallback replacement_fallback
private DecoderFallback standard_safe_fallback
public DecoderFallback ExceptionFallback
public int MaxCharCount
public DecoderFallback ReplacementFallback
internal DecoderFallback StandardSafeFallback
public DecoderFallback get_ExceptionFallback()
public int get_MaxCharCount()
public DecoderFallback get_ReplacementFallback()
internal DecoderFallback get_StandardSafeFallback()
public DecoderFallbackBuffer CreateFallbackBuffer()
}
public System.Text.DecoderFallbackBuffer : object {
public int Remaining
public int get_Remaining()
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public void Reset()
}
public System.Text.DecoderFallbackException : ArgumentException {
private string defaultMessage
private Byte[] bytes_unknown
private int index
public Byte[] BytesUnknown
public int Index
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
public void .ctor(string message, Byte[] bytesUnknown, int index)
public Byte[] get_BytesUnknown()
public int get_Index()
}
public System.Text.DecoderReplacementFallback : DecoderFallback {
private string replacement
public string DefaultString
public int MaxCharCount
public void .ctor(string replacement)
public string get_DefaultString()
public int get_MaxCharCount()
public DecoderFallbackBuffer CreateFallbackBuffer()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
private bool fallback_assigned
private int current
private string replacement
public int Remaining
public void .ctor(DecoderReplacementFallback fallback)
public int get_Remaining()
public bool Fallback(Byte[] bytesUnknown, int index)
public char GetNextChar()
public bool MovePrevious()
public void Reset()
}
public System.Text.Encoder : object {
private EncoderFallback fallback
private EncoderFallbackBuffer fallback_buffer
public EncoderFallback Fallback
public EncoderFallbackBuffer FallbackBuffer
public EncoderFallback get_Fallback()
public void set_Fallback(EncoderFallback value)
public EncoderFallbackBuffer get_FallbackBuffer()
public int GetByteCount(Char[] chars, int index, int count, bool flush)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush)
public int GetByteCount(Char* chars, int count, bool flush)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush)
public void Reset()
public void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
public void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed)
private void CheckArguments(Char* chars, int charCount, Byte* bytes, int byteCount)
}
public System.Text.EncoderExceptionFallback : EncoderFallback {
public int MaxCharCount
public int get_MaxCharCount()
public EncoderFallbackBuffer CreateFallbackBuffer()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
public int Remaining
public int get_Remaining()
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
}
public System.Text.EncoderFallback : object {
private EncoderFallback exception_fallback
private EncoderFallback replacement_fallback
private EncoderFallback standard_safe_fallback
public EncoderFallback ExceptionFallback
public int MaxCharCount
public EncoderFallback ReplacementFallback
internal EncoderFallback StandardSafeFallback
public EncoderFallback get_ExceptionFallback()
public int get_MaxCharCount()
public EncoderFallback get_ReplacementFallback()
internal EncoderFallback get_StandardSafeFallback()
public EncoderFallbackBuffer CreateFallbackBuffer()
}
public System.Text.EncoderFallbackBuffer : object {
public int Remaining
public int get_Remaining()
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
public char GetNextChar()
public bool MovePrevious()
public void Reset()
}
public System.Text.EncoderFallbackException : ArgumentException {
private string defaultMessage
private char char_unknown
private char char_unknown_high
private char char_unknown_low
private int index
public char CharUnknown
public char CharUnknownHigh
public char CharUnknownLow
public int Index
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
internal void .ctor(char charUnknown, int index)
internal void .ctor(char charUnknownHigh, char charUnknownLow, int index)
public char get_CharUnknown()
public char get_CharUnknownHigh()
public char get_CharUnknownLow()
public int get_Index()
public bool IsUnknownSurrogate()
}
public System.Text.EncoderReplacementFallback : EncoderFallback {
private string replacement
public string DefaultString
public int MaxCharCount
public void .ctor(string replacement)
public string get_DefaultString()
public int get_MaxCharCount()
public EncoderFallbackBuffer CreateFallbackBuffer()
public bool Equals(object value)
public int GetHashCode()
}
public System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
private string replacement
private int current
private bool fallback_assigned
public int Remaining
public void .ctor(EncoderReplacementFallback fallback)
public int get_Remaining()
public bool Fallback(char charUnknown, int index)
public bool Fallback(char charUnknownHigh, char charUnknownLow, int index)
private bool Fallback(int index)
public char GetNextChar()
public bool MovePrevious()
public void Reset()
}
public System.Text.Encoding : object {
internal int codePage
internal int windows_code_page
private bool is_readonly
private DecoderFallback decoder_fallback
private EncoderFallback encoder_fallback
private Assembly i18nAssembly
private bool i18nDisabled
private EncodingInfo[] encoding_infos
private Object[] encodings
internal string body_name
internal string encoding_name
internal string header_name
internal bool is_mail_news_display
internal bool is_mail_news_save
internal bool is_browser_save
internal bool is_browser_display
internal string web_name
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) asciiEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) defaultEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf7Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingWithMarkers
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingWithoutMarkers
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) unicodeEncoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) isoLatin1Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf8EncodingUnsafe
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) utf32Encoding
private Encoding modreq(System.Runtime.CompilerServices.IsVolatile) bigEndianUTF32Encoding
private object lockobj
public bool IsReadOnly
public bool IsSingleByte
public DecoderFallback DecoderFallback
public EncoderFallback EncoderFallback
public string BodyName
public int CodePage
public string EncodingName
public string HeaderName
public bool IsBrowserDisplay
public bool IsBrowserSave
public bool IsMailNewsDisplay
public bool IsMailNewsSave
public string WebName
public int WindowsCodePage
public Encoding ASCII
public Encoding BigEndianUnicode
public Encoding Default
private Encoding ISOLatin1
public Encoding UTF7
public Encoding UTF8
internal Encoding UTF8Unmarked
internal Encoding UTF8UnmarkedUnsafe
public Encoding Unicode
public Encoding UTF32
internal Encoding BigEndianUTF32
protected void .ctor(int codePage)
internal string _(string arg)
public bool get_IsReadOnly()
public bool get_IsSingleByte()
public DecoderFallback get_DecoderFallback()
public void set_DecoderFallback(DecoderFallback value)
public EncoderFallback get_EncoderFallback()
public void set_EncoderFallback(EncoderFallback value)
internal void SetFallbackInternal(EncoderFallback e, DecoderFallback d)
public Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes)
public Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count)
public bool Equals(object value)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char[] chars)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public Byte[] GetBytes(string s)
public Byte[] GetBytes(Char[] chars, int index, int count)
public Byte[] GetBytes(Char[] chars)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte[] bytes)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public Char[] GetChars(Byte[] bytes, int index, int count)
public Char[] GetChars(Byte[] bytes)
public Decoder GetDecoder()
public Encoder GetEncoder()
private object InvokeI18N(string name, Object[] args)
public Encoding GetEncoding(int codepage)
public object Clone()
public Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
public Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
public EncodingInfo[] GetEncodings()
public bool IsAlwaysNormalized()
public bool IsAlwaysNormalized(NormalizationForm form)
public Encoding GetEncoding(string name)
public int GetHashCode()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Byte[] GetPreamble()
public string GetString(Byte[] bytes, int index, int count)
public string GetString(Byte[] bytes)
public string get_BodyName()
public int get_CodePage()
public string get_EncodingName()
public string get_HeaderName()
public bool get_IsBrowserDisplay()
public bool get_IsBrowserSave()
public bool get_IsMailNewsDisplay()
public bool get_IsMailNewsSave()
public string get_WebName()
public int get_WindowsCodePage()
public Encoding get_ASCII()
public Encoding get_BigEndianUnicode()
internal string InternalCodePage(Int32& code_page)
public Encoding get_Default()
private Encoding get_ISOLatin1()
public Encoding get_UTF7()
public Encoding get_UTF8()
internal Encoding get_UTF8Unmarked()
internal Encoding get_UTF8UnmarkedUnsafe()
public Encoding get_Unicode()
public Encoding get_UTF32()
internal Encoding get_BigEndianUTF32()
public int GetByteCount(Char* chars, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
}
public System.Text.EncodingInfo : object {
private int codepage
private Encoding encoding
public int CodePage
public string DisplayName
public string Name
internal void .ctor(int cp)
public int get_CodePage()
public string get_DisplayName()
public string get_Name()
public bool Equals(object value)
public int GetHashCode()
public Encoding GetEncoding()
}
internal System.Text.Latin1Encoding : Encoding {
internal int ISOLATIN_CODE_PAGE
public bool IsSingleByte
public string BodyName
public string EncodingName
public string HeaderName
public bool IsBrowserDisplay
public bool IsBrowserSave
public bool IsMailNewsDisplay
public bool IsMailNewsSave
public string WebName
public bool get_IsSingleByte()
public bool IsAlwaysNormalized(NormalizationForm form)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, EncoderFallbackBuffer& buffer, Char[]& fallback_chars)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex, EncoderFallbackBuffer& buffer, Char[]& fallback_chars)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public string GetString(Byte[] bytes, int index, int count)
public string GetString(Byte[] bytes)
public string get_BodyName()
public string get_EncodingName()
public string get_HeaderName()
public bool get_IsBrowserDisplay()
public bool get_IsBrowserSave()
public bool get_IsMailNewsDisplay()
public bool get_IsMailNewsSave()
public string get_WebName()
}
internal System.Text.MLangCodePageEncoding : object {
private int codePage
private bool isReadOnly
private EncoderFallback encoderFallback
private DecoderFallback decoderFallback
private Encoding realObject
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Text.NormalizationForm : Enum {
public int value__
public NormalizationForm FormC
public NormalizationForm FormD
public NormalizationForm FormKC
public NormalizationForm FormKD
}
public System.Text.StringBuilder : object {
private int constDefaultCapacity
private int _length
private string _str
private string _cached_str
private int _maxCapacity
public int MaxCapacity
public int Capacity
public int Length
public char Chars
public void .ctor(string value, int startIndex, int length, int capacity)
private void .ctor(string value, int startIndex, int length, int capacity, int maxCapacity)
public void .ctor(int capacity)
public void .ctor(int capacity, int maxCapacity)
public void .ctor(string value)
public void .ctor(string value, int capacity)
private void .ctor(SerializationInfo info, StreamingContext context)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public int get_MaxCapacity()
public int get_Capacity()
public void set_Capacity(int value)
public int get_Length()
public void set_Length(int value)
public char get_Chars(int index)
public void set_Chars(int index, char value)
public string ToString()
public string ToString(int startIndex, int length)
public int EnsureCapacity(int capacity)
public bool Equals(StringBuilder sb)
public StringBuilder Remove(int startIndex, int length)
public StringBuilder Replace(char oldChar, char newChar)
public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count)
public StringBuilder Replace(string oldValue, string newValue)
public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count)
public StringBuilder Append(Char[] value)
public StringBuilder Append(string value)
public StringBuilder Append(bool value)
public StringBuilder Append(byte value)
public StringBuilder Append(decimal value)
public StringBuilder Append(double value)
public StringBuilder Append(short value)
public StringBuilder Append(int value)
public StringBuilder Append(long value)
public StringBuilder Append(object value)
public StringBuilder Append(sbyte value)
public StringBuilder Append(float value)
public StringBuilder Append(ushort value)
public StringBuilder Append(UInt32 value)
public StringBuilder Append(ulong value)
public StringBuilder Append(char value)
public StringBuilder Append(char value, int repeatCount)
public StringBuilder Append(Char[] value, int startIndex, int charCount)
public StringBuilder Append(string value, int startIndex, int count)
public StringBuilder AppendLine()
public StringBuilder AppendLine(string value)
public StringBuilder AppendFormat(string format, Object[] args)
public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args)
public StringBuilder AppendFormat(string format, object arg0)
public StringBuilder AppendFormat(string format, object arg0, object arg1)
public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2)
public StringBuilder Insert(int index, Char[] value)
public StringBuilder Insert(int index, string value)
public StringBuilder Insert(int index, bool value)
public StringBuilder Insert(int index, byte value)
public StringBuilder Insert(int index, char value)
public StringBuilder Insert(int index, decimal value)
public StringBuilder Insert(int index, double value)
public StringBuilder Insert(int index, short value)
public StringBuilder Insert(int index, int value)
public StringBuilder Insert(int index, long value)
public StringBuilder Insert(int index, object value)
public StringBuilder Insert(int index, sbyte value)
public StringBuilder Insert(int index, float value)
public StringBuilder Insert(int index, ushort value)
public StringBuilder Insert(int index, UInt32 value)
public StringBuilder Insert(int index, ulong value)
public StringBuilder Insert(int index, string value, int count)
public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount)
private void InternalEnsureCapacity(int size)
public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count)
}
internal System.Text.SurrogateEncoder : object {
private Encoding encoding
private Encoder realObject
private void .ctor(SerializationInfo info, StreamingContext context)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.Text.UnicodeEncoding : Encoding {
internal int UNICODE_CODE_PAGE
internal int BIG_UNICODE_CODE_PAGE
public int CharSize
private bool bigEndian
private bool byteOrderMark
public void .ctor(bool bigEndian, bool byteOrderMark)
public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(string s)
public int GetByteCount(Char* chars, int count)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
private int GetBytesInternal(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
private int GetCharsInternal(Byte* bytes, int byteCount, Char* chars, int charCount)
public Encoder GetEncoder()
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Decoder GetDecoder()
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
private void CopyChars(Byte* src, Byte* dest, int count, bool bigEndian)
}
public System.Text.UTF32Encoding : Encoding {
internal int UTF32_CODE_PAGE
internal int BIG_UTF32_CODE_PAGE
private bool bigEndian
private bool byteOrderMark
public void .ctor(bool bigEndian, bool byteOrderMark)
public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters)
public int GetByteCount(Char[] chars, int index, int count)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Decoder GetDecoder()
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
public int GetByteCount(Char* chars, int count)
public int GetByteCount(string s)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
public Encoder GetEncoder()
}
public System.Text.UTF7Encoding : Encoding {
internal int UTF7_CODE_PAGE
private string base64Chars
private bool allowOptionals
private Byte[] encodingRules
private SByte[] base64Values
public void .ctor(bool allowOptionals)
public int GetHashCode()
public bool Equals(object value)
private int InternalGetByteCount(Char[] chars, int index, int count, bool flush, int leftOver, bool isInShifted, bool allowOptionals)
public int GetByteCount(Char[] chars, int index, int count)
private int InternalGetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush, Int32& leftOver, Boolean& isInShifted, bool allowOptionals)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
private int InternalGetCharCount(Byte[] bytes, int index, int count, int leftOver)
public int GetCharCount(Byte[] bytes, int index, int count)
private int InternalGetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, Int32& leftOver)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Decoder GetDecoder()
public Encoder GetEncoder()
public int GetByteCount(Char* chars, int count)
public int GetByteCount(string s)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetCharCount(Byte* bytes, int count)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public string GetString(Byte[] bytes, int index, int count)
}
public System.Text.UTF8Encoding : Encoding {
internal int UTF8_CODE_PAGE
private bool emitIdentifier
public void .ctor(bool encoderShouldEmitUTF8Identifier)
public void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes)
private int InternalGetByteCount(Char[] chars, int index, int count, Char& leftOver, bool flush)
private int InternalGetByteCount(Char* chars, int count, Char& leftOver, bool flush)
public int GetByteCount(Char[] chars, int index, int count)
public int GetByteCount(Char* chars, int count)
private int InternalGetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, Char& leftOver, bool flush)
private int InternalGetBytes(Char* chars, int count, Byte* bytes, int bcount, Char& leftOver, bool flush)
public int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex)
public int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount)
private int InternalGetCharCount(Byte[] bytes, int index, int count, UInt32 leftOverBits, UInt32 leftOverCount, object provider, DecoderFallbackBuffer& fallbackBuffer, Byte[]& bufferArg, bool flush)
private int InternalGetCharCount(Byte* bytes, int count, UInt32 leftOverBits, UInt32 leftOverCount, object provider, DecoderFallbackBuffer& fallbackBuffer, Byte[]& bufferArg, bool flush)
private int Fallback(object provider, DecoderFallbackBuffer& buffer, Byte[]& bufferArg, Byte* bytes, long index, UInt32 size)
private void Fallback(object provider, DecoderFallbackBuffer& buffer, Byte[]& bufferArg, Byte* bytes, long byteIndex, UInt32 size, Char* chars, Int32& charIndex)
public int GetCharCount(Byte[] bytes, int index, int count)
public int GetCharCount(Byte* bytes, int count)
private int InternalGetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, UInt32& leftOverBits, UInt32& leftOverCount, object provider, DecoderFallbackBuffer& fallbackBuffer, Byte[]& bufferArg, bool flush)
private int InternalGetChars(Byte* bytes, int byteCount, Char* chars, int charCount, UInt32& leftOverBits, UInt32& leftOverCount, object provider, DecoderFallbackBuffer& fallbackBuffer, Byte[]& bufferArg, bool flush)
public int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex)
public int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount)
public int GetMaxByteCount(int charCount)
public int GetMaxCharCount(int byteCount)
public Decoder GetDecoder()
public Encoder GetEncoder()
public Byte[] GetPreamble()
public bool Equals(object value)
public int GetHashCode()
public int GetByteCount(string chars)
public string GetString(Byte[] bytes, int index, int count)
}
public System.Threading.AbandonedMutexException : SystemException {
private Mutex mutex
private int mutex_index
public Mutex Mutex
public int MutexIndex
public void .ctor(string message)
public void .ctor(int location, WaitHandle handle)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception inner)
public void .ctor(string message, int location, WaitHandle handle)
public void .ctor(string message, Exception inner, int location, WaitHandle handle)
public Mutex get_Mutex()
public int get_MutexIndex()
}
public System.Threading.ApartmentState : Enum {
public int value__
public ApartmentState STA
public ApartmentState MTA
public ApartmentState Unknown
}
public System.Threading.AsyncFlowControl : ValueType {
private Thread _t
private AsyncFlowControlType _type
internal void .ctor(Thread t, AsyncFlowControlType type)
private void System.IDisposable.Dispose()
public void Undo()
public int GetHashCode()
public bool Equals(object obj)
public bool Equals(AsyncFlowControl obj)
public bool op_Equality(AsyncFlowControl a, AsyncFlowControl b)
public bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b)
}
internal System.Threading.AsyncFlowControlType : Enum {
public int value__
public AsyncFlowControlType None
public AsyncFlowControlType Execution
public AsyncFlowControlType Security
}
public System.Threading.AutoResetEvent : EventWaitHandle {
public void .ctor(bool initialState)
}
public System.Threading.CompressedStack : object {
private ArrayList _list
internal IList List
internal void .ctor(int length)
internal void .ctor(CompressedStack cs)
public CompressedStack CreateCopy()
public CompressedStack Capture()
public CompressedStack GetCompressedStack()
public void GetObjectData(SerializationInfo info, StreamingContext context)
public void Run(CompressedStack compressedStack, ContextCallback callback, object state)
internal bool Equals(CompressedStack cs)
internal bool IsEmpty()
internal IList get_List()
}
public System.Threading.ContextCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.EventResetMode : Enum {
public int value__
public EventResetMode AutoReset
public EventResetMode ManualReset
}
public System.Threading.EventWaitHandle : WaitHandle {
private void .ctor(IntPtr handle)
public void .ctor(bool initialState, EventResetMode mode)
public void .ctor(bool initialState, EventResetMode mode, string name)
public void .ctor(bool initialState, EventResetMode mode, string name, Boolean& createdNew)
public void .ctor(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity)
private bool IsManualReset(EventResetMode mode)
public EventWaitHandleSecurity GetAccessControl()
public EventWaitHandle OpenExisting(string name)
public EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights)
public bool Reset()
public bool Set()
public void SetAccessControl(EventWaitHandleSecurity eventSecurity)
}
public System.Threading.ExecutionContext : object {
private SecurityContext _sc
private bool _suppressFlow
private bool _capture
internal SecurityContext SecurityContext
internal bool FlowSuppressed
internal void .ctor(ExecutionContext ec)
internal void .ctor(SerializationInfo info, StreamingContext context)
public ExecutionContext Capture()
public ExecutionContext CreateCopy()
public void GetObjectData(SerializationInfo info, StreamingContext context)
internal SecurityContext get_SecurityContext()
internal void set_SecurityContext(SecurityContext value)
internal bool get_FlowSuppressed()
internal void set_FlowSuppressed(bool value)
public bool IsFlowSuppressed()
public void RestoreFlow()
public void Run(ExecutionContext executionContext, ContextCallback callback, object state)
public AsyncFlowControl SuppressFlow()
}
public System.Threading.HostExecutionContext : object {
private object _state
protected internal object State
public void .ctor(object state)
public HostExecutionContext CreateCopy()
protected internal object get_State()
protected internal void set_State(object value)
}
public System.Threading.HostExecutionContextManager : object {
public HostExecutionContext Capture()
public void Revert(object previousState)
public object SetHostExecutionContext(HostExecutionContext hostExecutionContext)
}
public System.Threading.Interlocked : object {
public int CompareExchange(Int32& location1, int value, int comparand)
public object CompareExchange(Object& location1, object value, object comparand)
public float CompareExchange(Single& location1, float value, float comparand)
public int Decrement(Int32& location)
public long Decrement(Int64& location)
public int Increment(Int32& location)
public long Increment(Int64& location)
public int Exchange(Int32& location1, int value)
public object Exchange(Object& location1, object value)
public float Exchange(Single& location1, float value)
public long CompareExchange(Int64& location1, long value, long comparand)
public IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand)
public double CompareExchange(Double& location1, double value, double comparand)
public T CompareExchange(T& location1, T value, T comparand)
public long Exchange(Int64& location1, long value)
public IntPtr Exchange(IntPtr& location1, IntPtr value)
public double Exchange(Double& location1, double value)
public T Exchange(T& location1, T value)
public long Read(Int64& location)
public int Add(Int32& location1, int value)
public long Add(Int64& location1, long value)
}
public System.Threading.IOCompletionCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP)
public IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.LockCookie : ValueType {
internal int ThreadId
internal int ReaderLocks
internal int WriterLocks
internal void .ctor(int thread_id)
internal void .ctor(int thread_id, int reader_locks, int writer_locks)
public int GetHashCode()
public bool Equals(LockCookie obj)
public bool Equals(object obj)
public bool op_Equality(LockCookie a, LockCookie b)
public bool op_Inequality(LockCookie a, LockCookie b)
}
internal System.Threading.LockQueue : object {
private ReaderWriterLock rwlock
private int lockCount
public bool IsEmpty
public void .ctor(ReaderWriterLock rwlock)
public bool Wait(int timeout)
public bool get_IsEmpty()
public void Pulse()
public void PulseAll()
}
public System.Threading.ManualResetEvent : EventWaitHandle {
public void .ctor(bool initialState)
}
public System.Threading.Monitor : object {
private bool Monitor_try_enter(object obj, int ms)
public void Enter(object obj)
public void Exit(object obj)
private void Monitor_pulse(object obj)
private bool Monitor_test_synchronised(object obj)
public void Pulse(object obj)
private void Monitor_pulse_all(object obj)
public void PulseAll(object obj)
public bool TryEnter(object obj)
public bool TryEnter(object obj, int millisecondsTimeout)
public bool TryEnter(object obj, TimeSpan timeout)
private bool Monitor_wait(object obj, int ms)
public bool Wait(object obj)
public bool Wait(object obj, int millisecondsTimeout)
public bool Wait(object obj, TimeSpan timeout)
public bool Wait(object obj, int millisecondsTimeout, bool exitContext)
public bool Wait(object obj, TimeSpan timeout, bool exitContext)
}
public System.Threading.Mutex : WaitHandle {
private void .ctor(IntPtr handle)
public void .ctor(bool initiallyOwned)
public void .ctor(bool initiallyOwned, string name)
public void .ctor(bool initiallyOwned, string name, Boolean& createdNew)
public void .ctor(bool initiallyOwned, string name, Boolean& createdNew, MutexSecurity mutexSecurity)
private IntPtr CreateMutex_internal(bool initiallyOwned, string name, Boolean& created)
private bool ReleaseMutex_internal(IntPtr handle)
private IntPtr OpenMutex_internal(string name, MutexRights rights, MonoIOError& error)
public MutexSecurity GetAccessControl()
public Mutex OpenExisting(string name)
public Mutex OpenExisting(string name, MutexRights rights)
public void ReleaseMutex()
public void SetAccessControl(MutexSecurity mutexSecurity)
}
internal System.Threading.NativeEventCalls : object {
public IntPtr CreateEvent_internal(bool manual, bool initial, string name, Boolean& created)
public bool SetEvent_internal(IntPtr handle)
public bool ResetEvent_internal(IntPtr handle)
public void CloseEvent_internal(IntPtr handle)
public IntPtr OpenEvent_internal(string name, EventWaitHandleRights rights, MonoIOError& error)
}
public System.Threading.NativeOverlapped : ValueType {
public IntPtr EventHandle
public IntPtr InternalHigh
public IntPtr InternalLow
public int OffsetHigh
public int OffsetLow
internal int Handle1
internal int Handle2
}
public System.Threading.Overlapped : object {
private IAsyncResult ares
private int offsetL
private int offsetH
private int evt
private IntPtr evt_ptr
public IAsyncResult AsyncResult
public int EventHandle
public IntPtr EventHandleIntPtr
public int OffsetHigh
public int OffsetLow
public void .ctor(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar)
public void .ctor(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar)
public void Free(NativeOverlapped* nativeOverlappedPtr)
public Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr)
public NativeOverlapped* Pack(IOCompletionCallback iocb)
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData)
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb)
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData)
public IAsyncResult get_AsyncResult()
public void set_AsyncResult(IAsyncResult value)
public int get_EventHandle()
public void set_EventHandle(int value)
public IntPtr get_EventHandleIntPtr()
public void set_EventHandleIntPtr(IntPtr value)
public int get_OffsetHigh()
public void set_OffsetHigh(int value)
public int get_OffsetLow()
public void set_OffsetLow(int value)
}
public System.Threading.ParameterizedThreadStart : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object obj)
public IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.ReaderWriterLock : CriticalFinalizerObject {
private int seq_num
private int state
private int readers
private LockQueue writer_queue
private Hashtable reader_locks
private int writer_lock_owner
public bool IsReaderLockHeld
public bool IsWriterLockHeld
public int WriterSeqNum
protected void Finalize()
public bool get_IsReaderLockHeld()
public bool get_IsWriterLockHeld()
public int get_WriterSeqNum()
public void AcquireReaderLock(int millisecondsTimeout)
private void AcquireReaderLock(int millisecondsTimeout, int initialLockCount)
public void AcquireReaderLock(TimeSpan timeout)
public void AcquireWriterLock(int millisecondsTimeout)
private void AcquireWriterLock(int millisecondsTimeout, int initialLockCount)
public void AcquireWriterLock(TimeSpan timeout)
public bool AnyWritersSince(int seqNum)
public void DowngradeFromWriterLock(LockCookie& lockCookie)
public LockCookie ReleaseLock()
public void ReleaseReaderLock()
private void ReleaseReaderLock(int currentCount, int releaseCount)
public void ReleaseWriterLock()
private void ReleaseWriterLock(int releaseCount)
public void RestoreLock(LockCookie& lockCookie)
public LockCookie UpgradeToWriterLock(int millisecondsTimeout)
public LockCookie UpgradeToWriterLock(TimeSpan timeout)
private LockCookie GetLockCookie()
private bool HasWriterLock()
private int CheckTimeout(TimeSpan timeout)
}
public System.Threading.RegisteredWaitHandle : MarshalByRefObject {
private WaitHandle _waitObject
private WaitOrTimerCallback _callback
private TimeSpan _timeout
private object _state
private bool _executeOnlyOnce
private WaitHandle _finalEvent
private ManualResetEvent _cancelEvent
private int _callsInProcess
private bool _unregistered
internal void .ctor(WaitHandle waitObject, WaitOrTimerCallback callback, object state, TimeSpan timeout, bool executeOnlyOnce)
internal void Wait(object state)
private void DoCallBack(object timedOut)
public bool Unregister(WaitHandle waitObject)
}
public System.Threading.SendOrPostCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.SynchronizationContext : object {
private bool notification_required
private SynchronizationContext currentContext
public SynchronizationContext Current
internal void .ctor(SynchronizationContext context)
public SynchronizationContext get_Current()
public SynchronizationContext CreateCopy()
public bool IsWaitNotificationRequired()
public void OperationCompleted()
public void OperationStarted()
public void Post(SendOrPostCallback d, object state)
public void Send(SendOrPostCallback d, object state)
public void SetSynchronizationContext(SynchronizationContext syncContext)
protected void SetWaitNotificationRequired()
public int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout)
protected int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout)
}
public System.Threading.SynchronizationLockException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Threading.Thread : CriticalFinalizerObject {
private int lock_thread_id
private IntPtr system_thread_handle
private object cached_culture_info
private IntPtr unused0
private bool threadpool_thread
private IntPtr name
private int name_len
private ThreadState state
private object abort_exc
private int abort_state_handle
private long thread_id
private IntPtr start_notify
private IntPtr stack_ptr
private UIntPtr static_data
private IntPtr jit_data
private IntPtr lock_data
private object current_appcontext
private int stack_size
private object start_obj
private IntPtr appdomain_refs
private int interruption_requested
private IntPtr suspend_event
private IntPtr suspended_event
private IntPtr resume_event
private IntPtr synch_cs
private IntPtr serialized_culture_info
private int serialized_culture_info_len
private IntPtr serialized_ui_culture_info
private int serialized_ui_culture_info_len
private bool thread_dump_requested
private IntPtr end_stack
private bool thread_interrupt_requested
private byte apartment_state
private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) critical_region_level
private int small_id
private IntPtr manage_callback
private object pending_exception
private ExecutionContext ec_to_set
private IntPtr interrupt_on_stop
private IntPtr unused3
private IntPtr unused4
private IntPtr unused5
private IntPtr unused6
private Object[] local_slots
private ExecutionContext _ec
private MulticastDelegate threadstart
private int managed_id
private IPrincipal _principal
private Hashtable datastorehash
private object datastore_lock
private bool in_currentculture
private object culture_lock
public Context CurrentContext
public IPrincipal CurrentPrincipal
public Thread CurrentThread
internal int CurrentThreadId
public ApartmentState ApartmentState
public CultureInfo CurrentCulture
public CultureInfo CurrentUICulture
public bool IsThreadPoolThread
internal bool IsThreadPoolThreadInternal
public bool IsAlive
public bool IsBackground
public string Name
public ThreadPriority Priority
public ThreadState ThreadState
public ExecutionContext ExecutionContext
public int ManagedThreadId
public void .ctor(ThreadStart start)
public void .ctor(ThreadStart start, int maxStackSize)
public void .ctor(ParameterizedThreadStart start)
public void .ctor(ParameterizedThreadStart start, int maxStackSize)
private void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Thread.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
public Context get_CurrentContext()
public IPrincipal get_CurrentPrincipal()
public void set_CurrentPrincipal(IPrincipal value)
private Thread CurrentThread_internal()
public Thread get_CurrentThread()
internal int get_CurrentThreadId()
private void InitDataStoreHash()
public LocalDataStoreSlot AllocateNamedDataSlot(string name)
public void FreeNamedDataSlot(string name)
public LocalDataStoreSlot AllocateDataSlot()
public object GetData(LocalDataStoreSlot slot)
public void SetData(LocalDataStoreSlot slot, object data)
internal void FreeLocalSlotValues(int slot, bool thread_local)
public LocalDataStoreSlot GetNamedDataSlot(string name)
public AppDomain GetDomain()
public int GetDomainID()
private void ResetAbort_internal()
public void ResetAbort()
private void Sleep_internal(int ms)
public void Sleep(int millisecondsTimeout)
public void Sleep(TimeSpan timeout)
private IntPtr Thread_internal(MulticastDelegate start)
private void Thread_init()
public ApartmentState get_ApartmentState()
public void set_ApartmentState(ApartmentState value)
private CultureInfo GetCachedCurrentCulture()
private Byte[] GetSerializedCurrentCulture()
private void SetCachedCurrentCulture(CultureInfo culture)
private void SetSerializedCurrentCulture(Byte[] culture)
private CultureInfo GetCachedCurrentUICulture()
private Byte[] GetSerializedCurrentUICulture()
private void SetCachedCurrentUICulture(CultureInfo culture)
private void SetSerializedCurrentUICulture(Byte[] culture)
public CultureInfo get_CurrentCulture()
public void set_CurrentCulture(CultureInfo value)
public CultureInfo get_CurrentUICulture()
public void set_CurrentUICulture(CultureInfo value)
public bool get_IsThreadPoolThread()
internal bool get_IsThreadPoolThreadInternal()
internal void set_IsThreadPoolThreadInternal(bool value)
public bool get_IsAlive()
public bool get_IsBackground()
public void set_IsBackground(bool value)
private string GetName_internal()
private void SetName_internal(string name)
public string get_Name()
public void set_Name(string value)
public ThreadPriority get_Priority()
public void set_Priority(ThreadPriority value)
public ThreadState get_ThreadState()
private void Abort_internal(object stateInfo)
public void Abort()
public void Abort(object stateInfo)
internal object GetAbortExceptionState()
private void Interrupt_internal()
public void Interrupt()
private bool Join_internal(int ms, IntPtr handle)
public void Join()
public bool Join(int millisecondsTimeout)
public bool Join(TimeSpan timeout)
public void MemoryBarrier()
private void Resume_internal()
public void Resume()
private void SpinWait_nop()
public void SpinWait(int iterations)
public void Start()
private void Suspend_internal()
public void Suspend()
private void Thread_free_internal(IntPtr handle)
protected void Finalize()
private void SetState(ThreadState set)
private void ClrState(ThreadState clr)
private ThreadState GetState()
public byte VolatileRead(Byte& address)
public double VolatileRead(Double& address)
public short VolatileRead(Int16& address)
public int VolatileRead(Int32& address)
public long VolatileRead(Int64& address)
public IntPtr VolatileRead(IntPtr& address)
public object VolatileRead(Object& address)
public sbyte VolatileRead(SByte& address)
public float VolatileRead(Single& address)
public ushort VolatileRead(UInt16& address)
public UInt32 VolatileRead(UInt32& address)
public ulong VolatileRead(UInt64& address)
public UIntPtr VolatileRead(UIntPtr& address)
public void VolatileWrite(Byte& address, byte value)
public void VolatileWrite(Double& address, double value)
public void VolatileWrite(Int16& address, short value)
public void VolatileWrite(Int32& address, int value)
public void VolatileWrite(Int64& address, long value)
public void VolatileWrite(IntPtr& address, IntPtr value)
public void VolatileWrite(Object& address, object value)
public void VolatileWrite(SByte& address, sbyte value)
public void VolatileWrite(Single& address, float value)
public void VolatileWrite(UInt16& address, ushort value)
public void VolatileWrite(UInt32& address, UInt32 value)
public void VolatileWrite(UInt64& address, ulong value)
public void VolatileWrite(UIntPtr& address, UIntPtr value)
private int GetNewManagedId()
private int GetNewManagedId_internal()
public ExecutionContext get_ExecutionContext()
public int get_ManagedThreadId()
public void BeginCriticalRegion()
public void EndCriticalRegion()
public void BeginThreadAffinity()
public void EndThreadAffinity()
public ApartmentState GetApartmentState()
public void SetApartmentState(ApartmentState state)
public bool TrySetApartmentState(ApartmentState state)
public int GetHashCode()
public void Start(object parameter)
public CompressedStack GetCompressedStack()
public void SetCompressedStack(CompressedStack stack)
}
public System.Threading.ThreadAbortException : SystemException {
public object ExceptionState
private void .ctor(SerializationInfo info, StreamingContext sc)
public object get_ExceptionState()
}
public System.Threading.ThreadInterruptedException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Threading.ThreadPool : object {
public bool BindHandle(IntPtr osHandle)
public bool BindHandle(SafeHandle osHandle)
public void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads)
public void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads)
public void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads)
public bool SetMinThreads(int workerThreads, int completionPortThreads)
public bool SetMaxThreads(int workerThreads, int completionPortThreads)
public bool QueueUserWorkItem(WaitCallback callBack)
public bool QueueUserWorkItem(WaitCallback callBack, object state)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)
public RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce)
public bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped)
public bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce)
public RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce)
}
public System.Threading.ThreadPriority : Enum {
public int value__
public ThreadPriority Lowest
public ThreadPriority BelowNormal
public ThreadPriority Normal
public ThreadPriority AboveNormal
public ThreadPriority Highest
}
public System.Threading.ThreadStart : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke()
public IAsyncResult BeginInvoke(AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.ThreadStartException : SystemException {
internal void .ctor(string message)
internal void .ctor(SerializationInfo info, StreamingContext context)
internal void .ctor(string message, Exception innerException)
}
public System.Threading.ThreadState : Enum {
public int value__
public ThreadState Running
public ThreadState StopRequested
public ThreadState SuspendRequested
public ThreadState Background
public ThreadState Unstarted
public ThreadState Stopped
public ThreadState WaitSleepJoin
public ThreadState Suspended
public ThreadState AbortRequested
public ThreadState Aborted
}
public System.Threading.ThreadStateException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.Threading.Timeout : object {
public int Infinite
}
public System.Threading.Timer : MarshalByRefObject {
private long MaxValue
private Scheduler scheduler
private TimerCallback callback
private object state
private long due_time_ms
private long period_ms
private long next_run
private bool disposed
public void .ctor(TimerCallback callback, object state, int dueTime, int period)
public void .ctor(TimerCallback callback, object state, long dueTime, long period)
public void .ctor(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period)
public void .ctor(TimerCallback callback, object state, UInt32 dueTime, UInt32 period)
public void .ctor(TimerCallback callback)
private void Init(TimerCallback callback, object state, long dueTime, long period)
public bool Change(int dueTime, int period)
public bool Change(TimeSpan dueTime, TimeSpan period)
public bool Change(UInt32 dueTime, UInt32 period)
public void Dispose()
public bool Change(long dueTime, long period)
private bool Change(long dueTime, long period, bool first)
public bool Dispose(WaitHandle notifyObject)
}
public System.Threading.TimerCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.WaitCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state)
public IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.Threading.WaitHandle : MarshalByRefObject {
public int WaitTimeout
private SafeWaitHandle safe_wait_handle
protected IntPtr InvalidHandle
private bool disposed
public IntPtr Handle
public SafeWaitHandle SafeWaitHandle
private void System.IDisposable.Dispose()
private bool WaitAll_internal(WaitHandle[] handles, int ms, bool exitContext)
private void CheckArray(WaitHandle[] handles, bool waitAll)
public bool WaitAll(WaitHandle[] waitHandles)
public bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
public bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)
private int WaitAny_internal(WaitHandle[] handles, int ms, bool exitContext)
public int WaitAny(WaitHandle[] waitHandles)
public int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext)
public int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout)
public int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout)
public int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext)
public void Close()
public IntPtr get_Handle()
public void set_Handle(IntPtr value)
private bool WaitOne_internal(IntPtr handle, int ms, bool exitContext)
protected void Dispose(bool explicitDisposing)
public SafeWaitHandle get_SafeWaitHandle()
public void set_SafeWaitHandle(SafeWaitHandle value)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext)
public bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext)
private bool SignalAndWait_Internal(IntPtr toSignal, IntPtr toWaitOn, int ms, bool exitContext)
public bool WaitOne()
public bool WaitOne(int millisecondsTimeout, bool exitContext)
public bool WaitOne(int millisecondsTimeout)
public bool WaitOne(TimeSpan timeout)
public bool WaitOne(TimeSpan timeout, bool exitContext)
internal void CheckDisposed()
public bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout)
public bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout)
protected void Finalize()
}
public System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.Threading.WaitOrTimerCallback : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object state, bool timedOut)
public IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
public System.TimeoutException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception innerException)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.TimeSpan : ValueType {
public long TicksPerDay
public long TicksPerHour
public long TicksPerMillisecond
public long TicksPerMinute
public long TicksPerSecond
public TimeSpan MaxValue
public TimeSpan MinValue
public TimeSpan Zero
private long _ticks
public int Days
public int Hours
public int Milliseconds
public int Minutes
public int Seconds
public long Ticks
public double TotalDays
public double TotalHours
public double TotalMilliseconds
public double TotalMinutes
public double TotalSeconds
public void .ctor(long ticks)
public void .ctor(int hours, int minutes, int seconds)
public void .ctor(int days, int hours, int minutes, int seconds)
public void .ctor(int days, int hours, int minutes, int seconds, int milliseconds)
internal long CalculateTicks(int days, int hours, int minutes, int seconds, int milliseconds)
public int get_Days()
public int get_Hours()
public int get_Milliseconds()
public int get_Minutes()
public int get_Seconds()
public long get_Ticks()
public double get_TotalDays()
public double get_TotalHours()
public double get_TotalMilliseconds()
public double get_TotalMinutes()
public double get_TotalSeconds()
public TimeSpan Add(TimeSpan ts)
public int Compare(TimeSpan t1, TimeSpan t2)
public int CompareTo(object value)
public int CompareTo(TimeSpan value)
public bool Equals(TimeSpan obj)
public TimeSpan Duration()
public bool Equals(object value)
public bool Equals(TimeSpan t1, TimeSpan t2)
public TimeSpan FromDays(double value)
public TimeSpan FromHours(double value)
public TimeSpan FromMinutes(double value)
public TimeSpan FromSeconds(double value)
public TimeSpan FromMilliseconds(double value)
private TimeSpan From(double value, long tickMultiplicator)
public TimeSpan FromTicks(long value)
public int GetHashCode()
public TimeSpan Negate()
public TimeSpan Parse(string s)
public bool TryParse(string s, TimeSpan& result)
public TimeSpan Subtract(TimeSpan ts)
public string ToString()
public TimeSpan op_Addition(TimeSpan t1, TimeSpan t2)
public bool op_Equality(TimeSpan t1, TimeSpan t2)
public bool op_GreaterThan(TimeSpan t1, TimeSpan t2)
public bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2)
public bool op_Inequality(TimeSpan t1, TimeSpan t2)
public bool op_LessThan(TimeSpan t1, TimeSpan t2)
public bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2)
public TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2)
public TimeSpan op_UnaryNegation(TimeSpan t)
public TimeSpan op_UnaryPlus(TimeSpan t)
}
public System.TimeZone : object {
private TimeZone currentTimeZone
private object tz_lock
private long timezone_check
public TimeZone CurrentTimeZone
public string DaylightName
public string StandardName
public TimeZone get_CurrentTimeZone()
public string get_DaylightName()
public string get_StandardName()
public DaylightTime GetDaylightChanges(int year)
public TimeSpan GetUtcOffset(DateTime time)
public bool IsDaylightSavingTime(DateTime time)
public bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes)
public DateTime ToLocalTime(DateTime time)
public DateTime ToUniversalTime(DateTime time)
internal TimeSpan GetLocalTimeDiff(DateTime time)
internal TimeSpan GetLocalTimeDiff(DateTime time, TimeSpan utc_offset)
}
public System.Type : MemberInfo {
internal BindingFlags DefaultBindingFlags
internal RuntimeTypeHandle _impl
public char Delimiter
public Type[] EmptyTypes
public MemberFilter FilterAttribute
public MemberFilter FilterName
public MemberFilter FilterNameIgnoreCase
public object Missing
public Assembly Assembly
public string AssemblyQualifiedName
public TypeAttributes Attributes
public Type BaseType
public Type DeclaringType
public Binder DefaultBinder
public string FullName
public Guid GUID
public bool HasElementType
public bool IsAbstract
public bool IsAnsiClass
public bool IsArray
public bool IsAutoClass
public bool IsAutoLayout
public bool IsByRef
public bool IsClass
public bool IsCOMObject
public bool IsContextful
public bool IsEnum
public bool IsExplicitLayout
public bool IsImport
public bool IsInterface
public bool IsLayoutSequential
public bool IsMarshalByRef
public bool IsNestedAssembly
public bool IsNestedFamANDAssem
public bool IsNestedFamily
public bool IsNestedFamORAssem
public bool IsNestedPrivate
public bool IsNestedPublic
public bool IsNotPublic
public bool IsPointer
public bool IsPrimitive
public bool IsPublic
public bool IsSealed
public bool IsSerializable
public bool IsSpecialName
public bool IsUnicodeClass
public bool IsValueType
public MemberTypes MemberType
public Module Module
public string Namespace
public Type ReflectedType
public RuntimeTypeHandle TypeHandle
public ConstructorInfo TypeInitializer
public Type UnderlyingSystemType
internal bool IsSystemType
public bool ContainsGenericParameters
public bool IsGenericTypeDefinition
public bool IsGenericType
public bool IsGenericParameter
public bool IsNested
public bool IsVisible
public int GenericParameterPosition
public GenericParameterAttributes GenericParameterAttributes
public MethodBase DeclaringMethod
public StructLayoutAttribute StructLayoutAttribute
internal bool IsUserType
private void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid& riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId)
private void System.Runtime.InteropServices._Type.GetTypeInfo(UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo)
private void System.Runtime.InteropServices._Type.GetTypeInfoCount(UInt32& pcTInfo)
private void System.Runtime.InteropServices._Type.Invoke(UInt32 dispIdMember, Guid& riid, UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr)
private bool FilterName_impl(MemberInfo m, object filterCriteria)
private bool FilterNameIgnoreCase_impl(MemberInfo m, object filterCriteria)
private bool FilterAttribute_impl(MemberInfo m, object filterCriteria)
public Assembly get_Assembly()
public string get_AssemblyQualifiedName()
public TypeAttributes get_Attributes()
public Type get_BaseType()
public Type get_DeclaringType()
public Binder get_DefaultBinder()
public string get_FullName()
public Guid get_GUID()
public bool get_HasElementType()
public bool get_IsAbstract()
public bool get_IsAnsiClass()
public bool get_IsArray()
public bool get_IsAutoClass()
public bool get_IsAutoLayout()
public bool get_IsByRef()
public bool get_IsClass()
public bool get_IsCOMObject()
public bool get_IsContextful()
public bool get_IsEnum()
public bool get_IsExplicitLayout()
public bool get_IsImport()
public bool get_IsInterface()
public bool get_IsLayoutSequential()
public bool get_IsMarshalByRef()
public bool get_IsNestedAssembly()
public bool get_IsNestedFamANDAssem()
public bool get_IsNestedFamily()
public bool get_IsNestedFamORAssem()
public bool get_IsNestedPrivate()
public bool get_IsNestedPublic()
public bool get_IsNotPublic()
public bool get_IsPointer()
public bool get_IsPrimitive()
public bool get_IsPublic()
public bool get_IsSealed()
public bool get_IsSerializable()
public bool get_IsSpecialName()
public bool get_IsUnicodeClass()
public bool get_IsValueType()
public MemberTypes get_MemberType()
public Module get_Module()
public string get_Namespace()
public Type get_ReflectedType()
public RuntimeTypeHandle get_TypeHandle()
public ConstructorInfo get_TypeInitializer()
public Type get_UnderlyingSystemType()
public bool Equals(object o)
public bool Equals(Type o)
internal bool EqualsInternal(Type type)
private Type internal_from_handle(IntPtr handle)
private Type internal_from_name(string name, bool throwOnError, bool ignoreCase)
public Type GetType(string typeName)
public Type GetType(string typeName, bool throwOnError)
public Type GetType(string typeName, bool throwOnError, bool ignoreCase)
public Type[] GetTypeArray(Object[] args)
internal TypeCode GetTypeCodeInternal(Type type)
public TypeCode GetTypeCode(Type type)
public Type GetTypeFromCLSID(Guid clsid)
public Type GetTypeFromCLSID(Guid clsid, bool throwOnError)
public Type GetTypeFromCLSID(Guid clsid, string server)
public Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError)
public Type GetTypeFromHandle(RuntimeTypeHandle handle)
public Type GetTypeFromProgID(string progID)
public Type GetTypeFromProgID(string progID, bool throwOnError)
public Type GetTypeFromProgID(string progID, string server)
public Type GetTypeFromProgID(string progID, string server, bool throwOnError)
public RuntimeTypeHandle GetTypeHandle(object o)
internal bool type_is_subtype_of(Type a, Type b, bool check_interfaces)
internal bool type_is_assignable_from(Type a, Type b)
public Type GetType()
public bool IsSubclassOf(Type c)
public Type[] FindInterfaces(TypeFilter filter, object filterCriteria)
public Type GetInterface(string name)
public Type GetInterface(string name, bool ignoreCase)
internal void GetInterfaceMapData(Type t, Type iface, MethodInfo[]& targets, MethodInfo[]& methods)
public InterfaceMapping GetInterfaceMap(Type interfaceType)
public Type[] GetInterfaces()
public bool IsAssignableFrom(Type c)
public bool IsInstanceOfType(object o)
public int GetArrayRank()
public Type GetElementType()
public EventInfo GetEvent(string name)
public EventInfo GetEvent(string name, BindingFlags bindingAttr)
public EventInfo[] GetEvents()
public EventInfo[] GetEvents(BindingFlags bindingAttr)
public FieldInfo GetField(string name)
public FieldInfo GetField(string name, BindingFlags bindingAttr)
public FieldInfo[] GetFields()
public FieldInfo[] GetFields(BindingFlags bindingAttr)
public int GetHashCode()
public MemberInfo[] GetMember(string name)
public MemberInfo[] GetMember(string name, BindingFlags bindingAttr)
public MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr)
public MemberInfo[] GetMembers()
public MemberInfo[] GetMembers(BindingFlags bindingAttr)
public MethodInfo GetMethod(string name)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr)
public MethodInfo GetMethod(string name, Type[] types)
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
internal MethodInfo GetMethodImplInternal(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
internal MethodInfo GetMethod(MethodInfo fromNoninstanciated)
internal ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated)
internal FieldInfo GetField(FieldInfo fromNoninstanciated)
public MethodInfo[] GetMethods()
public MethodInfo[] GetMethods(BindingFlags bindingAttr)
public Type GetNestedType(string name)
public Type GetNestedType(string name, BindingFlags bindingAttr)
public Type[] GetNestedTypes()
public Type[] GetNestedTypes(BindingFlags bindingAttr)
public PropertyInfo[] GetProperties()
public PropertyInfo[] GetProperties(BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr)
public PropertyInfo GetProperty(string name, Type returnType)
public PropertyInfo GetProperty(string name, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types)
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers)
public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
internal PropertyInfo GetPropertyImplInternal(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
protected ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
protected TypeAttributes GetAttributeFlagsImpl()
protected bool HasElementTypeImpl()
protected bool IsArrayImpl()
protected bool IsByRefImpl()
protected bool IsCOMObjectImpl()
protected bool IsPointerImpl()
protected bool IsPrimitiveImpl()
internal bool IsArrayImpl(Type type)
protected bool IsValueTypeImpl()
protected bool IsContextfulImpl()
protected bool IsMarshalByRefImpl()
public ConstructorInfo GetConstructor(Type[] types)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
public ConstructorInfo[] GetConstructors()
public ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
public MemberInfo[] GetDefaultMembers()
public MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture)
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters)
public string ToString()
internal bool get_IsSystemType()
public Type[] GetGenericArguments()
public bool get_ContainsGenericParameters()
public bool get_IsGenericTypeDefinition()
internal Type GetGenericTypeDefinition_impl()
public Type GetGenericTypeDefinition()
public bool get_IsGenericType()
private Type MakeGenericType(Type gt, Type[] types)
public Type MakeGenericType(Type[] typeArguments)
public bool get_IsGenericParameter()
public bool get_IsNested()
public bool get_IsVisible()
private int GetGenericParameterPosition()
public int get_GenericParameterPosition()
private GenericParameterAttributes GetGenericParameterAttributes()
public GenericParameterAttributes get_GenericParameterAttributes()
private Type[] GetGenericParameterConstraints_impl()
public Type[] GetGenericParameterConstraints()
public MethodBase get_DeclaringMethod()
private Type make_array_type(int rank)
public Type MakeArrayType()
public Type MakeArrayType(int rank)
private Type make_byref_type()
public Type MakeByRefType()
public Type MakePointerType()
public Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase)
private void GetPacking(Int32& packing, Int32& size)
public StructLayoutAttribute get_StructLayoutAttribute()
internal Object[] GetPseudoCustomAttributes()
internal bool get_IsUserType()
}
public System.TypeCode : Enum {
public int value__
public TypeCode Empty
public TypeCode Object
public TypeCode DBNull
public TypeCode Boolean
public TypeCode Char
public TypeCode SByte
public TypeCode Byte
public TypeCode Int16
public TypeCode UInt16
public TypeCode Int32
public TypeCode UInt32
public TypeCode Int64
public TypeCode UInt64
public TypeCode Single
public TypeCode Double
public TypeCode Decimal
public TypeCode DateTime
public TypeCode String
}
public System.TypedReference : ValueType {
private RuntimeTypeHandle type
private IntPtr value
private IntPtr klass
public bool Equals(object o)
public int GetHashCode()
public Type GetTargetType(TypedReference value)
public TypedReference MakeTypedReference(object target, FieldInfo[] flds)
public void SetTypedReference(TypedReference target, object value)
public RuntimeTypeHandle TargetTypeToken(TypedReference value)
public object ToObject(TypedReference value)
}
public System.TypeInitializationException : SystemException {
private string type_name
public string TypeName
public void .ctor(string fullTypeName, Exception innerException)
internal void .ctor(SerializationInfo info, StreamingContext context)
public string get_TypeName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.TypeLoadException : SystemException {
private int Result
private string className
private string assemblyName
public string Message
public string TypeName
public void .ctor(string message)
public void .ctor(string message, Exception inner)
internal void .ctor(string className, string assemblyName)
protected void .ctor(SerializationInfo info, StreamingContext context)
public string get_Message()
public string get_TypeName()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
public System.TypeUnloadedException : SystemException {
public void .ctor(string message)
protected void .ctor(SerializationInfo info, StreamingContext context)
public void .ctor(string message, Exception innerException)
}
public System.UInt16 : ValueType {
public ushort MaxValue
public ushort MinValue
internal ushort m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(ushort value)
public bool Equals(ushort obj)
public ushort Parse(string s, IFormatProvider provider)
public ushort Parse(string s, NumberStyles style)
public ushort Parse(string s, NumberStyles style, IFormatProvider provider)
public ushort Parse(string s)
public bool TryParse(string s, UInt16& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.UInt32 : ValueType {
public UInt32 MaxValue
public UInt32 MinValue
internal UInt32 m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(UInt32 value)
public bool Equals(UInt32 obj)
internal bool Parse(string s, bool tryParse, UInt32& result, Exception& exc)
internal bool Parse(string s, NumberStyles style, IFormatProvider provider, bool tryParse, UInt32& result, Exception& exc)
public UInt32 Parse(string s)
public UInt32 Parse(string s, NumberStyles style, IFormatProvider provider)
public UInt32 Parse(string s, IFormatProvider provider)
public UInt32 Parse(string s, NumberStyles style)
public bool TryParse(string s, UInt32& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.UInt64 : ValueType {
public ulong MaxValue
public ulong MinValue
internal ulong m_value
private bool System.IConvertible.ToBoolean(IFormatProvider provider)
private byte System.IConvertible.ToByte(IFormatProvider provider)
private char System.IConvertible.ToChar(IFormatProvider provider)
private DateTime System.IConvertible.ToDateTime(IFormatProvider provider)
private decimal System.IConvertible.ToDecimal(IFormatProvider provider)
private double System.IConvertible.ToDouble(IFormatProvider provider)
private short System.IConvertible.ToInt16(IFormatProvider provider)
private int System.IConvertible.ToInt32(IFormatProvider provider)
private long System.IConvertible.ToInt64(IFormatProvider provider)
private sbyte System.IConvertible.ToSByte(IFormatProvider provider)
private float System.IConvertible.ToSingle(IFormatProvider provider)
private object System.IConvertible.ToType(Type targetType, IFormatProvider provider)
private ushort System.IConvertible.ToUInt16(IFormatProvider provider)
private UInt32 System.IConvertible.ToUInt32(IFormatProvider provider)
private ulong System.IConvertible.ToUInt64(IFormatProvider provider)
public int CompareTo(object value)
public bool Equals(object obj)
public int GetHashCode()
public int CompareTo(ulong value)
public bool Equals(ulong obj)
public ulong Parse(string s)
public ulong Parse(string s, IFormatProvider provider)
public ulong Parse(string s, NumberStyles style)
internal bool Parse(string s, NumberStyles style, IFormatProvider provider, bool tryParse, UInt64& result, Exception& exc)
public ulong Parse(string s, NumberStyles style, IFormatProvider provider)
public bool TryParse(string s, UInt64& result)
public bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result)
public string ToString()
public string ToString(IFormatProvider provider)
public string ToString(string format)
public string ToString(string format, IFormatProvider provider)
public TypeCode GetTypeCode()
}
public System.UIntPtr : ValueType {
public UIntPtr Zero
private Void* _pointer
public int Size
public void .ctor(ulong value)
public void .ctor(UInt32 value)
public void .ctor(Void* value)
private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
public bool Equals(object obj)
public int GetHashCode()
public UInt32 ToUInt32()
public ulong ToUInt64()
public Void* ToPointer()
public string ToString()
public int get_Size()
public bool op_Equality(UIntPtr value1, UIntPtr value2)
public bool op_Inequality(UIntPtr value1, UIntPtr value2)
public ulong op_Explicit(UIntPtr value)
public UInt32 op_Explicit(UIntPtr value)
public UIntPtr op_Explicit(ulong value)
public UIntPtr op_Explicit(Void* value)
public Void* op_Explicit(UIntPtr value)
public UIntPtr op_Explicit(UInt32 value)
}
public System.UnauthorizedAccessException : SystemException {
private int Result
public void .ctor(string message)
public void .ctor(string message, Exception inner)
protected void .ctor(SerializationInfo info, StreamingContext context)
}
public System.UnhandledExceptionEventArgs : EventArgs {
private object exception
private bool m_isTerminating
public object ExceptionObject
public bool IsTerminating
public void .ctor(object exception, bool isTerminating)
public object get_ExceptionObject()
public bool get_IsTerminating()
}
public System.UnhandledExceptionEventHandler : MulticastDelegate {
public void .ctor(object object, IntPtr method)
public void Invoke(object sender, UnhandledExceptionEventArgs e)
public IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object)
public void EndInvoke(IAsyncResult result)
}
internal System.UnitySerializationHolder : object {
private string _data
private UnityType _unityType
private string _assemblyName
private void .ctor(SerializationInfo info, StreamingContext ctx)
public void GetTypeData(Type instance, SerializationInfo info, StreamingContext ctx)
public void GetDBNullData(DBNull instance, SerializationInfo info, StreamingContext ctx)
public void GetAssemblyData(Assembly instance, SerializationInfo info, StreamingContext ctx)
public void GetModuleData(Module instance, SerializationInfo info, StreamingContext ctx)
public void GetObjectData(SerializationInfo info, StreamingContext context)
public object GetRealObject(StreamingContext context)
}
public System.ValueType : object {
private bool InternalEquals(object o1, object o2, Object[]& fields)
internal bool DefaultEquals(object o1, object o2)
public bool Equals(object obj)
internal int InternalGetHashCode(object o, Object[]& fields)
public int GetHashCode()
public string ToString()
}
internal System.Variant : ValueType {
public short vt
public ushort wReserved1
public ushort wReserved2
public ushort wReserved3
public long llVal
public int lVal
public byte bVal
public short iVal
public float fltVal
public double dblVal
public short boolVal
public IntPtr bstrVal
public sbyte cVal
public ushort uiVal
public UInt32 ulVal
public ulong ullVal
public int intVal
public UInt32 uintVal
public IntPtr pdispVal
public BRECORD bRecord
public void SetValue(object obj)
public object GetValue()
public void Clear()
}
public System.Version : object {
private int UNDEFINED
private int _Major
private int _Minor
private int _Build
private int _Revision
public int Build
public int Major
public int Minor
public int Revision
public short MajorRevision
public short MinorRevision
public void .ctor(string version)
public void .ctor(int major, int minor)
public void .ctor(int major, int minor, int build)
public void .ctor(int major, int minor, int build, int revision)
private void CheckedSet(int defined, int major, int minor, int build, int revision)
public int get_Build()
public int get_Major()
public int get_Minor()
public int get_Revision()
public short get_MajorRevision()
public short get_MinorRevision()
public object Clone()
public int CompareTo(object version)
public bool Equals(object obj)
public int CompareTo(Version value)
public bool Equals(Version obj)
public int GetHashCode()
public string ToString()
public string ToString(int fieldCount)
internal Version CreateFromString(string info)
public bool op_Equality(Version v1, Version v2)
public bool op_Inequality(Version v1, Version v2)
public bool op_GreaterThan(Version v1, Version v2)
public bool op_GreaterThanOrEqual(Version v1, Version v2)
public bool op_LessThan(Version v1, Version v2)
public bool op_LessThanOrEqual(Version v1, Version v2)
}
public System.WeakReference : object {
private bool isLongReference
private GCHandle gcHandle
public bool IsAlive
public object Target
public bool TrackResurrection
public void .ctor(object target)
public void .ctor(object target, bool trackResurrection)
protected void .ctor(SerializationInfo info, StreamingContext context)
private void AllocateHandle(object target)
public bool get_IsAlive()
public object get_Target()
public void set_Target(object value)
public bool get_TrackResurrection()
protected void Finalize()
public void GetObjectData(SerializationInfo info, StreamingContext context)
}
internal System.WindowsConsoleDriver : object {
private IntPtr inputHandle
private IntPtr outputHandle
private short defaultAttribute
public ConsoleColor BackgroundColor
public int BufferHeight
public int BufferWidth
public bool CapsLock
public int CursorLeft
public int CursorSize
public int CursorTop
public bool CursorVisible
public ConsoleColor ForegroundColor
public bool KeyAvailable
public bool Initialized
public int LargestWindowHeight
public int LargestWindowWidth
public bool NumberLock
public string Title
public bool TreatControlCAsInput
public int WindowHeight
public int WindowLeft
public int WindowTop
public int WindowWidth
private ConsoleColor GetForeground(short attr)
private ConsoleColor GetBackground(short attr)
private short GetAttrForeground(int attr, ConsoleColor color)
private short GetAttrBackground(int attr, ConsoleColor color)
public ConsoleColor get_BackgroundColor()
public void set_BackgroundColor(ConsoleColor value)
public int get_BufferHeight()
public void set_BufferHeight(int value)
public int get_BufferWidth()
public void set_BufferWidth(int value)
public bool get_CapsLock()
public int get_CursorLeft()
public void set_CursorLeft(int value)
public int get_CursorSize()
public void set_CursorSize(int value)
public int get_CursorTop()
public void set_CursorTop(int value)
public bool get_CursorVisible()
public void set_CursorVisible(bool value)
public ConsoleColor get_ForegroundColor()
public void set_ForegroundColor(ConsoleColor value)
public bool get_KeyAvailable()
public bool get_Initialized()
public int get_LargestWindowHeight()
public int get_LargestWindowWidth()
public bool get_NumberLock()
public string get_Title()
public void set_Title(string value)
public bool get_TreatControlCAsInput()
public void set_TreatControlCAsInput(bool value)
public int get_WindowHeight()
public void set_WindowHeight(int value)
public int get_WindowLeft()
public void set_WindowLeft(int value)
public int get_WindowTop()
public void set_WindowTop(int value)
public int get_WindowWidth()
public void set_WindowWidth(int value)
public void Beep(int frequency, int duration)
public void Clear()
public void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor)
public void Init()
public string ReadLine()
public ConsoleKeyInfo ReadKey(bool intercept)
public void ResetColor()
public void SetBufferSize(int width, int height)
public void SetCursorPosition(int left, int top)
public void SetWindowPosition(int left, int top)
public void SetWindowSize(int width, int height)
private IntPtr GetStdHandle(Handles handle)
private void _Beep(int frequency, int duration)
private bool GetConsoleScreenBufferInfo(IntPtr handle, ConsoleScreenBufferInfo& info)
private bool FillConsoleOutputCharacter(IntPtr handle, char c, int size, Coord coord, Int32& written)
private bool FillConsoleOutputAttribute(IntPtr handle, short c, int size, Coord coord, Int32& written)
private bool SetConsoleCursorPosition(IntPtr handle, Coord coord)
private bool SetConsoleTextAttribute(IntPtr handle, short attribute)
private bool SetConsoleScreenBufferSize(IntPtr handle, Coord newSize)
private bool SetConsoleWindowInfo(IntPtr handle, bool absolute, SmallRect& rect)
private int GetConsoleTitle(StringBuilder sb, int size)
private bool SetConsoleTitle(string title)
private bool GetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info)
private bool SetConsoleCursorInfo(IntPtr handle, ConsoleCursorInfo& info)
private short GetKeyState(int virtKey)
private bool GetConsoleMode(IntPtr handle, Int32& mode)
private bool SetConsoleMode(IntPtr handle, int mode)
private bool PeekConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& eventsRead)
private bool ReadConsoleInput(IntPtr handle, InputRecord& record, int length, Int32& nread)
private Coord GetLargestConsoleWindowSize(IntPtr handle)
private bool ReadConsoleOutput(IntPtr handle, Void* buffer, Coord bsize, Coord bpos, SmallRect& region)
private bool WriteConsoleOutput(IntPtr handle, CharInfo[] buffer, Coord bsize, Coord bpos, SmallRect& region)
}
